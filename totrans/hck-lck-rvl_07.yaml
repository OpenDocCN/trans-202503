- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">DOCKER,
    ALEPH, AND MAKING DATASETS SEARCHABLE</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">DOCKER、ALEPH与使数据集可搜索</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: When I get my hands on a new dataset, the first thing I do is search it for
    any juicy, easy-to-find revelations. Depending on the dataset, I might look for
    politicians, organizations, or the city where I live. In the previous chapter,
    you learned to search text files like CSV or JSON files using <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>,
    but <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> won’t work on binary
    files like PDFs or Office documents. In this chapter, you’ll expand your search
    capabilities with Aleph, an open source investigation tool.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我获得一个新的数据集时，我做的第一件事就是搜索其中是否有任何有价值且易于发现的信息。根据数据集的不同，我可能会查找政治人物、组织或我所在的城市。在上一章中，你学习了如何使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>来搜索CSV或JSON文件这样的文本文件，但<samp
    class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>无法对像PDF或Office文档这样的二进制文件进行搜索。在本章中，你将通过Aleph这一开源调查工具，拓展你的搜索能力。
- en: Aleph is developed by the Organized Crime and Corruption Reporting Project,
    a group of investigative journalists largely based in eastern Europe and central
    Asia. The tool allows you to *index* datasets, extracting all the text they contain
    so they’re easy to search. You can use Aleph to search for keywords or *entities*
    (like people, companies, organizations, or addresses) and discover related entities
    in other datasets. Aleph also performs optical character recognition (OCR), which,
    as mentioned in [Chapter 1](chapter1.xhtml), takes flat images like scanned documents
    or screenshots, uses artificial intelligence to recognize any words, and converts
    those words into text that you can search or copy and paste.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Aleph是由“有组织犯罪与腐败报告项目”开发的，这个项目是一个主要基于东欧和中亚地区的调查记者团队。该工具允许你*索引*数据集，提取其中包含的所有文本，使其易于搜索。你可以使用Aleph搜索关键词或*实体*（例如人物、公司、组织或地址），并发现与其他数据集中的相关实体。Aleph还可以执行光学字符识别（OCR），正如在[第1章](chapter1.xhtml)中提到的，它将扫描文档或截图等平面图像，利用人工智能识别其中的文字，并将这些文字转换成可以搜索或复制粘贴的文本。
- en: In the first half of this chapter, you’ll learn the ins and outs of using Docker
    and Docker Compose, the software required for running Aleph. In the second half,
    you’ll use your new Docker skills to run an Aleph server, then index and search
    part of the BlueLeaks dataset.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前半部分，你将学习如何使用Docker和Docker Compose，这是运行Aleph所需的软件。在后半部分，你将运用新学的Docker技能来运行Aleph服务器，然后对BlueLeaks数据集的部分内容进行索引和搜索。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Introducing Docker and Linux Containers</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">介绍Docker和Linux容器</samp>
- en: Docker is the most popular software for running *Linux containers*, a type of
    software package. Linux containers can organize ready-to-go Linux software—complete
    with all of its dependencies, configuration, and source code—into a single bundle
    called a *container image* that you can quickly and easily run. The software inside
    containers is isolated from the rest of your computer; it can’t access any of
    those files unless you allow it to do so.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是运行*Linux容器*（一种软件包类型）最流行的软件。Linux容器可以将已经配置好的Linux软件——包括所有依赖项、配置和源代码——打包成一个叫做*容器镜像*的单一包，这样你就可以快速且轻松地运行它。容器中的软件与计算机的其他部分是隔离的；除非你允许，否则它不能访问任何文件。
- en: For example, let’s say you want to set up the popular WordPress blogging software
    in Linux. You use a package manager like apt to install the software WordPress
    depends on. You then put the WordPress source code in a location on your disk
    with the right permissions, configure your web server software so it knows where
    to look for that source code, and configure a database to store the blog’s data.
    You can then save all this work in a Linux container called <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    and reuse that container to spin up new WordPress sites with a single Docker command.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你想在Linux中设置流行的WordPress博客软件。你使用像apt这样的包管理器来安装WordPress所依赖的软件包。然后，你将WordPress的源代码放置在磁盘上的一个位置，并设置正确的权限，配置你的Web服务器软件，以便它知道在哪里查找源代码，并配置一个数据库来存储博客的数据。之后，你可以将这些工作保存到一个名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>的Linux容器中，并通过一个Docker命令重新使用该容器来启动新的WordPress站点。
- en: 'Because Linux containers are isolated from the rest of your computer, multiple
    WordPress containers can run at the same time without interfering with each other.
    If someone hacks the software running in your container, they won’t be able to
    access any of the data located elsewhere on your computer—at least, not without
    also hacking Docker itself. This is why Dangerzone relies on Linux containers:
    if a malicious document manages to hack the Dangerzone container you’re using,
    your computer should still be safe. In addition to software like WordPress, you
    can use Linux containers to run commands in most Linux distributions without having
    to install those operating systems.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Linux 容器与计算机其他部分是隔离的，所以多个 WordPress 容器可以同时运行而互不干扰。如果有人入侵了在容器中运行的软件，他们将无法访问存储在计算机其他地方的数据——至少，在没有黑入
    Docker 本身的情况下，是无法做到的。这就是为什么 Dangerzone 依赖于 Linux 容器：如果恶意文档成功入侵你正在使用的 Dangerzone
    容器，你的计算机应该依然是安全的。除了像 WordPress 这样的软件，你还可以使用 Linux 容器在大多数 Linux 发行版中运行命令，而无需安装这些操作系统。
- en: 'Docker comes with two commands you’ll use in this chapter: <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>,
    which runs individual containers, and <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp>,
    which lets you run multiple containers at once. You’ll practice using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">docker</samp> command by running Linux
    containers for the Ubuntu and Kali Linux operating systems, as well as for the
    data science software Jupyter Notebook. You’ll then use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp>
    to run a WordPress server and an Aleph server. Aleph requires a small network
    of services that communicate with each other, but as with WordPress, you can use
    a single Docker command to start up all these individual servers in their own
    containers. This process should prepare you to run Linux containers with Docker
    for other purposes later in the book.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 带有两个你将在本章中使用的命令：<samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>，用于运行单独的容器，以及
    <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp>，它让你可以同时运行多个容器。你将通过运行
    Ubuntu 和 Kali Linux 操作系统的 Linux 容器，以及数据科学软件 Jupyter Notebook 来练习使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>
    命令。然后，你将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp>
    来运行 WordPress 服务器和 Aleph 服务器。Aleph 需要一个小型的服务网络，它们相互通信，但和 WordPress 一样，你可以使用单个
    Docker 命令在各自的容器中启动所有这些独立的服务器。这个过程应该能帮助你为本书后续章节中使用 Docker 运行 Linux 容器做准备。
- en: 'This chapter covers two applications for running Docker containers: Docker
    Desktop and Docker Engine. Docker Desktop runs Docker containers on workstation
    computers in a Linux VM. Docker Engine, on the other hand, runs Docker directly
    on a Linux computer. Windows and Mac users, turn to Exercise 5-1 to set up Docker
    Desktop. Linux users, turn to Exercise 5-2 to install Docker Engine.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了两种用于运行 Docker 容器的应用程序：Docker Desktop 和 Docker Engine。Docker Desktop 在工作站计算机的
    Linux 虚拟机上运行 Docker 容器。而 Docker Engine 则直接在 Linux 计算机上运行 Docker。Windows 和 Mac
    用户请转到练习 5-1 来设置 Docker Desktop。Linux 用户请转到练习 5-2 来安装 Docker Engine。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*It’s possible for Linux users to install Docker Desktop, but I don’t recommend
    it for this chapter. Without a VM, Docker will be free to use all of your computer’s
    memory and processors, which will make indexing datasets in Aleph much faster.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*Linux 用户可以安装 Docker Desktop，但我不推荐在本章中使用它。没有虚拟机时，Docker 会自由地使用你计算机的所有内存和处理器，这将使
    Aleph 中的数据集索引速度大大加快。*'
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 5-1: Initialize Docker Desktop
    on Windows and macOS</samp>'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 5-1：在 Windows 和 macOS 上初始化 Docker
    Desktop</samp>
- en: When you installed Dangerzone in Exercise 1-3, Docker Desktop also should have
    been installed, since Dangerzone requires it. Confirm that Docker Desktop is installed
    by checking whether your *Applications* folder in macOS or Start menu in Windows
    has a Docker program; if not, download it from [*https://<wbr>www<wbr>.docker<wbr>.com<wbr>/products<wbr>/docker<wbr>-desktop<wbr>/*](https://www.docker.com/products/docker-desktop/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在练习 1-3 中安装 Dangerzone 时，Docker Desktop 应该也已安装，因为 Dangerzone 需要它。通过检查你的 macOS
    中的 *应用程序* 文件夹或 Windows 中的开始菜单是否有 Docker 程序来确认 Docker Desktop 是否已安装；如果没有，请从 [*https://<wbr>www<wbr>.docker<wbr>.com<wbr>/products<wbr>/docker<wbr>-desktop<wbr>/*](https://www.docker.com/products/docker-desktop/)
    下载。
- en: Open Docker and follow the onscreen instructions to initialize the software.
    You may need to reboot your computer. Docker Desktop’s Linux VM should be up and
    running before you can use Docker. If you click the Docker icon in your system
    tray and it tells you that Docker Desktop is running, you’re ready to proceed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Docker并按照屏幕上的说明初始化软件。您可能需要重新启动计算机。Docker Desktop的Linux虚拟机应已启动并运行，才能使用Docker。如果您点击系统托盘中的Docker图标并看到Docker
    Desktop正在运行，说明您可以继续操作。
- en: If you’re using Windows, you can use either PowerShell or Ubuntu with WSL for
    this chapter, since the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-desktop</samp> commands
    should run fine in either. Even when you use Docker from PowerShell, it technically
    relies on WSL under the hood.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Windows，可以使用PowerShell或Ubuntu与WSL来完成本章内容，因为<samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">docker-desktop</samp>命令在两者中都应该能正常运行。即使您在PowerShell中使用Docker，它本质上也依赖于后台的WSL。
- en: If you’re using macOS, click the Docker icon in your system tray and choose
    **Preferences**. Switch to the Resources tab and make sure that the Memory resource
    is set to at least 6GB—higher if you have more to spare—to be sure Docker’s Linux
    VM has enough memory to handle Aleph. Click **Apply & Restart**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是macOS，点击系统托盘中的Docker图标并选择**偏好设置**。切换到“资源”标签，确保内存资源至少设置为6GB——如果您的电脑有更多内存，可以设置得更高——确保Docker的Linux虚拟机有足够的内存来运行Aleph。点击**应用并重启**。
- en: 'For either operating system, to test whether Docker is working, open a terminal
    and run this command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任一操作系统，测试Docker是否正常工作，打开终端并运行以下命令：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command should run a Docker container image called <samp class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp>.
    If you don’t already have the <samp class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp>
    image on your computer, Docker should download it first. The output should look
    something like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应该运行一个名为<samp class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp>的Docker容器镜像。如果您的计算机上尚未有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp>镜像，Docker会先下载该镜像。输出应该类似于以下内容：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Your computer is ready to run Linux containers. Skip to the “Running Containers
    with Docker” section on page 123.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您的计算机已经准备好运行Linux容器。跳至第123页的“使用Docker运行容器”部分。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 5-2: Initialize Docker Engine
    on Linux</samp>'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 5-2：在Linux上初始化Docker Engine</samp>
- en: Follow the detailed instructions for Server rather than Desktop at [*https://<wbr>docs<wbr>.docker<wbr>.com<wbr>/engine<wbr>/install<wbr>/*](https://docs.docker.com/engine/install/)
    to install Docker Engine for your version of Linux. In Ubuntu, the installation
    process involves adding a new apt repository to your computer and installing some
    Docker packages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照[*https://<wbr>docs<wbr>.docker<wbr>.com<wbr>/engine<wbr>/install<wbr>/*](https://docs.docker.com/engine/install/)中的详细说明安装适用于您版本的Linux的Docker
    Engine。在Ubuntu中，安装过程包括将一个新的apt源添加到您的计算机中并安装一些Docker软件包。
- en: Docker Engine on Linux requires root access to run containers. After completing
    this exercise, if you’re using Linux, add <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp>
    to the beginning of all <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp> commands
    in this book. To run all your Docker commands as root automatically without using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp>, check the Docker Engine
    documentation for instructions on adding your Linux user to the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>
    group; however, keep in mind that doing so decreases your computer’s security
    and isn’t recommended.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上运行Docker Engine需要root权限。完成此练习后，如果您使用的是Linux，请在本书中所有的<samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp>命令前添加<samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp>。要使所有Docker命令都自动以root身份运行而无需使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp>，请查阅Docker Engine文档，了解如何将Linux用户添加到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>组中；但请注意，这样做会降低计算机的安全性，不建议这么做。
- en: 'Once Docker is installed, open a terminal and run:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Docker后，打开终端并运行：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This command runs a Docker container image called <samp class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp>.
    If you don’t already have the <samp class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp>
    image on your computer, Docker downloads it first. The output should look something
    like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令运行一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp>
    的Docker容器镜像。如果你的计算机上还没有 <samp class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp>
    镜像，Docker将首先下载它。输出结果应该类似于以下内容：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If the <samp class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp> container
    ran successfully, you can now use the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>
    command on your computer. Next, run the following command to install the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp> package, which will
    give you access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp>
    command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp> 容器成功运行，你现在可以在计算机上使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp> 命令。接下来，运行以下命令来安装 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp> 包，这将使你能够使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp> 命令：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Your computer is now ready to run Linux containers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你的计算机现在已经准备好运行Linux容器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Running Containers with Docker</samp>
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用Docker运行容器</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp> command you’ve
    just installed allows you to run Linux containers on your computer. In this section
    you’ll learn how to use this command to open a shell inside containers, force
    running containers to quit, mount volumes to save persistent data or access certain
    files, set environment variables, and publish ports so your computer can connect
    to network services inside your container. This foundational understanding of
    Docker will prepare you to run Docker containers in Exercise 5-3 and help you
    troubleshoot any problems you later encounter with Aleph.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚安装的 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp> 命令允许你在计算机上运行Linux容器。在本节中，你将学习如何使用这个命令在容器内打开Shell、强制运行中的容器退出、挂载卷以保存持久数据或访问特定文件、设置环境变量，以及发布端口，使你的计算机能够连接到容器内的网络服务。对Docker的这一基础理解将帮助你在第5-3章运行Docker容器，并帮助你排查以后与Aleph相关的任何问题。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*For additional information on Docker commands, run* <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">docker
    help</samp> *or check the documentation at* [https://docs.docker.com](https://docs.docker.com)*.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关Docker命令的更多信息，请运行* <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">docker
    help</samp> *或查看文档* [https://docs.docker.com](https://docs.docker.com)*。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running an Ubuntu
    Container</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">运行Ubuntu容器</samp>
- en: You’ll begin by learning how to run a Linux container with the Ubuntu operating
    system in it. People often base more complicated container images on the Ubuntu
    container image to access all Ubuntu software that apt can install. An Ubuntu
    container is also a convenient way to access a shell on a clean Ubuntu system,
    allowing you to install software or test programs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从学习如何运行一个包含Ubuntu操作系统的Linux容器开始。人们通常在Ubuntu容器镜像的基础上构建更复杂的容器镜像，以便访问apt可以安装的所有Ubuntu软件。Ubuntu容器也是一种方便的方式来访问一个干净的Ubuntu系统上的Shell，允许你安装软件或测试程序。
- en: 'Docker commands use the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">command</samp> syntax.
    Run the following to start your own Ubuntu container (if you’re using Linux, remember
    to add <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp>):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Docker命令使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">命令</samp> 语法。运行以下命令来启动你自己的Ubuntu容器（如果你使用的是Linux，请记得加上
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp>）：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command runs <samp class="SANS_TheSansMonoCd_W5Regular_11">ubuntu:latest</samp>,
    the latest version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ubuntu</samp>
    image. If that image isn’t already on your computer, Docker automatically downloads
    it from Docker Hub, a library of public container images at [*https://<wbr>hub<wbr>.docker<wbr>.com*](https://hub.docker.com).
    Next, the <samp class="SANS_TheSansMonoCd_W5Regular_11">bash</samp> command runs,
    giving you shell access inside that container. Include the <samp class="SANS_TheSansMonoCd_W5Regular_11">-it</samp>
    argument, which is short for <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp>
    (or <samp class="SANS_TheSansMonoCd_W5Regular_11">--interactive</samp>) and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-t</samp> (or <samp class="SANS_TheSansMonoCd_W5Regular_11">--tty</samp>),
    after <samp class="SANS_TheSansMonoCd_W5Regular_11">docker run</samp> whenever
    you plan to open a shell in a container, so that any commands you type in the
    terminal run in the container. Without the <samp class="SANS_TheSansMonoCd_W5Regular_11">-it</samp>
    argument, the bash shell would immediately quit before you could run any commands,
    as would the container.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令运行<samp class="SANS_TheSansMonoCd_W5Regular_11">ubuntu:latest</samp>，即最新版本的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ubuntu</samp>镜像。如果该镜像尚未存在于你的计算机中，Docker会自动从Docker
    Hub下载该镜像，Docker Hub是一个公开容器镜像库，网址是[*https://<wbr>hub<wbr>.docker<wbr>.com*](https://hub.docker.com)。接下来，运行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">bash</samp>命令，为你提供容器内部的shell访问权限。在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">docker run</samp>后加上<samp class="SANS_TheSansMonoCd_W5Regular_11">-it</samp>参数，它是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-i</samp>（或<samp class="SANS_TheSansMonoCd_W5Regular_11">--interactive</samp>）和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-t</samp>（或<samp class="SANS_TheSansMonoCd_W5Regular_11">--tty</samp>）的缩写，当你计划在容器内打开shell时使用该参数，这样你在终端中输入的任何命令都会在容器内运行。如果没有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-it</samp>参数，bash shell会在你运行任何命令之前立刻退出，容器也会退出。
- en: 'This command gives me the following output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令给我以下输出：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since I didn’t already have the <samp class="SANS_TheSansMonoCd_W5Regular_11">ubuntu:latest</samp>
    image, the command downloaded that image, started the container, and dropped me
    into a bash shell. I can now run whatever commands I want inside this container,
    such as installing software or running programs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我之前没有安装<samp class="SANS_TheSansMonoCd_W5Regular_11">ubuntu:latest</samp>镜像，命令下载了该镜像，启动了容器，并进入了bash
    shell。我现在可以在这个容器内运行任何命令，例如安装软件或运行程序。
- en: 'Running the <samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp> command
    quits the container. If you start a new <samp class="SANS_TheSansMonoCd_W5Regular_11">ubuntu:latest</samp>
    container, it contains none of the old container’s data. For example, with the
    following commands, I create a file called *test.txt* in one container, quit the
    container, and start a new one:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 运行<samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp>命令退出容器。如果你启动一个新的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ubuntu:latest</samp>容器，它将不包含旧容器的任何数据。例如，使用以下命令，我在一个容器中创建了一个名为*test.txt*的文件，然后退出了该容器，接着启动了一个新的容器：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The output shows that *test.txt* no longer exists. For data in a container to
    persist when you rerun the container image, you need to use volumes, as we’ll
    discuss in “Mounting and Removing Volumes” on page 125.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示*test.txt*文件不再存在。为了让容器中的数据在重新运行容器镜像时得以保存，你需要使用卷，具体内容我们将在第125页的《挂载和移除卷》中讨论。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Listing and Killing
    Containers</samp>
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">列出和终止容器</samp>
- en: 'If you’ve exited your Ubuntu container, run a new one. With that container
    running in the background, open a second terminal window and run the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker
    ps</samp> command. This should show you a list of all containers currently running.
    Here’s the output I get, for example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经退出了Ubuntu容器，运行一个新的容器。该容器在后台运行时，打开第二个终端窗口，运行<samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker
    ps</samp>命令。这个命令将显示当前所有正在运行的容器列表。以下是我得到的输出示例：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When you start a container with <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    run</samp>, you can give it a name with the arguments <samp class="SANS_TheSansMonoCd_W5Regular_11">--name</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">your_container_name</samp>.
    Otherwise, it will be assigned a random name. The container in my <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    ps</samp> output is called <samp class="SANS_TheSansMonoCd_W5Regular_11">epic_borg</samp>.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker run</samp> 启动一个容器时，你可以通过参数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--name</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">your_container_name</samp>
    给它命名。否则，它将被分配一个随机名称。我的 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker ps</samp>
    输出中的容器名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">epic_borg</samp>。
- en: 'To *kill* a container, or force it to quit, you run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    kill</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">container_name</samp>.
    For example, running the following command in my other terminal window quits my
    <samp class="SANS_TheSansMonoCd_W5Regular_11">epic_borg</samp> container:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要*杀死*一个容器，或者强制它退出，你可以运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    kill</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">container_name</samp>。例如，在我的另一个终端窗口中运行以下命令可以退出我的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">epic_borg</samp> 容器：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run this command for your own container. If you switch back to your other terminal
    window, the container should have quit, and you should be back in your normal
    shell.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的容器运行这个命令。如果你切换回另一个终端窗口，容器应该已经退出，并且你应该回到正常的 shell 中。
- en: 'When you exit a container, Docker still keeps track of it, allowing you to
    restart it if you want. To see all of the containers Docker is tracking, including
    ones that aren’t running anymore, you run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker
    ps -a</samp> (short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--all</samp>).
    Here’s the output I get when I run this command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你退出一个容器时，Docker 仍然会追踪它，允许你在需要时重新启动它。要查看 Docker 追踪的所有容器，包括那些已经不再运行的容器，你可以运行
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker ps -a</samp>（即 <samp class="SANS_TheSansMonoCd_W5Regular_11">--all</samp>
    的简写）。以下是我运行此命令时的输出：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It’s good practice to run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker
    rm</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">container_name</samp>
    to prune your stopped Docker containers when you’re done using them. For example,
    I’d run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker rm nostalgic_keldysh</samp>
    to remove my <samp class="SANS_TheSansMonoCd_W5Regular_11">nostalgic_keldysh</samp>
    container.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker rm</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">container_name</samp>
    来修剪你停止的 Docker 容器是一种好习惯，当你完成使用它们时。举个例子，我会运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    rm nostalgic_keldysh</samp> 来删除我的 <samp class="SANS_TheSansMonoCd_W5Regular_11">nostalgic_keldysh</samp>
    容器。
- en: 'You can run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker container prune</samp>
    to remove all stopped containers at once. When I ran this command, I saw the following
    output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker container prune</samp>
    来一次性删除所有停止的容器。当我运行这个命令时，我看到了以下输出：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'I entered <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> and got the
    following output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我输入了 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 并得到了以下输出：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This displays the container ID, a long string of random-looking text, for each
    container that’s deleted. In my case, I deleted a single container.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这会显示每个已删除容器的容器 ID，一长串看起来随机的文本。在我的例子中，我删除了一个容器。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Mounting and Removing
    Volumes</samp>
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">挂载和移除卷</samp>
- en: Containers support *volumes*, which you can think of as folders in your container
    designed to store persistent data. You can use volumes to save changes you’ve
    made to your container after you quit and remove it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 容器支持*卷*，你可以把它们看作是容器中的文件夹，用于存储持久化数据。你可以使用卷来保存你在退出并删除容器后所做的更改。
- en: For example, suppose you start a container without any volumes that runs the
    PostgreSQL database software. Any data you add to it is saved to the */var/lib/postgresql/data*
    folder inside your container. When you quit and remove the container, you’ll lose
    all of your data. If you instead *mount* a folder on your host operating system
    into */var/lib/postgresql/data* on the container, when software in the container
    accesses that folder, it’s actually accessing the folder on your host operating
    system. You’ll still have all of your data when the container closes and is removed,
    and you can start the container again in the future with the same data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你启动了一个没有任何卷的容器，并且运行 PostgreSQL 数据库软件。你添加到容器中的任何数据都会保存在容器内的*/var/lib/postgresql/data*文件夹中。当你退出并移除容器时，所有数据都会丢失。如果你将主机操作系统中的一个文件夹*挂载*到容器中的*/var/lib/postgresql/data*，那么当容器中的软件访问该文件夹时，实际上是在访问主机操作系统中的文件夹。容器关闭并移除后，你仍然可以保留所有数据，未来你可以使用相同的数据重新启动容器。
- en: 'Docker has two main types of volumes: *bind mounts*, or folders from your host
    machine mounted into a container, and normal Docker volumes, where Docker keeps
    track of your persistent folders without your having to provide a path on your
    host operating system. For example, if you want to store your database container’s
    data in the */Volumes/datasets/volumes/db-data* folder on your host filesystem,
    you would mount this folder as a bind mount. If you don’t need your data to be
    stored in a specific folder on your host, just use a normal volume, and Docker
    will keep track of where it’s stored.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 有两种主要的卷类型：*绑定挂载*，即将主机机器上的文件夹挂载到容器中，以及普通 Docker 卷，其中 Docker 会跟踪你的持久化文件夹，而你无需提供主机操作系统中的路径。例如，如果你想将数据库容器的数据存储在主机文件系统中的*/Volumes/datasets/volumes/db-data*文件夹中，你将把这个文件夹作为绑定挂载。如果你不需要将数据存储在主机上的特定文件夹中，只需使用普通卷，Docker
    会自动跟踪数据存储的位置。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Storing volumes in a Linux VM with Docker Desktop makes them faster than bind
    mounts, but your VM might run out of disk space if your volumes get too big (if
    you index large datasets into Aleph, for example). In macOS, you can increase
    the amount of disk space available to your VM in the Docker Desktop preferences
    under the Resources tab. In Windows, your VM will use as much space on the* C:
    *drive as it needs, but again, this drive could run out of disk space if you’re
    dealing with large amounts of data. Alternatively, you could use bind mounts instead
    of volumes, storing data on external disks.*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*将卷存储在带有 Docker Desktop 的 Linux 虚拟机中比绑定挂载更快，但如果你的卷变得太大（例如，如果你将大型数据集索引到 Aleph
    中），虚拟机可能会用完磁盘空间。在 macOS 中，你可以通过 Docker Desktop 偏好设置中的资源选项卡增加虚拟机可用的磁盘空间。在 Windows
    中，虚拟机会使用 C: 盘上需要的空间，但如果处理大量数据，该驱动器也可能会用完磁盘空间。另一种选择是使用绑定挂载，而不是卷，将数据存储在外部磁盘上。*'
- en: You can also use volumes to access data outside of a container while that container
    is running. In Exercise 5-5, you’ll bind-mount your *datasets* USB disk as a folder
    in an Aleph container. This way, your container can access the BlueLeaks dataset,
    allowing you to index it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在容器运行时使用卷来访问容器外部的数据。在练习 5-5 中，你将把你的*datasets* USB 磁盘绑定挂载为 Aleph 容器中的一个文件夹。这样，容器就可以访问
    BlueLeaks 数据集，从而进行索引。
- en: 'Use this command to start a container with a volume:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令启动带有卷的容器：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use this command to start a container with a bind mount:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令启动带有绑定挂载的容器：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">--mount</samp> argument tells
    Docker that you’re going to mount a volume and is followed by comma-separated
    details about that volume. The <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    parameter specifies the type of mount: <samp class="SANS_TheSansMonoCd_W5Regular_11">volume</samp>
    for volumes and <samp class="SANS_TheSansMonoCd_W5Regular_11">bind</samp> for
    bind mounts. The <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> parameter
    specifies the source of the volume or bind mount. For volumes, its value is the
    volume name; for bind mounts, its value is the absolute path on your host filesystem
    to the folder you want to mount. The <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    parameter specifies the destination of the volume or bind mount, in both cases
    the absolute path of the folder inside the container to which you’re mounting.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">--mount</samp> 参数告诉 Docker 你将挂载一个卷，后面跟着有关该卷的以逗号分隔的详细信息。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">type</samp> 参数指定挂载类型：对于卷是 <samp class="SANS_TheSansMonoCd_W5Regular_11">volume</samp>，对于绑定挂载是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">bind</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    参数指定卷或绑定挂载的源。对于卷，它的值是卷名；对于绑定挂载，它的值是主机文件系统中你想挂载的文件夹的绝对路径。<samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    参数指定卷或绑定挂载的目标，在两种情况下，它都是容器内你要挂载的文件夹的绝对路径。
- en: 'Let’s practice these two commands, starting with mounting a volume. Run the
    following code (your prompt will be different from mine):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们练习这两个命令，从挂载一个卷开始。运行以下代码（你的提示符与我的会有所不同）：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code starts an Ubuntu container and mounts a volume called <samp class="SANS_TheSansMonoCd_W5Regular_11">test-data</samp>
    into the */mnt* folder in the container. It then saves some data into the */mnt/test.txt*
    file and exits the container.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码启动一个 Ubuntu 容器，并将一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">test-data</samp>
    的卷挂载到容器中的 */mnt* 文件夹。然后，它将一些数据保存到 */mnt/test.txt* 文件中，并退出容器。
- en: 'Use the following commands to open a separate container, mounting the same
    volume into it to see whether your data is still there (again, your command prompt
    will be different):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令打开一个单独的容器，将相同的卷挂载到其中，看看你的数据是否仍然存在（再次提醒，你的命令提示符会不同）：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, because you mounted */mnt* in the <samp class="SANS_TheSansMonoCd_W5Regular_11">test-data</samp>
    volume, the data persisted.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，由于你在 <samp class="SANS_TheSansMonoCd_W5Regular_11">test-data</samp> 卷中挂载了
    */mnt*，数据得以持久化。
- en: 'To see a list of the volumes that Docker is managing, run the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker
    volume ls</samp> command. You should get the following output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Docker 管理的卷列表，运行 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker volume
    ls</samp> 命令。你应该看到以下输出：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can remove volumes only from containers that have been completely removed
    from Docker. If you’ve just stopped a container but Docker is still tracking it,
    it won’t let you remove the volume. Completely remove all stopped containers by
    running <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker container prune</samp>,
    which then allows you to remove any volumes attached to those containers. You
    should get the following output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能从已经完全从 Docker 中删除的容器中删除卷。如果你刚刚停止了一个容器，但 Docker 仍在跟踪它，它将不允许你删除该卷。通过运行 <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">docker container prune</samp> 完全删除所有停止的容器，然后你可以删除附加到这些容器的任何卷。你应该看到以下输出：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">y</samp> to continue:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">y</samp> 继续：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can now run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker volume rm</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">volume-name</samp> to remove
    any volumes attached to those containers, or run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker
    volume prune</samp> to delete all volumes that Docker containers aren’t currently
    using. Run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker volume rm test-data</samp>
    to remove the <samp class="SANS_TheSansMonoCd_W5Regular_11">test-data</samp> volume,
    then run the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker volume ls</samp>
    command again. This time, you shouldn’t see any volumes listed in the output.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以运行 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker volume rm</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">volume-name</samp> 来删除附加到这些容器的任何卷，或者运行
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker volume prune</samp> 来删除 Docker
    容器当前未使用的所有卷。运行 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker volume rm test-data</samp>
    来删除 <samp class="SANS_TheSansMonoCd_W5Regular_11">test-data</samp> 卷，然后再次运行 <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">docker volume ls</samp> 命令。这次，你不应该在输出中看到任何列出的卷。
- en: Next, you’ll practice bind mounting by mounting the folder on your host system
    containing the BlueLeaks dataset into a container running Kali Linux. This Linux
    distribution is designed for *penetration testing*, in which people hack into
    systems with permission from the system owners to find and fix security flaws.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re a Mac or Linux user, run the following command, replacing the path
    with the appropriate path on your machine:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This should run a <samp class="SANS_TheSansMonoCd_W5Regular_11">kalilinux/kali-rolling</samp>
    container, mounting your *BlueLeaks-extracted* folder in it at the path */blueleaks*,
    and drop you into a bash shell.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Windows users might have trouble bind-mounting a folder on the *datasets* USB
    disk into a container, because Docker Desktop for Windows runs Linux containers
    using WSL, and WSL doesn’t always have access to your USB disks. To avoid this
    problem, if you plugged in your USB disk after opening a WSL terminal or using
    Docker, restart WSL by running <samp class="SANS_TheSansMonoCd_W7Bold_B_11">wsl
    --shutdown</samp> in PowerShell. You should see a notification from Docker Desktop
    asking if you want to restart it. Click **Restart**. After you restart WSL with
    the USB disk already plugged in, Docker should be able to mount it. (See Appendix
    A for more information.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re using Windows with PowerShell to work through this chapter, run the
    following command to mount the folder that contains the BlueLeaks data into */datasets*,
    replacing <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">D:/BlueLeaks-extracted</samp>
    with the appropriate path:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you’re using Ubuntu with WSL in Windows, mount the *BlueLeaks* folder by
    accessing the *D:* drive from */mnt/d* with the following syntax:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'From within your Kali container, you can now use the tools that come with Kali
    on the BlueLeaks dataset. By default, Kali customizes your bash shell to look
    slightly different than Ubuntu does. The prompt will look something like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Docker containers are assigned random hostnames. In this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">root</samp>
    is the name of the current user, <samp class="SANS_TheSansMonoCd_W5Regular_11">6a36e316663c</samp>
    is the hostname of the computer, and <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>
    is the current working directory. From here, run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls
    /blueleaks/</samp> to list the files in the *BlueLeaks* folder:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can learn more about volumes and bind mounts at* [https://<wbr>docs<wbr>.docker<wbr>.com<wbr>/storage<wbr>/](https://docs.docker.com/storage/).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Passing Environment
    Variables</samp>
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also use environment variables, introduced in [Chapter 4](chapter4.xhtml),
    to pass sensitive information like database credentials into containers. When
    starting up a container, you pass an environment variable into it using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-e</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">variable_name</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">value</samp>
    (the <samp class="SANS_TheSansMonoCd_W5Regular_11">-e</samp> is short for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">--env</samp>) arguments. Programs in the
    container can then access the value of that variable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, run the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This starts an Ubuntu container with the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">DB_USER</samp>
    set to <samp class="SANS_TheSansMonoCd_W5Regular_11">root</samp> and the variable
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DB_PASSWORD</samp> set to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">yourefired</samp>. From inside the container,
    try displaying the values of those variables to confirm that you can access this
    information there, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">echo
    $</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">variable_name</samp>
    command like so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You’ll practice passing environment variables to containers further in Exercise
    5-3.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running Server Software</samp>
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also run robust, fully configured software on the operating systems
    running in containers. This technique is mostly used to access *server software*,
    software to which you can connect over a network using web browsers, database
    clients, or other similar programs. You’ll need this skill for Exercise 5-3 and,
    eventually, to run Aleph.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Different computers (or VMs, or containers), called *hosts*, are identified
    by IP addresses or hostnames. Your own computer’s IP address is always 127.0.0.1,
    and its hostname is always *localhost*. Hosts can listen on different ports for
    incoming network connections, meaning the host is available for other hosts to
    connect to over a network. A *port* is a number that the computer uses to sort
    out which network traffic should go to which application.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Different services have different default ports. For example, HTTP and HTTPS
    services are two types of websites that use port 80 and port 443, respectively.
    When you load the URL *http://<wbr>example<wbr>.com* in your browser, it will
    try to connect to the host *example.com* on port 80 using HTTP. If you load *https://<wbr>example<wbr>.com*,
    it will try to connect on port 443 using HTTPS.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: However, you can change the default ports that services use. If you’re running
    an HTTP service on *localhost* on port 5000, the URL for that service would be
    *http://<wbr>localhost:5000*, where *http://<wbr>* means you’re using the HTTP
    protocol, *localhost* means you’re connecting to the *localhost* host, and *:5000*
    means you’re connecting to port 5000 instead of the default HTTP port, 80.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: To connect to a network port inside your Docker container, you must *publish*
    a network port when you run your container, making that port available on the
    host operating system. To do so, use the arguments <samp class="SANS_TheSansMonoCd_W5Regular_11">-p</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">host_port</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">container_port</samp> (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-p</samp> is short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--publish</samp>).
    Once the container starts up, your host operating system will listen on <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">host_port</samp>. If you connect
    to that port, your connection will be forwarded to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">container_port</samp>
    inside the container.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of running server software and publishing a port so
    that you can connect to it from your host computer. Run the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This command should download and run the latest version of the *jupyter/scipy-notebook*
    container image, which includes the most popular science-related Python libraries.
    (Jupyter Notebook is a powerful data science tool for creating and sharing computational
    documents.) Jupyter Notebook starts an HTTP service on port 8888 in the container.
    The arguments <samp class="SANS_TheSansMonoCd_W5Regular_11">-p 8000:8888</samp>
    mean that <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">host_port</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">8000</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">container_port</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">8888</samp>. If you connect to
    *localhost* on port 8000, using either the URL *http://<wbr>localhost:8000* or
    *http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:8000*, you’ll now actually connect to port
    8888 inside the container.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output from the previous command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The output shows that this command downloaded the latest version of the *jupyter/scipy-notebook*
    container image from Docker Hub and then ran it. This time, instead of starting
    a shell in the container, the container runs only the service it was designed
    for, which is Jupyter Notebook. Each time Jupyter Notebook outputs a log message,
    the terminal window now displays it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The end of the output shows three different URLs to access the server. Copy
    the final URL, paste it in your browser, and change the port number from 8888
    to 8000 before you load it. When you connect to your own computer on port 8000
    (127.0.0.1:8000), your connection will be forwarded to the container on port 8888\.
    Your browser should load the Jupyter Notebook service running in your container.
    When this happens, you should see more log messages appear in the terminal.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-1](#fig5-1) shows a web browser running on my Mac, connected to a
    Jupyter Notebook server, which is running in my Linux container.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a web browser loading Jupyter Notebook running in a container.
    The open document shows a snippet of Python code that was run.](Images/Figure5-1.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: Jupyter Notebook
    running in a container</samp>'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The container keeps running until you press CTRL-C to quit it. If you need to
    run any other terminal commands while the container is still running, you’ll need
    to open a separate terminal window. For now, press CTRL-C in your terminal to
    exit the Jupyter Notebook container.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: You won’t use Jupyter Notebook further in this book, but you’ll rely on your
    new understanding of running server software to run a WordPress website in Exercise
    5-3.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For more information about Jupyter Notebook, visit* [https://jupyter.org](https://jupyter.org)*,*
    *and for thorough documentation on running Jupyter Notebook in Docker, see* [https://jupyter-docker-stacks.readthedocs.io](https://jupyter-docker-stacks.readthedocs.io)*.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Freeing Up Disk Space</samp>
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Docker images take up a lot of disk space. To free up space quickly, use the
    following command to delete all of the container images you’ve downloaded from
    Docker Hub and other data that Docker stores (besides volumes):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since this command doesn’t delete volumes, it won’t delete any of your important
    data. The next time you use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    run</samp> commands, you’ll just redownload the container images you need from
    Docker Hub.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 5-3: Run a WordPress Site
    with</samp> <samp class="SANS_Futura_Std_Heavy_B_21">Docker Compose</samp>'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More complicated software like Aleph requires running multiple containers that
    interact with each other. To do that, you’ll need to learn to use Docker Compose,
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker run</samp> command’s
    arguments quickly become hard to keep track of when used to run more complicated
    containers—those with volumes, environment variables, publishing ports, and so
    on. It’s especially unwieldy to run a single application that requires multiple
    containers at once.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose makes it easier to define and run such Docker applications. The
    tool allows you to configure your containers (choosing images, volumes, environment
    variables, published ports, and so on) in a single file, and to start and stop
    all of your containers with a single command. I often use Docker Compose even
    for software that requires a single container, because it simplifies keeping track
    of all of the configuration. You’ll need to be proficient in Docker Compose to
    run an Aleph server.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you’ll familiarize yourself with Docker Compose by using it
    to run WordPress. You won’t need WordPress for the remainder of this book, but
    here it serves as an example to prepare you for using Docker Compose with Aleph.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Make a docker-compose.yaml
    File</samp>
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The YAML file format ([*https://<wbr>yaml<wbr>.org*](https://yaml.org)) is popular
    among programmers for storing configuration files because it’s relatively human-readable.
    YAML files have either a *.yml* or *.yaml* file extension. Docker Compose defines
    containers and their settings in a file called *docker-compose.yaml*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal and change to your *exercises* folder. Make a new folder called
    *wordpress* for this exercise and then, using your text editor, make a file in
    that folder called *docker-compose.yaml*. Enter the following code into *that*
    file (or copy and paste it from [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-5<wbr>/wordpress<wbr>/docker<wbr>-compose<wbr>.yaml*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-5/wordpress/docker-compose.yaml)):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: YAML files are whitespace sensitive, meaning that indentations affect the meaning
    of the code. This file defines two containers named <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>. For each container,
    it defines which container image to use, what volumes to mount, which ports to
    publish (in the case of the <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    container), which environment variables to set, and other settings.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp> container
    uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress:latest</samp>
    image to create an instance of the WordPress web application. The <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>
    container uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">mariadb:10.9</samp>
    container image to create an instance of a MySQL database server. (MySQL is a
    popular data management system that you’ll learn more about in [Chapter 12](chapter12.xhtml).)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Because these two containers are defined in the same *docker-compose.yaml* file,
    by default they’re part of the same Docker network so that they can communicate
    with each other. The <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    container sets <samp class="SANS_TheSansMonoCd_W5Regular_11">WORDPRESS_DB_HOST</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>, the name of the other
    container, because it connects to that hostname. The <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    environment variables ❶ also match the <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>
    environment variables ❷. If these database credentials aren’t the same, WordPress
    gets a “permission denied” error when trying to connect to the database.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The WordPress* docker-compose.yaml *file in this example is a slightly modified
    version of a sample file in the Docker documentation at* [https://docs.docker.com/samples/wordpress/](https://docs.docker.com/samples/wordpress/)*.*
    *See the documentation for a more thorough description of how to use Docker Compose.*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Start Your WordPress
    Site</samp>
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In your terminal, change to the folder you created for this exercise and run
    the following command to start both containers at the same time:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first time you run it, Docker should download the <samp class="SANS_TheSansMonoCd_W5Regular_11">mariadb:10.9</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress:latest</samp> container
    images from Docker Hub. The command should then run a MySQL container and a web
    server container running WordPress, and you should see logs from both containers
    scroll by in your terminal. Logs from the <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>
    container start with <samp class="SANS_TheSansMonoCd_W5Regular_11">db_1</samp>,
    while logs from the <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    container start with <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress_1</samp>.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp> container doesn’t
    need to publish any ports for WordPress to connect to it, since both containers
    share a Docker network. However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    container publishes ports 8000:80\. This means that loading *http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:8000*
    in your browser connects to your host operating system on port 8000 and loads
    the web server in the <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    container running on port 80.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Enter ***http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:8000*** in your browser, and you’re
    running WordPress! [Figure 5-2](#fig5-2) shows the WordPress installation process
    that appears when I load that URL on my Mac after selecting English as my language.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a web browser loading WordPress running in a container. It
    shows the installation screen where the user sets a website title, a username,
    and a password.](Images/Figure5-2.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-2: WordPress running
    in two containers with Docker Compose</samp>'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Fill out the form with your WordPress site’s title, a username, and a password,
    and then explore your new WordPress site.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'To open a shell and run commands in an active container with Docker Compose,
    you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose exec</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">container_name command</samp>
    syntax. For example, this is how you’d get a shell in the <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    container:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: While <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose run</samp>
    starts a new container, <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose
    exec</samp> runs a command in an active container—a little like opening a new
    terminal window inside a running container.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Exit the shell when you are done. Back in the terminal running <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    -compose up</samp>, press CTRL-C to shut down the containers. Now you’re ready
    to use your new Docker and Docker Compose skills to make your datasets searchable
    with Aleph.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Introducing Aleph</samp>
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Truth cannot penetrate a closed mind. If all places in the universe are in
    the Aleph, then all stars, all lamps, all sources of light are in it, too.*'
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Jorge Luis Borges, “The Aleph”
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Organized Crime and Corruption Reporting Project (OCCRP), founded in 2006,
    has a history of publishing high-profile investigations into corruption, often
    leading to criminal investigations, arrests, and seizure of stolen funds. In partnership
    with dozens of newsrooms around the world, the group relies on large datasets
    for its investigations. For example, OCCRP, along with the International Consortium
    of Investigative Journalists (ICIJ), was part of a coalition investigating the
    Panama Papers, an offshore tax haven dataset that led to over 40 stories about
    corruption. One of those stories implicated a close friend of Vladimir Putin who
    had embezzled $230 million from Russian taxpayers. Because OCCRP deals with so
    much data, it developed Aleph as an investigation tool to make it easier to track
    white-collar crime, follow the money, and cross-reference various datasets.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'OCCRP runs an Aleph server available to the public at [*https://<wbr>data<wbr>.occrp<wbr>.org*](https://data.occrp.org).
    This server includes over 250 public datasets with documents from 139 different
    countries and territories. While there’s some overlap with datasets published
    by DDoSecrets, most public datasets in OCCRP’s Aleph server are different. Many
    of them are regularly updated datasets of public records: registries of company
    ownership around the world, lists of people and organizations facing international
    sanctions, and court records. These datasets might not seem exciting on their
    own, but when your investigation leads you to a specific person or company, they
    can be crucial for helping you fill in the gaps. OCCRP’s Aleph server also contains
    many more private datasets, which are available to journalists who apply for access.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Take some time to check out OCCRP’s Aleph server, explore which public datasets
    are available, and make some searches. For example, if you search for Rudy Giuliani
    (Donald Trump’s confidant and former lawyer, and the former mayor of New York
    City) and filter by the US Federal Courts Archive dataset, you’ll find a series
    of court documents that reference Giuliani.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'You can upload your own datasets to OCCRP’s Aleph server only if OCCRP makes
    an account for you. Even if you do have an account, you won’t be able to upload
    medium- or high-security datasets without sharing this data with a third party:
    OCCRP. That’s why I help run a private Aleph server for The Intercept. You won’t
    use OCCRP’s public Aleph server further in this book. Instead, in Exercise 5-4,
    you’ll run a small Aleph server and bring up Aleph containers on your own laptop.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 5-4: Run Aleph Locally in
    Linux Containers</samp>'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This exercise prepares you to run your own server directly on your computer
    with Docker Compose. Instead of accessing Aleph at [*https://<wbr>data<wbr>.occrp<wbr>.org*](https://data.occrp.org),
    you’ll bring up your Aleph containers and access your private server at *http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:8080*.
    You’ll use Docker Compose to run the many different services Aleph requires on
    your computer with a single command.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Make a new folder called *aleph* to use for this exercise and the next. Save
    a copy of *docker-compose.yml* and *aleph.env.tmpl* from Aleph’s git repo, located
    at [*https://<wbr>github<wbr>.com<wbr>/alephdata<wbr>/aleph*](https://github.com/alephdata/aleph),
    into the *aleph* folder.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'The *docker-compose.yml* file describes the nine containers that Aleph requires
    and all of their configuration, including the volumes that will save the indexed
    versions of your datasets. One of these containers, called <samp class="SANS_TheSansMonoCd_W5Regular_11">shell</samp>,
    includes a bind mount that maps your home folder (*~*) on your host filesystem
    to */host* in the container:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In your copy of *docker-compose.yml*, delete this line or comment it out by
    prepending a hash mark (<samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp>)
    to make Aleph run faster and avoid giving the container access to your home folder.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Now rename *aleph.env.tmpl* to *aleph.env*, and open that file in your text
    editor. This file contains the settings for your Aleph instance on different lines,
    in the format <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SETTING_NAME</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">setting_value</samp>,
    which you’ll need to modify in a few ways.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run the following command to generate a random value for <samp class="SANS_TheSansMonoCd_W5Regular_11">ALEPH_SECRET_KEY</samp>
    (Windows users, run this in your Ubuntu terminal):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Since you’re running Aleph on your computer instead of setting it up on a server
    for others to use, change <samp class="SANS_TheSansMonoCd_W5Regular_11">ALEPH_SINGLE_USER</samp>
    in *aleph.env* to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> instead
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>, which allows you
    to use Aleph without having to create an admin user for yourself. Save the file.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Aleph relies on many different services to run, including three databases:
    PostgreSQL, Redis, and Elasticsearch. Elasticsearch is designed to search large
    amounts of data for text strings. For it to operate quickly, it needs to hold
    lots of data in memory. Linux’s default memory management setting <samp class="SANS_TheSansMonoCd_W5Regular_11">vm.max_map_count</samp>
    is far too low for Elasticsearch to work properly. If you’re using Linux or Windows
    with WSL, run the following command to increase the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">vm.max_map_count</samp>:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you’re using macOS, run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sysctl
    -w vm.max_map_count=262144</samp> inside of your Linux VM managed by Docker Desktop.
    To do this, run the following command to start a shell directly in your Linux
    VM:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once you’re in this shell, run this command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">exit</samp> to exit the Linux
    VM shell. Each time you restart Docker Desktop, this change is undone, so you’ll
    need to run these commands again to continue using Elasticsearch. (Refer to the
    “Increasing Elasticsearch Memory in Docker Desktop” box to speed up this process
    in the future.)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, for all operating systems, run the following command to start Aleph:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first time you run this command, you’ll download a few gigabytes of container
    images. Text will scroll past in the terminal while Aleph boots up; wait for it
    to stop.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need to run an <samp class="SANS_TheSansMonoCd_W5Regular_11">upgrade</samp>
    command the first time you use Aleph and whenever you upgrade your version of
    it. Once Aleph finishes booting, open a second terminal, change to the *exercises*
    folder, and run:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This command initializes the databases that Aleph uses by running the command
    <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph upgrade</samp> inside the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">shell</samp> container. Wait for
    this command to completely finish; you’ll know it’s done when the program stops
    displaying output and you end up back at your terminal’s command prompt.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For more detailed documentation for Aleph, see* [https://docs.aleph.occrp.org](https://docs.aleph.occrp.org)*.*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Using Aleph’s Web and Command Line Interfaces</samp>
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you have a local Aleph server, you can explore its two different interfaces:
    the web interface, which you’ll use to investigate datasets, and the CLI interface,
    which you’ll use to index new datasets or administer your Aleph server.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: With your Aleph containers up, open *http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:8080<wbr>/*
    in a browser to see the web interface. For example, [Figure 5-3](#fig5-3) shows
    Aleph running in Docker containers on my Mac.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of Aleph loaded in a web browser, with link to “Search entities,”
    “Browse datasets,” “Start an investigation,” and “Create a search alert.”](Images/Figure5-3.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-3: Aleph hosted in
    Docker containers</samp>'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use this interface to search data you upload into Aleph. The search bar
    at the top allows you to search every dataset you’ve indexed in your Aleph server
    at once, and the slider icon just to the right of the search box lets you perform
    advanced searches.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The Datasets and Investigations buttons at the top show you the datasets in
    Aleph; for now, both of those pages will be empty. In Aleph, datasets and investigations
    are both collections of documents, with different user interfaces for exploring
    each. A dataset should be static, while an investigation is a collection of documents
    that you might still be adding to.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: After performing a search in Aleph, you can optionally save your search query
    as an alert. This feature is useful only on servers that have multiple users and
    are configured to send email. In those cases, the server automatically searches
    any new data indexed into the server for all of a user’s saved alerts. If it gets
    a hit, it sends an email to the user. In the example, you set <samp class="SANS_TheSansMonoCd_W5Regular_11">ALEPH_SINGLE_USER</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>, so that feature
    doesn’t apply.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the web-based user interface you just explored, designed for
    journalists and researchers, Aleph has a command line interface designed for running
    the Aleph server itself. You must use the command line interface for administrative
    tasks like creating Aleph users (if you aren’t using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ALEPH_SINGLE_USER</samp>
    setting in future projects) or indexing folders of data, which you’ll do later
    in this chapter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the command line interface, run <samp class="SANS_TheSansMonoCd_W5Regular_11">bash</samp>
    inside the container called <samp class="SANS_TheSansMonoCd_W5Regular_11">shell</samp>
    to start an Aleph shell like so:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When you first opened a shell in a container using Docker Compose, you used
    <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose exec</samp>, which
    executes a command in an already running container. Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose
    run</samp> runs a new container in which to execute your command. The <samp class="SANS_TheSansMonoCd_W5Regular_11">--rm</samp>
    argument tells Docker to remove the container as soon as your command finishes
    running. In this case, your command is <samp class="SANS_TheSansMonoCd_W5Regular_11">bash</samp>,
    so you can run <samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp> in the
    bash shell to remove this temporary container.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: You can now use the <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph</samp>
    command. Run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">aleph --help</samp>
    to see a list of all of the commands that Aleph supports. To learn more about
    a specific command, run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--help</samp>
    on it. For example, to learn more about the <samp class="SANS_TheSansMonoCd_W5Regular_11">crawldir</samp>
    command (which we’ll discuss in Exercise 5-5), you’d run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">aleph
    crawldir --help</samp>.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">exit</samp> to quit the Aleph
    shell. Back in your other terminal window, press CTRL-C to shut down all the Aleph
    containers when you’re not using them. When you run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose
    up</samp> to start the containers again, all the data in Aleph—including any datasets
    that you’ve added to it—will still be there, because that data is stored in Docker
    volumes, making it persistent.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Indexing Data in Aleph</samp>
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding data to Aleph is called *indexing*. By loading and processing every file
    in a dataset, Aleph allows you to extract useful information, which you can browse
    and search via its web-based user interface.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Indexing works differently for different types of files:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '**Office documents and PDFs** Aleph extracts all of the searchable text from
    these documents and attempts to find anything that looks like a person’s name,
    a company name, or other types of data that Aleph calls *entities*. It also extracts
    any metadata it can find.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '**Email messages**#x2003;Aleph again extracts searchable text and entities.
    This time, the entities it finds are likely to include both names and email addresses,
    which it determines by checking the sender and recipient of each email. It also
    extracts email attachments and indexes those individually.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '**Compressed files, such as ZIP files** Aleph decompresses these files, then
    indexes each file inside them individually, which can become as recursive as necessary.
    For example, a ZIP file might contain an email file with an attachment that contains
    another ZIP file, and so on.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Indexing datasets can take hours, days, or weeks, depending on the size of the
    dataset and the computational resources available to your Aleph server. In Exercise
    5-5, you’ll index a single BlueLeaks folder called *icefishx*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 5-5: Index a BlueLeaks Folder
    in Aleph</samp>'
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *icefishx* folder contains data from an American police intelligence network
    called Intelligence Communications Enterprise for Information Sharing and Exchange
    (ICEFISHX), a partnership between law enforcement in Minnesota, North Dakota,
    and South Dakota. I’ve selected this data because it covers the state where Minneapolis
    cop Derek Chauvin murdered George Floyd, sparking the 2020 Black Lives Matter
    uprising. Searching this dataset for *George Floyd* might reveal some interesting
    internal docs about police violence or the protests that it triggered.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Mount Your Datasets
    into the Aleph Shell</samp>
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you don’t already have Aleph running, change to your *aleph* folder and
    enter the following command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Wait for Aleph to boot up.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'In a separate terminal, start an Aleph shell. This time, however, bind-mount
    your *datasets* USB disk into the container, using the following command, substituting
    the correct path for your USB disk:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The arguments in this command are similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">--mount</samp>
    argument you used earlier to mount a volume with the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>
    command. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-v</samp> argument
    (short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--volume</samp>) is followed
    by the colon-separated list <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">/Volumes/datasets</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">:/datasets:ro</samp> containing three
    parts: the absolute path to the folder on the host operating system (on my computer,
    this is */Volumes/datasets*), the absolute path to the folder in the container
    (*/datasets*), and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ro</samp>
    option. Short for “read-only,” <samp class="SANS_TheSansMonoCd_W5Regular_11">ro</samp>
    gives the container permission to access the files in the bind mount but not to
    change any of them or create new files.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this command, make sure to use the correct path for your USB disk.
    In macOS, the path is */Volumes/datasets* or similar; in Linux, it’s */media/micah/datasets*
    or similar; and in Windows with WSL, it’s */mnt/d* or similar. If you’re using
    Windows with PowerShell, mount the *D:* drive into the container at the path */datasets*
    with this command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Altogether, this command runs a new <samp class="SANS_TheSansMonoCd_W5Regular_11">shell</samp>
    container and executes the <samp class="SANS_TheSansMonoCd_W5Regular_11">bash</samp>
    command inside of it. Your *datasets* folder on your host operating system becomes
    accessible as the folder */datasets* in the container, and it’s mounted in read-only
    mode, preventing the container from modifying anything on the USB disk.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have access to your datasets within the Aleph shell, you’ll index
    the *icefishx* data.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Index the icefishx
    Folder</samp>
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To index a dataset, you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph
    crawldir</samp> command. Aleph’s use of the term *crawl* means to open the folder
    and index each file in it, then open each subfolder it finds and index each file
    in that, and so on, until everything in the original folder has been indexed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to start indexing the *icefishx* folder:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This command tells Aleph to index data in the */datasets/BlueLeaks-extracted/icefishx*
    folder in the container (which is actually */Volumes/datasets/BlueLeaks-extracted/icefishx*
    on my host operating system). The <samp class="SANS_TheSansMonoCd_W5Regular_11">-l</samp>
    option (short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--language</samp>)
    helps you use OCR on documents. Because different languages use different alphabets
    and words, using <samp class="SANS_TheSansMonoCd_W5Regular_11">-l</samp> tells
    the OCR software what language you’re dealing with—in this case, English (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">eng</samp>).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Aleph should begin to work its way through each of the 19,992 files in the *icefishx*
    folder, totaling over 2GB. The output should display the filename of each file,
    which is added to a list of files to crawl. Even before the <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph
    crawldir</samp> command finishes, Aleph begins to index each file.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Switch to your other terminal window running Docker Compose and watch the output
    as it indexes and performs OCR on each file.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can use OCR for documents in languages other than English, too. To index
    a Russian dataset, for example, you’d use -<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">l
    rus</samp> so that Aleph recognizes Russian words in the Cyrillic alphabet. Under
    the hood, Aleph uses software called Tesseract to do the OCR; for a list of valid
    language codes in Tesseract’s documentation, see* [https://tesseract-ocr.github.io/tessdoc/Data-Files-in-different-versions.html](https://tesseract-ocr.github.io/tessdoc/Data-Files-in-different-versions.html)*.*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The *icefishx* folder took about an hour and a half to index on my Mac. It also
    used about 17GB worth of Docker volumes. Indexing larger quantities of data could
    take days and require much more disk space.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Check Indexing Status</samp>
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph crawldir</samp> has
    finished running, while you’re waiting for the indexing to complete, try a few
    more Aleph commands to query your Aleph server and check the indexing status.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run the following command to see a list of all of the datasets and investigations
    (known together as *collections*) in your Aleph server:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Foreign ID</samp> field is
    the unique identifier for each dataset, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    field is the human-readable name for the dataset displayed in the Aleph web application.
    I used the Aleph web interface to create a new investigation called Test Investigation
    before I started indexing *icefishx*, so I have two collections. When you use
    the web interface to make investigations, they get assigned completely random
    foreign IDs. When you use <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph
    crawldir</samp> to create them, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Foreign
    ID</samp> is based on the filesystem path that you’re indexing; alternatively,
    you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-f</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">foreign_id</samp> arguments to
    specify your own if you like.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, run the following command while indexing *icefishx* to check the status
    of the indexing:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This command displays a table of data that tells you the number of pending,
    running, and finished tasks for each collection that’s indexing, split into <samp
    class="SANS_TheSansMonoCd_W5Regular_11">analyze</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ingest</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> phases. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Collection</samp> column shows the ID
    of the collection—if you look back at the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph
    collections</samp>, the ID of the ICEFISHX dataset is <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>.
    When I ran <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph status</samp>,
    based on the total pending and finished numbers, indexing was roughly 15 percent
    complete (though this might be misleading; for example, one of those pending files
    could be a ZIP file containing another 1,000 files).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: If Aleph breaks in the middle of indexing a dataset, you can recover your progress.
    If you’re seeing a lot of error messages in the Docker Compose logs or in the
    Aleph web interface, the simplest solution is to restart the containers. In your
    Docker Compose terminal window, you’d press CTRL-C to quit all of the containers
    and then run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose up</samp>
    to start them again. After a few minutes, your containers should finish booting
    and the indexing should commence where it left off. If something failed before
    your <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph crawldir</samp> command
    finished running in the Aleph shell, you can run <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph
    crawldir</samp> again. This will reindex the entire dataset, but it should be
    quicker the second time around, because it won’t redo time-consuming tasks like
    performing OCR on documents that have already been processed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: You can also check the indexing status via the Aleph web interface. In your
    browser, navigate to the Investigations page. From there, click the ICEFISHX investigation,
    and you should see a progress bar showing you how the indexing is doing. [Figure
    5-4](#fig5-4) shows the indexing status from inside the web application.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of Aleph showing that the ICEFISHX dataset is 29% finished indexing.](Images/Figure5-4.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-4: The ICEFISHX dataset
    in the process of indexing</samp>'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'While you’re here, click the gear icon in the top-right corner of the screen
    and go to **Settings**. From there you can change the label, category, and summary
    of this dataset. For example, you can change the label from *icefishx* to something
    more descriptive, like *BlueLeaks: Intelligence Communications Enterprise for
    Information Sharing and Exchange (ICEFISHX)*. The default category is Investigations.
    If you change it to anything else, like Leaks, Court Archives, or Other Material,
    ICEFISHX will appear under Datasets instead of Investigations. For now, stick
    with the Investigations category.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Sit back and wait for Aleph to finish indexing the ICEFISHX dataset before moving
    on to the next section, where you’ll begin to use Aleph to explore the data.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*It’s possible to start looking through datasets in Aleph before indexing is
    complete, but it’s best to wait for the full index to finish before digging too
    deep. If you don’t, you’ll search only the data that’s been indexed to that point,
    so your searches might miss important documents.*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Explore BlueLeaks with Aleph</samp>
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’ve finished indexing the *icefishx* folder, navigate to the ICEFISHX
    dataset you’ve just imported in the Aleph web interface. It should be listed under
    the Investigations link at the top of the page. The Documents link in the left
    sidebar lets you manually browse the files in the dataset and open various documents,
    but where Aleph really shines is its search engine.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'When you enter a term in the search field, Aleph searches every dataset you’ve
    imported. You can filter your results in a variety of ways, using the left sidebar:
    for example, you can filter to a specific dataset, a specific date range, or even
    to documents that mention specific email addresses, phone numbers, or names. Once
    you’ve filtered the search results, you can click on documents to preview them.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-5](#fig5-5) shows some of the 335 search results for the term *George
    Floyd* in the ICEFISHX dataset.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of Aleph search results, with a document selected that’s titled
    “Possibility for Increased Threatening Activity towards Law Enforcement and Government
    Officials Following Worldwide Coverage of Minneapolis In-Custody Death.”](Images/Figure5-5.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-5: Aleph’s search
    interface with results returned for the term</samp> <samp class="SANS_Futura_Std_Book_11">George
    Floyd</samp>'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The document selected in [Figure 5-5](#fig5-5), classified as U//LES (Unclassified,
    Law Enforcement Sensitive), was created by the Minnesota Fusion Center on May
    27, 2020\. It warns of an increase in threatening activity toward law enforcement
    officers in response to George Floyd’s murder in police custody two days earlier.
    According to the document, two of the four officers involved had been doxed, and
    people protested outside one of their homes. Thousands of people began marching
    in the streets, and there were “increased discussions on White Supremacist Extremist
    (WSE) online forums.” The document recommends that police “avoid wearing organizationally-affiliated
    clothing outside of work settings,” “reduce social media footprint and use an
    alias,” and consider “varying travel patterns to avoid surveillance.”
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Aleph makes it easy to find connections between documents. If you click Expand
    in the top left of the selected document, you should end up at that document’s
    detail page. This page shows the document’s metadata on the left, as well as any
    names or email addresses it finds that are also mentioned in other documents.
    If you click on one of those—for example, on someone’s name or email—you should
    be taken to search results that list all of the documents mentioning that person.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: When you’re done exploring *icefishx*, try indexing additional folders in BlueLeaks
    or even the entire *BlueLeaks-extracted* folder.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Aleph Features</samp>
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s a lot more to Aleph than what we’ve covered so far. This section will
    introduce a few of the other cool things it can do, which you’ll find useful in
    the future as you continue to analyze hacked and leaked datasets. As you’ve seen,
    Aleph is great at indexing folders full of a wide variety of documents, but it
    also supports importing *structured data*—data that follows a consistent and well-defined
    data model. Entities in Aleph, which I mentioned earlier, are an example of structured
    data. Specifically, Aleph uses a data model called FollowTheMoney, which contains
    types of entities like Person, Company, Organization, or Address. Learn more about
    the FollowTheMoney data model and how to import these entities directly into Aleph
    at [*https://<wbr>followthemoney<wbr>.tech*](https://followthemoney.tech).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: When you index a dataset in Aleph, it automatically extracts its best guess
    at entities—data like the names of people and companies, and phone numbers and
    addresses—but its guesses are far from perfect. Aleph also allows you to manually
    create and edit entities in more detail. You can add a list of people to an investigation,
    for example, providing not just their names but also their contact information
    and any relationships they have to other entities like their employers. When you’re
    viewing an entity in Aleph’s web interface, it shows you all of the data about
    that entity and links to all of its related entities.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: You can also generate entities from data in spreadsheets like CSV or Excel files.
    For example, the ICEFISHX dataset has a spreadsheet called *Registrations.csv*
    that lists the name, rank, agency, home address, email address, phone number,
    supervisor, and other information about all 6,000 people who had accounts on the
    site. From the detail page of this file in the Aleph web interface, you can click
    Generate Entities to define exactly how this data should map to entities, and
    even how these entities should relate to other entities. This could help you build
    an organization chart of who reports to whom, for example.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph crawldir</samp>
    command you used in Exercise 5-5, there are other ways to index data into Aleph.
    First, you can use a different CLI program called <samp class="SANS_TheSansMonoCd_W5Regular_11">alephclient</samp>,
    which allows you to index data and push it into a remote Aleph server over the
    internet using Aleph’s application programming interface (API), without opening
    an Aleph shell. APIs are designed to allow software, rather than humans, to communicate.
    Every user on an Aleph server (or, if it’s a server with users disabled, the whole
    server) has an API secret access key, a credential that allows software to add
    data to, or otherwise interact with, the Aleph server. You can pass this API key
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">alephclient</samp> as an argument
    to index large datasets on an Aleph server that someone else runs. The command
    to install <samp class="SANS_TheSansMonoCd_W5Regular_11">alephclient</samp> is
    <samp class="SANS_TheSansMonoCd_W5Regular_11">python3 -m pip install alephclient</samp>.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can create a new investigation directly in the web interface
    by clicking Investigations at the top, then New Investigation. You’ll be prompted
    to give your investigation a title and an optional summary and language. You can
    upload files to your investigation directly from your web browser. This is useful
    if you want to upload a spreadsheet of names and email address and cross-reference
    it with the rest of the data in your Aleph server. For uploading big datasets
    like BlueLeaks, however, using the Aleph shell or <samp class="SANS_TheSansMonoCd_W5Regular_11">alephclient</samp>
    is easier and less error-prone.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: One of Aleph’s most powerful features is its ability to search multiple datasets
    at once. For example, you could index the BlueLeaks dataset, the Oath Keepers
    dataset you downloaded in [Chapter 4](chapter4.xhtml), and several others to search
    them all for someone’s name, email address, or phone number. Since the BlueLeaks
    dataset is full of PII of law enforcement officers and the Oath Keepers militia
    is known to recruit retired police, you could check if any Oath Keepers members
    or donors are mentioned in BlueLeaks. (I recommend waiting to try this until you
    further explore the Oath Keepers dataset in [Chapter 6](chapter6.xhtml).)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Aleph can also cross-reference the entities from one dataset with entities in
    all of the other datasets that have been indexed in a server. Navigating to an
    investigation and clicking Cross-Reference in the left sidebar allows you to compare
    each entity in the investigation with entities in every other dataset or investigation.
    For example, you could upload a spreadsheet of people you’re investigating—say,
    everyone who works at the White House—into an investigation, use the Generate
    Entities feature to convert it into a detailed list of Person entities, and then
    cross-reference this list with all of the other datasets you’ve indexed to see
    if any White House employees show up in them.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Spend some time experimenting with Aleph and getting to know its features on
    your own. When DDoSecrets publishes a dataset that you’re interested in, try downloading
    it and indexing it in Aleph. Explore searching multiple datasets at once as well
    as using the cross-referencing feature. Aleph’s documentation is available at
    [*https://<wbr>docs<wbr>.aleph<wbr>.occrp<wbr>.org*](https://docs.aleph.occrp.org).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Dedicated Aleph Servers</samp>
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Running Aleph in containers on your computer works well if you want to search
    just a few small datasets yourself. However, to index a large amount of data (such
    as all of BlueLeaks) that will stretch your laptop’s computational resources,
    or to work with others on the same datasets, consider setting up a dedicated Aleph
    server instead. Full instructions on doing that are outside the scope of this
    book, but this section provides an introduction.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](chapter4.xhtml), you learned how to create servers in the cloud;
    earlier in this chapter, you learned how to set up your own Aleph server. By combining
    those skills, you should be able to set up Aleph running in Docker containers
    on a cloud server. However, you’ll also need to decide how to secure the server
    and make sure it stays updated. How will you manage its users, and how will you
    restrict access to the server? How will you know and what will you do if someone
    hacks it? To run an Aleph server for your organization, I recommend that you bring
    in a professional system administrator or DevOps engineer to set it up and maintain
    it over time.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: As you set up your server, consider the security levels of the datasets on which
    you plan to use Aleph. For low- to medium-security datasets, you can host Aleph
    in a cloud server, which allows you to temporarily give your server more RAM or
    processing power to index a dataset more quickly. For medium- to high-security
    datasets, host Aleph on physical hardware, like a server in an office or in a
    server closet in a data center. Decide whether to require people to come into
    the office to use Aleph or to configure it so that they can access it over the
    internet. If you choose the latter, you’ll need to secure your Aleph server and
    the data it contains. For the highest-security datasets, you’ll have to download
    Linux containers on a computer with internet access, export the datasets, and
    import them on an air-gapped server.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you’ve learned how to run software in Linux containers using
    Docker, then applied those skills to run Aleph on your computer and index the
    *icefishx* folder from BlueLeaks, making it searchable. A search for the keyword
    *George Floyd* uncovered interesting law enforcement documents about the 2020
    racial justice protests that you couldn’t have uncovered with just <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>.
    You’ve also learned about some Aleph features you can explore on your own, the
    possibility of running a dedicated Aleph server instead of running it on your
    laptop, and dataset-indexing tools other than Aleph.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll revisit Docker in [Chapter 10](chapter10.xhtml), when you learn to use
    BlueLeaks Explorer, and in [Chapter 12](chapter12.xhtml), when you learn about
    SQL databases. In the following chapter, you’ll learn the tools and techniques
    required to dig through one of the most prevalent forms of data leaks: email dumps.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
