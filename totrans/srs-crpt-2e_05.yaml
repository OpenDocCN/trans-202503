- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CRYPTOGRAPHIC
    SECURITY</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">密码学安全</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Cryptographic definitions of security are not the same as those that apply to
    general computer security. The main difference between software security and cryptographic
    security is that we can *quantify* the latter. Unlike in the software world, where
    we usually say applications are either secure or insecure, in the cryptographic
    world it’s often possible to calculate the amount of effort required to break
    a cryptographic algorithm. Also, whereas software security focuses on preventing
    attackers from abusing a program’s code, the goal of cryptographic security is
    to make well-defined problems impossible to solve.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学中的安全定义与一般计算机安全的定义不同。软件安全和密码学安全的主要区别在于，我们可以*量化*后者。不同于软件领域，在那里我们通常说应用程序要么安全，要么不安全，在密码学领域，通常可以计算破解一个密码算法所需的努力程度。而且，软件安全侧重于防止攻击者滥用程序的代码，而密码学安全的目标是让某些明确的问题变得不可能解决。
- en: Cryptographic problems involve mathematical notions but not complex math—at
    least, not in this book. This chapter walks through some of these security notions
    and how you can apply them to solve real-world problems. In the following sections,
    I discuss how to quantify crypto security in ways that are both theoretically
    sound and practically relevant. I discuss the notions of unconditional versus
    computational security, bit security versus full attack cost, provable versus
    heuristic security, and symmetric versus asymmetric key generation. I conclude
    the chapter with real-world examples of failures in seemingly strong cryptography.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学问题涉及数学概念，但不涉及复杂的数学——至少在本书中不涉及。本章将介绍一些这些安全性概念以及如何将它们应用于解决实际问题。在接下来的章节中，我将讨论如何以理论上严谨和实际相关的方式量化密码安全性。我将讨论无条件安全与计算安全、比特安全与完全攻击成本、可证明安全与启发式安全、对称与非对称密钥生成等概念。我将在本章结束时，通过一些看似强大的密码学失败的现实案例来总结。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Defining the Impossible</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">定义不可能</samp>
- en: In [Chapter 1](chapter1.xhtml), I described a cipher’s security relative to
    an attacker’s capabilities and goals and deemed a cipher secure if it’s impossible
    to reach these goals given an attacker’s known capabilities. But what does *impossible*
    mean in this context?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](chapter1.xhtml)中，我描述了一个密码的安全性相对于攻击者的能力和目标，并认为如果在已知攻击者的能力下无法实现这些目标，则该密码是安全的。那么，在这个背景下，*不可能*是什么意思呢？
- en: 'Two notions define the concept of impossible in cryptography: unconditional
    security and computational security. Roughly speaking, *unconditional security*
    is about theoretical impossibility, whereas *computational security* is about
    practical impossibility. Unconditional security doesn’t quantify security because
    it views a cipher as either secure or insecure, with no middle ground; it’s therefore
    useless in practice, although it plays an important role in theoretical cryptography.
    Computational security is the more relevant and practical measure of the strength
    of a cipher.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个概念定义了密码学中“不可能”的含义：无条件安全和计算安全。大致来说，*无条件安全*是关于理论上的不可能性，而*计算安全*是关于实际上的不可能性。无条件安全并没有量化安全性，因为它将密码视为要么安全，要么不安全，没有中间地带；因此，它在实践中没有用，尽管在理论密码学中起着重要作用。计算安全是衡量密码强度的更相关和实用的标准。
- en: '<samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security in Theory:
    Unconditional Security</samp>'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">理论中的安全性：无条件安全</samp>
- en: Unconditional security is based not on how hard it is to break a cipher but
    on whether it’s conceivable to break it at all. A cipher is unconditionally secure
    only if, given unlimited computation time and memory, it cannot be broken. Even
    if a successful attack on a cipher would take trillions of years, such a cipher
    is unconditionally *in*secure.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 无条件安全并不是基于破解一个密码有多难，而是基于是否可以想象破解它。只有在给定无限的计算时间和内存时，密码无法被破解，这时它才是无条件安全的。即使破解一个密码需要数万亿年，这样的密码也是无条件的*不*安全。
- en: For example, the one-time pad in [Chapter 1](chapter1.xhtml) is unconditionally
    secure. Recall that the one-time pad encrypts a plaintext, *P*, to a ciphertext,
    *C* = *P* ⊕ *K*, where *K* is a random bit string that is unique to each plaintext.
    The cipher is unconditionally secure because, given a ciphertext and unlimited
    time to try all possible keys, *K*, and compute the corresponding plaintext, *P*,
    you’d still be unable to identify the right *K* because there are as many possible
    *P*s as there are *K*s.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[第 1 章](chapter1.xhtml)中的一次性密码本是无条件安全的。回想一下，一次性密码本将明文 *P* 加密为密文 *C* = *P*
    ⊕ *K*，其中 *K* 是一个唯一的随机比特串，专用于每个明文。这个密码是无条件安全的，因为即使给定一个密文，并且有无限时间来尝试所有可能的密钥 *K*
    并计算对应的明文 *P*，你仍然无法识别正确的 *K*，因为有多少个可能的 *P*，就有多少个可能的 *K*。
- en: '<samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security in Practice:
    Computational Security</samp>'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">实践中的安全性：计算安全</samp>
- en: Unlike unconditional security, computational security views a cipher as secure
    if it cannot be broken within a *reasonable* amount of time and with reasonable
    resources such as memory, hardware, budget, and energy. Computational security
    is a way to quantify the security of a cipher or any crypto algorithm.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与无条件安全不同，计算安全将一个密码视为安全的标准是，如果它在*合理*的时间内，且在合理的资源限制下（如内存、硬件、预算和能量），无法被破解。计算安全是一种量化密码或任何加密算法安全性的方法。
- en: For example, consider a cipher, **E**, for which you know a plaintext–ciphertext
    pair (*P*, *C*) but not the 128-bit key, *K*, that computes *C* = **E**(*K*, *P*).
    This cipher is not unconditionally secure because you could break it after trying
    the 2^(128) possible 128-bit *K*s until you find the one that satisfies **E**(*K*,
    *P*) = *C*. But in practice, even with testing 100 billion keys per second, it
    would take more than 100,000,000,000,000,000,000 years. In other words, reasonably
    speaking, this cipher is computationally secure because it’s practically impossible
    to break.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个密码**E**，你知道一个明文-密文对（*P*，*C*），但不知道计算 *C* = **E**(*K*，*P*) 的 128 位密钥 *K*。这个密码不是无条件安全的，因为你可以通过尝试
    2^(128) 个可能的 128 位 *K*，直到找到一个满足 **E**(*K*，*P*) = *C* 的密钥来破解它。但实际上，即便每秒测试 1000
    亿个密钥，也需要超过 100,000,000,000,000,000,000 年。换句话说，合理来说，这个密码是计算上安全的，因为几乎不可能破解。
- en: 'We can express computational security in terms of two values:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用两个值来表示计算安全性：
- en: '*t*, which is a limit on the number of operations that an attacker will carry
    out'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*t*，是攻击者将要执行的操作次数的上限'
- en: ε (*epsilon*), which is a limit on the probability of success of an attack
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ε (*epsilon*)，是攻击成功概率的上限
- en: We then say that a cryptographic scheme is (*t*, ε)-*secure* if an attacker
    performing at most *t* operations—whatever those operations are—has a probability
    of success that is no higher than ε, where ε is at least 0 and at most 1\. Computational
    security gives a limit on how hard it is to break a cryptographic algorithm.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以说，一个加密方案是 (*t*, ε)-*安全的*，如果一个执行最多 *t* 次操作的攻击者——无论这些操作是什么——成功的概率不高于 ε，其中
    ε 至少为 0，最多为 1。计算安全性提供了破解加密算法的难度的界限。
- en: 'Recognize that *t* and ε are just limits: if a cipher is (*t*, ε)-secure, then
    no attacker performing fewer than *t* operations will succeed (with probability
    ε). However, this doesn’t imply that an attacker doing exactly *t* operations
    will succeed, and it doesn’t provide the necessary number of operations, which
    may be much larger than *t*. We say that *t* is a *lower bound* on the necessary
    computation effort because you’d need at least *t* operations to compromise security.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 需要认识到 *t* 和 ε 只是上限：如果一个密码是 (*t*, ε)-安全的，那么在进行少于 *t* 次操作的攻击者将不会成功（成功概率为 ε）。然而，这并不意味着一个执行恰好
    *t* 次操作的攻击者会成功，也没有提供所需的操作次数，这个次数可能远大于 *t*。我们说 *t* 是必要计算努力的*下限*，因为你至少需要 *t* 次操作才能破解安全性。
- en: If we do know precisely how much effort it takes to break a cipher, we say that
    (*t*, ε)-security gives us a *tight bound* when an attack exists that breaks the
    cipher with probability ε and exactly *t* operations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确切知道破解一个密码所需的努力量，我们就可以说 (*t*, ε)-安全提供了一个*紧密的界限*，当存在一个攻击，可以通过 ε 的概率和恰好 *t*
    次操作来破解密码时。
- en: For example, consider a symmetric cipher with a 128-bit key. Ideally, this cipher
    should be (*t*, *t/*2^(128))-secure for any value of *t* between 1 and 2^(128).
    The best attack should be *brute force* (trying all keys until you find the correct
    one). Any better attack would have to exploit some imperfection in the cipher,
    so we strive to create ciphers where brute force is the best possible attack.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个具有128位密钥的对称加密算法。理想情况下，该加密算法应该是(*t*, *t/*2^(128))-安全的，适用于任何值的*t*，其中1 ≤
    *t* ≤ 2^(128)。最好的攻击方式应为*暴力破解*（尝试所有密钥直到找到正确的）。任何更好的攻击都必须利用加密算法中的某些缺陷，因此我们努力创建那些暴力破解是最好的攻击方式的加密算法。
- en: 'Given the statement (*t*, *t*/2^(128))-secure, let’s examine the probability
    of success of three possible attacks:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 给定(*t*, *t*/2^(128))-安全性，我们来检查三种可能攻击的成功概率：
- en: In the first case, *t* = 1, an attacker tries one key and succeeds with a probability
    of ε = 1/2^(128).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个情况下，*t* = 1，攻击者尝试一个密钥并以概率ε = 1/2^(128)成功。
- en: In the second case, *t* = 2^(128), an attacker tries all 2^(128) keys, and one
    succeeds. Thus, the probability ε = 1\. (If the attacker tries all keys, the right
    one must be among them.)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二种情况下，*t* = 2^(128)，攻击者尝试所有2^(128)个密钥，并且最终成功。因此，成功的概率ε = 1。（如果攻击者尝试所有密钥，正确的密钥必定在其中。）
- en: In the third case, an attacker tries only *t* = 2^(64) keys and succeeds with
    a probability of ε = 2^(64)/2^(128) = 2^(−64). When an attacker tries only a fraction
    of all keys, the success probability is proportional to the number of keys tried.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三种情况下，攻击者仅尝试*t* = 2^(64)个密钥，并以概率ε = 2^(64)/2^(128) = 2^(-64)成功。当攻击者只尝试部分密钥时，成功的概率与尝试的密钥数量成正比。
- en: We can conclude that a cipher with a key of *n* bits is at best (*t*, *t/*2*^n*)-secure,
    for any *t* between 1 and 2*^n*, because no matter how strong the cipher, a brute-force
    attack against it will always succeed. The key thus needs to be long enough to
    blunt brute-force attacks in practice.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出结论，一个具有*n*位密钥的加密算法，最好的安全性为(*t*, *t/*2*^n*)-安全，适用于任何1 ≤ *t* ≤ 2*^n*，因为无论加密算法多么强大，对其进行暴力破解的攻击总是会成功。因此，密钥长度需要足够长，以有效抵御实际中的暴力破解攻击。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*In this example, we’re counting the number of evaluations of the cipher, not
    the absolute time or number of processor clock cycles. Computational security
    is technology agnostic, which means a cipher that’s (*t*, ε)-secure today will
    be (*t*, ε)-secure tomorrow—but what’s considered secure in practice today might
    not be considered secure tomorrow.*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这个例子中，我们计算的是加密算法的评估次数，而不是绝对的时间或处理器时钟周期数。计算安全性与技术无关，这意味着今天是(*t*, ε)-安全的加密算法，明天仍将是(*t*,
    ε)-安全的——但今天被认为安全的东西，明天可能不再被认为安全。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Quantifying Security</samp>
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">量化安全性</samp>
- en: When you’ve found an attack, you should first figure out how efficient it is
    in theory and how practical it is, if at all. Likewise, given a cipher that’s
    allegedly secure, you’ll want to know what amount of work it can withstand. To
    address those questions, I’ll explain how we measure cryptographic security in
    bits (the theoretical view) and what factors affect the actual cost of an attack.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发现一个攻击方式时，首先应弄清楚它在理论上有多高效，以及它在实际中有多可行。同样，给定一个声称安全的加密算法，你也需要知道它能承受多少工作量。为了回答这些问题，我将解释如何以比特为单位衡量密码学安全性（理论视角），以及哪些因素影响实际攻击的成本。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Measuring Security
    in Bits</samp>
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">以比特为单位衡量安全性</samp>
- en: When speaking of computational security, a cipher is *t-*secure when a successful
    attack needs at least *t* operations. We thus avoid the nonintuitive (*t*, ε)
    notation by assuming a success probability of ε close to 1, or whatever probability
    we care about in practice. We then express security in bits, where “*n*-bit security”
    means that we need about 2*^n* operations to compromise some particular security
    notion.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到计算安全性时，如果一个加密算法的成功攻击至少需要*t*次操作，那么它被认为是*t*-安全的。因此，我们通过假设成功概率ε接近1，或者我们在实际中关心的任何概率，来避免使用不直观的(*t*,
    ε)表示法。然后我们以比特为单位表示安全性，其中“*n*位安全性”意味着我们需要大约2*^n*次操作来破坏某个特定的安全概念。
- en: 'If you know approximately how many operations it takes to break a cipher, you
    can determine its security level in bits by taking the binary logarithm of the
    number of operations: if it takes 1,000,000 operations, the security level is
    log[2](1,000,000), or about 20 bits (as 1,000,000 is approximately equal to 2^(20)).
    Recall that an *n*-bit key will give at most *n*-bit security because a brute-force
    attack with all 2*^n* possible keys will always succeed. But the key size doesn’t
    always match the security level—it just gives an *upper bound*, or the highest
    possible security level.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你大致知道破解一个密码需要多少操作，你可以通过取操作次数的二进制对数来确定其位安全级别：如果需要1,000,000次操作，安全级别就是log[2](1,000,000)，大约是20位（因为1,000,000大约等于2^(20)）。记住，一个*n*位的密钥最多只能提供*n*位的安全性，因为一个暴力破解攻击通过所有2*^n*个可能的密钥总会成功。但密钥大小并不总是与安全级别相匹配——它只提供一个*上界*，即最高可能的安全级别。
- en: 'A security level may be smaller than the key size for one of two reasons:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 安全级别可能会小于密钥大小，原因有二：
- en: An attack broke the cipher in fewer operations than expected—for example, using
    a method that recovers the key by trying only a subset of the 2*^n* keys.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种攻击用比预期更少的操作破解了密码——例如，使用一种方法，通过只尝试2*^n*密钥的一个子集来恢复密钥。
- en: The cipher’s security level intentionally differs from its key size, as with
    most public-key algorithms. For example, the RSA algorithm with 1,024-bit private-key
    elements (thus with a 2,048-bit modulus) provides less than 128-bit security.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码的安全级别故意与其密钥大小不同，正如大多数公钥算法一样。例如，具有1,024位私钥元素（因此具有2,048位模数）的RSA算法提供的安全性不足128位。
- en: Bit security proves useful when comparing the security level of ciphers, but
    it doesn’t provide enough information on the actual cost of an attack. It’s sometimes
    too simple an abstraction because it assumes that an *n*-bit-secure cipher takes
    2*^n* operations to break, whatever these operations are. Two ciphers with the
    same bit security level can therefore have vastly different real-world security
    levels when you factor in the actual cost of an attack to a real attacker.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 位安全性在比较密码的安全级别时很有用，但它并未提供关于攻击实际成本的足够信息。它有时是一个过于简单的抽象，因为它假设一个*n*位安全的密码需要2*^n*次操作才能破解，无论这些操作是什么。因此，两个具有相同位安全级别的密码在实际攻击成本上可能有着巨大的差异。
- en: Say we have two ciphers, each with a 128-bit key and 128-bit security. We must
    evaluate each cipher 2^(128) times to break it, but the second cipher is 100 times
    slower than the first. Evaluating the second cipher 2^(128) times thus takes the
    same time as 100 × 2^(128) ≈ 2^(134.64) evaluations of the first. If we count
    in terms of the first, fast cipher, then breaking the slower one takes 2^(134.64)
    operations. If we count in terms of the second, slow cipher, it takes only 2^(128)
    operations. Should we then say that the second cipher is stronger than the first?
    In principle, yes, but we rarely see such a hundred-fold performance difference
    between common ciphers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个密码，每个密码都有128位的密钥和128位的安全性。我们必须评估每个密码2^(128)次才能破解它，但第二个密码比第一个慢100倍。因此，评估第二个密码2^(128)次的时间相当于评估第一个密码100
    × 2^(128) ≈ 2^(134.64)次。如果我们按照第一个快速密码来计算，那么破解第二个密码需要2^(134.64)次操作。如果我们按照第二个慢密码来计算，则只需要2^(128)次操作。那么我们是否应该说第二个密码比第一个更强？原则上是的，但我们很少看到常见密码之间有如此百倍的性能差异。
- en: The inconsistent definition of an operation raises more difficulties when comparing
    the efficiency of attacks. Some attacks claim to reduce a cipher’s security because
    they perform 2^(120) evaluations of some operation rather than 2^(128) evaluations
    of the cipher, but the speed of each type of attack is left out of the analysis.
    The 2^(120)-operation attack won’t always be faster than a 2^(128) brute-force
    attack.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 操作定义的不一致性在比较攻击效率时带来了更多困难。有些攻击声称通过执行2^(120)次某种操作而不是2^(128)次密码操作来降低密码的安全性，但每种攻击类型的速度在分析中被忽略了。2^(120)次操作的攻击并不总是比2^(128)次暴力破解攻击更快。
- en: Nevertheless, bit security remains a useful notion as long as the operation
    is reasonably defined—meaning about as fast as an evaluation of the cipher. After
    all, in real life, all it takes to determine whether a security level is sufficient
    is an order of magnitude.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只要操作被合理定义——即大约与评估密码的速度相同——位安全性仍然是一个有用的概念。毕竟，在现实生活中，判断安全级别是否足够所需要的只是一个数量级。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Calculating the Full
    Attack Cost</samp>
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">计算完整攻击成本</samp>
- en: 'Bit security expresses the cost of the fastest attack against a cipher by estimating
    the order of magnitude of the number of operations it needs to succeed. But other
    factors affect the cost of an attack, and we must take these into account when
    estimating the actual security level. I’ll explain the four main ones: parallelism,
    memory, precomputation, and the number of targets.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 比特安全通过估算执行成功所需的操作数量的数量级来表示对加密算法最迅速攻击的成本。但其他因素也会影响攻击的成本，我们在估算实际安全水平时必须考虑这些因素。我将解释四个主要因素：并行性、内存、预计算和目标数量。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Parallelism</samp>
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">并行性</samp>
- en: The first factor to consider is computational parallelism—that is, the ability
    of the attack’s implementation to take advantage of parallel computing, such as
    multicore systems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个需要考虑的因素是计算并行性——即攻击实现是否能够利用并行计算，如多核系统。
- en: 'For example, consider these two attacks of 2^(56) operations each:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这两次各自执行 2^(56) 次操作的攻击：
- en: The first attack performs 2^(56) *sequentially dependent* operations, computing
    *x*i [+ 1] = *f*i(*x*i) for some fixed *x*[0] and distinct functions *f*i (with
    *i* from 1 to 2^(56)).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一次攻击执行 2^(56) *顺序依赖* 操作，计算 *x*i [+ 1] = *f*i(*x*i)，其中 *x*[0] 是固定的，*f*i 是不同的函数（*i*
    从 1 到 2^(56)）。
- en: The second attack performs 2^(56) *independent* operations, computing *x*i =
    *f*i(*x*) for some fixed *x* and distinct functions *f*i (with *i* from 1 to 2^(56)).
    It can execute the *f*i(*x*) computations in parallel because each *f*i(*x*) is
    independent of the others.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次攻击执行 2^(56) *独立* 操作，计算 *x*i = *f*i(*x*)，其中 *x* 是固定的，*f*i 是不同的函数（*i* 从 1 到
    2^(56)）。因为每个 *f*i(*x*) 互相独立，所以它们可以并行执行。
- en: The difference between the two attacks is that one can parallelize the second
    attack but not the first. Parallel processing can be orders of magnitude faster
    than sequential processing. For example, if you had 2^(16) = 65,536 processors
    available, you could divide the workload of the parallel attacks into 2^(16) independent
    tasks, each performing 2^(56) / 2^(16) = 2^(40) operations. The first attack,
    however, cannot benefit from having multiple cores available because each operation
    relies on the previous operation’s result. Therefore, the parallel attack will
    complete 65,536 times faster than the sequential one, even though they perform
    the same number of operations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这两次攻击的区别在于，第二次攻击可以并行化，而第一次攻击不能。并行处理比顺序处理要快几个数量级。例如，如果你有 2^(16) = 65,536 个处理器可用，你可以将并行攻击的工作负载划分为
    2^(16) 个独立任务，每个任务执行 2^(56) / 2^(16) = 2^(40) 次操作。然而，第一次攻击无法利用多个核心，因为每个操作依赖于前一个操作的结果。因此，尽管两次攻击执行相同数量的操作，平行攻击将比顺序攻击快
    65,536 倍。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Algorithms that become* N *times faster to attack when* N *cores are available
    are* embarrassingly parallel*; their execution times scale linearly with respect
    to the number of computing cores.*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*当* N *个核心可用时，*攻击速度会加速 N 倍的算法是* 极易并行化*；它们的执行时间与计算核心的数量成线性关系。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Memory</samp>
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">内存</samp>
- en: 'The second factor when determining the cost of an attack is memory. We evaluate
    cryptanalytic attacks with respect to their use of time and space: How many operations
    do they perform over time, how much memory or space do they consume, how do they
    use the space they consume, and what’s the speed of the available memory? Unfortunately,
    bit security focuses only on the time it takes to perform an attack.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定攻击成本时，第二个因素是内存。我们评估密码分析攻击时考虑时间和空间的使用：它们在时间上执行了多少操作，占用了多少内存或空间，如何利用这些空间，以及可用内存的速度如何？不幸的是，比特安全仅关注执行攻击所需的时间。
- en: Concerning the way an attack uses space, it’s important to consider how many
    memory lookups the attack requires, the speed of memory accesses (which may differ
    between reads and writes), the size of the accessed data, the access pattern (contiguous
    or random memory addresses), and how it structures data in memory. For example,
    on a 2021 Intel Xeon 8380 Ice Lake processor, accessing a register takes 1 clock
    cycle, accessing the L1 cache (48kB) takes 5 cycles, accessing the L2 cache (1.25MB)
    takes 14 cycles, accessing the L3 cache (60MB) takes 63.5 cycles, and accessing
    DRAM is at best as fast but often much slower than accessing the L3 cache (the
    exact delay depends on several factors).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 关于攻击如何使用空间，考虑攻击所需的内存查找次数、内存访问的速度（可能在读写操作之间有所不同）、访问数据的大小、访问模式（连续或随机内存地址）以及数据在内存中的结构是很重要的。例如，在2021年Intel
    Xeon 8380 Ice Lake处理器上，访问一个寄存器需要1个时钟周期，访问L1缓存（48KB）需要5个周期，访问L2缓存（1.25MB）需要14个周期，访问L3缓存（60MB）需要63.5个周期，而访问DRAM的速度最好和L3缓存一样快，但通常比访问L3缓存慢得多（具体延迟取决于多个因素）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Precomputation</samp>
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">预计算</samp>
- en: Precomputation operations need to be performed only once and can be reused over
    subsequent executions of the attack. We sometimes call precomputation the *offline
    stage* of an attack.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 预计算操作只需执行一次，并可以在随后的攻击执行中重用。我们有时称预计算为攻击的*离线阶段*。
- en: Consider the time-memory trade-off attack, in which the attacker performs one
    huge computation that produces large lookup tables that we then store and reuse
    to perform the actual attack. For example, one attack on 2G mobile encryption
    took two months to build 2TB’s worth of tables, which attackers then used to break
    the encryption in 2G and recover a secret session key in only a few seconds.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑时间-内存权衡攻击，在这种攻击中，攻击者执行一次巨大的计算，生成大型查找表，然后存储并重用这些表来执行实际的攻击。例如，针对2G移动加密的一次攻击花费了两个月的时间来构建2TB的表格，攻击者随后使用这些表格在仅仅几秒钟内破解了2G加密，并恢复了一个秘密会话密钥。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Number of Targets</samp>
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">目标数量</samp>
- en: Finally, we come to the number of targets of the attack. The greater the number
    of targets, the greater the attack surface, and the more attackers can learn about
    the keys they’re after.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来讨论攻击的目标数量。目标数量越多，攻击面越大，攻击者能够了解到他们所追寻的密钥的信息就越多。
- en: 'For example, consider a brute-force key search: if you target a single *n*-bit
    key, it will take 2*^n* attempts to find the correct key with certainty. If you
    target multiple *n*-bit keys—say, a number *M*—and if for a single *P* you have
    *M* distinct ciphertexts, where *C* = **E**(*K*, *P*) for each of the *M* keys
    (*K*) that you’re after, it will again take 2*^n* attempts to find each key. But
    if you’re interested only in *at least one* of the *M* keys and not in every one,
    it would take on average 2*^n*/*M* attempts to succeed. For example, to break
    one 128-bit key of 2^(16) = 65,536 target keys, it will take on average 2^(128
    − 16) = 2^(112) evaluations of the cipher. That is, the cost (and speed) of the
    attack decreases as the number of targets increases.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑暴力破解密钥搜索：如果你目标是一个*n*位密钥，需要进行2*^n*次尝试才能确定找到正确的密钥。如果你目标是多个*n*位密钥——比如一个数量*M*——并且对于一个单一的*P*，你有*M*个不同的密文，其中*C*
    = **E**(*K*, *P*)表示你想要的每个*M*密钥(*K*)，那么每个密钥仍然需要2*^n*次尝试来找到。但如果你只对*M*个密钥中的*至少一个*感兴趣，而不是每一个，那么平均来说，你将需要进行2*^n*/*M*次尝试才能成功。例如，要破解一个128位的密钥，如果目标是2^(16)
    = 65,536个密钥，那么平均需要进行2^(128 − 16) = 2^(112)次密码评估。也就是说，攻击的成本（和速度）随着目标数量的增加而降低。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Choosing and Evaluating
    Security Levels</samp>
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">选择和评估安全级别</samp>
- en: Choosing a security level often involves selecting between the 128-bit and 256-bit
    security levels available in most standard crypto algorithms and implementations.
    You’ll find schemes with 64- or 80-bit security, but these are generally not secure
    enough for real-world use.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 选择安全级别通常涉及在大多数标准加密算法和实现中选择128位和256位的安全级别。你会发现一些64位或80位的安全方案，但这些方案通常不足以在实际应用中保证安全。
- en: At a high level, 128-bit security means you’d need to carry out approximately
    2^(128) operations to break that cryptosystem. To give you a sense of what this
    number means, consider the fact that the universe is approximately 2^(88) nanoseconds
    old (there’s a billion nanoseconds in a second). Since testing a key with today’s
    technology takes no less than a nanosecond, you’d need several times the age of
    the universe for an attack to succeed (2^(40) times, to be precise).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来说，128位安全意味着你需要进行大约2^(128)次操作才能破解该加密系统。为了让你了解这个数字的含义，可以考虑这样一个事实：宇宙大约有2^(88)纳秒的历史（1秒有10亿纳秒）。由于今天的技术测试一个密钥至少需要1纳秒，你需要几倍宇宙年龄的时间才能成功进行一次攻击（准确地说是2^(40)倍）。
- en: But can’t parallelism and multiple targets dramatically reduce the time it takes
    to complete a successful attack? Not exactly. Say you’re interested in breaking
    any one of a million targets and that you have a million parallel cores available.
    That brings the search time down from 2^(128) to (2^(128) / 2^(20)) / 2^(20) =
    2^(88), which is equivalent to “only” one universe lifetime.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，难道并行处理和多个目标不会显著缩短成功攻击的时间吗？并非完全如此。假设你想破解其中一个百万个目标中的任意一个，并且你有一百万个并行核心可用。这将把搜索时间从2^(128)缩短到(2^(128)
    / 2^(20)) / 2^(20) = 2^(88)，这相当于“仅仅”一个宇宙的寿命。
- en: 'Another thing to consider when evaluating security levels is the evolution
    of technology. Moore’s law posits that computing efficiency doubles roughly every
    two years. We can think of this as a loss of 1 bit of security every two years:
    if today a $1,000 budget allows you to break, say, a 40-bit key in one hour, then
    Moore’s law says that two years later, you could break a 41-bit key in one hour
    for the same $1,000 budget (I’m simplifying). We can extrapolate from this to
    say that, according to Moore’s law, we’ll have 40 fewer bits of security in 80
    years compared to today. In other words, in 80 years doing 2^(128) operations
    may cost as much as doing 2^(88) operations today. Accounting for parallelism
    and multiple targets, we’re down to 2^(48) nanoseconds of computation, or about
    three days. But this extrapolation is highly inaccurate because Moore’s law won’t
    and can’t scale that much. Still, you get the idea: what looks infeasible today
    may be realistic in a century.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 评估安全级别时，还需要考虑技术的演变。摩尔定律认为计算效率大约每两年就会翻倍。我们可以将其视为每两年失去1位安全性：如果今天1000美元的预算可以在一小时内破解一个40位密钥，那么根据摩尔定律，两年后，你可以用相同的1000美元预算在一小时内破解一个41位的密钥（我在简化）。我们可以从中推测，根据摩尔定律，80年后我们的安全性将比今天少40位。换句话说，80年后，执行2^(128)次操作的成本可能和今天执行2^(88)次操作一样。考虑到并行处理和多个目标的因素，我们需要大约2^(48)纳秒的计算时间，也就是大约三天。但这个推测并不准确，因为摩尔定律不会也不能如此大幅度地扩展。不过，你可以理解：今天看起来不可行的事情，可能在一个世纪后变得现实。
- en: There will be times when a security level lower than 128 bits is justified such
    as when you need security for a short time period and when the costs of implementing
    a higher security level will negatively impact the cost or usability of a system.
    An example is pay-TV systems, wherein encryption keys are either 48 or 64 bits.
    This sounds ridiculously low but is sufficient because the key refreshes every
    5 or 10 seconds.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，低于128位的安全级别是可以被接受的，比如当你只需要短时间的安全保护，或者实现更高安全级别的成本会对系统的成本或可用性产生负面影响时。一个例子是付费电视系统，其中加密密钥为48位或64位。听起来可能非常低，但实际上是足够的，因为密钥每5到10秒就会刷新一次。
- en: Nevertheless, to ensure long-term security, you should choose 256-bit security
    or a bit less. Even in a worst-case scenario—the existence of quantum computers
    (see [Chapter 14](chapter14.xhtml))—we’re unlikely to break a 256-bit secure scheme
    in the foreseeable future. More than 256 bits of security is practically unnecessary,
    except as a marketing device.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了确保长期安全，你应该选择256位安全级别或略低于此的安全级别。即使在最坏的情况下——量子计算机的出现（见[第14章](chapter14.xhtml)）——我们也不太可能在可预见的未来破解256位的安全方案。256位以上的安全性在实际应用中是没有必要的，除非作为营销手段。
- en: 'As cryptographer John Kelsey once put it: “The difference between 80 bits and
    128 bits of key search is like the difference between a mission to Mars and a
    mission to Alpha Centauri. As far as I can see, there is no meaningful difference
    between 192-bit and 256-bit keys in terms of practical brute-force attacks; impossible
    is impossible.”'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如密码学家约翰·凯尔西曾经说的：“80位和128位密钥搜索之间的差距，就像是前往火星与前往半人马座阿尔法星的差距。就我看来，192位和256位密钥在实际暴力破解攻击中没有实质性的区别；不可能的事就是不可能。”
- en: <samp class="SANS_Futura_Std_Bold_B_11">Achieving Security</samp>
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">实现安全性</samp>
- en: Once you’ve chosen a security level, it’s important to guarantee that your cryptographic
    schemes will stick to it. In other words, you want *confidence*, not just hope
    and uncertainty, that things will work as planned, all the time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了一个安全级别，确保你的加密方案保持在这个级别是很重要的。换句话说，你希望有*信心*，而不仅仅是希望和不确定性，确保事情会按照计划进行，始终如此。
- en: When building confidence in the security of a crypto algorithm, you can rely
    on mathematical proofs, an approach we call *provable security*, or on evidence
    of failed attempts to break the algorithm, which I’ll call *heuristic security*
    (though it’s sometimes called *probable* security). These two approaches are complementary,
    and neither is better than the other, as you’ll see.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立对密码算法安全性的信心时，你可以依赖于数学证明，这种方法我们称之为*可证明的安全性*，或者依赖于未能破解算法的证据，我称之为*启发式安全性*（虽然它有时也被称为*可能*安全性）。这两种方法是互补的，没有哪一种比另一种更好，正如你将看到的那样。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Provable Security</samp>
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">可证明的安全性</samp>
- en: Provable security is about proving that breaking your crypto scheme is at least
    as hard as solving another problem known to be hard. Such a *security proof* guarantees
    that the crypto remains safe as long as the hard problem remains hard. This type
    of proof is called a *reduction*, and it comes from the field of complexity theory.
    We say problem X is reducible to breaking some cipher if any method to break the
    cipher also yields a method to solve problem X. Such a reduction guarantees that
    as long as problem X is hard, the cipher is secure.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 可证明的安全性是指证明破解你的密码学方案至少和解决另一个已知困难的问题一样难。这样的*安全证明*保证了只要该困难问题依然困难，密码学就保持安全。这类证明称为*归约*，源自复杂性理论领域。我们说问题
    X 可归约为破解某个密码，如果任何破解该密码的方法也会产生解决问题 X 的方法。这样的归约保证了只要问题 X 是困难的，密码就安全。
- en: 'Security proofs come in two flavors, depending on the type of presumably hard
    problem you use: proofs relative to a mathematical problem and proofs relative
    to a cryptographic problem.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 安全证明有两种类型，取决于你使用的假定困难问题的类型：相对于数学问题的证明和相对于密码学问题的证明。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Proofs Relative to a Mathematical
    Problem</samp>
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">相对于数学问题的证明</samp>
- en: Many security proofs (such as those for public-key crypto) show that breaking
    a crypto scheme is at least as hard as solving some hard mathematical problem.
    We’re talking of problems for which we know a solution exists and is easy to verify
    once we know it but is computationally hard to find.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 许多安全证明（例如针对公钥密码学的证明）表明，破解一个密码学方案至少和解决某个困难的数学问题一样难。我们说的是那些我们知道有解且一旦知道解就容易验证，但计算上很难找到解的问题。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注</samp>
- en: '*There’s no real proof that seemingly hard math problems are actually hard.
    In fact, proving this for a specific class of problems is one of the greatest
    challenges in the field of complexity theory. As I write this, there is a $1,000,000
    bounty for anyone who can prove this, awarded by the Clay Mathematics Institute.
    I discuss this in more detail in [Chapter 9](chapter9.xhtml).*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*没有真正的证据表明看似困难的数学问题实际上是困难的。事实上，证明这一点对于特定类别的问题来说是复杂性理论领域的最大挑战之一。写这篇文章时，克雷数学研究所为任何能证明这一点的人提供了100万美元的奖金。我在[第9章](chapter9.xhtml)中详细讨论了这个问题。*'
- en: 'For example, consider the challenge of solving the *factoring problem*, which
    is the best-known math problem in crypto: given a number that you know is the
    product of two prime numbers (*n* = *pq*), find the said primes. For example,
    if *n* = 15, the answer is 3 and 5\. That’s easy for a small number, but it becomes
    exponentially harder as the size of the number grows. For example, if a number,
    *n*, is 3,000 bits long (about 900 decimal digits) or more, factoring is believed
    to be practically infeasible.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑解决*因式分解问题*，这是密码学中最著名的数学问题：给定一个你知道是两个素数（*n* = *pq*）乘积的数字，找出这两个素数。例如，如果 *n*
    = 15，答案是 3 和 5。对于一个小数字来说这很容易，但随着数字大小的增加，它会变得呈指数级难。比如，如果一个数字 *n* 长达 3000 位（大约 900
    位十进制数字）或更多，因式分解被认为实际上是不可行的。
- en: 'Rivest–Shamir–Adleman (RSA) is the most famous crypto scheme to rely on the
    factoring problem: RSA encrypts a plaintext, *P*, seen as a large number, by computing
    *C* = *P**^e* mod *n*, where the number *e* and *n* = *pq* are the public key.
    Decryption recovers a plaintext from a ciphertext by computing *P* = *C**^d* mod
    *n*, where *d* is the private key associated with *e* and *n*. If we can factor
    *n*, then we can break RSA (by recovering the private key from the public key),
    and if we can obtain the private key, then we can factor *n* (for example, see
    the article at *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2004<wbr>/208](https://eprint.iacr.org/2004/208)*).
    In other words, recovering an RSA private key and factoring *n* are equivalently
    hard problems. That’s the kind of reduction we’re looking for in provable security.
    However, there is no guarantee that recovering an RSA plaintext is as hard as
    factoring *n*, since the knowledge of a plaintext doesn’t reveal the private key.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Rivest–Shamir–Adleman (RSA) 是最著名的依赖于因式分解问题的加密方案：RSA通过计算 *C* = *P**^e* mod *n*
    对明文 *P*（看作一个大数）进行加密，其中 *e* 和 *n* = *pq* 是公钥。解密通过计算 *P* = *C**^d* mod *n* 恢复明文，其中
    *d* 是与 *e* 和 *n* 相关的私钥。如果我们能够因式分解 *n*，那么就可以破解RSA（通过从公钥恢复私钥），如果我们能获得私钥，那么就能因式分解
    *n*（例如，参见文章 *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2004<wbr>/208](https://eprint.iacr.org/2004/208)*）。换句话说，恢复RSA私钥和因式分解
    *n* 是等价的困难问题。这就是我们在可证明安全性中寻求的那种归约。然而，并不能保证恢复RSA明文和因式分解 *n* 是同样困难的，因为明文的信息并不能揭示私钥。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Proofs Relative to Another
    Crypto Problem</samp>
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">相对于另一个加密问题的证明</samp>
- en: Instead of comparing a crypto scheme to a math problem, you can compare it to
    another crypto scheme and prove that you can break the second scheme only if you
    can break the first. Security proofs for symmetric ciphers usually follow this
    approach.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将加密方案与其他加密方案进行比较，而不是与数学问题进行比较，并证明只有在能够破解第一个方案时，才能破解第二个方案。对称加密算法的安全性证明通常采用这种方法。
- en: For example, if all you have is a single permutation algorithm, then you can
    build symmetric ciphers, random bit generators, and other crypto objects such
    as hash functions by combining calls to the permutations with various types of
    inputs (as you’ll see in [Chapter 6](chapter6.xhtml)). Proofs then show that the
    newly created schemes are secure if the permutation is secure. In other words,
    we know that the newly created algorithm is *not weaker* than the original one.
    Such proofs usually work by crafting an attack on the smaller component, given
    an attack on the larger one—that is, by showing a reduction.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你只有一个单一的置换算法，那么你可以通过将置换与各种输入类型组合，构建对称加密算法、随机比特生成器和其他加密对象，如哈希函数（如你将在[第6章](chapter6.xhtml)中看到的那样）。然后，证明表明，如果置换是安全的，那么新创建的方案也是安全的。换句话说，我们知道新创建的算法*不比*原始算法弱。此类证明通常通过给定对较大组件的攻击，构造对较小组件的攻击来工作——即通过展示一个归约。
- en: 'When proving that a crypto algorithm is no weaker than another, the main benefit
    is that of a reduced attack surface: instead of analyzing both the core algorithm
    and the combination, you can simply look at the new cipher’s core algorithm. Specifically,
    if you write a cipher that uses a newly developed permutation and a new combination,
    you may prove that the combination doesn’t weaken security compared to the core
    algorithm. Therefore, to break the combination, you need to break the new permutation.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当证明某个加密算法不比另一个算法弱时，主要的好处是减少了攻击面：你可以仅仅分析新加密算法的核心算法，而无需分析核心算法和组合的两部分。具体来说，如果你编写了一个使用新开发的置换和新组合的加密算法，你可以证明该组合在安全性上不弱于核心算法。因此，要破解该组合，你需要破解新的置换。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Caveats</samp>
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">注意事项</samp>
- en: Cryptography researchers rely heavily on security proofs, whether with respect
    to math problem schemes or to other crypto schemes. But the existence of a security
    proof doesn’t guarantee that a cryptographic scheme is perfect, nor is it an excuse
    for neglecting the more practical aspects of implementation. After all, as cryptographer
    Lars Knudsen once said, “If it’s provably secure, it’s probably not,” meaning
    that a security proof shouldn’t be taken as an absolute guarantee of security.
    Worse, there are multiple reasons why a “provably secure” scheme may lead to a
    security failure.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学研究人员在很大程度上依赖于安全证明，无论是针对数学问题方案还是其他加密方案。但安全证明的存在并不保证加密方案是完美的，也不能作为忽视实施中更实际方面的借口。毕竟，正如密码学家拉尔斯·克努森曾经说过的，“如果它是可以证明安全的，它可能并不安全”，这意味着安全证明不应被视为绝对的安全保障。更糟糕的是，有多种原因可能导致“可证明安全”的方案最终导致安全失败。
- en: One issue is with the phrase “proof of security” itself. In mathematics, a proof
    is the demonstration of an *absolute truth*, but in crypto, a proof is only the
    demonstration of a *relative truth*. For example, a proof that your cipher is
    as hard to break as it is to compute discrete logarithms—finding the number *x*
    given *g* and *g**^x* mod *n*—guarantees that if your cipher fails, a whole lot
    of other ciphers will fail as well, and nobody will blame you if the worst happens.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题在于“安全证明”这一短语本身。在数学中，证明是对*绝对真理*的展示，但在密码学中，证明仅仅是对*相对真理*的展示。例如，证明你的加密算法像计算离散对数一样难以破解——给定
    *g* 和 *g**^x* mod *n* 来找到 *x*——保证了如果你的加密算法失败，其他许多算法也会失败，如果最坏的情况发生，没人会怪你。
- en: Another caveat is that one usually proves security with respect to a single
    notion of security. For example, you might prove that recovering the private key
    of a cipher is as hard as the factoring problem. But if you can recover plaintexts
    from ciphertext without the key, you’ll bypass the proof, and recovering the key
    hardly matters.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个警告是，通常人们根据单一的安全概念来证明安全性。例如，你可能证明恢复加密算法的私钥与因式分解问题一样困难。但如果你能在没有密钥的情况下从密文中恢复明文，那么你就绕过了这个证明，而恢复密钥几乎没有意义。
- en: Then again, proofs are not always correct, and it may be easier to break an
    algorithm than originally thought.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但证明并不总是正确的，破解一个算法有时可能比最初想的更容易。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Unfortunately, few researchers carefully check security proofs, which commonly
    span dozens of pages, thus complicating quality control. That said, demonstrating
    that a proof is incorrect doesn’t necessarily imply that the proof’s goal is completely
    wrong; if the result is correct, one may salvage the proof by correcting its errors.*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*不幸的是，很少有研究人员仔细检查安全证明，而这些证明通常长达数十页，因此使得质量控制变得复杂。尽管如此，证明不正确并不一定意味着证明的目标完全错误；如果结果是正确的，可以通过修正错误来挽救证明。*'
- en: Another important consideration is that hard math problems sometimes turn out
    to be easier to solve than expected. For example, certain weak parameters make
    it easy to break the RSA cryptosystem. Or the math problem may be hard in certain
    cases but not on average, as often happens when the reference problem is new and
    not well understood. That’s what happened when the 1978 knapsack encryption scheme
    by Merkle and Hellman was later broken using lattice reduction techniques.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的考虑因素是，困难的数学问题有时会比预期的更容易解决。例如，某些弱参数使得破解 RSA 加密系统变得容易。或者，数学问题在某些情况下可能很难，但在大多数情况下却并不难，正如常常发生的那样，当参考问题是新的且没有被充分理解时。这就是
    1978 年梅尔克和赫尔曼的背包加密方案后来被使用格减法技术破解的原因。
- en: 'Finally, although the proof of an algorithm’s security may be fine, the implementation
    of the algorithm can be weak. For example, attackers may exploit side-channel
    information such as power consumption or execution time to learn about an algorithm’s
    internal operations in order to break it, thus bypassing the proof. Or implementers
    may misuse the crypto scheme: if the algorithm is too complicated with too many
    knobs to configure, chances are higher that the user or developer will get a configuration
    wrong, which may render the algorithm completely insecure.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，虽然算法的安全证明可能没问题，但算法的实现可能很脆弱。例如，攻击者可能利用侧信道信息，如功耗或执行时间，来了解算法的内部操作并破解它，从而绕过证明。或者实现者可能滥用加密方案：如果算法过于复杂，且有太多配置选项，用户或开发者出错的几率就会增加，这可能导致算法完全不安全。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Heuristic Security</samp>
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">启发式安全性</samp>
- en: Provable security is a great tool to gain confidence in a crypto scheme, but
    it doesn’t apply to all kinds of algorithms. In fact, most symmetric ciphers don’t
    have a security proof. For example, every day we rely on AES to securely communicate
    using our mobile phones, laptops, and desktop computers, but AES is not provably
    secure; there’s no proof that it’s as hard to break as some well-known problem.
    AES can’t be related to a math problem or to another algorithm because it’s the
    hard problem itself.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 可证明安全性是获得对加密方案信心的好工具，但并不适用于所有类型的算法。事实上，大多数对称加密算法并没有安全性证明。例如，我们每天依赖AES来通过手机、笔记本电脑和台式计算机安全地通信，但AES并不是可证明安全的；没有证明它和某些知名问题一样难以破解。AES无法与数学问题或其他算法关联，因为它本身就是那个难题。
- en: In cases where provable security doesn’t apply, the only reason to trust a cipher
    is because many skilled people tried to break it and failed. We call this *heuristic
    security*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在无法证明安全性适用的情况下，信任某个密码算法的唯一理由就是很多技术人员曾尝试攻破它但失败了。我们称这种安全性为*启发式安全性*。
- en: When can we be sure that a cipher is secure? We can never be sure, but we can
    be pretty confident that an algorithm won’t be broken when hundreds of experienced
    cryptanalysts have each spent hundreds of hours trying to break it and published
    their findings—usually by attempting attacks on *simplified versions* of a cipher
    (often versions with fewer operations, or fewer *rounds*, which are short series
    of operations that ciphers iterate in order to mix bits together).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们什么时候可以确信一个密码算法是安全的？我们永远无法完全确信，但我们可以相当有信心某个算法不会被攻破，当成百上千的经验丰富的密码分析师每人都花费了数百小时尝试攻破它并发表了他们的研究成果——通常是通过攻击密码算法的*简化版本*（通常是操作步骤较少的版本，或是操作步骤数较少的*轮*，这些轮次是加密算法反复执行的操作序列，用来混合数据位）。
- en: When analyzing a new cipher, cryptanalysts first try to break one round, then
    two, three, or as many as they can. The *security margin* is then the difference
    between the total number of rounds and the number of successfully attacked rounds.
    After years of study, if a cipher’s security margin is still high, we become confident
    that it’s (probably) secure.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析新的加密算法时，密码分析师首先会尝试攻破一轮，然后是两轮、三轮，甚至尽可能多的轮数。*安全边际*则是总轮数与成功攻击的轮数之间的差值。经过多年的研究，如果某个加密算法的安全边际仍然很高，我们就可以相当有信心它是（可能）安全的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Generating Keys</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">生成密钥</samp>
- en: If you plan to encrypt something, you’ll have to generate keys, whether they’re
    temporary “session keys” (like the ones generated when browsing an HTTPS site)
    or long-term public keys. Recall from [Chapter 2](chapter2.xhtml) that secret
    keys are the crux of cryptographic security and should be randomly generated so
    that they are unpredictable and secret.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划加密某些内容，你将不得不生成密钥，无论是临时的“会话密钥”（就像浏览HTTPS网站时生成的那种）还是长期的公钥。回想一下[第二章](chapter2.xhtml)中提到的，秘密密钥是加密安全的关键，应当随机生成，以便它们不可预测且保密。
- en: 'For example, when you browse an HTTPS website, your browser receives the site’s
    public key and uses it to establish a symmetric key that’s valid only for the
    current session, and that site’s public key and its associated private key may
    be valid for years. Therefore, it’d better be hard for an attacker to find. But
    generating a secret key isn’t always as simple as dumping enough pseudorandom
    bits. We can generate cryptographic keys in one of three ways:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你浏览一个HTTPS网站时，浏览器接收该网站的公钥，并使用它建立一个只在当前会话中有效的对称密钥，而该网站的公钥及其关联的私钥可能会有效多年。因此，攻击者最好很难找到它。但生成一个密钥并不总是像丢出足够的伪随机位那样简单。我们可以通过三种方式生成加密密钥：
- en: '*Randomly*, using a PRNG feeding a key-generation algorithm'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*随机地*，使用伪随机数生成器（PRNG）来为密钥生成算法提供输入'
- en: From a *password*, using a password-based key derivation function (PBKDF), which
    transforms the user-supplied password into a key
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过*密码*，使用基于密码的密钥派生函数（PBKDF），它将用户提供的密码转换为密钥
- en: Through a *key agreement protocol*, which is a series of message exchanges between
    two or more parties that ends with the establishment of a shared key
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过*密钥协商协议*，即两个或更多方之间通过一系列消息交换，最终建立共享密钥的过程
- en: 'For now, I’ll explain the simplest method: randomized generation.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我将解释最简单的方法：随机生成。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Symmetric Keys</samp>
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">对称密钥</samp>
- en: 'Symmetric keys are secret keys shared by two parties, and they are the simplest
    to generate. They are usually the same length as the security level they provide:
    a 128-bit key provides 128-bit security, and any of the 2^(128) possible keys
    is valid.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对称密钥是由两方共享的秘密密钥，它们是最简单生成的。它们通常与所提供的安全级别相同长度：一个 128 位的密钥提供 128 位的安全性，任何 2^(128)
    个可能的密钥都是有效的。
- en: 'To generate a symmetric key of *n* bits using a cryptographic PRNG, you simply
    ask it for *n* pseudorandom bits and use those bits as the key. That’s it. You
    can, for example, use the OpenSSL toolkit to generate a random symmetric key by
    dumping pseudorandom bytes, as in the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用加密的伪随机数生成器（PRNG）生成 *n* 位的对称密钥，你只需向它请求 *n* 位伪随机比特，并将这些比特作为密钥。这就完成了。例如，你可以使用
    OpenSSL 工具包通过转储伪随机字节来生成一个随机的对称密钥，如下命令所示：
- en: '[PRE0]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Your result will, of course, differ from mine.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果当然会与我的不同。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Asymmetric Keys</samp>
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">非对称密钥</samp>
- en: Unlike symmetric keys, asymmetric keys are usually longer than the security
    level they provide. But the main problem stems from asymmetric keys being trickier
    to generate than symmetric ones because you can’t dump *n* bits from your PRNG
    and get away with the result. Asymmetric keys aren’t just raw bit sequences. Instead,
    they represent a specific type of object, such as a large number with specific
    properties (in RSA, a product of two primes). A random bit string value (and thus
    a random number) is unlikely to have the necessary properties and therefore won’t
    be a valid key.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与对称密钥不同，非对称密钥通常比它们提供的安全级别要长。但主要问题来自于非对称密钥比对称密钥更难生成，因为你不能仅仅从伪随机数生成器（PRNG）中获取
    *n* 位并得到有效结果。非对称密钥不仅仅是原始的比特序列，而是代表一种特定类型的对象，比如一个具有特定属性的大数（在 RSA 中，是两个素数的乘积）。一个随机的比特串值（因此是一个随机数）不太可能具备所需的属性，因此不能成为有效的密钥。
- en: To generate an asymmetric key, you send pseudorandom bits as a seed to a *key-generation
    algorithm*. This algorithm takes as input a seed value that’s at least as long
    as the intended security level and constructs from it a private key and its respective
    public key, ensuring that both satisfy the necessary criteria. For example, a
    naive key-generation algorithm for RSA would generate a number, *n* = *pq*, by
    using an algorithm to generate two random primes of about the same length. That
    algorithm would pick random numbers until one happens to be prime, so you’d also
    need an algorithm to test whether a number is prime.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个非对称密钥，你将伪随机比特作为种子输入到一个 *密钥生成算法* 中。这个算法以一个至少与预期安全级别一样长的种子值为输入，并从中构造一个私钥及其相应的公钥，确保两者都满足必要的标准。例如，RSA
    的一个简单密钥生成算法会通过生成两个大致相同长度的随机素数，使用算法得到一个 *n* = *pq* 的数值。该算法会选择随机数，直到有一个是素数，因此你还需要一个算法来检测某个数字是否为素数。
- en: 'To save yourself the burden of manually implementing the key-generation algorithm,
    you can use OpenSSL to generate a 4,096-bit RSA private key, like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免手动实现密钥生成算法的麻烦，你可以使用 OpenSSL 来生成一个 4,096 位的 RSA 私钥，如下所示：
- en: '[PRE1]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the key comes in a specific format—namely, base64-encoded data between
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">BEGIN RSA PRIVATE KEY</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">END RSA PRIVATE KEY</samp> markers.
    That’s a standard encoding format that most systems support and can convert to
    raw bytes of data. The dot sequences at the beginning are a kind of progress bar,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">e is 65537 (0x10001)</samp>
    indicates the parameter to use when encrypting (remember that RSA encrypts by
    computing *C* = *P**^e* mod *n*).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，密钥以特定格式呈现——即在 <samp class="SANS_TheSansMonoCd_W5Regular_11">BEGIN RSA PRIVATE
    KEY</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">END RSA PRIVATE KEY</samp>
    标记之间的 base64 编码数据。这是一个大多数系统支持的标准编码格式，可以转换为原始字节数据。开始的点序列是一种进度条，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">e
    是 65537 (0x10001)</samp> 表示在加密时使用的参数（记住，RSA 通过计算 *C* = *P**^e* mod *n* 来加密）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Protecting Keys</samp>
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">密钥保护</samp>
- en: 'Once you have a secret key, you need to keep it secret yet available when you
    need it. There are three ways to address this problem:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你拥有了一个秘密密钥，你需要保持它的机密性，同时在需要时能够使用它。有三种方法可以解决这个问题：
- en: '**Key wrapping (encrypting the key using a second key)**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥封装（使用第二个密钥加密密钥）**'
- en: The problem with this approach is that the second key must be available when
    you need to decrypt the protected key. In practice, this second key is often generated
    from a password the user supplies when they need to use the protected key. That’s
    how private keys for the Secure Shell (SSH) protocol are usually protected.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于，第二个密钥必须在需要解密受保护密钥时可用。在实际操作中，这第二个密钥通常是由用户在需要使用受保护密钥时提供的密码生成的。这就是安全外壳（SSH）协议的私钥通常受到保护的方式。
- en: '**On-the-fly generation from a password**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**实时生成密码**'
- en: This doesn’t require storing an encrypted file because the key comes straight
    out from the password. Systems like cryptocurrency wallets and password managers
    often use this method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这不需要存储加密文件，因为密钥直接来自密码。像加密货币钱包和密码管理器这样的系统通常使用这种方法。
- en: 'Although this method is more direct than key wrapping, it’s less widespread,
    in part because it’s more vulnerable to weak passwords. Say, for example, that
    an attacker captured some encrypted message: if we used key wrapping, the attacker
    first needs to get the protected key file, which may be stored locally on the
    user’s file system or in a key management system (KMS), and therefore is not easy
    to access. But if we used on-the-fly generation, the attacker can directly search
    for the correct password by attempting to decrypt the encrypted message with candidate
    passwords. And if the password is weak, the key is compromised.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法比密钥包装更直接，但它的普及程度较低，部分原因是它更容易受到弱密码的攻击。例如，假设攻击者截获了一些加密消息：如果我们使用密钥包装，攻击者首先需要获取受保护的密钥文件，该文件可能存储在用户的本地文件系统中或在密钥管理系统（KMS）中，因此不容易访问。但如果我们使用实时生成，攻击者可以通过尝试使用候选密码解密加密消息，直接搜索正确的密码。如果密码较弱，密钥就会被破解。
- en: '**Storing the key on a hardware token (smart card or USB dongle)**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**将密钥存储在硬件令牌（智能卡或USB加密狗）中**'
- en: In this approach, we store the key in secure memory, and it remains safe even
    if the computer is compromised. This is the safest approach to key storage but
    also the costliest and least convenient because it requires you to carry the hardware
    token with you and run the risk of losing it. Smart cards and USB dongles usually
    require you to enter a password to unlock the key from the secure memory.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们将密钥存储在安全内存中，即使计算机被攻击，密钥也保持安全。这是最安全的密钥存储方法，但也是最昂贵且最不方便的方法，因为它要求你随身携带硬件令牌，并且有丢失的风险。智能卡和USB加密狗通常需要你输入密码来解锁存储在安全内存中的密钥。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Whatever method you use, make sure not to mistake the private key for the
    public one when exchanging keys, and don’t accidentally publish the private key
    through email or source code. (I’ve actually found private keys on GitHub.)*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*无论使用何种方法，交换密钥时请务必确保不要将私钥与公钥混淆，也不要通过电子邮件或源代码不小心发布私钥。（我实际上曾在GitHub上找到私钥。）*'
- en: 'To test key wrapping, run the following OpenSSL command with the argument <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-aes128</samp> to tell OpenSSL to encrypt
    the key with the cipher AES-128 (AES with a 128-bit key):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试密钥包装，请运行以下OpenSSL命令，并使用参数<samp class="SANS_TheSansMonoCd_W5Regular_11">-aes128</samp>告知OpenSSL使用AES-128（128位密钥的AES加密算法）加密密钥：
- en: '[PRE2]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: OpenSSL will use the requested passphrase to encrypt the newly created key.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL将使用请求的密码短语来加密新创建的密钥。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">问题所在</samp>
- en: Cryptographic security can go wrong in many ways. The biggest risk is when you
    have a false sense of security due to security proofs or well-studied protocols,
    as the following examples illustrate.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 加密安全可能以多种方式出错。最大风险是由于安全证明或研究透彻的协议而产生的虚假安全感，以下示例对此进行了说明。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Incorrect Security
    Proof</samp>
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">错误的安全证明</samp>
- en: Even proofs of security by renowned researchers may be wrong. One of the most
    striking examples of a proof gone terribly wrong is that of *Optimal Asymmetric
    Encryption Padding (OAEP)*, a method of secure encryption that used RSA and was
    implemented in many applications. An incorrect proof of OAEP’s security against
    chosen-ciphertext attackers was accepted as valid for seven years, until a researcher
    found a flaw in 2001\. Not only was the proof wrong, but the result was wrong
    as well. A new proof later showed that OAEP is only almost secure against chosen-ciphertext
    attackers. We now have to trust the new proof and hope that it’s flawless. (For
    further details, see the 2001 paper “OAEP Reconsidered” by Victor Shoup.)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Short Keys for Legacy
    Support</samp>
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In 2015, researchers found that some HTTPS sites and SSH servers supported public-key
    cryptography with shorter keys than expected—namely, 512 bits instead of at least
    2,048 bits. Remember, with public-key schemes, the security level isn’t equal
    to the key size, and in the case of HTTPS, keys of 512 bits offer a security level
    of approximately 60 bits. These keys could be broken after only about two weeks
    of computation using a cluster of 72 processors. This affected many websites,
    including the website of the US Federal Bureau of Investigation (FBI). Although
    the software was ultimately fixed (thanks to patches for OpenSSL and for other
    software), the problem was quite an unpleasant surprise.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about provable security for symmetric ciphers, read the sponge
    functions documentation (*[https://<wbr>keccak<wbr>.team<wbr>/sponge<wbr>_duplex<wbr>.html](https://keccak.team/sponge_duplex.html)*).
    Sponge functions introduced the permutation-based approach in symmetric crypto,
    which describes how to construct a bunch of different cryptographic functions
    using only one permutation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Some must-reads on the real cost of attacks include Daniel J. Bernstein’s 2005
    paper “Understanding Brute Force” and Michael Wiener’s 2004 paper “The Full Cost
    of Cryptanalytic Attacks,” both available online for free.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: To determine the security level for a given key size, visit *[https://<wbr>www<wbr>.keylength<wbr>.com](https://www.keylength.com)*.
    This site presents the recommendations of several government agencies concerning
    key sizes, as well as the order of magnitude of security guaranteed according
    to the size of public keys.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as an exercise, pick an application (such as a secure messaging application)
    and identify its crypto schemes, key length, and respective security levels. You’ll
    often find surprising inconsistencies, such as a first scheme providing a 256-bit
    security level but a second scheme providing only 100-bit security. The security
    of the whole system is often only as strong as that of its weakest component.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
