<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch13">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_297" aria-label="297"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch13">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">13</span></span>&#13;
<span class="CT"><span class="Sans_Dogma_B">DNS MONITOR</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="377" height="376"/></figure>&#13;
<p class="CO">In this chapter, I’ll focus on the practicalities of building a deployable host-based network monitor capable of proxying and blocking DNS traffic from unrecognized processes or destined for untrusted domains.</p>&#13;
<p class="TX"><span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span> covered the basic design of a DNS proxy capable of monitoring traffic via Apple’s <i>NetworkExtension</i> framework. There, however, I skipped over many of the steps required to build a deployable tool, including obtaining necessary entitlements and correctly bundling the extension within a host application. This chapter will discuss these tasks, as well as ways of extending a basic monitor, such as by parsing DNS queries and responses to block those found on a block list.</p>&#13;
<p class="TX">You can find these capabilities and more in the open source DNSMonitor, which is part of Objective-See’s tool suite (<a href="https://github.com/objective-see/DNSMonitor"><i>https://<wbr/>github<wbr/>.com<wbr/>/objective<wbr/>-see<wbr/>/DNSMonitor</i></a>). I recommend that you download the project or reference the source code in the repository while reading the chapter, as the following discussions often omit parts of the code for brevity.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_298" aria-label="298"/>&#13;
<h3 class="H1" id="sec1"><span id="h1-72"/><span class="SANS_Futura_Std_Bold_B_11">Network Extension Deployment Prerequisites</span></h3>&#13;
<p class="TNI">Modern networking monitors, including DNSMonitor, make use of the network extension framework. Because they’re packaged as system extensions and run as stand-alone processes with elevated privileges, Apple requires developers to entitle and bundle them in a very specific way. In <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>, we walked through the process of obtaining the Endpoint Security entitlement and then creating a provisioning profile for the tool in the Apple Developer portal. If you’re building a network extension, you’ll follow a similar process, with a few key differences.</p>&#13;
<p class="TX">First, you’ll need to generate two provisioning profiles, one for the network extension and another for the application that contains and loads the extension. Follow the process described in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span> to create an ID for each item on the Apple Developer site. When asked to select capabilities for the extension, check <b>Network Extensions</b>, which maps to the <i>com.apple .developer.networking.networkextension</i> entitlement. Any developer can use this entitlement (unlike the Endpoint Security entitlement, which requires explicit approval from Apple). For the application, select that same capability, as well as <b>System Extension</b>, which will allow the application to install, load, and manage the extension. Once you’ve created both IDs, create the two provisioning profiles.</p>&#13;
<p class="TX">Now you must install each provisioning profile in Xcode. If you look at the <i>DNSMonitor</i> project, you’ll see that it contains two targets: the extension and its host application. When you click either of these targets, the Signing and Capabilities tab should provide an option to specify the relevant provisioning profile. Apple’s developer documentation recommends enabling manual signing by leaving the Automatically Manage Signing option unchecked.<sup><a role="doc-noteref" id="chapter13_1" href="#chapter13-1">1</a></sup></p>&#13;
<p class="TX">The Signing and Capabilities tab will also show that the DNSMonitor project has enabled additional capabilities for both the extension and application that match those we specified when building the provisioning profile. The extension specifies the Network Extensions capability, while the app specifies both Network Extensions and System Extensions. If you’re building your own network extension, you’ll have to add these capabilities manually by clicking the + next to Capabilities.</p>&#13;
<p class="TX">Behind the scenes, adding these capabilities applies the relevant entitlements to each target’s <i>entitlements.plist</i>. Unfortunately, we must manually edit these <i>entitlements.plist</i> files. Adding the Network Extensions capability and checking DNS Proxy will add the entitlement with a value of <span class="SANS_TheSansMonoCd_W5Regular_11">dns-proxy</span>, but we’ll need a value of <span class="SANS_TheSansMonoCd_W5Regular_11">dns-proxy-systemextension</span> to deploy an extension signed with a developer ID.<sup><a role="doc-noteref" id="chapter13_2" href="#chapter13-2">2</a></sup> <a href="chapter13.xhtml#Lis13-1">Listing 13-1</a> shows this in the extension’s <i>entitlements .plist</i> file.</p>&#13;
<span id="Lis13-1"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_299" aria-label="299"/>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&#13;
...&#13;
&lt;plist version="1.0"&gt;&#13;
&lt;dict&gt;&#13;
    &lt;key&gt;<b>com.apple.developer.networking.networkextension</b>&lt;/key&gt;&#13;
    &lt;array&gt;&#13;
        &lt;string&gt;<b>dns-proxy-systemextension</b>&lt;/string&gt;&#13;
    &lt;/array&gt;&#13;
    ...&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-1: We must entitle network extensions and specify an extension type.</span></p>&#13;
<p class="TX">The file includes the network extension entitlement as a key, along with an array holding any extension types.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-73"/><span class="SANS_Futura_Std_Bold_B_11">Packaging the Extension</span></h3>&#13;
<p class="TNI">Any tool that uses a network extension must implement it as a system extension, then structure itself in a specific way so that macOS can validate and activate it. Specifically, Apple requires that any system extension be packaged within a bundle, such as an application, in the bundle’s <i>Contents/Library/SystemExtensions/</i> directory. A provisioning profile must also authorize the use of restricted entitlements, and we can’t embed provisioning profiles directly into a stand-alone binary.</p>&#13;
<p class="TX">For these reasons, DNSMonitor contains two components: a host application and a network extension.<sup><a role="doc-noteref" id="chapter13_3" href="#chapter13-3">3</a></sup> To properly package the extension in Xcode, we specify the application component dependency on the extension under <b>Build Phases</b>. We set the destination to <b>System Extensions</b> so that macOS will copy the extension into the application’s <i>Contents/Library/SystemExtensions/</i> directory while building the application (<a href="chapter13.xhtml#fig13-1">Figure 13-1</a>).</p>&#13;
<figure class="IMG"><img class="img7" id="fig13-1" src="../images/Figure13-1.jpg" alt="" width="1143" height="389"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: The application contains a build step to embed the system extension.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Let’s now turn our attention to the extension’s <i>Info.plist</i> file (<a href="chapter13.xhtml#Lis13-2">Listing 13-2</a>).</p>&#13;
<span id="Lis13-2"/>&#13;
<pre><code>&lt;?xml version="1.0" encoding=”UTF-8"?&gt;&#13;
...&#13;
&lt;plist version="1.0"&gt;&#13;
&lt;dict&gt;&#13;
    ...&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> &lt;key&gt;CFBundlePackageType&lt;/key&gt;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_300" aria-label="300"/>    &lt;string&gt;$(PRODUCT_BUNDLE_PACKAGE_TYPE)&lt;/string&gt;&#13;
    ...&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> &lt;key&gt;NetworkExtension&lt;/key&gt;&#13;
    &lt;dict&gt;&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> &lt;key&gt;NEMachServiceName&lt;/key&gt;&#13;
        &lt;string&gt;$(TeamIdentifierPrefix)com.objective-see.dnsmonitor&lt;/string&gt;&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> &lt;key&gt;NEProviderClasses&lt;/key&gt;&#13;
            &lt;dict&gt;&#13;
                &lt;key&gt;com.apple.networkextension.dns-proxy&lt;/key&gt;&#13;
                &lt;string&gt;DNSProxyProvider&lt;/string&gt;&#13;
            &lt;/dict&gt;&#13;
        &lt;/dict&gt;&#13;
        ...&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-2: The extension’s</span> <span class="SANS_Futura_Std_Book_11">Info.plist</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">file contains various key-value pairs specific to network extensions.</span></p>&#13;
<p class="TX">We set <span class="SANS_TheSansMonoCd_W5Regular_11">CFBundlePackageType</span> to a variable <span class="CodeAnnotation" aria-label="annotation1">❶</span> that the compiler will replace with the project’s type, <span class="SANS_TheSansMonoCd_W5Regular_11">systemextension</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">NetworkExtension</span> key holds a dictionary containing key and value pairs relevant to network extensions <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">NEMachServiceName</span> key specifies the name of the Mach service the extension can use for XPC communications <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Also, note the <span class="SANS_TheSansMonoCd_W5Regular_11">NEProviderClasses</span> key, which contains the network extension’s type and the name of the class within DNSMonitor that implements the required network extension logic <span class="CodeAnnotation" aria-label="annotation4">❹</span>. In <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, I mentioned that this class should implement <span class="SANS_TheSansMonoCd_W5Regular_11">NEDNSProxyProvider</span> delegate methods. We must also link the extension component against the <i>NetworkExtension</i> framework.</p>&#13;
<p class="TX">The application’s <i>entitlements.plist</i> file, shown in <a href="chapter13.xhtml#Lis13-3">Listing 13-3</a>, is fairly similar to that of the extension.</p>&#13;
<span id="Lis13-3"/>&#13;
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&#13;
...&#13;
&lt;plist version="1.0"&gt;&#13;
&lt;dict&gt;&#13;
    &lt;key&gt;com.apple.developer.networking.networkextension&lt;/key&gt;&#13;
    &lt;array&gt;&#13;
        &lt;string&gt;dns-proxy-systemextension&lt;/string&gt;&#13;
    &lt;/array&gt;&#13;
    &lt;key&gt;com.apple.developer.system-extension.install&lt;/key&gt;&#13;
    &lt;true/&gt;&#13;
    &lt;key&gt;com.apple.security.application-groups&lt;/key&gt;&#13;
    &lt;array&gt;&#13;
        &lt;string&gt;$(TeamIdentifierPrefix)com.objective-see.dnsmonitor&lt;/string&gt;&#13;
    &lt;/array&gt;&#13;
&lt;/dict&gt;&#13;
&lt;/plist&gt;&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-3: The app’s</span> <span class="SANS_Futura_Std_Book_11">entitlements.plist</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">file also contains key-value pairs specific to network extensions.</span></p>&#13;
<p class="TX">One difference between the two is the addition of the <i>com.apple.developer .system-extension.install</i> entitlement, set to true. We indirectly added this entitlement to the app’s provisioning profile when we granted it the System <span role="doc-pagebreak" epub:type="pagebreak" id="pg_301" aria-label="301"/>Extension capability. The app needs this entitlement to install and activate the network extension.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1" id="sec3"><span id="h1-74"/><span class="SANS_Futura_Std_Bold_B_11">Tool Design</span></h3>&#13;
<p class="TNI">Now that I’ve explained the components of DNSMonitor, let’s focus on how it operates, starting with launching the application.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-98"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The App</span></h4>&#13;
<p class="TNI">You can find the initialization logic for the app in the <i>DNSMonitor/App/main.m</i> file. After performing some basic argument parsing (for example, checking whether the user invoked the app with the <span class="SANS_TheSansMonoCd_W5Regular_11">-h</span> flag to show the default usage), the app retrieves the responsible parent’s bundle ID. If this parent is the Finder or the Dock (the likely parents in scenarios where the user double-clicked the app icon), the app displays an informative alert explaining that DNSMonitor should run from the terminal.</p>&#13;
<p class="TX">Also, unless we run DNSMonitor from the <i>Applications</i> directory, when the <span class="SANS_TheSansMonoCd_W5Regular_11">OSSystemExtensionRequest request:didFailWithError:</span> delegate method is invoked by the application to activate the extension, it will fail:<sup><a role="doc-noteref" id="chapter13_4" href="#chapter13-4">4</a></sup></p>&#13;
&#13;
<pre><code>ERROR: method '-[Extension request:didFailWithError:]' invoked with&#13;
&lt;OSSystemExtensionActivationRequest: 0x600003a8f150&gt;, Error Domain=&#13;
OSSystemExtensionErrorDomain Code=3 "App containing System Extension&#13;
to be activated must be in /Applications folder" UserInfo={NSLocalized&#13;
Description=App containing System Extension to be activated must be in&#13;
/Applications folder}&#13;
</code></pre>&#13;
<p class="TX">So, when run from the terminal, DNSMonitor checks that it’s executing from the correct directory before loading the network extension component. If not, it prints an error message and exits (<a href="chapter13.xhtml#Lis13-4">Listing 13-4</a>).</p>&#13;
<span id="Lis13-4"/>&#13;
<pre><code>if(YES != [NSBundle.mainBundle.bundlePath hasPrefix:@"/Applications/"]) {&#13;
    ...&#13;
    NSLog(@"\n\nERROR: As %@ uses a System Extension, Apple requires it must&#13;
    be located in /Applications\n\n", [APP_NAME stringByDeletingPathExtension]);&#13;
    goto bail;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-4: Checking whether the monitor is running from the</span> <span class="SANS_Futura_Std_Book_11">/Applications</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">directory</span></p>&#13;
<p class="TX">To pass captured DNS traffic from the extension to the application so we can display it to the user, we use the system log. In <a href="chapter13.xhtml#Lis13-5">Listing 13-5</a>, the application initializes a custom log monitor with a predicate to match messages written to the log by the (soon-to-be-loaded) network extension. It then prints any received messages to the terminal.</p>&#13;
<span id="Lis13-5"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_302" aria-label="302"/>NSPredicate* predicate =&#13;
[NSPredicate predicateWithFormat:@"subsystem='com.objective-see.dnsmonitor'"];&#13;
&#13;
LogMonitor* logMonitor = [[LogMonitor alloc] init];&#13;
[logMonitor start:predicate level:Log_Level_Default eventHandler:^(OSLogEventProxy* event) {&#13;
    ...&#13;
    NSLog(@"%@", event.composedMessage);&#13;
}];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-5: The app’s log monitor ingests DNS traffic captured in the extension.</span></p>&#13;
<p class="TX">In other cases, you might want to use a more robust mechanism, such as XPC, to pass data back and forth between the extension and the app, but for a simple command line tool, the universal logging subsystem suffices.</p>&#13;
<p class="TX">Before loading the network extension, the app sets up a signal handler for the interrupt signal (<span class="SANS_TheSansMonoCd_W5Regular_11">SIGINT</span>). As a result, when the user presses <small>CTRL-</small>C, the app can unload the extension and gracefully exit (<a href="chapter13.xhtml#Lis13-6">Listing 13-6</a>).</p>&#13;
<span id="Lis13-6"/>&#13;
<pre><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> signal(SIGINT, SIG_IGN);&#13;
dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL,&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> SIGINT, 0, dispatch_get_main_queue());&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> dispatch_source_set_event_handler(source, ^{&#13;
    ...&#13;
    stopExtension();&#13;
    exit(0);&#13;
});&#13;
dispatch_resume(source);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-6: Setting up a custom interrupt signal handler</span></p>&#13;
<p class="TX">First, the code ignores the default <span class="SANS_TheSansMonoCd_W5Regular_11">SIGINT</span> action <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then it creates a dispatch source for the interrupt signal <span class="CodeAnnotation" aria-label="annotation2">❷</span> and sets a custom handler with the <span class="SANS_TheSansMonoCd_W5Regular_11">dispatch_source_set_event_handler</span> API <span class="CodeAnnotation" aria-label="annotation3">❸</span>. The custom handler invokes a helper function, <span class="SANS_TheSansMonoCd_W5Regular_11">stopExtension</span>, to unload and uninstall the network extension before exiting. Though not shown here, the monitor can be executed with a command line option to skip unloading the extension when it exits. This alleviates the need to restart, and thus reapprove, the extension each time the monitor is restarted.</p>&#13;
<p class="TX">Finally, the app installs and activates the network extension. Because I covered this process in full detail in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, I won’t repeat it here, other than to note that it involves making an <span class="SANS_TheSansMonoCd_W5Regular_11">OSSystemExtensionRequest</span> request and configuring an <span class="SANS_TheSansMonoCd_W5Regular_11">NEDNSProxyManager</span> object. You can find the full installation and activation code in DNSMonitor’s <i>App/Extension.m</i> file.</p>&#13;
<p class="TX">With the network extension running, the app tells the current run loop to continue until it receives an interrupt signal from the user, as it needs to hang around to print out captured DNS traffic.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-99"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Extension</span></h4>&#13;
<p class="TNI">Behind the scenes, when an application invokes the APIs to install and activate a network extension, macOS copies the extension from the app’s <span role="doc-pagebreak" epub:type="pagebreak" id="pg_303" aria-label="303"/><i>Contents/Library/SystemExtensions/</i> directory into a privileged directory, <i>/Library/SystemExtensions/&lt;UUID&gt;/</i>, validates it, then executes it with root privileges. Run the <span class="SANS_TheSansMonoCd_W7Bold_B_11">ps</span> command to show the activated network extension’s process information, such as its privilege level, process ID, and path:</p>&#13;
&#13;
<pre><code>% <b>ps aux</b>&#13;
...&#13;
root 38943 ... /Library/SystemExtensions/8DC3FC3A-825E-49C3-879B-6B0C08388238/&#13;
com.objective-see.dnsmonitor.extension.systemextension/Contents/MacOS/com&#13;
.objective-see.dnsmonitor.extension&#13;
</code></pre>&#13;
<p class="TX">Once loaded, DNSMonitor’s extension opens a handle to the universal logging subsystem via the <span class="SANS_TheSansMonoCd_W5Regular_11">os_log_create</span> API, as it passes captured DNS traffic to the app using log messages. The logging API takes two parameters that allow you to specify a subsystem and a category (<a href="chapter13.xhtml#Lis13-7">Listing 13-7</a>).</p>&#13;
<span id="Lis13-7"/>&#13;
<pre><code>#define BUNDLE_ID "com.objective-see.dnsmonitor"&#13;
&#13;
os_log_t logHandle = os_log_create(BUNDLE_ID, "extension");&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-7: Opening a log handle in the extension</span></p>&#13;
<p class="TX">By specifying a subsystem or a category, you can easily create predicates that return only certain messages, as we did in the application (<a href="chapter13.xhtml#Lis13-5">Listing 13-5</a>). Next, the extension invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">NEProvider</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">startSystemExtensionMode</span> method, which you’ll recall will instantiate the class specified under the <span class="SANS_TheSansMonoCd_W5Regular_11">NEProviderClasses</span> key in the extension’s <i>Info.plist</i> file. The extension uses its <span class="SANS_TheSansMonoCd_W5Regular_11">DNSProxyProvider</span> class, which inherits from the <span class="SANS_TheSansMonoCd_W5Regular_11">NEDNSProxyProvider</span> class (<a href="chapter13.xhtml#Lis13-8">Listing 13-8</a>).</p>&#13;
<span id="Lis13-8"/>&#13;
<pre><code>@interface DNSProxyProvider : NEDNSProxyProvider&#13;
    ...&#13;
@end&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-8: The interface for the <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">DNSProxyProvider</span> class</span></p>&#13;
<p class="TX">In <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, I described how a DNS monitor could implement the various <span class="SANS_TheSansMonoCd_W5Regular_11">NEDNSProxyProvider</span> methods, such as the all-important <span class="SANS_TheSansMonoCd_W5Regular_11">handleNewFlow:</span>, which will be automatically invoked for all new DNS flows. As such, I won’t cover this again here, though you can find the full code in the <i>Extension/DNSProxyProvider.m</i> file.</p>&#13;
<p class="TX">Previous chapters didn’t cover how the extension sends the message to the app via the log, builds a DNS cache, and blocks specific requests or responses. Let’s explore these topics in more detail.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-100"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Interprocess Communication</span></h4>&#13;
<p class="TNI">I mentioned that when DNSMonitor’s network extension receives a new DNS request or response, it uses the universal logging subsystem to send the message to the app’s log monitor, which prints it to the terminal. You can find the extension logic to handle the writing of DNS traffic to the log in a helper method named <span class="SANS_TheSansMonoCd_W5Regular_11">printPacket</span> (<a href="chapter13.xhtml#Lis13-9">Listing 13-9</a>).</p>&#13;
<span id="Lis13-9"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_304" aria-label="304"/>-(void)printPacket:(dns_reply_t*)packet flow:(NEAppProxyFlow*)flow {&#13;
    ...&#13;
    char* bytes = NULL;&#13;
    size_t length = 0;&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> NSMutableDictionary* processInfo = [self getProcessInfo:flow];&#13;
&#13;
    os_log(logHandle, "PROCESS:\n%{public}@\n", processInfo);&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> FILE* fp = open_memstream(&amp;bytes, &amp;length);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> dns_print_reply(packet, fp, 0xFFFF);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> fflush(fp);&#13;
&#13;
    os_log(logHandle, "PACKET:\n%{public}s\n", bytes);&#13;
&#13;
    fclose(fp);&#13;
    free(bytes);&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-9: Printing a DNS packet to the universal log</span></p>&#13;
<p class="TX">A helper function named <span class="SANS_TheSansMonoCd_W5Regular_11">getProcessInfo:</span> creates a dictionary that describes the process responsible for generating the DNS traffic. The code then writes the dictionary to the log using the <span class="SANS_TheSansMonoCd_W5Regular_11">os_log</span> API <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">Writing the bytes of the DNS packet is a bit more complicated, because the macOS <span class="SANS_TheSansMonoCd_W5Regular_11">dns_print_reply</span> API, which formats raw DNS packets, expects to print to a file stream pointer (<span class="SANS_TheSansMonoCd_W5Regular_11">FILE *</span>), such as <span class="SANS_TheSansMonoCd_W5Regular_11">stdout</span>. On the other hand, universal logging APIs take an <span class="SANS_TheSansMonoCd_W5Regular_11">os_log_t</span> instead of a <span class="SANS_TheSansMonoCd_W5Regular_11">FILE *</span>. We circumvent this minor obstacle by having <span class="SANS_TheSansMonoCd_W5Regular_11">dns_print_reply</span> indirectly write to a memory buffer, which we can log via <span class="SANS_TheSansMonoCd_W5Regular_11">os_log</span>.</p>&#13;
<p class="TX">To make <span class="SANS_TheSansMonoCd_W5Regular_11">dns_print_reply</span> write to a buffer, we pass it a file handle that, unbeknownst to the function, is backed by a buffer, created thanks to the often-overlooked <span class="SANS_TheSansMonoCd_W5Regular_11">open_memstream</span> API <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">dns_print_reply</span> function formats the raw DNS packet and then happily writes it via the file handle <span class="CodeAnnotation" aria-label="annotation3">❸</span>. After invoking <span class="SANS_TheSansMonoCd_W5Regular_11">fflush</span> to ensure all buffered data is written out to the underlying memory <span class="CodeAnnotation" aria-label="annotation4">❹</span>, we write the parsed DNS packet to the universal log with a second call to <span class="SANS_TheSansMonoCd_W5Regular_11">os_log</span>. As I previously noted, the log monitor in the app component can now ingest the message and print it to the user’s terminal.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1" id="sec7"><span id="h1-75"/><span class="SANS_Futura_Std_Bold_B_11">Building and Dumping DNS Caches</span></h3>&#13;
<p class="TNI">It always surprises me that macOS doesn’t provide a way to dump cached DNS resolutions, which contain the requested domains and resolved IP addresses. As you’ll see in this section, however, DNS cache dumping is easy enough to implement in a DNS monitor.</p>&#13;
<p class="TX">When the DNSMonitor network extension starts, it creates a global array to store dictionaries of the mappings between DNS requests (questions) and their responses (answers). It implements this logic in a helper method named <span class="SANS_TheSansMonoCd_W5Regular_11">cache:</span>, which takes a parsed DNS response packet that contains both the questions and any answers.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_305" aria-label="305"/>The majority of code within the <span class="SANS_TheSansMonoCd_W5Regular_11">cache:</span> method is dedicated to extracting the questions and answers from the DNS response packet, which can contain multiples of both. We covered this process in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, so we won’t repeat it here, but you can find the method’s full code in <i>Extension/DNSProxyProvider.m</i>.</p>&#13;
<p class="TX">Once we’ve extracted all questions and answers from the DNS response packet, we add them to the global cache array, named <span class="SANS_TheSansMonoCd_W5Regular_11">dnsCache</span> (<a href="chapter13.xhtml#Lis13-10">Listing 13-10</a>).</p>&#13;
<span id="Lis13-10"/>&#13;
<pre><code>-(void)cache:(dns_reply_t*)packet {&#13;
    NSMutableArray* answers = [NSMutableArray array];&#13;
    NSMutableArray* questions = [NSMutableArray array];&#13;
&#13;
    // Code to extract questions and answers from DNS response packet removed&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> @synchronized(dnsCache) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if(dnsCache.count &gt;= MAX_ENTRIES) {&#13;
            [dnsCache removeObjectsInRange:NSMakeRange(0, MAX_ENTRIES/2)];&#13;
        }&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> for(NSString* question in questions) {&#13;
            if(0 != answers.count) {&#13;
              <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> [dnsCache addObject:@{question:answers}];&#13;
            }&#13;
        }&#13;
        ...&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-10: Saving DNS questions and answers to a cache</span></p>&#13;
<p class="TX">As DNS responses can arrive and be processed asynchronously, we synchronize access to the global cache by wrapping it in a <span class="SANS_TheSansMonoCd_W5Regular_11">@synchronized</span> block <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Before adding another entry, the code checks that the cache hasn’t grown too large. If it has, it rather bluntly prunes the first half to evict the oldest ones <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Finally, it adds an entry for each question and its answers <span class="CodeAnnotation" aria-label="annotation3">❸</span> using the <span class="SANS_TheSansMonoCd_W5Regular_11">NSMutableArray</span>’s <span class="SANS_TheSansMonoCd_W5Regular_11">addObject:</span> method. Note that the snippet of code <span class="SANS_TheSansMonoCd_W5Regular_11">@{question:answers}</span> uses the Objective-C shorthand <span class="SANS_TheSansMonoCd_W5Regular_11">@{}</span> to create a dictionary whose key is the question and whose value is a list of answers <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">At this point, the extension is caching DNS questions and answers. The entries generated by resolving NoStarch.com and Objective-See.org would look like the following:</p>&#13;
&#13;
<pre><code>[&#13;
    {nostarch.com:["104.20.120.46", "104.20.121.46"]},&#13;
    {objective-see.org:["185.199.110.153", "185.199.109.153",&#13;
    "185.199.111.153", "185.199.108.153"]}&#13;
]&#13;
</code></pre>&#13;
<p class="TX">To facilitate the dumping of this cache, the extension installs a signal handler for the signal <span class="SANS_TheSansMonoCd_W5Regular_11">SIGUSR1</span>, otherwise known as <i>user signal 1</i> (<a href="chapter13.xhtml#Lis13-11">Listing 13-11</a>).</p>&#13;
<span id="Lis13-11"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_306" aria-label="306"/>signal(SIGUSR1, dumpDNSCache);</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-11: Installing a signal handler for user signal 1</span></p>&#13;
<p class="TX">Now, any adequately privileged process on the system can send a <span class="SANS_TheSansMonoCd_W5Regular_11">SIGUSR1</span> to the extension. Here’s how to do this manually in the terminal:</p>&#13;
&#13;
<pre><code>% <b>sudo kill -SIGUSR1 `pgrep com.objective-see.dnsmonitor.extension`</b></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">kill</span> shell command benignly sends a <span class="SANS_TheSansMonoCd_W5Regular_11">SIGUSR1</span> to the extension, whose process ID we find via <span class="SANS_TheSansMonoCd_W5Regular_11">pgrep</span>. Because the extension is running with root privileges, we must elevate our privileges with <span class="SANS_TheSansMonoCd_W5Regular_11">sudo</span> to deliver a signal.</p>&#13;
<p class="TX">As the code in <a href="chapter13.xhtml#Lis13-11">Listing 13-11</a> showed, the extension sets the handler for <span class="SANS_TheSansMonoCd_W5Regular_11">SIGUSR1</span> to a function named <span class="SANS_TheSansMonoCd_W5Regular_11">dumpDNSCache</span>. Let’s take a look at this function. Shown in <a href="chapter13.xhtml#Lis13-12">Listing 13-12</a>, it straightforwardly writes each cache entry to the universal log.</p>&#13;
<span id="Lis13-12"/>&#13;
<pre><code>void dumpDNSCache(int signal) {&#13;
    for(NSDictionary* entry in dnsCache) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> NSString* question = entry.allKeys.firstObject;&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> os_log(logHandle, "%{public}@:%{public}@", question, entry[question]);&#13;
    }&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-12: When the code receives a <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SIGUSR1</span> signal, it dumps the cache to the log.</span></p>&#13;
<p class="TX">In a <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop, the code iterates over all entries in its global DNS cache. Recall that this cache is an array of dictionaries. Each entry’s dictionary contains a single key representing the DNS question, and the code extracts it with the <span class="SANS_TheSansMonoCd_W5Regular_11">firstObject</span> property of the <span class="SANS_TheSansMonoCd_W5Regular_11">allKeys</span> array <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, using <span class="SANS_TheSansMonoCd_W5Regular_11">os_log</span>, it writes the question and the corresponding answers <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Note the use of the <span class="SANS_TheSansMonoCd_W5Regular_11">public</span> keyword, which tells the logging subsystem not to redact the cache data being logged.</p>&#13;
<p class="TX">When you send a <span class="SANS_TheSansMonoCd_W5Regular_11">SIGUSR1</span> to the extension while the DNSMonitor application component is running, it will automatically ingest the log message containing the dumped cache and print it out:</p>&#13;
&#13;
<pre><code>Dumping DNS Cache:&#13;
DNSMonitor[2027:25144] www.apple.com:(&#13;
    "23.2.84.211"&#13;
)&#13;
DNSMonitor[2027:25144] nostarch.com:(&#13;
    "104.20.120.46",&#13;
    "104.20.121.46"&#13;
)&#13;
DNSMonitor[2027:25144] objective-see.org:(&#13;
    "185.199.111.153",&#13;
    "185.199.110.153",&#13;
    "185.199.109.153",&#13;
    "185.199.108.153"&#13;
)&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_307" aria-label="307"/>Because the extension writes the items in its cache to the universal log, you can also view these messages directly via the <span class="SANS_TheSansMonoCd_W5Regular_11">log</span> command:</p>&#13;
&#13;
<pre><code>% <b>log stream --predicate="subsystem='com.objective-see.dnsmonitor'"</b></code></pre>&#13;
<p class="TX">I recommend specifying the filter predicate, however, because otherwise, you’ll be inundated with irrelevant log messages from the rest of the system.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h1-76"/><span class="SANS_Futura_Std_Bold_B_11">Blocking DNS Traffic</span></h3>&#13;
<p class="TNI">So far, we’ve focused on passive actions, such as printing DNS requests and responses and dumping an extension-built cache. But what if we wanted to extend the monitor to block certain traffic? <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span> covered Apple’s official way of blocking traffic using a network extension that implements a filter data provider to allow, drop, or pause network flows. Objective-See’s open source firewall LuLu takes this approach.<sup><a role="doc-noteref" id="chapter13_5" href="#chapter13-5">5</a></sup></p>&#13;
<p class="TX">It turns out we can also block DNS traffic using an <span class="SANS_TheSansMonoCd_W5Regular_11">NEDNSProxyProvider</span> object. Because we’re already proxying all DNS traffic, nothing stops us from closing any flow we so choose. A benefit of sticking with the <span class="SANS_TheSansMonoCd_W5Regular_11">NEDNSProxyProvider</span> class is that the system routes only DNS traffic through the extension. Because we’re not interested in other types of traffic, this keeps our code efficient. On the other hand, a filter data provider would make us responsible for examining and responding to all network flows.</p>&#13;
<p class="TX">One simple approach to specifying what DNS traffic to block is to use a block list. This block list could contain the domains and IP addresses of known malware command-and-control servers, unscrupulous internet service providers, or even servers that track users or display ads. Whenever an application attempts to resolve a domain, macOS will proxy the request through the extension, which can examine the request and block it if the domain is on the list. On the flip side, once a remote DNS server has processed a request and resolved the domain, macOS will proxy the response back through the extension before sending it to the application that made the original request. This gives the extension a chance to examine the response and block it if it contains a banned IP address.</p>&#13;
<p class="TX">You can find the logic to block a domain or IP address in the extension, in a method named <span class="SANS_TheSansMonoCd_W5Regular_11">shouldBlock:</span>. This method accepts a parsed DNS packet of type <span class="SANS_TheSansMonoCd_W5Regular_11">dns_reply_t</span> (used for both requests and responses) and returns a Boolean to indicate whether to block it. The method’s logic is rather involved, as it must handle both IPv4 and IPv6, so I won’t show its entire code here. <a href="chapter13.xhtml#Lis13-13">Listing 13-13</a> includes the part of the method that checks whether requests contain any domains on the block list.</p>&#13;
<span id="Lis13-13"/>&#13;
<pre><code>-(BOOL)shouldBlock:(dns_reply_t*)packet {&#13;
    BOOL block = NO;&#13;
    dns_header_t* header = packet-&gt;header;&#13;
&#13;
    if(DNS_FLAGS_QR_QUERY == (header-&gt;flags &amp; DNS_FLAGS_QR_MASK)) { <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
        for(uint16_t i = 0; i &lt; header-&gt;qdcount; i++) { <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_308" aria-label="308"/>            NSString* question = [NSString stringWithUTF8String:packet-&gt;question[i]-&gt;name]; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
            if(YES == [self.blockList containsObject:question]) { <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
                block = YES;&#13;
                goto bail;&#13;
            }&#13;
        }&#13;
    }&#13;
    ...&#13;
&#13;
bail:&#13;
    return block;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-13: Checking for domains to block</span></p>&#13;
<p class="TX">The code first initializes a <span class="SANS_TheSansMonoCd_W5Regular_11">dns_header_t</span> pointer to the header of the parsed DNS packet. Defined in Apple’s <i>dns_util.h</i> file, it contains flags (to indicate the type of DNS packet) and various counts, such as the number of questions and answers:</p>&#13;
&#13;
<pre><code>typedef struct {&#13;
    uint16_t xid;&#13;
    uint16_t flags;&#13;
    uint16_t qdcount;&#13;
    uint16_t ancount;&#13;
    uint16_t nscount;&#13;
    uint16_t arcount;&#13;
} dns_header_t;&#13;
</code></pre>&#13;
<p class="TX">The code in <a href="chapter13.xhtml#Lis13-13">Listing 13-13</a> checks the header’s <span class="SANS_TheSansMonoCd_W5Regular_11">flags</span> member to see whether the <span class="SANS_TheSansMonoCd_W5Regular_11">DNS_FLAGS_QR_QUERY</span> bit is set <span class="CodeAnnotation" aria-label="annotation1">❶</span>. This flag indicates that the DNS packet is a query containing one or more domains to resolve. (You won’t find constants such as <span class="SANS_TheSansMonoCd_W5Regular_11">DNS_FLAGS_QR_QUERY</span> in any header file, as Apple defines them in <i>dns_util.c</i>, so you might want to copy them directly into your own code.) Assuming the DNS packet contains a query, the code then iterates over each domain in the request <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The number of domains is stored in the <span class="SANS_TheSansMonoCd_W5Regular_11">qdcount</span> member of the header structure, while each domain to be resolved can be found in the packet’s <span class="SANS_TheSansMonoCd_W5Regular_11">question</span> array. The code extracts each domain and converts it to a more manageable Objective-C string object <span class="CodeAnnotation" aria-label="annotation3">❸</span> before checking whether it matches any of the items in the global block list <span class="CodeAnnotation" aria-label="annotation4">❹</span>. If so, the code sets a flag, breaks, and returns.</p>&#13;
<p class="TX">Though not shown here, the code to check a response packet is similar. Response packets list the number of answers in the <span class="SANS_TheSansMonoCd_W5Regular_11">ancount</span> member of the header structure and provide the answers themselves in the <span class="SANS_TheSansMonoCd_W5Regular_11">answer</span> array. Apple defines the <span class="SANS_TheSansMonoCd_W5Regular_11">dns_resource_record_t</span> structure to store these answers in the <i>dns_util.h</i> header file. This structure contains, among other things, a <span class="SANS_TheSansMonoCd_W5Regular_11">dnstype</span> member, which specifies the answer’s type, such as <span class="SANS_TheSansMonoCd_W5Regular_11">A</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">CNAME</span>. So, to extract an IPv4 address from a DNS <span class="SANS_TheSansMonoCd_W5Regular_11">A</span> record into an Objective-C object, you might write code similar to <a href="chapter13.xhtml#Lis13-14">Listing 13-14</a>.</p>&#13;
<span id="Lis13-14"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_309" aria-label="309"/>if(ns_t_a == packet-&gt;answer[i]-&gt;dnstype) {&#13;
    NSString* address =&#13;
    [NSString stringWithUTF8String:inet_ntoa(packet-&gt;answer[i]-&gt;data.A-&gt;addr)];&#13;
&#13;
    // Add code here to process the extracted answer (IP address).&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-14: Extracting an answer from a DNS A record</span></p>&#13;
<p class="TX">If a question or an answer matches an entry in DNSMonitor’s global block list, the <span class="SANS_TheSansMonoCd_W5Regular_11">shouldBlock:</span> method returns <span class="SANS_TheSansMonoCd_W5Regular_11">YES</span>, the Objective-C equivalent of true.</p>&#13;
<p class="TX">The location of the <span class="SANS_TheSansMonoCd_W5Regular_11">shouldBlock:</span> method’s invocation dictates how the flow closes. For example, it’s easy to block a question, as DNSMonitor is really a proxy that is responsible for making the actual connection to the remote DNS server and thus we can close the local flow using the <span class="SANS_TheSansMonoCd_W5Regular_11">closeWriteWithError:</span> method (<a href="chapter13.xhtml#Lis13-15">Listing 13-15</a>).</p>&#13;
<span id="Lis13-15"/>&#13;
<pre><code>BOOL block = [self shouldBlock:parsedPacket];&#13;
if(YES == block) {&#13;
    [flow closeWriteWithError:nil];&#13;
    return;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-15: Closing a local flow</span></p>&#13;
<p class="TX">To block an answer, we should make sure to also clean up the remote connection with the DNS server that provided the answer (<a href="chapter13.xhtml#Lis13-16">Listing 13-16</a>).</p>&#13;
<span id="Lis13-16"/>&#13;
<pre><code>nw_connection_receive(connection, 1, UINT32_MAX, ^(dispatch_data_t content,&#13;
nw_content_context_t context, bool is_complete, nw_error_t receive_error) {&#13;
    ...&#13;
    BOOL block = [self shouldBlock:parsedPacket];&#13;
    if(YES == block) {&#13;
        [flow closeWriteWithError:nil];&#13;
        nw_connection_cancel(connection);&#13;
        return;&#13;
    }&#13;
});&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-16: Closing a remote flow</span></p>&#13;
<p class="TX">DNSMonitor uses the <span class="SANS_TheSansMonoCd_W5Regular_11">nw_connection_receive</span> API to proxy responses. Thus, to block any responses, it first closes the flow and then calls <span class="SANS_TheSansMonoCd_W5Regular_11">nw_connection _cancel</span> to cancel the connection.</p>&#13;
<p class="TX">For completeness, I should mention that you could also handle DNS blocking by returning a response with the response code set to what is known as a <i>name error</i> or, more simply, <span class="SANS_TheSansMonoCd_W5Regular_11">NXDOMAIN</span>. Such a response would tell the requestor that the domain wasn’t found, meaning the resolution failed. DNSMonitor takes this approach when executed with the <span class="SANS_TheSansMonoCd_W5Regular_11">-nx</span> command line option.</p>&#13;
<p class="TX">To generate such a response, you could take the DNS request or response packet and modify the flags in its header in the manner shown in <a href="chapter13.xhtml#Lis13-17">Listing 13-17</a>.</p>&#13;
<span id="Lis13-17"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_310" aria-label="310"/>dns_header_t* header = (dns_header_t *)packet.bytes;&#13;
&#13;
header-&gt;flags |= htons(0x8000);&#13;
header-&gt;flags &amp;= ~htons(0xF);&#13;
header-&gt;flags |= htons(0x3);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-17: Crafting an <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NXDOMAIN</span> response</span></p>&#13;
<p class="TX">The code expects a DNS packet in a mutable data object. It first typecasts the packet’s bytes to a <span class="SANS_TheSansMonoCd_W5Regular_11">dns_header_t</span> pointer. Next, it sets the <span class="SANS_TheSansMonoCd_W5Regular_11">QR</span> bit of the <span class="SANS_TheSansMonoCd_W5Regular_11">flags</span> field in the header to indicate that the packet is a response. Following this, it clears the <span class="SANS_TheSansMonoCd_W5Regular_11">RCODE</span> (response code) bits before setting just the <span class="SANS_TheSansMonoCd_W5Regular_11">NXDOMAIN</span> response code. You can read more about the DNS header and these fields in the RFP 1035 that defines the technical specifications of DNS.<sup><a role="doc-noteref" id="chapter13_6" href="#chapter13-6">6</a></sup></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h1-77"/><span class="SANS_Futura_Std_Bold_B_11">Classifying Endpoints</span></h3>&#13;
<p class="TNI">Instead of using a hardcoded block list, a tool could determine whether to block DNS requests or responses heuristically, for example, by examining historical DNS records, WHOIS data, and any SSL/TLS certificates.<sup><a role="doc-noteref" id="chapter13_7" href="#chapter13-7">7</a></sup> Let’s look at each of these techniques more closely, using the 3CX supply chain attack as an example. The <i>3cx.cloud</i> domain used in the attack is a legitimate part of 3CX’s infrastructure, but the attacker-controlled <i>msstorageboxes.com</i> domain, used by the malicious code introduced into the application, raises some red flags:</p>&#13;
<blockquote>&#13;
<p class="EX1"><b>Historical DNS records</b> At the time of the 3CX supply chain attack in March 2023, only one DNS record existed for the <i>msstorageboxes.com</i> domain, which had been registered just a few months prior. Trusted domains usually have a longer history and many DNS records. On the other hand, hackers often register domains for their command-and-control servers just before their attacks and tear them down shortly thereafter. Of course, hackers sometimes leverage previously legitimate domains that they either bought through standard domain procurement processes or obtained when domain registration lapsed. Again, you’ll see this activity reflected in the domain’s historical DNS records.</p>&#13;
<p class="EX"><b>Redacted WHOIS data</b> The attackers redacted WHOIS data for the <i>msstorageboxes.com</i> domain for privacy reasons. It’s unusual for a large, well-established company to hide its identity. For example, the legitimate 3cx.cloud domain clearly shows that it’s registered to 3CX Software DMCC.</p>&#13;
<p class="EX2"><b>Domain name registrar</b> The attackers registered the <i>msstorageboxes.com</i> domain via NameCheap. Well-established companies often choose more enterprise-focused domain registrars, such as CloudFlare.</p>&#13;
</blockquote>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec10">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_311" aria-label="311"/>&#13;
<h3 class="H1" id="sec10"><span id="h1-78"/><span class="SANS_Futura_Std_Bold_B_11">Conclusion</span></h3>&#13;
<p class="TNI">A DNS monitor capable of tracking all requests and responses is a powerful tool for malware detection. In this chapter, I built on <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span> to describe how you might implement such a monitor atop Apple’s <i>NetworkExtension</i> framework. I showed you how to add capabilities to the tool, such as a cache and blocking capabilities, to extend its functionality.</p>&#13;
<p class="TX">In the book’s final chapter, we’ll pit tools such as this DNS monitor against real-life Mac malware. Read on to see how each side fares!</p>&#13;
</section>&#13;
<section epub:type="rearnotes" role="doc-endnotes" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span class="SANS_Futura_Std_Bold_B_11">Notes</span></h3>&#13;
<ol class="footnotes">&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter13-1" href="#chapter13_1">  1</a></span>.  “Network Extensions Entitlement,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_developer_networking_networkextension"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/bundleresources<wbr/>/entitlements<wbr/>/com<wbr/>_apple<wbr/>_developer<wbr/>_networking<wbr/>_networkextension</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter13-2" href="#chapter13_2">  2</a></span>.  psichel, “com.apple.developer.networking.networkextension Entitlements Don’t Match PP,” Apple Developer Forums, November 15, 2020, <a href="https://developer.apple.com/forums/thread/667045"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/forums<wbr/>/thread<wbr/>/667045</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter13-3" href="#chapter13_3">  3</a></span>.  “Signing a Daemon with a Restricted Entitlement,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/xcode/signing-a-daemon-with-a-restricted-entitlement"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/xcode<wbr/>/signing<wbr/>-a<wbr/>-daemon<wbr/>-with<wbr/>-a<wbr/>-restricted<wbr/>-entitlement</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter13-4" href="#chapter13_4">  4</a></span>.  “Installing System Extensions and Drivers,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/systemextensions/installing-system-extensions-and-drivers?language=objc"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/systemextensions<wbr/>/installing<wbr/>-system<wbr/>-extensions<wbr/>-and<wbr/>-drivers<wbr/>?language<wbr/>=objc</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter13-5" href="#chapter13_5">  5</a></span>.  See <a href="https://github.com/objective-see/LuLu"><i>https://<wbr/>github<wbr/>.com<wbr/>/objective<wbr/>-see<wbr/>/LuLu</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter13-6" href="#chapter13_6">  6</a></span>.  See “Domain Names—Implementation and Specification,” RFC 1035, Internet Engineering Task Force, <a href="https://datatracker.ietf.org/doc/html/rfc1035"><i>https://<wbr/>datatracker<wbr/>.ietf<wbr/>.org<wbr/>/doc<wbr/>/html<wbr/>/rfc1035</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter13-7" href="#chapter13_7">  7</a></span>.  Esteban Borges, “How to Perform Threat Hunting Using Passive DNS,” <i>Security Trails</i>, <a href="https://securitytrails.com/blog/threat-hunting-using-passive-dns"><i>https://<wbr/>securitytrails<wbr/>.com<wbr/>/blog<wbr/>/threat<wbr/>-hunting<wbr/>-using<wbr/>-passive<wbr/>-dns</i></a>.</p></li>&#13;
</ol>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>