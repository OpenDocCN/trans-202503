<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Permissions"><div class="titlepage"><div><div><h1 class="title"><a id="permissions-id00003"/>Chapter 2. Permissions</h1></div></div></div><p><a id="iddle2453" class="indexterm"/><a id="iddle2454" class="indexterm"/>In the previous chapter, we gave an overview of Android’s security model and briefly introduced permissions. In this chapter we’ll provide more details about permissions, focusing on their implementation and enforcement. We will then discuss how to define custom permissions and apply them to each of Android’s components. Finally, we’ll say a few words about <span class="emphasis"><em>pending intents</em></span>, which are tokens that allow an application to start an intent with the identity and privileges of another application.</p><div class="sect1" title="The Nature of Permissions"><div class="titlepage"><div><div><h1 class="title"><a id="nature_of_permissions"/>The Nature of Permissions</h1></div></div></div><p>As we learned in <a class="xref" href="ch01.html" title="Chapter 1. Android’s Security Model">Chapter 1</a>, Android applications are sandboxed and by default can access only their own files and a very limited set of system services. In order to interact with the system and other applications, Android applications can request a set of additional permissions that are granted at install time and cannot be changed (with some exceptions, as we’ll discuss later in this chapter).</p><p><a id="iddle2149" class="indexterm"/><a id="iddle2464" class="indexterm"/><a id="iddle2471" class="indexterm"/><a id="iddle2597" class="indexterm"/>In Android, a <span class="emphasis"><em>permission</em></span> is simply a string denoting the ability to perform a particular operation. The target operation can be anything from accessing a physical resource (such as the device’s SD card) or shared data (such as the list of registered contacts) to the ability to start or access a component in a third-party application. Android comes with a built-in set of predefined permissions. New permissions that correspond to new features are added in each version.</p><div class="note" title="Note"><h3 class="title"><a id="ch02note01"/>Note</h3><p><span class="emphasis"><em>New built-in permissions, which lock down functionality that previously didn’t require a permission, are applied conditionally, depending on the</em></span> targetSdkVersion <span class="emphasis"><em>specified in an app’s manifest: applications targeting Android versions that were released before the new permission was introduced cannot be expected to know about it, and therefore the permission is usually granted implicitly (without being requested). However, implicitly granted permissions are still shown in the list of permissions on the app installer screen so that users can be aware of them. Apps targeting later versions need to explicitly request the new permission.</em></span></p></div><p>Built-in permissions are documented in the platform API reference.<sup>[<a id="ch02fn01" href="#ftn.ch02fn01" class="footnote">11</a>]</sup> Additional permissions, called <span class="emphasis"><em>custom permissions</em></span>, can be defined by both system and user-installed applications.</p><p>To view a list of the permissions currently known to the system, use the <code class="literal">pm list permissions</code> command (see <a class="xref" href="ch02.html#getting_a_list_of_all_permissions" title="Example 2-1. Getting a list of all permissions">Example 2-1</a>). To display additional information about permissions, including the defining package, label, description, and protection level, add the <code class="literal">-f</code> parameter to the command.</p><div class="example"><a id="getting_a_list_of_all_permissions"/><p class="title">Example 2-1. Getting a list of all permissions</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>pm list permissions</strong></span>
All Permissions:

permission:android.permission.REBOOT➊
permission:android.permission.BIND_VPN_SERVICE➋
permission:com.google.android.gallery3d.permission.GALLERY_PROVIDER➌
permission:com.android.launcher3.permission.RECEIVE_LAUNCH_BROADCASTS➍
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>Permission names are typically prefixed with their defining package concatenated with the string <span class="emphasis"><em>.permission</em></span>. Because built-in permissions are defined in the <code class="literal">android</code> package, their names start with <span class="emphasis"><em>android.permission</em></span>. For example, in <a class="xref" href="ch02.html#getting_a_list_of_all_permissions" title="Example 2-1. Getting a list of all permissions">Example 2-1</a>, the <code class="literal">REBOOT</code> ➊ and <code class="literal">BIND_VPN_SERVICE</code> ➋ are built-in permissions, while <code class="literal">GALLERY_PROVIDER</code> ➌ is defined by the Gallery application (package <code class="literal">com.google.android.gallery3d</code>) and <code class="literal">RECEIVE_LAUNCH_BROADCASTS</code> ➍ is defined by the default launcher application (package <code class="literal">com.android.launcher3</code>).</p></div><div class="sect1" title="Requesting Permissions"><div class="titlepage"><div><div><h1 class="title"><a id="requesting_permissions"/>Requesting Permissions</h1></div></div></div><p><a id="iddle1143" class="indexterm"/><a id="iddle1981" class="indexterm"/><a id="iddle3137" class="indexterm"/>Applications request permissions by adding one or more <code class="literal">&lt;uses-permission&gt;</code> tags to their <span class="emphasis"><em>AndroidManifest.xml</em></span> file and can define new permissions with the <code class="literal">&lt;permission&gt;</code> tag. <a class="xref" href="ch02.html#requesting_permissions_using_the_applica" title="Example 2-2. Requesting permissions using the application manifest file">Example 2-2</a> shows an example manifest file that requests the <code class="literal">INTERNET</code> and <code class="literal">WRITE_EXTERNAL_STORAGE</code> permissions. (We show how to define custom permission in “<a class="xref" href="ch02.html#custom_permissions" title="Custom Permissions">Custom Permissions</a>”.)</p><div class="example"><a id="requesting_permissions_using_the_applica"/><p class="title">Example 2-2. Requesting permissions using the application manifest file</p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest 
    
    package="com.example.app"
    android:versionCode="1"
    android:versionName="1.0" &gt;

    &lt;uses-permission android:name="android.permission.INTERNET" /&gt;
    &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
    --<span class="emphasis"><em>snip</em></span>--
    &lt;application android:name="SampleApp" ...&gt;
    --<span class="emphasis"><em>snip</em></span>--
    &lt;/application&gt;
&lt;/manifest&gt;</pre></div></div></div><div class="sect1" title="Permission Management"><div class="titlepage"><div><div><h1 class="title"><a id="permission_management"/>Permission Management</h1></div></div></div><p>Permissions are assigned to each application (as identified by a unique <span class="emphasis"><em>package name</em></span>) at install time by the system <span class="emphasis"><em>package manager</em></span> service. The package manager maintains a central database of installed packages, both preinstalled and user-installed, with information about the install path, version, signing certificate, and assigned permissions of each package, as well as a list of all permissions defined on a device. (The <code class="literal">pm list permissions</code> command introduced in the previous section obtains this list by querying the package manager.) This package database is stored in the XML file <span class="emphasis"><em>/data/system/packages.xml</em></span>, which is updated each time an application is installed, updated, or uninstalled. <a class="xref" href="ch02.html#application_entry_in_packagesdotxml" title="Example 2-3. Application entry in packages.xml">Example 2-3</a> shows a typical application entry from <span class="emphasis"><em>packages.xml</em></span>.</p><div class="example"><a id="application_entry_in_packagesdotxml"/><p class="title">Example 2-3. Application entry in <span class="roman">packages.xml</span></p><div class="example-contents"><pre class="programlisting">&lt;package name="com.google.android.apps.translate"
         codePath="/data/app/com.google.android.apps.translate-2.apk"
         nativeLibraryPath="/data/app-lib/com.google.android.apps.translate-2"
         flags="4767300" ft="1430dfab9e0" it="142cdf04d67" ut="1430dfabd8d"
         version="30000028"
         userId="10204"➊
         installer="com.android.vending"&gt;

    &lt;sigs count="1"&gt;
        &lt;cert index="7" /&gt;➋
    &lt;/sigs&gt;
    &lt;perms&gt;➌
        &lt;item name="android.permission.READ_EXTERNAL_STORAGE" /&gt;
        &lt;item name="android.permission.USE_CREDENTIALS" /&gt;
        &lt;item name="android.permission.READ_SMS" /&gt;
        &lt;item name="android.permission.CAMERA" /&gt;
        &lt;item name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
        &lt;item name="android.permission.INTERNET" /&gt;
        &lt;item name="android.permission.MANAGE_ACCOUNTS" /&gt;
        &lt;item name="android.permission.GET_ACCOUNTS" /&gt;
        &lt;item name="android.permission.ACCESS_NETWORK_STATE" /&gt;
        &lt;item name="android.permission.RECORD_AUDIO" /&gt;
    &lt;/perms&gt;

    &lt;signing-keyset identifier="17" /&gt;
    &lt;signing-keyset identifier="6" /&gt;
&lt;/package&gt;</pre></div></div><p><a id="iddle2324" class="indexterm"/><a id="iddle2459" class="indexterm"/><a id="iddle2460" class="indexterm"/><a id="iddle2524" class="indexterm"/><a id="iddle2525" class="indexterm"/>We discuss the meaning of most tags and attributes in <a class="xref" href="ch03.html" title="Chapter 3. Package Management">Chapter 3</a>, but for now let’s focus on the ones that are related to permissions. Each package is represented by a <code class="literal">&lt;package&gt;</code> element, which contains information about the assigned UID (in the <code class="literal">userId</code> attribute ➊), signing certificate (in the <code class="literal">&lt;cert&gt;</code> tag ➋), and assigned permissions (listed as children of the <code class="literal">&lt;perms&gt;</code> tag ➌). To get information about an installed package programmatically, use the <code class="literal">getPackageInfo()</code> method of the <code class="literal">android.content.pm.PackageManager</code> class, which returns a <code class="literal">PackageInfo</code> instance that encapsulates the information contained in the <code class="literal">&lt;package&gt;</code> tag.</p><p>If all permissions are assigned at install time and cannot be changed or revoked without uninstalling the application, how does the package manager decide whether it should grant the requested permissions? To understand this, we need to discuss permission protection levels.</p></div><div class="sect1" title="Permission Protection Levels"><div class="titlepage"><div><div><h1 class="title"><a id="permission_protection_levels"/>Permission Protection Levels</h1></div></div></div><p>According to the official documentation,<sup>[<a id="ch02fn02" href="#ftn.ch02fn02" class="footnote">12</a>]</sup> a permission’s <span class="emphasis"><em>protection level</em></span> “characterizes the potential risk implied in the permission and indicates the procedure that the system should follow when determining whether or not to grant the permission.” In practice, this means that whether a permission is granted or not depends on its protection level. The following sections discuss the four protection levels defined in Android and how the system handles each.</p><div class="sect2" title="normal"><div class="titlepage"><div><div><h2 class="title"><a id="normal"/>normal</h2></div></div></div><p>This is the default value. It defines a permission with low risk to the system or other applications. Permissions with protection level <span class="emphasis"><em>normal</em></span> are <a id="iddle1311" class="indexterm"/><a id="iddle1518" class="indexterm"/><a id="iddle1906" class="indexterm"/><a id="iddle2458" class="indexterm"/><a id="iddle2523" class="indexterm"/><a id="iddle2570" class="indexterm"/>automatically granted without requiring user confirmation. Examples are <code class="literal">ACCESS_NETWORK_STATE</code> (allows applications to access information about networks) and <code class="literal">GET_ACCOUNTS</code> (allows access to the list of accounts in the Accounts Service).</p></div><div class="sect2" title="dangerous"><div class="titlepage"><div><div><h2 class="title"><a id="dangerous"/>dangerous</h2></div></div></div><p>Permissions with the <span class="emphasis"><em>dangerous</em></span> protection level give access to user data or some form of control over the device. Examples are <code class="literal">READ_SMS</code> (allows an application to read SMS messages) and <code class="literal">CAMERA</code> (gives applications access to the camera device). Before granting dangerous permissions, Android shows a confirmation dialog that displays information about the requested permissions. Because Android requires that all requested permission be granted at install time, the user can either agree to install the app, thus granting the requested <span class="emphasis"><em>dangerous</em></span> permission(s), or cancel the application install. For example, for the application shown in <a class="xref" href="ch02.html#application_entry_in_packagesdotxml" title="Example 2-3. Application entry in packages.xml">Example 2-3</a> (Google Translate), the system confirmation dialog will look like the one shown in <a class="xref" href="ch02.html#default_android_application_install_conf" title="Figure 2-1. Default Android application install confirmation dialog">Figure 2-1</a>.</p><p>Google Play and other application market clients display their own dialog, which is typically styled differently. For the same application, the Google Play Store client displays the dialog shown in <a class="xref" href="ch02.html#google_play_store_client_application_ins" title="Figure 2-2. Google Play Store client application install confirmation dialog">Figure 2-2</a>. Here, all <span class="emphasis"><em>dangerous</em></span> permissions are organized by permission group (see “<a class="xref" href="ch02.html#system_permissions" title="System Permissions">System Permissions</a>”) and normal permissions are not displayed.</p><div class="figure"><a id="default_android_application_install_conf"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00004"/><img src="figs/web/02fig01.png.jpg" alt="Default Android application install confirmation dialog"/></div></div><p class="title">Figure 2-1. Default Android application install confirmation dialog</p></div><div class="figure"><a id="google_play_store_client_application_ins"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00005"/><img src="figs/web/02fig02.png.jpg" alt="Google Play Store client application install confirmation dialog"/></div></div><p class="title">Figure 2-2. Google Play Store client application install confirmation dialog</p></div></div><div class="sect2" title="signature"><div class="titlepage"><div><div><h2 class="title"><a id="signature"/>signature</h2></div></div></div><p><a id="iddle1008" class="indexterm"/><a id="iddle1234" class="indexterm"/><a id="iddle2269" class="indexterm"/><a id="iddle2444" class="indexterm"/><a id="iddle2461" class="indexterm"/><a id="iddle2462" class="indexterm"/><a id="iddle2527" class="indexterm"/><a id="iddle2528" class="indexterm"/><a id="iddle2829" class="indexterm"/><a id="iddle2833" class="indexterm"/>A <span class="emphasis"><em>signature</em></span> permission is only granted to applications that are signed with the same key as the application that declared the permission. This is the “strongest” permission level because it requires the possession of a cryptographic key, which only the app (or platform) owner controls. Thus, applications using <span class="emphasis"><em>signature</em></span> permissions are typically controlled by the same author. Built-in signature permissions are typically used by system applications that perform device management tasks. Examples are <code class="literal">NET_ADMIN</code> (configure network interfaces, IPSec, and so on) and <code class="literal">ACCESS_ALL_EXTERNAL_STORAGE</code> (access all multi-user external storage). We’ll discuss <span class="emphasis"><em>signature</em></span> permissions in more detail in “<a class="xref" href="ch02.html#signature_permissions" title="Signature Permissions">Signature Permissions</a>”.</p></div><div class="sect2" title="signatureOrSystem"><div class="titlepage"><div><div><h2 class="title"><a id="signatureorsystem"/>signatureOrSystem</h2></div></div></div><p>Permissions with this protection level are somewhat of a compromise: they are granted to applications that are either part of the system image, or that are signed with the same key as the app that declared the permission. This allows vendors that have their applications preinstalled on an Android device to share specific features that require a permission without having to share signing keys. Until Android 4.3, any application installed on the <span class="emphasis"><em>system</em></span> partition was granted <span class="emphasis"><em>signatureOrSystem</em></span> permissions automatically. Since Android 4.4, applications need to be installed in the <span class="emphasis"><em>/system/priv-app/</em></span> directory in order to be granted permissions with this protection level.</p></div></div><div class="sect1" title="Permission Assignment"><div class="titlepage"><div><div><h1 class="title"><a id="permission_assignment"/>Permission Assignment</h1></div></div></div><p>Permissions are enforced at various layers in Android. Higher-level components such as applications and system services query the package manager to determine which permissions have been assigned to an application and decide whether to grant access. Lower-level components like native daemons typically do not have access to the package manager and rely on the UID, GID, and supplementary GIDs assigned to a process in order to determine which privileges to grant it. Access to system resources like device files, Unix domain sockets (local sockets), and network sockets is regulated by the kernel based on the owner and access mode of the target resource and the UID and GIDs of the accessing process.</p><p>We’ll look into framework-level permission enforcement in “<a class="xref" href="ch02.html#permission_enforcement" title="Permission Enforcement">Permission Enforcement</a>”. Let’s first discuss how permissions are mapped to OS-level constructs such as UID and GIDs and how these process IDs are used for permission enforcement.</p><div class="sect2" title="Permissions and Process Attributes"><div class="titlepage"><div><div><h2 class="title"><a id="permissions_and_process_attributes"/>Permissions and Process Attributes</h2></div></div></div><p>As in any Linux system, Android processes have a number of associated process attributes, most importantly real and effective UID and GID, and a set of supplementary GIDs.</p><p>As discussed in <a class="xref" href="ch01.html" title="Chapter 1. Android’s Security Model">Chapter 1</a>, each Android application is assigned a unique UID at install time and executes in a dedicated process. When the <a id="iddle1011" class="indexterm"/><a id="iddle1889" class="indexterm"/><a id="iddle2222" class="indexterm"/><a id="iddle2964" class="indexterm"/>application is started, the process’s UID and GID are set to the application UID assigned by the installer (the package manager service). If additional permissions have been assigned to the application, they are mapped to GIDs and assigned as supplementary GIDs to the process. Permission to GID mappings for built-in permissions are defined in the <span class="emphasis"><em>/etc/permission/ platform.xml</em></span> file. <a class="xref" href="ch02.html#permission_to_gid_mapping_in_platformdot" title="Example 2-4. Permission to GID mapping in platform.xml">Example 2-4</a> shows an excerpt from the <span class="emphasis"><em>platform.xml</em></span> file found on an Android 4.4 device.</p><div class="example"><a id="permission_to_gid_mapping_in_platformdot"/><p class="title">Example 2-4. Permission to GID mapping in <span class="roman">platform.xml</span></p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;permissions&gt;
    --<span class="emphasis"><em>snip</em></span>--
    &lt;permission name="android.permission.INTERNET" &gt;➊
        &lt;group gid="inet" /&gt;
    &lt;/permission&gt;

    &lt;permission name="android.permission.WRITE_EXTERNAL_STORAGE" &gt;➋
        &lt;group gid="sdcard_r" /&gt;
        &lt;group gid="sdcard_rw" /&gt;
    &lt;/permission&gt;

    &lt;assign-permission name="android.permission.MODIFY_AUDIO_SETTINGS"
                                                  uid="media" /&gt;➌
    &lt;assign-permission name="android.permission.ACCESS_SURFACE_FLINGER"
                                                  uid="media" /&gt;➍
    --<span class="emphasis"><em>snip</em></span>--
&lt;/permissions&gt;</pre></div></div><p>Here, the <code class="literal">INTERNET</code> permission is associated with the <span class="emphasis"><em>inet</em></span> GID ➊, and the <code class="literal">WRITE_EXTERNAL_STORAGE</code> permission is associated with the <span class="emphasis"><em>sdcard_r</em></span> and <span class="emphasis"><em>sdcard_rw</em></span> GIDs ➋. Thus any process for an app that has been granted the <code class="literal">INTERNET</code> permission is associated with the supplementary GID corresponding to the <span class="emphasis"><em>inet</em></span> group, and processes with the <code class="literal">WRITE_EXTERNAL_STORAGE</code> permission have the GIDs of <span class="emphasis"><em>sdcard_r</em></span> and <span class="emphasis"><em>sdcard_rw</em></span> added to the list of associated supplementary GIDs.</p><p>The <code class="literal">&lt;assign-permission&gt;</code> tag serves the opposite purpose: it is used to assign higher-level permissions to system processes running under a specific UID that do not have a corresponding package. <a class="xref" href="ch02.html#permission_to_gid_mapping_in_platformdot" title="Example 2-4. Permission to GID mapping in platform.xml">Example 2-4</a> shows that processes running with the <span class="emphasis"><em>media</em></span> UID (in practice, this is the <span class="emphasis"><em>mediaserver</em></span> daemon) are assigned the <code class="literal">MODIFY_AUDIO_SETTINGS</code> ➌ and <code class="literal">ACCESS_SURFACE_FLINGER</code> ➍ permissions.</p><p>Android does not have an <span class="emphasis"><em>/etc/group</em></span> file, so the mapping from group names to GIDs is static and defined in the <span class="emphasis"><em>android_filesystem_config.h</em></span> header file. <a class="xref" href="ch02.html#static_user_and_group_name_to_uidsolidus" title="Example 2-5. Static user and group name to UID/GID mapping in android_filesystem_config.h">Example 2-5</a> shows an excerpt containing the <span class="emphasis"><em>sdcard_rw</em></span> ➊, <span class="emphasis"><em>sdcard_r</em></span> ➋, and <span class="emphasis"><em>inet</em></span> ➌ groups.</p><div class="example"><a id="static_user_and_group_name_to_uidsolidus"/><p class="title">Example 2-5. Static user and group name to UID/GID mapping in <span class="roman">android_filesystem_config.h</span></p><div class="example-contents"><pre class="programlisting">--<span class="emphasis"><em>snip</em></span>-
#define AID_ROOT              0  /* traditional unix root user */
#define AID_SYSTEM         1000  /* system server */
--<span class="emphasis"><em>snip</em></span>--
#define AID_SDCARD_RW      1015  /* external storage write access */
#define AID_SDCARD_R       1028  /* external storage read access */
#define AID_SDCARD_ALL     1035  /* access all users external storage */
--<span class="emphasis"><em>snip</em></span>--
#define AID_INET           3003  /* can create AF_INET and AF_INET6 sockets */
--<span class="emphasis"><em>snip</em></span>--

struct android_id_info {
    const char *name;
    unsigned aid;
};

static const struct android_id_info android_ids[] = {
    { "root",          AID_ROOT, },
    { "system",        AID_SYSTEM, },
    --<span class="emphasis"><em>snip</em></span>--
    { "sdcard_rw",     AID_SDCARD_RW, },➊
    { "sdcard_r",      AID_SDCARD_R, },➋
    { "sdcard_all",    AID_SDCARD_ALL, },
    --<span class="emphasis"><em>snip</em></span>--
    { "inet",          AID_INET, },➌
};</pre></div></div><p><a id="iddle1826" class="indexterm"/><a id="iddle2456" class="indexterm"/><a id="iddle2476" class="indexterm"/><a id="iddle2518" class="indexterm"/><a id="iddle3164" class="indexterm"/>The <span class="emphasis"><em>android_filesystem_config.h</em></span> file also defines the owner, access mode, and associated capabilities (for executables) of core Android system directories and files.</p><p>The package manager reads <span class="emphasis"><em>platform.xml</em></span> at startup and maintains a list of permissions and associated GIDs. When it grants permissions to a package during installation, the package manager checks whether each permission has an associated GID(s). If so, the GID(s) is added to the list of supplementary GIDs associated with the application. The supplementary GID list is written as the last field of the <span class="emphasis"><em>packages.list</em></span> file (see <a class="xref" href="ch01.html#uid_corresponding_to_each_application_is" title="Example 1-6. The UID corresponding to each application is stored in /data/system/packages.list">Example 1-6</a>).</p><div class="sect3" title="Process Attribute Assignment"><div class="titlepage"><div><div><h3 class="title"><a id="process_attribute_assignment"/>Process Attribute Assignment</h3></div></div></div><p>Before we see how the kernel and lower-level system services check and enforce permissions, we need to examine how Android application processes are started and assigned process attributes.</p><p>As discussed in <a class="xref" href="ch01.html" title="Chapter 1. Android’s Security Model">Chapter 1</a>, Android applications are implemented in Java and are executed by the Dalvik VM. Thus each application process is in fact a Dalvik VM process executing the application’s bytecode. In order to reduce the application memory footprint and improve startup time, Android does not start a new Dalvik VM process for each application. Instead, it uses a partially initialized process called <span class="emphasis"><em>zygote</em></span> and forks it (using the <code class="literal">fork()</code> system call<sup>[<a id="ch02fn03" href="#ftn.ch02fn03" class="footnote">13</a>]</sup>) when it needs to start a new application. However, instead of calling one of the <code class="literal">exec()</code> functions like it does when starting a native process, it merely executes the <code class="literal">main()</code> function of the specified Java class. This process is called <span class="emphasis"><em>specialization</em></span>, because the generic <span class="emphasis"><em>zygote</em></span> process is turned into a specific application process, much like cells originating from the zygote cell specialize into cells that perform different functions. Thus the forked process inherits the memory image of the <span class="emphasis"><em>zygote</em></span> process, which has preloaded most core and application framework Java classes. Because those classes never change and Linux uses a copy-on-write mechanism when forking processes, all child processes of <span class="emphasis"><em>zygote</em></span> (that is, all Android applications) share the same copy of framework Java classes.</p><p>The <span class="emphasis"><em>zygote</em></span> process is started by the <span class="emphasis"><em>init.rc</em></span> initialization script and receives commands on a Unix-domain socket, also named <span class="emphasis"><em>zygote</em></span>. When <span class="emphasis"><em>zygote</em></span> receives a request to start a new application process, it forks itself, and the child process executes roughly the following code (abbreviated from <code class="literal">forkAndSpecializeCommon()</code> in <span class="emphasis"><em>dalvik_system_Zygote.cpp</em></span>) in order to specialize itself as shown in <a class="xref" href="ch02.html#application_process_specialization_in_zy" title="Example 2-6. Application process specialization in zygote">Example 2-6</a>.</p><div class="example"><a id="application_process_specialization_in_zy"/><p class="title">Example 2-6. Application process specialization in <span class="roman">zygote</span></p><div class="example-contents"><pre class="programlisting">pid = fork();

if (pid == 0) {
    int err;
    /* The child process */
    err = setgroupsIntarray(gids);➊
    err = setrlimitsFromArray(rlimits);➋
    err = setresgid(gid, gid, gid);➌
    err = setresuid(uid, uid, uid);➍
    err = setCapabilities(permittedCapabilities, effectiveCapabilities);➎
    err = set_sched_policy(0, SP_DEFAULT);➏
    err = setSELinuxContext(uid, isSystemServer, seInfo, niceName);➐
    enableDebugFeatures(debugFlags);➑
}</pre></div></div><p>As shown here, the child process first sets its supplementary GIDs (corresponding to permissions) using <code class="literal">setgroups()</code>, called by <code class="literal">setgroupsIntarray()</code> at ➊. Next, it sets resource limits using <code class="literal">setrlimit()</code>, called by <code class="literal">setrlimitsFromArray()</code> at ➋, then sets the real, effective, and saved user and group IDs using <code class="literal">setresgid()</code> ➌ and <code class="literal">setresuid()</code> ➍.</p><p>The child process is able to change its resource limits and all process attributes because it initially executes as root, just like its parent process, <span class="emphasis"><em>zygote</em></span>. After the new process attributes are set, the child process executes with the assigned UIDs and GIDs and cannot go back to executing as root because the saved user ID is not 0.</p><p>After setting the UIDs and GIDs, the process sets its capabilities<sup>[<a id="ch02fn04" href="#ftn.ch02fn04" class="footnote">14</a>]</sup> using <code class="literal">capset()</code>, called from <code class="literal">setCapabilities()</code> ➎. Then, it sets its scheduling policy <a id="iddle1734" class="indexterm"/><a id="iddle2062" class="indexterm"/><a id="iddle2450" class="indexterm"/><a id="iddle2723" class="indexterm"/>by adding itself to one of the predefined control groups ➏.<sup>[<a id="ch02fn05" href="#ftn.ch02fn05" class="footnote">15</a>]</sup> At ➐, the process sets its nice name (displayed in the process list, typically the application’s package name) and <span class="emphasis"><em>seinfo</em></span> tag (used by SELinux, which we discuss in <a class="xref" href="ch12.html" title="Chapter 12. Selinux">Chapter 12</a>). Finally, it enables debugging if requested ➑.</p><div class="note" title="Note"><h3 class="title"><a id="ch02note02"/>Note</h3><p><span class="emphasis"><em>Android 4.4 introduces a new, experimental runtime called Android RunTime (ART), which is expected to replace Dalvik in a future version. While ART brings many changes to the current execution environment, most importantly ahead-of-time (AOT) compilation, it uses the same zygote-based app process execution model as Dalvik.</em></span></p></div><p>The process relationship between <span class="emphasis"><em>zygote</em></span> and application process is evident in the process list obtained with the <code class="literal">ps</code> command, as shown in <a class="xref" href="ch02.html#zygote_and_application_process_relations" title="Example 2-7. zygote and application process relationship">Example 2-7</a>.</p><div class="example"><a id="zygote_and_application_process_relations"/><p class="title">Example 2-7. <span class="roman">zygote</span> and application process relationship</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>ps</strong></span>
USER      PID   PPID  VSIZE  RSS     WCHAN    PC         NAME
root       1     0     680    540   ffffffff 00000000 S /init➊
--<span class="emphasis"><em>snip</em></span>--
root       181   1     858808 38280 ffffffff 00000000 S zygote➋
--<span class="emphasis"><em>snip</em></span>--
radio      1139  181   926888 46512 ffffffff 00000000 S com.android.phone
nfc        1154  181   888516 36976 ffffffff 00000000 S com.android.nfc
u0_a7      1219  181   956836 48012 ffffffff 00000000 S com.google.android.gms</pre></div></div><p>Here, the PID column denotes the process ID, the PPID column denotes the parent process ID, and the NAME column denotes the process name. As you can see, <span class="emphasis"><em>zygote</em></span> (PID 181 ➋) is started by the <span class="emphasis"><em>init</em></span> process (PID 1 ➊) and all application processes have <span class="emphasis"><em>zygote</em></span> as their parent (PPID 181). Each process executes under a dedicated user, either built-in (<span class="emphasis"><em>radio</em></span>, <span class="emphasis"><em>nfc</em></span>), or automatically assigned (<span class="emphasis"><em>u0_a7</em></span>) at install time. The process names are set to the package name of each application (<code class="literal">com.android.phone</code>, <code class="literal">com.android.nfc</code>, and <code class="literal">com.google.android.gms</code>).</p></div></div></div><div class="sect1" title="Permission Enforcement"><div class="titlepage"><div><div><h1 class="title"><a id="permission_enforcement"/>Permission Enforcement</h1></div></div></div><p>As discussed in the previous section, each application process is assigned a UID, GID, and supplementary GIDs when it is forked from <span class="emphasis"><em>zygote</em></span>. The kernel and system daemons use these process identifiers to decide whether to grant access to a particular system resource or function.</p><div class="sect2" title="Kernel-Level Enforcement"><div class="titlepage"><div><div><h2 class="title"><a id="kernel-level_enforcement"/>Kernel-Level Enforcement</h2></div></div></div><p>Access to regular files, device nodes, and local sockets is regulated just as it is in any Linux system. One Android-specific addition is requiring processes that want to create network sockets to belong to the group <span class="emphasis"><em>inet</em></span>. This Android kernel addition is known as “paranoid network security” and is implemented as an additional check in the Android kernel, as shown in <a class="xref" href="ch02.html#paranoid_network_security_implementation" title="Example 2-8. Paranoid network security implementation in the Android kernel">Example 2-8</a>.</p><div class="example"><a id="paranoid_network_security_implementation"/><p class="title">Example 2-8. Paranoid network security implementation in the Android kernel</p><div class="example-contents"><pre class="programlisting">#ifdef CONFIG_ANDROID_PARANOID_NETWORK
#include &lt;linux/android_aid.h&gt;

static inline int current_has_network(void)
{        return in_egroup_p(AID_INET) || capable(CAP_NET_RAW);➊}
#else
static inline int current_has_network(void)
{        return 1;➋
}
#endif
--<span class="emphasis"><em>snip</em></span>--
static int inet_create(struct net *net, struct socket *sock, int protocol,
                                                     int kern)
{
        --<span class="emphasis"><em>snip</em></span>--
        if (!current_has_network())
                 return -EACCES;➌
        --<span class="emphasis"><em>snip</em></span>--
}</pre></div></div><p><a id="iddle1317" class="indexterm"/><a id="iddle1318" class="indexterm"/><a id="iddle1412" class="indexterm"/><a id="iddle1512" class="indexterm"/><a id="iddle1735" class="indexterm"/><a id="iddle2451" class="indexterm"/>Caller processes that do not belong to the <code class="literal">AID_INET</code> (GID 3003, name <span class="emphasis"><em>inet</em></span>) group and do not have the <code class="literal">CAP_NET_RAW</code> capability (allowing the use of RAW and PACKET sockets) receive an access denied error (➊ and ➌). NonAndroid kernels do not define <code class="literal">CONFIG_ANDROID_PARANOID_NETWORK</code> and thus no special group membership is required to create a socket ➋. In order for the <span class="emphasis"><em>inet</em></span> group to be assigned to an application process, it needs to be granted the <code class="literal">INTERNET</code> permission. As a result, only applications with the <code class="literal">INTERNET</code> per-mission can create network sockets. In addition to checking process credentials when creating sockets, Android kernels also grant certain capabilities to processes executing with specific GIDs: processes that execute with the <code class="literal">AID_NET_RAW</code> (GID 3004) are given the <code class="literal">CAP_NET_RAW</code> capability, and those executing with <code class="literal">AID_NET_ADMIN</code> (GID 3005) are given the <code class="literal">CAP_NET_ADMIN</code> capability.</p><p>Paranoid network security is also used to control access to Bluetooth sockets and the kernel tunneling driver (used for VPN). A full list of Android GIDs that the kernel treats in a special way can be found in the <span class="emphasis"><em>include/linux/android_aid.h</em></span> file in the kernel source tree.</p></div><div class="sect2" title="Native Daemon-Level Enforcement"><div class="titlepage"><div><div><h2 class="title"><a id="native_daemon-level_enforcement"/>Native Daemon-Level Enforcement</h2></div></div></div><p>While Binder is the preferred IPC mechanism in Android, lower-level native daemons often use Unix domain sockets (local sockets) for IPC. Because Unix domain sockets are represented as nodes on the filesystem, standard filesystem permission can be used to control access.</p><p>As most sockets are created with an access mode that only allows access to their owner and group, clients running under a different UID and GID cannot connect to the socket. Local sockets for system daemons are defined <a id="iddle1395" class="indexterm"/><a id="iddle1451" class="indexterm"/><a id="iddle2655" class="indexterm"/><a id="iddle2852" class="indexterm"/>in <span class="emphasis"><em>init.rc</em></span> and created by <span class="emphasis"><em>init</em></span> on startup with the specified access mode. For example, <a class="xref" href="ch02.html#vold_daemon_entry_in_initdotrc" title="Example 2-9. vold daemon entry in init.rc">Example 2-9</a> shows how the volume management daemon (<span class="emphasis"><em>vold</em></span>) is defined in <span class="emphasis"><em>init.rc</em></span>:</p><div class="example"><a id="vold_daemon_entry_in_initdotrc"/><p class="title">Example 2-9. <span class="roman">vold</span> daemon entry in <span class="roman">init.rc</span></p><div class="example-contents"><pre class="programlisting">service vold /system/bin/vold
    class core
    socket vold stream 0660 root mount➊
    ioprio be 2</pre></div></div><p><span class="emphasis"><em>vold</em></span> declares a socket called <span class="emphasis"><em>vold</em></span> with the 0660 access mode, owned by <span class="emphasis"><em>root</em></span> and with group set to <span class="emphasis"><em>mount</em></span> ➊. The <span class="emphasis"><em>vold</em></span> daemon needs to run as root in order to mount or unmount volumes, but members of the <span class="emphasis"><em>mount</em></span> group (<code class="literal">AID_MOUNT</code>, GID 1009) can send it commands via the local socket without needing to run as the superuser. Local sockets for Android daemons are created in the <span class="emphasis"><em>/dev/socket/</em></span> directory. <a class="xref" href="ch02.html#local_sockets_for_core_system_daemons_in" title="Example 2-10. Local sockets for core system daemons in /dev/socket/">Example 2-10</a> shows that the <span class="emphasis"><em>vold</em></span> socket ➊ has the owner and permission specified in <span class="emphasis"><em>init.rc</em></span>.</p><div class="example"><a id="local_sockets_for_core_system_daemons_in"/><p class="title">Example 2-10. Local sockets for core system daemons in <span class="roman">/dev/socket/</span></p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>ls -l /dev/socket</strong></span>

srw-rw---- system   system             1970-01-18 14:26 adbd
srw------- system   system             1970-01-18 14:26 installd
srw-rw---- root     system             1970-01-18 14:26 netd
--<span class="emphasis"><em>snip</em></span>--
srw-rw-rw- root     root               1970-01-18 14:26 property_service
srw-rw---- root     radio              1970-01-18 14:26 rild
srw-rw---- root     mount              1970-01-18 14:26 vold➊
srw-rw---- root     system             1970-01-18 14:26 zygote</pre></div></div><p>Unix domain sockets allow the passing and querying of client credentials using the <code class="literal">SCM_CREDENTIALS</code> control message and the <code class="literal">SO_PEERCRED</code> socket option. Like the effective UID and effective GUID that are part of a Binder transaction, the peer credentials associated with a local socket are checked by the kernel and cannot be forged by user-level processes. This allows native daemons to implement additional, fine-grained control over the operations that they allow for a particular client, as shown in <a class="xref" href="ch02.html#fine-grained_access_control_based_on_soc" title="Example 2-11. Fine-grained access control based on socket client credentials in vold">Example 2-11</a> using the <span class="emphasis"><em>vold</em></span> daemon as an example.</p><div class="example"><a id="fine-grained_access_control_based_on_soc"/><p class="title">Example 2-11. Fine-grained access control based on socket client credentials in <span class="roman">vold</span></p><div class="example-contents"><pre class="programlisting">int CommandListener::CryptfsCmd::runCommand(SocketClient *cli,
                                                      int argc, char **argv) {
    if ((cli-&gt;getUid() != 0) &amp;&amp; (cli-&gt;getUid() != AID_SYSTEM)) {➊
        cli-&gt;sendMsg(ResponseCode::CommandNoPermission,
               "No permission to run cryptfs commands", false);
        return 0;
    }
    --<span class="emphasis"><em>snip</em></span>--
}</pre></div></div><p><a id="iddle2449" class="indexterm"/>The <span class="emphasis"><em>vold</em></span> daemon only allows encrypted container management commands to clients running as the <span class="emphasis"><em>root</em></span> (UID 0) or <span class="emphasis"><em>system</em></span> (<code class="literal">AID_SYSTEM</code>, UID 1000) users. Here, the UID returned by <code class="literal">SocketClient-&gt;getUid()</code> ➊ is initialized with the client UID obtained using <code class="literal">getsockopt(SO_PEERCRED)</code> as shown in <a class="xref" href="ch02.html#obtaining_local_socket_client_credential" title="Example 2-12. Obtaining local socket client credentials using getsockopt()">Example 2-12</a> at ➊.</p><div class="example"><a id="obtaining_local_socket_client_credential"/><p class="title">Example 2-12. Obtaining local socket client credentials using <code class="literal">getsockopt()</code></p><div class="example-contents"><pre class="programlisting">void SocketClient::init(int socket, bool owned, bool useCmdNum) {
    --<span class="emphasis"><em>snip</em></span>--
    struct ucred creds;
    socklen_t szCreds = sizeof(creds);
    memset(&amp;creds, 0, szCreds);

    int err = getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &amp;creds, &amp;szCreds);➊
    if (err == 0) {
        mPid = creds.pid;
        mUid = creds.uid;
        mGid = creds.gid;
    }
}</pre></div></div><p>Local socket connection functionality is encapsulated in the <code class="literal">android.net.LocalSocket</code> class and is available to Java applications as well, allowing higher-level system services to communicate with native daemons without using JNI code. For example, the <code class="literal">MountService</code> framework class uses <code class="literal">LocalSocket</code> to send commands to the <span class="emphasis"><em>vold</em></span> daemon.</p></div><div class="sect2" title="Framework-Level Enforcement"><div class="titlepage"><div><div><h2 class="title"><a id="framework-level_enforcement"/>Framework-Level Enforcement</h2></div></div></div><p>As discussed in the introduction to Android permissions, access to Android components can be controlled using permissions by declaring the required permissions in the manifest of the enclosing application. The system keeps track of the permissions associated with each component and checks to see whether callers have been granted the required permissions before allowing access. Because components cannot change the permissions they require at runtime, enforcement by the system is <span class="emphasis"><em>static</em></span>. Static permissions are an example of declarative security. When using declarative security, security attributes such as roles and permissions are placed in the metadata of a component (the <span class="emphasis"><em>AndroidManifest.xml</em></span> file in Android), rather than in the component itself, and are enforced by the container or runtime environment. This has the advantage of isolating security decisions from business logic but can be less flexible than implementing securing checks within the component.</p><p>Android components can also check to see whether a calling process has been granted a certain permission without declaring the permissions in the manifest. This <span class="emphasis"><em>dynamic permission enforcement</em></span> requires more work but allows for more fine-grained access control. Dynamic permission enforcement is an example of imperative security, because security decisions are made by each component rather than being enforced by the runtime environment.</p><p><a id="iddle1271" class="indexterm"/><a id="iddle1730" class="indexterm"/><a id="iddle1833" class="indexterm"/><a id="iddle2441" class="indexterm"/><a id="iddle2442" class="indexterm"/>Let’s look at how dynamic and static permission enforcement are implemented in more detail.</p><div class="sect3" title="Dynamic Enforcement"><div class="titlepage"><div><div><h3 class="title"><a id="dynamic_enforcement"/>Dynamic Enforcement</h3></div></div></div><p>As discussed in <a class="xref" href="ch01.html" title="Chapter 1. Android’s Security Model">Chapter 1</a>, the core of Android is implemented as a set of cooperating system services that can be called from other processes using the Binder IPC mechanism. Core services register with the service manager and any application that knows their registration name can obtain a Binder reference. Because Binder does not have a built-in access control mechanism, when clients have a reference they can call any method of the underlying system service by passing the appropriate parameters to <code class="literal">Binder.transact()</code>. Therefore, access control needs to be implemented by each system service.</p><p>In <a class="xref" href="ch01.html" title="Chapter 1. Android’s Security Model">Chapter 1</a>, we showed that system services can regulate access to exported operations by directly checking the UID of the caller obtained from <code class="literal">Binder.getCallingUid()</code> (see <a class="xref" href="ch01.html#checking_that_the_caller_is_running_with" title="Example 1-8. Checking that the caller is running with the system UID">Example 1-8</a>). However, this method requires that the service knows the list of allowed UIDs in advance, which only works for well-known fixed UIDs such as those of <span class="emphasis"><em>root</em></span> (UID 0) and <span class="emphasis"><em>system</em></span> (UID 1000). Also, most services do not care about the actual UID of the caller; they simply want to check if it has been granted a certain permission.</p><p>Because each application UID in Android is associated with a unique package (unless it is part of a shared user ID), and the package manager keeps track of the permissions granted to each package, this is made possible by querying the package manager service. Checking to see whether the caller has a certain permission is a very common operation, and Android provides a number of helper methods in the <code class="literal">android.content.Context</code> class that can perform this check.</p><p>Let’s first examine how the <code class="literal">int Context.checkPermission(String permission, int pid, int uid)</code> method works. This method returns <code class="literal">PERMISSION_GRANTED</code> if the passed UID has the permission, and returns <code class="literal">PERMISSION_DENIED</code> otherwise. If the caller is <span class="emphasis"><em>root</em></span> or <span class="emphasis"><em>system</em></span>, the permission is automatically granted. As a performance optimization, if the requested permission has been declared by the calling app, it is granted without examining the actual permission. If that is not the case, the method checks to see whether the target component is public (exported) or private, and denies access to all private components. (We’ll discuss component export in “<a class="xref" href="ch02.html#public_and_private_components" title="Public and Private Components">Public and Private Components</a>”.) Finally, the code queries the package manager service to see if the caller has been granted the requested permission. The relevant code from the <code class="literal">PackageManagerService</code> class is shown in <a class="xref" href="ch02.html#uid-based_permission_check_in_packageman" title="Example 2-13. UID-based permission check in PackageManagerService">Example 2-13</a>.</p><div class="example"><a id="uid-based_permission_check_in_packageman"/><p class="title">Example 2-13. UID-based permission check in <code class="literal">PackageManagerService</code></p><div class="example-contents"><pre class="programlisting">public int checkUidPermission(String permName, int uid) {
    synchronized (mPackages) {
        Object obj = mSettings.getUserIdLPr(➊UserHandle.getAppId(uid));
        if (obj != null) {
            GrantedPermissions gp = (GrantedPermissions)obj;➋
            if (gp.grantedPermissions.contains(permName)) {
                return PackageManager.PERMISSION_GRANTED;
            }
        } else {
            HashSet&lt;String&gt; perms = mSystemPermissions.get(uid);➌
            if (perms != null &amp;&amp; perms.contains(permName)) {
                return PackageManager.PERMISSION_GRANTED;
            }
        }
    }
    return PackageManager.PERMISSION_DENIED;
}</pre></div></div><p><a id="iddle1371" class="indexterm"/><a id="iddle1736" class="indexterm"/><a id="iddle1911" class="indexterm"/><a id="iddle2396" class="indexterm"/>Here the <code class="literal">PackageManagerService</code> first determines the <span class="emphasis"><em>app ID</em></span> of the application based on the passed UID ➊ (the same application can be assigned multiple UIDs when installed for different users, which we discuss in detail in <a class="xref" href="ch04.html" title="Chapter 4. User Management">Chapter 4</a>) and then obtains the set of granted permissions. If the <code class="literal">GrantedPermission</code> class (which holds the actual <code class="literal">java.util.Set&lt;String&gt;</code> of permission names) contains the target permission, the method returns <code class="literal">PERMISSION_GRANTED</code> ➋. If not, it checks whether the target permission should be automatically assigned to the passed-in UID ➌ (based on the <code class="literal">&lt;assign-permission&gt;</code> tags in <code class="literal">platform.xml</code>, as shown in <a class="xref" href="ch02.html#permission_to_gid_mapping_in_platformdot" title="Example 2-4. Permission to GID mapping in platform.xml">Example 2-4</a>). If this check fails as well, it finally returns <code class="literal">PERMISSION_DENIED</code>.</p><p>The other permission-check helper methods in the <code class="literal">Context</code> class follow the same procedure. The <code class="literal">int checkCallingOrSelfPermission(String permission)</code> method calls <code class="literal">Binder.getCallingUid()</code> and <code class="literal">Binder.getCallingPid()</code> for us, and then calls <code class="literal">checkPermission(String permission, int pid, int uid)</code> using the obtained values. The <code class="literal">enforcePermission(String permission, int pid, int uid, String message)</code> method does not return a result but instead throws a <code class="literal">SecurityException</code> with the specified message if the permission is not granted. For example, the <code class="literal">BatterStatsService</code> class guarantees that only apps that have the <code class="literal">BATTERY_STATS</code> permission can obtain battery statistics by calling <code class="literal">enforceCallingPermission()</code> before executing any other code, as shown in <a class="xref" href="ch02.html#dynamic_permission_check_in_batterystats" title="Example 2-14. Dynamic permission check in BatteryStatsService">Example 2-14</a>. Callers that have not been granted the permission receive a <code class="literal">SecurityException</code>.</p><div class="example"><a id="dynamic_permission_check_in_batterystats"/><p class="title">Example 2-14. Dynamic permission check in <code class="literal">BatteryStatsService</code></p><div class="example-contents"><pre class="programlisting">public byte[] getStatistics() {
    mContext.enforceCallingPermission(
                android.Manifest.permission.BATTERY_STATS, null);
    Parcel out = Parcel.obtain();
    mStats.writeToParcel(out, 0);
    byte[] data = out.marshall();
    out.recycle();
    return data;
}</pre></div></div></div><div class="sect3" title="Static Enforcement"><div class="titlepage"><div><div><h3 class="title"><a id="static_enforcement"/>Static Enforcement</h3></div></div></div><p>Static permission enforcement comes into play when an application tries to interact with a component declared by another application. The <a id="iddle1071" class="indexterm"/><a id="iddle1422" class="indexterm"/><a id="iddle1727" class="indexterm"/><a id="iddle1729" class="indexterm"/><a id="iddle1732" class="indexterm"/><a id="iddle1830" class="indexterm"/><a id="iddle1832" class="indexterm"/><a id="iddle1835" class="indexterm"/><a id="iddle1857" class="indexterm"/><a id="iddle1858" class="indexterm"/><a id="iddle2707" class="indexterm"/><a id="iddle2764" class="indexterm"/><a id="iddle2869" class="indexterm"/><a id="iddle2871" class="indexterm"/>enforcement process takes into account the permissions declared for each target component (if any) and allows the interaction if the caller process has been granted the required permission.</p><p>Android uses intents to describe an operation it needs to perform, and intents that fully specify the target component (by package and class name) are called <span class="emphasis"><em>explicit</em></span>. On the other hand, <span class="emphasis"><em>implicit</em></span> intents contain some data (often only an abstract action such as <code class="literal">ACTION_SEND</code>) that allows the system to find a matching component, but they do not fully specify a target component.</p><p>When the system receives an implicit intent, it first resolves it by searching for matching components. If more than one matching component is found, the user is presented with a selection dialog. When a target component has been selected, Android checks to see whether it has any associated permissions, and if it does, checks whether they have been granted to the caller.</p><p>The general process is similar to dynamic enforcement: the UID and PID of the caller are obtained using <code class="literal">Binder.getCallingUid()</code> and <code class="literal">Binder.getCallingPid()</code>, the caller UID is mapped to a package name, and the associated permissions are retrieved. If the set of caller permissions contains the ones required by the target component, the component is started; otherwise, a <code class="literal">SecurityException</code> is thrown.</p><p>Permission checks are performed by the <code class="literal">ActivityManagerService</code>, which resolves the specified intent and checks to see whether the target component has an associated permission attribute. If so, it delegates the permission check to the package manager. The timing and concrete sequence of permission checks is slightly different depending on the target component. (Next, we’ll examine how checks are performed for each component.)</p></div><div class="sect3" title="Activity and Service Permission Enforcement"><div class="titlepage"><div><div><h3 class="title"><a id="activity_and_service_permission_enforcem"/>Activity and Service Permission Enforcement</h3></div></div></div><p>Permission checks for activities are performed if the intent passed to <code class="literal">Context.startActivity()</code> or <code class="literal">startActivityForResult()</code> resolves to an activity that declares a permission. A <code class="literal">SecurityException</code> is thrown if the caller does not have the required permission. Because Android services can be started, stopped, and bound to, calls to <code class="literal">Context.startService()</code>, <code class="literal">stopService()</code>, and <code class="literal">bindService()</code> are all subject to permission checks if the target service declares a permission.</p></div><div class="sect3" title="Content Provider Permission Enforcement"><div class="titlepage"><div><div><h3 class="title"><a id="content_provider_permission_enforcement"/>Content Provider Permission Enforcement</h3></div></div></div><p>Content provider permissions can either protect the whole component or a particular exported URI, and different permissions can be specified for reading and writing. (You’ll learn more about permission declaration in “<a class="xref" href="ch02.html#content_provider_permissions" title="Content Provider Permissions">Content Provider Permissions</a>”.) If different permissions for reading and writing have been specified, the read permission controls who can call <code class="literal">ContentResolver.query()</code> on the target provider or URI, and the write permission controls who can call <code class="literal">ContentResolver.insert()</code>, <code class="literal">ContentResolver.update()</code>, and <code class="literal">ContentResolver.delete()</code> on the provider or one of its exported URIs. The checks are performed synchronously when one of these methods is called.</p></div><div class="sect3" title="Broadcast Permission Enforcement"><div class="titlepage"><div><div><h3 class="title"><a id="broadcast_permission_enforcement"/>Broadcast Permission Enforcement</h3></div></div></div><p><a id="iddle1287" class="indexterm"/><a id="iddle1301" class="indexterm"/><a id="iddle1304" class="indexterm"/><a id="iddle1728" class="indexterm"/><a id="iddle1731" class="indexterm"/><a id="iddle1733" class="indexterm"/><a id="iddle1831" class="indexterm"/><a id="iddle1834" class="indexterm"/><a id="iddle1836" class="indexterm"/><a id="iddle2380" class="indexterm"/><a id="iddle2469" class="indexterm"/><a id="iddle2520" class="indexterm"/><a id="iddle2756" class="indexterm"/><a id="iddle2873" class="indexterm"/><a id="iddle2892" class="indexterm"/>When sending a broadcast, applications can require that receivers hold a particular permission by using the <code class="literal">Context.sendBroadcast (Intent intent, String receiverPermission)</code> method. Because broadcasts are asynchronous, no permission check is performed when calling this method. The check is performed when delivering the intent to registered receivers. If a target receiver does not hold the required permission, it is skipped and does not receive the broadcast, but no exception is thrown. In turn, broadcast receivers can require that broadcasters hold a specific permission in order to be able to target them.</p><p>The required permission is specified in the manifest or when registering a broadcast dynamically. This permission check is also performed when delivering the broadcast and does not result in a <code class="literal">SecurityException</code>. Thus delivering a broadcast might require two permission checks: one for the broadcast sender (if the receiver specified a permission) and one for the broadcast receiver (if the sender specified a permission).</p></div><div class="sect3" title="Protected and Sticky Broadcasts"><div class="titlepage"><div><div><h3 class="title"><a id="protected_and_sticky_broadcasts"/>Protected and Sticky Broadcasts</h3></div></div></div><p>Some system broadcasts are declared as <span class="emphasis"><em>protected</em></span> (for example, <code class="literal">BOOT_COMPLETED</code> and <code class="literal">PACKAGE_INSTALLED</code>) and can only be sent by a system process running as one of <code class="literal">SYSTEM_UID</code>, <code class="literal">PHONE_UID</code>, <code class="literal">SHELL_UID</code>, <code class="literal">BLUETOOTH_UID</code>, or <span class="emphasis"><em>root</em></span>. If a process running under a different UID tries to send a protected broadcast, it receives a <code class="literal">SecurityException</code> when calling one of the <code class="literal">sendBroadcast()</code> methods. Sending “sticky” broadcasts (if marked as sticky, the system preserves the sent <code class="literal">Intent</code> object after the broadcast is complete) requires that the sender holds <code class="literal">BROADCAST_STICKY</code> permission; otherwise, a <code class="literal">SecurityException</code> is thrown and the broadcast is not sent.</p></div></div></div><div class="sect1" title="System Permissions"><div class="titlepage"><div><div><h1 class="title"><a id="system_permissions"/>System Permissions</h1></div></div></div><p>Android’s built-in permissions are defined in the <code class="literal">android</code> package, sometimes also referred to as “the framework” or “the platform.” As we learned in <a class="xref" href="ch01.html" title="Chapter 1. Android’s Security Model">Chapter 1</a>, the core Android framework is the set of classes shared by system services, with some exposed via the public SDK as well. Framework classes are packaged in JAR files found in <span class="emphasis"><em>/system/framework/</em></span> (about 40 in latest releases).</p><p>Besides JAR libraries, the framework contains a single APK file, <span class="emphasis"><em>framework-res.apk</em></span>. As the name implies, it packages framework resources (animation, drawables, layouts, and so on), but no actual code. Most importantly, it defines the <code class="literal">android</code> package and system permissions. As <span class="emphasis"><em>framework-res.apk</em></span> is an APK file, it contains an <span class="emphasis"><em>AndroidManifest.xml</em></span> file where permission groups and permissions are declared (see <a class="xref" href="ch02.html#system_permission_definitions_in_the_man" title="Example 2-15. System permission definitions in the manifest of framework-res.apk">Example 2-15</a>).</p><div class="example"><a id="system_permission_definitions_in_the_man"/><p class="title">Example 2-15. System permission definitions in the manifest of <span class="roman">framework-res.apk</span></p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest 
    package="android" coreApp="true" android:sharedUserId="android.uid.system"
    android:sharedUserLabel="@string/android_system_label"&gt;
    --<span class="emphasis"><em>snip</em></span>-
    &lt;protected-broadcast android:name="android.intent.action.BOOT_COMPLETED" /&gt;➊
    &lt;protected-broadcast android:name="android.intent.action.PACKAGE_INSTALL" /&gt;
    --<span class="emphasis"><em>snip</em></span>--
    &lt;permission-group android:name="android.permission-group.MESSAGES"
        android:label="@string/permgrouplab_messages"
        android:icon="@drawable/perm_group_messages"
        android:description="@string/permgroupdesc_messages"
        android:permissionGroupFlags="personalInfo"
        android:priority="360"/&gt;➋
    &lt;permission android:name="android.permission.SEND_SMS"
        android:permissionGroup="android.permission-group.MESSAGES"➌
        android:protectionLevel="dangerous"
        android:permissionFlags="costsMoney"
        android:label="@string/permlab_sendSms"
        android:description="@string/permdesc_sendSms" /&gt;
    --<span class="emphasis"><em>snip</em></span>--
    &lt;permission android:name="android.permission.NET_ADMIN"
        android:permissionGroup="android.permission-group.SYSTEM_TOOLS"
        android:protectionLevel="signature" /&gt;➍
    --<span class="emphasis"><em>snip</em></span>--
    &lt;permission android:name="android.permission.MANAGE_USB"
        android:permissionGroup="android.permission-group.HARDWARE_CONTROLS"
        android:protectionLevel="signature|system"➎
        android:label="@string/permlab_manageUsb"
        android:description="@string/permdesc_manageUsb" /&gt;
    --<span class="emphasis"><em>snip</em></span>--
    &lt;permission android:name="android.permission.WRITE_SECURE_SETTINGS"
        android:permissionGroup="android.permission-group.DEVELOPMENT_TOOLS"
        android:protectionLevel="signature|system|development"➏
        android:label="@string/permlab_writeSecureSettings"
        android:description="@string/permdesc_writeSecureSettings" /&gt;
    --<span class="emphasis"><em>snip</em></span>--
&lt;/manifest&gt;</pre></div></div><p><a id="iddle1144" class="indexterm"/>As shown in this listing, the <span class="emphasis"><em>AndroidManifest.xml</em></span> file also declares the system’s protected broadcasts ➊. A <span class="emphasis"><em>permission group</em></span> ➋ specifies a name for a set of related permissions. Individual permission can be added to a group by specifying the group name in their <code class="literal">permissionGroup</code> attribute ➌.</p><p>Permission groups are used to display related permissions in the system UI, but each permission still needs to be requested individually. That is, applications cannot request that they be granted all the permissions in a group.</p><p>Recall that each permission has an associated protection level declared using the <code class="literal">protectionLevel</code> attribute, as shown at ➍.</p><p>Protection levels can be combined with <span class="emphasis"><em>protection flags</em></span> to further constrain how permissions are granted. The currently defined flags are <code class="literal">system</code> (0x10) and <code class="literal">development</code> (0x20). The <code class="literal">system</code> flag requires that applications be part of the system image (that is, installed on the read-only <span class="emphasis"><em>system</em></span> partition) in order to be granted a permission. For example, the <code class="literal">MANAGE_USB</code> permission, which allows applications to manage preferences and permissions for <a id="iddle1147" class="indexterm"/><a id="iddle1156" class="indexterm"/><a id="iddle1543" class="indexterm"/><a id="iddle2468" class="indexterm"/><a id="iddle2470" class="indexterm"/><a id="iddle2496" class="indexterm"/><a id="iddle2568" class="indexterm"/><a id="iddle2831" class="indexterm"/><a id="iddle2891" class="indexterm"/><a id="iddle2893" class="indexterm"/><a id="iddle3141" class="indexterm"/>USB devices, is only granted to applications that are both signed with the platform signing key and installed on the <span class="emphasis"><em>system</em></span> partition ➎. The <code class="literal">development</code> flag marks development permissions ➏, which we’ll discuss after presenting signature permissions.</p><div class="sect2" title="Signature Permissions"><div class="titlepage"><div><div><h2 class="title"><a id="signature_permissions"/>Signature Permissions</h2></div></div></div><p>As discussed in <a class="xref" href="ch01.html" title="Chapter 1. Android’s Security Model">Chapter 1</a>, all Android applications are required to be code signed with a signature key controlled by the developer. This applies to system applications and the framework resource package as well. We discuss package signing in detail in <a class="xref" href="ch03.html" title="Chapter 3. Package Management">Chapter 3</a>, but for now let’s say a few words about how system applications are signed.</p><p>System applications are signed by a <span class="emphasis"><em>platform key</em></span>. By default, there are four different keys in the current Android source tree: <span class="emphasis"><em>platform</em></span>, <span class="emphasis"><em>shared</em></span>, <span class="emphasis"><em>media</em></span>, and <span class="emphasis"><em>testkey</em></span> (<span class="emphasis"><em>releasekey</em></span> for release builds). All packages considered part of the core platform (System UI, Settings, Phone, Bluetooth, and so on) are signed with the <span class="emphasis"><em>platform</em></span> key; the search- and contacts-related packages with the <span class="emphasis"><em>shared</em></span> key; the gallery app and media related providers with the <span class="emphasis"><em>media</em></span> key; and everything else (including packages that don’t explicitly specify the signing key in their makefile) with the <span class="emphasis"><em>testkey</em></span> (or <span class="emphasis"><em>releasekey</em></span>). The <span class="emphasis"><em>framework-res.apk</em></span> APK that defines system permissions is signed with the <span class="emphasis"><em>platform</em></span> key. Thus any app trying to request a system permission with <span class="emphasis"><em>signature</em></span> protection level needs to be signed with the same key as the framework resource package.</p><p>For example, the <code class="literal">NET_ADMIN</code> permission shown in <a class="xref" href="ch02.html#system_permission_definitions_in_the_man" title="Example 2-15. System permission definitions in the manifest of framework-res.apk">Example 2-15</a> (which allows a granted application to control network interfaces), is declared with the <span class="emphasis"><em>signature</em></span> protection level ➍ and can only be granted to applications signed with the <span class="emphasis"><em>platform</em></span> key.</p><div class="note" title="Note"><h3 class="title"><a id="ch02note03"/>Note</h3><p><span class="emphasis"><em>The Android open source repository (AOSP) includes pregenerated test keys that are used by default when signing compiled packages. They should never be used for production builds because they are public and available to anyone who downloads Android source code. Release builds should be signed with newly generated private keys that belong only to the build owner. Keys can be generated using the</em></span> make_key <span class="emphasis"><em>script, which is included in the</em></span> development/tools/ <span class="emphasis"><em>AOSP directory. See the</em></span> build/target/product/security/README <span class="emphasis"><em>file for details on platform key generation.</em></span></p></div></div><div class="sect2" title="Development Permissions"><div class="titlepage"><div><div><h2 class="title"><a id="development_permissions"/>Development Permissions</h2></div></div></div><p>Traditionally, the Android permission model does not allow for dynamically granting and revoking permissions, and the set of granted permission for an application is fixed at install time. However, since Android 4.2, this rule has been relaxed a little by adding a number of <span class="emphasis"><em>development permissions</em></span> (such as <code class="literal">READ_LOGS</code> and <code class="literal">WRITE_SECURE_SETTINGS</code>). Development permission can be granted or revoked on demand using the <span class="emphasis"><em>pm grant</em></span> and <span class="emphasis"><em>pm revoke</em></span> commands on the Android shell.</p><div class="note" title="Note"><h3 class="title"><a id="ch02note04"/>Note</h3><p><a id="iddle1965" class="indexterm"/><a id="iddle1966" class="indexterm"/><a id="iddle2467" class="indexterm"/><a id="iddle2814" class="indexterm"/><span class="emphasis"><em>Of course, this operation is not available to everyone and is protected by the <code class="literal">GRANT_REVOKE_PERMISSIONS</code> signature permission. It is granted to the</em></span> android.uid.shell <span class="emphasis"><em>shared user ID (UID 2000), and to all processes started from the Android shell (which also runs as UID 2000).</em></span></p></div></div></div><div class="sect1" title="Shared User ID"><div class="titlepage"><div><div><h1 class="title"><a id="shared_user_id"/>Shared User ID</h1></div></div></div><p>Android applications signed with the same key can request the ability to run as the same UID, and optionally in the same process. This feature is referred to as <span class="emphasis"><em>shared user ID</em></span> and is extensively used by core framework services and system applications. Because it can have subtle effects on process accounting and application management, the Android team does not recommend that third-party applications use it, but it is available to user-installed applications as well. Additionally, switching an existing applications that does not use a shared user ID to a shared user ID is not supported, so cooperating applications that need to use shared user ID should be designed and released as such from the start.</p><p>Shared user ID is enabled by adding the <code class="literal">sharedUserId</code> attribute to <span class="emphasis"><em>AndroidManifest.xml</em></span>’s root element. The user ID specified in the manifest needs to be in Java package format (containing at least one dot [<code class="literal">.</code>]) and is used as an identifier, much like package names for applications. If the specified shared UID does not exist, it is created. If another package with the same shared UID is already installed, the signing certificate is compared to that of the existing package, and if they do not match, an <code class="literal">INSTALL_FAILED_SHARED_USER_INCOMPATIBLE</code> error is returned and installation fails.</p><p>Adding the <code class="literal">sharedUserId</code> attribute to a new version of an installed app will cause it to change its UID, which would result in losing access to its own files (that was the case in some early Android versions). Therefore, this is disallowed by the system, which will reject the update with the <code class="literal">INSTALL_FAILED_UID_CHANGED</code> error. In short, if you plan to use shared UID for your apps, you have to design for it from the start, and must have used it since the very first release.</p><p>The shared UID itself is a first class object in the system’s package database and is treated much like applications: it has an associated signing certificate(s) and permissions. Android has five built-in shared UIDs, which are automatically added when the system is bootstrapped:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>android.uid.system</em></span> (SYSTEM_UID, 1000)</p></li><li class="listitem"><p><span class="emphasis"><em>android.uid.phone</em></span> (PHONE_UID, 1001)</p></li><li class="listitem"><p><span class="emphasis"><em>android.uid.bluetooth</em></span> (BLUETOOH_UID, 1002)</p></li><li class="listitem"><p><span class="emphasis"><em>android.uid.log</em></span> (LOG_UID, 1007)</p></li><li class="listitem"><p><span class="emphasis"><em>android.uid.nfc</em></span> (NFC_UID, 1027)</p></li></ul></div><p><a class="xref" href="ch02.html#definition_of_the_androiddotuiddotsystem" title="Example 2-16. Definition of the android.uid.system shared user">Example 2-16</a> shows how the <span class="emphasis"><em>android.uid.system</em></span> shared user is defined:</p><div class="example"><a id="definition_of_the_androiddotuiddotsystem"/><p class="title">Example 2-16. Definition of the <span class="roman">android.uid.system</span> shared user</p><div class="example-contents"><pre class="programlisting">&lt;shared-user name="android.uid.system" userId="1000"&gt;
&lt;sigs count="1"&gt;
&lt;cert index="4" /&gt;
&lt;/sigs&gt;
&lt;perms&gt;
&lt;item name="android.permission.MASTER_CLEAR" /&gt;
&lt;item name="android.permission.CLEAR_APP_USER_DATA" /&gt;
&lt;item name="android.permission.MODIFY_NETWORK_ACCOUNTING" /&gt;
--<span class="emphasis"><em>snip</em></span>--
&lt;shared-user/&gt;</pre></div></div><p>As you can see, apart from having a bunch of scary permissions (about 66 on a 4.4 device), the definition is very similar to the package declarations shown earlier. Conversely, packages that are part of a shared user do not have an associated granted permission list. Instead, they inherit the permissions of the shared user, which are a union of the permissions requested by all currently installed packages with the same shared user ID. One side effect of this is that if a package is part of a shared user, it can access APIs that it hasn’t explicitly requested permissions for, as long as some package with the same shared user ID has already requested them. Permissions are dynamically removed from the <code class="literal">&lt;shared-user&gt;</code> definition as packages are installed or uninstalled though, so the set of available permissions is neither guaranteed nor constant.</p><p><a class="xref" href="ch02.html#package_declaration_of_an_application_th" title="Example 2-17. Package declaration of an application that runs under a shared user ID">Example 2-17</a> shows how the declaration of the <code class="literal">KeyChain</code> system app that runs under a shared user ID looks like. As you can see, it references the shared user with the <code class="literal">sharedUserId</code> attribute and lacks explicit permission declarations:</p><div class="example"><a id="package_declaration_of_an_application_th"/><p class="title">Example 2-17. Package declaration of an application that runs under a shared user ID</p><div class="example-contents"><pre class="programlisting">&lt;package name="com.android.keychain"
         codePath="/system/app/KeyChain.apk"
         nativeLibraryPath="/data/app-lib/KeyChain"
         flags="540229" ft="13cd65721a0"
         it="13c2d4721f0" ut="13cd65721a0"
         version="19"
         sharedUserId="1000"&gt;
        &lt;sigs count="1"&gt;
            &lt;cert index="4" /&gt;
        &lt;/sigs&gt;
        &lt;signing-keyset identifier="1" /&gt;
    &lt;/package&gt;</pre></div></div><p>The shared UID is not just a package management construct; it actually maps to a shared Linux UID at runtime as well. <a class="xref" href="ch02.html#applications_running_under_a_shared_uid" title="Example 2-18. Applications running under a shared UID (system)">Example 2-18</a> shows an example of two system apps running as the <span class="emphasis"><em>system</em></span> user (UID 1000):</p><div class="example"><a id="applications_running_under_a_shared_uid"/><p class="title">Example 2-18. Applications running under a shared UID <span class="roman">(system)</span></p><div class="example-contents"><pre class="programlisting">system    5901  9852  845708 40972 ffffffff 00000000 S com.android.settings
system    6201  9852  824756 22256 ffffffff 00000000 S com.android.keychain</pre></div></div><p><a id="iddle1372" class="indexterm"/><a id="iddle1737" class="indexterm"/><a id="iddle2448" class="indexterm"/>Applications that are part of a shared user can run in the same process, and because they already have the same Linux UID and can access the same system resources, this typically does not require any additional modifications. A common process can be requested by specifying the same process name in the <code class="literal">process</code> attribute of the <code class="literal">&lt;application&gt;</code> tag in the manifests of all apps that need to run in one process. While the obvious result of this is that the apps can share memory and communicate directly instead of using IPC, some system services allow special access to components running in the same process (for example, direct access to cached passwords or getting authentication tokens without showing UI prompts). Google applications (such as Play Services and the Google location service) take advantage of this by requesting to run in the same process as the Google login service in order to be able to sync data in the background without user interaction. Naturally, they are signed with the same certificate and are part of the <span class="emphasis"><em>com.google.uid.shared</em></span> shared user.</p></div><div class="sect1" title="Custom Permissions"><div class="titlepage"><div><div><h1 class="title"><a id="custom_permissions"/>Custom Permissions</h1></div></div></div><p><span class="emphasis"><em>Custom permissions</em></span> are simply permissions declared by third-party applications. When declared, they can be added to application components for static enforcement by the system, or the application can dynamically check to see if callers have been granted the permission using the <code class="literal">checkPermission()</code> or <code class="literal">enforcePermission()</code> methods of the <code class="literal">Context</code> class. As with built-in permissions, applications can define permission groups that their custom permissions are added to. For example, <a class="xref" href="ch02.html#custom_permission_treecomma_permission_g" title="Example 2-19. Custom permission tree, permission group, and permission declaration">Example 2-19</a> shows the declaration of a permission group ➋ and the permission belonging to that group ➌.</p><div class="example"><a id="custom_permission_treecomma_permission_g"/><p class="title">Example 2-19. Custom permission tree, permission group, and permission declaration</p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest 
    package="com.example.app"
    android:versionCode="1"
    android:versionName="1.0" &gt;
    --<span class="emphasis"><em>snip</em></span>--
    &lt;permission-tree
        android:name="com.example.app.permission"
        android:label="@string/example_permission_tree_label" /&gt;➊

    &lt;permission-group
        android:name="com.example.app.permission-group.TEST_GROUP"
        android:label="@string/test_permission_group_label"
        android:description="@string/test_permission_group_desc"/&gt;➋

    &lt;permission
        android:name="jcom.example.app.permission.PERMISSION1"
        android:label="@string/permission1_label"
        android:description="@string/permission1_desc"
        android:permissionGroup="com.example.app.permission-group.TEST_GROUP"
        android:protectionLevel="signature" /&gt;➌
        --<span class="emphasis"><em>snip</em></span>--
&lt;/manifest&gt;</pre></div></div><p><a id="iddle1105" class="indexterm"/><a id="iddle2457" class="indexterm"/><a id="iddle2463" class="indexterm"/><a id="iddle2541" class="indexterm"/>As with system permissions, if the protection level is <span class="emphasis"><em>normal</em></span> or <span class="emphasis"><em>dangerous</em></span>, custom permission will be granted automatically when the user okays the confirmation dialog. In order to be able to control which applications are granted a custom permission, you need to declare it with the <span class="emphasis"><em>signature</em></span> protection level to guarantee that it will only be granted to applications signed with the same key.</p><div class="note" title="Note"><h3 class="title"><a id="ch02note05"/>Note</h3><p><span class="emphasis"><em>The system can only grant a permission that it knows about, which means that applications that define custom permissions need to be installed before the applications that make use of those permissions are installed. If an application requests a permission unknown to the system, it is ignored and not granted.</em></span></p></div><p>Applications can also add new permissions dynamically using the <code class="literal">android.content.pm.PackageManager.addPermission()</code> API and remove them with the matching <code class="literal">removePermision()</code> API. Such dynamically added permissions must belong to a <span class="emphasis"><em>permission tree</em></span> defined by the application. Applications can only add or remove permissions from a permission tree in their own package or another package running as the same shared user ID.</p><p>Permission tree names are in reverse domain notation and a permission is considered to be in a permission tree if its name is prefixed with the permission tree name plus a dot (<code class="literal">.</code>). For example, the <code class="literal">com.example.app.permission.PERMISSION2</code> permission is a member of the <code class="literal">com.example.app.permission</code> tree defined in <a class="xref" href="ch02.html#custom_permission_treecomma_permission_g" title="Example 2-19. Custom permission tree, permission group, and permission declaration">Example 2-19</a> at ➊. <a class="xref" href="ch02.html#adding_a_dynamic_permission_programmatic" title="Example 2-20. Adding a dynamic permission programmatically">Example 2-20</a> shows how to add a dynamic permission programmatically.</p><div class="example"><a id="adding_a_dynamic_permission_programmatic"/><p class="title">Example 2-20. Adding a dynamic permission programmatically</p><div class="example-contents"><pre class="programlisting">PackageManager pm = getPackageManager();
PermissionInfo permission = new PermissionInfo();
permission.name = "com.example.app.permission.PERMISSION2";
permission.labelRes = R.string.permission_label;
permission.protectionLevel = PermissionInfo.PROTECTION_SIGNATURE;
boolean added = pm.addPermission(permission);
Log.d(TAG, "permission added: " + added);</pre></div></div><p>Dynamically added permissions are added to the package database (<span class="emphasis"><em>/data/system/packages.xml</em></span>). They persist across reboots, just like permissions defined in the manifest, but they have an additional <code class="literal">type</code> attribute set to <span class="emphasis"><em>dynamic</em></span>.</p></div><div class="sect1" title="Public and Private Components"><div class="titlepage"><div><div><h1 class="title"><a id="public_and_private_components"/>Public and Private Components</h1></div></div></div><p>Components defined in the <span class="emphasis"><em>AndroidManifest.xml</em></span> file can be public or private. Private components can be called only by the declaring application, while public ones are available to other applications as well.</p><p><a id="iddle1070" class="indexterm"/><a id="iddle2443" class="indexterm"/><a id="iddle2466" class="indexterm"/><a id="iddle2870" class="indexterm"/><a id="iddle2872" class="indexterm"/>With the exception of content providers, all components are private by default. Because the purpose of content providers is to share data with other applications, content providers were initially public by default, but this behavior changed in Android 4.2 (API Level 17). Applications that target API Level 17 or later now get private content providers by default, but they are kept public for backward compatibility when targeting a lower API level.</p><p>Components can be made public by explicitly setting the <code class="literal">exported</code> attribute to <code class="literal">true</code>, or implicitly by declaring an intent filter. Components that have an intent filter but that do not need to be public can be made private by setting the <code class="literal">exported</code> attribute to <code class="literal">false</code>. If a component is not exported, calls from external applications are blocked by the activity manager, regardless of the permissions the calling process has been granted (unless it is running as <span class="emphasis"><em>root</em></span> or <span class="emphasis"><em>system</em></span>). <a class="xref" href="ch02.html#keeping_a_component_private_by_setting" title="Example 2-21. Keeping a component private by setting exported=&quot;false&quot;">Example 2-21</a> shows how to keep a component private by setting the <code class="literal">exported</code> attribute to <code class="literal">false</code>.</p><div class="example"><a id="keeping_a_component_private_by_setting"/><p class="title">Example 2-21. Keeping a component private by setting <code class="literal">exported="false"</code></p><div class="example-contents"><pre class="programlisting">&lt;service android:name=".MyService" android:exported="false" &gt;
    &lt;intent-filter&gt;
        &lt;action android:name="com.example.FETCH_DATA" /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;</pre></div></div><p>Unless explicitly intended for public consumption, all public components should be protected by a custom permission.</p></div><div class="sect1" title="Activity and Service Permissions"><div class="titlepage"><div><div><h1 class="title"><a id="activity_and_service_permissions"/>Activity and Service Permissions</h1></div></div></div><p>Activities and services can each be protected by a single permission set with the <code class="literal">permission</code> attribute of the target component. The activity permission is checked when other applications call <code class="literal">Context.startActivity()</code> or <code class="literal">Con text.startActivityForResult()</code> with an intent that resolves to that activity. For services, the permission is checked when other applications call one of <code class="literal">Context.startService()</code>, <code class="literal">stopService()</code>, or <code class="literal">bindService()</code> with an intent that resolves to the service.</p><p>For example, <a class="xref" href="ch02.html#protecting_activities_and_services_with" title="Example 2-22. Protecting activities and services with custom permissions">Example 2-22</a> shows two custom permissions, <code class="literal">START_MY_ACTIVITY</code> and <code class="literal">USE_MY_SERVICE</code>, set to an activity ➊ and service ➋, respectively. Applications that want to use these components need to request the respective permissions using the <code class="literal">&lt;uses-permission&gt;</code> tag in their manifest.</p><div class="example"><a id="protecting_activities_and_services_with"/><p class="title">Example 2-22. Protecting activities and services with custom permissions</p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest 
    package="com.example.myapp"
    ... &gt;
    &lt;permission android:name="com.example.permission.START_MY_ACTIVITY"
        android:protectionLevel="signature"
        android:label="@string/start_my_activity_perm_label"
        android:description="@string/start_my_activity_perm_desc" /&gt;
    &lt;permission android:name="com.example.permission.USE_MY_SERVICE"
        android:protectionLevel="signature"
        android:label="@string/use_my_service_perm_label"
        android:description="@string/use_my_service_perm_desc" /&gt;

    --<span class="emphasis"><em>snip</em></span>--
    &lt;activity android:name=".MyActivity"
        android:label="@string/my_activity"
        android:permission="com.example.permission.START_MY_ACTIVITY"&gt;➊
        &lt;intent-filter&gt;
        --<span class="emphasis"><em>snip</em></span>--
       &lt;/intent-filter&gt;
    &lt;/activity&gt;
    &lt;service android:name=".MyService"
        android:permission="com.example.permission.USE_MY_SERVICE"&gt;➋
        &lt;intent-filter&gt;
        --<span class="emphasis"><em>snip</em></span>--
        &lt;/intent-filter&gt;
    &lt;/service&gt;
    --<span class="emphasis"><em>snip</em></span>--
&lt;/manifest&gt;</pre></div></div></div><div class="sect1" title="Broadcast Permissions"><div class="titlepage"><div><div><h1 class="title"><a id="broadcast_permissions"/>Broadcast Permissions</h1></div></div></div><p><a id="iddle1262" class="indexterm"/><a id="iddle1300" class="indexterm"/><a id="iddle1976" class="indexterm"/><a id="iddle2445" class="indexterm"/><a id="iddle2757" class="indexterm"/>Unlike activities and services, permissions for broadcast receivers can be specified both by the receiver itself and by the application sending the broadcast. When sending a broadcast, applications can either use the <code class="literal">Context.sendBroadcast(Intent intent)</code> method to send a broadcast to be delivered to all registered receives, or limit the scope of components that receive the broadcast by using the <code class="literal">Context.sendBroadcast(Intent intent, String receiverPermission)</code>. The <code class="literal">receiverPermission</code> parameter specifies the permission that interested receivers need to hold in order to receive the broadcast. Alternatively, starting with Android 4.0, senders can use the <code class="literal">Intent.setPackage(String packageName)</code> to limit the scope of receivers to those defined in the specified package. On multi-user devices, system applications that hold the <code class="literal">INTERACT_ACROSS_USERS</code> permission can send a broadcast that is delivered only to a specific user by the using the <code class="literal">sendBroadcastAsUser(Intent intent, UserHandle user)</code> and <code class="literal">sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission)</code> methods.</p><p>Receivers can limit who can send them broadcasts by specifying a permission using the <code class="literal">permission</code> attribute of the <code class="literal">&lt;receiver&gt;</code> tag in the manifest for statically registered receivers, or by passing the required permission to the <code class="literal">Context.registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)</code> method for dynamically registered receivers.</p><p>Only broadcasters that have been granted the required permission will be able to send a broadcast to that receiver. For example, device administration applications that enforce systemwide security policies (we discuss device administration in <a class="xref" href="ch09.html" title="Chapter 9. Enterprise Security">Chapter 9</a>) require the <code class="literal">BIND_DEVICE_ADMIN</code> <a id="iddle1423" class="indexterm"/><a id="iddle1544" class="indexterm"/><a id="iddle2447" class="indexterm"/>permission in order to receive the <code class="literal">DEVICE_ADMIN_ENABLED</code> broadcast. Because this is a system permission with protection level <span class="emphasis"><em>signature</em></span>, requiring the permission guarantees that only the system can activate device administration applications. For example, <a class="xref" href="ch02.html#specifying_a_permission_for_a_statically" title="Example 2-23. Specifying a permission for a statically registered broadcast receiver">Example 2-23</a> shows how the default Android Email application specifies the <code class="literal">BIND_DEVICE_ADMIN</code> ➊ permission for its <code class="literal">PolicyAdmin</code> receiver.</p><div class="example"><a id="specifying_a_permission_for_a_statically"/><p class="title">Example 2-23. Specifying a permission for a statically registered broadcast receiver</p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest 
    package="com.android.email"
    android:versionCode="500060" &gt;
        --<span class="emphasis"><em>snip</em></span>--
        &lt;receiver
            android:name=".SecurityPolicy$PolicyAdmin"
            android:label="@string/device_admin_label"
            android:description="@string/device_admin_description"
            android:permission="android.permission.BIND_DEVICE_ADMIN" &gt;➊
            &lt;meta-data
                android:name="android.app.device_admin"
                android:resource="@xml/device_admin" /&gt;
            &lt;intent-filter&gt;
                &lt;action
                    android:name="android.app.action.DEVICE_ADMIN_ENABLED" /&gt;
            &lt;/intent-filter&gt;
        &lt;/receiver&gt;
        --<span class="emphasis"><em>snip</em></span>--
&lt;/manifest&gt;</pre></div></div><p>As with other components, private broadcast receivers can only receive broadcasts originating from the same application.</p></div><div class="sect1" title="Content Provider Permissions"><div class="titlepage"><div><div><h1 class="title"><a id="content_provider_permissions"/>Content Provider Permissions</h1></div></div></div><p>As mentioned in “<a class="xref" href="ch02.html#nature_of_permissions" title="The Nature of Permissions">The Nature of Permissions</a>”, content providers have a more complex permission model than other components, as we’ll describe in detail in this section.</p><div class="sect2" title="Static Provider Permissions"><div class="titlepage"><div><div><h2 class="title"><a id="static_provider_permissions"/>Static Provider Permissions</h2></div></div></div><p>While a single permissions that controls access to the whole provider can be specified using the <code class="literal">permission</code> attribute, most providers employ different permission for reading and writing, and can also specify per-URI permissions. One example of a provider that uses different permissions for reading and writing is the built-in <code class="literal">ContactsProvider</code>. <a class="xref" href="ch02.html#contactsprovider_permission_declarations" title="Example 2-24. ContactsProvider permission declarations">Example 2-24</a> shows the declaration of its <code class="literal">ContactsProvider2</code> class.</p><div class="example"><a id="contactsprovider_permission_declarations"/><p class="title">Example 2-24. <code class="literal">ContactsProvider</code> permission declarations</p><div class="example-contents"><pre class="programlisting">&lt;manifest 
        package="com.android.providers.contacts"
        android:sharedUserId="android.uid.shared"
        android:sharedUserLabel="@string/sharedUserLabel"&gt;
        --<span class="emphasis"><em>snip</em></span>--
        &lt;provider android:name="ContactsProvider2"
           android:authorities="contacts;com.android.contacts"
           android:label="@string/provider_label"
           android:multiprocess="false"
           android:exported="true"
           android:readPermission="android.permission.READ_CONTACTS"➊
           android:writePermission="android.permission.WRITE_CONTACTS"&gt;➋
           --<span class="emphasis"><em>snip</em></span>--
           &lt;path-permission
                   android:pathPattern="/contacts/.*/photo"
                   android:readPermission="android.permission.GLOBAL_SEARCH" /&gt;➌
           &lt;grant-uri-permission android:pathPattern=".*" /&gt;
        &lt;/provider&gt;
        --<span class="emphasis"><em>snip</em></span>--
&lt;/manifest&gt;</pre></div></div><p><a id="iddle1421" class="indexterm"/><a id="iddle1893" class="indexterm"/><a id="iddle2446" class="indexterm"/><a id="iddle2561" class="indexterm"/><a id="iddle3136" class="indexterm"/>The provider uses the <code class="literal">readPermission</code> attribute to specify one permission for reading data (<code class="literal">READ_CONTACTS</code> ➊), and a separate permission for writing data using the <code class="literal">writePermission</code> attribute (<code class="literal">WRITE_CONTACTS</code> ➋). Thus, applications that only hold the <code class="literal">READ_CONTACTS</code> permission can only call the <code class="literal">query()</code> method of the provider, and calls to <code class="literal">insert()</code>, <code class="literal">update()</code>, or <code class="literal">delete()</code> require the caller to hold the <code class="literal">WRITE_CONTACTS</code> permission. Applications that need to both read and write to the contacts provider need to hold both permissions.</p><p>When the global read and write permission are not sufficiently flexible, providers can specify per-URI permissions to protect a certain subset of their data. Per-URI permissions have higher priority than the component-level permission (or read and write permissions, if specified separately). Thus if an application wants to access a content provider URI that has an associated permission, it needs to hold only the target URI’s permission, and not the component-level permission. In <a class="xref" href="ch02.html#contactsprovider_permission_declarations" title="Example 2-24. ContactsProvider permission declarations">Example 2-24</a>, the <code class="literal">ContactsProvider2</code> uses the <code class="literal">&lt;path-permission&gt;</code> tag to require that applications trying to read photos of contacts hold the <code class="literal">GLOBAL_SEARCH</code> permission ➌. As per-URI permissions override the global read permission, interested applications do not need to hold the <code class="literal">READ_CONTACTS</code> permission. In practice, the <code class="literal">GLOBAL_SEARCH</code> permission is used to grant read-only access to some of the system providers’ data to Android’s search system, which cannot be expected to hold read permissions to all providers.</p></div><div class="sect2" title="Dynamic Provider Permissions"><div class="titlepage"><div><div><h2 class="title"><a id="dynamic_provider_permissions"/>Dynamic Provider Permissions</h2></div></div></div><p>While statically defined per-URI permissions can be quite powerful, applications sometimes need to grant temporary access to a particular piece of data (referred to by its URI) to other apps, without requiring that they hold a particular permission. For example, an email or messaging application may need to cooperate with an image viewer app in order to display an attachment. Because the app cannot know the URIs of attachments in advance, if it used static per-URI permissions, it would need to grant read access to all attachments to the image viewer app, which is undesirable.</p><p><a id="iddle1813" class="indexterm"/><a id="iddle1814" class="indexterm"/><a id="iddle1815" class="indexterm"/><a id="iddle1912" class="indexterm"/><a id="iddle2613" class="indexterm"/><a id="iddle2614" class="indexterm"/>To avoid this situation and potential security concern, applications can dynamically grant temporary per-URI access using the <code class="literal">Context.grantUriPermission(String toPackage, Uri uri, int modeFlags)</code> method and revoke access using the matching <code class="literal">revokeUriPermission(Uri uri, int modeFlags)</code> method. Temporary per-URI access is enabled by setting the global <code class="literal">grantUriPermissions</code> attribute to <code class="literal">true</code> or by adding a <code class="literal">&lt;grant-uri-permission&gt;</code> tag in order to enable it for a specific URI. For example, <a class="xref" href="ch02.html#attachmentprovider_declaration_from_the" title="Example 2-25. AttachmentProvider declaration from the Email app">Example 2-25</a> shows how the Email application uses the <code class="literal">grantUriPermissions</code> attribute ➊ to allow temporary access to attachments without requiring the <code class="literal">READ_ATTACHMENT</code> permission.</p><div class="example"><a id="attachmentprovider_declaration_from_the"/><p class="title">Example 2-25. <code class="literal">AttachmentProvider</code> declaration from the Email app</p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest 
    package="com.android.email"
    android:versionCode="500060" &gt;
        &lt;provider
           android:name=".provider.AttachmentProvider"
           android:authorities="com.android.email.attachmentprovider"
           android:grantUriPermissions="true"➊
           android:exported="true"
           android:readPermission="com.android.email.permission.READ_ATTACHMENT"/&gt;
        --<span class="emphasis"><em>snip</em></span>--
&lt;/manifest&gt;</pre></div></div><p>In practice, applications rarely use the <code class="literal">Context.grantPermission()</code> and <code class="literal">revokePermission()</code> methods directly to allow per-URI access. Instead, they set the <code class="literal">FLAG_GRANT_READ_URI_PERMISSION</code> or <code class="literal">FLAG_GRANT_WRITE_URI_PERMISSION</code> flags to the intent used to start the cooperating application (image viewer in our example). When those flags are set, the recipient of the intent is granted permission to perform read or write operations on the URI in the intent’s data.</p><p>Beginning with Android 4.4 (API Level 19), per-URI access grants can be persisted across device reboots with the <code class="literal">ContentResolver.takePersistableUriPermission()</code> method, if the received intent has the <code class="literal">FLAG_GRANT_PERSISTABLE_URI_PERMISSION</code> flag set. Grants are persisted to the <span class="emphasis"><em>/data/system/urigrants.xml</em></span> file and can be revoked by calling the <code class="literal">releasePersistableUriPermission()</code> method. Both transient and persistent per-URI access grants are managed by the system <code class="literal">ActivityManagerService</code>, which APIs related to per-URI access call internally.</p><p>Beginning with Android 4.1 (API level 16), applications can use the <code class="literal">ClipData</code> facility<sup>[<a id="ch02fn06" href="#ftn.ch02fn06" class="footnote">16</a>]</sup> of intents to add more than one content URI to temporarily be granted access to.</p><p>Per-URI access is granted using one of the <code class="literal">FLAG_GRANT_*</code> intent flags, and automatically revoked when the task of the called application finishes, so there is no need to call <code class="literal">revokePermission()</code>. <a class="xref" href="ch02.html#using_the_flagunderscoregrantunderscorer" title="Example 2-26. Using the FLAG_GRANT_READ_URI_PERMISSION flag to start a viewer application">Example 2-26</a> shows how the Email application creates an intent that launches an attachment viewer application.</p><div class="example"><a id="using_the_flagunderscoregrantunderscorer"/><p class="title">Example 2-26. Using the <code class="literal">FLAG_GRANT_READ_URI_PERMISSION</code> flag to start a viewer application</p><div class="example-contents"><pre class="programlisting">public Intent getAttachmentIntent(Context context, long accountId) {
    Uri contentUri = getUriForIntent(context, accountId);
    Intent intent = new Intent(Intent.ACTION_VIEW);
    intent.setDataAndType(contentUri, mContentType);
    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION |
                    Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
    return intent;
}</pre></div></div></div></div><div class="sect1" title="Pending Intents"><div class="titlepage"><div><div><h1 class="title"><a id="pending_intents"/>Pending Intents</h1></div></div></div><p><a id="iddle1072" class="indexterm"/><a id="iddle2440" class="indexterm"/><a id="iddle2455" class="indexterm"/>Pending intents are neither an Android component nor a permission, but because they allow an application to grant its own permissions to another application, we discuss them here.</p><p>Pending intents encapsulate an intent and a target action to perform with it (start an activity, send a broadcast, and so on). The main difference from “regular” intents is that pending intents also include the identity of the applications that created them. This allows pending intents to be handed to other applications, which can use them to perform the specified action using the identity and permissions of the original application. The identity stored in pending intents is guaranteed by the system <code class="literal">ActivityManagerService</code>, which keeps track of the currently active pending intents.</p><p>Pending intents are used to implement alarms and notifications in Android. Alarms and notifications allow any application to specify an action that needs to be performed on its behalf, either at a specified time for alarms, or when the user interacts with a system notification. Alarms and notifications can be triggered when the application that created them is no longer running, and the system uses the information in the pending intent to start it and perform the intent action on its behalf. <a class="xref" href="ch02.html#using_a_pending_intent_to_schedule_an_al" title="Example 2-27. Using a pending intent to schedule an alarm">Example 2-27</a> shows how the Email application uses a pending intent created with the <code class="literal">PendingIntent.getBroadcast()</code> ➊ to schedule broadcasts that trigger email synchronization.</p><div class="example"><a id="using_a_pending_intent_to_schedule_an_al"/><p class="title">Example 2-27. Using a pending intent to schedule an alarm</p><div class="example-contents"><pre class="programlisting">private void setAlarm(long id, long millis) {
    --<span class="emphasis"><em>snip</em></span>--
    Intent i = new Intent(this, MailboxAlarmReceiver.class);
    i.putExtra("mailbox", id);
    i.setData(Uri.parse("Box" + id));
    pi = PendingIntent.getBroadcast(this, 0, i, 0);➊
    mPendingIntents.put(id, pi);
    AlarmManager am =
            (AlarmManager)getSystemService(Context.ALARM_SERVICE);
    m.set(AlarmManager.RTC_WAKEUP,
          System.currentTimeMillis() + millis, pi);
    --<span class="emphasis"><em>snip</em></span>--
}</pre></div></div><p>Pending intents can be handed to non-system applications as well. The same rules apply: applications that receive a <code class="literal">PendingIntent</code> instance can perform the specified operation with the same permissions and identity as creator applications. Therefore, care should be taken when building the base intent, and base intents should generally be as specific as possible (with component name explicitly specified) to ensure that the intent is received by the intended components.</p><p>The implementation of pending intents is rather complex, but it is based on the same IPC and sandboxing principles that other Android components are built upon. When an application creates a pending intent, the system retrieves its UID and PID using <code class="literal">Binder.getCallingUid()</code> and <code class="literal">Binder.getCallingPid()</code>. Based on those, the system retrieves the package name and user ID (on multi-user devices) of the creator and stores them in a <code class="literal">PendingIntentRecord</code> along with the base intent and any additional meta-data. The activity manager keeps a list of active pending intents by storing the corresponding <code class="literal">PendingIntentRecord</code>s, and when triggered, retrieves the necessary record. It then uses the information in the record to assume the identity of the pending intent creator and execute the specified action. From there, the process is the same as when starting any Android component and the same permission checks are performed.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00004"/>Summary</h1></div></div></div><p>Android runs each application in a restricted sandbox and requires that applications request specific permissions in order to interact with other apps or the system. Permissions are strings that denote the ability to perform a particular action. They are granted at application install time and (with the exception of development permissions) remain fixed during an application’s lifetime. Permissions can be mapped to Linux supplementary group IDs, which the kernel checks before granting access to system resources.</p><p>Higher-level system services enforce permissions by obtaining the UID of the calling application using Binder and looking up the permissions it holds in the package manager database. Permissions associated with a component declared in an application’s manifest file are automatically enforced by the system, but applications can also choose to perform additional permission checks dynamically. In addition to using built-in permissions, applications can also define custom permissions and associate them with their components in order to control access.</p><p>Each Android component can require a permission, and content providers can additionally specify read and write permissions on a per-URI basis. Pending intents encapsulate the identity of the application that created them as well as an intent and an action to perform, which allows the system or third-party applications to perform actions on behalf of the original applications with the same identity and permissions.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch02fn01" href="#ch02fn01" class="para">11</a>] </sup>Google, <span class="emphasis"><em>Android API Reference</em></span>, “Manifest.permission class,” <span class="emphasis"><em><a class="ulink" href="http://developer.android.com/reference/android/Manifest.permission.html">http://developer.android.com/reference/android/Manifest.permission.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch02fn02" href="#ch02fn02" class="para">12</a>] </sup>Google, <span class="emphasis"><em>Android API Guides,</em></span> “App Manifest: &lt;permission&gt; tag,” <span class="emphasis"><em><a class="ulink" href="http://developer.android.com/guide/topics/manifest/permission-element.html#plevel">http://developer.android.com/guide/topics/manifest/permission-element.html#plevel</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch02fn03" href="#ch02fn03" class="para">13</a>] </sup>For detailed information about process management functions like <code class="literal">fork()</code>, <code class="literal">setuid()</code>, and so on, see the respective man pages or a Unix programming text, such as W. Richard Stevens and Stephen A. Rago’s <span class="emphasis"><em>Advanced Programming in the UNIX Environment (3rd edition)</em></span>, Addison-Wesley Professional, 2013.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch02fn04" href="#ch02fn04" class="para">14</a>] </sup>For a discussion of Linux capabilities, see Chapter 39 of Michael Kerrisk’s <span class="emphasis"><em>The Linux Programming Interface: A Linux and UNIX System Programming Handbook</em></span>, No Starch Press, 2010.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch02fn05" href="#ch02fn05" class="para">15</a>] </sup>Linux Kernel Archives, <span class="emphasis"><em>CGROUPS</em></span>, <span class="emphasis"><em><a class="ulink" href="https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt">https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch02fn06" href="#ch02fn06" class="para">16</a>] </sup>Google, <span class="emphasis"><em>Android API Reference</em></span>, “ClipData,” <span class="emphasis"><em><a class="ulink" href="http://developer.android.com/reference/android/content/ClipData.html">http://developer.android.com/reference/android/content/ClipData.html</a></em></span></p></div></div></div></body></html>