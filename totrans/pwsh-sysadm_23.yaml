- en: '20'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CREATING AND CONFIGURING AN IIS WEB SERVER
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You’re at the last step in your automation journey: the web server. In this
    chapter, you’ll use *IIS*, a built-in Windows service that provides web services
    to clients. IIS is a server type you’ll run into often enough when you’re doing
    IT work—in other words, it’s an area ripe for automation! As in previous chapters,
    first you’ll deploy an IIS web server from scratch; then you’ll focus on getting
    the service installed and some basic configuration applied.'
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By now, you should be familiar with how to get a fresh virtual machine created
    and set up, so we won’t be covering those steps. I’m assuming that you already
    have a virtual machine up and running with Windows Server installed. If you don’t,
    you could leverage our existing work in the PowerLab module by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice that you specify a `Generic` server type this time; this is because you
    haven’t yet added full support for web servers (the task for this chapter!).
  prefs: []
  type: TYPE_NORMAL
- en: Installation and Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you’ve created a VM, it’s time to set up IIS. IIS is a Windows feature,
    and fortunately, PowerShell has a built-in command to install Windows features
    called `Add-WindowsFeature`. If you were doing this as a one-off test, you *could*
    use a single line to install IIS, but since you’re building this automation into
    a bigger project, you’ll install IIS just as you did SQL: by creating a function.
    Let’s call it `Install-PowerLabWebServer`.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll have this function adhere to the model you created earlier when you made
    the `Install-PowerLabSqlServer` function. As you begin to add further server support
    to this project, you’ll see how creating a function for even just a single line
    of code will make using the module, and changing it, much, much easier!
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to mirror the `Install-PowerLabSqlServer` function as closely
    as possible is to take the “skeleton” of the function by removing any of the SQL
    Server–specific code. Normally, I’d recommend reusing an existing function instead
    of building another one, but in this case, you have a completely different “object:”
    a SQL Server versus an IIS server. It makes more sense to have a different function.
    In [Listing 20-1](ch20.xhtml#ch20list1), you simply copy the `Install-PowerLabSqlServer`
    function but remove the “guts” while keeping all of the common parameters (you
    exclude the `AnswerFilePath` and `IsoFilePath` parameters since IIS doesn’t need
    them).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-1: The “skeleton” `Install-PowerLabWebServer` function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As for actually setting up the IIS service, that’s a piece of cake: you simply
    need to run one command that installs the `Web-Server` feature. Go ahead and add
    that line into your `Install-PowerLabWebServer` function ([Listing 20-2](ch20.xhtml#ch20list2)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-2: The `Install-PowerLabWebServer` function*'
  prefs: []
  type: TYPE_NORMAL
- en: The start of your `Install-PowerLabWebServer` function is complete! Let’s add
    more code to it.
  prefs: []
  type: TYPE_NORMAL
- en: Building Web Servers from Scratch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you have an install function for IIS, it’s time to update your `New-PowerLabServer`
    function. Recall in [Chapter 19](ch19.xhtml#ch19) that when you were refactoring
    your `New-PowerLabServer` function, you were forced to use placeholder code for
    the web server parts because you didn’t have the functionality needed. You used
    the line `Write-Host ''Web server deployments are not` `supported` `at this` `time''`
    as filler code. Now’s let’s replace that text with a call to your newly created
    `Install-PowerLabWebServer` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once you do this, you can bring up web servers the same way you do SQL servers!
  prefs: []
  type: TYPE_NORMAL
- en: The WebAdministration Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have a web server up and running, you need to do something with it.
    When the `Web-Server` feature is enabled on a server, a PowerShell module called
    `WebAdministration` is installed. This module contains the many commands needed
    to handle IIS objects. The `Web-Server` feature also creates a PowerShell drive
    called IIS that allows you to manage common IIS objects (websites, application
    pools, and so forth).
  prefs: []
  type: TYPE_NORMAL
- en: A *PowerShell drive* allows you to navigate data sources just like a filesystem.
    You’ll see next that you can manipulate websites, application pools, and many
    other IIS objects exactly as you would files and folders by using common cmdlets
    like `Get-Item`, `Set-Item`, and `Remove-Item`.
  prefs: []
  type: TYPE_NORMAL
- en: To make the IIS drive available, you first have to import the `WebAdministration`
    module. Let’s remote into your newly created web server and play around with the
    module a bit to see what you can do.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you’ll create a new PowerShell Direct session and enter it interactively.
    Previously, you were mostly using `Invoke-Command` to send commands to VMs. Now,
    since you’re just investigating what’s possible with IIS, you use `Enter-PSSession`
    to interactively work inside of the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `[WEBSRV]` in front of the final prompt. This is a signal that you’re
    now working on the WEBSRV host and can import the `WebAdministration` module.
    Once the module is imported into the session, you can verify that the IIS drive
    is created by running `Get-PSDrive`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can peruse this drive as you can any other PowerShell drive: by treating
    it like a filesystem and using commands such as `Get-ChildItem` to list items
    in the drive, `New-Item` to create new items, and `Set-Item` to modify items.
    But doing all that work isn’t automating; it’s just managing IIS via the command
    line. And you’re here to automate stuff! The only reason I’m mentioning the IIS
    drive now is that it will come in handy for automation tasks later, and it’s always
    good to know how to do things manually, in case you need to troubleshoot automation
    when it goes awry.'
  prefs: []
  type: TYPE_NORMAL
- en: Websites and Application Pools
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The commands in the `WebAdministration` module manage and automate just about
    every facet of IIS. You’ll begin by looking at how to handle websites and applications,
    as websites and application pools are two of the most common components that system
    administrators work with in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Websites
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You’ll start with a simple command: `Get-Website`, which lets you query IIS
    and returns all websites that currently exist on a web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll notice that you already created a website. This is because IIS has a
    website called Default Web Site when it is installed. But let’s say you don’t
    want this default website and would rather create your own. You can remove it
    by piping the output of `Get-Website` to `Remove-Website`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to create a website, you can do so just as easily by using the
    `New-Website` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If the website’s bindings are off, and you want to change them (say you want
    to bind to a nonstandard port), you can use the `Set-WebBinding` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You’ve seen a lot of what you can do with websites. Let’s check out what’s possible
    with application pools.
  prefs: []
  type: TYPE_NORMAL
- en: Application Pools
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Application pools* allow you to isolate your applications from one another,
    even if they are running on the same server. This way, if an error exists in one
    app, it won’t take down other applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The commands for application pools are similar to those for websites, as you
    can see in the following code. Since I have only a single application pool, only
    the `DefaultAppPool` shows up for me. If you run this command on your own web
    server, you may see more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since you already created a website, let’s see how to create an app pool and
    assign it to your website. To create an app pool, use the `New-WebAppPool` command,
    as shown in [Listing 20-3](ch20.xhtml#ch20list3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-3: Creating an app pool*'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, not all IIS tasks have a built-in cmdlet. To assign the app pool
    to an existing website, you have to use `Set-ItemProperty` and change the website
    in the IIS drive ❶ (as shown next). To apply that update, you need to stop ❷ and
    restart ❸ the website.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can also see that you can confirm that the app pool was changing by looking
    at the `applicationPool` property returned from running `Get-Website`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring SSL on a Website
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve seen the commands for working with IIS, let’s go back to your
    PowerLab module and write a function that will install an IIS certificate and
    change the binding to port 443.
  prefs: []
  type: TYPE_NORMAL
- en: You can either get a “real” certificate from a valid certificate authority or
    create a self-signed certificate by using the `New-SelfSignedCertificate` function.
    Because I’m just demonstrating this concept, let’s create a self-signed certificate
    for now and use that.
  prefs: []
  type: TYPE_NORMAL
- en: First, lay out the function and specify all the parameters you need ([Listing
    20-4](ch20.xhtml#ch20list4)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-4: The start of `New-IISCertificate`*'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing this function needs to do is create a self-signed certificate.
    You can do so with the `New-SelfSignedCertificate` command, which imports the
    certificate into the local computer’s `LocalMachine` *certificate store*, where
    all the computer’s certificates are housed. When you call `New-Self``SignedCertificate`,
    you can pass a `Subject` parameter to store a string that will give you information
    about what the certificate is. Generating the certificate will also import it
    into the local computer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 20-5](ch20.xhtml#ch20list5) provides the line you’ll use to generate
    the certificate using the passed-in subject (`$CertificateSubject`). Remember
    that you can use the `$null` variable to store the results of a command so that
    it doesn’t output anything to the console.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-5: Creating a self-signed certificate*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the certificate is created, you need to do two things: get the thumbprint
    of the certificate, and export the private key from the certificate. A certificate
    *thumbprint* is a string that uniquely identifies the certificate; the certificate’s
    *private key* is used to encrypt and decrypt the data sent to your server (I won’t
    go into the details here).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could have gotten the thumbprint from `New-SelfSignedCertificate`’s output,
    but we’re assuming that this certificate is going to be used on a computer other
    than the one you created it on, as that’s the more realistic scenario. To handle
    this, you first need to export the public key from your self-signed certificate,
    which you can do by using the `Export-Certificate` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will give you a *.cer* public key file, which you can
    use, along with some .NET magic, to temporarily import the certificate and retrieve
    the thumbprint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have the certificate’s thumbprint, you need to export the private
    key, which you’ll use to attach to the SSL binding on the web server. Here are
    the commands for exporting the private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once you have a private key, you can import your certificate into a certificate
    store on the web server by using the `Import-PfxCertificate` command. First, though,
    you need to check whether it was already imported. This is why you had to get
    the thumbprint earlier. You can use a certificate’s unique thumbprints to verify
    whether it already exists on the web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To import your certificate, you need to use a few of the commands you saw earlier
    in the chapter: you’ll create a PowerShell direct session, import the `WebAdministration`
    module, check whether the certificate exists, and then add it if it doesn’t. You’ll
    leave the last step out for now, and write up the code to do the rest in [Listing
    20-6](ch20.xhtml#ch20list6).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-6: Checking whether the certificate already exists*'
  prefs: []
  type: TYPE_NORMAL
- en: The first two lines of code should be familiar from earlier in the chapter,
    but notice that you have to use `Invoke-Command` to import the module remotely.
    Likewise, since you’re using a local variable inside the scriptblock in your `if`
    statement, you need to use the `$using:` prefix to expand the variable on the
    remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s fill in the code for the `else` statement in [Listing 20-7](ch20.xhtml#ch20list7).
    You need to do four things to finish setting up the IIS certificate. First, you
    need to copy the private key to the web server. Then you need to import the private
    key by using `Import-PfxCertificate`. Lastly, you need to set the SSL binding
    and then force it to use the private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 20-7: Binding an SSL certificate to an IIS*'
  prefs: []
  type: TYPE_NORMAL
- en: One thing to point out about this code is that you set the site binding on your
    website to use port 443 instead of port 80\. You do this to ensure that the website
    adheres to the typical SSL port of 443, allowing web browsers to understand that
    you’re using encrypting web traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you’re finished! You have successfully installed a self-signed
    certificate on the web server, created the SSL binding for your site, and forced
    the SSL binding to use your certificate! The only thing left to do is clean up
    the session you’ve been working in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: After your session is cleaned up, you can browse to *https://<webservername**>*
    and you’ll be prompted to trust the certificate. All browsers will do this because
    you issued a self-signed certificate, and not one issued by a public certificate
    authority. Once you trust the certificate, you’ll be presented with the default
    IIS web page.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to check out the `New-IISCertificate` function inside the PowerLab module
    to see all these commands in one place.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter covered yet another type of server, the web server. You learned
    how to create a web server from scratch, exactly the same way as you create SQL
    servers. You also learned some of the commands inside the `WebAdministration`
    module that comes with IIS. You learned how to use built-in commands to perform
    many basic tasks as well as looked at the IIS PowerShell drive that’s created.
    To wrap up the chapter, you followed, in detail, a real-world scenario that required
    piecing together many of the commands and techniques covered earlier.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve made it through this entire book, congratulations! We covered a lot
    of ground and I’m glad you stuck around. The skills you’ve learned and the projects
    you built should give you a foundation to solve problems with PowerShell. Take
    what you’ve learned here, close the book, and get to scripting. Just start somewhere
    and automate it with PowerShell. The only way you’ll truly master the concepts
    covered in this book is by practicing. There’s no better than time than now!
  prefs: []
  type: TYPE_NORMAL
