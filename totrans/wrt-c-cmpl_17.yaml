- en: '![](../images/pg382.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg382.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-38.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-38.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ARRAYS
    AND POINTER ARITHMETIC</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">数组与指针运算</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: 'In this chapter, you’ll implement array types. You’ll also add the main language
    features that programmers use to work with arrays: compound initializers, subscript
    operators, and pointer arithmetic. Arrays and pointers are distinct but closely
    related types. Many expressions of array type are implicitly converted to pointers,
    and many pointer operations, like subscripting, are meant to operate on pointers
    to array elements. So, to support arrays, you’ll build on the support for pointers
    that you added in the previous chapter.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将实现数组类型。你还将添加程序员用来处理数组的主要语言特性：复合初始化器、下标运算符和指针运算。数组和指针是不同的但密切相关的类型。许多数组类型的表达式会隐式转换为指针，而许多指针操作（如下标操作）则是用来操作指向数组元素的指针。因此，为了支持数组，你需要在上章中添加的指针支持基础上进行构建。
- en: The type checker plays an especially critical role here. It will handle the
    implicit conversions from arrays to pointers and annotate the AST with the type
    information you’ll rely on to perform pointer arithmetic. Once the type checker
    has done all the hard work, it will be relatively easy to break down subscript
    operators and compound initializers into simple pointer operations during TACKY
    generation. You won’t add any new assembly instructions in this chapter, but you’ll
    introduce new operands to represent objects in memory and elements within those
    objects.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器在这里发挥着特别关键的作用。它将处理从数组到指针的隐式转换，并用你将依赖的类型信息注释抽象语法树（AST），以便执行指针运算。一旦类型检查器完成了所有的繁重工作，在TACKY生成过程中，将相对容易地将下标运算符和复合初始化器拆解为简单的指针操作。你在本章中不会添加任何新的汇编指令，但你会引入新的操作数来表示内存中的对象和这些对象中的元素。
- en: As usual, we’ll start with an overview of the language constructs we’re going
    to add. We’ll pay special attention to the relationship between pointers and arrays
    and how this relationship plays out in pointer arithmetic and subscript expressions.
    This is a particularly confusing aspect of C, and it’s key to everything we’ll
    do in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将从我们要添加的语言构造的概述开始。我们将特别关注指针与数组之间的关系，以及这种关系如何体现在指针运算和下标表达式中。这是C语言中一个特别令人困惑的方面，也是本章中所有内容的关键。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Arrays and Pointer Arithmetic</samp>
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">数组与指针运算</samp>
- en: 'Let’s define a few terms up front. In the last chapter, we divided every object
    type we knew about into two categories: arithmetic types and non-arithmetic types.
    Now we’ll introduce another distinction. A *scalar type* represents a single value.
    The pointer and arithmetic types we’ve already implemented are all scalar types.
    An *aggregate type* represents a collection of values. Arrays are aggregate types;
    so are structures, which we’ll implement in [Chapter 18](chapter18.xhtml). All
    the values in an array have the same type, which is the array’s *element type*.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义一些术语。在上一章中，我们将我们所知道的每种对象类型分为两类：算术类型和非算术类型。现在我们将引入另一个区分。*标量类型*表示一个单一的值。我们已经实现的指针和算术类型都是标量类型。*聚合类型*表示一组值。数组是聚合类型，结构体也是聚合类型（我们将在[第18章](chapter18.xhtml)实现它）。数组中的所有值都具有相同的类型，这就是数组的*元素类型*。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array Declarations
    and Initializers</samp>
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">数组声明与初始化器</samp>
- en: 'When we declare an array, we specify its element type and how many elements
    it contains. For example, we could declare an array of three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    objects:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明一个数组时，我们指定它的元素类型以及它包含多少个元素。例如，我们可以声明一个包含三个<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>对象的数组：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or we could declare an array of five pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们也可以声明一个包含五个指向<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>类型的指针的数组：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: (Remember that we interpret a declaration by starting with the basic type—<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, in this case—and then applying
    type derivations from the outside in.)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: （记住，我们通过从基本类型—在这个例子中是<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>—开始，然后从外到内应用类型推导来解释声明。）
- en: 'Both of these examples use scalar element types, but we can use aggregate element
    types too. The following example declares an array of three elements, where each
    element is itself an array of two <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    objects:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例都使用标量元素类型，但我们也可以使用聚合元素类型。以下示例声明了一个包含三个元素的数组，其中每个元素本身是一个包含两个<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>对象的数组：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Arrays of arrays like this one are called *multidimensional arrays*. Note that
    we still apply type derivations from the outside in to determine this array’s
    type. We start with the base type <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>,
    apply the derivation specified by <samp class="SANS_TheSansMonoCd_W5Regular_11">[2]</samp>
    to get the type “array of two <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    objects,” and then apply the derivation specified by <samp class="SANS_TheSansMonoCd_W5Regular_11">[3]</samp>
    to get the type “array of three arrays of two <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    objects.”
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的数组数组被称为*多维数组*。请注意，我们仍然从外到内应用类型推导来确定这个数组的类型。我们从基础类型<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>开始，应用由<samp
    class="SANS_TheSansMonoCd_W5Regular_11">[2]</samp>指定的推导，得到类型为“两个<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>对象的数组”，然后应用由<samp
    class="SANS_TheSansMonoCd_W5Regular_11">[3]</samp>指定的推导，得到类型为“三个包含两个<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>对象数组的数组”。
- en: 'You can initialize an array with a *compound initializer*, which specifies
    an initial value for each element:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*复合初始化器*初始化一个数组，指定每个元素的初始值：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And you can initialize a multidimensional array with nested compound initializers:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用嵌套的复合初始化器初始化一个多维数组：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the three nested compound initializers initialize the three elements of
    the outer array. Each of those three elements is, itself, an array of two <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> objects. The nested initializer
    for each of these elements specifies two arithmetic values (which can be implicitly
    converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，三个嵌套的复合初始化器初始化外部数组的三个元素。每个元素本身是一个包含两个<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>对象的数组。每个这些元素的嵌套初始化器指定了两个算术值（这些值可以隐式转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>）。
- en: You can also leave an array uninitialized. If it has automatic storage duration,
    its initial value will be undefined. If it has static storage duration, it will
    be initialized to all zeros. In other words, we treat uninitialized arrays exactly
    like uninitialized scalar objects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以让一个数组不初始化。如果它具有自动存储持续时间，它的初始值将是未定义的。如果它具有静态存储持续时间，它将被初始化为全零。换句话说，我们将未初始化的数组视为与未初始化的标量对象相同。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Memory Layout of
    Arrays</samp>
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">数组的内存布局</samp>
- en: At this point, it’s helpful to talk a bit about the memory layout of flat and
    multidimensional arrays. If you declare an array of *n* objects, those *n* objects
    will be laid out sequentially in memory. Consider the array in [Listing 15-1](chapter15.xhtml#list15-1),
    which has a scalar element type.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，讨论一下平面数组和多维数组的内存布局会有所帮助。如果你声明一个包含*n*个对象的数组，这些*n*个对象将在内存中按顺序排列。考虑[清单 15-1](chapter15.xhtml#list15-1)中的数组，它具有标量元素类型。
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-1: An array of scalar
    values</samp>'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-1：标量值的数组</samp>
- en: '[Figure 15-1](#fig15-1) shows what <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp>
    might look like in memory right after it’s initialized (the memory addresses in
    this figure are just for illustration; they wouldn’t be valid on a real system).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-1](#fig15-1)展示了<samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp>在初始化后可能在内存中的样子（此图中的内存地址仅供说明，实际系统中这些地址不一定有效）。'
- en: '![](../images/fig15-1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig15-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-1: The layout of</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">six_ints in memory [Description](description-39.xhtml)</samp>'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 15-1：内存中</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">six_ints
    的布局 [描述](description-39.xhtml)</samp>
- en: Compare this declaration to [Listing 15-2](chapter15.xhtml#list15-2), which
    declares a multidimensional array with the same number and type of scalar elements
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp>.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将此声明与[列表15-2](chapter15.xhtml#list15-2)进行对比，后者声明了一个具有与<samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp>相同数量和类型的标量元素的多维数组。
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-2: An array of nested
    arrays</samp>'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表15-2：嵌套数组的数组</samp>
- en: The memory that holds <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>
    will also look like [Figure 15-1](#fig15-1). In memory, there’s no indication
    of where one element ends and another begins, so the two arrays are indistinguishable.
    Although the nested structure of <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>
    doesn’t impact its layout in memory, it does impact how you access individual
    array elements, as we’ll see shortly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 存储<samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>的内存将像[图15-1](#fig15-1)所示那样。在内存中，无法区分一个元素的结束和另一个元素的开始，因此这两个数组是不可区分的。尽管<samp
    class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>的嵌套结构不会影响其在内存中的布局，但它会影响如何访问单个数组元素，正如我们接下来将看到的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array-to-Pointer
    Decay</samp>
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">数组到指针衰退</samp>
- en: 'Once we’ve defined and initialized an array, what can we do with it? Not a
    lot, as it turns out. In fact, there are only two valid operations on objects
    of array type. First, we can get an array’s size with the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator, which we’ll implement in [Chapter 17](chapter17.xhtml). Second, we can
    get its address with the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义并初始化了一个数组，我们能对它做什么呢？实际上，能做的很少。事实上，数组类型的对象只有两种有效操作。首先，我们可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>运算符获取数组的大小，我们将在[第17章](chapter17.xhtml)中实现它。其次，我们可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">&</samp>运算符获取它的地址：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That’s it! There are no other valid operations on arrays. That probably sounds
    ridiculous, since C programs read and write array elements all the time. What’s
    going on here? The C standard (section 6.3.2.1, paragraph 3) provides the solution
    to this puzzle: “Except when it is the operand of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator, or the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator … an expression that has type ‘array of *type*’ is converted to an expression
    with type ‘pointer to *type*’ that points to the initial element of the array
    object and is not an lvalue.”'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！数组上没有其他有效的操作。这听起来可能很荒谬，因为C程序经常读取和写入数组元素。那么这里到底发生了什么呢？C标准（第6.3.2.1节，第3段）提供了这个谜题的答案：“除非它是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>运算符的操作数，或者一元的<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>运算符的操作数……具有‘数组类型
    *type*’的表达式会被转换为指向数组对象初始元素的‘指针类型 *type*’表达式，并且不是左值。”
- en: This implicit conversion from arrays to pointers is called *array-to-pointer
    decay*. (I’ll sometimes say that an array decays to a pointer, and sometimes that
    it’s implicitly converted to a pointer. They both mean the same thing.) While
    we can’t do much with arrays, we can perform all sorts of useful operations on
    pointers. We’ve already implemented some of these operations, and we’ll add a
    few more in this chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种从数组到指针的隐式转换被称为*数组到指针衰退*。（我有时会说数组衰退为指针，有时说它隐式地转换为指针，两者意思相同。）虽然我们不能对数组做太多操作，但可以对指针进行各种有用的操作。我们已经实现了一些这样的操作，并将在本章添加更多操作。
- en: The code snippet in [Listing 15-3](chapter15.xhtml#list15-3) shows an example
    of array decay.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表15-3](chapter15.xhtml#list15-3)中的代码片段展示了数组衰退的示例。'
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-3: Implicitly converting
    an array to a pointer</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表15-3：将数组隐式转换为指针</samp>
- en: Let’s say <samp class="SANS_TheSansMonoCd_W5Regular_11">my_array</samp> starts
    at address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>. When <samp
    class="SANS_TheSansMonoCd_W5Regular_11">my_array</samp> appears on the right side
    of the assignment expression in this listing, it will be implicitly converted
    to a pointer whose type is <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>
    and whose value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp> ❶.
    We can then assign this pointer’s value to <samp class="SANS_TheSansMonoCd_W5Regular_11">my_pointer</samp>.
    When we dereference <samp class="SANS_TheSansMonoCd_W5Regular_11">my_pointer</samp>,
    the result is the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> object
    stored in the first 4 bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">my_array</samp>
    ❷. Therefore, we’ll return this object’s current value, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    Note that the address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>
    can be interpreted in a couple of different ways, depending on its type. As an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>, it points to the array’s
    initial element, which we can read or write through a pointer dereference operation.
    The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">&my_array</samp>
    has the same value, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>,
    but it points to the whole array and its type is <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    (*)[3]</samp>.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设<samp class="SANS_TheSansMonoCd_W5Regular_11">my_array</samp>的起始地址是<samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>。当<samp
    class="SANS_TheSansMonoCd_W5Regular_11">my_array</samp>出现在赋值表达式的右侧时，它会被隐式转换为一个指针，类型是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>，值为<samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>
    ❶。然后我们可以将这个指针的值赋给<samp class="SANS_TheSansMonoCd_W5Regular_11">my_pointer</samp>。当我们解引用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">my_pointer</samp>时，结果是存储在<samp class="SANS_TheSansMonoCd_W5Regular_11">my_array</samp>前4个字节中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>对象 ❷。因此，我们将返回该对象的当前值<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。注意，地址<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>的解释可以根据其类型有所不同。作为<samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>，它指向数组的第一个元素，我们可以通过指针解引用操作来读写它。表达式<samp class="SANS_TheSansMonoCd_W5Regular_11">&my_array</samp>具有相同的值<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>，但它指向整个数组，其类型是<samp class="SANS_TheSansMonoCd_W5Regular_11">int
    (*)[3]</samp>。
- en: It’s especially important to keep track of a pointer’s type when working with
    multidimensional arrays. Consider [Listing 15-4](chapter15.xhtml#list15-4), which
    tries to assign to two array elements.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理多维数组时，跟踪指针的类型尤为重要。请参考[清单 15-4](chapter15.xhtml#list15-4)，它尝试给两个数组元素赋值。
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-4: Legal and illegal
    assignments to array elements</samp>'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-4：数组元素的合法和非法赋值</samp>
- en: The first assignment expression, which assigns to <samp class="SANS_TheSansMonoCd_W5Regular_11">**nested_array</samp>,
    is valid. First, we implicitly convert the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">nested_array</samp>
    to a pointer to the array’s initial element. That element has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp>,
    so the type of the pointer is <samp class="SANS_TheSansMonoCd_W5Regular_11">int(*)[2]</samp>.
    The first dereference operation on this pointer results in an array object with
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp>. We implicitly
    convert *this* array to a pointer with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>. The second pointer dereference therefore produces an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    object, which we can assign to. The assignment expression overwrites that object’s
    current value, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, with a
    new value, <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int(*)[2]</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp> pointers in this expression both point to the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">nested_array</samp>;
    only their types differ.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个赋值表达式，将值赋给<samp class="SANS_TheSansMonoCd_W5Regular_11">**nested_array</samp>，是有效的。首先，我们隐式地将变量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nested_array</samp>转换为指向数组初始元素的指针。该元素的类型是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp>，因此指针的类型是<samp class="SANS_TheSansMonoCd_W5Regular_11">int(*)[2]</samp>。对这个指针的第一次解引用操作会返回一个类型为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp>的数组对象。我们隐式地将*这个*数组转换为类型为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>的指针。因此，第二次指针解引用操作产生一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>对象，我们可以对其进行赋值。赋值表达式将该对象当前的值<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>覆盖为新值<samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>。这个表达式中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int(*)[2]</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>指针都指向<samp class="SANS_TheSansMonoCd_W5Regular_11">nested_array</samp>的起始位置；只是它们的类型不同。
- en: 'The next assignment expression, which assigns to <samp class="SANS_TheSansMonoCd_W5Regular_11">*nested_array</samp>,
    is illegal. It starts out as before: we implicitly convert <samp class="SANS_TheSansMonoCd_W5Regular_11">nested_array</samp>
    to a pointer of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int(*)[2]</samp>,
    dereference it, and implicitly convert the result to a pointer of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>. We then try to assign directly to this pointer, but the C standard states
    that the result of this implicit conversion “is not an lvalue,” so we can’t assign
    to it. It’s not clear what this assignment would do even if it were permitted;
    it would be like assigning to the result of an <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operation.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个赋值表达式，将值赋给<samp class="SANS_TheSansMonoCd_W5Regular_11">*nested_array</samp>，是非法的。它的开始与之前相同：我们隐式地将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nested_array</samp>转换为类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">int(*)[2]</samp>的指针，解引用它，并隐式地将结果转换为类型为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>的指针。接着，我们尝试直接赋值给这个指针，但C标准声明这个隐式转换的结果“不是一个左值”，因此我们不能赋值给它。即使允许这种赋值，也不清楚它会做什么；它就像是对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">&</samp>操作的结果进行赋值一样。
- en: Now we know how to access an array’s initial element in any dimension. We can
    even read and write to the initial scalar object in an array. However, we usually
    want to access an array’s other elements too. For that, we’ll need pointer arithmetic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何访问数组的初始元素，无论在哪个维度。我们甚至可以读写数组中的初始标量对象。然而，我们通常还希望访问数组的其他元素。为此，我们需要使用指针运算。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pointer Arithmetic
    to Access Array Elements</samp>
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用指针运算访问数组元素</samp>
- en: Once we have a pointer to an array’s initial element, we’ll use pointer addition
    to produce pointers to its other elements. Let’s work through the example in [Listing
    15-5](chapter15.xhtml#list15-5).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了指向数组初始元素的指针，我们就可以使用指针加法来生成指向数组其他元素的指针。让我们通过[列表 15-5](chapter15.xhtml#list15-5)中的例子来讲解。
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-5: Accessing later
    array elements with pointer arithmetic</samp>'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 15-5：使用指针运算访问数组后续元素</samp>
- en: We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp> again as
    the array’s starting address. In the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> decays
    to a pointer to the initial array element, as usual. When we add <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    to this pointer, the result is a pointer to the next <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    element in the array. Since each <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    is 4 bytes, we need to multiply <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    by a scale of 4 to calculate how many bytes to add to <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>’s
    address. The resulting pointer’s value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0x14</samp>.
    If we dereferenced this pointer, we would get the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    object at address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x14</samp>, whose
    current value is <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>. Array
    elements are zero indexed, so we say the initial element of <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>
    is at index 0 and the next element is at index 1.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用<samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>作为数组的起始地址。在表达式<samp
    class="SANS_TheSansMonoCd_W5Regular_11">array</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>中，变量<samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>像往常一样变为指向初始数组元素的指针。当我们将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>加到这个指针时，结果是指向数组中下一个<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>元素的指针。由于每个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>是4个字节，我们需要将<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>乘以4的倍数来计算需要加到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">array</samp>地址的字节数。结果指针的值是<samp class="SANS_TheSansMonoCd_W5Regular_11">0x14</samp>。如果我们解引用这个指针，我们将得到地址<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x14</samp>处的<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>对象，它的当前值是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">2</samp>。数组元素是从零开始索引的，所以我们说数组的初始元素位于索引0，下一元素位于索引1。
- en: More generally, when we add an integer *n* to a pointer, the result is a pointer
    to another array element at the position *n* elements further along in the array.
    Similarly, we can move backward in an array by subtracting an integer (or adding
    a negative integer). If the result would be outside the bounds of the array in
    either direction, the behavior is undefined.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，当我们将一个整数*n*加到一个指针时，结果是指向数组中位置为*n*个元素后移的另一个元素的指针。类似地，我们可以通过减去一个整数（或加上一个负整数）来在数组中向后移动。如果结果会超出数组的边界，行为是未定义的。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*If x is an* n*-element array, x + n points one past the end of x. This pointer
    is a special case. It’s not considered out of bounds, and you can use it in pointer
    arithmetic. For example, you can compare it to other pointers to elements in the
    same array. (When you’re looping through array elements, this is a useful way
    to test whether you’ve reached the end.) But dereferencing it is undefined behavior,
    because it doesn’t point to an element of the array.*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果x是一个*n*元素的数组，x + n指向x的末尾之后的位置。这个指针是一个特例，它不被认为是越界的，你可以在指针运算中使用它。例如，你可以将它与指向同一数组中其他元素的指针进行比较。（当你遍历数组元素时，这是一种有用的方式来测试你是否已经到达数组的末尾。）但解引用它是未定义行为，因为它并不指向数组中的任何元素。*'
- en: When we perform pointer arithmetic, the nested structure of the array we point
    into matters, because it dictates what counts as a single element. Let’s look
    at [Listing 15-6](chapter15.xhtml#list15-6) to see how this plays out for the
    two arrays we defined in [Listings 15-1](chapter15.xhtml#list15-1) and [15-2](chapter15.xhtml#list15-2),
    which had identical contents in memory.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行指针运算时，我们所指向的数组的嵌套结构非常重要，因为它决定了什么算作单个元素。让我们看一下[清单 15-6](chapter15.xhtml#list15-6)，看看这如何适用于我们在[清单
    15-1](chapter15.xhtml#list15-1)和[15-2](chapter15.xhtml#list15-2)中定义的两个数组，这两个数组在内存中具有相同的内容。
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-6: Pointer arithmetic
    with flat and nested arrays</samp>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-6：平面和嵌套数组的指针运算</samp>
- en: The result of the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    is a pointer to the element at index 1 in <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp>
    ❶. This element is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>. Similarly,
    when we compute <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    we get a pointer to the array element at index 1 in <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>
    ❷. In this case, however, this element is itself an array of two <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    objects, whose current values are <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>. Although <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp> may have
    identical contents in memory, performing the same operation on both of them produces
    very different results.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> 的结果是一个指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp>
    中索引 1 位置的元素的指针 ❶。该元素是一个值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    的 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。类似地，当我们计算 <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    时，我们得到一个指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp> 中索引
    1 位置的数组元素的指针 ❷。然而，在这种情况下，该元素本身是一个包含两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    对象的数组，其当前值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>。尽管
    <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>
    在内存中的内容可能相同，但对它们执行相同的操作会产生非常不同的结果。
- en: 'So how can we access the scalar objects in <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>?
    For example, how could we read the last <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    in this array, whose value is <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>?
    First, we’ll get a pointer to the last element in <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何访问 <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp> 中的标量对象呢？例如，如何读取这个数组中的最后一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，其值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>？首先，我们将获取指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp> 中最后一个元素的指针：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This points to the entire two-element array <samp class="SANS_TheSansMonoCd_W5Regular_11">{5,
    6}</samp>. We’ll dereference it to get a pointer to a single scalar element in
    this array instead:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指向整个包含两个元素的数组 <samp class="SANS_TheSansMonoCd_W5Regular_11">{5, 6}</samp>。我们将对其进行解引用，以获取指向该数组中单个标量元素的指针：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This dereference expression results in an array of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp>,
    which decays to a pointer with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>. Now <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_ptr</samp> points
    to the first <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in this
    nested array, whose value is <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>.
    We’ll increment it to point to the next <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    whose value is <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该解引用表达式会产生一个类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp>
    的数组，它会衰减为一个类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp> 的指针。现在，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">inner_ptr</samp> 指向这个嵌套数组中的第一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，其值为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>。我们将递增它，使其指向下一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，其值为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At that point, we can access its value with a normal pointer dereference:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以通过正常的指针解引用访问它的值：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can consolidate these statements into the single expression in [Listing 15-7](chapter15.xhtml#list15-7).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些语句合并为 [Listing 15-7](chapter15.xhtml#list15-7) 中的单一表达式。
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-7: Accessing the
    last</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">int</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">three_arrays</samp>'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-7: 访问</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">three_arrays</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">中的最后一个</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">int</samp>'
- en: Through repeated pointer addition, dereferencing, and implicit conversions from
    arrays to pointers, we can access any element in a multidimensional array. This
    is, obviously, a huge pain. The subscript operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>,
    provides more convenient syntax to accomplish the same thing. The expression <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp> is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">*(a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i)</samp>,
    so we can rewrite [Listing 15-7](chapter15.xhtml#list15-7) as [Listing 15-8](chapter15.xhtml#list15-8).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过反复的指针加法、解引用和从数组到指针的隐式转换，我们可以访问多维数组中的任何元素。显然，这是一个巨大的痛苦。下标操作符，<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>，提供了更方便的语法来完成相同的操作。表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp> 等价于 <samp class="SANS_TheSansMonoCd_W5Regular_11">*(a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i)</samp>，因此我们可以将
    [清单 15-7](chapter15.xhtml#list15-7) 改写为 [清单 15-8](chapter15.xhtml#list15-8)。
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-8: A more convenient
    way to access the last</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">int</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">three_arrays</samp>'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-8：更便捷的访问最后一个</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">int</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">在</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">three_arrays</samp>
- en: The last point I want to emphasize is that subscripting and pointer arithmetic
    apply to all pointers, not just pointers that decayed from arrays. If a pointed-to
    object isn’t in an array, we’ll treat it like the sole element in a one-element
    array. For example, [Listing 15-9](chapter15.xhtml#list15-9) is perfectly valid.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我想强调的最后一点是，下标和指针算术适用于所有指针，而不仅仅是从数组衰退出来的指针。如果被指向的对象不在数组中，我们将把它当作一个一元素数组中的唯一元素来处理。例如，[清单
    15-9](chapter15.xhtml#list15-9)是完全有效的。
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-9: Subscripting
    a pointer to a scalar object</samp>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-9：为标量对象进行下标操作</samp>
- en: When we add <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> and dereference the result,
    we get back the object <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
    Therefore, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr[0]</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>
    evaluates to 1 (that is, true).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> 加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    并解引用结果时，我们得到对象 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>。因此，表达式 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr[0]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> 评估为 1（即，真）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Even More Pointer
    Arithmetic</samp>
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">更多指针算术</samp>
- en: We’ll support two other operations on pointers. The first is subtraction; [Listing
    15-10](chapter15.xhtml#list15-10) gives an example.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将支持对指针进行另外两个操作。第一个是减法；[清单 15-10](chapter15.xhtml#list15-10)给出了一个示例。
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-10: Subtracting
    two pointers</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-10：减去两个指针</samp>
- en: When we subtract pointers to two elements in the same array, the result is the
    difference between their indices. In this example, unsurprisingly, we return <samp
    class="SANS_TheSansMonoCd_W5Regular_11">2</samp>.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们减去指向同一数组中两个元素的指针时，结果是它们索引之间的差值。在这个例子中，毫不意外地，我们返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>。
- en: We can also compare pointers to array elements, like in [Listing 15-11](chapter15.xhtml#list15-11).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以比较指向数组元素的指针，就像在 [清单 15-11](chapter15.xhtml#list15-11) 中一样。
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-11: Comparing pointers</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-11：比较指针</samp>
- en: The pointer to the element with the higher array index compares greater than
    the one with the lower index. In this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    points to the element at index 2 and <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>
    decays to a pointer to the element at index 0, so the comparison <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr
    > arr</samp> evaluates to 1\. If two pointers don’t point into the same array,
    the result of subtracting or comparing them is undefined.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 指向较高数组索引元素的指针会比较大于指向较低索引元素的指针。在这个例子中，<samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    指向索引为2的元素，<samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> 会退化为指向索引为0的元素的指针，因此比较
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr > arr</samp> 的结果为1。如果两个指针不指向同一个数组，那么它们相减或比较的结果是未定义的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array Types in Function
    Declarations</samp>
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">函数声明中的数组类型</samp>
- en: 'It’s illegal for a function to return an array, like in the following declaration:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 函数不能返回数组，如以下声明所示，这是不合法的：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A function can’t take arrays as parameters, either. Weirdly enough, the C standard
    lets you *declare* a function with array parameters, but it requires the compiler
    to adjust your function signature to take pointers instead. For example, the declaration
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也不能接受数组作为参数。奇怪的是，C标准允许你*声明*一个带有数组参数的函数，但它要求编译器将你的函数签名调整为接受指针。例如，声明
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'will be turned into:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将变为：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We’ll adjust parameters with array types to have the corresponding pointer types
    in the type checker.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调整带有数组类型的参数，使其在类型检查器中具有相应的指针类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Things We Aren’t
    Implementing</samp>
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">我们不实现的功能</samp>
- en: 'The features we won’t support are significant enough that I’ll mention them
    explicitly. We won’t implement variable-length arrays, whose length is determined
    at runtime, like this one:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会支持的功能足够重要，我会明确提到它们。我们不会实现可变长度数组，其长度在运行时决定，如下所示：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We’ll permit only constants as the dimensions in array declarations. We also
    won’t permit declarations of incomplete array types:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只允许常量作为数组声明中的维度。我们也不允许声明不完整的数组类型：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: C requires you to specify an array’s dimensions when you define it, but not
    when you declare it. However, we’ll require array dimensions in declarations as
    well as definitions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: C要求在定义数组时指定数组的维度，但在声明时不需要。然而，我们将要求在声明和定义中都指定数组维度。
- en: 'We won’t implement *compound literals*, which let you construct array objects
    (and other aggregate objects) outside of initializers:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会实现*复合字面量*，它允许你在初始化器外构造数组对象（以及其他聚合对象）：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Finally, we won’t fully support C’s semantics for initializing aggregate objects.
    Compound initializers are a bit of a free-for-all; you can omit braces, wrap scalar
    values in braces, or initialize some elements but not others. This makes it tricky
    to figure out which expression is supposed to initialize which element. We’ll
    take a much stricter approach. First of all, we’ll require braces around the initializers
    for each nested array. In other words, we’ll accept the declaration
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不会完全支持C的聚合对象初始化语义。复合初始化器有些自由，你可以省略花括号，将标量值包装在花括号中，或者初始化某些元素而不初始化其他元素。这使得很难弄清楚哪个表达式应该初始化哪个元素。我们将采取更严格的方法。首先，我们将要求每个嵌套数组的初始化器周围加上花括号。换句话说，我们将接受以下声明
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'but we’ll reject the following equivalent declaration, even though the C standard
    permits it:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们将拒绝以下等效的声明，尽管C标准允许它：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We’ll also reject braces around scalar initializers, like in the following
    example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将拒绝围绕标量初始化器的花括号，如下所示：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And we won’t support designators, which let you initialize elements out of
    order:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不支持设计符号，它允许你以非顺序的方式初始化元素：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, we *will* allow compound initializers that don’t initialize every
    array element, like the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们*将*允许不初始化每个数组元素的复合初始化器，如下所示：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this case, we’ll pad out any remaining elements with zeros; that’s the behavior
    the C standard requires. Now that we’ve clarified exactly what we will and won’t
    build, we can move on to the lexer.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将用零填充剩余的元素；这是C标准所要求的行为。现在我们已经明确了我们将构建和不会构建的内容，我们可以继续进行词法分析器的部分。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">词法分析器</samp>
- en: 'You’ll add two tokens in this chapter:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将添加两个标记：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">[</samp> An open square bracket
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">[</samp> 一个左方括号
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">]</samp> A close square bracket
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">]</samp> 一个右方括号
- en: After adding these tokens, you can test out your lexer.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这些标记后，你可以测试你的词法分析器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">解析器</samp>
- en: 'Next, we’ll add array types, subscript expressions, and compound initializers
    to the AST. An array’s type indicates the number of elements in the array and
    the type of those elements:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把数组类型、下标表达式和复合初始化器添加到抽象语法树（AST）中。数组的类型表示数组中元素的数量以及这些元素的类型：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can nest <samp class="SANS_TheSansMonoCd_W5Regular_11">Array</samp> constructors
    to specify a multidimensional array. For example, we’ll represent the type of
    the declaration
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过嵌套 <samp class="SANS_TheSansMonoCd_W5Regular_11">Array</samp> 构造器来指定多维数组。例如，我们将表示声明的类型
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: as <samp class="SANS_TheSansMonoCd_W5Regular_11">Array(Array(Int, 4), 3)</samp>.
    Since we won’t support variable-length arrays, every array type must have a constant
    size.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如 <samp class="SANS_TheSansMonoCd_W5Regular_11">Array(Array(Int, 4), 3)</samp>。由于我们不支持变长数组，每个数组类型必须具有常量大小。
- en: 'A subscript expression contains two subexpressions, a pointer and an index:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个下标表达式包含两个子表达式，一个指针和一个索引：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Surprisingly, the order in which these two subexpressions appear doesn’t matter;
    the expressions <samp class="SANS_TheSansMonoCd_W5Regular_11">x[1]</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1[x]</samp> are equivalent.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，这两个子表达式的出现顺序并不重要；表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">x[1]</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">1[x]</samp> 是等价的。
- en: 'Finally, we’ll add an <samp class="SANS_TheSansMonoCd_W5Regular_11">initializer</samp>
    construct to support both scalar and compound variable initializers:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">initializer</samp>
    构造，支持标量和复合变量初始化器：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp>
    to initialize arrays and <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleInit</samp>
    to initialize scalar objects, including individual array elements. We’ll use a
    nested <samp class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp> construct
    for each row in a multidimensional array. [Listing 15-12](chapter15.xhtml#list15-12)
    shows how to represent the initializer <samp class="SANS_TheSansMonoCd_W5Regular_11">{{1,
    2}, {3, 4}, {5, 6}}</samp>.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp> 来初始化数组，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleInit</samp> 来初始化标量对象，包括单个数组元素。对于多维数组的每一行，我们将使用嵌套的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp> 构造。 [Listing
    15-12](chapter15.xhtml#list15-12) 显示了如何表示初始化器 <samp class="SANS_TheSansMonoCd_W5Regular_11">{{1,
    2}, {3, 4}, {5, 6}}</samp>。
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-12: Representing
    the initializer for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">three_arrays</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">, from [Listing 15-2](chapter15.xhtml#list15-2),
    as an AST node</samp>'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-12: 表示来自 [Listing
    15-2](chapter15.xhtml#list15-2) 的</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">three_arrays</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11"> 初始化器作为 AST 节点</samp>'
- en: The type checker will annotate initializers with their types, just like it does
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> nodes. However you
    support type annotations on <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    nodes, you should do the same thing for <samp class="SANS_TheSansMonoCd_W5Regular_11">initializer</samp>.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器将用类型注释初始化器，就像它对 <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    节点所做的一样。无论你如何支持对 <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> 节点的类型注释，你也应该对
    <samp class="SANS_TheSansMonoCd_W5Regular_11">initializer</samp> 做同样的处理。
- en: '[Listing 15-13](chapter15.xhtml#list15-13) gives the complete AST definition,
    with this chapter’s additions bolded.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 15-13](chapter15.xhtml#list15-13) 给出了完整的 AST 定义，章节中的新增内容已加粗。'
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-13: The abstract
    syntax tree with array types, compound initializers, and subscript expressions</samp>'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-13: 包含数组类型、复合初始化器和下标表达式的抽象语法树</samp>'
- en: Let’s walk through how to parse each of these additions to the AST.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步解析如何将这些内容添加到 AST 中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Array Declarators</samp>
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">解析数组声明符</samp>
- en: You learned how to parse pointer and function declarators in the previous chapter;
    now we’ll extend that code to handle array declarators too. [Listing 15-14](chapter15.xhtml#list15-14)
    shows how to extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">declarator</samp>
    construct that we defined in [Listing 14-6](chapter14.xhtml#list14-6).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你在上一章学习了如何解析指针和函数声明符；现在我们将扩展该代码以处理数组声明符。[列表 15-14](chapter15.xhtml#list15-14)
    显示了如何扩展我们在[列表 14-6](chapter14.xhtml#list14-6)中定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">declarator</samp>
    构造。
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-14: Representing
    array declarators</samp>'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 15-14：表示数组声明符</samp>
- en: 'Next, we’ll add array declarators to the grammar. Since they have higher precedence
    than pointer declarators, they belong in the <samp class="SANS_TheSansMonoCd_W5Regular_11"><direct-declarator></samp>
    grammar rule:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向语法中添加数组声明符。由于它们的优先级高于指针声明符，因此它们应当属于 <samp class="SANS_TheSansMonoCd_W5Regular_11"><direct-declarator></samp>
    语法规则：
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A direct declarator is a simple declarator with an optional suffix: either
    a parenthesized list of function parameters or a sequence of constant array dimensions
    of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">[</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">const</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">]</samp>. Each <samp class="SANS_TheSansMonoCd_W5Regular_11">ArrayDeclarator</samp>
    specifies just one array dimension, so we’ll parse a <samp class="SANS_TheSansMonoCd_W5Regular_11"><declarator-suffix></samp>
    with multiple dimensions to a sequence of multiple nested <samp class="SANS_TheSansMonoCd_W5Regular_11">ArrayDeclarator</samp>
    nodes. For example, we’d parse the declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">array[1][2]</samp>
    to:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 直接声明符是一个简单的声明符，具有一个可选的后缀：要么是括起来的函数参数列表，要么是常量数组维度的序列，形式为 <samp class="SANS_TheSansMonoCd_W5Regular_11">[</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">const</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">]</samp>。每个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ArrayDeclarator</samp> 仅指定一个数组维度，因此我们将解析带有多个维度的
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><declarator-suffix></samp> 为多个嵌套的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ArrayDeclarator</samp> 节点。例如，我们将解析声明符
    <samp class="SANS_TheSansMonoCd_W5Regular_11">array[1][2]</samp> 为：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The grammar rule for <samp class="SANS_TheSansMonoCd_W5Regular_11"><declarator-suffix></samp>
    permits floating-point constants as array dimensions, but the C standard requires
    array dimensions to be integers. When you parse a <samp class="SANS_TheSansMonoCd_W5Regular_11"><declarator-suffix></samp>,
    you should reject floating-pointing constants and accept constants of any integer
    type. The C standard also requires array dimensions to be greater than zero, but
    Clang and GCC support zero-length arrays as a language extension. It’s up to you
    whether to accept zero-length arrays or reject them; the test suite doesn’t cover
    this case.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11"><declarator-suffix></samp> 的语法规则允许将浮点常量作为数组维度，但
    C 标准要求数组维度必须是整数。当你解析 <samp class="SANS_TheSansMonoCd_W5Regular_11"><declarator-suffix></samp>
    时，应该拒绝浮点常量并接受任何整数类型的常量。C 标准还要求数组维度必须大于零，但 Clang 和 GCC 支持零长度数组作为语言扩展。是否接受零长度数组由你决定；测试套件没有覆盖此情况。
- en: Finally, we’ll update <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>,
    which converts a <samp class="SANS_TheSansMonoCd_W5Regular_11">declarator</samp>
    construct into an AST node. [Listing 15-15](chapter15.xhtml#list15-15) illustrates
    how to handle array declarators in <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将更新 <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>，它将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">declarator</samp> 构造转化为 AST 节点。[列表
    15-15](chapter15.xhtml#list15-15) 说明了如何在 <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>
    中处理数组声明符。
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-15: Applying array
    type derivations</samp>'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 15-15：应用数组类型推导</samp>
- en: This listing follows the same pattern we introduced to derive pointer types
    in [Chapter 14](chapter14.xhtml).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表遵循我们在[第 14 章](chapter14.xhtml)中介绍的相同模式，用于推导指针类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Abstract
    Array Declarators</samp>
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">解析抽象数组声明符</samp>
- en: Next, let’s deal with abstract declarators, which specify types without declaring
    identifiers. We’ll parse abstract array declarators according to the grammar rule
    in [Listing 15-16](chapter15.xhtml#list15-16).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理抽象声明符，它们指定类型而不声明标识符。我们将根据[列表 15-16](chapter15.xhtml#list15-16)中的语法规则解析抽象数组声明符。
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-16: The grammar
    rule for abstract array declarators</samp>'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 15-16：抽象数组声明符的语法规则</samp>
- en: A direct abstract declarator is either a parenthesized declarator, optionally
    followed by a sequence of array dimensions, or just a sequence of array dimensions.
    (Remember that <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp> in EBNF
    syntax indicates zero or more repetitions, while <samp class="SANS_TheSansMonoCd_W5Regular_11">{}+</samp>
    indicates one or more repetitions.) We’ll take the same steps here that we took
    to support normal declarators. [Listing 15-17](chapter15.xhtml#list15-17) shows
    how to extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract_declarator</samp>
    construct.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个直接抽象声明符要么是一个括号包围的声明符，后面可选地跟随一系列数组维度，要么仅仅是一个数组维度的序列。（请记住，EBNF 语法中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    表示零次或多次重复，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">{}+</samp> 表示一次或多次重复。）我们将在这里采取与支持普通声明符时相同的步骤。[列表
    15-17](chapter15.xhtml#list15-17) 显示了如何扩展 <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract_declarator</samp>
    构造。
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-17: Representing
    abstract array declarators</samp>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 15-17：表示抽象数组声明符</samp>
- en: After updating <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract_declarator</samp>,
    we’ll change our parsing code to handle the grammar rule in [Listing 15-16](chapter15.xhtml#list15-16).
    (This code should accept integer constants as array dimensions and reject floating-point
    constants, just like the code to parse ordinary declarators.) Finally, we’ll update
    <samp class="SANS_TheSansMonoCd_W5Regular_11">process_abstract _declarator</samp>.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新了 <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract_declarator</samp>
    之后，我们将修改解析代码以处理 [列表 15-16](chapter15.xhtml#list15-16) 中的语法规则。（该代码应接受整数常量作为数组维度，并拒绝浮点常量，就像解析普通声明符的代码一样。）最后，我们将更新
    <samp class="SANS_TheSansMonoCd_W5Regular_11">process_abstract _declarator</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Compound
    Initializers</samp>
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">解析复合初始化器</samp>
- en: 'Now let’s define the grammar rule for initializers:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义初始化器的语法规则：
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This rule is straightforward: an initializer is either an expression or a brace-enclosed
    list of one or more nested initializers. Note that there can be a trailing comma
    after the last element in an initializer list: <samp class="SANS_TheSansMonoCd_W5Regular_11">{1,
    2, 3}</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">{1, 2, 3,}</samp>
    are both valid compound initializers.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则很简单：初始化器要么是一个表达式，要么是一个大括号包围的包含一个或多个嵌套初始化器的列表。注意，在初始化器列表的最后一个元素后可以有一个逗号：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">{1, 2, 3}</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">{1,
    2, 3,}</samp> 都是有效的复合初始化器。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Subscript
    Expressions</samp>
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">解析下标表达式</samp>
- en: 'The last new language feature we need to parse is the subscript operator. Subscripting
    is a *postfix* operator, which follows the expression it modifies. Postfix operators
    have higher precedence than prefix operators like <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>.
    We’ll break up the <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>
    grammar rule to reflect this difference in precedence. At the highest precedence
    level, we’ll have constants, variables, parenthesized expressions, and function
    calls:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解析的最后一个新语言特性是下标操作符。下标是一种*后缀*操作符，它跟随在它修改的表达式之后。后缀操作符的优先级高于前缀操作符，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>。我们将拆分
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp> 语法规则，以反映这种优先级差异。在最高优先级的层次上，我们将有常量、变量、括号表达式和函数调用：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, we’ll define a postfix expression as a primary expression, optionally
    followed by a sequence of subscript operators:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将定义后缀表达式作为基本表达式，后面可选地跟随一系列下标操作符：
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Each subscript operator is an expression enclosed in square brackets. Finally,
    we’ll define unary expressions, which include both prefix and cast operators:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 每个下标操作符都是一个被方括号包围的表达式。最后，我们将定义一元表达式，其中包括前缀操作符和强制转换操作符：
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[Listing 15-18](chapter15.xhtml#list15-18) shows the complete grammar, with
    this chapter’s changes bolded.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 15-18](chapter15.xhtml#list15-18) 显示了完整的语法，并将本章的更改加粗显示。'
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-18: The grammar
    with array types, compound initializers, and subscript expressions</samp>'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-18：包含数组类型、复合初始化器和下标表达式的语法</samp>
- en: Once you’ve updated your parser to account for all of the changes in [Listing
    15-18](chapter15.xhtml#list15-18), you’re ready to test it out.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你更新了你的解析器，以适应[清单 15-18](chapter15.xhtml#list15-18)中的所有更改，你就可以开始测试了。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Type Checker</samp>
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">类型检查器</samp>
- en: The type checker will do most of the heavy lifting in this chapter. It will
    add type information to subscript and pointer arithmetic expressions; validate
    the dimensions of compound initializers; and detect type errors, like casting
    an expression to an array type. It will also handle implicit conversions from
    array to pointer types. Just as we insert <samp class="SANS_TheSansMonoCd_W5Regular_11">Cast</samp>
    expressions into the AST to make implicit type conversions explicit, we’ll insert
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions to make
    conversions from arrays to pointers explicit.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器将在本章中完成大部分的繁重工作。它将为下标和指针算术表达式添加类型信息；验证复合初始化器的维度；并检测类型错误，例如将表达式强制转换为数组类型。它还将处理从数组到指针类型的隐式转换。就像我们将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Cast</samp>表达式插入到抽象语法树（AST）中以使隐式类型转换显式一样，我们将插入<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>表达式，以使从数组到指针的转换变得显式。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Arrays
    to Pointers</samp>
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将数组转换为指针</samp>
- en: We’ll convert any array type expression to a pointer, unless it’s already the
    operand of an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expression.
    This might sound familiar from the previous chapter, where we lvalue converted
    the result of every expression, except when we took its address or assigned to
    it. In [Chapter 14](chapter14.xhtml), we introduced a new <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>
    helper function to manage lvalue conversions; now we’ll use a similar design pattern
    in a different compiler pass. We’ll define a new <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    function, shown in [Listing 15-19](chapter15.xhtml#list15-19).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把任何数组类型的表达式转换为指针，除非它已经是<samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>表达式的操作数。这可能会让你想起上一章的内容，我们将每个表达式的结果转换为左值，除非我们获取了它的地址或对其进行了赋值。在[第14章](chapter14.xhtml)中，我们引入了一个新的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>助手函数来管理左值转换；现在，我们将在不同的编译器过程中使用类似的设计模式。我们将定义一个新的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>函数，如[清单 15-19](chapter15.xhtml#list15-19)所示。
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-19: Implicitly converting
    an array to a pointer</samp>'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-19：隐式将数组转换为指针</samp>
- en: 'If an expression has array type, we insert an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    operation to get its address. We then record its result type, which is a pointer
    to the array’s element type. This is a different result type than we’d get from
    an explicit <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator, which
    always produces a pointer to the type of its operand. Take the following declaration:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个表达式具有数组类型，我们插入一个<samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>操作以获取它的地址。然后我们记录它的结果类型，这是指向数组元素类型的指针。这与我们从显式的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">&</samp>操作符中得到的结果类型不同，后者总是返回指向操作数类型的指针。以下是一个声明示例：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">&arr</samp> has
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">int (*)[3]</samp>. The expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>, on the other hand, has
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. In the type checked
    AST, we’re using <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> to
    represent two ways of taking an object’s address, which yield different result
    types: through an implicit conversion or an explicit <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式<samp class="SANS_TheSansMonoCd_W5Regular_11">&arr</samp>的类型是<samp class="SANS_TheSansMonoCd_W5Regular_11">int
    (*)[3]</samp>。另一方面，表达式<samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>的类型是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>。在类型检查后的AST中，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>来表示获取对象地址的两种方式，它们会产生不同的结果类型：通过隐式转换或显式的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">&</samp>操作符。
- en: Once we’ve introduced <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>,
    we’ll use it in place of <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>
    to check both subexpressions and full expressions. The one exception is type checking
    the operand of <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>. This
    operand should not be converted from an array to a pointer, so we’ll continue
    to process it by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>
    directly.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦引入了 <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>，我们将用它代替
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp> 来检查子表达式和完整表达式。唯一的例外是类型检查
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> 的操作数。这个操作数不应从数组转换为指针，因此我们将继续通过直接调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp> 来处理它。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Validating Lvalues</samp>
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">验证 Lvalue</samp>
- en: We’ll change a couple of details about how we validate lvalues. First, we should
    recognize <samp class="SANS_TheSansMonoCd_W5Regular_11">Subscript</samp> expressions
    as lvalues, in addition to <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更改验证 lvalue 的一些细节。首先，我们应该将 <samp class="SANS_TheSansMonoCd_W5Regular_11">下标</samp>
    表达式作为 lvalue 识别，除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">变量</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">解引用</samp>。
- en: Second, we need to reject assignment expressions that try to assign to arrays.
    Once an array decays to a pointer, it’s no longer an lvalue and can’t be assigned
    to. To catch these invalid assignment expressions, we’ll process the left operand
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    before we check whether it’s an lvalue. [Listing 15-20](chapter15.xhtml#list15-20)
    shows the latest logic to type check assignment expressions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要拒绝尝试赋值给数组的赋值表达式。一旦数组衰退为指针，它就不再是 lvalue，不能进行赋值。为了捕捉这些无效的赋值表达式，我们将在检查它是否为
    lvalue 之前，用 <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    处理左操作数。[列表 15-20](chapter15.xhtml#list15-20) 显示了最新的逻辑来进行赋值表达式的类型检查。
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-20: Type checking
    assignment expressions</samp>'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 15-20：赋值表达式类型检查</samp>
- en: If the left operand is an array, <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    will wrap it in an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    operation. Then, since <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    isn’t an lvalue, the type checker will throw an error.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左操作数是数组，<samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    将把它包装在一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> 操作中。然后，由于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> 不是 lvalue，类型检查器将抛出错误。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking
    Pointer Arithmetic</samp>'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">指针算术类型检查</samp>'
- en: Next, we’ll extend addition, subtraction, and the relational operators to work
    with pointers. Adding any integer type to a pointer is valid. [Listing 15-21](chapter15.xhtml#list15-21)
    demonstrates how to type check addition.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将扩展加法、减法和关系运算符，使其能够与指针一起使用。将任何整数类型加到指针上是有效的。[列表 15-21](chapter15.xhtml#list15-21)
    演示了如何进行加法的类型检查。
- en: '[PRE52]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-21: Type checking
    pointer addition</samp>'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 15-21：指针加法类型检查</samp>
- en: To type check addition involving a pointer and an integer, we first convert
    the integer operand to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    ❶. This will simplify later compiler passes, when pointer indices will need to
    be 8 bytes wide so that we can add them to 8-byte memory addresses. This conversion
    doesn’t come from the C standard; we’re just adding it for our own convenience.
    But it also doesn’t violate the standard; converting a valid array index to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> won’t change its value, so
    the result of the whole expression is the same either way. (If an integer is too
    big to represent as a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>,
    we can safely assume that it’s not a valid array index, since no hardware supports
    arrays with anywhere close to 2^(63) elements.)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行包含指针和整数的加法类型检查，我们首先将整数操作数转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    ❶。这将简化后续编译器的处理过程，当指针索引需要是 8 字节宽时，以便我们可以将它们加到 8 字节的内存地址中。这个转换并非来自 C 标准；我们只是为了自己的方便而添加它。但它也不会违反标准；将有效的数组索引转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 不会改变它的值，因此整个表达式的结果无论如何都是相同的。（如果一个整数太大，无法表示为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>，我们可以安全地假设它不是一个有效的数组索引，因为没有硬件支持包含接近
    2^(63) 个元素的数组。）
- en: The result of pointer addition has the same type as the pointer operand ❷. We
    use the same logic whether the first or second operand is the pointer, so I’ve
    omitted the pseudocode for the latter case ❸. Finally, in any case other than
    adding a pointer to an integer or adding two arithmetic operands, we throw an
    error.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 指针相加的结果与指针操作数的类型相同 ❷。无论第一个还是第二个操作数是指针，我们都使用相同的逻辑，因此我省略了后一种情况的伪代码 ❸。最后，在除将指针加到整数或将两个算术操作数相加之外的任何情况下，我们都会抛出错误。
- en: 'Subtracting an integer from a pointer works the same way: we convert the integer
    operand to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and annotate
    the result with the same type as the pointer operand. The only difference is that
    operand order matters. You can subtract an integer from a pointer, but you can’t
    subtract a pointer from an integer.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 从指针中减去一个整数的方式与此相同：我们将整数操作数转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>，并使用与指针操作数相同的类型来注解结果。唯一的不同之处在于操作数的顺序很重要。你可以从指针中减去一个整数，但不能从整数中减去一个指针。
- en: When we subtract one pointer from another, both operands must have the same
    type, and the result has an implementation-defined signed integer type. We’ll
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> as the result type
    here, which is the norm on 64-bit systems. This type is supposed to be aliased
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">ptrdiff_t</samp> in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><stddef.h></samp> header, to help users
    write more portable code. Since we don’t support <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    and therefore can’t compile <samp class="SANS_TheSansMonoCd_W5Regular_11"><stddef.h></samp>,
    we’ll ignore this requirement.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从一个指针中减去另一个指针时，两个操作数必须具有相同的类型，结果会有一个实现定义的有符号整数类型。我们在这里使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    作为结果类型，这是64位系统上的标准类型。这个类型在 <samp class="SANS_TheSansMonoCd_W5Regular_11"><stddef.h></samp>
    头文件中应该被别名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptrdiff_t</samp>，以帮助用户编写更具可移植性的代码。由于我们不支持
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>，因此无法编译 <samp class="SANS_TheSansMonoCd_W5Regular_11"><stddef.h></samp>，所以我们将忽略这一要求。
- en: '[Listing 15-22](chapter15.xhtml#list15-22) demonstrates how to type check both
    cases of pointer subtraction.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 15-22](chapter15.xhtml#list15-22) 展示了如何进行指针减法的类型检查。'
- en: '[PRE53]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-22: Type checking
    pointer subtraction</samp>'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 15-22：指针减法的类型检查</samp>
- en: If an expression subtracts an integer from a pointer, we handle it just like
    pointer addition ❶. If it subtracts two pointers of the same type, we record <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> as the result type ❷. In any
    other case—if an expression subtracts two pointers of different types, subtracts
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> from a pointer,
    or subtracts a pointer from an arithmetic value—we’ll throw an error.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个表达式从指针中减去一个整数，我们就像处理指针相加那样处理它 ❶。如果它从两个相同类型的指针中减去，我们记录 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    作为结果类型 ❷。在任何其他情况下——如果表达式从两个不同类型的指针中减去，或者从指针中减去一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，或者从算术值中减去一个指针——我们都会抛出错误。
- en: Finally, let’s deal with the <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> operators. Each of
    these accepts two pointer operands of the same type and returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    These are pretty simple to type check, so I won’t provide pseudocode for this
    case.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们处理<samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">></samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp>操作符。每个操作符都接受两个相同类型的指针操作数，并返回一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。这些操作符的类型检查比较简单，因此我不会为这个情况提供伪代码。
- en: Note that none of these operators accept null pointer constants; they compare
    pointers to elements in the same array, but a null pointer, by definition, doesn’t
    point to an array element. By the same logic, you can’t subtract a pointer from
    a null pointer constant. If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is a pointer, the expressions <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">x !=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    are legal, but <samp class="SANS_TheSansMonoCd_W5Regular_11">0 - x</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0 < x</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    >=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> are not. (Clang
    and GCC are more permissive than the standard here; as a language extension, they
    both let you use null pointer constants with any relational operator. With this
    extension, any non-null pointer will compare greater than the null pointer constant.)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些操作符都不接受空指针常量；它们将指针与同一数组中的元素进行比较，但空指针根据定义并不指向数组元素。按照同样的逻辑，你不能从空指针常量中减去一个指针。如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>是一个指针，那么表达式<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">x !=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    是合法的，但<samp class="SANS_TheSansMonoCd_W5Regular_11">0 - x</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">0
    < x</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">x >=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>则不是。
    (Clang和GCC在这里比标准更宽松；作为语言扩展，它们允许你在任何关系操作符中使用空指针常量。使用此扩展时，任何非空指针都会与空指针常量进行“大于”的比较。)
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Subscript
    Expressions</samp>
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">下标表达式的类型检查</samp>
- en: One operand of a subscript expression must be a pointer, and the other must
    be an integer. The pointer’s referenced type is the result type. Remember that
    these two operands can appear in either order; we can’t assume that the pointer
    will be the first operand. [Listing 15-23](chapter15.xhtml#list15-23) shows how
    to type check subscript expressions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 下标表达式的一个操作数必须是指针，另一个操作数必须是整数。指针所引用的类型是结果类型。记住，这两个操作数可以任意顺序出现；我们不能假设指针一定是第一个操作数。[列表
    15-23](chapter15.xhtml#list15-23)展示了如何进行下标表达式的类型检查。
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-23: Type checking
    a subscript expression</samp>'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 15-23：类型检查下标表达式</samp>
- en: First, we validate that one operand is a pointer and the other is an integer
    ❶. We then convert the integer operand to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    ❷. Finally, we annotate the whole expression with the pointer’s referenced type
    ❸.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们验证一个操作数是指针，另一个是整数 ❶。然后，我们将整数操作数转换为<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    ❷。最后，我们用指针所引用的类型注解整个表达式 ❸。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Cast
    Expressions</samp>
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">类型检查类型转换表达式</samp>
- en: 'This one is easy: you can’t cast an expression to an array type. For example,
    the expression'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个很简单：你不能将一个表达式转换为数组类型。例如，表达式
- en: '[PRE55]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: is invalid and should produce a type error.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 是无效的，应该产生类型错误。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Function
    Declarations</samp>
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">类型检查函数声明</samp>
- en: When we process a function declaration, we consider both its return type and
    its parameter types. If a function returns an array type, we throw an error. If
    any of its parameters has an array type, we adjust it to a pointer type instead.
    [Listing 15-24](chapter15.xhtml#list15-24) describes how to validate and implicitly
    adjust a function type.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理一个函数声明时，我们需要考虑其返回类型和参数类型。如果一个函数返回数组类型，我们会抛出一个错误。如果它的任何参数有数组类型，我们会将其调整为指针类型。
    [示例 15-24](chapter15.xhtml#list15-24)描述了如何验证并隐式调整函数类型。
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-24: Adjusting array
    types in function declarations</samp>'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 15-24：调整函数声明中的数组类型</samp>
- en: You should add this logic to the very beginning of <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_function
    _declaration</samp>, in order to adjust a function’s parameter types before you
    check whether it conflicts with prior definitions of the same identifier. You
    should also ensure that both the symbol table and the AST node itself use the
    adjusted parameter types.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将这段逻辑添加到<samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_function
    _declaration</samp>的开头，以便在检查函数参数类型是否与同一标识符的先前定义冲突之前，先调整函数的参数类型。你还应该确保符号表和AST节点本身都使用已调整的参数类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Compound
    Initializers</samp>
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">类型检查复合初始化器</samp>
- en: We need to annotate each initializer with its type and emit an error if an initializer
    is incompatible with the type of the object it’s supposed to initialize. To type
    check a compound initializer, we first validate that the object it initializes
    is an array. Then, we recursively type check each nested initializer, validating
    that it’s compatible with the array’s element type. [Listing 15-25](chapter15.xhtml#list15-25)
    illustrates this approach.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为每个初始化器标注其类型，并在初始化器与其应初始化的对象的类型不兼容时发出错误。为了类型检查复合初始化器，我们首先验证它初始化的对象是否是一个数组。然后，我们递归地类型检查每个嵌套的初始化器，验证它是否与数组的元素类型兼容。[示例
    15-25](chapter15.xhtml#list15-25)演示了这种方法。
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-25: Type checking
    initializers</samp>'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 15-25：类型检查初始化器</samp>
- en: In the base case, an initializer is a single expression ❶. We’ll type check
    this expression, then call <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>,
    which we defined in [Chapter 14](chapter14.xhtml), to convert it to the target
    type. If it’s not compatible with the target type, <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>
    will throw an error (this includes cases where the target type is an array type).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本情况下，初始化器是一个单一的表达式❶。我们将对这个表达式进行类型检查，然后调用<samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>，该函数在[第14章](chapter14.xhtml)中定义，用来将其转换为目标类型。如果它与目标类型不兼容，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>会抛出一个错误（这包括目标类型是数组类型的情况）。
- en: In the recursive case, we’ll initialize an array using a compound initializer
    ❷. Each item in the list will initialize one element in the array. First, we’ll
    check that the list doesn’t contain too many elements ❸. Then, we’ll type check
    each list item recursively, using the array’s element type as the target type
    ❹. If the initializer list contains too few elements, we’ll pad it with zeros
    ❺. We’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>
    helper function, which I haven’t provided pseudocode for, to produce zero-valued
    initializers that we can add to the initializer list. Given a scalar type, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp> should return
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleInit</samp> of that type
    with the value 0\. Given an array type, it should return a <samp class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp>
    whose scalar elements (which may be nested several layers deep) have the value
    0\. For example, calling <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>
    on the type <samp class="SANS_TheSansMonoCd_W5Regular_11">UInt</samp> should return
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在递归情况下，我们将使用复合初始化器❷初始化一个数组。列表中的每个项将初始化数组中的一个元素。首先，我们将检查列表中是否包含太多元素❸。然后，我们将递归地对每个列表项进行类型检查，使用数组的元素类型作为目标类型❹。如果初始化器列表包含的元素太少，我们将用零来填充❺。我们将使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>辅助函数，我没有提供伪代码，用来生成可以添加到初始化器列表中的零值初始化器。给定一个标量类型，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>应该返回一个值为0的该类型的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SingleInit</samp>。给定一个数组类型，它应该返回一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp>，其中标量元素（可能嵌套多层）值为0。例如，调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">UInt</samp>时应该返回
- en: '[PRE58]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'and calling it on the type <samp class="SANS_TheSansMonoCd_W5Regular_11">Array(Array(Int,
    2), 2)</samp> should return:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">Array(Array(Int, 2), 2)</samp>时应该返回：
- en: '[PRE59]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Once we’ve finished building the type checked list of initializers, we’ll package
    it into a <samp class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp>, which
    we’ll annotate with the target type ❻. If the initializer isn’t a single expression
    and the target type isn’t an array type, we’re trying to initialize a scalar object
    with a compound initializer, so we’ll throw an error ❼.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了构建类型检查过的初始化器列表，我们将把它打包成一个<samp class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp>，并用目标类型❻进行注解。如果初始化器不是一个单一的表达式且目标类型不是数组类型，我们正在尝试用复合初始化器初始化一个标量对象，因此我们会抛出错误❼。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Initializing Static
    Arrays</samp>
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">初始化静态数组</samp>
- en: 'As with other static variables, we’ll store the initial values of static arrays
    in the symbol table. We’ll need to update the data structures we use to represent
    these initial values. We’ll represent the initializer for every object as a list
    of scalar values:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他静态变量一样，我们将静态数组的初始值存储在符号表中。我们需要更新用来表示这些初始值的数据结构。我们将每个对象的初始化器表示为标量值的列表：
- en: '[PRE60]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: For scalar objects, <samp class="SANS_TheSansMonoCd_W5Regular_11">init_list</samp>
    will have only one element. The declaration
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标量对象，<samp class="SANS_TheSansMonoCd_W5Regular_11">init_list</samp>将只有一个元素。声明
- en: '[PRE61]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'will have this initializer:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 将会有这个初始化器：
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: For multidimensional arrays, we’ll flatten out any nested structures. Therefore,
    the declaration
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多维数组，我们将展平任何嵌套的结构。因此，声明
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'will have this initializer:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 将会有这个初始化器：
- en: '[PRE64]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we’ll add a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    constructor to represent zeroed-out objects of any size:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个<samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>构造函数，用于表示任何大小的零初始化对象：
- en: '[PRE65]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">bytes</samp> argument to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> specifies how many bytes
    to initialize to zero. If a static array is only partially initialized, we’ll
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> to pad out any
    uninitialized elements. For example, the declaration
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>的<code>bytes</code>参数指定了要初始化为零的字节数。如果一个静态数组只部分初始化，我们会使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>来填充任何未初始化的元素。例如，声明
- en: '[PRE66]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'will have this initializer:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将会有这个初始化器：
- en: '[PRE67]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The second element of this initializer list, <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(4)</samp>,
    initializes the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> at <samp
    class="SANS_TheSansMonoCd_W5Regular_11">nested[0][1]</samp>; the last element,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(8)</samp>, initializes
    both elements of the nested array <samp class="SANS_TheSansMonoCd_W5Regular_11">nested[2]</samp>.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 该初始化器列表的第二个元素，<samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(4)</samp>，初始化了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nested[0][1]</samp>处的<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>；最后一个元素，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(8)</samp>，初始化了嵌套数组<samp class="SANS_TheSansMonoCd_W5Regular_11">nested[2]</samp>的两个元素。
- en: Once you’ve updated the <samp class="SANS_TheSansMonoCd_W5Regular_11">initial_value</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> data structures,
    write a function to convert a compound initializer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    list. You’ll need to validate that initializers for static arrays have the correct
    size and structure, just like initializers for non-static arrays; you should reject
    initializers with too many elements, scalar initializers for arrays, and compound
    initializers for scalar objects. I won’t provide pseudocode for this transformation,
    since it’s similar to the way we type check non-static initializers in [Listing
    15-25](chapter15.xhtml#list15-25).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你更新了<samp class="SANS_TheSansMonoCd_W5Regular_11">initial_value</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>数据结构，编写一个函数将复合初始化器转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>列表。你需要验证静态数组的初始化器是否具有正确的大小和结构，就像对非静态数组初始化器进行类型检查一样；你应该拒绝具有过多元素的初始化器、用于数组的标量初始化器以及用于标量对象的复合初始化器。我不会为这个转换提供伪代码，因为它与我们在[列表
    15-25](chapter15.xhtml#list15-25)中检查非静态初始化器的方式类似。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Initializing Scalar
    Variables with ZeroInit</samp>
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用 ZeroInit 初始化标量变量</samp>
- en: You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    to initialize scalar variables to zero. For instance, given the declaration
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>来将标量变量初始化为零。例如，给定以下声明
- en: '[PRE68]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'you could use this initializer:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下初始化器：
- en: '[PRE69]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Using <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> here is
    optional, but it makes code emission simpler because you can easily tell which
    initializers belong in <samp class="SANS_TheSansMonoCd_W5Regular_11">.data</samp>
    and which belong in <samp class="SANS_TheSansMonoCd_W5Regular_11">.bss</samp>.
    Just be careful about using <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    to initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>s; use
    it only if you’re sure the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>’s
    initial value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp> and
    not <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>是可选的，但它使得代码的生成更加简单，因为你可以轻松地判断哪些初始化器属于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">.data</samp>段，哪些属于<samp class="SANS_TheSansMonoCd_W5Regular_11">.bss</samp>段。只需小心不要使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>来初始化<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>类型；仅当你确定该<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>的初始值为<samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>而非<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>时，才使用它。
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">TACKY 生成</samp>
- en: 'To accommodate pointer arithmetic and compound initializers, we’ll make a few
    changes to the TACKY IR. First, since we changed how we represent initializers
    in the symbol table, we’ll make the corresponding change in TACKY:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应指针运算和复合初始化器，我们将对 TACKY IR 进行一些更改。首先，由于我们改变了在符号表中表示初始化器的方式，我们将在 TACKY 中进行相应的更改：
- en: '[PRE70]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We’ll also introduce a new instruction to support pointer arithmetic:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将引入一个新的指令来支持指针运算：
- en: '[PRE71]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We’ll use this instruction to add or subtract an integer from a pointer, but
    not to subtract one pointer from another. The <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp>
    operand is the size, in bytes, of each element in the array that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    points into. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp>
    operand will be <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, since
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is 4 bytes. If <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    (*)[3]</samp>, a pointer to an array of three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    objects, then <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp> will
    be <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    operand tells us how many elements forward or back to move from the base pointer.
    At runtime, the program will multiply <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp> to determine how
    many bytes to add to the base pointer. It would be possible to implement pointer
    arithmetic using the existing TACKY instructions for multiplication and addition.
    However, introducing a specialized <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction here will help us take advantage of the x64 architecture’s built-in
    support for pointer arithmetic.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用此指令将一个整数加到或从指针中减去，但不能将一个指针从另一个指针中减去。<samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp>
    操作数是数组中每个元素的大小（以字节为单位），而 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    指向的正是这个数组。例如，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> 是一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>，那么 <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp>
    操作数将是 <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>，因为一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    占 4 个字节。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> 是一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int (*)[3]</samp>，即指向一个包含三个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    对象的数组的指针，那么 <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp> 将是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">12</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    操作数告诉我们从基指针开始，应该向前或向后移动多少个元素。在运行时，程序将把 <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    乘以 <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp> 来确定要加到基指针上的字节数。虽然可以使用现有的
    TACKY 指令进行乘法和加法运算来实现指针算术，但在这里引入一个专门的 <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    指令，将有助于我们利用 x64 架构对指针算术的内建支持。
- en: 'We’ll introduce one more instruction to support compound initializers:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍另一个指令，以支持复合初始化器：
- en: '[PRE72]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In this instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    is a scalar value, <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> is
    the name of some variable of aggregate type, and <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>
    specifies the number of bytes between the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    and the position we should copy <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    to. It’s important to note that <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    designates an array, *not* a pointer to an array element. In other words, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> doesn’t use the value
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>; it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    to identify an object with a fixed location in memory. Because this instruction
    operates directly on arrays, rather than pointers, it’s useful for array initialization
    but not for subscripting. In [Chapter 18](chapter18.xhtml), we’ll use it to initialize
    and update structures too.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在此指令中，<samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> 是一个标量值，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> 是某个聚合类型变量的名称，<samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>
    指定了 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> 的起始位置与我们应该将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">src</samp> 复制到的位置之间的字节数。值得注意的是，<samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    表示的是一个数组，*不是*指向数组元素的指针。换句话说，<samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    不使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> 的值，而是使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    来标识一个在内存中位置固定的对象。由于此指令直接作用于数组，而不是指针，因此它对于数组初始化很有用，但不适用于下标操作。在 [第18章](chapter18.xhtml)
    中，我们还将使用它来初始化和更新结构体。
- en: '[Listing 15-26](chapter15.xhtml#list15-26) shows the updated TACKY IR, with
    this chapter’s changes bolded.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 15-26](chapter15.xhtml#list15-26)展示了更新后的TACKY IR，本章的更改以粗体标出。'
- en: '[PRE73]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-26: Adding support
    for arrays to the TACKY IR</samp>'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-26: 向TACKY IR添加对数组的支持</samp>'
- en: With these additions, we can implement every new operator and construct in this
    chapter. Let’s handle each of them in turn.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些新增的功能，我们可以实现本章中每个新的运算符和构造。让我们依次处理它们。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pointer Arithmetic</samp>
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">指针运算</samp>
- en: We’ll implement the pointer arithmetic expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp>
    with an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> instruction,
    as [Listing 15-27](chapter15.xhtml#list15-27) demonstrates.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> 指令实现指针运算表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp>，正如[Listing
    15-27](chapter15.xhtml#list15-27)所示。
- en: '[PRE74]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-27: Adding an integer
    to a pointer in TACKY</samp>'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-27: 在TACKY中将整数加到指针上</samp>'
- en: There are a couple of things to note about this listing. First, the pointer
    is always the first operand to the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction and the integer is always the second, regardless of which was the
    first operand in the original expression. Second, you need to calculate the size
    of the pointer’s referenced type at compile time, since the <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp>
    operand is a constant rather than a TACKY value.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个列表，有几个要注意的地方。首先，指针始终是 <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    指令的第一个操作数，整数始终是第二个操作数，无论它们在原始表达式中的顺序如何。第二，您需要在编译时计算指针引用类型的大小，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp>
    操作数是常量，而不是TACKY值。
- en: The TACKY to subtract an integer from a pointer is almost identical; we just
    negate the index before we include it in <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>.
    We’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp>
    to the TACKY in [Listing 15-28](chapter15.xhtml#list15-28).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 从指针中减去整数的TACKY操作几乎是相同的；我们只是先对索引取反，然后再将其包括在 <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    中。我们将 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr></samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp>
    转换为[TACKY](chapter15.xhtml#list15-28)中的表示方式。
- en: '[PRE75]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-28: Subtracting
    an integer from a pointer in TACKY</samp>'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-28: 在TACKY中从指针减去整数</samp>'
- en: Subtracting one pointer from another works a bit differently. First, we calculate
    the difference in bytes, using an ordinary <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp>
    instruction. Then, we divide this result by the number of bytes in one array element,
    to calculate the difference between the two pointers in terms of array indices.
    In other words, we’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr2></samp>
    to the TACKY in [Listing 15-29](chapter15.xhtml#list15-29).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个指针减去另一个指针的操作稍有不同。首先，我们使用普通的<samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp>指令计算字节差值。然后，我们将结果除以一个数组元素的字节数，以计算两个指针之间的数组索引差异。换句话说，我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr1></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr2></samp> 转换为[TACKY](chapter15.xhtml#list15-29)中的表示方式。
- en: '[PRE76]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-29: Subtracting
    two pointers in TACKY</samp>'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-29: 在TACKY中从两个指针中减去</samp>'
- en: We’ll calculate the size of the referenced type at compile time. You can use
    the type of either operand here, since the type checker already validated that
    they both have the same type.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在编译时计算引用类型的大小。这里可以使用任一操作数的类型，因为类型检查器已经验证它们都具有相同的类型。
- en: We’ll compare pointers exactly like arithmetic values, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp> operators.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像处理算术值一样比较指针，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp> 操作符。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Subscripting</samp>
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">下标操作</samp>
- en: According to the C standard, the subscript expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr></samp>[<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp>] is equivalent to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp>. So, to implement a subscript
    expression, we’ll generate the TACKY for pointer addition from [Listing 15-27](chapter15.xhtml#list15-27)
    but return a <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(result)</samp>
    to the caller instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand(result)</samp>.
    Generating the right TACKY here is simple, but understanding why it works, especially
    for multidimensional arrays, is a little trickier. To explore this further, let’s
    work through the example in [Listing 15-30](chapter15.xhtml#list15-30).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 C 标准，下标表达式 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr></samp>[<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp>] 等价于 <samp class="SANS_TheSansMonoCd_W5Regular_11">*(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>。因此，为了实现下标表达式，我们将从
    [列表 15-27](chapter15.xhtml#list15-27) 中生成指针加法的 TACKY，但返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(result)</samp>
    给调用者，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand(result)</samp>。在这里生成正确的
    TACKY 很简单，但理解它为什么有效，尤其是对于多维数组，要稍微复杂一些。为了进一步探讨这一点，让我们通过 [列表 15-30](chapter15.xhtml#list15-30)
    中的示例来深入了解。
- en: '[PRE77]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-30: Returning the
    result of a subscript operator</samp>'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 15-30：返回下标操作符的结果</samp>
- en: '[Listing 15-31](chapter15.xhtml#list15-31) shows the TACKY implementation of
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement in this
    example.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 15-31](chapter15.xhtml#list15-31) 显示了该示例中 TACKY 实现的 <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    语句。'
- en: '[PRE78]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-31: Implementing
    [Listing 15-30](chapter15.xhtml#list15-30) in TACKY</samp>'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 15-31：在 TACKY 中实现 [列表 15-30](chapter15.xhtml#list15-30)</samp>
- en: First, we issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    instruction to get a pointer to the first element in <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>.
    Then, we issue two <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instructions to calculate a pointer to the array element at <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i][j]</samp>.
    Finally, we use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction
    to read that array element’s current value into a temporary variable, which we
    return. [Listing 15-31](chapter15.xhtml#list15-31) is efficient, without any superfluous
    instructions. We saw earlier that array subscripting requires us to repeatedly
    get the addresses of array elements, perform pointer arithmetic, and dereference
    the result. But in this listing, we get an array’s address only once, at the beginning
    ❶, and we use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction
    to dereference a pointer only once, at the end ❷. How does our strategy for TACKY
    generation produce this result?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们发出一个<samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>指令，以获取指向数组<samp
    class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>中第一个元素的指针。接着，我们发出两个<samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>指令，计算指向数组元素<samp
    class="SANS_TheSansMonoCd_W5Regular_11">arr[i][j]</samp>的指针。最后，我们使用一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>指令，将该数组元素的当前值读入一个临时变量，并返回该值。[Listing
    15-31](chapter15.xhtml#list15-31)是高效的，没有任何多余的指令。我们之前看到，数组下标操作需要我们反复获取数组元素的地址，进行指针运算，并解引用结果。但是在这个清单中，我们只在开始时获取一次数组的地址❶，并且只在最后一次使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>指令解引用指针❷。我们的TACKY生成策略是如何实现这一结果的呢？
- en: '[Listing 15-32](chapter15.xhtml#list15-32) gives the AST for the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement in [Listing 15-30](chapter15.xhtml#list15-30). Let’s figure out how
    each subexpression in this AST is converted to TACKY.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 15-32](chapter15.xhtml#list15-32)给出了[Listing 15-30](chapter15.xhtml#list15-30)中<samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp>语句的AST。让我们来看看如何将这个AST中的每个子表达式转换为TACKY。'
- en: '[PRE79]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-32: The AST for
    [Listing 15-30](chapter15.xhtml#list15-30)</samp>'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-32: [Listing 15-30](chapter15.xhtml#list15-30)的AST</samp>'
- en: The AST includes the two <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    expressions we inserted during type checking. The inner one ❺ gets the address
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>, and the outer one
    ❸ gets the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i]</samp>.
    Of course, <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> would have been renamed
    during identifier resolution, but we’ll ignore that detail in this example (and
    in the later examples in this chapter).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 该AST包括我们在类型检查期间插入的两个<samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>表达式。内部的表达式❺获取<samp
    class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>的地址，而外部的表达式❸获取<samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i]</samp>的地址。当然，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">j</samp>在标识符解析期间会被重命名，但我们在这个示例中（以及本章后续示例中）忽略这个细节。
- en: 'As always, we convert this AST to TACKY in postorder, processing each expression’s
    operands before we process the expression itself. The first non-leaf AST node
    we process is the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    expression, which takes the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>
    ❺. We convert it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    instruction:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们按照后序遍历将这个AST转换为TACKY，在处理表达式本身之前先处理每个操作数。我们处理的第一个非叶子节点是内部的<samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>表达式，它获取<samp
    class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>的地址❺。我们将其转换为<samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>指令：
- en: '[PRE80]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Next, to implement the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">Subscript</samp>
    expression ❹, we emit an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了实现内部<samp class="SANS_TheSansMonoCd_W5Regular_11">Subscript</samp>表达式❹，我们发出一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>指令：
- en: '[PRE81]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The scale here is <samp class="SANS_TheSansMonoCd_W5Regular_11">16</samp> because
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> points to a four-<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> array. The second part of a
    subscript operation is dereferencing the result, so we’ll return <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(tmp1)</samp>
    to the caller.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的规模是 <samp class="SANS_TheSansMonoCd_W5Regular_11">16</samp>，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp>
    指向一个四个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 的数组。下标操作的第二部分是取消引用结果，因此我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(tmp1)</samp>
    返回给调用者。
- en: In the caller, we process the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    expression ❸. When we take the address of a dereferenced pointer, the operations
    cancel out. Therefore, we return <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand(tmp1)</samp>
    as the result of this expression, without emitting any further instructions.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用者中，我们处理外部的 <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> 表达式
    ❸。当我们获取取消引用指针的地址时，这些操作相互抵消。因此，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand(tmp1)</samp>
    作为这个表达式的结果返回，不会发出任何进一步的指令。
- en: 'Now we process the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">Subscript</samp>
    expression ❷. Once again, we emit an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们处理外部的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Subscript</samp> 表达式
    ❷。我们再次发出 <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> 指令：
- en: '[PRE82]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We then return <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(tmp2)</samp>
    to the caller. Because this <samp class="SANS_TheSansMonoCd_W5Regular_11">Subscript</samp>
    expression appears in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    statement ❶, not an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    or assignment expression, we lvalue convert this result. That means we emit a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(tmp2)</samp>
    返回给调用者。由于这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Subscript</samp> 表达式出现在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> 语句 ❶ 中，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    或赋值表达式中，我们对这个结果进行了左值转换。这意味着我们发出一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>
    指令：
- en: '[PRE83]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp3</samp> contains the
    lvalue-converted result of the whole expression, so we return it:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp3</samp> 包含了整个表达式左值转换后的结果，因此我们将其返回：
- en: '[PRE84]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: As this example illustrates, when we index into a multidimensional array the
    dereference operations and implicit address loads cancel each other out, without
    producing any extra instructions. Therefore, any subscript and dereference operators
    work out to pure pointer arithmetic in TACKY, without any <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instructions, until
    we reach a scalar array element.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个例子所示，当我们对一个多维数组进行索引时，取消引用操作和隐式地址加载相互抵消，不会产生任何额外的指令。因此，任何下标和取消引用操作在 TACKY
    中都会转化为纯粹的指针运算，不需要任何 <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> 指令，直到我们访问到标量数组元素。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Compound Initializers</samp>
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">复合初始化器</samp>
- en: To process a compound initializer, we evaluate each scalar expression in the
    initializer and copy it to the appropriate location in memory with a <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    instruction. For example, we’ll convert the initializer
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理复合初始化器，我们计算初始化器中每个标量表达式，并通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    指令将其复制到适当的内存位置。例如，我们将转换初始化器
- en: '[PRE85]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'to the following sequence of instructions:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为以下指令序列：
- en: '[PRE86]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Since a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> is 8 bytes,
    the offset increases by eight with each element. Even when we process a nested
    initializer, we only need to copy the scalar values at the leaves to the correct
    memory locations. For example, we’ll convert
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 是 8 字节，所以每个元素的偏移量增加
    8。即使我们处理嵌套的初始化器，我们也只需将叶子节点的标量值复制到正确的内存位置。例如，我们将转换
- en: '[PRE87]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'to:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为：
- en: '[PRE88]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This conversion is pretty straightforward, so I’ll omit the pseudocode for it.
    I will note, however, that you should use the type information the type checker
    added to each compound initializer to calculate the offset of each element.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这个转换相当直接，因此我会省略相关的伪代码。不过，我需要指出的是，你应该使用类型检查器为每个复合初始化器添加的类型信息来计算每个元素的偏移量。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tentative Array Definitions</samp>
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">暂定数组定义</samp>
- en: Recall that when we convert symbol table entries to <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>
    constructs, we initialize tentatively defined variables to zero. That goes for
    tentatively defined arrays too. You should use the new initializer we added in
    the previous section, <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>,
    to initialize an *n*-byte array to zero.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们将符号表条目转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>
    构造时，我们将暂定定义的变量初始化为零。暂定定义的数组也适用这一点。你应该使用我们在上一节中添加的新初始化器 <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
    来初始化一个 *n* 字节的数组为零。
- en: You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    to initialize tentatively defined scalar variables. For consistency, you should
    only use <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> here if
    you’re using it to initialize explicitly defined scalar variables to zero in the
    type checker.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> 来初始化暂定定义的标量变量。为了保持一致性，只有在你用它来初始化类型检查器中显式定义的标量变量为零时，才应该在这里使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">汇编生成</samp>
- en: 'We won’t introduce any new assembly instructions in this chapter. We will,
    however, introduce a new memory addressing mode, sometimes called *indexed addressing*.
    Right now, we can specify a memory operand with a base address in a register and
    a constant offset, like <samp class="SANS_TheSansMonoCd_W5Regular_11">4(%rax)</samp>.
    Using indexed addressing, we can store the base address in one register and an
    index in another. We can also specify a scale, which must be one of the constants
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>.
    Here’s an example of indexed addressing in action:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们不会引入任何新的汇编指令。不过，我们会介绍一种新的内存寻址模式，有时称为*索引寻址*。现在，我们可以使用寄存器中的基地址和常量偏移量来指定内存操作数，例如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4(%rax)</samp>。使用索引寻址时，我们可以将基地址存储在一个寄存器中，索引存储在另一个寄存器中。我们还可以指定一个比例因子，必须是常量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">4</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>
    之一。下面是一个索引寻址的示例：
- en: '[PRE89]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: To find the destination address of this <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    instruction, the CPU will calculate RAX + RBX × 4\. Then, it will store the 4-byte
    constant <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> at this address.
    This addressing mode is convenient for array accesses. If RAX holds the address
    of an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> objects
    and RBX holds an index *i* into that array, the operand <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rax,
    %rbx, 4)</samp> specifies the element at index *i*.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> 指令的目标地址，CPU
    将计算 RAX + RBX × 4。然后，它将在这个地址存储 4 字节常量 <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>。这种寻址模式对数组访问非常方便。如果
    RAX 存储了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型数组的地址，而 RBX
    存储了数组的索引 *i*，那么操作数 <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rax, %rbx,
    4)</samp> 指定了索引 *i* 处的元素。
- en: 'We’ll add a new operand to support indexed addressing:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个新操作数以支持索引寻址：
- en: '[PRE90]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We’ll also make a few other changes to the assembly AST to help with bookkeeping
    in later backend passes. For starters, we’ll add another operand to represent
    aggregate objects that haven’t been assigned a fixed address yet:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将对汇编 AST 做一些其他更改，以帮助后续后端处理中的账务管理。首先，我们将添加另一个操作数，用于表示尚未分配固定地址的聚合对象：
- en: '[PRE91]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> operand serves
    a similar purpose to the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    operand; it lets us represent variables in assembly before we’ve allocated registers
    or memory locations for them. The difference is that <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    represents aggregate objects, which we’ll always store in memory (even once we
    implement register allocation in [Part III](part3.xhtml)). <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>,
    on the other hand, represents scalar objects that could potentially be stored
    in registers. The <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operand also lets us specify a byte offset into the object in question. Note that
    the identifier in this operand designates an aggregate object, not a pointer to
    an aggregate object.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> 操作数的作用与现有的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> 操作数类似；它允许我们在为变量分配寄存器或内存位置之前，在汇编中表示这些变量。不同之处在于，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> 表示聚合对象，我们总是将它们存储在内存中（即使在[第三部分](part3.xhtml)实现寄存器分配后也是如此）。另一方面，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> 表示标量对象，这些对象有可能存储在寄存器中。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> 操作数还允许我们指定对象的字节偏移量。请注意，这个操作数中的标识符指定的是聚合对象，而不是指向聚合对象的指针。
- en: 'Next, we’ll add a new assembly type to represent arrays. In assembly, we’ll
    treat an array like an undifferentiated chunk of memory. We no longer need to
    track how many objects will be stored in that chunk of memory or what those objects’
    types will be. We do, however, care about its alignment and how much space it
    takes up, so we can allocate stack space for it. Therefore, we’ll convert array
    types to a new <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>
    type:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一种新的汇编类型来表示数组。在汇编中，我们将把数组当作一块未区分的内存块来处理。我们不再需要跟踪将要存储在该内存块中的对象数量或这些对象的类型。然而，我们关心它的对齐方式和占用的空间大小，以便为它分配栈空间。因此，我们将数组类型转换为新的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp> 类型：
- en: '[PRE92]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Finally, we’ll adjust how we represent static variables. As in earlier compiler
    passes, we’ll initialize a static variable with a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    values, instead of just one:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将调整如何表示静态变量。与早期的编译器阶段一样，我们将用一组 <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    值初始化静态变量，而不是仅用一个值：
- en: '[PRE93]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[Listing 15-33](chapter15.xhtml#list15-33) highlights all the changes to the
    assembly AST in this chapter.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 15-33](chapter15.xhtml#list15-33) 高亮显示了本章对汇编 AST 所做的所有更改。'
- en: '[PRE94]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-33: The assembly
    AST with support for aggregate objects and indexed addressing</samp>'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 15-33：具有聚合对象和索引寻址支持的汇编 AST</samp>
- en: Once we’ve updated the assembly AST, we’ll update the conversion from TACKY
    to assembly.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们更新了汇编 AST，我们将更新从 TACKY 到汇编的转换。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting TACKY
    to Assembly</samp>
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将 TACKY 转换为汇编</samp>
- en: First, we’ll deal with TACKY variables of array type. To distinguish these from
    scalar values, we’ll convert them to <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operands, instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    operands. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>
    is an array, we’ll convert
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将处理 TACKY 数组类型的变量。为了将这些与标量值区分开，我们将它们转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    操作数，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> 操作数。例如，如果
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> 是一个数组，我们将进行转换。
- en: '[PRE95]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'to:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 到：
- en: '[PRE96]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Whenever we convert an aggregate TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>
    to assembly, we’ll use an offset of zero, in order to designate the whole object.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们将一个聚合 TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> 转换为汇编时，我们会使用零偏移量，以指定整个对象。
- en: Next, let’s deal with the new <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> instructions.
    We’ll use a <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> operand
    with the appropriate offset to represent the destination of a <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    instruction. Therefore, we’ll convert
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们处理新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> 指令。我们将使用带有适当偏移量的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> 操作数来表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    指令的目标地址。因此，我们将转换
- en: '[PRE97]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'to:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 到：
- en: '[PRE98]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We’ll implement <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    with an <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp> instruction using
    the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp> operand.
    The details will vary depending on the scale and index. First, let’s consider
    the case where the scale is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>. We’ll convert
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp> 操作数，通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp> 指令实现 <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>。具体实现将根据比例和索引的不同而有所不同。首先，我们来考虑比例为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">4</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>
    的情况。我们将转换
- en: '[PRE99]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: to [Listing 15-34](chapter15.xhtml#list15-34).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 到 [列表 15-34](chapter15.xhtml#list15-34)。
- en: '[PRE100]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-34: Implementing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddPtr</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    assembly</samp>'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 15-34：在汇编中实现</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">AddPtr</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数</samp>
- en: First, we copy <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> into registers; I’ve
    used RAX and RDX here, but anything other than the callee-saved registers or our
    scratch registers will do. Then, we emit an <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp>
    instruction to compute <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">index
    * scale</samp> and store the result in <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    复制到寄存器中；我这里使用的是 RAX 和 RDX，但除了被调用保存的寄存器或我们的临时寄存器外，任何寄存器都可以。然后，我们发出一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp>
    指令，计算 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">index * scale</samp>，并将结果存储在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> 中。
- en: The scale of <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> may
    not be one of the four values that <samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp>
    supports, especially if we’re indexing into a multidimensional array instead of
    an array of scalar objects. In that case, we’ll use a separate instruction to
    multiply the scale by the index, as [Listing 15-35](chapter15.xhtml#list15-35)
    illustrates.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> 的比例可能不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp>
    支持的四个值之一，尤其是当我们对多维数组进行索引，而不是标量对象数组时。在这种情况下，我们将使用单独的指令将比例与索引相乘，正如 [列表 15-35](chapter15.xhtml#list15-35)
    所示。
- en: '[PRE101]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-35: Implementing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddPtr</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    assembly with a nonstandard scale</samp>'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 15-35：使用非标准比例在汇编中实现</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddPtr</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数</samp>
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> operand is
    a constant, we can save an instruction by computing <samp class="SANS_TheSansMonoCd_W5Regular_11">index
    * scale</samp> at compile time. Then, we’ll generate just the two instructions
    in [Listing 15-36](chapter15.xhtml#list15-36).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> 操作数是常量，我们可以通过在编译时计算
    <samp class="SANS_TheSansMonoCd_W5Regular_11">index * scale</samp> 来节省一条指令。然后，我们将仅生成
    [列表 15-36](chapter15.xhtml#list15-36) 中的两条指令。
- en: '[PRE102]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-36: Implementing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddPtr</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">with
    a constant index</samp>'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 15-36：实现</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddPtr</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">与常量索引</samp>
- en: 'Next, we’ll deal with pointer comparisons. We’ll implement these exactly like
    unsigned integer comparisons, using the unsigned condition codes: <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp>.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将处理指针比较。我们将像无符号整数比较一样实现这些，使用无符号条件码：<samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AE</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp>。
- en: 'Finally, let’s talk about the alignment requirements for arrays. There are
    a couple of cases where we need to calculate an array’s alignment: when we convert
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> of array
    type from TACKY to assembly (a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>
    in assembly includes an <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>
    field), and when we convert a frontend symbol table entry of array type to the
    corresponding entry in the backend symbol table. The assembly type of each array
    in the backend symbol table will be a <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>
    with the appropriate size and alignment. The size will be the size of the array’s
    element type in bytes, multiplied by the number of elements. The rules for calculating
    alignment are a bit less obvious.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来讨论一下数组的对齐要求。我们需要计算数组对齐的几种情况：当我们将一个数组类型的 <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>
    从 TACKY 转换为汇编代码时（汇编中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>
    包含一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp> 字段），以及当我们将一个前端符号表条目（数组类型）转换为后端符号表中的相应条目时。后端符号表中每个数组的汇编类型将是一个具有适当大小和对齐的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>。其大小将是数组元素类型的字节大小，乘以元素的数量。计算对齐的规则则不太直观。
- en: If an array is smaller than 16 bytes, it has the same alignment as its scalar
    elements. For example, an array with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp>
    and an array with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2][1]</samp>
    both have an alignment of 4\. If an array-type variable is 16 bytes or larger,
    its alignment is always 16, no matter what type its elements are. This requirement
    makes it possible to use SSE instructions to operate on multiple array elements
    at once. We don’t use SSE instructions this way, but we need to maintain ABI compatibility
    with other object files that might.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数组小于 16 字节，它与其标量元素具有相同的对齐方式。例如，一个类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp>
    的数组和一个类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2][1]</samp> 的数组都具有
    4 字节的对齐方式。如果一个数组类型的变量为 16 字节或更大，它的对齐方式始终为 16，无论其元素的类型是什么。这个要求使得可以使用 SSE 指令同时操作多个数组元素。虽然我们不会以这种方式使用
    SSE 指令，但我们需要与可能使用该指令的其他目标文件保持 ABI 兼容性。
- en: Note that this alignment requirement applies only to variables, not to nested
    arrays. For example, if we declare the variable
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个对齐要求仅适用于变量，而不适用于嵌套数组。例如，如果我们声明一个变量
- en: '[PRE103]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: then <samp class="SANS_TheSansMonoCd_W5Regular_11">nested</samp> needs to start
    at a 16-byte-aligned address because its total size is 60 bytes. But its first
    and second elements start at 20 and 40 bytes, respectively, from the start of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nested</samp>, so they aren’t 16-byte
    aligned, even though each of these elements is also larger than 16 bytes.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 <samp class="SANS_TheSansMonoCd_W5Regular_11">nested</samp> 需要从一个 16 字节对齐的地址开始，因为它的总大小为
    60 字节。但是它的第一个和第二个元素分别从 <samp class="SANS_TheSansMonoCd_W5Regular_11">nested</samp>
    的起始地址的 20 字节和 40 字节位置开始，因此它们并不是 16 字节对齐的，尽管这两个元素的大小也都大于 16 字节。
- en: '[Tables 15-1](chapter15.xhtml#tab15-1) through [15-5](chapter15.xhtml#tab15-5)
    summarize this chapter’s updates to this compiler pass; as usual, new constructs
    and changes to the conversions for existing constructs are bolded.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 15-1](chapter15.xhtml#tab15-1) 到 [15-5](chapter15.xhtml#tab15-5) 总结了本章对该编译器通道的更新；像往常一样，新的构造和现有构造转换的变化会加粗显示。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-1:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Top-Level TACKY Constructs to Assembly</samp>
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 15-1：</samp> <samp class="SANS_Futura_Std_Book_11">将顶层
    TACKY 结构转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 顶层结构</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编顶层结构</samp>
    |'
- en: '| --- | --- |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE104]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '|'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE105]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '|'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 15-2：</samp> <samp class="SANS_Futura_Std_Book_11">将
    TACKY 指令转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 指令</samp> |  | <samp class="SANS_Futura_Std_Heavy_B_11">汇编指令</samp>
    |'
- en: '| --- | --- | --- |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE106]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Constant index</samp> |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">常数索引</samp> |'
- en: '[PRE107]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '|'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE108]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '|'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE109]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '|'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE110]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '|'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE111]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '|'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE112]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '|'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE113]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '|'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-3:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Comparisons to Assembly</samp>
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 15-3：</samp> <samp class="SANS_Futura_Std_Book_11">将
    TACKY 比较转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY comparison</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly condition code</samp> |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 比较</samp> |  | <samp class="SANS_Futura_Std_Heavy_B_11">汇编条件码</samp>
    |'
- en: '| --- | --- | --- |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp> | <samp class="SANS_Futura_Std_Book_11">有符号</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> |'
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">pointer</samp><samp
    class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Book_11">无符号，</samp> <samp class="SANS_Futura_Std_Heavy_B_11">指针</samp><samp
    class="SANS_Futura_Std_Book_11">，或</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">双精度</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">LE</samp>
    |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">有符号</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">LE</samp>
    |'
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">pointer</samp><samp
    class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Book_11">无符号，</samp> <samp class="SANS_Futura_Std_Heavy_B_11">指针</samp><samp
    class="SANS_Futura_Std_Book_11">，或</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">双精度</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp>
    |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp> | <samp
    class="SANS_Futura_Std_Book_11">有符号</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp>
    |'
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">pointer</samp><samp
    class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Book_11">无符号，</samp> <samp class="SANS_Futura_Std_Heavy_B_11">指针</samp><samp
    class="SANS_Futura_Std_Book_11">，或</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">双精度</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">GE</samp>
    |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">有符号</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">GE</samp>
    |'
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">pointer</samp><samp
    class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp> |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Book_11">无符号，</samp> <samp class="SANS_Futura_Std_Heavy_B_11">指针</samp><samp
    class="SANS_Futura_Std_Book_11">，或</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">双精度</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp> |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-4:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Operands to Assembly</samp>
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 15-4:</samp> <samp class="SANS_Futura_Std_Book_11">将TACKY操作数转换为汇编代码</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY操作数</samp> |  | <samp class="SANS_Futura_Std_Heavy_B_11">汇编操作数</samp>
    |'
- en: '| --- | --- | --- |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Var(identifier)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Scalar value</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Pseudo(identifier)</samp>
    |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Var(标识符)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">标量值</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Pseudo(标识符)</samp> |'
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">Aggregate value</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">PseudoMem(identifier, 0)</samp> |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">聚合值</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">PseudoMem(标识符,
    0)</samp> |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-5:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Types to Assembly</samp>
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 15-5:</samp> <samp class="SANS_Futura_Std_Book_11">将类型转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp> |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">源类型</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编类型</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">对齐方式</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Array(element, size)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Variables that are 16 bytes or larger</samp>
    |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">数组(元素, 大小)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">16字节或更大的变量</samp>
    |'
- en: '[PRE114]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">16</samp> |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">16</samp> |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Everything else</samp> |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">其他所有内容</samp> |'
- en: '[PRE115]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Same alignment as element</samp>
    |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">与元素相同的对齐方式</samp> |'
- en: Next, we’ll replace <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operands with concrete addresses.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将用具体地址替换 <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    操作数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing PseudoMem
    Operands</samp>
  id: totrans-424
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">替换PseudoMem操作数</samp>
- en: We can’t call this pass “pseudoregister replacement” anymore, because we’re
    replacing aggregate values too. Just like we’ll allocate 4 bytes of stack space
    for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp> and 8 bytes
    for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>, we’ll allocate
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">size</samp> bytes for an
    object with type <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">size</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">alignment</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>.
    As usual, we’ll round down the array’s address to the appropriate alignment.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能再把这个阶段称为“伪寄存器替换”了，因为我们也在替换聚合值。就像我们会为一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">长字</samp>
    分配4个字节的栈空间，为一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">四字</samp> 分配8个字节一样，我们会为类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">大小</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">对齐方式</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> 的对象分配 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">大小</samp>
    字节的空间。像往常一样，我们会将数组的地址向下舍入到适当的对齐方式。
- en: 'Once an array has been assigned a memory address, we’ll replace any <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operands that refer to it. A <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operand includes an offset from the start of the array, and the array’s concrete
    address includes an offset from the address in RBP. We’ll add these two offsets
    to construct a new concrete memory address. For example, suppose we encounter
    the following instruction:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数组被分配了内存地址，我们将替换任何指向它的 <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    操作数。一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> 操作数包括数组起始位置的偏移量，而数组的具体地址则包括相对于RBP的地址偏移。我们将这两个偏移量相加，构造一个新的具体内存地址。例如，假设我们遇到以下指令：
- en: '[PRE116]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Let’s say that we previously assigned <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>
    the stack address <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>.
    We compute –12 + 4 to determine that our new, concrete operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>.
    We then rewrite the instruction accordingly:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们之前将<samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>分配为栈地址<samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>。我们计算-12
    + 4，得出我们的新操作数是<samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>。然后我们相应地重写指令：
- en: '[PRE117]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: To access an array with static storage duration, we use the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operand. If <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> is a static
    array, we convert
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问具有静态存储持续时间的数组，我们使用现有的<samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>操作数。如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>是一个静态数组，我们将转换
- en: '[PRE118]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'to:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 到：
- en: '[PRE119]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: If we encountered <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem("arr",</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
    for any nonzero <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp>,
    we’d be in trouble, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operand doesn’t include an offset. Luckily, this situation won’t come up. At the
    moment, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operands with nonzero offsets only to initialize arrays with automatic storage
    duration, not to access arrays with static storage duration.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到<samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem("arr",</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>，对于任何非零的<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp>，我们会遇到问题，因为<samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>操作数不包括偏移量。幸运的是，这种情况不会发生。目前，我们仅使用非零偏移量的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>操作数来初始化具有自动存储持续时间的数组，而不是访问具有静态存储持续时间的数组。
- en: RIP-relative addressing *does* support constant offsets—for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">foo+4(%rip)</samp>
    represents the address 4 bytes past the symbol <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>—but
    we can’t represent these offsets in the assembly AST yet. We’ll add them in [Chapter
    18](chapter18.xhtml) to support operations on structures.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: RIP相对寻址*支持*常量偏移量——例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">foo+4(%rip)</samp>表示符号<samp
    class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>之后的4个字节地址——但是我们目前无法在汇编AST中表示这些偏移量。我们将在[第18章](chapter18.xhtml)中添加它们，以支持对结构的操作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up Instructions</samp>
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">修正指令</samp>
- en: We didn’t introduce any new instructions, so we don’t need any new instruction
    fix-up rules. This pass must recognize that the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp>
    operand specifies a memory address and therefore can’t be used where a register
    or immediate value is required. Otherwise, we don’t need to change anything.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有引入新的指令，因此不需要新的指令修正规则。这个阶段必须识别出新的<samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp>操作数指定的是一个内存地址，因此不能在要求使用寄存器或立即数的地方使用。否则，我们不需要做任何更改。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">代码输出</samp>
- en: 'We’ll make four small additions to this stage. First, we’ll emit the new <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp> operand. Second, we’ll
    emit the static <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    initializer as a <samp class="SANS_TheSansMonoCd_W5Regular_11">.zero</samp> assembly
    directive. For example, we’ll emit <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(32)</samp>
    as:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对这个阶段进行四个小的修改。首先，我们会输出新的<samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp>操作数。第二，我们会将静态<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>初始化器作为<samp class="SANS_TheSansMonoCd_W5Regular_11">.zero</samp>汇编指令输出。例如，我们会将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(32)</samp>输出为：
- en: '[PRE120]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Third, if a variable’s only initializer is <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>,
    we’ll write it to the BSS section instead of the data section.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，如果变量的唯一初始化器是<samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>，我们将其写入BSS段，而不是数据段。
- en: And finally, when we define a static variable, we’ll emit each item in the associated
    initializer list. The file scope declaration
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们定义静态变量时，我们会在关联的初始化列表中逐一输出每个项。文件作用域声明
- en: '[PRE121]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: will ultimately be translated to the assembly in [Listing 15-37](chapter15.xhtml#list15-37).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 最终将会被转换为[Listing 15-37](chapter15.xhtml#list15-37)中的汇编代码。
- en: '[PRE122]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-37: Initializing
    a static array in assembly</samp>'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单15-37：在汇编中初始化静态数组</samp>
- en: Note that we initialize the last element of this array to zero because it wasn’t
    initialized explicitly.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将这个数组的最后一个元素初始化为零，因为它没有被显式初始化。
- en: '[Tables 15-6](chapter15.xhtml#tab15-6) through [15-8](chapter15.xhtml#tab15-8)
    summarize these additions to the code emission stage, with new constructs and
    changes to the way we emit existing constructs bolded.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '[表15-6](chapter15.xhtml#tab15-6)到[15-8](chapter15.xhtml#tab15-8)总结了这些新增的代码生成阶段内容，新的构造和对现有构造的更改已用粗体标出。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-6:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Top-Level Assembly Constructs</samp>
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表15-6：</samp> <samp class="SANS_Futura_Std_Book_11">格式化顶层汇编结构</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |  | <samp class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编顶层结构</samp> |  | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- | --- |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE123]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '|'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE124]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '|'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE125]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '|'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">All other variables</samp> |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">所有其他变量</samp> |'
- en: '[PRE126]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '|'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-7:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Static Initializers</samp>
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表15-7：</samp> <samp class="SANS_Futura_Std_Book_11">格式化静态初始化器</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Static initializer</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">静态初始化器</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">ZeroInit(n)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">.zero</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><n></samp> |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">ZeroInit(n)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">.zero</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><n></samp> |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-8:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表15-8：</samp> <samp class="SANS_Futura_Std_Book_11">格式化汇编操作数</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编操作数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Indexed(reg1, reg2, int)</samp>
    |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">索引(reg1, reg2, int)</samp> |'
- en: '[PRE127]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '|'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: After making these changes, you can test out your compiler.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些更改后，你可以测试你的编译器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: You’ve just implemented your first aggregate type! In this chapter, you learned
    how to parse array declarators and compound initializers. In the type checker,
    you made implicit conversions from arrays to pointers explicit and analyzed the
    types of pointer arithmetic expressions. During TACKY generation, you relied on
    those conversions and that type information to handle operations on pointers cleanly,
    regardless of whether they point to arrays or scalar values. And on the backend,
    you added new, more flexible ways to address values in memory.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚实现了你的第一个聚合类型！在这一章中，你学习了如何解析数组声明符和复合初始化器。在类型检查器中，你将数组到指针的隐式转换显式化，并分析了指针算术表达式的类型。在TACKY生成过程中，你依赖这些转换和类型信息来干净地处理指针操作，无论它们指向数组还是标量值。而在后端，你为内存中值的寻址添加了新的、更灵活的方式。
- en: 'In the next chapter, you’ll implement three more integer types: <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>. You’ll also implement string literals, which can be either array
    initializers or <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> arrays
    that decay to pointers, depending on context. Because you’ve already implemented
    integer types, pointers, and arrays, a lot of the groundwork for the work you’ll
    do there is already in place.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将实现另外三种整数类型：<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>。你还将实现字符串字面量，这些字面量可以是数组初始化器，也可以是根据上下文退化为指针的<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>数组。因为你已经实现了整数类型、指针和数组，所以你将要进行的工作的大部分基础已经到位。
