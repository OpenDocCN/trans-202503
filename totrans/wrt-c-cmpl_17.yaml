- en: '![](../images/pg382.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-38.xhtml)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ARRAYS
    AND POINTER ARITHMETIC</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, you’ll implement array types. You’ll also add the main language
    features that programmers use to work with arrays: compound initializers, subscript
    operators, and pointer arithmetic. Arrays and pointers are distinct but closely
    related types. Many expressions of array type are implicitly converted to pointers,
    and many pointer operations, like subscripting, are meant to operate on pointers
    to array elements. So, to support arrays, you’ll build on the support for pointers
    that you added in the previous chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: The type checker plays an especially critical role here. It will handle the
    implicit conversions from arrays to pointers and annotate the AST with the type
    information you’ll rely on to perform pointer arithmetic. Once the type checker
    has done all the hard work, it will be relatively easy to break down subscript
    operators and compound initializers into simple pointer operations during TACKY
    generation. You won’t add any new assembly instructions in this chapter, but you’ll
    introduce new operands to represent objects in memory and elements within those
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we’ll start with an overview of the language constructs we’re going
    to add. We’ll pay special attention to the relationship between pointers and arrays
    and how this relationship plays out in pointer arithmetic and subscript expressions.
    This is a particularly confusing aspect of C, and it’s key to everything we’ll
    do in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Arrays and Pointer Arithmetic</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s define a few terms up front. In the last chapter, we divided every object
    type we knew about into two categories: arithmetic types and non-arithmetic types.
    Now we’ll introduce another distinction. A *scalar type* represents a single value.
    The pointer and arithmetic types we’ve already implemented are all scalar types.
    An *aggregate type* represents a collection of values. Arrays are aggregate types;
    so are structures, which we’ll implement in [Chapter 18](chapter18.xhtml). All
    the values in an array have the same type, which is the array’s *element type*.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array Declarations
    and Initializers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we declare an array, we specify its element type and how many elements
    it contains. For example, we could declare an array of three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we could declare an array of five pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: (Remember that we interpret a declaration by starting with the basic type—<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, in this case—and then applying
    type derivations from the outside in.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of these examples use scalar element types, but we can use aggregate element
    types too. The following example declares an array of three elements, where each
    element is itself an array of two <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Arrays of arrays like this one are called *multidimensional arrays*. Note that
    we still apply type derivations from the outside in to determine this array’s
    type. We start with the base type <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>,
    apply the derivation specified by <samp class="SANS_TheSansMonoCd_W5Regular_11">[2]</samp>
    to get the type “array of two <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    objects,” and then apply the derivation specified by <samp class="SANS_TheSansMonoCd_W5Regular_11">[3]</samp>
    to get the type “array of three arrays of two <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    objects.”
  prefs: []
  type: TYPE_NORMAL
- en: 'You can initialize an array with a *compound initializer*, which specifies
    an initial value for each element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can initialize a multidimensional array with nested compound initializers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the three nested compound initializers initialize the three elements of
    the outer array. Each of those three elements is, itself, an array of two <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> objects. The nested initializer
    for each of these elements specifies two arithmetic values (which can be implicitly
    converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: You can also leave an array uninitialized. If it has automatic storage duration,
    its initial value will be undefined. If it has static storage duration, it will
    be initialized to all zeros. In other words, we treat uninitialized arrays exactly
    like uninitialized scalar objects.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Memory Layout of
    Arrays</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At this point, it’s helpful to talk a bit about the memory layout of flat and
    multidimensional arrays. If you declare an array of *n* objects, those *n* objects
    will be laid out sequentially in memory. Consider the array in [Listing 15-1](chapter15.xhtml#list15-1),
    which has a scalar element type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-1: An array of scalar
    values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-1](#fig15-1) shows what <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp>
    might look like in memory right after it’s initialized (the memory addresses in
    this figure are just for illustration; they wouldn’t be valid on a real system).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig15-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-1: The layout of</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">six_ints in memory [Description](description-39.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Compare this declaration to [Listing 15-2](chapter15.xhtml#list15-2), which
    declares a multidimensional array with the same number and type of scalar elements
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-2: An array of nested
    arrays</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The memory that holds <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>
    will also look like [Figure 15-1](#fig15-1). In memory, there’s no indication
    of where one element ends and another begins, so the two arrays are indistinguishable.
    Although the nested structure of <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>
    doesn’t impact its layout in memory, it does impact how you access individual
    array elements, as we’ll see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array-to-Pointer
    Decay</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once we’ve defined and initialized an array, what can we do with it? Not a
    lot, as it turns out. In fact, there are only two valid operations on objects
    of array type. First, we can get an array’s size with the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator, which we’ll implement in [Chapter 17](chapter17.xhtml). Second, we can
    get its address with the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s it! There are no other valid operations on arrays. That probably sounds
    ridiculous, since C programs read and write array elements all the time. What’s
    going on here? The C standard (section 6.3.2.1, paragraph 3) provides the solution
    to this puzzle: “Except when it is the operand of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator, or the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator … an expression that has type ‘array of *type*’ is converted to an expression
    with type ‘pointer to *type*’ that points to the initial element of the array
    object and is not an lvalue.”'
  prefs: []
  type: TYPE_NORMAL
- en: This implicit conversion from arrays to pointers is called *array-to-pointer
    decay*. (I’ll sometimes say that an array decays to a pointer, and sometimes that
    it’s implicitly converted to a pointer. They both mean the same thing.) While
    we can’t do much with arrays, we can perform all sorts of useful operations on
    pointers. We’ve already implemented some of these operations, and we’ll add a
    few more in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The code snippet in [Listing 15-3](chapter15.xhtml#list15-3) shows an example
    of array decay.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-3: Implicitly converting
    an array to a pointer</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say <samp class="SANS_TheSansMonoCd_W5Regular_11">my_array</samp> starts
    at address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>. When <samp
    class="SANS_TheSansMonoCd_W5Regular_11">my_array</samp> appears on the right side
    of the assignment expression in this listing, it will be implicitly converted
    to a pointer whose type is <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>
    and whose value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp> ❶.
    We can then assign this pointer’s value to <samp class="SANS_TheSansMonoCd_W5Regular_11">my_pointer</samp>.
    When we dereference <samp class="SANS_TheSansMonoCd_W5Regular_11">my_pointer</samp>,
    the result is the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> object
    stored in the first 4 bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">my_array</samp>
    ❷. Therefore, we’ll return this object’s current value, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    Note that the address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>
    can be interpreted in a couple of different ways, depending on its type. As an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>, it points to the array’s
    initial element, which we can read or write through a pointer dereference operation.
    The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">&my_array</samp>
    has the same value, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>,
    but it points to the whole array and its type is <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    (*)[3]</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: It’s especially important to keep track of a pointer’s type when working with
    multidimensional arrays. Consider [Listing 15-4](chapter15.xhtml#list15-4), which
    tries to assign to two array elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-4: Legal and illegal
    assignments to array elements</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first assignment expression, which assigns to <samp class="SANS_TheSansMonoCd_W5Regular_11">**nested_array</samp>,
    is valid. First, we implicitly convert the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">nested_array</samp>
    to a pointer to the array’s initial element. That element has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp>,
    so the type of the pointer is <samp class="SANS_TheSansMonoCd_W5Regular_11">int(*)[2]</samp>.
    The first dereference operation on this pointer results in an array object with
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp>. We implicitly
    convert *this* array to a pointer with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>. The second pointer dereference therefore produces an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    object, which we can assign to. The assignment expression overwrites that object’s
    current value, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, with a
    new value, <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int(*)[2]</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp> pointers in this expression both point to the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">nested_array</samp>;
    only their types differ.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next assignment expression, which assigns to <samp class="SANS_TheSansMonoCd_W5Regular_11">*nested_array</samp>,
    is illegal. It starts out as before: we implicitly convert <samp class="SANS_TheSansMonoCd_W5Regular_11">nested_array</samp>
    to a pointer of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int(*)[2]</samp>,
    dereference it, and implicitly convert the result to a pointer of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>. We then try to assign directly to this pointer, but the C standard states
    that the result of this implicit conversion “is not an lvalue,” so we can’t assign
    to it. It’s not clear what this assignment would do even if it were permitted;
    it would be like assigning to the result of an <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operation.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we know how to access an array’s initial element in any dimension. We can
    even read and write to the initial scalar object in an array. However, we usually
    want to access an array’s other elements too. For that, we’ll need pointer arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pointer Arithmetic
    to Access Array Elements</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once we have a pointer to an array’s initial element, we’ll use pointer addition
    to produce pointers to its other elements. Let’s work through the example in [Listing
    15-5](chapter15.xhtml#list15-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-5: Accessing later
    array elements with pointer arithmetic</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp> again as
    the array’s starting address. In the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> decays
    to a pointer to the initial array element, as usual. When we add <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    to this pointer, the result is a pointer to the next <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    element in the array. Since each <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    is 4 bytes, we need to multiply <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    by a scale of 4 to calculate how many bytes to add to <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>’s
    address. The resulting pointer’s value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0x14</samp>.
    If we dereferenced this pointer, we would get the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    object at address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x14</samp>, whose
    current value is <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>. Array
    elements are zero indexed, so we say the initial element of <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>
    is at index 0 and the next element is at index 1.
  prefs: []
  type: TYPE_NORMAL
- en: More generally, when we add an integer *n* to a pointer, the result is a pointer
    to another array element at the position *n* elements further along in the array.
    Similarly, we can move backward in an array by subtracting an integer (or adding
    a negative integer). If the result would be outside the bounds of the array in
    either direction, the behavior is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If x is an* n*-element array, x + n points one past the end of x. This pointer
    is a special case. It’s not considered out of bounds, and you can use it in pointer
    arithmetic. For example, you can compare it to other pointers to elements in the
    same array. (When you’re looping through array elements, this is a useful way
    to test whether you’ve reached the end.) But dereferencing it is undefined behavior,
    because it doesn’t point to an element of the array.*'
  prefs: []
  type: TYPE_NORMAL
- en: When we perform pointer arithmetic, the nested structure of the array we point
    into matters, because it dictates what counts as a single element. Let’s look
    at [Listing 15-6](chapter15.xhtml#list15-6) to see how this plays out for the
    two arrays we defined in [Listings 15-1](chapter15.xhtml#list15-1) and [15-2](chapter15.xhtml#list15-2),
    which had identical contents in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-6: Pointer arithmetic
    with flat and nested arrays</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The result of the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    is a pointer to the element at index 1 in <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp>
    ❶. This element is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>. Similarly,
    when we compute <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    we get a pointer to the array element at index 1 in <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>
    ❷. In this case, however, this element is itself an array of two <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    objects, whose current values are <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>. Although <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp> may have
    identical contents in memory, performing the same operation on both of them produces
    very different results.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how can we access the scalar objects in <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>?
    For example, how could we read the last <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    in this array, whose value is <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>?
    First, we’ll get a pointer to the last element in <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This points to the entire two-element array <samp class="SANS_TheSansMonoCd_W5Regular_11">{5,
    6}</samp>. We’ll dereference it to get a pointer to a single scalar element in
    this array instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This dereference expression results in an array of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp>,
    which decays to a pointer with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>. Now <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_ptr</samp> points
    to the first <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in this
    nested array, whose value is <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>.
    We’ll increment it to point to the next <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    whose value is <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'At that point, we can access its value with a normal pointer dereference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can consolidate these statements into the single expression in [Listing 15-7](chapter15.xhtml#list15-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-7: Accessing the
    last</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">int</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">three_arrays</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Through repeated pointer addition, dereferencing, and implicit conversions from
    arrays to pointers, we can access any element in a multidimensional array. This
    is, obviously, a huge pain. The subscript operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>,
    provides more convenient syntax to accomplish the same thing. The expression <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp> is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">*(a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i)</samp>,
    so we can rewrite [Listing 15-7](chapter15.xhtml#list15-7) as [Listing 15-8](chapter15.xhtml#list15-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-8: A more convenient
    way to access the last</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">int</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">three_arrays</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The last point I want to emphasize is that subscripting and pointer arithmetic
    apply to all pointers, not just pointers that decayed from arrays. If a pointed-to
    object isn’t in an array, we’ll treat it like the sole element in a one-element
    array. For example, [Listing 15-9](chapter15.xhtml#list15-9) is perfectly valid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-9: Subscripting
    a pointer to a scalar object</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we add <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> and dereference the result,
    we get back the object <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
    Therefore, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr[0]</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>
    evaluates to 1 (that is, true).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Even More Pointer
    Arithmetic</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll support two other operations on pointers. The first is subtraction; [Listing
    15-10](chapter15.xhtml#list15-10) gives an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-10: Subtracting
    two pointers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we subtract pointers to two elements in the same array, the result is the
    difference between their indices. In this example, unsurprisingly, we return <samp
    class="SANS_TheSansMonoCd_W5Regular_11">2</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: We can also compare pointers to array elements, like in [Listing 15-11](chapter15.xhtml#list15-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-11: Comparing pointers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The pointer to the element with the higher array index compares greater than
    the one with the lower index. In this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    points to the element at index 2 and <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>
    decays to a pointer to the element at index 0, so the comparison <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr
    > arr</samp> evaluates to 1\. If two pointers don’t point into the same array,
    the result of subtracting or comparing them is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array Types in Function
    Declarations</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s illegal for a function to return an array, like in the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: A function can’t take arrays as parameters, either. Weirdly enough, the C standard
    lets you *declare* a function with array parameters, but it requires the compiler
    to adjust your function signature to take pointers instead. For example, the declaration
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'will be turned into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We’ll adjust parameters with array types to have the corresponding pointer types
    in the type checker.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Things We Aren’t
    Implementing</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The features we won’t support are significant enough that I’ll mention them
    explicitly. We won’t implement variable-length arrays, whose length is determined
    at runtime, like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll permit only constants as the dimensions in array declarations. We also
    won’t permit declarations of incomplete array types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: C requires you to specify an array’s dimensions when you define it, but not
    when you declare it. However, we’ll require array dimensions in declarations as
    well as definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We won’t implement *compound literals*, which let you construct array objects
    (and other aggregate objects) outside of initializers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we won’t fully support C’s semantics for initializing aggregate objects.
    Compound initializers are a bit of a free-for-all; you can omit braces, wrap scalar
    values in braces, or initialize some elements but not others. This makes it tricky
    to figure out which expression is supposed to initialize which element. We’ll
    take a much stricter approach. First of all, we’ll require braces around the initializers
    for each nested array. In other words, we’ll accept the declaration
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'but we’ll reject the following equivalent declaration, even though the C standard
    permits it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also reject braces around scalar initializers, like in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And we won’t support designators, which let you initialize elements out of
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we *will* allow compound initializers that don’t initialize every
    array element, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we’ll pad out any remaining elements with zeros; that’s the behavior
    the C standard requires. Now that we’ve clarified exactly what we will and won’t
    build, we can move on to the lexer.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll add two tokens in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">[</samp> An open square bracket
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">]</samp> A close square bracket
  prefs: []
  type: TYPE_NORMAL
- en: After adding these tokens, you can test out your lexer.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we’ll add array types, subscript expressions, and compound initializers
    to the AST. An array’s type indicates the number of elements in the array and
    the type of those elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We can nest <samp class="SANS_TheSansMonoCd_W5Regular_11">Array</samp> constructors
    to specify a multidimensional array. For example, we’ll represent the type of
    the declaration
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: as <samp class="SANS_TheSansMonoCd_W5Regular_11">Array(Array(Int, 4), 3)</samp>.
    Since we won’t support variable-length arrays, every array type must have a constant
    size.
  prefs: []
  type: TYPE_NORMAL
- en: 'A subscript expression contains two subexpressions, a pointer and an index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Surprisingly, the order in which these two subexpressions appear doesn’t matter;
    the expressions <samp class="SANS_TheSansMonoCd_W5Regular_11">x[1]</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1[x]</samp> are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’ll add an <samp class="SANS_TheSansMonoCd_W5Regular_11">initializer</samp>
    construct to support both scalar and compound variable initializers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp>
    to initialize arrays and <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleInit</samp>
    to initialize scalar objects, including individual array elements. We’ll use a
    nested <samp class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp> construct
    for each row in a multidimensional array. [Listing 15-12](chapter15.xhtml#list15-12)
    shows how to represent the initializer <samp class="SANS_TheSansMonoCd_W5Regular_11">{{1,
    2}, {3, 4}, {5, 6}}</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-12: Representing
    the initializer for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">three_arrays</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">, from [Listing 15-2](chapter15.xhtml#list15-2),
    as an AST node</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The type checker will annotate initializers with their types, just like it does
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> nodes. However you
    support type annotations on <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    nodes, you should do the same thing for <samp class="SANS_TheSansMonoCd_W5Regular_11">initializer</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-13](chapter15.xhtml#list15-13) gives the complete AST definition,
    with this chapter’s additions bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-13: The abstract
    syntax tree with array types, compound initializers, and subscript expressions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through how to parse each of these additions to the AST.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Array Declarators</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You learned how to parse pointer and function declarators in the previous chapter;
    now we’ll extend that code to handle array declarators too. [Listing 15-14](chapter15.xhtml#list15-14)
    shows how to extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">declarator</samp>
    construct that we defined in [Listing 14-6](chapter14.xhtml#list14-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-14: Representing
    array declarators</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll add array declarators to the grammar. Since they have higher precedence
    than pointer declarators, they belong in the <samp class="SANS_TheSansMonoCd_W5Regular_11"><direct-declarator></samp>
    grammar rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'A direct declarator is a simple declarator with an optional suffix: either
    a parenthesized list of function parameters or a sequence of constant array dimensions
    of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">[</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">const</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">]</samp>. Each <samp class="SANS_TheSansMonoCd_W5Regular_11">ArrayDeclarator</samp>
    specifies just one array dimension, so we’ll parse a <samp class="SANS_TheSansMonoCd_W5Regular_11"><declarator-suffix></samp>
    with multiple dimensions to a sequence of multiple nested <samp class="SANS_TheSansMonoCd_W5Regular_11">ArrayDeclarator</samp>
    nodes. For example, we’d parse the declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">array[1][2]</samp>
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The grammar rule for <samp class="SANS_TheSansMonoCd_W5Regular_11"><declarator-suffix></samp>
    permits floating-point constants as array dimensions, but the C standard requires
    array dimensions to be integers. When you parse a <samp class="SANS_TheSansMonoCd_W5Regular_11"><declarator-suffix></samp>,
    you should reject floating-pointing constants and accept constants of any integer
    type. The C standard also requires array dimensions to be greater than zero, but
    Clang and GCC support zero-length arrays as a language extension. It’s up to you
    whether to accept zero-length arrays or reject them; the test suite doesn’t cover
    this case.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll update <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>,
    which converts a <samp class="SANS_TheSansMonoCd_W5Regular_11">declarator</samp>
    construct into an AST node. [Listing 15-15](chapter15.xhtml#list15-15) illustrates
    how to handle array declarators in <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-15: Applying array
    type derivations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This listing follows the same pattern we introduced to derive pointer types
    in [Chapter 14](chapter14.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Abstract
    Array Declarators</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, let’s deal with abstract declarators, which specify types without declaring
    identifiers. We’ll parse abstract array declarators according to the grammar rule
    in [Listing 15-16](chapter15.xhtml#list15-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-16: The grammar
    rule for abstract array declarators</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A direct abstract declarator is either a parenthesized declarator, optionally
    followed by a sequence of array dimensions, or just a sequence of array dimensions.
    (Remember that <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp> in EBNF
    syntax indicates zero or more repetitions, while <samp class="SANS_TheSansMonoCd_W5Regular_11">{}+</samp>
    indicates one or more repetitions.) We’ll take the same steps here that we took
    to support normal declarators. [Listing 15-17](chapter15.xhtml#list15-17) shows
    how to extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract_declarator</samp>
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-17: Representing
    abstract array declarators</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: After updating <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract_declarator</samp>,
    we’ll change our parsing code to handle the grammar rule in [Listing 15-16](chapter15.xhtml#list15-16).
    (This code should accept integer constants as array dimensions and reject floating-point
    constants, just like the code to parse ordinary declarators.) Finally, we’ll update
    <samp class="SANS_TheSansMonoCd_W5Regular_11">process_abstract _declarator</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Compound
    Initializers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s define the grammar rule for initializers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This rule is straightforward: an initializer is either an expression or a brace-enclosed
    list of one or more nested initializers. Note that there can be a trailing comma
    after the last element in an initializer list: <samp class="SANS_TheSansMonoCd_W5Regular_11">{1,
    2, 3}</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">{1, 2, 3,}</samp>
    are both valid compound initializers.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Subscript
    Expressions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last new language feature we need to parse is the subscript operator. Subscripting
    is a *postfix* operator, which follows the expression it modifies. Postfix operators
    have higher precedence than prefix operators like <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>.
    We’ll break up the <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>
    grammar rule to reflect this difference in precedence. At the highest precedence
    level, we’ll have constants, variables, parenthesized expressions, and function
    calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we’ll define a postfix expression as a primary expression, optionally
    followed by a sequence of subscript operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Each subscript operator is an expression enclosed in square brackets. Finally,
    we’ll define unary expressions, which include both prefix and cast operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 15-18](chapter15.xhtml#list15-18) shows the complete grammar, with
    this chapter’s changes bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-18: The grammar
    with array types, compound initializers, and subscript expressions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve updated your parser to account for all of the changes in [Listing
    15-18](chapter15.xhtml#list15-18), you’re ready to test it out.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Type Checker</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The type checker will do most of the heavy lifting in this chapter. It will
    add type information to subscript and pointer arithmetic expressions; validate
    the dimensions of compound initializers; and detect type errors, like casting
    an expression to an array type. It will also handle implicit conversions from
    array to pointer types. Just as we insert <samp class="SANS_TheSansMonoCd_W5Regular_11">Cast</samp>
    expressions into the AST to make implicit type conversions explicit, we’ll insert
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions to make
    conversions from arrays to pointers explicit.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Arrays
    to Pointers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll convert any array type expression to a pointer, unless it’s already the
    operand of an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expression.
    This might sound familiar from the previous chapter, where we lvalue converted
    the result of every expression, except when we took its address or assigned to
    it. In [Chapter 14](chapter14.xhtml), we introduced a new <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>
    helper function to manage lvalue conversions; now we’ll use a similar design pattern
    in a different compiler pass. We’ll define a new <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    function, shown in [Listing 15-19](chapter15.xhtml#list15-19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-19: Implicitly converting
    an array to a pointer</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'If an expression has array type, we insert an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    operation to get its address. We then record its result type, which is a pointer
    to the array’s element type. This is a different result type than we’d get from
    an explicit <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator, which
    always produces a pointer to the type of its operand. Take the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">&arr</samp> has
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">int (*)[3]</samp>. The expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>, on the other hand, has
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. In the type checked
    AST, we’re using <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> to
    represent two ways of taking an object’s address, which yield different result
    types: through an implicit conversion or an explicit <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve introduced <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>,
    we’ll use it in place of <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>
    to check both subexpressions and full expressions. The one exception is type checking
    the operand of <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>. This
    operand should not be converted from an array to a pointer, so we’ll continue
    to process it by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Validating Lvalues</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll change a couple of details about how we validate lvalues. First, we should
    recognize <samp class="SANS_TheSansMonoCd_W5Regular_11">Subscript</samp> expressions
    as lvalues, in addition to <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we need to reject assignment expressions that try to assign to arrays.
    Once an array decays to a pointer, it’s no longer an lvalue and can’t be assigned
    to. To catch these invalid assignment expressions, we’ll process the left operand
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    before we check whether it’s an lvalue. [Listing 15-20](chapter15.xhtml#list15-20)
    shows the latest logic to type check assignment expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-20: Type checking
    assignment expressions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If the left operand is an array, <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    will wrap it in an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    operation. Then, since <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    isn’t an lvalue, the type checker will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking
    Pointer Arithmetic</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll extend addition, subtraction, and the relational operators to work
    with pointers. Adding any integer type to a pointer is valid. [Listing 15-21](chapter15.xhtml#list15-21)
    demonstrates how to type check addition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-21: Type checking
    pointer addition</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To type check addition involving a pointer and an integer, we first convert
    the integer operand to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    ❶. This will simplify later compiler passes, when pointer indices will need to
    be 8 bytes wide so that we can add them to 8-byte memory addresses. This conversion
    doesn’t come from the C standard; we’re just adding it for our own convenience.
    But it also doesn’t violate the standard; converting a valid array index to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> won’t change its value, so
    the result of the whole expression is the same either way. (If an integer is too
    big to represent as a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>,
    we can safely assume that it’s not a valid array index, since no hardware supports
    arrays with anywhere close to 2^(63) elements.)
  prefs: []
  type: TYPE_NORMAL
- en: The result of pointer addition has the same type as the pointer operand ❷. We
    use the same logic whether the first or second operand is the pointer, so I’ve
    omitted the pseudocode for the latter case ❸. Finally, in any case other than
    adding a pointer to an integer or adding two arithmetic operands, we throw an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subtracting an integer from a pointer works the same way: we convert the integer
    operand to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and annotate
    the result with the same type as the pointer operand. The only difference is that
    operand order matters. You can subtract an integer from a pointer, but you can’t
    subtract a pointer from an integer.'
  prefs: []
  type: TYPE_NORMAL
- en: When we subtract one pointer from another, both operands must have the same
    type, and the result has an implementation-defined signed integer type. We’ll
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> as the result type
    here, which is the norm on 64-bit systems. This type is supposed to be aliased
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">ptrdiff_t</samp> in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><stddef.h></samp> header, to help users
    write more portable code. Since we don’t support <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    and therefore can’t compile <samp class="SANS_TheSansMonoCd_W5Regular_11"><stddef.h></samp>,
    we’ll ignore this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-22](chapter15.xhtml#list15-22) demonstrates how to type check both
    cases of pointer subtraction.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-22: Type checking
    pointer subtraction</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If an expression subtracts an integer from a pointer, we handle it just like
    pointer addition ❶. If it subtracts two pointers of the same type, we record <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> as the result type ❷. In any
    other case—if an expression subtracts two pointers of different types, subtracts
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> from a pointer,
    or subtracts a pointer from an arithmetic value—we’ll throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s deal with the <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> operators. Each of
    these accepts two pointer operands of the same type and returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    These are pretty simple to type check, so I won’t provide pseudocode for this
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Note that none of these operators accept null pointer constants; they compare
    pointers to elements in the same array, but a null pointer, by definition, doesn’t
    point to an array element. By the same logic, you can’t subtract a pointer from
    a null pointer constant. If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is a pointer, the expressions <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">x !=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    are legal, but <samp class="SANS_TheSansMonoCd_W5Regular_11">0 - x</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0 < x</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    >=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> are not. (Clang
    and GCC are more permissive than the standard here; as a language extension, they
    both let you use null pointer constants with any relational operator. With this
    extension, any non-null pointer will compare greater than the null pointer constant.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Subscript
    Expressions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One operand of a subscript expression must be a pointer, and the other must
    be an integer. The pointer’s referenced type is the result type. Remember that
    these two operands can appear in either order; we can’t assume that the pointer
    will be the first operand. [Listing 15-23](chapter15.xhtml#list15-23) shows how
    to type check subscript expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-23: Type checking
    a subscript expression</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we validate that one operand is a pointer and the other is an integer
    ❶. We then convert the integer operand to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    ❷. Finally, we annotate the whole expression with the pointer’s referenced type
    ❸.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Cast
    Expressions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This one is easy: you can’t cast an expression to an array type. For example,
    the expression'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: is invalid and should produce a type error.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Function
    Declarations</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we process a function declaration, we consider both its return type and
    its parameter types. If a function returns an array type, we throw an error. If
    any of its parameters has an array type, we adjust it to a pointer type instead.
    [Listing 15-24](chapter15.xhtml#list15-24) describes how to validate and implicitly
    adjust a function type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-24: Adjusting array
    types in function declarations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You should add this logic to the very beginning of <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_function
    _declaration</samp>, in order to adjust a function’s parameter types before you
    check whether it conflicts with prior definitions of the same identifier. You
    should also ensure that both the symbol table and the AST node itself use the
    adjusted parameter types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Compound
    Initializers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We need to annotate each initializer with its type and emit an error if an initializer
    is incompatible with the type of the object it’s supposed to initialize. To type
    check a compound initializer, we first validate that the object it initializes
    is an array. Then, we recursively type check each nested initializer, validating
    that it’s compatible with the array’s element type. [Listing 15-25](chapter15.xhtml#list15-25)
    illustrates this approach.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-25: Type checking
    initializers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In the base case, an initializer is a single expression ❶. We’ll type check
    this expression, then call <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>,
    which we defined in [Chapter 14](chapter14.xhtml), to convert it to the target
    type. If it’s not compatible with the target type, <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>
    will throw an error (this includes cases where the target type is an array type).
  prefs: []
  type: TYPE_NORMAL
- en: In the recursive case, we’ll initialize an array using a compound initializer
    ❷. Each item in the list will initialize one element in the array. First, we’ll
    check that the list doesn’t contain too many elements ❸. Then, we’ll type check
    each list item recursively, using the array’s element type as the target type
    ❹. If the initializer list contains too few elements, we’ll pad it with zeros
    ❺. We’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>
    helper function, which I haven’t provided pseudocode for, to produce zero-valued
    initializers that we can add to the initializer list. Given a scalar type, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp> should return
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleInit</samp> of that type
    with the value 0\. Given an array type, it should return a <samp class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp>
    whose scalar elements (which may be nested several layers deep) have the value
    0\. For example, calling <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>
    on the type <samp class="SANS_TheSansMonoCd_W5Regular_11">UInt</samp> should return
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'and calling it on the type <samp class="SANS_TheSansMonoCd_W5Regular_11">Array(Array(Int,
    2), 2)</samp> should return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Once we’ve finished building the type checked list of initializers, we’ll package
    it into a <samp class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp>, which
    we’ll annotate with the target type ❻. If the initializer isn’t a single expression
    and the target type isn’t an array type, we’re trying to initialize a scalar object
    with a compound initializer, so we’ll throw an error ❼.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Initializing Static
    Arrays</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As with other static variables, we’ll store the initial values of static arrays
    in the symbol table. We’ll need to update the data structures we use to represent
    these initial values. We’ll represent the initializer for every object as a list
    of scalar values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: For scalar objects, <samp class="SANS_TheSansMonoCd_W5Regular_11">init_list</samp>
    will have only one element. The declaration
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'will have this initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: For multidimensional arrays, we’ll flatten out any nested structures. Therefore,
    the declaration
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'will have this initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll add a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    constructor to represent zeroed-out objects of any size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">bytes</samp> argument to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> specifies how many bytes
    to initialize to zero. If a static array is only partially initialized, we’ll
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> to pad out any
    uninitialized elements. For example, the declaration
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'will have this initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The second element of this initializer list, <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(4)</samp>,
    initializes the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> at <samp
    class="SANS_TheSansMonoCd_W5Regular_11">nested[0][1]</samp>; the last element,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(8)</samp>, initializes
    both elements of the nested array <samp class="SANS_TheSansMonoCd_W5Regular_11">nested[2]</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve updated the <samp class="SANS_TheSansMonoCd_W5Regular_11">initial_value</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> data structures,
    write a function to convert a compound initializer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    list. You’ll need to validate that initializers for static arrays have the correct
    size and structure, just like initializers for non-static arrays; you should reject
    initializers with too many elements, scalar initializers for arrays, and compound
    initializers for scalar objects. I won’t provide pseudocode for this transformation,
    since it’s similar to the way we type check non-static initializers in [Listing
    15-25](chapter15.xhtml#list15-25).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Initializing Scalar
    Variables with ZeroInit</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    to initialize scalar variables to zero. For instance, given the declaration
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'you could use this initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Using <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> here is
    optional, but it makes code emission simpler because you can easily tell which
    initializers belong in <samp class="SANS_TheSansMonoCd_W5Regular_11">.data</samp>
    and which belong in <samp class="SANS_TheSansMonoCd_W5Regular_11">.bss</samp>.
    Just be careful about using <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    to initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>s; use
    it only if you’re sure the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>’s
    initial value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp> and
    not <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To accommodate pointer arithmetic and compound initializers, we’ll make a few
    changes to the TACKY IR. First, since we changed how we represent initializers
    in the symbol table, we’ll make the corresponding change in TACKY:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also introduce a new instruction to support pointer arithmetic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use this instruction to add or subtract an integer from a pointer, but
    not to subtract one pointer from another. The <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp>
    operand is the size, in bytes, of each element in the array that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    points into. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp>
    operand will be <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, since
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is 4 bytes. If <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    (*)[3]</samp>, a pointer to an array of three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    objects, then <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp> will
    be <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    operand tells us how many elements forward or back to move from the base pointer.
    At runtime, the program will multiply <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp> to determine how
    many bytes to add to the base pointer. It would be possible to implement pointer
    arithmetic using the existing TACKY instructions for multiplication and addition.
    However, introducing a specialized <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction here will help us take advantage of the x64 architecture’s built-in
    support for pointer arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll introduce one more instruction to support compound initializers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In this instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    is a scalar value, <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> is
    the name of some variable of aggregate type, and <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>
    specifies the number of bytes between the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    and the position we should copy <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    to. It’s important to note that <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    designates an array, *not* a pointer to an array element. In other words, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> doesn’t use the value
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>; it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    to identify an object with a fixed location in memory. Because this instruction
    operates directly on arrays, rather than pointers, it’s useful for array initialization
    but not for subscripting. In [Chapter 18](chapter18.xhtml), we’ll use it to initialize
    and update structures too.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-26](chapter15.xhtml#list15-26) shows the updated TACKY IR, with
    this chapter’s changes bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-26: Adding support
    for arrays to the TACKY IR</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: With these additions, we can implement every new operator and construct in this
    chapter. Let’s handle each of them in turn.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pointer Arithmetic</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll implement the pointer arithmetic expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp>
    with an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> instruction,
    as [Listing 15-27](chapter15.xhtml#list15-27) demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-27: Adding an integer
    to a pointer in TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of things to note about this listing. First, the pointer
    is always the first operand to the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction and the integer is always the second, regardless of which was the
    first operand in the original expression. Second, you need to calculate the size
    of the pointer’s referenced type at compile time, since the <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp>
    operand is a constant rather than a TACKY value.
  prefs: []
  type: TYPE_NORMAL
- en: The TACKY to subtract an integer from a pointer is almost identical; we just
    negate the index before we include it in <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>.
    We’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp>
    to the TACKY in [Listing 15-28](chapter15.xhtml#list15-28).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-28: Subtracting
    an integer from a pointer in TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Subtracting one pointer from another works a bit differently. First, we calculate
    the difference in bytes, using an ordinary <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp>
    instruction. Then, we divide this result by the number of bytes in one array element,
    to calculate the difference between the two pointers in terms of array indices.
    In other words, we’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr2></samp>
    to the TACKY in [Listing 15-29](chapter15.xhtml#list15-29).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-29: Subtracting
    two pointers in TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll calculate the size of the referenced type at compile time. You can use
    the type of either operand here, since the type checker already validated that
    they both have the same type.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll compare pointers exactly like arithmetic values, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp> operators.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Subscripting</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: According to the C standard, the subscript expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr></samp>[<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp>] is equivalent to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp>. So, to implement a subscript
    expression, we’ll generate the TACKY for pointer addition from [Listing 15-27](chapter15.xhtml#list15-27)
    but return a <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(result)</samp>
    to the caller instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand(result)</samp>.
    Generating the right TACKY here is simple, but understanding why it works, especially
    for multidimensional arrays, is a little trickier. To explore this further, let’s
    work through the example in [Listing 15-30](chapter15.xhtml#list15-30).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-30: Returning the
    result of a subscript operator</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-31](chapter15.xhtml#list15-31) shows the TACKY implementation of
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement in this
    example.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-31: Implementing
    [Listing 15-30](chapter15.xhtml#list15-30) in TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    instruction to get a pointer to the first element in <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>.
    Then, we issue two <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instructions to calculate a pointer to the array element at <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i][j]</samp>.
    Finally, we use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction
    to read that array element’s current value into a temporary variable, which we
    return. [Listing 15-31](chapter15.xhtml#list15-31) is efficient, without any superfluous
    instructions. We saw earlier that array subscripting requires us to repeatedly
    get the addresses of array elements, perform pointer arithmetic, and dereference
    the result. But in this listing, we get an array’s address only once, at the beginning
    ❶, and we use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction
    to dereference a pointer only once, at the end ❷. How does our strategy for TACKY
    generation produce this result?
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-32](chapter15.xhtml#list15-32) gives the AST for the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement in [Listing 15-30](chapter15.xhtml#list15-30). Let’s figure out how
    each subexpression in this AST is converted to TACKY.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-32: The AST for
    [Listing 15-30](chapter15.xhtml#list15-30)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The AST includes the two <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    expressions we inserted during type checking. The inner one ❺ gets the address
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>, and the outer one
    ❸ gets the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i]</samp>.
    Of course, <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> would have been renamed
    during identifier resolution, but we’ll ignore that detail in this example (and
    in the later examples in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we convert this AST to TACKY in postorder, processing each expression’s
    operands before we process the expression itself. The first non-leaf AST node
    we process is the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    expression, which takes the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>
    ❺. We convert it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, to implement the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">Subscript</samp>
    expression ❹, we emit an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The scale here is <samp class="SANS_TheSansMonoCd_W5Regular_11">16</samp> because
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> points to a four-<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> array. The second part of a
    subscript operation is dereferencing the result, so we’ll return <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(tmp1)</samp>
    to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: In the caller, we process the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    expression ❸. When we take the address of a dereferenced pointer, the operations
    cancel out. Therefore, we return <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand(tmp1)</samp>
    as the result of this expression, without emitting any further instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we process the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">Subscript</samp>
    expression ❷. Once again, we emit an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We then return <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(tmp2)</samp>
    to the caller. Because this <samp class="SANS_TheSansMonoCd_W5Regular_11">Subscript</samp>
    expression appears in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    statement ❶, not an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    or assignment expression, we lvalue convert this result. That means we emit a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Now <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp3</samp> contains the
    lvalue-converted result of the whole expression, so we return it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: As this example illustrates, when we index into a multidimensional array the
    dereference operations and implicit address loads cancel each other out, without
    producing any extra instructions. Therefore, any subscript and dereference operators
    work out to pure pointer arithmetic in TACKY, without any <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instructions, until
    we reach a scalar array element.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Compound Initializers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To process a compound initializer, we evaluate each scalar expression in the
    initializer and copy it to the appropriate location in memory with a <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    instruction. For example, we’ll convert the initializer
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'to the following sequence of instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Since a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> is 8 bytes,
    the offset increases by eight with each element. Even when we process a nested
    initializer, we only need to copy the scalar values at the leaves to the correct
    memory locations. For example, we’ll convert
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This conversion is pretty straightforward, so I’ll omit the pseudocode for it.
    I will note, however, that you should use the type information the type checker
    added to each compound initializer to calculate the offset of each element.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tentative Array Definitions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recall that when we convert symbol table entries to <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>
    constructs, we initialize tentatively defined variables to zero. That goes for
    tentatively defined arrays too. You should use the new initializer we added in
    the previous section, <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>,
    to initialize an *n*-byte array to zero.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    to initialize tentatively defined scalar variables. For consistency, you should
    only use <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> here if
    you’re using it to initialize explicitly defined scalar variables to zero in the
    type checker.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We won’t introduce any new assembly instructions in this chapter. We will,
    however, introduce a new memory addressing mode, sometimes called *indexed addressing*.
    Right now, we can specify a memory operand with a base address in a register and
    a constant offset, like <samp class="SANS_TheSansMonoCd_W5Regular_11">4(%rax)</samp>.
    Using indexed addressing, we can store the base address in one register and an
    index in another. We can also specify a scale, which must be one of the constants
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>.
    Here’s an example of indexed addressing in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: To find the destination address of this <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    instruction, the CPU will calculate RAX + RBX × 4\. Then, it will store the 4-byte
    constant <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> at this address.
    This addressing mode is convenient for array accesses. If RAX holds the address
    of an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> objects
    and RBX holds an index *i* into that array, the operand <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rax,
    %rbx, 4)</samp> specifies the element at index *i*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll add a new operand to support indexed addressing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also make a few other changes to the assembly AST to help with bookkeeping
    in later backend passes. For starters, we’ll add another operand to represent
    aggregate objects that haven’t been assigned a fixed address yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> operand serves
    a similar purpose to the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    operand; it lets us represent variables in assembly before we’ve allocated registers
    or memory locations for them. The difference is that <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    represents aggregate objects, which we’ll always store in memory (even once we
    implement register allocation in [Part III](part3.xhtml)). <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>,
    on the other hand, represents scalar objects that could potentially be stored
    in registers. The <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operand also lets us specify a byte offset into the object in question. Note that
    the identifier in this operand designates an aggregate object, not a pointer to
    an aggregate object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll add a new assembly type to represent arrays. In assembly, we’ll
    treat an array like an undifferentiated chunk of memory. We no longer need to
    track how many objects will be stored in that chunk of memory or what those objects’
    types will be. We do, however, care about its alignment and how much space it
    takes up, so we can allocate stack space for it. Therefore, we’ll convert array
    types to a new <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we’ll adjust how we represent static variables. As in earlier compiler
    passes, we’ll initialize a static variable with a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    values, instead of just one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 15-33](chapter15.xhtml#list15-33) highlights all the changes to the
    assembly AST in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-33: The assembly
    AST with support for aggregate objects and indexed addressing</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve updated the assembly AST, we’ll update the conversion from TACKY
    to assembly.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting TACKY
    to Assembly</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, we’ll deal with TACKY variables of array type. To distinguish these from
    scalar values, we’ll convert them to <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operands, instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    operands. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>
    is an array, we’ll convert
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Whenever we convert an aggregate TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>
    to assembly, we’ll use an offset of zero, in order to designate the whole object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s deal with the new <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> instructions.
    We’ll use a <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> operand
    with the appropriate offset to represent the destination of a <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    instruction. Therefore, we’ll convert
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: We’ll implement <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    with an <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp> instruction using
    the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp> operand.
    The details will vary depending on the scale and index. First, let’s consider
    the case where the scale is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>. We’ll convert
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: to [Listing 15-34](chapter15.xhtml#list15-34).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-34: Implementing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddPtr</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    assembly</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we copy <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> into registers; I’ve
    used RAX and RDX here, but anything other than the callee-saved registers or our
    scratch registers will do. Then, we emit an <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp>
    instruction to compute <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">index
    * scale</samp> and store the result in <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The scale of <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> may
    not be one of the four values that <samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp>
    supports, especially if we’re indexing into a multidimensional array instead of
    an array of scalar objects. In that case, we’ll use a separate instruction to
    multiply the scale by the index, as [Listing 15-35](chapter15.xhtml#list15-35)
    illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-35: Implementing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddPtr</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    assembly with a nonstandard scale</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> operand is
    a constant, we can save an instruction by computing <samp class="SANS_TheSansMonoCd_W5Regular_11">index
    * scale</samp> at compile time. Then, we’ll generate just the two instructions
    in [Listing 15-36](chapter15.xhtml#list15-36).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-36: Implementing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddPtr</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">with
    a constant index</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll deal with pointer comparisons. We’ll implement these exactly like
    unsigned integer comparisons, using the unsigned condition codes: <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s talk about the alignment requirements for arrays. There are
    a couple of cases where we need to calculate an array’s alignment: when we convert
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> of array
    type from TACKY to assembly (a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>
    in assembly includes an <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>
    field), and when we convert a frontend symbol table entry of array type to the
    corresponding entry in the backend symbol table. The assembly type of each array
    in the backend symbol table will be a <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>
    with the appropriate size and alignment. The size will be the size of the array’s
    element type in bytes, multiplied by the number of elements. The rules for calculating
    alignment are a bit less obvious.'
  prefs: []
  type: TYPE_NORMAL
- en: If an array is smaller than 16 bytes, it has the same alignment as its scalar
    elements. For example, an array with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp>
    and an array with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2][1]</samp>
    both have an alignment of 4\. If an array-type variable is 16 bytes or larger,
    its alignment is always 16, no matter what type its elements are. This requirement
    makes it possible to use SSE instructions to operate on multiple array elements
    at once. We don’t use SSE instructions this way, but we need to maintain ABI compatibility
    with other object files that might.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this alignment requirement applies only to variables, not to nested
    arrays. For example, if we declare the variable
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: then <samp class="SANS_TheSansMonoCd_W5Regular_11">nested</samp> needs to start
    at a 16-byte-aligned address because its total size is 60 bytes. But its first
    and second elements start at 20 and 40 bytes, respectively, from the start of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nested</samp>, so they aren’t 16-byte
    aligned, even though each of these elements is also larger than 16 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Tables 15-1](chapter15.xhtml#tab15-1) through [15-5](chapter15.xhtml#tab15-5)
    summarize this chapter’s updates to this compiler pass; as usual, new constructs
    and changes to the conversions for existing constructs are bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-1:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Top-Level TACKY Constructs to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Constant index</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-3:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Comparisons to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY comparison</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly condition code</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">pointer</samp><samp
    class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">LE</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">pointer</samp><samp
    class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">pointer</samp><samp
    class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">GE</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">pointer</samp><samp
    class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp> |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-4:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Operands to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Var(identifier)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Scalar value</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Pseudo(identifier)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">Aggregate value</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">PseudoMem(identifier, 0)</samp> |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-5:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Types to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Array(element, size)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Variables that are 16 bytes or larger</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">16</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Everything else</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Same alignment as element</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Next, we’ll replace <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operands with concrete addresses.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing PseudoMem
    Operands</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can’t call this pass “pseudoregister replacement” anymore, because we’re
    replacing aggregate values too. Just like we’ll allocate 4 bytes of stack space
    for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp> and 8 bytes
    for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>, we’ll allocate
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">size</samp> bytes for an
    object with type <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">size</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">alignment</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>.
    As usual, we’ll round down the array’s address to the appropriate alignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once an array has been assigned a memory address, we’ll replace any <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operands that refer to it. A <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operand includes an offset from the start of the array, and the array’s concrete
    address includes an offset from the address in RBP. We’ll add these two offsets
    to construct a new concrete memory address. For example, suppose we encounter
    the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s say that we previously assigned <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>
    the stack address <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>.
    We compute –12 + 4 to determine that our new, concrete operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>.
    We then rewrite the instruction accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: To access an array with static storage duration, we use the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operand. If <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> is a static
    array, we convert
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: If we encountered <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem("arr",</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
    for any nonzero <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp>,
    we’d be in trouble, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operand doesn’t include an offset. Luckily, this situation won’t come up. At the
    moment, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operands with nonzero offsets only to initialize arrays with automatic storage
    duration, not to access arrays with static storage duration.
  prefs: []
  type: TYPE_NORMAL
- en: RIP-relative addressing *does* support constant offsets—for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">foo+4(%rip)</samp>
    represents the address 4 bytes past the symbol <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>—but
    we can’t represent these offsets in the assembly AST yet. We’ll add them in [Chapter
    18](chapter18.xhtml) to support operations on structures.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up Instructions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We didn’t introduce any new instructions, so we don’t need any new instruction
    fix-up rules. This pass must recognize that the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp>
    operand specifies a memory address and therefore can’t be used where a register
    or immediate value is required. Otherwise, we don’t need to change anything.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll make four small additions to this stage. First, we’ll emit the new <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp> operand. Second, we’ll
    emit the static <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    initializer as a <samp class="SANS_TheSansMonoCd_W5Regular_11">.zero</samp> assembly
    directive. For example, we’ll emit <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(32)</samp>
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Third, if a variable’s only initializer is <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>,
    we’ll write it to the BSS section instead of the data section.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, when we define a static variable, we’ll emit each item in the associated
    initializer list. The file scope declaration
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: will ultimately be translated to the assembly in [Listing 15-37](chapter15.xhtml#list15-37).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-37: Initializing
    a static array in assembly</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we initialize the last element of this array to zero because it wasn’t
    initialized explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: '[Tables 15-6](chapter15.xhtml#tab15-6) through [15-8](chapter15.xhtml#tab15-8)
    summarize these additions to the code emission stage, with new constructs and
    changes to the way we emit existing constructs bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-6:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Top-Level Assembly Constructs</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |  | <samp class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">All other variables</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-7:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Static Initializers</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Static initializer</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">ZeroInit(n)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">.zero</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><n></samp> |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-8:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Indexed(reg1, reg2, int)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: After making these changes, you can test out your compiler.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve just implemented your first aggregate type! In this chapter, you learned
    how to parse array declarators and compound initializers. In the type checker,
    you made implicit conversions from arrays to pointers explicit and analyzed the
    types of pointer arithmetic expressions. During TACKY generation, you relied on
    those conversions and that type information to handle operations on pointers cleanly,
    regardless of whether they point to arrays or scalar values. And on the backend,
    you added new, more flexible ways to address values in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you’ll implement three more integer types: <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>. You’ll also implement string literals, which can be either array
    initializers or <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> arrays
    that decay to pointers, depending on context. Because you’ve already implemented
    integer types, pointers, and arrays, a lot of the groundwork for the work you’ll
    do there is already in place.'
  prefs: []
  type: TYPE_NORMAL
