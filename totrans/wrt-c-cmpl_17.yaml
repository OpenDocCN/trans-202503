- en: '![](../images/pg382.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-38.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ARRAYS
    AND POINTER ARITHMETIC</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, you’ll implement array types. You’ll also add the main language
    features that programmers use to work with arrays: compound initializers, subscript
    operators, and pointer arithmetic. Arrays and pointers are distinct but closely
    related types. Many expressions of array type are implicitly converted to pointers,
    and many pointer operations, like subscripting, are meant to operate on pointers
    to array elements. So, to support arrays, you’ll build on the support for pointers
    that you added in the previous chapter.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: The type checker plays an especially critical role here. It will handle the
    implicit conversions from arrays to pointers and annotate the AST with the type
    information you’ll rely on to perform pointer arithmetic. Once the type checker
    has done all the hard work, it will be relatively easy to break down subscript
    operators and compound initializers into simple pointer operations during TACKY
    generation. You won’t add any new assembly instructions in this chapter, but you’ll
    introduce new operands to represent objects in memory and elements within those
    objects.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we’ll start with an overview of the language constructs we’re going
    to add. We’ll pay special attention to the relationship between pointers and arrays
    and how this relationship plays out in pointer arithmetic and subscript expressions.
    This is a particularly confusing aspect of C, and it’s key to everything we’ll
    do in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Arrays and Pointer Arithmetic</samp>
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s define a few terms up front. In the last chapter, we divided every object
    type we knew about into two categories: arithmetic types and non-arithmetic types.
    Now we’ll introduce another distinction. A *scalar type* represents a single value.
    The pointer and arithmetic types we’ve already implemented are all scalar types.
    An *aggregate type* represents a collection of values. Arrays are aggregate types;
    so are structures, which we’ll implement in [Chapter 18](chapter18.xhtml). All
    the values in an array have the same type, which is the array’s *element type*.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array Declarations
    and Initializers</samp>
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we declare an array, we specify its element type and how many elements
    it contains. For example, we could declare an array of three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    objects:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or we could declare an array of five pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: (Remember that we interpret a declaration by starting with the basic type—<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, in this case—and then applying
    type derivations from the outside in.)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of these examples use scalar element types, but we can use aggregate element
    types too. The following example declares an array of three elements, where each
    element is itself an array of two <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    objects:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Arrays of arrays like this one are called *multidimensional arrays*. Note that
    we still apply type derivations from the outside in to determine this array’s
    type. We start with the base type <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>,
    apply the derivation specified by <samp class="SANS_TheSansMonoCd_W5Regular_11">[2]</samp>
    to get the type “array of two <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    objects,” and then apply the derivation specified by <samp class="SANS_TheSansMonoCd_W5Regular_11">[3]</samp>
    to get the type “array of three arrays of two <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    objects.”
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'You can initialize an array with a *compound initializer*, which specifies
    an initial value for each element:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And you can initialize a multidimensional array with nested compound initializers:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the three nested compound initializers initialize the three elements of
    the outer array. Each of those three elements is, itself, an array of two <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> objects. The nested initializer
    for each of these elements specifies two arithmetic values (which can be implicitly
    converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: You can also leave an array uninitialized. If it has automatic storage duration,
    its initial value will be undefined. If it has static storage duration, it will
    be initialized to all zeros. In other words, we treat uninitialized arrays exactly
    like uninitialized scalar objects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Memory Layout of
    Arrays</samp>
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At this point, it’s helpful to talk a bit about the memory layout of flat and
    multidimensional arrays. If you declare an array of *n* objects, those *n* objects
    will be laid out sequentially in memory. Consider the array in [Listing 15-1](chapter15.xhtml#list15-1),
    which has a scalar element type.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-1: An array of scalar
    values</samp>'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-1](#fig15-1) shows what <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp>
    might look like in memory right after it’s initialized (the memory addresses in
    this figure are just for illustration; they wouldn’t be valid on a real system).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig15-1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 15-1: The layout of</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">six_ints in memory [Description](description-39.xhtml)</samp>'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Compare this declaration to [Listing 15-2](chapter15.xhtml#list15-2), which
    declares a multidimensional array with the same number and type of scalar elements
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp>.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-2: An array of nested
    arrays</samp>'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The memory that holds <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>
    will also look like [Figure 15-1](#fig15-1). In memory, there’s no indication
    of where one element ends and another begins, so the two arrays are indistinguishable.
    Although the nested structure of <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>
    doesn’t impact its layout in memory, it does impact how you access individual
    array elements, as we’ll see shortly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array-to-Pointer
    Decay</samp>
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once we’ve defined and initialized an array, what can we do with it? Not a
    lot, as it turns out. In fact, there are only two valid operations on objects
    of array type. First, we can get an array’s size with the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator, which we’ll implement in [Chapter 17](chapter17.xhtml). Second, we can
    get its address with the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That’s it! There are no other valid operations on arrays. That probably sounds
    ridiculous, since C programs read and write array elements all the time. What’s
    going on here? The C standard (section 6.3.2.1, paragraph 3) provides the solution
    to this puzzle: “Except when it is the operand of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator, or the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator … an expression that has type ‘array of *type*’ is converted to an expression
    with type ‘pointer to *type*’ that points to the initial element of the array
    object and is not an lvalue.”'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: This implicit conversion from arrays to pointers is called *array-to-pointer
    decay*. (I’ll sometimes say that an array decays to a pointer, and sometimes that
    it’s implicitly converted to a pointer. They both mean the same thing.) While
    we can’t do much with arrays, we can perform all sorts of useful operations on
    pointers. We’ve already implemented some of these operations, and we’ll add a
    few more in this chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The code snippet in [Listing 15-3](chapter15.xhtml#list15-3) shows an example
    of array decay.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-3: Implicitly converting
    an array to a pointer</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say <samp class="SANS_TheSansMonoCd_W5Regular_11">my_array</samp> starts
    at address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>. When <samp
    class="SANS_TheSansMonoCd_W5Regular_11">my_array</samp> appears on the right side
    of the assignment expression in this listing, it will be implicitly converted
    to a pointer whose type is <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>
    and whose value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp> ❶.
    We can then assign this pointer’s value to <samp class="SANS_TheSansMonoCd_W5Regular_11">my_pointer</samp>.
    When we dereference <samp class="SANS_TheSansMonoCd_W5Regular_11">my_pointer</samp>,
    the result is the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> object
    stored in the first 4 bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">my_array</samp>
    ❷. Therefore, we’ll return this object’s current value, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    Note that the address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>
    can be interpreted in a couple of different ways, depending on its type. As an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>, it points to the array’s
    initial element, which we can read or write through a pointer dereference operation.
    The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">&my_array</samp>
    has the same value, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>,
    but it points to the whole array and its type is <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    (*)[3]</samp>.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: It’s especially important to keep track of a pointer’s type when working with
    multidimensional arrays. Consider [Listing 15-4](chapter15.xhtml#list15-4), which
    tries to assign to two array elements.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-4: Legal and illegal
    assignments to array elements</samp>'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The first assignment expression, which assigns to <samp class="SANS_TheSansMonoCd_W5Regular_11">**nested_array</samp>,
    is valid. First, we implicitly convert the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">nested_array</samp>
    to a pointer to the array’s initial element. That element has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp>,
    so the type of the pointer is <samp class="SANS_TheSansMonoCd_W5Regular_11">int(*)[2]</samp>.
    The first dereference operation on this pointer results in an array object with
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp>. We implicitly
    convert *this* array to a pointer with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>. The second pointer dereference therefore produces an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    object, which we can assign to. The assignment expression overwrites that object’s
    current value, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, with a
    new value, <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int(*)[2]</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp> pointers in this expression both point to the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">nested_array</samp>;
    only their types differ.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'The next assignment expression, which assigns to <samp class="SANS_TheSansMonoCd_W5Regular_11">*nested_array</samp>,
    is illegal. It starts out as before: we implicitly convert <samp class="SANS_TheSansMonoCd_W5Regular_11">nested_array</samp>
    to a pointer of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int(*)[2]</samp>,
    dereference it, and implicitly convert the result to a pointer of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>. We then try to assign directly to this pointer, but the C standard states
    that the result of this implicit conversion “is not an lvalue,” so we can’t assign
    to it. It’s not clear what this assignment would do even if it were permitted;
    it would be like assigning to the result of an <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operation.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Now we know how to access an array’s initial element in any dimension. We can
    even read and write to the initial scalar object in an array. However, we usually
    want to access an array’s other elements too. For that, we’ll need pointer arithmetic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pointer Arithmetic
    to Access Array Elements</samp>
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once we have a pointer to an array’s initial element, we’ll use pointer addition
    to produce pointers to its other elements. Let’s work through the example in [Listing
    15-5](chapter15.xhtml#list15-5).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-5: Accessing later
    array elements with pointer arithmetic</samp>'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp> again as
    the array’s starting address. In the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> decays
    to a pointer to the initial array element, as usual. When we add <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    to this pointer, the result is a pointer to the next <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    element in the array. Since each <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    is 4 bytes, we need to multiply <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    by a scale of 4 to calculate how many bytes to add to <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>’s
    address. The resulting pointer’s value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0x14</samp>.
    If we dereferenced this pointer, we would get the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    object at address <samp class="SANS_TheSansMonoCd_W5Regular_11">0x14</samp>, whose
    current value is <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>. Array
    elements are zero indexed, so we say the initial element of <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>
    is at index 0 and the next element is at index 1.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用<samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>作为数组的起始地址。在表达式<samp
    class="SANS_TheSansMonoCd_W5Regular_11">array</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>中，变量<samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>像往常一样变为指向初始数组元素的指针。当我们将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>加到这个指针时，结果是指向数组中下一个<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>元素的指针。由于每个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>是4个字节，我们需要将<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>乘以4的倍数来计算需要加到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">array</samp>地址的字节数。结果指针的值是<samp class="SANS_TheSansMonoCd_W5Regular_11">0x14</samp>。如果我们解引用这个指针，我们将得到地址<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x14</samp>处的<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>对象，它的当前值是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">2</samp>。数组元素是从零开始索引的，所以我们说数组的初始元素位于索引0，下一元素位于索引1。
- en: More generally, when we add an integer *n* to a pointer, the result is a pointer
    to another array element at the position *n* elements further along in the array.
    Similarly, we can move backward in an array by subtracting an integer (or adding
    a negative integer). If the result would be outside the bounds of the array in
    either direction, the behavior is undefined.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，当我们将一个整数*n*加到一个指针时，结果是指向数组中位置为*n*个元素后移的另一个元素的指针。类似地，我们可以通过减去一个整数（或加上一个负整数）来在数组中向后移动。如果结果会超出数组的边界，行为是未定义的。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*If x is an* n*-element array, x + n points one past the end of x. This pointer
    is a special case. It’s not considered out of bounds, and you can use it in pointer
    arithmetic. For example, you can compare it to other pointers to elements in the
    same array. (When you’re looping through array elements, this is a useful way
    to test whether you’ve reached the end.) But dereferencing it is undefined behavior,
    because it doesn’t point to an element of the array.*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果x是一个*n*元素的数组，x + n指向x的末尾之后的位置。这个指针是一个特例，它不被认为是越界的，你可以在指针运算中使用它。例如，你可以将它与指向同一数组中其他元素的指针进行比较。（当你遍历数组元素时，这是一种有用的方式来测试你是否已经到达数组的末尾。）但解引用它是未定义行为，因为它并不指向数组中的任何元素。*'
- en: When we perform pointer arithmetic, the nested structure of the array we point
    into matters, because it dictates what counts as a single element. Let’s look
    at [Listing 15-6](chapter15.xhtml#list15-6) to see how this plays out for the
    two arrays we defined in [Listings 15-1](chapter15.xhtml#list15-1) and [15-2](chapter15.xhtml#list15-2),
    which had identical contents in memory.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行指针运算时，我们所指向的数组的嵌套结构非常重要，因为它决定了什么算作单个元素。让我们看一下[清单 15-6](chapter15.xhtml#list15-6)，看看这如何适用于我们在[清单
    15-1](chapter15.xhtml#list15-1)和[15-2](chapter15.xhtml#list15-2)中定义的两个数组，这两个数组在内存中具有相同的内容。
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-6: Pointer arithmetic
    with flat and nested arrays</samp>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 15-6：平面和嵌套数组的指针运算</samp>
- en: The result of the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    is a pointer to the element at index 1 in <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp>
    ❶. This element is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>. Similarly,
    when we compute <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    we get a pointer to the array element at index 1 in <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>
    ❷. In this case, however, this element is itself an array of two <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    objects, whose current values are <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>. Although <samp class="SANS_TheSansMonoCd_W5Regular_11">six_ints</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp> may have
    identical contents in memory, performing the same operation on both of them produces
    very different results.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'So how can we access the scalar objects in <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>?
    For example, how could we read the last <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    in this array, whose value is <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>?
    First, we’ll get a pointer to the last element in <samp class="SANS_TheSansMonoCd_W5Regular_11">three_arrays</samp>:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This points to the entire two-element array <samp class="SANS_TheSansMonoCd_W5Regular_11">{5,
    6}</samp>. We’ll dereference it to get a pointer to a single scalar element in
    this array instead:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This dereference expression results in an array of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp>,
    which decays to a pointer with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>. Now <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_ptr</samp> points
    to the first <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in this
    nested array, whose value is <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>.
    We’ll increment it to point to the next <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    whose value is <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At that point, we can access its value with a normal pointer dereference:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can consolidate these statements into the single expression in [Listing 15-7](chapter15.xhtml#list15-7).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-7: Accessing the
    last</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">int</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">three_arrays</samp>'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Through repeated pointer addition, dereferencing, and implicit conversions from
    arrays to pointers, we can access any element in a multidimensional array. This
    is, obviously, a huge pain. The subscript operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>,
    provides more convenient syntax to accomplish the same thing. The expression <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a[i]</samp> is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">*(a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i)</samp>,
    so we can rewrite [Listing 15-7](chapter15.xhtml#list15-7) as [Listing 15-8](chapter15.xhtml#list15-8).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-8: A more convenient
    way to access the last</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">int</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">three_arrays</samp>'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The last point I want to emphasize is that subscripting and pointer arithmetic
    apply to all pointers, not just pointers that decayed from arrays. If a pointed-to
    object isn’t in an array, we’ll treat it like the sole element in a one-element
    array. For example, [Listing 15-9](chapter15.xhtml#list15-9) is perfectly valid.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-9: Subscripting
    a pointer to a scalar object</samp>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: When we add <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> and dereference the result,
    we get back the object <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
    Therefore, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr[0]</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>
    evaluates to 1 (that is, true).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Even More Pointer
    Arithmetic</samp>
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll support two other operations on pointers. The first is subtraction; [Listing
    15-10](chapter15.xhtml#list15-10) gives an example.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-10: Subtracting
    two pointers</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: When we subtract pointers to two elements in the same array, the result is the
    difference between their indices. In this example, unsurprisingly, we return <samp
    class="SANS_TheSansMonoCd_W5Regular_11">2</samp>.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: We can also compare pointers to array elements, like in [Listing 15-11](chapter15.xhtml#list15-11).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-11: Comparing pointers</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The pointer to the element with the higher array index compares greater than
    the one with the lower index. In this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    points to the element at index 2 and <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>
    decays to a pointer to the element at index 0, so the comparison <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr
    > arr</samp> evaluates to 1\. If two pointers don’t point into the same array,
    the result of subtracting or comparing them is undefined.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 指向较高数组索引元素的指针会比较大于指向较低索引元素的指针。在这个例子中，<samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    指向索引为2的元素，<samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> 会退化为指向索引为0的元素的指针，因此比较
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr > arr</samp> 的结果为1。如果两个指针不指向同一个数组，那么它们相减或比较的结果是未定义的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array Types in Function
    Declarations</samp>
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">函数声明中的数组类型</samp>
- en: 'It’s illegal for a function to return an array, like in the following declaration:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 函数不能返回数组，如以下声明所示，这是不合法的：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A function can’t take arrays as parameters, either. Weirdly enough, the C standard
    lets you *declare* a function with array parameters, but it requires the compiler
    to adjust your function signature to take pointers instead. For example, the declaration
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也不能接受数组作为参数。奇怪的是，C标准允许你*声明*一个带有数组参数的函数，但它要求编译器将你的函数签名调整为接受指针。例如，声明
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'will be turned into:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将变为：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We’ll adjust parameters with array types to have the corresponding pointer types
    in the type checker.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调整带有数组类型的参数，使其在类型检查器中具有相应的指针类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Things We Aren’t
    Implementing</samp>
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">我们不实现的功能</samp>
- en: 'The features we won’t support are significant enough that I’ll mention them
    explicitly. We won’t implement variable-length arrays, whose length is determined
    at runtime, like this one:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会支持的功能足够重要，我会明确提到它们。我们不会实现可变长度数组，其长度在运行时决定，如下所示：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We’ll permit only constants as the dimensions in array declarations. We also
    won’t permit declarations of incomplete array types:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只允许常量作为数组声明中的维度。我们也不允许声明不完整的数组类型：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: C requires you to specify an array’s dimensions when you define it, but not
    when you declare it. However, we’ll require array dimensions in declarations as
    well as definitions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: C要求在定义数组时指定数组的维度，但在声明时不需要。然而，我们将要求在声明和定义中都指定数组维度。
- en: 'We won’t implement *compound literals*, which let you construct array objects
    (and other aggregate objects) outside of initializers:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会实现*复合字面量*，它允许你在初始化器外构造数组对象（以及其他聚合对象）：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Finally, we won’t fully support C’s semantics for initializing aggregate objects.
    Compound initializers are a bit of a free-for-all; you can omit braces, wrap scalar
    values in braces, or initialize some elements but not others. This makes it tricky
    to figure out which expression is supposed to initialize which element. We’ll
    take a much stricter approach. First of all, we’ll require braces around the initializers
    for each nested array. In other words, we’ll accept the declaration
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不会完全支持C的聚合对象初始化语义。复合初始化器有些自由，你可以省略花括号，将标量值包装在花括号中，或者初始化某些元素而不初始化其他元素。这使得很难弄清楚哪个表达式应该初始化哪个元素。我们将采取更严格的方法。首先，我们将要求每个嵌套数组的初始化器周围加上花括号。换句话说，我们将接受以下声明
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'but we’ll reject the following equivalent declaration, even though the C standard
    permits it:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们将拒绝以下等效的声明，尽管C标准允许它：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We’ll also reject braces around scalar initializers, like in the following
    example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将拒绝围绕标量初始化器的花括号，如下所示：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And we won’t support designators, which let you initialize elements out of
    order:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不支持设计符号，它允许你以非顺序的方式初始化元素：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, we *will* allow compound initializers that don’t initialize every
    array element, like the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们*将*允许不初始化每个数组元素的复合初始化器，如下所示：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this case, we’ll pad out any remaining elements with zeros; that’s the behavior
    the C standard requires. Now that we’ve clarified exactly what we will and won’t
    build, we can move on to the lexer.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将用零填充剩余的元素；这是C标准所要求的行为。现在我们已经明确了我们将构建和不会构建的内容，我们可以继续进行词法分析器的部分。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">词法分析器</samp>
- en: 'You’ll add two tokens in this chapter:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将添加两个标记：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">[</samp> An open square bracket
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">]</samp> A close square bracket
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: After adding these tokens, you can test out your lexer.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we’ll add array types, subscript expressions, and compound initializers
    to the AST. An array’s type indicates the number of elements in the array and
    the type of those elements:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can nest <samp class="SANS_TheSansMonoCd_W5Regular_11">Array</samp> constructors
    to specify a multidimensional array. For example, we’ll represent the type of
    the declaration
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: as <samp class="SANS_TheSansMonoCd_W5Regular_11">Array(Array(Int, 4), 3)</samp>.
    Since we won’t support variable-length arrays, every array type must have a constant
    size.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'A subscript expression contains two subexpressions, a pointer and an index:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Surprisingly, the order in which these two subexpressions appear doesn’t matter;
    the expressions <samp class="SANS_TheSansMonoCd_W5Regular_11">x[1]</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1[x]</samp> are equivalent.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’ll add an <samp class="SANS_TheSansMonoCd_W5Regular_11">initializer</samp>
    construct to support both scalar and compound variable initializers:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp>
    to initialize arrays and <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleInit</samp>
    to initialize scalar objects, including individual array elements. We’ll use a
    nested <samp class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp> construct
    for each row in a multidimensional array. [Listing 15-12](chapter15.xhtml#list15-12)
    shows how to represent the initializer <samp class="SANS_TheSansMonoCd_W5Regular_11">{{1,
    2}, {3, 4}, {5, 6}}</samp>.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-12: Representing
    the initializer for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">three_arrays</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">, from [Listing 15-2](chapter15.xhtml#list15-2),
    as an AST node</samp>'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The type checker will annotate initializers with their types, just like it does
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> nodes. However you
    support type annotations on <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    nodes, you should do the same thing for <samp class="SANS_TheSansMonoCd_W5Regular_11">initializer</samp>.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-13](chapter15.xhtml#list15-13) gives the complete AST definition,
    with this chapter’s additions bolded.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-13: The abstract
    syntax tree with array types, compound initializers, and subscript expressions</samp>'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through how to parse each of these additions to the AST.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Array Declarators</samp>
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You learned how to parse pointer and function declarators in the previous chapter;
    now we’ll extend that code to handle array declarators too. [Listing 15-14](chapter15.xhtml#list15-14)
    shows how to extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">declarator</samp>
    construct that we defined in [Listing 14-6](chapter14.xhtml#list14-6).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-14: Representing
    array declarators</samp>'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll add array declarators to the grammar. Since they have higher precedence
    than pointer declarators, they belong in the <samp class="SANS_TheSansMonoCd_W5Regular_11"><direct-declarator></samp>
    grammar rule:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A direct declarator is a simple declarator with an optional suffix: either
    a parenthesized list of function parameters or a sequence of constant array dimensions
    of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">[</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">const</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">]</samp>. Each <samp class="SANS_TheSansMonoCd_W5Regular_11">ArrayDeclarator</samp>
    specifies just one array dimension, so we’ll parse a <samp class="SANS_TheSansMonoCd_W5Regular_11"><declarator-suffix></samp>
    with multiple dimensions to a sequence of multiple nested <samp class="SANS_TheSansMonoCd_W5Regular_11">ArrayDeclarator</samp>
    nodes. For example, we’d parse the declarator <samp class="SANS_TheSansMonoCd_W5Regular_11">array[1][2]</samp>
    to:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The grammar rule for <samp class="SANS_TheSansMonoCd_W5Regular_11"><declarator-suffix></samp>
    permits floating-point constants as array dimensions, but the C standard requires
    array dimensions to be integers. When you parse a <samp class="SANS_TheSansMonoCd_W5Regular_11"><declarator-suffix></samp>,
    you should reject floating-pointing constants and accept constants of any integer
    type. The C standard also requires array dimensions to be greater than zero, but
    Clang and GCC support zero-length arrays as a language extension. It’s up to you
    whether to accept zero-length arrays or reject them; the test suite doesn’t cover
    this case.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll update <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>,
    which converts a <samp class="SANS_TheSansMonoCd_W5Regular_11">declarator</samp>
    construct into an AST node. [Listing 15-15](chapter15.xhtml#list15-15) illustrates
    how to handle array declarators in <samp class="SANS_TheSansMonoCd_W5Regular_11">process_declarator</samp>.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-15: Applying array
    type derivations</samp>'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: This listing follows the same pattern we introduced to derive pointer types
    in [Chapter 14](chapter14.xhtml).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Abstract
    Array Declarators</samp>
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, let’s deal with abstract declarators, which specify types without declaring
    identifiers. We’ll parse abstract array declarators according to the grammar rule
    in [Listing 15-16](chapter15.xhtml#list15-16).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-16: The grammar
    rule for abstract array declarators</samp>'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: A direct abstract declarator is either a parenthesized declarator, optionally
    followed by a sequence of array dimensions, or just a sequence of array dimensions.
    (Remember that <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp> in EBNF
    syntax indicates zero or more repetitions, while <samp class="SANS_TheSansMonoCd_W5Regular_11">{}+</samp>
    indicates one or more repetitions.) We’ll take the same steps here that we took
    to support normal declarators. [Listing 15-17](chapter15.xhtml#list15-17) shows
    how to extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract_declarator</samp>
    construct.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-17: Representing
    abstract array declarators</samp>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: After updating <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract_declarator</samp>,
    we’ll change our parsing code to handle the grammar rule in [Listing 15-16](chapter15.xhtml#list15-16).
    (This code should accept integer constants as array dimensions and reject floating-point
    constants, just like the code to parse ordinary declarators.) Finally, we’ll update
    <samp class="SANS_TheSansMonoCd_W5Regular_11">process_abstract _declarator</samp>.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Compound
    Initializers</samp>
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s define the grammar rule for initializers:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This rule is straightforward: an initializer is either an expression or a brace-enclosed
    list of one or more nested initializers. Note that there can be a trailing comma
    after the last element in an initializer list: <samp class="SANS_TheSansMonoCd_W5Regular_11">{1,
    2, 3}</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">{1, 2, 3,}</samp>
    are both valid compound initializers.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Subscript
    Expressions</samp>
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last new language feature we need to parse is the subscript operator. Subscripting
    is a *postfix* operator, which follows the expression it modifies. Postfix operators
    have higher precedence than prefix operators like <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>.
    We’ll break up the <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>
    grammar rule to reflect this difference in precedence. At the highest precedence
    level, we’ll have constants, variables, parenthesized expressions, and function
    calls:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, we’ll define a postfix expression as a primary expression, optionally
    followed by a sequence of subscript operators:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Each subscript operator is an expression enclosed in square brackets. Finally,
    we’ll define unary expressions, which include both prefix and cast operators:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[Listing 15-18](chapter15.xhtml#list15-18) shows the complete grammar, with
    this chapter’s changes bolded.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-18: The grammar
    with array types, compound initializers, and subscript expressions</samp>'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve updated your parser to account for all of the changes in [Listing
    15-18](chapter15.xhtml#list15-18), you’re ready to test it out.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Type Checker</samp>
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The type checker will do most of the heavy lifting in this chapter. It will
    add type information to subscript and pointer arithmetic expressions; validate
    the dimensions of compound initializers; and detect type errors, like casting
    an expression to an array type. It will also handle implicit conversions from
    array to pointer types. Just as we insert <samp class="SANS_TheSansMonoCd_W5Regular_11">Cast</samp>
    expressions into the AST to make implicit type conversions explicit, we’ll insert
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions to make
    conversions from arrays to pointers explicit.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Arrays
    to Pointers</samp>
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll convert any array type expression to a pointer, unless it’s already the
    operand of an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expression.
    This might sound familiar from the previous chapter, where we lvalue converted
    the result of every expression, except when we took its address or assigned to
    it. In [Chapter 14](chapter14.xhtml), we introduced a new <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky_and_convert</samp>
    helper function to manage lvalue conversions; now we’ll use a similar design pattern
    in a different compiler pass. We’ll define a new <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    function, shown in [Listing 15-19](chapter15.xhtml#list15-19).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-19: Implicitly converting
    an array to a pointer</samp>'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'If an expression has array type, we insert an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    operation to get its address. We then record its result type, which is a pointer
    to the array’s element type. This is a different result type than we’d get from
    an explicit <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator, which
    always produces a pointer to the type of its operand. Take the following declaration:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">&arr</samp> has
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">int (*)[3]</samp>. The expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>, on the other hand, has
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. In the type checked
    AST, we’re using <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> to
    represent two ways of taking an object’s address, which yield different result
    types: through an implicit conversion or an explicit <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve introduced <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>,
    we’ll use it in place of <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>
    to check both subexpressions and full expressions. The one exception is type checking
    the operand of <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>. This
    operand should not be converted from an array to a pointer, so we’ll continue
    to process it by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>
    directly.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Validating Lvalues</samp>
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll change a couple of details about how we validate lvalues. First, we should
    recognize <samp class="SANS_TheSansMonoCd_W5Regular_11">Subscript</samp> expressions
    as lvalues, in addition to <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Dereference</samp>.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Second, we need to reject assignment expressions that try to assign to arrays.
    Once an array decays to a pointer, it’s no longer an lvalue and can’t be assigned
    to. To catch these invalid assignment expressions, we’ll process the left operand
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    before we check whether it’s an lvalue. [Listing 15-20](chapter15.xhtml#list15-20)
    shows the latest logic to type check assignment expressions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-20: Type checking
    assignment expressions</samp>'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: If the left operand is an array, <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    will wrap it in an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    operation. Then, since <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    isn’t an lvalue, the type checker will throw an error.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking
    Pointer Arithmetic</samp>'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll extend addition, subtraction, and the relational operators to work
    with pointers. Adding any integer type to a pointer is valid. [Listing 15-21](chapter15.xhtml#list15-21)
    demonstrates how to type check addition.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-21: Type checking
    pointer addition</samp>'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: To type check addition involving a pointer and an integer, we first convert
    the integer operand to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    ❶. This will simplify later compiler passes, when pointer indices will need to
    be 8 bytes wide so that we can add them to 8-byte memory addresses. This conversion
    doesn’t come from the C standard; we’re just adding it for our own convenience.
    But it also doesn’t violate the standard; converting a valid array index to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> won’t change its value, so
    the result of the whole expression is the same either way. (If an integer is too
    big to represent as a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>,
    we can safely assume that it’s not a valid array index, since no hardware supports
    arrays with anywhere close to 2^(63) elements.)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The result of pointer addition has the same type as the pointer operand ❷. We
    use the same logic whether the first or second operand is the pointer, so I’ve
    omitted the pseudocode for the latter case ❸. Finally, in any case other than
    adding a pointer to an integer or adding two arithmetic operands, we throw an
    error.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Subtracting an integer from a pointer works the same way: we convert the integer
    operand to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and annotate
    the result with the same type as the pointer operand. The only difference is that
    operand order matters. You can subtract an integer from a pointer, but you can’t
    subtract a pointer from an integer.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: When we subtract one pointer from another, both operands must have the same
    type, and the result has an implementation-defined signed integer type. We’ll
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> as the result type
    here, which is the norm on 64-bit systems. This type is supposed to be aliased
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">ptrdiff_t</samp> in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><stddef.h></samp> header, to help users
    write more portable code. Since we don’t support <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    and therefore can’t compile <samp class="SANS_TheSansMonoCd_W5Regular_11"><stddef.h></samp>,
    we’ll ignore this requirement.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-22](chapter15.xhtml#list15-22) demonstrates how to type check both
    cases of pointer subtraction.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-22: Type checking
    pointer subtraction</samp>'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: If an expression subtracts an integer from a pointer, we handle it just like
    pointer addition ❶. If it subtracts two pointers of the same type, we record <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> as the result type ❷. In any
    other case—if an expression subtracts two pointers of different types, subtracts
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> from a pointer,
    or subtracts a pointer from an arithmetic value—we’ll throw an error.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s deal with the <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> operators. Each of
    these accepts two pointer operands of the same type and returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    These are pretty simple to type check, so I won’t provide pseudocode for this
    case.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Note that none of these operators accept null pointer constants; they compare
    pointers to elements in the same array, but a null pointer, by definition, doesn’t
    point to an array element. By the same logic, you can’t subtract a pointer from
    a null pointer constant. If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is a pointer, the expressions <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">x !=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    are legal, but <samp class="SANS_TheSansMonoCd_W5Regular_11">0 - x</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0 < x</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    >=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> are not. (Clang
    and GCC are more permissive than the standard here; as a language extension, they
    both let you use null pointer constants with any relational operator. With this
    extension, any non-null pointer will compare greater than the null pointer constant.)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Subscript
    Expressions</samp>
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One operand of a subscript expression must be a pointer, and the other must
    be an integer. The pointer’s referenced type is the result type. Remember that
    these two operands can appear in either order; we can’t assume that the pointer
    will be the first operand. [Listing 15-23](chapter15.xhtml#list15-23) shows how
    to type check subscript expressions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-23: Type checking
    a subscript expression</samp>'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: First, we validate that one operand is a pointer and the other is an integer
    ❶. We then convert the integer operand to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    ❷. Finally, we annotate the whole expression with the pointer’s referenced type
    ❸.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Cast
    Expressions</samp>
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This one is easy: you can’t cast an expression to an array type. For example,
    the expression'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: is invalid and should produce a type error.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Function
    Declarations</samp>
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we process a function declaration, we consider both its return type and
    its parameter types. If a function returns an array type, we throw an error. If
    any of its parameters has an array type, we adjust it to a pointer type instead.
    [Listing 15-24](chapter15.xhtml#list15-24) describes how to validate and implicitly
    adjust a function type.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-24: Adjusting array
    types in function declarations</samp>'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: You should add this logic to the very beginning of <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_function
    _declaration</samp>, in order to adjust a function’s parameter types before you
    check whether it conflicts with prior definitions of the same identifier. You
    should also ensure that both the symbol table and the AST node itself use the
    adjusted parameter types.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Compound
    Initializers</samp>
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We need to annotate each initializer with its type and emit an error if an initializer
    is incompatible with the type of the object it’s supposed to initialize. To type
    check a compound initializer, we first validate that the object it initializes
    is an array. Then, we recursively type check each nested initializer, validating
    that it’s compatible with the array’s element type. [Listing 15-25](chapter15.xhtml#list15-25)
    illustrates this approach.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-25: Type checking
    initializers</samp>'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: In the base case, an initializer is a single expression ❶. We’ll type check
    this expression, then call <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>,
    which we defined in [Chapter 14](chapter14.xhtml), to convert it to the target
    type. If it’s not compatible with the target type, <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>
    will throw an error (this includes cases where the target type is an array type).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: In the recursive case, we’ll initialize an array using a compound initializer
    ❷. Each item in the list will initialize one element in the array. First, we’ll
    check that the list doesn’t contain too many elements ❸. Then, we’ll type check
    each list item recursively, using the array’s element type as the target type
    ❹. If the initializer list contains too few elements, we’ll pad it with zeros
    ❺. We’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>
    helper function, which I haven’t provided pseudocode for, to produce zero-valued
    initializers that we can add to the initializer list. Given a scalar type, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp> should return
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleInit</samp> of that type
    with the value 0\. Given an array type, it should return a <samp class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp>
    whose scalar elements (which may be nested several layers deep) have the value
    0\. For example, calling <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>
    on the type <samp class="SANS_TheSansMonoCd_W5Regular_11">UInt</samp> should return
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'and calling it on the type <samp class="SANS_TheSansMonoCd_W5Regular_11">Array(Array(Int,
    2), 2)</samp> should return:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Once we’ve finished building the type checked list of initializers, we’ll package
    it into a <samp class="SANS_TheSansMonoCd_W5Regular_11">CompoundInit</samp>, which
    we’ll annotate with the target type ❻. If the initializer isn’t a single expression
    and the target type isn’t an array type, we’re trying to initialize a scalar object
    with a compound initializer, so we’ll throw an error ❼.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Initializing Static
    Arrays</samp>
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As with other static variables, we’ll store the initial values of static arrays
    in the symbol table. We’ll need to update the data structures we use to represent
    these initial values. We’ll represent the initializer for every object as a list
    of scalar values:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: For scalar objects, <samp class="SANS_TheSansMonoCd_W5Regular_11">init_list</samp>
    will have only one element. The declaration
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'will have this initializer:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: For multidimensional arrays, we’ll flatten out any nested structures. Therefore,
    the declaration
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'will have this initializer:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we’ll add a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    constructor to represent zeroed-out objects of any size:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">bytes</samp> argument to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> specifies how many bytes
    to initialize to zero. If a static array is only partially initialized, we’ll
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> to pad out any
    uninitialized elements. For example, the declaration
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'will have this initializer:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The second element of this initializer list, <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(4)</samp>,
    initializes the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> at <samp
    class="SANS_TheSansMonoCd_W5Regular_11">nested[0][1]</samp>; the last element,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(8)</samp>, initializes
    both elements of the nested array <samp class="SANS_TheSansMonoCd_W5Regular_11">nested[2]</samp>.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve updated the <samp class="SANS_TheSansMonoCd_W5Regular_11">initial_value</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> data structures,
    write a function to convert a compound initializer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    list. You’ll need to validate that initializers for static arrays have the correct
    size and structure, just like initializers for non-static arrays; you should reject
    initializers with too many elements, scalar initializers for arrays, and compound
    initializers for scalar objects. I won’t provide pseudocode for this transformation,
    since it’s similar to the way we type check non-static initializers in [Listing
    15-25](chapter15.xhtml#list15-25).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Initializing Scalar
    Variables with ZeroInit</samp>
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    to initialize scalar variables to zero. For instance, given the declaration
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'you could use this initializer:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Using <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> here is
    optional, but it makes code emission simpler because you can easily tell which
    initializers belong in <samp class="SANS_TheSansMonoCd_W5Regular_11">.data</samp>
    and which belong in <samp class="SANS_TheSansMonoCd_W5Regular_11">.bss</samp>.
    Just be careful about using <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    to initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>s; use
    it only if you’re sure the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>’s
    initial value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp> and
    not <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To accommodate pointer arithmetic and compound initializers, we’ll make a few
    changes to the TACKY IR. First, since we changed how we represent initializers
    in the symbol table, we’ll make the corresponding change in TACKY:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We’ll also introduce a new instruction to support pointer arithmetic:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We’ll use this instruction to add or subtract an integer from a pointer, but
    not to subtract one pointer from another. The <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp>
    operand is the size, in bytes, of each element in the array that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    points into. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp>
    operand will be <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, since
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is 4 bytes. If <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    (*)[3]</samp>, a pointer to an array of three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    objects, then <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp> will
    be <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    operand tells us how many elements forward or back to move from the base pointer.
    At runtime, the program will multiply <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp> to determine how
    many bytes to add to the base pointer. It would be possible to implement pointer
    arithmetic using the existing TACKY instructions for multiplication and addition.
    However, introducing a specialized <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction here will help us take advantage of the x64 architecture’s built-in
    support for pointer arithmetic.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll introduce one more instruction to support compound initializers:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In this instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    is a scalar value, <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> is
    the name of some variable of aggregate type, and <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>
    specifies the number of bytes between the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    and the position we should copy <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    to. It’s important to note that <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    designates an array, *not* a pointer to an array element. In other words, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> doesn’t use the value
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>; it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    to identify an object with a fixed location in memory. Because this instruction
    operates directly on arrays, rather than pointers, it’s useful for array initialization
    but not for subscripting. In [Chapter 18](chapter18.xhtml), we’ll use it to initialize
    and update structures too.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-26](chapter15.xhtml#list15-26) shows the updated TACKY IR, with
    this chapter’s changes bolded.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-26: Adding support
    for arrays to the TACKY IR</samp>'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: With these additions, we can implement every new operator and construct in this
    chapter. Let’s handle each of them in turn.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pointer Arithmetic</samp>
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll implement the pointer arithmetic expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp>
    with an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> instruction,
    as [Listing 15-27](chapter15.xhtml#list15-27) demonstrates.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-27: Adding an integer
    to a pointer in TACKY</samp>'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of things to note about this listing. First, the pointer
    is always the first operand to the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction and the integer is always the second, regardless of which was the
    first operand in the original expression. Second, you need to calculate the size
    of the pointer’s referenced type at compile time, since the <samp class="SANS_TheSansMonoCd_W5Regular_11">scale</samp>
    operand is a constant rather than a TACKY value.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The TACKY to subtract an integer from a pointer is almost identical; we just
    negate the index before we include it in <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>.
    We’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp>
    to the TACKY in [Listing 15-28](chapter15.xhtml#list15-28).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-28: Subtracting
    an integer from a pointer in TACKY</samp>'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Subtracting one pointer from another works a bit differently. First, we calculate
    the difference in bytes, using an ordinary <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp>
    instruction. Then, we divide this result by the number of bytes in one array element,
    to calculate the difference between the two pointers in terms of array indices.
    In other words, we’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr2></samp>
    to the TACKY in [Listing 15-29](chapter15.xhtml#list15-29).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-29: Subtracting
    two pointers in TACKY</samp>'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: We’ll calculate the size of the referenced type at compile time. You can use
    the type of either operand here, since the type checker already validated that
    they both have the same type.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: We’ll compare pointers exactly like arithmetic values, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp> operators.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Subscripting</samp>
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: According to the C standard, the subscript expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr></samp>[<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp>] is equivalent to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><ptr></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp>. So, to implement a subscript
    expression, we’ll generate the TACKY for pointer addition from [Listing 15-27](chapter15.xhtml#list15-27)
    but return a <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(result)</samp>
    to the caller instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand(result)</samp>.
    Generating the right TACKY here is simple, but understanding why it works, especially
    for multidimensional arrays, is a little trickier. To explore this further, let’s
    work through the example in [Listing 15-30](chapter15.xhtml#list15-30).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-30: Returning the
    result of a subscript operator</samp>'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-31](chapter15.xhtml#list15-31) shows the TACKY implementation of
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement in this
    example.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-31: Implementing
    [Listing 15-30](chapter15.xhtml#list15-30) in TACKY</samp>'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: First, we issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    instruction to get a pointer to the first element in <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>.
    Then, we issue two <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instructions to calculate a pointer to the array element at <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i][j]</samp>.
    Finally, we use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction
    to read that array element’s current value into a temporary variable, which we
    return. [Listing 15-31](chapter15.xhtml#list15-31) is efficient, without any superfluous
    instructions. We saw earlier that array subscripting requires us to repeatedly
    get the addresses of array elements, perform pointer arithmetic, and dereference
    the result. But in this listing, we get an array’s address only once, at the beginning
    ❶, and we use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction
    to dereference a pointer only once, at the end ❷. How does our strategy for TACKY
    generation produce this result?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-32](chapter15.xhtml#list15-32) gives the AST for the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement in [Listing 15-30](chapter15.xhtml#list15-30). Let’s figure out how
    each subexpression in this AST is converted to TACKY.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-32: The AST for
    [Listing 15-30](chapter15.xhtml#list15-30)</samp>'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: The AST includes the two <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    expressions we inserted during type checking. The inner one ❺ gets the address
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>, and the outer one
    ❸ gets the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i]</samp>.
    Of course, <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> would have been renamed
    during identifier resolution, but we’ll ignore that detail in this example (and
    in the later examples in this chapter).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we convert this AST to TACKY in postorder, processing each expression’s
    operands before we process the expression itself. The first non-leaf AST node
    we process is the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    expression, which takes the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>
    ❺. We convert it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    instruction:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Next, to implement the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">Subscript</samp>
    expression ❹, we emit an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The scale here is <samp class="SANS_TheSansMonoCd_W5Regular_11">16</samp> because
    <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> points to a four-<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> array. The second part of a
    subscript operation is dereferencing the result, so we’ll return <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(tmp1)</samp>
    to the caller.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: In the caller, we process the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    expression ❸. When we take the address of a dereferenced pointer, the operations
    cancel out. Therefore, we return <samp class="SANS_TheSansMonoCd_W5Regular_11">PlainOperand(tmp1)</samp>
    as the result of this expression, without emitting any further instructions.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we process the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">Subscript</samp>
    expression ❷. Once again, we emit an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We then return <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(tmp2)</samp>
    to the caller. Because this <samp class="SANS_TheSansMonoCd_W5Regular_11">Subscript</samp>
    expression appears in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    statement ❶, not an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    or assignment expression, we lvalue convert this result. That means we emit a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> instruction:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp3</samp> contains the
    lvalue-converted result of the whole expression, so we return it:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: As this example illustrates, when we index into a multidimensional array the
    dereference operations and implicit address loads cancel each other out, without
    producing any extra instructions. Therefore, any subscript and dereference operators
    work out to pure pointer arithmetic in TACKY, without any <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instructions, until
    we reach a scalar array element.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Compound Initializers</samp>
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To process a compound initializer, we evaluate each scalar expression in the
    initializer and copy it to the appropriate location in memory with a <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    instruction. For example, we’ll convert the initializer
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'to the following sequence of instructions:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Since a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> is 8 bytes,
    the offset increases by eight with each element. Even when we process a nested
    initializer, we only need to copy the scalar values at the leaves to the correct
    memory locations. For example, we’ll convert
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'to:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This conversion is pretty straightforward, so I’ll omit the pseudocode for it.
    I will note, however, that you should use the type information the type checker
    added to each compound initializer to calculate the offset of each element.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tentative Array Definitions</samp>
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recall that when we convert symbol table entries to <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>
    constructs, we initialize tentatively defined variables to zero. That goes for
    tentatively defined arrays too. You should use the new initializer we added in
    the previous section, <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>,
    to initialize an *n*-byte array to zero.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    to initialize tentatively defined scalar variables. For consistency, you should
    only use <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> here if
    you’re using it to initialize explicitly defined scalar variables to zero in the
    type checker.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We won’t introduce any new assembly instructions in this chapter. We will,
    however, introduce a new memory addressing mode, sometimes called *indexed addressing*.
    Right now, we can specify a memory operand with a base address in a register and
    a constant offset, like <samp class="SANS_TheSansMonoCd_W5Regular_11">4(%rax)</samp>.
    Using indexed addressing, we can store the base address in one register and an
    index in another. We can also specify a scale, which must be one of the constants
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>.
    Here’s an example of indexed addressing in action:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: To find the destination address of this <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    instruction, the CPU will calculate RAX + RBX × 4\. Then, it will store the 4-byte
    constant <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> at this address.
    This addressing mode is convenient for array accesses. If RAX holds the address
    of an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> objects
    and RBX holds an index *i* into that array, the operand <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rax,
    %rbx, 4)</samp> specifies the element at index *i*.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll add a new operand to support indexed addressing:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We’ll also make a few other changes to the assembly AST to help with bookkeeping
    in later backend passes. For starters, we’ll add another operand to represent
    aggregate objects that haven’t been assigned a fixed address yet:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> operand serves
    a similar purpose to the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    operand; it lets us represent variables in assembly before we’ve allocated registers
    or memory locations for them. The difference is that <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    represents aggregate objects, which we’ll always store in memory (even once we
    implement register allocation in [Part III](part3.xhtml)). <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>,
    on the other hand, represents scalar objects that could potentially be stored
    in registers. The <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operand also lets us specify a byte offset into the object in question. Note that
    the identifier in this operand designates an aggregate object, not a pointer to
    an aggregate object.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll add a new assembly type to represent arrays. In assembly, we’ll
    treat an array like an undifferentiated chunk of memory. We no longer need to
    track how many objects will be stored in that chunk of memory or what those objects’
    types will be. We do, however, care about its alignment and how much space it
    takes up, so we can allocate stack space for it. Therefore, we’ll convert array
    types to a new <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>
    type:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Finally, we’ll adjust how we represent static variables. As in earlier compiler
    passes, we’ll initialize a static variable with a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    values, instead of just one:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[Listing 15-33](chapter15.xhtml#list15-33) highlights all the changes to the
    assembly AST in this chapter.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-33: The assembly
    AST with support for aggregate objects and indexed addressing</samp>'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve updated the assembly AST, we’ll update the conversion from TACKY
    to assembly.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting TACKY
    to Assembly</samp>
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, we’ll deal with TACKY variables of array type. To distinguish these from
    scalar values, we’ll convert them to <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operands, instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    operands. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>
    is an array, we’ll convert
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'to:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Whenever we convert an aggregate TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>
    to assembly, we’ll use an offset of zero, in order to designate the whole object.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s deal with the new <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> instructions.
    We’ll use a <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> operand
    with the appropriate offset to represent the destination of a <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    instruction. Therefore, we’ll convert
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'to:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We’ll implement <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    with an <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp> instruction using
    the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp> operand.
    The details will vary depending on the scale and index. First, let’s consider
    the case where the scale is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>. We’ll convert
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: to [Listing 15-34](chapter15.xhtml#list15-34).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-34: Implementing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddPtr</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    assembly</samp>'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: First, we copy <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> into registers; I’ve
    used RAX and RDX here, but anything other than the callee-saved registers or our
    scratch registers will do. Then, we emit an <samp class="SANS_TheSansMonoCd_W5Regular_11">Lea</samp>
    instruction to compute <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">index
    * scale</samp> and store the result in <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: The scale of <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> may
    not be one of the four values that <samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp>
    supports, especially if we’re indexing into a multidimensional array instead of
    an array of scalar objects. In that case, we’ll use a separate instruction to
    multiply the scale by the index, as [Listing 15-35](chapter15.xhtml#list15-35)
    illustrates.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-35: Implementing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddPtr</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    assembly with a nonstandard scale</samp>'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> operand is
    a constant, we can save an instruction by computing <samp class="SANS_TheSansMonoCd_W5Regular_11">index
    * scale</samp> at compile time. Then, we’ll generate just the two instructions
    in [Listing 15-36](chapter15.xhtml#list15-36).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-36: Implementing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">AddPtr</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">with
    a constant index</samp>'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll deal with pointer comparisons. We’ll implement these exactly like
    unsigned integer comparisons, using the unsigned condition codes: <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp>.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s talk about the alignment requirements for arrays. There are
    a couple of cases where we need to calculate an array’s alignment: when we convert
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> of array
    type from TACKY to assembly (a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>
    in assembly includes an <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>
    field), and when we convert a frontend symbol table entry of array type to the
    corresponding entry in the backend symbol table. The assembly type of each array
    in the backend symbol table will be a <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>
    with the appropriate size and alignment. The size will be the size of the array’s
    element type in bytes, multiplied by the number of elements. The rules for calculating
    alignment are a bit less obvious.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: If an array is smaller than 16 bytes, it has the same alignment as its scalar
    elements. For example, an array with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2]</samp>
    and an array with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int[2][1]</samp>
    both have an alignment of 4\. If an array-type variable is 16 bytes or larger,
    its alignment is always 16, no matter what type its elements are. This requirement
    makes it possible to use SSE instructions to operate on multiple array elements
    at once. We don’t use SSE instructions this way, but we need to maintain ABI compatibility
    with other object files that might.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Note that this alignment requirement applies only to variables, not to nested
    arrays. For example, if we declare the variable
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: then <samp class="SANS_TheSansMonoCd_W5Regular_11">nested</samp> needs to start
    at a 16-byte-aligned address because its total size is 60 bytes. But its first
    and second elements start at 20 and 40 bytes, respectively, from the start of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nested</samp>, so they aren’t 16-byte
    aligned, even though each of these elements is also larger than 16 bytes.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[Tables 15-1](chapter15.xhtml#tab15-1) through [15-5](chapter15.xhtml#tab15-5)
    summarize this chapter’s updates to this compiler pass; as usual, new constructs
    and changes to the conversions for existing constructs are bolded.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-1:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Top-Level TACKY Constructs to Assembly</samp>
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '|'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '|'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Constant index</samp> |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
- en: '[PRE107]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '|'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '|'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '|'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '|'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '|'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '|'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '|'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-3:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Comparisons to Assembly</samp>
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY comparison</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly condition code</samp> |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">pointer</samp><samp
    class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">LE</samp>
    |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">pointer</samp><samp
    class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp>
    |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">pointer</samp><samp
    class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">GE</samp>
    |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">pointer</samp><samp
    class="SANS_Futura_Std_Book_11">, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp> |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-4:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Operands to Assembly</samp>
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Var(identifier)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Scalar value</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Pseudo(identifier)</samp>
    |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">Aggregate value</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">PseudoMem(identifier, 0)</samp> |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-5:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Types to Assembly</samp>
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp> |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Array(element, size)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Variables that are 16 bytes or larger</samp>
    |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
- en: '[PRE114]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">16</samp> |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Everything else</samp> |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
- en: '[PRE115]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Same alignment as element</samp>
    |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
- en: Next, we’ll replace <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operands with concrete addresses.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing PseudoMem
    Operands</samp>
  id: totrans-424
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can’t call this pass “pseudoregister replacement” anymore, because we’re
    replacing aggregate values too. Just like we’ll allocate 4 bytes of stack space
    for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp> and 8 bytes
    for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>, we’ll allocate
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">size</samp> bytes for an
    object with type <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">size</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">alignment</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>.
    As usual, we’ll round down the array’s address to the appropriate alignment.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'Once an array has been assigned a memory address, we’ll replace any <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operands that refer to it. A <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operand includes an offset from the start of the array, and the array’s concrete
    address includes an offset from the address in RBP. We’ll add these two offsets
    to construct a new concrete memory address. For example, suppose we encounter
    the following instruction:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Let’s say that we previously assigned <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>
    the stack address <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>.
    We compute –12 + 4 to determine that our new, concrete operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>.
    We then rewrite the instruction accordingly:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: To access an array with static storage duration, we use the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operand. If <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> is a static
    array, we convert
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'to:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: If we encountered <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem("arr",</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
    for any nonzero <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp>,
    we’d be in trouble, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operand doesn’t include an offset. Luckily, this situation won’t come up. At the
    moment, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operands with nonzero offsets only to initialize arrays with automatic storage
    duration, not to access arrays with static storage duration.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: RIP-relative addressing *does* support constant offsets—for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">foo+4(%rip)</samp>
    represents the address 4 bytes past the symbol <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>—but
    we can’t represent these offsets in the assembly AST yet. We’ll add them in [Chapter
    18](chapter18.xhtml) to support operations on structures.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up Instructions</samp>
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We didn’t introduce any new instructions, so we don’t need any new instruction
    fix-up rules. This pass must recognize that the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp>
    operand specifies a memory address and therefore can’t be used where a register
    or immediate value is required. Otherwise, we don’t need to change anything.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll make four small additions to this stage. First, we’ll emit the new <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp> operand. Second, we’ll
    emit the static <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    initializer as a <samp class="SANS_TheSansMonoCd_W5Regular_11">.zero</samp> assembly
    directive. For example, we’ll emit <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit(32)</samp>
    as:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Third, if a variable’s only initializer is <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>,
    we’ll write it to the BSS section instead of the data section.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: And finally, when we define a static variable, we’ll emit each item in the associated
    initializer list. The file scope declaration
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: will ultimately be translated to the assembly in [Listing 15-37](chapter15.xhtml#list15-37).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 15-37: Initializing
    a static array in assembly</samp>'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: Note that we initialize the last element of this array to zero because it wasn’t
    initialized explicitly.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[Tables 15-6](chapter15.xhtml#tab15-6) through [15-8](chapter15.xhtml#tab15-8)
    summarize these additions to the code emission stage, with new constructs and
    changes to the way we emit existing constructs bolded.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-6:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Top-Level Assembly Constructs</samp>
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |  | <samp class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '|'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '|'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '|'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">All other variables</samp> |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
- en: '[PRE126]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '|'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-7:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Static Initializers</samp>
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Static initializer</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">ZeroInit(n)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">.zero</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><n></samp> |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 15-8:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Indexed(reg1, reg2, int)</samp>
    |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
- en: '[PRE127]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '|'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: After making these changes, you can test out your compiler.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve just implemented your first aggregate type! In this chapter, you learned
    how to parse array declarators and compound initializers. In the type checker,
    you made implicit conversions from arrays to pointers explicit and analyzed the
    types of pointer arithmetic expressions. During TACKY generation, you relied on
    those conversions and that type information to handle operations on pointers cleanly,
    regardless of whether they point to arrays or scalar values. And on the backend,
    you added new, more flexible ways to address values in memory.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you’ll implement three more integer types: <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>. You’ll also implement string literals, which can be either array
    initializers or <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> arrays
    that decay to pointers, depending on context. Because you’ve already implemented
    integer types, pointers, and arrays, a lot of the groundwork for the work you’ll
    do there is already in place.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
