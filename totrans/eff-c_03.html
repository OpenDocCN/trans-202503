<html><head></head><body>
<section aria-labelledby="ch3" epub:type="chapter" role="doc-chapter">
<span aria-label="47" epub:type="pagebreak" id="pg_47" role="doc-pagebreak"/>
<hgroup>

<h1 class="CHAPTER" id="ch3">
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">ARITHMETIC TYPES</samp></span>
</h1>
</hgroup>
<figure class="opener"><img alt="" class="opener" src="../images/opener.jpg"/>
</figure>
<p class="COS">In this chapter, you’ll learn about the two kinds of <i>arithmetic types</i>: integers and floating types. Most operators in C operate on arithmetic types. Because C is a system-level language, performing arithmetic operations correctly can be difficult, resulting in frequent defects. This is partially because arithmetic operations in digital systems with limited range and precision do not always produce the same result as they would in ordinary mathematics. Performing basic arithmetic correctly is an essential foundation to becoming a professional C programmer.</p>
<p class="TX">We’ll dive deep into how arithmetic works in the C language so that you have a firm grasp of these fundamental concepts. We’ll also look at how to <span aria-label="48" epub:type="pagebreak" id="pg_48" role="doc-pagebreak"/>convert one arithmetic type to another, which is necessary for performing operations on mixed types.</p>
<section aria-labelledby="sec1" epub:type="division">

<h2 class="H1"><span id="sec1"/><span id="h1-27"/><samp class="SANS_Futura_Std_Bold_B_11">Integers</samp></h2>
<p class="TNI">As mentioned in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, each integer type represents a finite range of integers. Signed integer types represent values that can be negative, zero, or positive; unsigned integers represent values that can be only zero or positive. The range of values that each integer type can represent depends on your implementation.</p>
<p class="TX">The <i>value</i> of an integer object is the ordinary mathematical value stored in the object. The <i>representation</i> of a value for an integer object is the particular encoding of the value in the bits of the object’s allocated storage. We’ll look at the representation in more detail later.</p>
<section aria-labelledby="sec2" epub:type="division">

<h3 class="H2"><span id="sec2"/><span id="h2-31"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Padding, Width, and Precision</samp></h3>
<p class="TNI">All integer types except <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> may contain unused bits, called <i>padding</i>, that allow implementations to accommodate hardware quirks (such as skipping over a sign bit in the middle of a multiple- word representation) or to optimally align with a target architecture. The number of bits used to represent a value of a given type, excluding padding but including the sign, is called the <i>width</i> and is often denoted by <i>N</i>. The <i>precision</i> is the number of bits used to represent values, excluding sign and padding bits.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">

<h3 class="H2"><span id="sec3"/><span id="h2-32"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integer Ranges</samp></h3>
<p class="TNI">A <i>representable value</i> is a value that can be represented in the number of bits available to an object of a particular type. Values that cannot be represented will be diagnosed by the compiler or converted to a representable but different (incorrect) value. The <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;limits.h&gt;</samp> header file defines object-like macros that expand to various limits and parameters of the standard integer types. To write portable code, you should use these macros rather than integer literals such as +2147483647 (the maximum value representable as a 32-bit integer) that represent a specific limit and may change when porting to a different implementation.</p>
<p class="TX">The C standard imposes only three constraints on integer sizes. First, storage for <i>every</i> data type occupies an integral number of adjacent <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> objects (which may include padding). Second, each integer type must support a minimum range of values, allowing you to depend on a portable range of values across any implementation. Third, smaller types cannot be wider than larger types. So, for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">short</samp> cannot be wider than <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, but both types may have the same width.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<span aria-label="49" epub:type="pagebreak" id="pg_49" role="doc-pagebreak"/>
<h3 class="H2"><span id="sec4"/><span id="h2-33"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integer Declarations</samp></h3>
<p class="TNI">Unless declared as <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>, integer types are assumed to be signed (except for <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, which the implementation can define as either a signed or unsigned integer type). The following are valid declarations of unsigned integers:</p>

<pre><code>unsigned int ui; // unsigned is required
unsigned u; // int can be omitted
unsigned long long ull2; // int can be omitted
unsigned char uc; // unsigned is required</code></pre>
<p class="TX">When declaring signed integer types, you can omit the signed keyword— except for <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, which requires the keyword to distinguish <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> from plain <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>.</p>
<p class="TX">You can also omit <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> when declaring variables of type <samp class="SANS_TheSansMonoCd_W5Regular_11">short</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">long long</samp>. For example:</p>

<pre><code>int i; // signed can be omitted
long long int sll; // signed can be omitted
long long sll2; // signed and int can be omitted
signed char sc; // signed is required</code></pre>
<p class="Continued">These are all valid signed integer declarations.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">

<h3 class="H2"><span id="sec5"/><span id="h2-34"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unsigned Integers</samp></h3>
<p class="TNI"><i>Unsigned integers</i> have ranges that start at 0, and their upper bound is greater than that of the corresponding signed integer type. Unsigned integers are frequently used for counting items that may have large, nonnegative quantities.</p>
<section aria-labelledby="sec6" epub:type="division">

<h4 class="H3"><span id="sec6"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Representation</samp></h4>
<p class="TNI">Unsigned integer types are easier to understand and to use than signed integer types. They represent values using a pure binary system with no offset: the least significant bit has the weight 2<sup>0</sup>, the next least significant has the weight 2<sup>1</sup>, and so forth. The value of the binary number is the sum of all the weights of the set bits. <a href="chapter3.xhtml#tab3-1">Table 3-1</a> shows some examples of unsigned values using an unpadded 8-bit representation.</p>
<p class="TT" id="tab3-1"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</samp> <samp class="SANS_Futura_Std_Book_11">8-Bit Unsigned Values</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Decimal</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Binary</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Hexadecimal</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0b00000000</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0b00000001</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0x01</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0b00101010</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0x2A</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">255</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0b11111111</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX"><span aria-label="50" epub:type="pagebreak" id="pg_50" role="doc-pagebreak"/>Unsigned integer types do not have a sign bit, allowing for 1-bit greater precision than the corresponding signed integer types. Unsigned integer values range from 0 to a maximum value that depends on the width of the type. This maximum value is 2<i><sup>N</sup></i> – 1, where <i>N</i> is the width. For example, most x86 architectures use 32-bit integers with no padding bits, so an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> has a range of 0 to 2<sup>32</sup> – 1 (4,294,967,295). The constant expression <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;limits.h&gt;</samp> specifies the implementation-defined upper range for this type. <a href="chapter3.xhtml#tab3-2">Table 3-2</a> shows the constant expressions from <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;limits.h&gt;</samp> for each unsigned type and the minimum magnitude required by the standard.</p>
<p class="TT" id="tab3-2"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-2:</samp> <samp class="SANS_Futura_Std_Book_11">Unsigned Integer Minimum Magnitudes</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Constant expression</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Minimum magnitude</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Maximum value for an object of type</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">UCHAR_MAX</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">255 // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">8</samp> <samp class="SANS_Futura_Std_Book_11">– 1</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">USHRT_MAX</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">65,535 // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">16</samp> <samp class="SANS_Futura_Std_Book_11">– 1</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned short int</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">65,535 // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">16</samp> <samp class="SANS_Futura_Std_Book_11">– 1</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">ULONG_MAX</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4,294,967,295 // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">32</samp> <samp class="SANS_Futura_Std_Book_11">– 1</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long int</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">ULLONG_MAX</samp></p></td>
<td class="TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">18,446,744,073,709,551,615 // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">64</samp> <samp class="SANS_Futura_Std_Book_11">– 1</samp></p></td>
<td class="TBL"><p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long long int</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">Your compiler will replace these values with implementation-defined magnitudes.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">

<h4 class="H3"><span id="sec7"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Wraparound</samp></h4>
<p class="TNI">C23 defines <i>wraparound</i> as “the process by which a value is reduced modulo 2<i><sup>N</sup></i>, where <i>N</i> is the width of the resulting type.” Wraparound occurs when you perform arithmetic operations that result in values too small (less than 0) or too large (greater than 2<i><sup>N</sup></i> – 1) to be represented as a particular unsigned integer type. In this case, the value is reduced modulo the number that is one greater than the largest value that can be represented in the resulting type. Wraparound is well-defined behavior in the C language. Whether it is a defect in your code depends on the context. If you are counting something and the value wraps, it is likely to be an error. However, the use of wraparound in certain algorithms is intentional.</p>
<p class="TX">The code in <a href="chapter3.xhtml#Lis3-1">Listing 3-1</a> illustrates wraparound by initializing an unsigned integer value <samp class="SANS_TheSansMonoCd_W5Regular_11">ui</samp> to its maximum value and incrementing it.</p>
<span id="Lis3-1"/>
<pre><code>unsigned int ui = UINT_MAX;  // 4,294,967,295 on x86
ui++;
printf("ui = %u\n", ui); // ui is 0
ui--;
printf("ui = %u\n", ui); // ui is 4,294,967,295</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-1: Unsigned integer wraparound</samp></p>
<p class="TX"><span aria-label="51" epub:type="pagebreak" id="pg_51" role="doc-pagebreak"/>The resulting value cannot be represented as an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, so it wraps around to 0. If the resulting value is decremented, it falls outside the range again and will wrap around back to <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>.</p>
<p class="TX">Because of wraparound, an unsigned integer expression can never evaluate to less than 0. It’s easy to lose track of this and implement comparisons that are always true or always false. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> in the following <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop can never take on a negative value, so this loop will never terminate:</p>

<pre><code>for (unsigned int i = n; i &gt;= 0; --i)</code></pre>
<p class="TX">This behavior has caused some notable real-world bugs. For example, all six power-generating systems on a Boeing 787 are managed by a corresponding generator control unit. Boeing’s laboratory testing discovered that an internal software counter in the generator control unit wraps around after running continuously for 248 days (see the Federal Aviation Administration Rule at <i><a href="https://www.federalregister.gov/documents/2015/05/01/2015-10066/airworthiness-directives-the-boeing-company-airplanes">https://<wbr/>www<wbr/>.federalregister<wbr/>.gov<wbr/>/documents<wbr/>/2015<wbr/>/05<wbr/>/01<wbr/>/2015<wbr/>-10066<wbr/>/airworthiness<wbr/>-directives<wbr/>-the<wbr/>-boeing<wbr/>-company<wbr/>-airplanes</a></i>). This defect causes all six generator control units on the engine-mounted generators to enter fail-safe mode at the same time.</p>
<p class="TX">To avoid unplanned behavior (such as having your airplane fall from the sky), it’s important to check for wraparound by using the limits from <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;limits.h&gt;</samp>. Be careful when implementing these checks because it’s easy to make mistakes. For example, the following code contains a defect, as <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ui</samp> can never be larger than <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>:</p>

<pre><code>extern unsigned int ui, sum;
// assign values to ui and sum
if (sum + ui &gt; UINT_MAX)
  too_big();
else
  sum = sum + ui;</code></pre>
<p class="TX">If the result of adding <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ui</samp> is larger than <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>, it is reduced modulo <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. Therefore, the test is useless, and the generated code will unconditionally perform the summation. Quality compilers might issue a warning pointing this out, but not all do so. To remedy this, you can subtract <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> from both sides of the inequality to form the following effective test:</p>

<pre><code>extern unsigned int ui, sum;
// assign values to ui and sum
<b>if (ui &gt; UINT_MAX - sum)</b>
  too_big();
else
  sum = sum + ui;</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp> macro is the largest representable <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> value, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> is a value between 0 and <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>, the result of the subtraction is 0, and if <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> is equal to 0, the result of the subtraction is <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>. Because the result of this operation will always fall in the allowable range of 0 to <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>, it can never wrap around.</p>
<p class="TX"><span aria-label="52" epub:type="pagebreak" id="pg_52" role="doc-pagebreak"/>The same problem occurs when checking the result of an arithmetic operation against 0, the minimum unsigned value:</p>

<pre><code>extern unsigned int i, j;
// assign values to i and j
if (<b>i - j &lt; 0</b>)  // cannot happen
  negative();
else
  i = i - j;</code></pre>
<p class="TX">Because unsigned integer values can never be negative, the subtraction will be performed unconditionally. Quality compilers may warn about this mistake as well. Instead of this useless test, you can check for wraparound by testing whether <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>:</p>

<pre><code>if (<b>j &gt; i</b>)  // correct
  negative();
else
  i = i - j;</code></pre>
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">j &gt; i</samp>, the difference would wrap around, so the possibility of wraparound is prevented. By eliminating the subtraction from the test, the possibility of wraparound is also eliminated.</p>
<blockquote>
<p class="Note"><samp class="SANS_Dogma_OT_Bold_B_15">WARNING</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>Keep in mind that the width used during wraparound depends on the implementation, which means you can obtain different results on different platforms. Your code won’t be portable if you fail to account for this.</i></p>
</section>
</section>
<section aria-labelledby="sec8" epub:type="division">

<h3 class="H2"><span id="sec8"/><span id="h2-35"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Signed Integers</samp></h3>
<p class="TNI">Each unsigned integer type (excluding <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>) has a corresponding signed integer type that occupies the same amount of storage. Use signed integers to represent negative, zero, and positive values, the range of which depends on the number of bits allocated to the type and the representation.</p>
<section aria-labelledby="sec9" epub:type="division">

<h4 class="H3"><span id="sec9"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Representation</samp></h4>
<p class="TNI">Representing signed integer types is more complicated than representing unsigned integer types. Historically, the C language has supported three different schemes for representing negative numbers: sign and magnitude, one’s complement, and two’s complement.</p>
<p class="TX">Starting with C23, only two’s-complement representation is supported. In two’s complement representation, the sign bit is given the weight −(2<i><sup>N</sup></i> <sup>− 1</sup>), and the other value bits have the same weights as for unsigned. The remainder of this book assumes the two’s complement representation.</p>
<p class="TX">Signed two’s-complement integer types with a width of <i>N</i> can represent any integer value in the range of –2<i><sup>N</sup></i> <sup>– 1</sup> to 2<i><sup>N</sup></i> <sup>– 1</sup> – 1. This means, for example, that an 8-bit value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> has a range of –128 to 127. Compared to other signed integer representations, two’s complement can <span aria-label="53" epub:type="pagebreak" id="pg_53" role="doc-pagebreak"/>represent an additional <i>most negative</i> value. The most negative value for an 8-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> is –128, and its absolute value |–128| cannot be represented as this type. This leads to some interesting edge cases, which we’ll soon examine in more detail.</p>
<p class="TX"><a href="chapter3.xhtml#tab3-3">Table 3-3</a> shows the constant expressions from <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;limits.h&gt;</samp> for each signed type and the minimum magnitudes required by the standard. Your compiler will replace these values with implementation-defined magnitudes.</p>
<p class="TT" id="tab3-3"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-3:</samp> <samp class="SANS_Futura_Std_Book_11">Signed Integer Minimum Magnitudes</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Constant expression</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Minimum magnitude</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Type</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MIN</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">–128 // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">7</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MAX</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">+127 // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">7</samp> <samp class="SANS_Futura_Std_Book_11">– 1</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">SHRT_MIN</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">–32,768 // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">15</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">short int</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">SHRT_MAX</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">+32,767 // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">15</samp> <samp class="SANS_Futura_Std_Book_11">– 1</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">short int</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">INT_MIN</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">–32,768 // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">15</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">INT_MAX</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">+32,767 // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">15</samp> <samp class="SANS_Futura_Std_Book_11">– 1</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MIN</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">–2,147,483,648 // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">31</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">+2,147,483,647 // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">31</samp> <samp class="SANS_Futura_Std_Book_11">– 1</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">LLONG_MIN</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">–9,223,372,036,854,775,808 // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">63</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">LLONG_MAX</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">+9,223,372,036,854,775,807 // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">63</samp> <samp class="SANS_Futura_Std_Book_11">– 1</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">To negate a value in two’s-complement representation, simply toggle each nonpadding bit and then add 1 (with carries as necessary), as shown in <a href="chapter3.xhtml#fig3-1">Figure 3-1</a>.</p>
<figure class="IMG"><img alt="" class="img1" id="fig3-1" src="../images/f03001.jpg"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: Negating an 8-bit value in two’s-complement representation</samp></p></figcaption>
</figure>
<p class="TX"><a href="chapter3.xhtml#tab3-4">Table 3-4</a> shows the binary and decimal representations for an 8-bit two’s-complement signed integer type with no padding (that is, <i>N</i> = 8).</p>
<p class="TT" id="tab3-4"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-4:</samp> <samp class="SANS_Futura_Std_Book_11">8-Bit Two’s-Complement Values</samp></p>
<p class="Anchor"><span aria-label="54" epub:type="pagebreak" id="pg_54" role="doc-pagebreak"/></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Binary</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Decimal</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Weighting</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Constant</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">00000000</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>
<td class="TB"/>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">00000001</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">2</samp><samp class="SANS_Futura_Std_Book_SUP_11">0</samp></p></td>
<td class="TB"/>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">01111110</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">126</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">2</samp><samp class="SANS_Futura_Std_Book_SUP_11">6</samp> <samp class="SANS_Futura_Std_Book_11">+ 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">5</samp> <samp class="SANS_Futura_Std_Book_11">+ 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">4</samp> <samp class="SANS_Futura_Std_Book_11">+ 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">3</samp> <samp class="SANS_Futura_Std_Book_11">+ 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp> <samp class="SANS_Futura_Std_Book_11">+ 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">1</samp></p></td>
<td class="TB"/>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">01111111</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">127</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">2</samp><samp class="SANS_Futura_Std_Book_SUP_11">8</samp> <samp class="SANS_Futura_Std_Book_SUP_11">−</samp> <samp class="SANS_Futura_Std_Book_SUP_11">1</samp> <samp class="SANS_Futura_Std_Book_11">– 1</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MAX</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">10000000</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">−128</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">−(2</samp><samp class="SANS_Futura_Std_Book_SUP_11">8</samp> <samp class="SANS_Futura_Std_Book_SUP_11">−</samp> <samp class="SANS_Futura_Std_Book_SUP_11">1</samp><samp class="SANS_Futura_Std_Book_11">) + 0</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MIN</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">10000001</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">−127</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">−(2</samp><samp class="SANS_Futura_Std_Book_SUP_11">8</samp> <samp class="SANS_Futura_Std_Book_SUP_11">−</samp> <samp class="SANS_Futura_Std_Book_SUP_11">1</samp><samp class="SANS_Futura_Std_Book_11">) + 1</samp></p></td>
<td class="TB"/>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">11111110</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">−2</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">−(2</samp><samp class="SANS_Futura_Std_Book_SUP_11">8</samp> <samp class="SANS_Futura_Std_Book_SUP_11">−</samp> <samp class="SANS_Futura_Std_Book_SUP_11">1</samp><samp class="SANS_Futura_Std_Book_11">) + 126</samp></p></td>
<td class="TB"/>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">11111111</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">−1</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">−(2</samp><samp class="SANS_Futura_Std_Book_SUP_11">8</samp> <samp class="SANS_Futura_Std_Book_SUP_11">−</samp> <samp class="SANS_Futura_Std_Book_SUP_11">1</samp><samp class="SANS_Futura_Std_Book_11">) + 127</samp></p></td>
<td class="TBL"/>
</tr>
</tbody>
</table>
<p class="TX">It is not necessary to know the binary representations of numbers, but as a C programmer, you will likely find it useful.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">

<h4 class="H3"><span id="sec10"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Integer Overflow</samp></h4>
<p class="TNI"><i>Integer overflow</i> occurs when a signed integer operation results in a value that cannot be represented in the resulting type. Signed integer overflow and unsigned integer wraparound are often confused. The primary difference is that signed integer overflow is undefined behavior, while unsigned integer wraparound is well-defined behavior. Unsigned integers cannot overflow.</p>
<p class="TX">Consider the following function-like macro that returns the absolute value of an arithmetic operand:</p>

<pre><code>// undefined or wrong for the most-negative value
#define ABS(i) ((i) &lt; 0 ? –(i) : (i))</code></pre>
<p class="TX">We’ll examine macros in detail in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>. For now, think of function-like macros as functions that operate on generic types. On the surface, this macro appears to correctly implement the absolute value function by returning the nonnegative value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> without regard to its sign. We use the conditional (<samp class="SANS_TheSansMonoCd_W5Regular_11">? :</samp>) operator (which I’ll cover in more detail in the next chapter) to test whether the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is negative. If so, <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is negated to <samp class="SANS_TheSansMonoCd_W5Regular_11">-(i)</samp>; otherwise, it evaluates to the unmodified value <samp class="SANS_TheSansMonoCd_W5Regular_11">(i)</samp>.</p>
<p class="TX">Because we’ve implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp> as a function-like macro, it can take an argument of any type. This macro can overflow when passed a signed integer argument of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> or a larger signed integer type. Of course, invoking this macro with an unsigned integer is pointless because unsigned integers can never be negative, so the macro’s output would just reproduce the argument. Let’s explore the behavior of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp> macro when passed a signed integer argument:</p>

<pre><code>signed int si = -25;
signed int abs_si = <b>ABS(si)</b>;
printf("%d\n", abs_si);  // prints 25</code></pre>
<p class="TX">In this example, we pass an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp> with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">-25</samp> as an argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp> macro. This invocation expands to the following:</p>

<pre><code>signed int si = -25;
signed int abs_si = <b>((si) &lt; 0 ? –(si) : (si))</b>;
printf("%d\n", abs_si);  // prints 25</code></pre>
<p class="TX"><span aria-label="55" epub:type="pagebreak" id="pg_55" role="doc-pagebreak"/>The macro correctly returned the absolute value of <samp class="SANS_TheSansMonoCd_W5Regular_11">25</samp>. So far, so good. The problem is that the negative of the two’s-complement most negative value for a given type cannot be represented in that type, so this use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp> macro results in signed integer overflow. Consequently, this implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp> is defective and can do anything, including unexpectedly returning a negative value:</p>

<pre><code>signed int si = <b>INT_MIN</b>;
signed int abs_si = ABS(si);  // undefined behavior
printf("%d\n", abs_si);</code></pre>
<p class="TX">What should <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS(INT_MIN)</samp> return to fix this behavior? Signed integer overflow is undefined behavior in C, allowing implementations to silently wrap around (the most common behavior), trap, or both (for example, some operations wrap around while other operations trap). <i>Traps</i> interrupt execution of the program so that no further operations are performed. Common architectures like x86 do a combination of both. Because the behavior is undefined, no universally correct solution to this problem exists, but we can at least test for the possibility of undefined behavior before it occurs and take appropriate action.</p>
<p class="TX">To make the absolute-value macro useful for a variety of types, we’ll add a type-dependent <samp class="SANS_TheSansMonoCd_W5Regular_11">flag</samp> argument to it. The flag represents the <samp class="SANS_TheSansMonoCd_W5Regular_11">*_MIN</samp> macro, which matches the type of the first argument. This value is returned in the following problematic case:</p>

<pre><code>#define ABSM(i, flag) ((i) &gt;= 0 ? (i) : ((i)==(flag) ? (flag) : -(i)))
signed int si = -25;  // try INT_MIN to trigger the undefined behavior
signed int abs_si = ABSM(si, INT_MIN);
if (abs_si == INT_MIN)
  overflow();  // handle special case
else
  printf("%d\n", abs_si);  // prints 25</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ABSM</samp> macro tests for the most negative value and simply returns it if found instead of triggering the undefined behavior by negating it.</p>
<p class="TX">On some systems, the C standard library implements the following <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>-only absolute-value function to avoid overflow when the function is passed <samp class="SANS_TheSansMonoCd_W5Regular_11">INT_MIN</samp> as an argument:</p>

<pre><code>int abs(int i) {
  return (i &gt;= 0) ? i : -(unsigned)i;  // avoids overflow
}</code></pre>
<p class="TX">In this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is converted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> and negated. (I’ll discuss conversions in more detail later in this chapter.)</p>
<p class="TX">Perhaps surprisingly, the unary minus (<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>) operator is defined for unsigned integer types. The resulting unsigned integer value is reduced modulo the number that is one greater than the largest value that the resulting type can represent. Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is implicitly converted back to <span aria-label="56" epub:type="pagebreak" id="pg_56" role="doc-pagebreak"/><samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp> as required by the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">-INT_MIN</samp> can’t be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>, the result is implementation defined, which is why this implementation is used only on <i>some</i> systems, and even on these systems, the <samp class="SANS_TheSansMonoCd_W5Regular_11">abs</samp> function returns an incorrect value.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ABSM</samp> function-like macros evaluate their parameters more than once, which can cause surprises when their arguments change the program state. These are called <i>side effects</i> (covered in detail in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>). Function calls, on the other hand, evaluate each argument only once.</p>
<p class="TX">Unsigned integers have well-defined wraparound behavior. Signed integer overflow, or the possibility of it, should always be considered a defect.</p>
</section>
</section>
<section aria-labelledby="sec11" epub:type="division">

<h3 class="H2"><span id="sec11"/><span id="h2-36"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bit-Precise Integer Types</samp></h3>
<p class="TNI">As noted in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, bit-precise integer types accept an operand specifying the width of the integer, so a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(32)</samp> is a signed 32-bit integer and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned _BitInt(32)</samp> is an unsigned 32-bit integer. Bit-precise integer types can have <i>any</i> width up to <samp class="SANS_TheSansMonoCd_W5Regular_11">BITINT_MAXWIDTH</samp>. Bit-precise integer types are useful in application domains, such as using 256-bit integer values in cryptographic symmetric ciphers like Advanced Encryption Standard (AES), calculating Secure Hash Algorithm (SHA)-256 hashes, representing a 24-bit color space, or describing the layout of network or serial protocols.</p>
<p class="TX">Bit-precise integer types are also very useful when programming field-programmable gate arrays (FPGAs). <i>FPGAs</i> are integrated circuits often sold off-the-shelf that provide customers with the ability to reconfigure the hardware to meet specific use-case requirements after the manufacturing process. In the case of FPGA hardware, using normal integer types for small value ranges where the full bit-width isn’t used is extremely wasteful and creates severe performance and space concerns. At the other extreme, FPGAs can support wide integers, essentially providing arbitrary precision, and existing FPGA applications make use of large integers—for example, up to 2,031 bits. Prior to C23, programmers must pick an integer data type of the next larger size and manually perform mask and shifting operations. However, this is error prone because integer widths are implementation defined.</p>
<p class="TX">A bit-precise signed integer type is designated as <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(</samp><i>N</i><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>, where <i>N</i> is an integer constant expression that specifies the width of the type. Because bit-precise integer types are specified including the sign bit, a signed <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(1)</samp> is invalid because it has one sign bit and no value bits. Unsigned bit-precise integer types do not include a sign bit, so the correct way to specify a 1-bit integer is <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned _BitInt(1)</samp>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> types follow the usual C standard integer conversion ranks, as detailed in the “<span class="Xref">Integer Conversion Rank</span>” section on <a href="#pg_65">page 65</a>. The usual arithmetic conversions also work the same, where the smaller ranked integer is converted to the larger. However, <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> types are excepted from integer promotions.</p>
<p class="TX">Overflow occurs when a value exceeds the allowable range of a given data type. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">(_BitInt(3))7</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(_BitInt(3))2</samp> overflows, and the result is undefined as with other signed integer types. To avoid the overflow, <span aria-label="57" epub:type="pagebreak" id="pg_57" role="doc-pagebreak"/>the operation type can be widened to 4 bits by casting one of the operands to <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(4)</samp>. Unsigned <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> wraparound is well-defined, and the value wraps around with two’s complement semantics.</p>
<p class="TX">To avoid overflow, you can cast one of the operands to a sufficient width to represent all possible values. For example, the following function casts one of the operands to 32 bits:</p>

<pre><code>_BitInt(32) multiply(_BitInt(8) a8, _BitInt(24) a24) {
  _BitInt(32) a32 = a8 * (_BitInt(32))a24;
  return a32;
}</code></pre>
<p class="Continued">This guarantees that the product can be represented.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">

<h3 class="H2"><span id="sec12"/><span id="h2-37"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integer Constants</samp></h3>
<p class="TNI"><i>Integer constants</i> (or <i>integer literals</i>) introduce integer values into a program. For example, you might use them in a declaration to initialize a counter to 0. C has four kinds of integer constants that use different number systems: decimal constants, binary constants, octal constants, and hexadecimal constants.</p>
<p class="TX"><i>Decimal constants</i> always begin with a nonzero digit. For example, the following code uses two decimal constants:</p>

<pre><code>unsigned int ui = 71;
int si;
si = -12;</code></pre>
<p class="TX">In this example code, we initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">ui</samp> to the decimal constant <samp class="SANS_TheSansMonoCd_W5Regular_11">71</samp> and assign <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp> the decimal constant value <samp class="SANS_TheSansMonoCd_W5Regular_11">-12</samp>. (Formally, <samp class="SANS_TheSansMonoCd_W5Regular_11">-12</samp> is the negation operator [<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>] followed by an integer constant [<samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>]. However, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">-12</samp> is usable as an integer constant expression and therefore effectively indistinguishable from an integer constant whose value is –12.) Use decimal constants when introducing regular integer values into your code.</p>
<p class="TX">If a constant starts with a 0, optionally followed by digits 0 through 7, it is an <i>octal constant</i>. Here’s an example:</p>

<pre><code>int agent = 007;
int permissions = 0777;</code></pre>
<p class="TX">In this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">007</samp> octal equals <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp> decimal, and the octal constant <samp class="SANS_TheSansMonoCd_W5Regular_11">0777</samp> equals the decimal value 511. Octal constants are convenient when dealing with 3-bit fields such as POSIX file permissions.</p>
<p class="TX">You can also create a <i>hexadecimal constant</i> by prefixing a sequence of decimal digits and the letters a (or A) through f (or F) with <samp class="SANS_TheSansMonoCd_W5Regular_11">0x</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">0X</samp>. For example:</p>

<pre><code>int burger = 0xDEADBEEF;</code></pre>
<p class="TX"><span aria-label="58" epub:type="pagebreak" id="pg_58" role="doc-pagebreak"/>Use hexadecimal constants when the constant you are introducing is meant to represent a bit pattern more than a particular value—for example, when representing an address. Idiomatically, most hexadecimal constants are written like <samp class="SANS_TheSansMonoCd_W5Regular_11">0xDEADBEEF</samp> because it resembles a typical hex dump. It’s probably a good idea for you to write all your hexadecimal constants like this.</p>
<p class="TX">Starting with C23, you can also specify a binary constant by appending a sequence of 1 and 0 decimal digits to <samp class="SANS_TheSansMonoCd_W5Regular_11">0b</samp>. For example:</p>

<pre><code>int mask = 0b110011;</code></pre>
<p class="TX">Binary constants can be more readable than octal or hexadecimal constants, especially when the value is used as a bitmask.</p>
<p class="TX">You can also append a suffix to your constant to specify its type. Without a suffix, a decimal constant is given the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type if it can be represented as a value in that type. If it can’t be represented as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, it will be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> suffix specifies the <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> type, and <samp class="SANS_TheSansMonoCd_W5Regular_11">LL</samp> specifies the <samp class="SANS_TheSansMonoCd_W5Regular_11">long long</samp> type. You can combine these suffixes with <samp class="SANS_TheSansMonoCd_W5Regular_11">U</samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ULL</samp> suffix specifies the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long long</samp> type. Here are some examples:</p>

<pre><code>unsigned int ui = 71U;
signed long int sli = 9223372036854775807L;
unsigned long long int ui = 18446744073709551615ULL;</code></pre>
<p class="TX">These suffixes can be either uppercase or lowercase. Uppercase is generally preferred for readability, as a lowercase letter l might be mistaken for the number 1.</p>
<p class="TX"><i>Bit-precise constants</i> were added in C23 to specify <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> literals. The suffixes <samp class="SANS_TheSansMonoCd_W5Regular_11">wb</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">uwb</samp> designate a constant of type <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned _BitInt(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>, respectively. The width <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp> is the smallest <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp> greater than 1 that can accommodate the value and the sign bit (when present).</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">wb</samp> suffix results in a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> that includes space for the sign bit even if the value of the constant is positive or was specified in binary, octal, or hexadecimal notation:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">-3wb</samp> Yields a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp> that is then negated; two value bits, one sign bit</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">-0x3wb</samp> Yields a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp> that is then negated; two value bits, one sign bit</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">3wb</samp> Yields a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp>; two value bits, one sign bit</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">3ub</samp> Yields an unsigned <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(2)</samp></p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">-3uwb </samp>Yields an unsigned <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(2)</samp> that is then negated, resulting in wraparound</p>
<p class="TX">If we don’t use a suffix and the integer constant isn’t of the required type, it may be implicitly converted. (We’ll discuss implicit conversion in the “<span class="Xref">Arithmetic Conversion</span>” section on <span class="Xref"><a href="#pg_64">page 64</a></span>.) This may result in a surprising conversion or a compiler diagnostic, so it’s best to specify an integer <span aria-label="59" epub:type="pagebreak" id="pg_59" role="doc-pagebreak"/>constant of an appropriate type. Section 6.4.4.1 of the C standard contains more information on integer constants (ISO/IEC 2024).</p>
</section>
</section>
<section aria-labelledby="sec13" epub:type="division">

<h2 class="H1"><span id="sec13"/><span id="h1-28"/><samp class="SANS_Futura_Std_Bold_B_11">Floating-Point Representation</samp></h2>
<p class="TNI"><i>Floating-point representation</i> is the most common digital representation of real numbers. Floating-point representation is a technique that uses scientific notation to represent numbers with a mantissa and an exponent for a given base. For example, the decimal number <samp class="SANS_TheSansMonoCd_W5Regular_11">123.456</samp> can be represented as 1.23456 × 10<sup>2</sup>, while the binary number <samp class="SANS_TheSansMonoCd_W5Regular_11">0b10100.11</samp> can be represented as 1.010011 × 2<sup>4</sup>.</p>
<p class="TX">The C standard defines a general floating-point model for floating-point numbers. However, it does not require all implementations to use the same representation schemes or formats, and it allows implementations to provide values that are not in the C model. To keep things simple, we’ll assume conformance to Annex F. Annex F includes the most common floating-point formats specified in IEC 60559. You can test the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_IEC_559__</samp> macro, or of the <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_IEC_60559_BFP__</samp> macro in newer compilers, to determine whether the implementation conforms to Annex F.</p>
<p class="TX">This section explains floating types, arithmetic, values, and constants, so you will know how and when to use them to emulate math on real numbers and when to avoid them.</p>
<section aria-labelledby="sec14" epub:type="division">

<h3 class="H2"><span id="sec14"/><span id="h2-38"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating Types and Encodings</samp></h3>
<p class="TNI">C has three standard floating types: <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> type can be used for floating-point data and results that can be adequately represented with the precision and exponent range of the type. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> arithmetic to compute <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> results from <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> data is particularly vulnerable to roundoff error. The common IEC 60559 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> type encodes values using 1 sign bit, 8 exponent bits, and 23 significand bits. The value has a 24-bit significand, which is encoded in 23 bits (with help from the exponent field to determine the implicit leading bit).</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type provides greater precision and exponent range but requires additional storage. Arithmetic with the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type greatly increases the reliability of computation of <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> results from <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> data. The IEC 60559 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type encodes values using 1 sign bit, 11 exponent bits, and 52 significand bits. The value has a 53-bit significand, which is encoded in 52 bits (with help from the exponent field to determine the implicit leading bit).</p>
<p class="TX">These encodings for <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> are illustrated in <a href="chapter3.xhtml#fig3-2">Figure 3-2</a>.<span aria-label="60" epub:type="pagebreak" id="pg_60" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="" class="img1" id="fig3-2" src="../images/f03002.jpg"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">float</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">double</samp> types</samp></p></figcaption>
</figure>
<p class="TX">Let’s illustrate with an example encoding in type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>:</p>
<div class="spc"/>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH1" scope="col"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp></p></th>
<th class="TCH1" scope="col"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">1000 0001</samp></p></th>
<th class="TCH1" scope="col"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">011 0000 0000 0000 0000 0000</samp></p></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p class="TX">The sign bit is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, the exponent field is <samp class="SANS_TheSansMonoCd_W5Regular_11">1000 0001</samp>, and the significand field is <samp class="SANS_TheSansMonoCd_W5Regular_11">011 0000 0000 0000 0000 0000</samp>. The sign bit encodes the sign of the number, where 0 is used for a positive sign and 1 is used for a negative sign. Consequently, the number represented in this example has a negative sign.</p>
<p class="TX">Because the exponent field is neither all 0s nor all 1s, the bits in the significand field are interpreted as bits to the right of a binary point where an implicit 1 bit is to the left of the binary point. In this example, the significand of the encoded number is <samp class="SANS_TheSansMonoCd_W5Regular_11">1.011 0000 0000 0000 0000 0000</samp> = 1 + 2<sup>–2</sup> + 2<sup>–3</sup> = 1.375.</p>
<p class="TX">Putting this all together produces the following real number: –2<sup>2</sup>(1 + 2<sup>–2</sup> + 2<sup>–3</sup>) = –5.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">

<h3 class="H2"><span id="sec15"/><span id="h2-39"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">C Floating-Point Model</samp></h3>
<p class="TNI">The following formula represents a number in the <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> type using the C model:</p>
<figure class="IMG"><img alt="" class="img1" src="../images/eq03001.jpg"/>
</figure>
<p class="TX">The <i>s</i> is the sign, which may be 1 or –1. The <i>e</i> is the exponent, and <i>f</i><sub>1</sub> through <i>f</i><sub>24</sub> are the significand bits. Note that the exponent in the C model representation is 1 greater than the exponent we determined from the encoding because the C model places the (explicit) leading bit to the right of the binary point, while the encoding has the (implicit) leading bit to the left of the binary point.</p>
<p class="TX"><span aria-label="61" epub:type="pagebreak" id="pg_61" role="doc-pagebreak"/>The following formula represents a number in the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type:</p>
<figure class="IMG"><img alt="" class="img1" src="../images/eq03002.jpg"/>
</figure>
<p class="TX">In general, the C model defines floating-point numbers in each floating type by the parameters <i>b</i>, <i>p</i>, <i>e</i><sub>min</sub>, and <i>e</i><sub>max</sub>. The parameter <i>b</i> is the radix (the base for the exponent and the significand digits). The radix <i>b</i> for all the standard floating types is represented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_RADIX</samp> macro defined in <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;float.h&gt;</samp>. For Annex F, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_RADIX</samp> is 2. The parameter <i>p</i> is the number of base-<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">b</samp> digits in the floating-point significand. The <i>e</i><sub>min</sub> parameter is the minimum negative integer such that <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">b</samp> raised to one less than that power is a normalized floating-point number. Finally, the <i>e</i><sub>max</sub> parameter is the maximum integer such that <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">b</samp> raised to one less than that power is a representable finite floating-point number, provided that representable finite floating-point number is normalized (as it will be for all IEC 60559 types). <a href="chapter3.xhtml#tab3-5">Table 3-5</a> shows the actual macro names.</p>
<p class="TT" id="tab3-5"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-5:</samp> <samp class="SANS_Futura_Std_Book_11">Standard Type Characterization Macros in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;float.h&gt;</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Parameter</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">long double</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">p</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_MANT_DIG</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">DBL_MANT_DIG</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">LDBL_MANT_DIG</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">e</samp><samp class="SANS_Futura_Std_Book_SUB_11">min</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_MIN_EXP</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">DBL_MIN_EXP</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">LDBL_MIN_EXP</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">e</samp><samp class="SANS_Futura_Std_Book_SUB_11">max</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_MAX_EXP</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">DBL_MAX_EXP</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">LDBL_MAX_EXP</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">Each implementation assigns the <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp> type one of the following formats:</p>
<ul class="ul">
<li class="ListBullet">IEC 60559 quadruple (or binary128) format (IEC 60559 added binary128 to its basic formats in the 2011 revision)</li>
<li class="ListBullet">IEC 60559 binary64-extended format</li>
<li class="ListBullet">A non-IEC 60559 extended format</li>
<li class="ListBullet">IEC 60559 double (or binary64) format</li>
</ul>
<p class="TX">Recommended practice for compiler implementers is to match the <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp> type with the IEC 60559 binary128 format or an IEC 60559 binary64-extended format. IEC 60559 binary64-extended formats include the common 80-bit IEC 60559 format.</p>
<p class="TX">Arithmetic with the <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp> type should be considered for computations whose reliability might benefit from the maximum range and precision that the implementation provides for a standard floating type. However, the extra range and precision in the <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp> type (compared with <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>) varies considerably among implementations, as does the performance (speed) of <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp> arithmetic. Consequently, the <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp> type is unsuitable for data interchange or reproducible results (across implementations) or for portable high performance.</p>
<p class="TX"><span aria-label="62" epub:type="pagebreak" id="pg_62" role="doc-pagebreak"/>Larger types have greater precision but require more storage. Any value that can be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> can also be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and any value that can be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>. The header <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;float.h&gt;</samp> defines several macros that define the characteristics of floating types.</p>
<p class="TX">Annex H of C23 specifies additional floating types that have the arithmetic interchange and extended floating-point formats specified in IEC 60559. These include a sequence of types with unbounded precision and range and a 16-bit type. Future versions of C may include other floating types.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">

<h3 class="H2"><span id="sec16"/><span id="h2-40"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating-Point Arithmetic</samp></h3>
<p class="TNI">Floating-point arithmetic is similar to, and used to model, the arithmetic of real numbers. However, there are differences to consider. Unlike in real number arithmetic, floating-point numbers are bounded in magnitude and have finite precision. Addition and multiplication operations are <i>not</i> associative; the distributive property <i>doesn’t</i> hold, nor do many other properties of real numbers.</p>
<p class="TX">Floating types cannot represent all real numbers exactly, even when they can be represented in a small number of decimal digits. For example, common decimal constants such as 0.1 can’t be represented exactly as binary floating-point numbers. Floating types may lack the necessary precision for various applications such as loop counters or performing financial calculations. See CERT C rule FLP30-C (do not use floating-point variables as loop counters) for more information.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">

<h3 class="H2"><span id="sec17"/><span id="h2-41"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating-Point Values</samp></h3>
<p class="TNI">A floating-point representation whose significand is 0 (all <i>f</i><sub>k</sub> = 0) represents a floating-point zero. Zeros are signed according to the sign (<i>s</i>), and there are two floating-point zero values: +0 and –0. They are equal but behave differently in a few operations. A notable example is <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0/0.0</samp> yields positive infinity and <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0/(-0.0)</samp> yields negative infinity.</p>
<p class="TX">There are no leading zeros in the significand of a <i>normalized</i> floating-point number (<i>f</i><sub>1</sub> = 1); leading zeros are removed by adjusting the exponent. These are <i>normal</i> numbers, and they use the full precision of the significand. Therefore, <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> has 24 significant bits of precision, <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> has 53 significant bits of precision, and <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp> has 113 significant bits of precision (assuming the IEC 60559 binary128 format).</p>
<p class="TX"><i>Subnormal</i> numbers are positive and negative numbers (but not 0) of very small magnitude whose normalized representation would result in an exponent that is less than the smallest exponent for the type. Their representations have exponent <i>e</i> = <i>e</i><sub>min</sub> and leading significand bit <i>f</i><sub>1</sub> = 0. <a href="chapter3.xhtml#fig3-3">Figure 3-3</a> is a number line showing the range of subnormal values around 0. The precision of subnormal numbers is less than that of normalized numbers.<span aria-label="63" epub:type="pagebreak" id="pg_63" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="" class="img7" id="fig3-3" src="../images/f03003.jpg"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: The domain of subnormal numbers</samp></p></figcaption>
</figure>
<p class="TX">Floating types can also represent values that are not floating-point numbers, such as negative and positive infinity and not-a-number (NaN) values. <i>NaNs</i> are values that do not represent a number.</p>
<p class="TX">Having infinity available as a specific value allows operations to continue past overflow and divide-by-zero situations and produce a useful result without requiring special treatment. Dividing any nonzero number by (positive or negative) zero yields an infinity. Operations with infinite values are well-defined in the IEEE floating-point standard.</p>
<p class="TX">A <i>quiet NaN</i> propagates through almost every arithmetic operation without raising a floating-point exception and is typically tested after a selected sequence of operations. An arithmetic operation with a <i>signaling NaN</i> operand generally raises a floating-point exception immediately. Floating-point exceptions are an advanced topic not covered here. For more information, refer to Annex F of the C standard.</p>
<p class="TX">In C23, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NAN</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">INFINITY</samp> macros in <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;float.h&gt;</samp> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">nan</samp> functions in <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;math.h&gt;</samp> provide designations for IEC 60559 quiet NaNs and infinities. The <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_SNAN</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">DBL_SNAN</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">LDBL_SNAN</samp> macros in <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;float.h&gt;</samp> provide designations for IEC 60559 signaling NaNs. C Annex F doesn’t require full support for signaling NaNs.</p>
<p class="TX">You can identify the class of a floating-point value using the <samp class="SANS_TheSansMonoCd_W5Regular_11">fpclassify</samp> function-like macro, which classifies its argument value as NaN, infinite, normal, subnormal, or zero:</p>

<pre><code>#include &lt;math.h&gt;
int fpclassify(real-floating x);</code></pre>
<p class="TX">In <a href="chapter3.xhtml#Lis3-2">Listing 3-2</a>, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">fpclassify</samp> macro in the <samp class="SANS_TheSansMonoCd_W5Regular_11">show_classification</samp> function to determine whether a floating-point value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> is a normal value, subnormal value, zero, infinity, or NaN.</p>
<span id="Lis3-2"/>
<pre><code>const char *show_classification(double x) {
  switch(fpclassify(x)) {
    case FP_INFINITE:  return "Inf";
    case FP_NAN:       return "NaN";
    case FP_NORMAL:    return "normal";
    case FP_SUBNORMAL: return "subnormal";
    case FP_ZERO:      return "zero";
    default:           return "unknown";
  }</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-2: The</samp> <samp class="I">fpclassify</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">macro</samp></p>
<p class="TX"><span aria-label="64" epub:type="pagebreak" id="pg_64" role="doc-pagebreak"/>The function argument <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> (a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> in this example) is passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">fpclassify</samp> macro, which switches on the return value. The <samp class="SANS_TheSansMonoCd_W5Regular_11">show_classification</samp> function returns a string corresponding to the class of value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.</p>
<p class="TX">There are also a variety of other classification macros including <samp class="SANS_TheSansMonoCd_W5Regular_11">isinf</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">isnan</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">isnormal</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">issubnormal</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">iszero</samp>, and so forth that may be more useful than the <samp class="SANS_TheSansMonoCd_W5Regular_11">fpclassify</samp> macro in many applications.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">

<h3 class="H2"><span id="sec18"/><span id="h2-42"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating Constants</samp></h3>
<p class="TNI">A <i>floating constant</i> is a decimal or hexadecimal number that represents a real number. You should use floating-point constants to represent floating-point values that cannot be changed. The following are some examples of floating-point constants:</p>

<pre><code>15.75
1.575E1   /* 15.75 */
1575e-2   /* 15.75 */
25E-4     /* 0.0025 */</code></pre>
<p class="TX">The following illustrates constants defined two ways: with a decimal floating constant and with a hexadecimal floating constant. The hexadecimal constants have values that can be represented exactly in their (binary) type. The decimal constants require conversion to binary and might be slightly affected by rounding direction modes and evaluation methods. (Rounding modes and evaluation methods are not covered in this book.) Hexadecimal constants should be used in such cases if you want a specific (to the last bit) value.</p>

<pre><code>DBL_EPSILON 2.2204460492503131E-16 // decimal constant
DBL_EPSILON 0X1P-52                // hex constant
DBL_MIN 2.2250738585072014E-308    // decimal constant
DBL_MIN 0X1P-1022                  // hex constant
DBL_MAX 1.7976931348623157E+308    // decimal constant
DBL_MAX 0X1.fffffffffffffP1023     // hex constant</code></pre>
<p class="TX">All floating-point constants have a type. The type is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> if unsuffixed, <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> if suffixed by the letter <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">F</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp> if suffixed by the letter <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp>, as shown here:</p>

<pre><code>10.0F  /* type float */
10.0   /* type double */
10.0L  /* type long double */</code></pre>
<p class="TX">The decimal point is mandatory in these examples, but the trailing zero is not.</p>
</section>
</section>
<section aria-labelledby="sec19" epub:type="division">

<h2 class="H1"><span id="sec19"/><span id="h1-29"/><samp class="SANS_Futura_Std_Bold_B_11">Arithmetic Conversion</samp></h2>
<p class="TNI">Frequently, a value represented in one type (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>) must be represented in a different type (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>). This might occur when <span aria-label="65" epub:type="pagebreak" id="pg_65" role="doc-pagebreak"/>you have an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> and need to pass it as an argument to a function that accepts an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. When such conversions are necessary, you should always ensure that the value is adequately representable in the new type. I’ll discuss this further in “<span class="Xref">Safe Conversions</span>” on <a href="chapter3.xhtml#pg_70">page 70</a>.</p>
<p class="TX">Values can be implicitly or explicitly converted from one arithmetic type to another. You can use the <i>cast</i> operator to perform <i>explicit</i> conversions. <a href="chapter3.xhtml#Lis3-3">Listing 3-3</a> shows two examples of casts.</p>
<span id="Lis3-3"/>
<pre><code>int si = 5;
short ss = 8;
long sl = (long)si;
unsigned short us = (unsigned short)(ss + sl);</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-3: Cast operators</samp></p>
<p class="TX">To perform a cast, place a type name in parentheses just before the expression. The cast converts the expression to the unqualified version of the type name in parentheses. Here, we cast the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp> to the type <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp> is of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, this cast is guaranteed to be safe because the value can always be represented in a larger integer type of the same signedness.</p>
<p class="TX">The second cast in this example casts the result of the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(ss</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">sl)</samp> to type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned short</samp>. Because the value is converted to an unsigned type (<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned short</samp>) with less precision, the result of the conversion might not be equal to the original value. (Some compilers might warn about this; others won’t.) In this example, the result of the expression (13) can be correctly represented in the resulting type.</p>
<p class="TX"><i>Implicit conversion</i>, also known as <i>coercion</i>, occurs automatically in expressions as required. Values are coerced, for example, when operations are performed on mixed types. In <a href="chapter3.xhtml#Lis3-3">Listing 3-3</a>, implicit conversions are used to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">ss</samp> to the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">sl</samp> so that the addition <samp class="SANS_TheSansMonoCd_W5Regular_11">ss</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">sl</samp> can be performed on a common type. The rules concerning which values are implicitly converted to which types are somewhat complicated and involve three concepts: integer conversion rank, integer promotions, and the usual arithmetic conversions.</p>
<section aria-labelledby="sec20" epub:type="division">

<h3 class="H2"><span id="sec20"/><span id="h2-43"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integer Conversion Rank</samp></h3>
<p class="TNI"><i>Integer conversion rank</i> is a standard rank ordering of integer types used to determine a common type for computations. Every integer type has an integer conversion rank that determines when and how conversions are implicitly performed.</p>
<p class="TX">The C standard, section 6.3.1.1, paragraph 1 (ISO/IEC 9899:2024), states that every integer type has an integer conversion rank where the following applies:</p>
<ul class="ul">
<li class="ListBullet">No two signed integer types have the same rank, even if they have the same representation.</li>
<li class="ListBullet">The rank of a signed integer type is greater than the rank of any signed integer type with less precision.</li>
<li class="ListBullet"><span aria-label="66" epub:type="pagebreak" id="pg_66" role="doc-pagebreak"/>The rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp> is greater than the rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp>, which is greater than the rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, which is greater than the rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">short int</samp>, which is greater than the rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>.</li>
<li class="ListBullet">The rank of a bit-precise signed integer type is greater than the rank of any standard integer type with less width or any bit-precise integer type with less width.</li>
<li class="ListBullet">The rank of any unsigned integer type equals the rank of the corresponding signed integer type, if any.</li>
<li class="ListBullet">The rank of any standard integer type is greater than the rank of any extended integer type with the same width or bit-precise integer type with the same width.</li>
<li class="ListBullet">The rank of any bit-precise integer type relative to an extended integer type of the same width is implementation defined.</li>
<li class="ListBullet">The rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> equals the rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>.</li>
<li class="ListBullet">The rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> is less than the rank of all other standard integer types.</li>
<li class="ListBullet">The rank of any enumerated type equals the rank of the compatible integer type. Each enumerated type is compatible with <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, a signed integer type, or an unsigned integer type.</li>
</ul>
<p class="TX">The rank of any extended signed integer type relative to another extended signed integer type with the same precision is implementation defined but still subject to the other rules for determining the integer conversion rank.</p>
</section>
<section aria-labelledby="sec21" epub:type="division">

<h3 class="H2"><span id="sec21"/><span id="h2-44"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integer Promotions</samp></h3>
<p class="TNI">A <i>small type</i> is an integer with a lower conversion rank than <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>. <i>Integer promotion</i> is the process of converting values of small types to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>. Integer promotions allow you to use an expression of a small type in any expression where an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> may be used. For example, you could use a lower-ranked integer type—typically, <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">short</samp>—on the right-hand side of an assignment or as an argument to a function.</p>
<p class="TX">Integer promotions serve two primary purposes. First, they encourage operations to be performed in a natural size (<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>) for the architecture, which improves performance. Second, they help avoid arithmetic errors from the overflow of intermediate values, for example:</p>

<pre><code>signed char cresult, c1, c2, c3;
c1 = 100; c2 = 3; c3 = 4;
cresult = c1 * c2 / c3;</code></pre>
<p class="TX">Without integer promotion, <samp class="SANS_TheSansMonoCd_W5Regular_11">c1 * c2</samp> would result in an overflow of the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> type on platforms where <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> is represented by an 8-bit two’s-complement value. This is because 300 is outside the range of values (–128 to 127) that can be represented by an object of this type. However, because of integer promotion, <samp class="SANS_TheSansMonoCd_W5Regular_11">c1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">c2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">c3</samp> are implicitly converted to objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>, and the multiplication and division operations <span aria-label="67" epub:type="pagebreak" id="pg_67" role="doc-pagebreak"/>take place in this size. There is no possibility of overflow while performing these operations because the resulting values can be represented by this wider type. In this specific example, the result of the entire expression is 75, which is within range of the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> type, so the value is preserved when stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">cresult</samp>.</p>
<p class="TX">Prior to the first C standard, compilers used one of two approaches for integer promotions: the unsigned-preserving approach or the value-preserving approach. In the <i>unsigned-preserving approach</i>, the compiler promotes small, unsigned types to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>. In the <i>value-preserving approach</i>, if all values of the original type can be represented as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, the value of the original small type is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Otherwise, it’s converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>. When developing the original version of the standard (C89), the C standards committee decided on value-preserving rules, because they produce incorrect results less often than the unsigned-preserving approach. If necessary, you can override this behavior by using explicit type casts, as in <a href="chapter3.xhtml#Lis3-3">Listing 3-3</a>.</p>
<p class="TX">The result of promoting small unsigned types depends on the precision of the integer types, which is implementation defined. For example, the x86-32 and x86-64 architectures have an 8-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type, a 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">short</samp> type, and a 32-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type. For implementations that target one of these architectures, values of both <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned short</samp> are promoted to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>, because all the values that can be represented in these smaller types can be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>. However, 16-bit architectures, such as Intel 8086/8088 and the IBM Series/1, have an 8-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type, a 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">short</samp> type, and a 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type. For implementations that target these architectures, values of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> are promoted to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>, while values of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned short</samp> are promoted to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>. This is because all the values that can be represented as an 8-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> type can be represented as a 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>, but some values that can be represented as a 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned short</samp> cannot be represented as a 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> types are exempt from integer promotions. Integer promotions might inflate the size of required hardware on some platforms, so <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> types aren’t subject to the integer promotion rules. For example, in a binary expression involving a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(12)</samp> and an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned _BitInt(3)</samp>, the usual arithmetic conversions would not promote either operand to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> before determining the common type. Because one type is signed and one is unsigned and because the signed type has greater rank than the unsigned type (due to the bit-widths of the types), the unsigned <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp> will be converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(12)</samp> as the common type.</p>
</section>
<section aria-labelledby="sec22" epub:type="division">

<h3 class="H2"><span id="sec22"/><span id="h2-45"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Usual Arithmetic Conversions</samp></h3>
<p class="TNI">The <i>usual arithmetic conversions</i> are rules for yielding a <i>common real type</i> for the operands and result of an arithmetic operation. Ignoring complex or imaginary types, each operand is converted to the common real type. Many operators that accept integer operands (including <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp> , <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">? :</samp>) perform conversions using the usual arithmetic conversions. The usual arithmetic conversions are applied to the promoted operands.</p>
<p class="TX"><span aria-label="68" epub:type="pagebreak" id="pg_68" role="doc-pagebreak"/>The usual arithmetic conversions first check whether one of the operands in the balancing conversion is a floating type. If so, it applies the following rules:</p>
<div class="spc">
<p class="ListNumber">  1.  If one type of either operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>, the other operand is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>.</p>
<p class="ListNumber">  2.  Otherwise, if one type of either operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, the other operand is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.</p>
<p class="ListNumber">  3.  Otherwise, if the type of either operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>, the other operand is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>.</p>
<p class="ListNumber">  4.  Otherwise, the integer promotions are performed on both operands.</p>
</div>
<p class="TX">If one operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and the other operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, for example, the operand of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is converted to an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. If one operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> and the other operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, the operand of type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> is converted to an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. Particularly notable is the case of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>, which converts the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> operand to <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>, although <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> typically has greater precision than <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>.</p>
<p class="TX">If neither operand is a floating type, the following usual arithmetic conversion rules are applied to the promoted integer operands:</p>
<div class="spc">
<p class="ListNumber">  1.  If both operands have the same type, no further conversion is needed.</p>
<p class="ListNumber">  2.  Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand with the type that has the lesser integer conversion rank is converted to the type of the operand with greater rank. If one operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and the other operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, for example, the operand of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is converted to an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>.</p>
<p class="ListNumber">  3.  Otherwise, if the operand that has the unsigned integer type has a rank greater than or equal to the rank of the other operand’s type, then the operand with the signed integer type is converted to the type of the operand with the unsigned integer type. For example, if one operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp> and the other operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, the operand of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp> is converted to an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>.</p>
<p class="ListNumber">  4.  Otherwise, if the type of the operand with the signed integer type can represent all the values of the type of the operand with unsigned integer type, then the operand with unsigned integer type is converted to the type of the operand with signed integer type. For example, if one operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> and the other operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long long</samp> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long long</samp> type can represent all the values of the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> type, then the operand of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> is converted to an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long long</samp>. This is the case for implementations with a 32-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type and a 64-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">long long</samp> type, such as x86-32 and x86-64.</p>
<p class="ListNumber">  5.  Otherwise, both operands are converted to the unsigned integer type corresponding to the type of the operand with signed integer type.</p>
</div>
<p class="TX"><span aria-label="69" epub:type="pagebreak" id="pg_69" role="doc-pagebreak"/>One consequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> being exempt from the integer promotion rules is that a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> operand of a binary operator is not always promoted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> as part of the usual arithmetic conversions. Instead, a lower-ranked operand is converted to the higher-rank operand type, and the result of the operation is the higher-ranked type. For example, given the following declarations</p>

<pre><code>_BitInt(2) a2 = 1;
_BitInt(3) a3 = 2;
_BitInt(33) a33 = 1;
signed char c = 3;</code></pre>
<p class="Continued">the <samp class="SANS_TheSansMonoCd_W5Regular_11">a2</samp> operand in the following expression is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp> as part of the multiplication, and the resulting type is <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp>:</p>

<pre><code>a2 * a3;</code></pre>
<p class="TX">As part of the following multiplication, <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is promoted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">a2</samp> is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, and the resulting type is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:</p>

<pre><code>a2 * c;</code></pre>
<p class="TX">Finally, as part of the following multiplication, <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is promoted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Then, provided the width of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is not greater than 32, it is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(33)</samp> and the resulting type is <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(33)</samp>:</p>

<pre><code>a33 * c;</code></pre>
<p class="TX">These conversion rules, which evolved as new types were added, take some getting used to. The irregularities in these patterns resulted from varying architectural properties (notably, the PDP-11’s automatic promotion of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>) coupled with a desire to avoid changing the behavior of existing programs and (subject to those constraints) a desire for uniformity. When in doubt, use type casts to explicitly force the conversions that you intend. That said, try not to overuse explicit conversions because casts can disable important diagnostics.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">

<h3 class="H2"><span id="sec23"/><span id="h2-46"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example of Implicit Conversion</samp></h3>
<p class="TNI">The following example illustrates the use of integer conversion rank, integer promotions, and the usual arithmetic conversions. This code compares the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> value <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> for equality with the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> value <samp class="SANS_TheSansMonoCd_W5Regular_11">ui</samp>. We’ll assume this code is being compiled for the x86 architecture:</p>

<pre><code>unsigned int ui = UINT_MAX;
signed char c = -1;
if (c == ui) {
  printf("%d equals %u\n", c, ui);
}</code></pre>
<p class="TX"><span aria-label="70" epub:type="pagebreak" id="pg_70" role="doc-pagebreak"/>The variable <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> has a lower integer conversion rank than <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is promoted to an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp> when used in the comparison. This is accomplished by sign-extending the original value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFFFFFFFF</samp>. <i>Sign extension</i> is used to convert a signed value to a larger-width object. The sign bit is copied into each bit position of the expanded object. This operation preserves the sign and magnitude when converting a value from a smaller to a larger signed integer type.</p>
<p class="TX">Next, the usual arithmetic conversions are applied. Because the operands to the equal (<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>) operator have different signedness and equal rank, the operand with the signed integer type is converted to the type of the operand with the unsigned integer type. The comparison is then performed as a 32-bit unsigned operation. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp> has the same values as the promoted and converted value of <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>, the comparison yields <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, and the code snippet prints the following:</p>

<pre><code>-1 equals 4294967295</code></pre>
<p class="TX">This result should no longer be surprising.</p>
</section>
<section aria-labelledby="sec24" epub:type="division">

<h3 class="H2"><span id="sec24"/><span id="h2-47"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Safe Conversions</samp></h3>
<p class="TNI">Both implicit and explicit conversions (the result of a cast operation) can produce values that can’t be represented in the resulting type. It’s preferable to perform operations on objects of the same type to avoid conversions. However, conversions are unavoidable when a function returns or accepts an object of a different type. In those cases, we must ensure that the conversion is performed correctly.</p>
<section aria-labelledby="sec25" epub:type="division">

<h4 class="H3"><span id="sec25"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Integer Conversions</samp></h4>
<p class="TNI"><i>Integer conversions</i> occur when a value of an integer type is converted to a different integer type. Conversions to larger types of the same signedness are always safe and don’t need to be checked. Most other conversions can produce unexpected results if the resulting value cannot be represented in the resulting type. To perform these conversions correctly, you must test that the value stored in the original integer type is within the range of values that can be represented in the resulting integer type. As an example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">do_stuff</samp> function shown in <a href="chapter3.xhtml#Lis3-4">Listing 3-4</a> accepts a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp> argument <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> that needs to be used in a context in which only a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> is appropriate.</p>
<span id="Lis3-4"/>
<pre><code>#include &lt;errno.h&gt;
#include &lt;limits.h&gt;

errno_t do_stuff(signed long value) {
  if (<b>(value &lt; SCHAR_MIN) || (value &gt; SCHAR_MAX)</b>) {
    return ERANGE;
  }
<span aria-label="71" epub:type="pagebreak" id="pg_71" role="doc-pagebreak"/>  signed char sc = (signed char)value; // cast quiets warning
<var>  </var>// <var>--snip--</var>
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-4: Safe conversion</samp></p>
<p class="TX">To perform this conversion safely, the function checks that <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> can be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> in the range [<samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MIN</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MAX</samp>] and returns an error if it cannot.</p>
<p class="TX">The specific range tests vary based on the conversion. See CERT C rule INT31-C (“Ensure that integer conversions do not result in lost or misinterpreted data”) for more information.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">

<h4 class="H3"><span id="sec26"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Integer-Type to Floating-Type Conversions</samp></h4>
<p class="TNI">Floating types that conform to Annex F support positive and negative infinities, so all integer values are in range. The usual IEC 60559 conversion rules apply. See CERT C rule FLP36-C (“Preserve precision when converting integral values to floating type”) for more information.</p>
</section>
<section aria-labelledby="sec27" epub:type="division">

<h4 class="H3"><span id="sec27"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Floating-Type to Integer-Type Conversions</samp></h4>
<p class="TNI">When a finite value of a floating type is converted to an integer type (other than <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>), the fractional part is discarded. If the value of the integral part cannot be represented by the integer type, Annex F specifies that the “invalid” floating-point exception is raised, and the result is unspecified.</p>
</section>
<section aria-labelledby="sec28" epub:type="division">

<h4 class="H3"><span id="sec28"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Floating-Type Demotions</samp></h4>
<p class="TNI">Converting a floating-point value to a larger floating type is always safe. Demoting a floating-point value (that is, converting to a smaller floating type) is like converting an integer value to a floating type. Floating types that conform to Annex F support positive and negative infinities. Demoting values of floating types for these implementations will always succeed because any out-of-range values are converted to infinities. See CERT C rule FLP34-C (“Ensure that floating-point conversions are within range of the new type”) for more information on floating-point conversions.</p>
<aside aria-label="box-5" class="box1">
<p class="BoxTitle" id="box-5"><samp class="SANS_Dogma_OT_Bold_B_11">EXERCISES</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Book_11">1.  Write a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> <samp class="SANS_Futura_Std_Book_11">function that calls the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">show_classification</samp> <samp class="SANS_Futura_Std_Book_11">function from <a href="chapter3.xhtml#Lis3-2">Listing 3-2</a> with different values of type</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp><samp class="SANS_Futura_Std_Book_11">. Try to exercise all the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> <samp class="SANS_Futura_Std_Book_11">cases.</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Book_11">2.  Find an example where a conversion from</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> <samp class="SANS_Futura_Std_Book_11">to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> <samp class="SANS_Futura_Std_Book_11">results in a loss of precision.</samp></p>
</aside>
</section>
</section>
</section>
<section aria-labelledby="sec29" epub:type="division">
<span aria-label="72" epub:type="pagebreak" id="pg_72" role="doc-pagebreak"/>
<h2 class="H1"><span id="sec29"/><span id="h1-30"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<p class="TNI">In this chapter, you learned about integers and floating types. You also learned about implicit and explicit conversions, integer conversion rank, integer promotions, and the usual arithmetic conversions.</p>
<p class="TX">The use of these basic types, particularly integers, is unavoidable and ubiquitous in C programming. Even the “Hello, world!” program returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and prints a string—an array of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>—which, of course, is an integer type. Because integer types are used so often, you can’t simply reread this chapter each time you need to use them. You must understand their behavior so you can program effectively.</p>
<p class="TX">In the next chapter, you’ll learn about operators and how to write simple expressions to perform operations on these arithmetic types as well as other object types.</p>
</section>
</section>
</body></html>