- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 7 WORKING WITH FILES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you were to ask a coder only tangentially acquainted with Batch for its primary
    use, their response would likely mention moving files around. Batch can do much
    more, but without a doubt one of its primary uses is file movements. In this chapter,
    we’ll explore the different commands and techniques available. You’ll also learn
    about creating empty files, along with methods for merging, moving, renaming,
    and deleting files. I’ll introduce file masks and wildcards, allowing you to execute
    the commands you’re about to learn on many similarly named files instead of just
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Commands for Copying Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Batch has three commands for copying files: copy, xcopy, and robocopy. In this
    section, I’ll compare them and give recommendations on when to use each one, because
    they have their respective niches. Are you copying many small files or a few large
    files? Is the network stable? Is speed a consideration? Do you want a straightforward
    return code or one that’s more nuanced? How important is the logging to you? You’ll
    need to answer many questions before deciding on the optimal command and options
    for any particular copy.'
  prefs: []
  type: TYPE_NORMAL
- en: copy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The copy command offers a quick and easy way to create empty files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In Batch, the word nul represents a perpetually null or empty file (apparently,
    someone felt the need to abbreviate *null*). Here we’re making a copy of the nul
    file to produce an empty file with a path and name of our choosing (in [Chapter
    12](chapter12.xhtml), I’ll demonstrate how to dispose of unwanted output by sending
    it to this file where it disappears). A fun fact: Windows won’t let you create
    a file named nul in any folder, regardless of the extension or the lack of an
    extension, even manually. Go ahead and try.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only other use I’ve ever had for the copy command is to merge two or more
    relatively small files. The /B option performs a *binary* file copy, which means
    that every byte, even special characters such as the carriage return and line
    feed, are copied without alteration, resulting in a true concatenation of the
    files. The source files are separated by the plus sign, followed by the merged
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We’re concatenating two files here, but we can merge more with more plus sign
    delimiters.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that I’ve mentioned only two uses for the copy command,
    neither of which involve the copying of actual files. You can use the command
    to copy files, but I never use it for this purpose because it’s primitive and
    has a paucity of options. These shortcomings were apparent shortly after the first
    release of Batch, and it was soon largely replaced by the far more useful and
    configurable xcopy command.
  prefs: []
  type: TYPE_NORMAL
- en: xcopy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The basic syntax for the xcopy command has two arguments—the source file and
    the destination path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: One huge advantage of the xcopy command is that it’ll create the target directory
    if it doesn’t yet exist. In contrast, the copy command wouldn’t find the path
    and would fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example only a target path is given, which means the copied
    file will have the same name as the source file. But we can rename the destination
    file as part of the xcopy command by simply giving it a filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This command sometimes fails because the interpreter isn’t sure whether the
    destination is a directory or a file (in [Chapter 12](chapter12.xhtml), I’ll discuss
    how to make that work all of the time).
  prefs: []
  type: TYPE_NORMAL
- en: The xcopy command has two options that I use nearly every time I invoke the
    command. The /Y option suppresses the prompt to confirm overwriting a destination
    file. Although it might make sense to ask for confirmation when running via a
    command prompt or even interactively, in most other situations it does nothing
    more than halt processing and create a hang, so it’s best to turn it off.
  prefs: []
  type: TYPE_NORMAL
- en: The other option I can’t do without is /F. It displays the full source and destination
    paths and filenames of every file copied, which leaves a useful audit trail when
    the wildcard is used to copy multiple files. Without the /F option, only the source
    file or files are shown along with a total file count. At the other extreme, if
    you’re not interested in all of this information, you can use the /Q option (for
    *quiet* mode) to turn off the display altogether.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these two indispensable options, the following command suppresses the
    prompts and supplies detailed logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This command has too many available options to reasonably go over here; use
    the help command for a full list. As a small sampling, however, the /U option
    copies only files that already exist at the destination; the /S option copies
    folders and subfolders; and the /J option uses unbuffered I/O, which is optimal
    for very large files.
  prefs: []
  type: TYPE_NORMAL
- en: Although copy has been deprecated in favor of xcopy, Microsoft technically considers
    xcopy itself deprecated in favor of the even newer robocopy command. Even so,
    the wide use of the xcopy command means it’ll still be available in foreseeable
    operating systems, and as I’ll detail shortly, it’s still the better choice in
    many instances. I even used this command in what may have been your very first
    bat file in [Chapter 1](chapter1.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: robocopy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Removing the last character from the name of the command reveals the title of
    an old science-fiction film, but robocopy really stands for *robust copy*, which
    isn’t hyperbole. Although xcopy has many useful options, robocopy provides some
    impressive logging and a mind-boggling array of options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though the robocopy command is far more powerful than xcopy, it’s also
    quite easy to use. The arguments are a bit different: first provide the source
    directory sans the filename, then the destination directory, and finally the file,
    files, or file mask to be copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is functionally equivalent to the xcopy command from the previous
    section and reproduced here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Because the first two arguments of the robocopy command are known to be paths,
    you can leave off the trailing slash, which is a great advantage over xcopy where
    a missed slash can turn a destination directory into a filename.
  prefs: []
  type: TYPE_NORMAL
- en: robocopy Logging
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To get an idea of how robust robocopy really is, look no further than its logging
    capability. If you are an xcopy aficionado, be seated before glancing ahead. Verbose
    is the only word that comes to mind, and even that isn’t adequate. Besides the
    list of files copied, logs include a fancy header, the start and end times, file
    sizes, copy speed statistics, source and destination paths, total counts of the
    files and directories copied and skipped, along with any failed copies, a list
    of the command line options used, and much more. It’s even formatted nicely with
    plenty of whitespace for readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simple robocopy command shown previously to copy a single file generates
    the following log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Some of the results are self-explanatory such as Total, Copied, and FAILED,
    but others are not. If a file to be copied is already in the destination path
    and is identical, robocopy is smart enough to not waste time overlaying it and
    instead considers it justifiably Skipped. A Mismatch occurs when a copy is thwarted
    because a source file and a destination folder (or a source folder and a destination
    file) have the same name. Extras are files and directories not at the source but
    already at the destination. Obviously, the files weren’t copied, but the interpreter
    feels obligated to note their existence. For this task of copying one small file,
    the logging may be overkill. A more interesting task might go on for pages, but
    for that more interesting task, the logging may be invaluable.
  prefs: []
  type: TYPE_NORMAL
- en: By default, all this information is written to the console (in [Chapter 12](chapter12.xhtml),
    I’ll discuss how to instead redirect logging from any command or even an entire
    bat file to a logfile). But the robocopy command is unique in that you can easily
    create a logfile with an option. The path and name of the logfile simply follows
    the appropriately named /LOG option, delimited by a colon.
  prefs: []
  type: TYPE_NORMAL
- en: 'This may be the first instance you’ve seen where an option has more than one
    character after the slash, and this command has plenty more. Adding the plus sign
    to the option, /LOG+, results in the information being appended to the logfile
    if it already exists. To demonstrate, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After defining roboLog as the path and name of the logfile, it’s used in two
    robocopy commands. The first creates the logfile with information from its copy,
    overwriting an existing file if present, and the second robocopy command appends
    to that logfile with the results of its copy.
  prefs: []
  type: TYPE_NORMAL
- en: Both of the last two commands use the /NP option, which stands for *no progress*,
    because I consider it a necessity when creating a logfile. If the information
    is being written to the console, the progress of each copy is shown in real time
    as a percentage, updated multiple times a second. Relatively large files might
    display several dozens of values before 100% is finally shown. That status is
    great when viewed on the console, but in a logfile, each update becomes a new
    record. It doesn’t take many large files to turn the log into a complete mess.
    Even small files can result in a few extra unneeded records in the logfile. The
    /NP option cleans that up very nicely, updating the log only after each copy completes.
  prefs: []
  type: TYPE_NORMAL
- en: Useful robocopy Options
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are many robocopy options, so I’ll quickly go over the most useful ones.
    But first, here’s a command to serve as the canvas for the options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This simple command (lacking the third argument of a file) copies all files
    in the source directory to the target directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command automatically performs retries of failed copies, which is fabulous,
    but the default is a staggering one million attempts, each separated by a 30-second
    wait. This can result in a hang of several months for a fatally flawed attempted
    copy. The /R and /W options override the default number of *retries* and the *wait*
    time in seconds, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With these options, the interpreter will retry the failed copy up to 20 times,
    with 5 seconds between each attempt, before initiating an abort. Choose values
    that make sense to you and your hardware, but the defaults must not stand.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you add the /S option, it also will copy all the *subdirectories*, except
    for empty subdirectories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The /E option copies all of the subdirectories, *empty* and nonempty alike:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can refine this option to copy only the files in the source directory (*C:\Source\*)
    and its immediate subdirectories, but not lower levels of subdirectories. The
    /LEV option defines the number of *levels*, including the root, as 2, to handle
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Unbuffered I/O is more efficient for very large files and is invoked oddly
    enough with the /J option. (This option is borrowed from the xcopy command, where
    the /U option was already spoken for.) The /MIN and /MAX options set *minimum*
    and *maximum* byte limits for the files to be copied. The following two commands
    copy all files in a folder, using unbuffered I/O for only the files of at least
    1GB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: I snuck the /MT option, which stands for *multithreading*, into the command
    for the smaller files. By default, the robocopy command copies files serially,
    but this option copies eight files in parallel. You can even define the number
    of threads; /MT:128 is the maximum, but in my experience, this isn’t appreciably
    faster than the option default of eight. We can debate the threshold, but unbuffered
    I/O for large files and multithreading for smaller files will optimize any copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The /MINAGE and /MAXAGE options (*minimum* and *maximum ages*) define what’s
    to be copied based on the last modified date. You can use them individually or
    together to create a date range. The following command copies only files touched
    since Microsoft’s disastrous release of Windows Me on September 14, 2000, excluding
    anything that was changed in the last seven days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can define the value of both options as either a date (formatted as CCYYMMDD)
    or a number of days. The interpreter is smart enough to know that the eight-byte
    number represents a date and not a timespan of more than 50,000 years. Batch may
    not be a new language, but it was used by neither the Denisovans nor our hunter-gatherer
    forebearers. Any number less than 1,900 is considered by the interpreter to be
    a number of days.
  prefs: []
  type: TYPE_NORMAL
- en: The /PURGE option deletes extra files and directories at the destination, which
    you obviously should use with caution, but it’s a very handy tool for creating
    backups. If you back up a folder one day, change the name of a file in the source
    directory the next, and then back up the folder again, you’ll end up with an extraneous
    file in the backup unless you use the /PURGE option. Even better is the /MIR option
    that *mirrors* a directory tree. The /MIR option essentially does what the /PURGE
    option does, but it includes subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: The /XF option *excludes* one or more *files* from the copy, while /XD similarly
    *excludes* one or more *directories*. The /L option doesn’t copy anything; it
    produces a *list* of everything that would’ve been copied if the option hadn’t
    been used.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the robocopy command to move files (see “Moving Files” on page
    80). As always, use the help command for a complete list of available options.
  prefs: []
  type: TYPE_NORMAL
- en: The robocopy Return Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The xcopy command is like most Batch commands in that a successful execution
    returns an errorlevel of 0, while a failure returns a number other than 0. In
    contrast, robocopy is unique—a uniqueness that if not understood can breed much
    bewilderment. A return code of 0 means that nothing was copied, but if at least
    one file was copied successfully, the interpreter returns an odd number between
    1 and 15, inclusive, but even some of those codes aren’t exactly *good* return
    codes. Here are the six basic return codes the robocopy command generates:'
  prefs: []
  type: TYPE_NORMAL
- en: 0    No error, but no file(s) was copied; in other words, all files were skipped.
  prefs: []
  type: TYPE_NORMAL
- en: 1    One or more files copied successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 2    One or more extra files or directories were found; none were copied.
  prefs: []
  type: TYPE_NORMAL
- en: 4    One or more mismatches were found; none were copied.
  prefs: []
  type: TYPE_NORMAL
- en: 8    Some files or directories could not be copied.
  prefs: []
  type: TYPE_NORMAL
- en: 16    Nothing was copied; there was a serious error.
  prefs: []
  type: TYPE_NORMAL
- en: Oh, the elegance of the *powers of two*; a mathematician must’ve come up with
    these return codes. Wouldn’t it have been easier to use codes 0 through 5? No,
    the four codes in the middle aren’t mutually exclusive; that is, it’s possible
    for more than one of them (even all four) to be true at the same time. The interpreter
    adds up all of the codes that are true and returns the sum as the errorlevel.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, envision a robocopy command of all files in a source folder to
    a destination folder where some files are copied successfully, but the destination
    also has extra copies. Return codes 1 and 2 are both true; hence, 3, their sum,
    is returned as the errorlevel. It’s also possible that when files were copied,
    extras were found along with a mismatch, and another file failed to copy because
    it was held open by someone or some process. Do the math (1 + 2 + 4 + 8), and
    the interpreter returns 15.
  prefs: []
  type: TYPE_NORMAL
- en: These return codes give the savvy coder the opportunity to fine-tune the error
    handling. Return codes of 1 and 3 are clearly good, and I often consider 3 or
    less to also be good. Anything from 4 to 7 involves a mismatch, and anything above
    that has at least one explicit failure. Depending on the circumstances, mismatches
    might be completely acceptable so that only a return code of 8 or greater would
    be considered bad.
  prefs: []
  type: TYPE_NORMAL
- en: To explicitly verify that at least one file was copied, we need to look only
    for an odd-numbered return code, which we can do with the modulo function from
    [Chapter 6](chapter6.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: xcopy vs. robocopy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Despite the subjective nature of the word, most Batch coders agree that robocopy
    is *better* than xcopy because of its myriad of options, multithreading, automated
    retries, impressive logging, and everything behind the scenes that makes it more
    efficient. But there’s one major batveat. When trying to copy a single file, the
    xcopy error handling is *better* by far. Both of these commands are attempting
    to copy a named file that doesn’t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The xcopy command reports that no files were copied and returns an errorlevel
    of 4, but the robocopy command simply returns 0, stating that there were no errors
    and no files copied. I contend that this should be an error. When attempting to
    copy multiple files, both commands return 0 when there are no source files—that
    makes sense, but both of these commands are calling for an explicit file to be
    copied, and the robocopy return code doesn’t distinguish between the file not
    being found and being skipped because it already exists at the target directory.
    The skipping of nonupdated files is a great feature of robocopy, but it’s something
    quite different from a file not being found. The robust logging makes this clear,
    but the return code does not.
  prefs: []
  type: TYPE_NORMAL
- en: This failure of the return code to report why a file wasn’t copied (not found
    or skipped) is a deficiency, but we can overcome it. When copying one specific
    file with the robocopy command, you can perform an if exist on the target file
    when errorlevel is 0. If it exists, the file was properly skipped; if not, there
    was an error. Or, do as I do and just use xcopy in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: There are other instances when the complex return code of the robocopy command
    is more than what’s needed. You might not care whether there are extra or mismatched
    files and instead just want a simple result of good or bad, zero or nonzero. There’s
    nothing wrong with that, and if I’m being honest, I sometimes still use it in
    new code out of habit and ease of use.
  prefs: []
  type: TYPE_NORMAL
- en: That said, the robocopy command is, as its name suggests, much more robust.
    It’s far more configurable, faster, and less prone to fail. If copying very large
    files, a large number of files, or files that might fail due to a connectivity
    issue, robocopy is the obvious choice, and that complex return code is a major
    boon at times. Also, the xcopy command has a 254-byte limitation on the length
    of a path and filename. I’ve never come close to exceeding this limitation, but
    if you ever do, robocopy can handle it.
  prefs: []
  type: TYPE_NORMAL
- en: The most definitive statement I’ll make on this topic is that you should never
    use the copy command to copy a file, but keep it in your toolbox for creating
    an empty file or merging files.
  prefs: []
  type: TYPE_NORMAL
- en: File Masks and Wildcards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of the previous xcopy examples copied a single file, and the robocopy examples
    copied either a single file or all of the files in a directory. But with file
    masks and wildcards, you can create far more targeted commands that copy only
    some of the files in a directory; in fact, they might copy a different number
    of files every time they execute. A *file mask* replaces the filename in both
    of these commands and consists of one or more *wildcard* characters, possibly
    with some hardcoded text or resolved variables. Then when it executes, the command
    copies all of the files that satisfy or fit the file mask.
  prefs: []
  type: TYPE_NORMAL
- en: File masks are not unique to commands that copy files. Upcoming commands in
    this chapter for moving, deleting, and even renaming files also accept file masks
    in lieu of filenames, allowing you to move, delete, and rename multiple files
    at once. The for command makes great use of file masks, and I’ll demonstrate how
    in [Part II](part2.xhtml). Any command that performs some action on a file probably
    works with wildcards; experiment if in doubt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Batch recognizes two characters as wildcards, the asterisk (*) and the question
    mark (?). They behave quite differently, and I’ll detail both with the xcopy command,
    but first let’s take a look at a set of files to copy. A meticulously organized
    person might maintain spreadsheets with budget information, one file for each
    month of a year. For this demonstration, the *C:\Budget\* folder contains spreadsheets
    with a naming convention noting the year and month. Here are just three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These files are from the year of the financial crisis and the start of the Great
    Recession, and the folder contains similarly named files from the year before
    and after, along with other types of files.
  prefs: []
  type: TYPE_NORMAL
- en: The Asterisk Wildcard Character
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The asterisk is the most common Batch wildcard character and is a stand-in
    for zero to many characters. To demonstrate, the following xcopy command copies
    all of the files, and only the files, from 2008, or more specifically, the files
    residing in *C:\Budget\* that satisfy the Budget.*2008.xlsx mask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The asterisk is the wildcard, meaning that this command copies every file with
    a name that starts with Budget. and ends with 2008.xlsx, with something, or even
    nothing, in between. If a file named *Budget.2008.xlsx* happens to be in the folder,
    it also satisfies the mask and is one of the copied files.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the year, a dozen such files should satisfy this mask, one for
    each month, resulting in the command copying all 12\. But the command won’t copy
    files from 2007 or 2009, nor will it copy a Word document with the same name but
    a different extension, such as *Budget.June2008 .docx*. If you were to remove
    the first dot from the name of one of the files, *BudgetAugust2008.xlsx*, the
    interpreter won’t copy it either because it doesn’t satisfy the mask.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following very subtle change of inserting the letter J before the wildcard
    results in the command copying only three files, the ones for January, June, and
    July:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Add one more character before the wildcard, and the Budget.Ju*2008.xlsx mask
    excludes the January file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You aren’t limited to a single wildcard in a mask. Here’s an example that uses
    two asterisks, where the last one is a stand-in for the extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The aforementioned Word document, *Budget.June2008.docx*, now gets caught up
    in the dragnet.
  prefs: []
  type: TYPE_NORMAL
- en: You now know that the asterisk wildcard can represent any text of any length,
    including no text at all, but there are times that you may want to be more restrictive.
    Batch has a lesser known and much lesser understood wildcard character for this
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The Question Mark Wildcard Character
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While the asterisk is a wildcard for zero to many characters, the question
    mark is a wildcard for exactly one character, *usually*. (Yes, the italics mean
    that a batveat is on the way.) To copy files only with four-character months,
    I’ll use four question marks where there once was an asterisk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This command copies the files for June and July, but not the files for March,
    April, May, and all the other months, which happen to be more verbose.
  prefs: []
  type: TYPE_NORMAL
- en: That seems straightforward, but I promised you a batveat. If a set of one or
    more question mark wildcards comes at the end of a file mask or if those question
    marks immediately precede a dot, Batch also considers a null to be a valid replacement
    value for each of the question marks.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, I’ll make a tweak to the file naming convention by inserting
    a period between the month and year, resulting in filenames such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, I’ll insert the period into the file mask between the four question marks
    and the year like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Even some experienced Batch coders might expect the files for June and July
    only to satisfy this mask. They would be correct in that files for March, April,
    and all the other months denoted with more than four letters won’t be copied,
    but the file for May will also satisfy the mask. The first three wildcards match
    on each of the three letters in May, but the fourth question mark matches on a
    null or nonexistent character. Even the oddly named *Budget..2008.xlsx* satisfies
    this mask.
  prefs: []
  type: TYPE_NORMAL
- en: The upshot is that when *n* question mark wildcards come at the end of a file
    mask or are followed by a dot, the mask is satisfied with zero to *n* characters.
    Otherwise, *n* question mark wildcards are satisfied with exactly *n* characters.
    It’s a very subtle oddity, and understanding it might save you hours of grief.
  prefs: []
  type: TYPE_NORMAL
- en: To put a fine point on the difference between the two Batch wildcard characters,
    shot, shoot, shut, shunt, shallot, and even sht all satisfy the sh*t file mask.
    Of these words (and one nonword), only shot and shut satisfy the sh?t file mask.
  prefs: []
  type: TYPE_NORMAL
- en: Moving Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Moving a file is similar to copying a file; the only difference is that after
    a file is copied, it exists in two places, while after a file is moved, the original
    file is no more. The move command performs this task easily. It simply takes the
    source and the target as arguments, and you’ll usually see it with the /Y option
    to suppress the confirmation prompt for overwriting the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Plenty of old code still contains the move command, but it has been largely
    deprecated in favor of the robocopy command. The following command with the /MOV
    option is functionally equivalent to the previous move command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Removing the filename from this robocopy command moves all the files in the
    source folder, but nothing from the subfolders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the /S option results in moving all of the contents in all the subfolders,
    even if the target subfolders need to be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This command moves all of the files. They are no longer at the source, but the
    source folder structure remains. Now this is where it gets a bit weird, worthy
    of a batveat. We’ve been discussing the /MOV option, which is obviously short
    for *move*, but a similarly named option called /MOVE stands for ... I guess *move
    with an E*. These two options are subtly different. The robocopy command with
    the /MOVE option truly moves files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'The addition of the E to the option deletes the source directory structure
    after copying all of the files to the destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: What we have is a /MOV option that moves files while copying subdirectories
    and a /MOVE option that moves both files and subdirectories. It isn’t particularly
    intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: When considering which command to use for a particular move, the robocopy command
    is the most efficient choice for all the same reasons mentioned in “xcopy vs.
    robocopy” on page 76. But like the xcopy command, the move command has the more
    straightforward return code and still has a place in the Batch ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When files are no longer needed, it just makes sense to clean them up. The
    del command easily deletes one or more files. The /Q option, which again stands
    for *quiet* mode, prevents the interpreter from asking permission to delete the
    file. The command accepts multiple arguments of files to be deleted where you
    can use both explicit filenames and file masks. The following command deletes
    one specific file named *Junk.txt* and all files in the folder with the *.OLD*
    extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Use the /A option to select files for deletion based on their attributes. For
    example, delete only hidden files using the /AH option. Negating the logic, the
    /A-H option deletes only files that are *not* hidden. As always, use the help
    command for a complete list of options.
  prefs: []
  type: TYPE_NORMAL
- en: Delete all the files in a folder by simply using the directory as the argument
    to the del command, but the directory itself will still exist. You’ll need a different
    command for that, and I’ll share it in [Chapter 13](chapter13.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Renaming Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ren and rename commands are Batch synonyms; that is, they are the same
    command. The first argument is the file to be renamed, and the second argument
    is the new filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If the destination file already exists, the interpreter returns an errorlevel
    of 1. If there’s the possibility that a file with the same name is already there,
    I’ll quietly delete it prior to the rename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Wildcards are supported even for this command, but I’ve used the ren command
    only for explicit filenames, primarily because the command doesn’t write a list
    of renamed files to the console. (If I have more than one file to rename, I’ll
    use a dir command as input into a for command and do the renames one by one. We’ll
    explore these commands further in [Chapters 13](chapter13.xhtml) and [17](chapter17.xhtml),
    respectively.)
  prefs: []
  type: TYPE_NORMAL
- en: The ren command isn’t complicated, but I’ve seen one common batveat far too
    often. It’s easy to use the path on both arguments, but when you reflect on this
    for a moment, the interpreter already knows the path from the first argument.
    The file isn’t being moved or copied anywhere; by the nature of this command,
    it’s being renamed in place. If the first argument doesn’t have a path, the current
    directory is assumed (more on that in the next chapter), but the second argument
    is the new filename only and should never have a path associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter likely will become one that you reference most in this book. Batch
    would be nothing without the ability to create, copy, move, merge, and delete
    files, and I introduced a bevy of commands for those tasks here. Some of the commands
    I discussed are straightforward, but I covered more than one batveat along with
    solutions for mitigating them. You also learned how to execute these commands
    on multiple files at a time with the use of file masks and wildcards.
  prefs: []
  type: TYPE_NORMAL
- en: Copying a file might sound like a simple task, but I detailed the many techniques
    available and considerations at play. I hope that I showed you how powerful and
    useful the robocopy command really is, while also instilling in you an appreciation
    for the simplicity and usefulness of the xcopy command.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter I’ll describe how to execute a program compiled in another
    language, which will involve a deeper discussion about how the interpreter finds
    the program to execute when you don’t provide a path.
  prefs: []
  type: TYPE_NORMAL
