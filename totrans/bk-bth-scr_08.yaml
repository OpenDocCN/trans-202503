- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: 7 WORKING WITH FILES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: If you were to ask a coder only tangentially acquainted with Batch for its primary
    use, their response would likely mention moving files around. Batch can do much
    more, but without a doubt one of its primary uses is file movements. In this chapter,
    we’ll explore the different commands and techniques available. You’ll also learn
    about creating empty files, along with methods for merging, moving, renaming,
    and deleting files. I’ll introduce file masks and wildcards, allowing you to execute
    the commands you’re about to learn on many similarly named files instead of just
    one.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Commands for Copying Files
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Batch has three commands for copying files: copy, xcopy, and robocopy. In this
    section, I’ll compare them and give recommendations on when to use each one, because
    they have their respective niches. Are you copying many small files or a few large
    files? Is the network stable? Is speed a consideration? Do you want a straightforward
    return code or one that’s more nuanced? How important is the logging to you? You’ll
    need to answer many questions before deciding on the optimal command and options
    for any particular copy.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: copy
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The copy command offers a quick and easy way to create empty files:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In Batch, the word nul represents a perpetually null or empty file (apparently,
    someone felt the need to abbreviate *null*). Here we’re making a copy of the nul
    file to produce an empty file with a path and name of our choosing (in [Chapter
    12](chapter12.xhtml), I’ll demonstrate how to dispose of unwanted output by sending
    it to this file where it disappears). A fun fact: Windows won’t let you create
    a file named nul in any folder, regardless of the extension or the lack of an
    extension, even manually. Go ahead and try.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'The only other use I’ve ever had for the copy command is to merge two or more
    relatively small files. The /B option performs a *binary* file copy, which means
    that every byte, even special characters such as the carriage return and line
    feed, are copied without alteration, resulting in a true concatenation of the
    files. The source files are separated by the plus sign, followed by the merged
    file:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’re concatenating two files here, but we can merge more with more plus sign
    delimiters.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that I’ve mentioned only two uses for the copy command,
    neither of which involve the copying of actual files. You can use the command
    to copy files, but I never use it for this purpose because it’s primitive and
    has a paucity of options. These shortcomings were apparent shortly after the first
    release of Batch, and it was soon largely replaced by the far more useful and
    configurable xcopy command.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: xcopy
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The basic syntax for the xcopy command has two arguments—the source file and
    the destination path:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: One huge advantage of the xcopy command is that it’ll create the target directory
    if it doesn’t yet exist. In contrast, the copy command wouldn’t find the path
    and would fail.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example only a target path is given, which means the copied
    file will have the same name as the source file. But we can rename the destination
    file as part of the xcopy command by simply giving it a filename:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command sometimes fails because the interpreter isn’t sure whether the
    destination is a directory or a file (in [Chapter 12](chapter12.xhtml), I’ll discuss
    how to make that work all of the time).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The xcopy command has two options that I use nearly every time I invoke the
    command. The /Y option suppresses the prompt to confirm overwriting a destination
    file. Although it might make sense to ask for confirmation when running via a
    command prompt or even interactively, in most other situations it does nothing
    more than halt processing and create a hang, so it’s best to turn it off.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The other option I can’t do without is /F. It displays the full source and destination
    paths and filenames of every file copied, which leaves a useful audit trail when
    the wildcard is used to copy multiple files. Without the /F option, only the source
    file or files are shown along with a total file count. At the other extreme, if
    you’re not interested in all of this information, you can use the /Q option (for
    *quiet* mode) to turn off the display altogether.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these two indispensable options, the following command suppresses the
    prompts and supplies detailed logging:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command has too many available options to reasonably go over here; use
    the help command for a full list. As a small sampling, however, the /U option
    copies only files that already exist at the destination; the /S option copies
    folders and subfolders; and the /J option uses unbuffered I/O, which is optimal
    for very large files.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Although copy has been deprecated in favor of xcopy, Microsoft technically considers
    xcopy itself deprecated in favor of the even newer robocopy command. Even so,
    the wide use of the xcopy command means it’ll still be available in foreseeable
    operating systems, and as I’ll detail shortly, it’s still the better choice in
    many instances. I even used this command in what may have been your very first
    bat file in [Chapter 1](chapter1.xhtml).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: robocopy
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Removing the last character from the name of the command reveals the title of
    an old science-fiction film, but robocopy really stands for *robust copy*, which
    isn’t hyperbole. Although xcopy has many useful options, robocopy provides some
    impressive logging and a mind-boggling array of options.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though the robocopy command is far more powerful than xcopy, it’s also
    quite easy to use. The arguments are a bit different: first provide the source
    directory sans the filename, then the destination directory, and finally the file,
    files, or file mask to be copied:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This example is functionally equivalent to the xcopy command from the previous
    section and reproduced here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because the first two arguments of the robocopy command are known to be paths,
    you can leave off the trailing slash, which is a great advantage over xcopy where
    a missed slash can turn a destination directory into a filename.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 robocopy 命令的前两个参数被认为是路径，因此你可以省略结尾的斜杠，这相比 xcopy 是一个很大的优势，因为在 xcopy 中，漏掉斜杠会把目标目录误当作文件名。
- en: robocopy Logging
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: robocopy 日志记录
- en: To get an idea of how robust robocopy really is, look no further than its logging
    capability. If you are an xcopy aficionado, be seated before glancing ahead. Verbose
    is the only word that comes to mind, and even that isn’t adequate. Besides the
    list of files copied, logs include a fancy header, the start and end times, file
    sizes, copy speed statistics, source and destination paths, total counts of the
    files and directories copied and skipped, along with any failed copies, a list
    of the command line options used, and much more. It’s even formatted nicely with
    plenty of whitespace for readability.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 robocopy 的强大功能，不妨看看它的日志记录能力。如果你是 xcopy 的爱好者，最好先坐下再继续往下看。Verbose（详细）是唯一能形容它的词，甚至连这个词也不够准确。除了复制的文件列表，日志还包括一个漂亮的头部、开始和结束时间、文件大小、复制速度统计、源路径和目标路径、复制和跳过的文件和目录总数、任何失败的复制、使用的命令行选项列表等等。它的格式也很不错，有很多空白区域，便于阅读。
- en: 'The simple robocopy command shown previously to copy a single file generates
    the following log:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面展示的简单 robocopy 命令用于复制一个文件，它会生成以下日志：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Some of the results are self-explanatory such as Total, Copied, and FAILED,
    but others are not. If a file to be copied is already in the destination path
    and is identical, robocopy is smart enough to not waste time overlaying it and
    instead considers it justifiably Skipped. A Mismatch occurs when a copy is thwarted
    because a source file and a destination folder (or a source folder and a destination
    file) have the same name. Extras are files and directories not at the source but
    already at the destination. Obviously, the files weren’t copied, but the interpreter
    feels obligated to note their existence. For this task of copying one small file,
    the logging may be overkill. A more interesting task might go on for pages, but
    for that more interesting task, the logging may be invaluable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一些结果不言自明，比如Total（总数）、Copied（已复制）和FAILED（失败），但其他结果则不太明显。如果要复制的文件已经存在于目标路径中并且完全相同，robocopy
    会聪明地避免浪费时间覆盖它，而是将其视为合理的 Skipped（跳过）。当复制被阻止，因为源文件和目标文件夹（或源文件夹和目标文件）同名时，会发生 Mismatch（不匹配）。Extras（额外项）是指不在源目录中，但已经存在于目标位置的文件和目录。显然，这些文件并没有被复制，但解释器觉得有必要记录它们的存在。对于仅复制一个小文件的任务来说，日志记录可能显得有些过多。一个更有趣的任务可能会持续几页，但对于那个更有趣的任务，日志记录可能是不可或缺的。
- en: By default, all this information is written to the console (in [Chapter 12](chapter12.xhtml),
    I’ll discuss how to instead redirect logging from any command or even an entire
    bat file to a logfile). But the robocopy command is unique in that you can easily
    create a logfile with an option. The path and name of the logfile simply follows
    the appropriately named /LOG option, delimited by a colon.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有这些信息都会写入控制台（在[第12章](chapter12.xhtml)中，我会讨论如何将任何命令甚至整个批处理文件的日志重定向到日志文件）。但
    robocopy 命令的独特之处在于，你可以轻松地通过选项创建日志文件。日志文件的路径和名称紧随其后，通过冒号与 /LOG 选项分隔。
- en: 'This may be the first instance you’ve seen where an option has more than one
    character after the slash, and this command has plenty more. Adding the plus sign
    to the option, /LOG+, results in the information being appended to the logfile
    if it already exists. To demonstrate, consider the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是你第一次看到选项后有多个字符的情况，而且这个命令还有更多类似的选项。将加号添加到选项中，如/LOG+，会导致信息附加到日志文件中（如果文件已存在）。为了演示，考虑以下内容：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After defining roboLog as the path and name of the logfile, it’s used in two
    robocopy commands. The first creates the logfile with information from its copy,
    overwriting an existing file if present, and the second robocopy command appends
    to that logfile with the results of its copy.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义 roboLog 为日志文件路径和名称后，它会在两个 robocopy 命令中使用。第一个命令创建日志文件并写入复制信息，如果文件已存在，则会覆盖；第二个
    robocopy 命令则将复制结果追加到该日志文件中。
- en: Both of the last two commands use the /NP option, which stands for *no progress*,
    because I consider it a necessity when creating a logfile. If the information
    is being written to the console, the progress of each copy is shown in real time
    as a percentage, updated multiple times a second. Relatively large files might
    display several dozens of values before 100% is finally shown. That status is
    great when viewed on the console, but in a logfile, each update becomes a new
    record. It doesn’t take many large files to turn the log into a complete mess.
    Even small files can result in a few extra unneeded records in the logfile. The
    /NP option cleans that up very nicely, updating the log only after each copy completes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个命令都使用了/NP选项，代表*无进度*，因为在创建日志文件时我认为它是必需的。如果信息被写入控制台，复制的进度会实时显示为百分比，并且每秒更新多次。较大的文件可能会显示几十个进度值，直到最终显示100%。这种状态在控制台上查看时非常好，但在日志文件中，每次更新都会成为一个新记录。即使是几个大文件，也能让日志文件变得一团糟。即使是小文件，也可能导致日志文件中出现一些不需要的额外记录。/NP选项非常好地解决了这个问题，它只会在每次复制完成后更新日志。
- en: Useful robocopy Options
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 有用的robocopy选项
- en: 'There are many robocopy options, so I’ll quickly go over the most useful ones.
    But first, here’s a command to serve as the canvas for the options:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: robocopy有许多选项，所以我将快速介绍其中最有用的几个。但首先，给出一个命令作为选项的基础：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This simple command (lacking the third argument of a file) copies all files
    in the source directory to the target directory.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的命令（没有文件的第三个参数）会将源目录中的所有文件复制到目标目录。
- en: 'The command automatically performs retries of failed copies, which is fabulous,
    but the default is a staggering one million attempts, each separated by a 30-second
    wait. This can result in a hang of several months for a fatally flawed attempted
    copy. The /R and /W options override the default number of *retries* and the *wait*
    time in seconds, respectively:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会自动重试失败的复制操作，功能非常棒，但默认的重试次数高达一百万次，每次之间间隔30秒。这可能会导致在进行有致命错误的复制尝试时，程序挂起几个月。/R和/W选项分别覆盖了默认的*重试*次数和*等待*时间（秒）：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With these options, the interpreter will retry the failed copy up to 20 times,
    with 5 seconds between each attempt, before initiating an abort. Choose values
    that make sense to you and your hardware, but the defaults must not stand.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些选项时，解释器会在失败的复制操作中最多重试20次，每次尝试之间间隔5秒，之后才会中止。选择适合你的硬件和需求的值，但默认值不能继续使用。
- en: 'If you add the /S option, it also will copy all the *subdirectories*, except
    for empty subdirectories:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果添加了/S选项，它还会复制所有的*子目录*，不过会排除空子目录：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The /E option copies all of the subdirectories, *empty* and nonempty alike:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: /E选项会复制所有的子目录，包括*空*目录和非空目录：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can refine this option to copy only the files in the source directory (*C:\Source\*)
    and its immediate subdirectories, but not lower levels of subdirectories. The
    /LEV option defines the number of *levels*, including the root, as 2, to handle
    that:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以精细化此选项，只复制源目录（*C:\Source\*）及其直接子目录中的文件，但不包括更低层级的子目录。/LEV选项将子目录的*层级*（包括根目录）定义为2，以此来处理：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Unbuffered I/O is more efficient for very large files and is invoked oddly
    enough with the /J option. (This option is borrowed from the xcopy command, where
    the /U option was already spoken for.) The /MIN and /MAX options set *minimum*
    and *maximum* byte limits for the files to be copied. The following two commands
    copy all files in a folder, using unbuffered I/O for only the files of at least
    1GB:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 无缓冲I/O对于非常大的文件来说效率更高，而且通过/ J选项调用，奇怪的是，它的实现方式与xcopy命令中的/U选项有关（/U已经被占用了）。/MIN和/MAX选项设置了文件复制时的*最小*和*最大*字节限制。以下两个命令会复制文件夹中的所有文件，只对至少1GB的文件使用无缓冲I/O：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I snuck the /MT option, which stands for *multithreading*, into the command
    for the smaller files. By default, the robocopy command copies files serially,
    but this option copies eight files in parallel. You can even define the number
    of threads; /MT:128 is the maximum, but in my experience, this isn’t appreciably
    faster than the option default of eight. We can debate the threshold, but unbuffered
    I/O for large files and multithreading for smaller files will optimize any copy.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我偷偷将/MT选项（代表*多线程*）加到了小文件的命令中。默认情况下，robocopy命令是串行复制文件的，但这个选项会并行复制八个文件。你甚至可以定义线程数；/MT:128是最大值，但根据我的经验，这并不会比默认的八个线程快太多。我们可以讨论阈值，但对于大文件的无缓冲I/O和小文件的多线程操作，都会优化任何复制过程。
- en: 'The /MINAGE and /MAXAGE options (*minimum* and *maximum ages*) define what’s
    to be copied based on the last modified date. You can use them individually or
    together to create a date range. The following command copies only files touched
    since Microsoft’s disastrous release of Windows Me on September 14, 2000, excluding
    anything that was changed in the last seven days:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can define the value of both options as either a date (formatted as CCYYMMDD)
    or a number of days. The interpreter is smart enough to know that the eight-byte
    number represents a date and not a timespan of more than 50,000 years. Batch may
    not be a new language, but it was used by neither the Denisovans nor our hunter-gatherer
    forebearers. Any number less than 1,900 is considered by the interpreter to be
    a number of days.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The /PURGE option deletes extra files and directories at the destination, which
    you obviously should use with caution, but it’s a very handy tool for creating
    backups. If you back up a folder one day, change the name of a file in the source
    directory the next, and then back up the folder again, you’ll end up with an extraneous
    file in the backup unless you use the /PURGE option. Even better is the /MIR option
    that *mirrors* a directory tree. The /MIR option essentially does what the /PURGE
    option does, but it includes subdirectories.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The /XF option *excludes* one or more *files* from the copy, while /XD similarly
    *excludes* one or more *directories*. The /L option doesn’t copy anything; it
    produces a *list* of everything that would’ve been copied if the option hadn’t
    been used.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the robocopy command to move files (see “Moving Files” on page
    80). As always, use the help command for a complete list of available options.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The robocopy Return Code
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The xcopy command is like most Batch commands in that a successful execution
    returns an errorlevel of 0, while a failure returns a number other than 0. In
    contrast, robocopy is unique—a uniqueness that if not understood can breed much
    bewilderment. A return code of 0 means that nothing was copied, but if at least
    one file was copied successfully, the interpreter returns an odd number between
    1 and 15, inclusive, but even some of those codes aren’t exactly *good* return
    codes. Here are the six basic return codes the robocopy command generates:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 0    No error, but no file(s) was copied; in other words, all files were skipped.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 1    One or more files copied successfully.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 2    One or more extra files or directories were found; none were copied.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 4    One or more mismatches were found; none were copied.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 8    Some files or directories could not be copied.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 16    Nothing was copied; there was a serious error.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Oh, the elegance of the *powers of two*; a mathematician must’ve come up with
    these return codes. Wouldn’t it have been easier to use codes 0 through 5? No,
    the four codes in the middle aren’t mutually exclusive; that is, it’s possible
    for more than one of them (even all four) to be true at the same time. The interpreter
    adds up all of the codes that are true and returns the sum as the errorlevel.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: As an example, envision a robocopy command of all files in a source folder to
    a destination folder where some files are copied successfully, but the destination
    also has extra copies. Return codes 1 and 2 are both true; hence, 3, their sum,
    is returned as the errorlevel. It’s also possible that when files were copied,
    extras were found along with a mismatch, and another file failed to copy because
    it was held open by someone or some process. Do the math (1 + 2 + 4 + 8), and
    the interpreter returns 15.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: These return codes give the savvy coder the opportunity to fine-tune the error
    handling. Return codes of 1 and 3 are clearly good, and I often consider 3 or
    less to also be good. Anything from 4 to 7 involves a mismatch, and anything above
    that has at least one explicit failure. Depending on the circumstances, mismatches
    might be completely acceptable so that only a return code of 8 or greater would
    be considered bad.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: To explicitly verify that at least one file was copied, we need to look only
    for an odd-numbered return code, which we can do with the modulo function from
    [Chapter 6](chapter6.xhtml).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: xcopy vs. robocopy
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Despite the subjective nature of the word, most Batch coders agree that robocopy
    is *better* than xcopy because of its myriad of options, multithreading, automated
    retries, impressive logging, and everything behind the scenes that makes it more
    efficient. But there’s one major batveat. When trying to copy a single file, the
    xcopy error handling is *better* by far. Both of these commands are attempting
    to copy a named file that doesn’t exist:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The xcopy command reports that no files were copied and returns an errorlevel
    of 4, but the robocopy command simply returns 0, stating that there were no errors
    and no files copied. I contend that this should be an error. When attempting to
    copy multiple files, both commands return 0 when there are no source files—that
    makes sense, but both of these commands are calling for an explicit file to be
    copied, and the robocopy return code doesn’t distinguish between the file not
    being found and being skipped because it already exists at the target directory.
    The skipping of nonupdated files is a great feature of robocopy, but it’s something
    quite different from a file not being found. The robust logging makes this clear,
    but the return code does not.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: This failure of the return code to report why a file wasn’t copied (not found
    or skipped) is a deficiency, but we can overcome it. When copying one specific
    file with the robocopy command, you can perform an if exist on the target file
    when errorlevel is 0. If it exists, the file was properly skipped; if not, there
    was an error. Or, do as I do and just use xcopy in this situation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: There are other instances when the complex return code of the robocopy command
    is more than what’s needed. You might not care whether there are extra or mismatched
    files and instead just want a simple result of good or bad, zero or nonzero. There’s
    nothing wrong with that, and if I’m being honest, I sometimes still use it in
    new code out of habit and ease of use.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: That said, the robocopy command is, as its name suggests, much more robust.
    It’s far more configurable, faster, and less prone to fail. If copying very large
    files, a large number of files, or files that might fail due to a connectivity
    issue, robocopy is the obvious choice, and that complex return code is a major
    boon at times. Also, the xcopy command has a 254-byte limitation on the length
    of a path and filename. I’ve never come close to exceeding this limitation, but
    if you ever do, robocopy can handle it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The most definitive statement I’ll make on this topic is that you should never
    use the copy command to copy a file, but keep it in your toolbox for creating
    an empty file or merging files.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: File Masks and Wildcards
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of the previous xcopy examples copied a single file, and the robocopy examples
    copied either a single file or all of the files in a directory. But with file
    masks and wildcards, you can create far more targeted commands that copy only
    some of the files in a directory; in fact, they might copy a different number
    of files every time they execute. A *file mask* replaces the filename in both
    of these commands and consists of one or more *wildcard* characters, possibly
    with some hardcoded text or resolved variables. Then when it executes, the command
    copies all of the files that satisfy or fit the file mask.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: File masks are not unique to commands that copy files. Upcoming commands in
    this chapter for moving, deleting, and even renaming files also accept file masks
    in lieu of filenames, allowing you to move, delete, and rename multiple files
    at once. The for command makes great use of file masks, and I’ll demonstrate how
    in [Part II](part2.xhtml). Any command that performs some action on a file probably
    works with wildcards; experiment if in doubt.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Batch recognizes two characters as wildcards, the asterisk (*) and the question
    mark (?). They behave quite differently, and I’ll detail both with the xcopy command,
    but first let’s take a look at a set of files to copy. A meticulously organized
    person might maintain spreadsheets with budget information, one file for each
    month of a year. For this demonstration, the *C:\Budget\* folder contains spreadsheets
    with a naming convention noting the year and month. Here are just three:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These files are from the year of the financial crisis and the start of the Great
    Recession, and the folder contains similarly named files from the year before
    and after, along with other types of files.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The Asterisk Wildcard Character
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The asterisk is the most common Batch wildcard character and is a stand-in
    for zero to many characters. To demonstrate, the following xcopy command copies
    all of the files, and only the files, from 2008, or more specifically, the files
    residing in *C:\Budget\* that satisfy the Budget.*2008.xlsx mask:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The asterisk is the wildcard, meaning that this command copies every file with
    a name that starts with Budget. and ends with 2008.xlsx, with something, or even
    nothing, in between. If a file named *Budget.2008.xlsx* happens to be in the folder,
    it also satisfies the mask and is one of the copied files.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the year, a dozen such files should satisfy this mask, one for
    each month, resulting in the command copying all 12\. But the command won’t copy
    files from 2007 or 2009, nor will it copy a Word document with the same name but
    a different extension, such as *Budget.June2008 .docx*. If you were to remove
    the first dot from the name of one of the files, *BudgetAugust2008.xlsx*, the
    interpreter won’t copy it either because it doesn’t satisfy the mask.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'The following very subtle change of inserting the letter J before the wildcard
    results in the command copying only three files, the ones for January, June, and
    July:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Add one more character before the wildcard, and the Budget.Ju*2008.xlsx mask
    excludes the January file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'You aren’t limited to a single wildcard in a mask. Here’s an example that uses
    two asterisks, where the last one is a stand-in for the extension:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The aforementioned Word document, *Budget.June2008.docx*, now gets caught up
    in the dragnet.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: You now know that the asterisk wildcard can represent any text of any length,
    including no text at all, but there are times that you may want to be more restrictive.
    Batch has a lesser known and much lesser understood wildcard character for this
    purpose.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The Question Mark Wildcard Character
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While the asterisk is a wildcard for zero to many characters, the question
    mark is a wildcard for exactly one character, *usually*. (Yes, the italics mean
    that a batveat is on the way.) To copy files only with four-character months,
    I’ll use four question marks where there once was an asterisk:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This command copies the files for June and July, but not the files for March,
    April, May, and all the other months, which happen to be more verbose.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: That seems straightforward, but I promised you a batveat. If a set of one or
    more question mark wildcards comes at the end of a file mask or if those question
    marks immediately precede a dot, Batch also considers a null to be a valid replacement
    value for each of the question marks.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, I’ll make a tweak to the file naming convention by inserting
    a period between the month and year, resulting in filenames such as these:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, I’ll insert the period into the file mask between the four question marks
    and the year like so:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Even some experienced Batch coders might expect the files for June and July
    only to satisfy this mask. They would be correct in that files for March, April,
    and all the other months denoted with more than four letters won’t be copied,
    but the file for May will also satisfy the mask. The first three wildcards match
    on each of the three letters in May, but the fourth question mark matches on a
    null or nonexistent character. Even the oddly named *Budget..2008.xlsx* satisfies
    this mask.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: The upshot is that when *n* question mark wildcards come at the end of a file
    mask or are followed by a dot, the mask is satisfied with zero to *n* characters.
    Otherwise, *n* question mark wildcards are satisfied with exactly *n* characters.
    It’s a very subtle oddity, and understanding it might save you hours of grief.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: To put a fine point on the difference between the two Batch wildcard characters,
    shot, shoot, shut, shunt, shallot, and even sht all satisfy the sh*t file mask.
    Of these words (and one nonword), only shot and shut satisfy the sh?t file mask.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Moving Files
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Moving a file is similar to copying a file; the only difference is that after
    a file is copied, it exists in two places, while after a file is moved, the original
    file is no more. The move command performs this task easily. It simply takes the
    source and the target as arguments, and you’ll usually see it with the /Y option
    to suppress the confirmation prompt for overwriting the target:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Plenty of old code still contains the move command, but it has been largely
    deprecated in favor of the robocopy command. The following command with the /MOV
    option is functionally equivalent to the previous move command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Removing the filename from this robocopy command moves all the files in the
    source folder, but nothing from the subfolders.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the /S option results in moving all of the contents in all the subfolders,
    even if the target subfolders need to be created:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This command moves all of the files. They are no longer at the source, but the
    source folder structure remains. Now this is where it gets a bit weird, worthy
    of a batveat. We’ve been discussing the /MOV option, which is obviously short
    for *move*, but a similarly named option called /MOVE stands for ... I guess *move
    with an E*. These two options are subtly different. The robocopy command with
    the /MOVE option truly moves files and directories.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'The addition of the E to the option deletes the source directory structure
    after copying all of the files to the destination:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: What we have is a /MOV option that moves files while copying subdirectories
    and a /MOVE option that moves both files and subdirectories. It isn’t particularly
    intuitive.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: When considering which command to use for a particular move, the robocopy command
    is the most efficient choice for all the same reasons mentioned in “xcopy vs.
    robocopy” on page 76. But like the xcopy command, the move command has the more
    straightforward return code and still has a place in the Batch ecosystem.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Files
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When files are no longer needed, it just makes sense to clean them up. The
    del command easily deletes one or more files. The /Q option, which again stands
    for *quiet* mode, prevents the interpreter from asking permission to delete the
    file. The command accepts multiple arguments of files to be deleted where you
    can use both explicit filenames and file masks. The following command deletes
    one specific file named *Junk.txt* and all files in the folder with the *.OLD*
    extension:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Use the /A option to select files for deletion based on their attributes. For
    example, delete only hidden files using the /AH option. Negating the logic, the
    /A-H option deletes only files that are *not* hidden. As always, use the help
    command for a complete list of options.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Delete all the files in a folder by simply using the directory as the argument
    to the del command, but the directory itself will still exist. You’ll need a different
    command for that, and I’ll share it in [Chapter 13](chapter13.xhtml).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Renaming Files
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ren and rename commands are Batch synonyms; that is, they are the same
    command. The first argument is the file to be renamed, and the second argument
    is the new filename:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the destination file already exists, the interpreter returns an errorlevel
    of 1. If there’s the possibility that a file with the same name is already there,
    I’ll quietly delete it prior to the rename:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Wildcards are supported even for this command, but I’ve used the ren command
    only for explicit filenames, primarily because the command doesn’t write a list
    of renamed files to the console. (If I have more than one file to rename, I’ll
    use a dir command as input into a for command and do the renames one by one. We’ll
    explore these commands further in [Chapters 13](chapter13.xhtml) and [17](chapter17.xhtml),
    respectively.)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The ren command isn’t complicated, but I’ve seen one common batveat far too
    often. It’s easy to use the path on both arguments, but when you reflect on this
    for a moment, the interpreter already knows the path from the first argument.
    The file isn’t being moved or copied anywhere; by the nature of this command,
    it’s being renamed in place. If the first argument doesn’t have a path, the current
    directory is assumed (more on that in the next chapter), but the second argument
    is the new filename only and should never have a path associated with it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter likely will become one that you reference most in this book. Batch
    would be nothing without the ability to create, copy, move, merge, and delete
    files, and I introduced a bevy of commands for those tasks here. Some of the commands
    I discussed are straightforward, but I covered more than one batveat along with
    solutions for mitigating them. You also learned how to execute these commands
    on multiple files at a time with the use of file masks and wildcards.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Copying a file might sound like a simple task, but I detailed the many techniques
    available and considerations at play. I hope that I showed you how powerful and
    useful the robocopy command really is, while also instilling in you an appreciation
    for the simplicity and usefulness of the xcopy command.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter I’ll describe how to execute a program compiled in another
    language, which will involve a deeper discussion about how the interpreter finds
    the program to execute when you don’t provide a path.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
