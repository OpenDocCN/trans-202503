- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: INTRODUCTION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Welcome to *The Art of ARM Assembly*. This book will teach you how to program
    64-bit ARM CPUs, such as those found in modern Apple macOS machines, ARM-based
    Linux systems (including the Raspberry Pi with a 64-bit version of Raspberry Pi
    OS, previously known as Raspbian, which I’ll just call Pi OS), and even mobile
    devices such as iPhones, iPads, and some Android devices. With the arrival of
    the ARM-based Apple macOS systems, the need to learn and understand 64-bit ARM
    assembly language increased dramatically, leading me to write this book. However,
    I’ve made the source code and other information in this book as portable as possible
    so that it applies to all 64-bit ARM machines.
  prefs: []
  type: TYPE_NORMAL
- en: This book is a sister volume to *The Art of 64-Bit Assembly*, which was, itself,
    a rewrite of *The Art of Assembly Language Programming* (*AoA*). *AoA* was a project
    I began way back in 1989 as a tool for teaching 80x86 (x86) assembly-language
    programming to students at California State Polytechnic University, Pomona, and
    the University of California, Riverside. For over 25 years, *AoA* served as a
    guide for learning x86 assembly language programming. During that time, other
    processors came and went, but x86 remained king of the hill in personal computers
    and high-end workstations, and x86 assembly language remained the de facto assembly
    language to learn. However, ARM-based PCs became mainstream with the introduction
    of the Apple M1-based systems (and later Apple machines), so the need to learn
    ARM assembly language programming is increasing.
  prefs: []
  type: TYPE_NORMAL
- en: This book was written using *The Art of 64-Bit Assembly* as a model for the
    material to cover. Anyone who has read my earlier books will find this book to
    be very familiar at a high level. Of course, the ARM instructions and assemblers—either
    the GNU assembler (Gas) or Apple’s Clang assembler (largely compatible with Gas)—are
    quite different from the x86 instructions and the Microsoft Macro Assembler (MASM).
    The low-level presentation and programming techniques are therefore also somewhat
    different.
  prefs: []
  type: TYPE_NORMAL
- en: 0.1 A Brief History of the ARM CPU
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ARM CPU has a long and storied history. It was first developed by Acorn
    Computers Ltd. in late 1983 as a replacement for the venerable 8-bit 6502 CPU
    used in its BBC Micro system. *ARM* originally stood for *Acorn RISC Machine*,
    though this was later changed to *Advanced RISC Machine* (*RISC* stands for *reduced
    instruction set computer*). That original design was largely a mind meld between
    the design described in the early University of California, Berkeley, RISC design
    and the 6502 CPU. For this reason, many would argue that the ARM initially wasn’t
    a pure RISC design. We might think of the ARM as the spiritual successor to the
    6502, inheriting many of the 6502’s features.
  prefs: []
  type: TYPE_NORMAL
- en: In many respects, the ARM CPU is modeled on the 6502 CPU’s notion of a reduced
    instruction set computer. In the original RISC design, each instruction was designed
    to do as little work as possible so it would require less hardware support and
    could run faster. Pure RISC architectures, for example, generally don’t use condition
    code bits (as setting condition codes after the execution of an instruction would
    require the CPU do extra work), and use fixed-size machine instruction encodings
    (typically 32 bits). The 6502, on the other hand, attempted to reduce the total
    *number* of machine instructions as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the original ARM supported both 16-bit and 32-bit instruction
    encodings. While pure RISC CPUs try to maximize the number of general-purpose
    registers (generally 32), the original ARM design supported only 16\. Furthermore,
    the ARM used one of the general-purpose registers as the program counter, which
    allows for all kinds of programming tricks but creates problems for pure RISC
    designs (such as handling exceptions). Finally, the ARM partially supported a
    hardware stack, something you don’t see on pure RISC machines. Nevertheless, “pure”
    or not, the ARM design outlasted all the other RISC CPUs of that era.
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, the ARM CPU variants have largely been used in mobile and embedded
    applications, with the vast majority of ARM CPUs winding up in mobile phones and
    tablets. However, one notable use is in the Raspberry Pi computer system (with
    over 61 million units sold as of this writing). In addition to the Pi, millions
    of ARM-based Arduino-compatible and other single-board computers (such as the
    Teensy series) have been sold. At the time of writing, the Raspberry Pi Foundation
    released the Raspberry Pi Pico, an ARM-based microcontroller board for $4 (US),
    selling more than 4 million of these devices by January 2024.
  prefs: []
  type: TYPE_NORMAL
- en: 0.2 Why Learn ARM Assembly?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RISC CPUs were designed to be programmed using high-level languages (especially
    C/C++). Very few programs of note have been written in RISC assembly language
    (though the original ARM Basic is a good counterexample). The main reason assembly
    language is taught in colleges and universities is to teach *machine organization*
    (an introduction to the machine’s architecture). In addition, some applications
    (or, at the very least, portions of some applications) can benefit from an assembly
    language implementation. Speed and space are the two main reasons for using assembly
    language, though it is also true that certain algorithms are more easily written
    in assembly language (particularly bit-handling operations).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, learning assembly language can help you write much better high-level
    language code. After all, a compiler for a language like C/C++ translates that
    high-level source code into assembly language. Understanding the underlying machine
    language will help you write better high-level language (HLL) code because you
    can avoid inefficient HLL constructs. This understanding can also be helpful when
    debugging or optimizing HLL code. Sometimes you must look at the code that the
    compiler generated to understand a bug or inefficiency.
  prefs: []
  type: TYPE_NORMAL
- en: So why a book on ARM assembly language in particular? Until the Apple Silicon
    M1 CPU came along, the only common personal computer using an ARM CPU was the
    Raspberry Pi. While the Pi was popular, it generally wasn’t being used in schools
    to teach machine organization and assembly language programming. A few hobbyists
    were probably interested in picking up ARM assembly language on their own, but
    most Pi programmers were using Scratch or Python, with the hard-core types programming
    in C/C++. While mobile devices such as iPhones, iPads, and Android phones and
    tablets are also popular, developers rarely consider switching from Objective-C,
    Swift, or Java into assembly language for applications on those devices.
  prefs: []
  type: TYPE_NORMAL
- en: However, once Apple released M1-based Mac minis, MacBooks, and iMacs, the situation
    changed. Interest in low-level programming on ARMs spiked, because now ARM assembly
    could be taught in colleges and universities on “normal” machines. Apple has sold
    more A-series (iPad and iPhone) and M-series (iPad and Mac) systems than Raspberry
    Pi since they were introduced. It is conceivable that Apple will have sold around
    a billion ARM-based personal computers and mobile devices by the time you’re reading
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Given these developments, a lot more people are going to be interested in assembly
    language programming on ARM CPUs. If you want to be able to write high-performance,
    efficient, and small code on this new crop of devices, learning ARM assembly language
    is the place to start.
  prefs: []
  type: TYPE_NORMAL
- en: 0.3 Why Learn 64-Bit ARM?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the original ARM was a 32-bit CPU, Arm Holdings—the outfit that licenses
    the ARM design—introduced a 64-bit version in 2011\. Apple introduced its 32-bit
    iPhone 5 a few years after that. Since then, most mobile and personal computer
    devices (including the Raspberry Pi 3, 4, and 400) have used 64-bit CPUs, while
    embedded devices have largely stuck with the 32-bit CPU variants. Code written
    for 32-bit CPUs is generally more memory efficient than that for 64-bit CPUs;
    unless an application requires more than 4GB, using a 32-bit instruction set is
    usually better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, for high-performance computing, 64 bits is definitely the future.
    Why is this the case? Can’t 64-bit ARM CPUs run the older 32-bit code? The answer
    is a qualified yes. For example, the Raspberry Pi provides a 32-bit OS that runs
    only 32-bit code, even when running on a 64-bit CPU such as on the Pi 3, 4, or
    400\. However, the 64-bit ARM CPUs (ARMv8 or AARCH64, informally abbreviated to
    ARM64) operate in one of two modes: 32-bit or 64-bit. When in 32-bit mode, they
    execute the 32-bit instruction set; when in 64-bit mode, they execute the 64-bit
    instruction set. Though these instruction sets have some similarities, they are
    not the same. Thus, when operating in one of these modes, you cannot execute the
    instructions from the other mode.'
  prefs: []
  type: TYPE_NORMAL
- en: Given the incompatibility of the two instruction sets, this book focuses on
    64-bit ARM assembly language. Since you can’t program the Apple M1 (and later)
    in 32-bit ARM assembly language, teaching 32-bit alone would be a nonstarter.
    Why not teach both? While knowing 32-bit assembly language would help readers
    who want to write code for the 32-bit Pi OS and other embedded single-board microcontrollers,
    this book aims to teach fundamentals. Teaching two different instruction sets
    complicates the educational experience; better to do one thing well (64-bit assembly)
    rather than two things poorly. Teaching both 32-bit and 64-bit assembly is almost
    like trying to teach x86-64 and ARM in the same book; it’s just too much to take
    in all at once. Moreover, the 32-bit operating modes will likely fade away entirely
    over time. As I write this, ARM has already introduced a variant that supports
    only 64-bit code; I expect all future desktop-class processors will head in this
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: '> NOTE'
  prefs: []
  type: TYPE_NORMAL
- en: '*Although concentrating on 64-bit ARM assembly language for desktop-class and
    mobile machines (such as iPhones) makes sense, some will want to learn 32-bit
    ARM assembly language to work with embedded devices. Arduino-based single-board
    computers (SBCs), Raspberry Pi Pico SBCs, and many other classes of ARM-based
    embedded systems use 32-bit ARM variants. Furthermore, if you’re operating a Raspberry
    Pi using a 32-bit version of Pi OS, you’ll need to use 32-bit ARM assembly language.
    For that reason,* The Art of ARM Assembly, Volume 2*, will cover 32-bit ARM assembly
    language on those systems.*'
  prefs: []
  type: TYPE_NORMAL
- en: 0.4 Expectations and Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book assumes that you are already comfortable programming in an HLL such
    as C/C++ (preferred), Python, Swift, Java, Pascal, Ruby, BASIC, or another object-oriented
    or imperative (procedural) programming language. Although many programmers have
    successfully learned assembly language as their very first programming language,
    I recommend that you learn to *program* first, then learn assembly language programming.
    This book makes use of several HLL examples (typically in C/C++ or Pascal). The
    examples are generally simple, so you should be able to understand them if you
    know a different HLL.
  prefs: []
  type: TYPE_NORMAL
- en: This book also assumes you’re comfortable with the edit/compile/test/debug cycle
    during program development. You should be familiar with source code editors and
    using standard software development tools, as I won’t explain how to edit source
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'A wide variety of 64-bit ARM systems are out there, and I aimed to make this
    book applicable to as many of them as possible. To that end, every example program
    in this book has been tested on each of the following systems:'
  prefs: []
  type: TYPE_NORMAL
- en: Apple M1-based Mac systems such as the Mac mini M1 and Mac mini M2\. The book’s
    example code was tested on the mini M1 but should work on any of the ARM-based
    MacBooks or iMacs, as well as future M*x* systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspberry Pi 3, 4, 400, and 5 systems (and future 64-bit-capable Pi systems)
    running the 64-bit version of Pi OS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PINE64 system including the Pinebook, Pinebook Pro, and ROCKPro 64.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Almost any 64-bit ARM-based Linux system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NVIDIA Jetson Nano systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In theory, it should be possible to apply the information in this book to ARM-based
    Windows machines (such as the Surface Laptop Copilot+). Unfortunately, Microsoft’s
    software development tools, particularly its assembler, are based on the original
    ARM assembly syntax defined by Arm (the company), not Gas. While Microsoft’s *armasm64*
    is a better tool in many respects (as it uses standard ARM assembly language syntax),
    everyone else uses Gas syntax. The machine instructions are more or less the same
    between the two sets of assemblers, but the other statements (known as *assembler
    directives* or *pseudo-opcodes*) are completely different. Therefore, example
    programs written in Gas will not assemble under *armasm64*, and vice versa. Since
    trying to present both syntax forms in example programs would be just as confusing
    as trying to teach 32- and 64-bit programming simultaneously, I stick to Gas syntax
    in my examples.
  prefs: []
  type: TYPE_NORMAL
- en: 0.5 Source Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This book contains considerable ARM assembly language (and some C/C++) source
    code that typically comes in one of three forms: code snippets, single assembly
    language procedures or functions (modules), or full-blown programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Code snippets* are fragments of a program; they are not stand-alone, and you
    cannot compile them by using an ARM assembler (or a C++ compiler, in the case
    of C/C++ source code). They exist to make a point or provide a small example of
    a particular programming technique. Here is a typical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The vertical ellipses denote arbitrary code that could appear in their place.
  prefs: []
  type: TYPE_NORMAL
- en: '*Modules* are small blocks of code that can be compiled but won’t run on their
    own. Modules typically contain a function that will be called by another program.
    Here is a typical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Full-blown programs are called *listings* in this book, and I refer to them
    by listing number or filename. A typical filename usually takes the form *Listing*C*-*N*.S*,
    where C is the chapter number and N is a listing number within that chapter. For
    example, the following *Listing1-1.S* is the first listing that appears in [Chapter
    1](chapter1.xhtml):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Although most listings take the form *Listing*C*-*N*.S*, some (especially those
    from external sources) simply consist of a descriptive filename, such as the *aoaa.inc*
    header file used by most of the sample programs in this book.
  prefs: []
  type: TYPE_NORMAL
- en: All listings are available in electronic form at *[https://<wbr>artofarm<wbr>.randallhyde<wbr>.com](https://artofarm.randallhyde.com)*,
    either individually or as a ZIP file containing all the listings found in this
    book. That page also contains support information for this book, including errata
    and PowerPoint slides for instructors.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the programs in this book run from a command line. These examples typically
    use the bash shell interpreter. Therefore, every build command and sample output
    will typically have the text prefix $ or % before any command you would type from
    the keyboard on the command line. Under macOS, the default shell (command line)
    program is zsh. It prints a percent sign (%) rather than $ as the prompt character.
    If you are completely unfamiliar with the Linux or macOS command line, please
    see [Appendix D](appendix-D.xhtml) for a quick introduction to the command line
    interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Unless otherwise noted, all source code appearing in this book is covered under
    the Creative Commons 4.0 license. You may freely use that code in your own projects
    as per the Creative Commons license. See *[https://<wbr>creativecommons<wbr>.org<wbr>/licenses<wbr>/by<wbr>/4<wbr>.0<wbr>/](https://creativecommons.org/licenses/by/4.0/)*
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 0.6 Typography and Pedantry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Computer books have a habit of abusing the English language. This book is no
    exception. Whenever source code snippets appear in the middle of an English sentence,
    a conflict often arises between the grammar rules of the programming language
    and English. This section describes my choices for differentiating syntactical
    rules in English versus programming languages, in addition to a few other conventions.
  prefs: []
  type: TYPE_NORMAL
- en: First, this book uses a monospaced font to denote any text that appears as part
    of a program source file. This includes variable and procedure functions, program
    output, and user input to a program. Therefore, when you see something like get,
    you know that the book is describing an identifier in a program, not commanding
    you to get something.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few logic operations have names that also have common English meanings: AND,
    OR, and NOT. When using these terms as logic functions, this book uses all caps
    to help differentiate otherwise-confusing English statements. When using these
    terms as English, this book uses the standard typeset font. The fourth logic operator,
    exclusive or (XOR), doesn’t normally appear in English statements, but this book
    still capitalizes it.'
  prefs: []
  type: TYPE_NORMAL
- en: In general, I always try to define any acronym or abbreviation the first time
    I use it. If I haven’t used the term in a while, I will often redefine it on that
    usage. The glossary in [Appendix B](appendix-B.xhtml) also includes most of the
    acronyms appearing in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 0.7 Organization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book is organized into 4 parts comprising 16 chapters and [6](chapter6.xhtml)
    appendixes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Part I](part1.xhtml), Machine Organization, covers data types and machine
    architecture for the ARM processor:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 1](chapter1.xhtml): Hello, World of Assembly Language**    Teaches
    you a small handful of instructions so you can experiment with the software development
    tools and write simple little programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 2](chapter2.xhtml): Data Representation and Operations**    Discusses
    the internal representation of simple data types such as integers, characters,
    and Boolean values. It also discusses the various arithmetic and logical operations
    possible on these data types. This chapter also introduces some basic ARM assembly
    language operand formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 3](chapter3.xhtml): Memory Access and Organization**    Discusses
    how the ARM organizes main memory. It explains the layout of memory and how to
    declare and access memory variables. It also introduces the ARM’s methods for
    accessing memory and the stack (a place to store temporary values).'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 4](chapter4.xhtml): Constants, Variables, and Data Types**    Describes
    how to declare named constants in assembly language, how to declare and use pointers,
    and the use of composite data structures such as strings, arrays, structs (records),
    and unions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Part II](part2.xhtml), Basic Assembly Language, provides the basic tools and
    instructions you need to write assembly language programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 5](chapter5.xhtml): Procedures**    Covers the instructions and
    syntax you need to write your own assembly language functions (procedures). This
    chapter describes how to pass arguments (parameters) to functions and return function
    results. It also describes how to declare (and use) local or automatic variables
    that you allocate on the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 6](chapter6.xhtml): Arithmetic**    Explains the basic integer arithmetic
    and logical operations in ARM assembly language. It also describes how to convert
    arithmetic expressions from an HLL into ARM assembly language. Finally, this chapter
    covers floating-point arithmetic using the hardware-based floating-point instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 7](chapter7.xhtml): Low-Level Control Structures**    Describes
    how to implement HLL-like control structures such as if, elseif, else, while,
    do...while (repeat...until), for, and switch in ARM assembly language. This chapter
    also touches on optimizing loops and other code in assembly language.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Part III](part3.xhtml), Advanced Assembly Language, covers more advanced assembly
    language operations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 8](chapter8.xhtml): Advanced Arithmetic**    Explores extended-precision
    arithmetic, mixed-mode arithmetic, and other advanced arithmetic operations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 9](chapter9.xhtml): Numeric Conversion**    Provides a very useful
    set of library functions you can use to convert numeric values to string format
    and convert string values to numeric format.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 10](chapter10.xhtml): Table Lookups**    Describes how to use memory-based
    lookup tables (arrays) to accelerate certain computations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 11](chapter11.xhtml): Neon and SIMD Programming**    Discusses the
    ARM Advanced SIMD instruction set that allows you to speed up certain applications
    by operating on multiple pieces of data at once.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 12](chapter12.xhtml): Bit Manipulation**    Describes various operations
    and functions that allow you to manipulate data at the bit level in ARM assembly
    language.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 13](chapter13.xhtml): Macros and the Gas Compile-Time Language**    Covers
    the Gas macro facilities. Macros are powerful constructs enabling you to design
    your own assembly language statements that expand to a large number of individual
    ARM assembly language instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 14](chapter14.xhtml): String Operations**    Explains the use and
    creation of various character string library functions in ARM assembly language.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 15](chapter15.xhtml): Managing Complex Projects**    Describes how
    to create libraries of assembly language code, and build those libraries by using
    makefiles (along with a discussion of the make language).'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 16](chapter16.xhtml): Stand-Alone Assembly Language Programs**    Shows
    how to write assembly language applications that don’t use the C/C++ standard
    library for I/O and other operations. This chapter includes system call examples
    for both Linux (Pi OS) and macOS.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Part IV](part4.xhtml), Reference Materials, provides reference information,
    including a table listing the full ASCII character set, a glossary, instructions
    for installing and using Gas on your system, an introduction to the bash shell
    interpreter, useful C/C++ functions you can call from your assembly language programs,
    and answers to the questions at the end of each chapter.'
  prefs: []
  type: TYPE_NORMAL
