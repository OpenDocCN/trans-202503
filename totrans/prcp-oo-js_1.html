<html><head></head><body><section class="chapter" title="Chapter&#xA0;1.&#xA0;Primitive and Reference Types" epub:type="chapter" id="primitive_and_reference_types"><div class="titlepage"><div><div><h2 class="title">Chapter 1. Primitive and Reference Types</h2></div></div></div><p><a id="iddle1047" class="indexterm"/>Most developers learn object-oriented programming by working with class-based languages such as Java or C#. When these developers start learning JavaScript, they get disoriented because JavaScript has no formal support for classes. Instead of defining classes from the beginning, with JavaScript you can just write code and create data structures as you need them. Because it lacks classes, JavaScript also lacks class groupings such as packages. Whereas in languages like Java, package and class names define both the types of objects you use and the layout of files and folders in your project, programming in JavaScript is like starting with a blank slate: You can <a id="iddle1077" class="indexterm"/><a id="iddle1109" class="indexterm"/><a id="iddle1110" class="indexterm"/><a id="iddle1124" class="indexterm"/><a id="iddle1156" class="indexterm"/><a id="iddle1233" class="indexterm"/><a id="iddle1244" class="indexterm"/><a id="iddle1260" class="indexterm"/><a id="iddle1315" class="indexterm"/><a id="iddle1372" class="indexterm"/><a id="iddle1384" class="indexterm"/>organize things any way you want. Some developers choose to mimic structures from other languages, while others take advantage of JavaScript’s flexibility to come up with something completely new. To the uninitiated, this freedom of choice can be overwhelming, but once you get used to it, you’ll find JavaScript to be an incredibly flexible language that can adapt to your preferences quite easily.</p><p>To ease the transition from traditional object-oriented languages, JavaScript makes objects the central part of the language. Almost all data in JavaScript is either an object or accessed through objects. In fact, even functions (which languages traditionally make you jump through hoops to get references to) are represented as objects in JavaScript, which makes them <span class="emphasis"><em>first-class functions</em></span>.</p><p>Working with and understanding objects is key to understanding JavaScript as a whole. You can create objects at any time and add or remove properties from them whenever you want. In addition, JavaScript objects are extremely flexible and have capabilities that create unique and interesting patterns that are simply not possible in other languages.</p><p>This chapter focuses on how to identify and work with the two primary JavaScript data types: primitive types and reference types. Though both are accessed through objects, they behave in different ways that are important to understand.</p><div class="sect1" title="What Are Types?"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="what_are_typesquestion_mark">What Are Types?</h2></div></div></div><p>Although JavaScript has no concept of classes, it still uses two kinds of <span class="emphasis"><em>types</em></span>: primitive and reference. <span class="emphasis"><em>Primitive types</em></span> are stored as simple data types. <span class="emphasis"><em>Reference types</em></span> are stored as objects, which are really just references to locations in memory.</p><p>The tricky thing is that JavaScript lets you treat primitive types like reference types in order to make the language more consistent for the developer.</p><p>While other programming languages distinguish between primitive and reference types by storing primitives on the stack and references in the heap, JavaScript does away with this concept completely: It tracks variables for a particular scope with a <span class="emphasis"><em>variable object</em></span>. Primitive values are stored directly on the variable object, while reference values are placed as a pointer in the variable object, which serves as a reference to a location in memory where the object is stored. However, as you’ll see later in this chapter, primitive values and reference values behave quite differently although they may initially seem the same.</p><p>Of course, there are other differences between primitive and reference types.</p></div><div class="sect1" title="Primitive Types"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="primitive_types">Primitive Types</h2></div></div></div><p><a id="iddle1033" class="indexterm"/><a id="iddle1175" class="indexterm"/><a id="iddle1202" class="indexterm"/><a id="iddle1208" class="indexterm"/><a id="iddle1261" class="indexterm"/><a id="iddle1348" class="indexterm"/><a id="iddle1376" class="indexterm"/><a id="iddle1385" class="indexterm"/>Primitive types represent simple pieces of data that are stored as is, such as <code class="literal">true</code> and 25. There are five primitive types in JavaScript:</p><div class="informaltable"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/></colgroup><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Boolean</strong></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">true</code> or <code class="literal">false</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Number</strong></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Any integer or floating-point numeric value</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>String</strong></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>A character or sequence of characters delimited by either single or double quotes (JavaScript has no separate character type)</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Null</strong></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>A primitive type that has only one value, <code class="literal">null</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p><span class="strong"><strong>Undefined</strong></span></p></td><td style="vertical-align: top; "><p>A primitive type that has only one value, <code class="literal">undefined (undefined</code> is the value assigned to a variable that is not initialized)</p></td></tr></tbody></table></div><p>The first three types (Boolean, number, and string) behave in similar ways, while the last two (null and undefined) work a bit differently, as will be discussed throughout this chapter. All primitive types have literal representations of their values. <span class="emphasis"><em>Literals</em></span> represent values that aren’t stored in a variable, such as a hardcoded name or price. Here are some examples of each type using its literal form:</p><a id="pro_id00002"/><pre class="programlisting"><span class="pd_green1"><code class="c1">// strings</code></span>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">;</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">selection</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"a"</code></span><code class="p">;</code>

<span class="pd_green1"><code class="c1">// numbers</code></span>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">count</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_ash"><code class="mi">25</code></span><code class="p">;</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">cost</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_ash"><code class="mf">1.51</code></span><code class="p">;</code>

<span class="pd_green1"><code class="c1">// boolean</code></span>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">found</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kc">true</code></span><code class="p">;</code>

<span class="pd_green1"><code class="c1">// null</code></span>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">object</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kc">null</code></span><code class="p">;</code>

<span class="pd_green1"><code class="c1">// undefined</code></span>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">flag</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kc">undefined</code></span><code class="p">;</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">ref</code><code class="p">;</code>    <span class="pd_green1"><code class="c1">// assigned undefined automatically</code></span></pre><p>In JavaScript, as in many other languages, a variable holding a primitive directly contains the primitive value (rather than a pointer to an object). When you assign a primitive value to a variable, the value is copied into that variable. This means that if you set one variable equal to another, each variable gets its own copy of the data. For example:</p><a id="pro_id00003"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">color1</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"red"</code></span><code class="p">;</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">color2</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">color1</code><code class="p">;</code></pre><p><a id="iddle1370" class="indexterm"/>Here, <code class="literal">color1</code> is assigned the value of <code class="literal">"red"</code>. The variable <code class="literal">color2</code> is then assigned the value <code class="literal">color1</code>, which stores <code class="literal">"red"</code> in <code class="literal">color2</code>. Even though <code class="literal">color1</code> and <code class="literal">color2</code> contain the same value, they are completely separate from each other, and you can change the value in <code class="literal">color1</code> without affecting <code class="literal">color2</code> and vice versa. That’s because there are two different storage locations, one for each variable. <a class="xref" href="ch01.html#variable_object" title="Figure 1-1. Variable object">Figure 1-1</a> illustrates the variable object for this snippet of code.</p><div class="figure"><a id="variable_object"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00001"/><img src="figs/web/oojs01_01.png.jpg" alt="Variable object"/></div></div><div class="figure-title">Figure 1-1. Variable object</div></div><p>Because each variable containing a primitive value uses its own storage space, changes to one variable are not reflected on the other. For example:</p><a id="pro_id00004"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">color1</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"red"</code></span><code class="p">;</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">color2</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">color1</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">color1</code><code class="p">);</code>    <span class="pd_green1"><code class="c1">// "red"</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">color2</code><code class="p">);</code>    <span class="pd_green1"><code class="c1">// "red"</code></span>

<code class="nx">color1</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"blue"</code></span><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">color1</code><code class="p">);</code>    <span class="pd_green1"><code class="c1">// "blue"</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">color2</code><code class="p">);</code>    <span class="pd_green1"><code class="c1">// "red"</code></span></pre><p>In this code, <code class="literal">color1</code> is changed to <code class="literal">"blue"</code> and <code class="literal">color2</code> retains its original value of <code class="literal">"red"</code>.</p><div class="sect2" title="Identifying Primitive Types"><div class="titlepage"><div><div><h3 class="title" id="identifying_primitive_types">Identifying Primitive Types</h3></div></div></div><p>The best way to identify primitive types is with the <code class="literal">typeof</code> operator, which works on any variable and returns a string indicating the type of data. The <code class="literal">typeof</code> operator works well with strings, numbers, Booleans, and <code class="literal">undefined</code>. The following shows the output when using <code class="literal">typeof</code> on different primitive values:</p><a id="pro_id00005"/><pre class="programlisting"><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">typeof</code></span> <span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">);</code>     <span class="pd_green1"><code class="c1">// "string"</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">typeof</code></span> <span class="pd_ash"><code class="mi">10</code></span><code class="p">);</code>             <span class="pd_green1"><code class="c1">// "number"</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">typeof</code></span> <span class="pd_ash"><code class="mf">5.1</code></span><code class="p">);</code>            <span class="pd_green1"><code class="c1">// "number"</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">typeof</code> <code class="kc">true</code></span><code class="p">);</code>           <span class="pd_green1"><code class="c1">// "boolean"</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">typeof</code> <code class="kc">undefined</code></span><code class="p">);</code>      <span class="pd_green1"><code class="c1">// "undefined"</code></span></pre><p><a id="iddle1003" class="indexterm"/><a id="iddle1004" class="indexterm"/><a id="iddle1050" class="indexterm"/><a id="iddle1093" class="indexterm"/><a id="iddle1100" class="indexterm"/><a id="iddle1203" class="indexterm"/><a id="iddle1206" class="indexterm"/><a id="iddle1368" class="indexterm"/>As you might expect, <code class="literal">typeof</code> returns <code class="literal">"string"</code> when the value is a string; <code class="literal">"number"</code> when the value is a number (regardless of integer or floating-point values); <code class="literal">"boolean"</code> when the value is a Boolean; and <code class="literal">"undefined"</code> when the value is undefined.</p><p>The tricky part involves <code class="literal">null</code>.</p><p>You wouldn’t be the first developer to be confused by the result of this line of code:</p><a id="pro_id00006"/><pre class="programlisting"><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">typeof</code> <code class="kc">null</code></span><code class="p">);</code>        <span class="pd_green1"><code class="c1">// "object"</code></span></pre><p>When you run <code class="literal">typeof null</code>, the result is <code class="literal">"object"</code>. But why an object when the type is <code class="literal">null</code>? (In fact, this has been acknowledged as an error by TC39, the committee that designs and maintains JavaScript. You could reason that <code class="literal">null</code> is an empty object pointer, making <code class="literal">"object"</code> a logical return value, but that’s still confusing.)</p><p>The best way to determine if a value is <code class="literal">null</code> is to compare it against <code class="literal">null</code> directly, like this:</p><a id="pro_id00007"/><pre class="programlisting"><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code> <span class="pd_ash"><code class="o">===</code></span> <span class="pd_green"><code class="kc">null</code></span><code class="p">);</code>        <span class="pd_green1"><code class="c1">// true or false</code></span></pre><div class="sidebar"><a id="comparing_without_coercion"/><div class="sidebar-title">Comparing Without Coercion</div><p>Notice that this code uses the triple equals operator (<code class="literal">===</code>) instead of the double equals operator. The reason is that triple equals does the comparison without coercing the variable to another type. To understand why this is important, consider the following:</p><a id="pro_id00008"/><pre class="programlisting"><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_red"><code class="s2">"5"</code></span> <span class="pd_ash"><code class="o">==</code> <code class="mi">5</code></span><code class="p">);</code>              <span class="pd_green1"><code class="c1">// true</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_red"><code class="s2">"5"</code></span> <span class="pd_ash"><code class="o">===</code> <code class="mi">5</code></span><code class="p">);</code>             <span class="pd_green1"><code class="c1">// false</code></span>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="kc">undefined</code></span> <span class="pd_ash"><code class="o">==</code></span> <span class="pd_green"><code class="kc">null</code></span><code class="p">);</code>     <span class="pd_green1"><code class="c1">// true</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="kc">undefined</code></span> <span class="pd_ash"><code class="o">===</code></span> <span class="pd_green"><code class="kc">null</code></span><code class="p">);</code>    <span class="pd_green1"><code class="c1">// false</code></span></pre><p>When you use the double equals, the string <code class="literal">"5"</code> and the number <code class="literal">5</code> are considered equal because the double equals converts the string into a number before it makes the comparison. The triple equals operator doesn’t consider these values equal because they are two different types. Likewise, when you compare <code class="literal">undefined</code> and <code class="literal">null</code>, the double equals says that they are equivalent, while the triple equals says they are not. When you’re trying to identify <code class="literal">null</code>, use triple equals so that you can correctly identify the type.</p></div></div><div class="sect2" title="Primitive Methods"><div class="titlepage"><div><div><h3 class="title" id="primitive_methods">Primitive Methods</h3></div></div></div><p><a id="iddle1046" class="indexterm"/><a id="iddle1057" class="indexterm"/><a id="iddle1072" class="indexterm"/><a id="iddle1159" class="indexterm"/><a id="iddle1161" class="indexterm"/><a id="iddle1182" class="indexterm"/><a id="iddle1185" class="indexterm"/><a id="iddle1195" class="indexterm"/><a id="iddle1234" class="indexterm"/><a id="iddle1236" class="indexterm"/><a id="iddle1259" class="indexterm"/><a id="iddle1267" class="indexterm"/><a id="iddle1316" class="indexterm"/><a id="iddle1347" class="indexterm"/><a id="iddle1349" class="indexterm"/><a id="iddle1362" class="indexterm"/><a id="iddle1363" class="indexterm"/><a id="iddle1364" class="indexterm"/>Despite the fact that they’re primitive types, strings, numbers, and Booleans actually have methods. (The <code class="literal">null</code> and <code class="literal">undefined</code> types have no methods.) Strings, in particular, have numerous methods to help you work with them. For example:</p><a id="pro_id00009"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">;</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">lowercaseName</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">name</code><code class="p">.</code><code class="nx">toLowerCase</code><code class="p">();</code>     <span class="pd_green1"><code class="c1">// convert to lowercase</code></span>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">firstLetter</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">name</code><code class="p">.</code><code class="nx">charAt</code><code class="p">(</code><span class="pd_ash"><code class="mi">0</code></span><code class="p">);</code>           <span class="pd_green1"><code class="c1">// get first character</code></span>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">middleOfName</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">name</code><code class="p">.</code><code class="nx">substring</code><code class="p">(</code><span class="pd_ash"><code class="mi">2</code></span><code class="p">,</code> <span class="pd_ash"><code class="mi">5</code></span><code class="p">);</code>    <span class="pd_green1"><code class="c1">// get characters 2-4</code></span>

<span class="pd_green"><code class="kd">var</code></span> <code class="nx">count</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_ash"><code class="mi">10</code></span><code class="p">;</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">fixedCount</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">count</code><code class="p">.</code><code class="nx">toFixed</code><code class="p">(</code><span class="pd_ash"><code class="mi">2</code></span><code class="p">);</code>          <span class="pd_green1"><code class="c1">// convert to "10.00"</code></span>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">hexCount</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">count</code><code class="p">.</code><code class="nx">toString</code><code class="p">(</code><span class="pd_ash"><code class="mi">16</code></span><code class="p">);</code>          <span class="pd_green1"><code class="c1">// convert to "a"</code></span>

<span class="pd_green"><code class="kd">var</code></span> <code class="nx">flag</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kc">true</code></span><code class="p">;</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">stringFlag</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">flag</code><code class="p">.</code><code class="nx">toString</code><code class="p">();</code>           <span class="pd_green1"><code class="c1">// convert to "true"</code></span></pre><div class="note" title="Note"><h3 class="title"><a id="ch01note01"/>Note</h3><p><span class="emphasis"><em>Despite the fact that they have methods, primitive values themselves are not objects. JavaScript makes them look like objects to provide a consistent experience in the language, as you’ll see later in this chapter.</em></span></p></div></div></div><div class="sect1" title="Reference Types"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="reference_types">Reference Types</h2></div></div></div><p>Reference types represent objects in JavaScript and are the closest things to classes that you will find in the language. Reference values are <span class="emphasis"><em>instances</em></span> of reference types and are synonymous with objects (the rest of this chapter refers to reference values simply as <span class="emphasis"><em>objects</em></span>). An object is an unordered list of <span class="emphasis"><em>properties</em></span> consisting of a name (always a string) and a value. When the value of a property is a function, it is called a <span class="emphasis"><em>method</em></span>. Functions themselves are actually reference values in JavaScript, so there’s little difference between a property that contains an array and one that contains a function except that a function can be executed.</p><p>Of course, you must create objects before you can begin working with them.</p><div class="sect2" title="Creating Objects"><div class="titlepage"><div><div><h3 class="title" id="creating_objects">Creating Objects</h3></div></div></div><p>It sometimes helps to think of JavaScript objects as nothing more than hash tables, as shown in <a class="xref" href="ch01.html#structure_of_an_object" title="Figure 1-2. Structure of an object">Figure 1-2</a>.</p><div class="figure"><a id="structure_of_an_object"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00002"/><img src="figs/web/oojs01_02.png.jpg" alt="Structure of an object"/></div></div><div class="figure-title">Figure 1-2. Structure of an object</div></div><p>There are a couple of ways to create, or <span class="emphasis"><em>instantiate</em></span>, objects. The first is to use the <code class="literal">new</code> operator with a <span class="emphasis"><em>constructor</em></span>. (A constructor is simply a function that uses <code class="literal">new</code> to create an object—any function can be <a id="iddle1090" class="indexterm"/><a id="iddle1131" class="indexterm"/><a id="iddle1181" class="indexterm"/><a id="iddle1204" class="indexterm"/><a id="iddle1237" class="indexterm"/><a id="iddle1256" class="indexterm"/>a constructor.) By convention, constructors in JavaScript begin with a capital letter to distinguish them from nonconstructor functions. For example, this code instantiates a generic object and stores a reference to it in <code class="literal">object</code>:</p><a id="pro_id00010"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">object</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">Object</code></span><code class="p">();</code></pre><p>Reference types do not store the object directly into the variable to which it is assigned, so the <code class="literal">object</code> variable in this example doesn’t actually contain the object instance. Instead, it holds a pointer (or reference) to the location in memory where the object exists. This is the primary difference between objects and primitive values, as the primitive is stored directly in the variable.</p><p>When you assign an object to a variable, you’re actually assigning a pointer. That means if you assign one variable to another, each variable gets a copy of the pointer, and both still reference the same object in memory. For example:</p><a id="pro_id00011"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">object1</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">Object</code></span><code class="p">();</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">object2</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">object1</code><code class="p">;</code></pre><p>This code first creates an object (with <code class="literal">new</code>) and stores a reference in <code class="literal">object1</code>. Next, <code class="literal">object2</code> is assigned the value of <code class="literal">object1</code>. There is still only the one instance of the object that was created on the first line, but both variables now point to that object, as illustrated in <a class="xref" href="ch01.html#two_variables_pointing_to_one_object" title="Figure 1-3. Two variables pointing to one object">Figure 1-3</a>.</p><div class="figure"><a id="two_variables_pointing_to_one_object"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00003"/><img src="figs/web/oojs01_03-new.png" alt="Two variables pointing to one object"/></div></div><div class="figure-title">Figure 1-3. Two variables pointing to one object</div></div></div><div class="sect2" title="Dereferencing Objects"><div class="titlepage"><div><div><h3 class="title" id="dereferencing_objects">Dereferencing Objects</h3></div></div></div><p>JavaScript is a garbage-collected language, so you don’t really need to worry about memory allocations when you use reference types. However, it’s best to <span class="emphasis"><em>dereference</em></span> objects that you no longer need so that the garbage collector can free up that memory. The best way to do this is to set the object variable to <code class="literal">null</code>.</p><a id="pro_id00012"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">object1</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">Object</code></span><code class="p">();</code>

<span class="pd_green1"><code class="c1">// do something</code></span>

<code class="nx">object1</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kc">null</code></span><code class="p">;</code>     <span class="pd_green1"><code class="c1">// dereference</code></span></pre><p><a id="iddle1013" class="indexterm"/><a id="iddle1021" class="indexterm"/><a id="iddle1040" class="indexterm"/><a id="iddle1081" class="indexterm"/><a id="iddle1160" class="indexterm"/><a id="iddle1270" class="indexterm"/><a id="iddle1322" class="indexterm"/><a id="iddle1375" class="indexterm"/>Here, <code class="literal">object1</code> is created and used before finally being set to <code class="literal">null</code>. When there are no more references to an object in memory, the garbage collector can use that memory for something else. (Dereferencing objects is especially important in very large applications that use millions of objects.)</p></div><div class="sect2" title="Adding or Removing Properties"><div class="titlepage"><div><div><h3 class="title" id="adding_or_removing_properties">Adding or Removing Properties</h3></div></div></div><p>Another interesting aspect of objects in JavaScript is that you can add and remove properties at any time. For example:</p><a id="pro_id00013"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">object1</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">Object</code></span><code class="p">();</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">object2</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">object1</code><code class="p">;</code>

<code class="nx">object1</code><code class="p">.</code><code class="nx">myCustomProperty</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"Awesome!"</code></span><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">object2</code><code class="p">.</code><code class="nx">myCustomProperty</code><code class="p">);</code>      <span class="pd_green1"><code class="c1">// "Awesome!"</code></span></pre><p>Here, <code class="literal">myCustomProperty</code> is added to <code class="literal">object1</code> with a value of <code class="literal">"Awesome!"</code>. That property is also accessible on <code class="literal">object2</code> because both <code class="literal">object1</code> and <code class="literal">object2</code> point to the same object.</p><div class="note" title="Note"><h3 class="title"><a id="ch01note02"/>Note</h3><p><span class="emphasis"><em>This example demonstrates one particularly unique aspect of JavaScript: You can modify objects whenever you want, even if you didn’t define them in the first place. And there are ways to prevent such modifications, as you’ll learn later in this book.</em></span></p></div><p>In addition to generic object reference types, JavaScript has several other built-in types that are at your disposal.</p></div></div><div class="sect1" title="Instantiating Built-in Types"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="instantiating_built-in_types">Instantiating Built-in Types</h2></div></div></div><p>You’ve seen how to create and interact with generic objects created with <code class="literal">new Object()</code>. The <code class="literal">Object</code> type is just one of a handful of built-in reference types that JavaScript provides. The other built-in types are more specialized in their intended usage and can be instantiated at any time.</p><p>The built-in types are:</p><div class="informaltable"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/></colgroup><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong><code class="literal">Array</code></strong></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>An ordered list of numerically indexed values</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong><code class="literal">Date</code></strong></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>A date and time<a id="iddle1002" class="indexterm"/><a id="iddle1023" class="indexterm"/><a id="iddle1037" class="indexterm"/><a id="iddle1101" class="indexterm"/><a id="iddle1119" class="indexterm"/><a id="iddle1176" class="indexterm"/><a id="iddle1179" class="indexterm"/><a id="iddle1200" class="indexterm"/><a id="iddle1209" class="indexterm"/><a id="iddle1225" class="indexterm"/><a id="iddle1280" class="indexterm"/><a id="iddle1319" class="indexterm"/><a id="iddle1343" class="indexterm"/></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong><code class="literal">Error</code></strong></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>A runtime error (there are also several more specific error subtypes)</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong><code class="literal">Function</code></strong></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>A function</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong><code class="literal">Object</code></strong></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>A generic object</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p><span class="strong"><strong><code class="literal">RegExp</code></strong></span></p></td><td style="vertical-align: top; "><p>A regular expression</p></td></tr></tbody></table></div><p>You can instantiate each built-in reference type using <code class="literal">new</code>, as shown here:</p><a id="pro_id00014"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">items</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">Array</code></span><code class="p">();</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">now</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">Date</code></span><code class="p">();</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">error</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">Error</code></span><code class="p">(</code><span class="pd_red"><code class="s2">"Something bad happened."</code></span><code class="p">);</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">func</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">Function</code></span><code class="p">(</code><span class="pd_red"><code class="s2">"console.log('Hi');"</code></span><code class="p">);</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">object</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">Object</code></span><code class="p">();</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">re</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">RegExp</code></span><code class="p">(</code><span class="pd_red"><code class="s2">"\\d+"</code></span><code class="p">);</code></pre><div class="sect2" title="Literal Forms"><div class="titlepage"><div><div><h3 class="title" id="literal_forms">Literal Forms</h3></div></div></div><p>Several built-in reference types have literal forms. A <span class="emphasis"><em>literal</em></span> is syntax that allows you to define a reference value without explicitly creating an object, using the <code class="literal">new</code> operator and the object’s constructor. (Earlier in this chapter, you saw examples of primitive literals including string literals, numeric literals, Boolean literals, the <code class="literal">null</code> literal, and the <code class="literal">undefined</code> literal.)</p></div><div class="sect2" title="Object and Array Literals"><div class="titlepage"><div><div><h3 class="title" id="object_and_array_literals">Object and Array Literals</h3></div></div></div><p>To create an object with <span class="emphasis"><em>object literal</em></span> syntax, you can define the properties of a new object inside braces. Properties are made up of an identifier or string, a colon, and a value, with multiple properties separated by commas. For example:</p><a id="pro_id00015"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">book</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{</code>
    <code class="nx">name</code><code class="o">:</code> <span class="pd_red"><code class="s2">"The Principles of Object-Oriented JavaScript"</code></span><code class="p">,</code>
    <code class="nx">year</code><code class="o">:</code> <span class="pd_ash"><code class="mi">2014</code></span>
<code class="p">};</code></pre><p>You can also use string literals as property names, which is useful when you want a property name to have spaces or other special characters:</p><a id="pro_id00016"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">book</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{</code>
    <span class="pd_red"><code class="s2">"name"</code></span><span class="pd_ash"><code class="o">:</code></span> <span class="pd_red"><code class="s2">"The Principles of Object-Oriented JavaScript"</code></span><code class="p">,</code>
    <span class="pd_red"><code class="s2">"year"</code></span><span class="pd_ash"><code class="o">:</code></span> <span class="pd_ash"><code class="mi">2014</code></span>
<code class="p">};</code></pre><p><a id="iddle1005" class="indexterm"/><a id="iddle1120" class="indexterm"/><a id="iddle1123" class="indexterm"/><a id="iddle1177" class="indexterm"/><a id="iddle1178" class="indexterm"/><a id="iddle1337" class="indexterm"/>This example is equivalent to the previous one despite the syntactic differences. Both examples are also logically equivalent to the following:</p><a id="pro_id00017"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">book</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">Object</code></span><code class="p">();</code>
<code class="nx">book</code><code class="p">.</code><code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"The Principles of Object-Oriented JavaScript"</code></span><code class="p">;</code>
<code class="nx">book</code><code class="p">.</code><code class="nx">year</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_ash"><code class="mi">2014</code></span><code class="p">;</code></pre><p>The outcome of each of the previous three examples is the same: an object with two properties. The choice of pattern is up to you because the functionality is ultimately the same.</p><div class="note" title="Note"><h3 class="title"><a id="ch01note03"/>Note</h3><p><span class="emphasis"><em>Using an object literal doesn’t actually call new Object(). Instead, the JavaScript engine follows the same steps it does when using new Object() without actually calling the constructor. This is true for all reference literals.</em></span></p></div><p>You can define an <span class="emphasis"><em>array literal</em></span> in a similar way by enclosing any number of comma-separated values inside square brackets. For example:</p><a id="pro_id00018"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">colors</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">[</code> <span class="pd_red"><code class="s2">"red"</code></span><code class="p">,</code> <span class="pd_red"><code class="s2">"blue"</code></span><code class="p">,</code> <span class="pd_red"><code class="s2">"green"</code></span> <code class="p">];</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">colors</code><code class="p">[</code><span class="pd_ash"><code class="mi">0</code></span><code class="p">]);</code>     <span class="pd_green1"><code class="c1">// "red"</code></span></pre><p>This code is equivalent to the following:</p><a id="pro_id00019"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">colors</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">Array</code></span><code class="p">(</code><span class="pd_red"><code class="s2">"red"</code></span><code class="p">,</code> <span class="pd_red"><code class="s2">"blue"</code></span><code class="p">,</code> <span class="pd_red"><code class="s2">"green"</code></span><code class="p">)</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">colors</code><code class="p">[</code><span class="pd_ash"><code class="mi">0</code></span><code class="p">]);</code>     <span class="pd_green1"><code class="c1">// "red"</code></span></pre></div><div class="sect2" title="Function Literals"><div class="titlepage"><div><div><h3 class="title" id="function_literals">Function Literals</h3></div></div></div><p>You almost always define functions using their literal form. In fact, using the <code class="literal">Function</code> constructor is typically discouraged given the challenges of maintaining, reading, and debugging a string of code rather than actual code, so you’ll rarely see it in code.</p><p>Creating functions is much easier and less error prone when you use the literal form. For example:</p><a id="pro_id00020"/><pre class="programlisting"><span class="pd_green"><code class="kd">function</code></span> <code class="nx">reflect</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <span class="pd_green"><code class="k">return</code></span> <code class="nx">value</code><code class="p">;</code>
<code class="p">}</code>

<span class="pd_green1"><code class="c1">// is the same as</code></span>

<span class="pd_green"><code class="kd">var</code></span> <code class="nx">reflect</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">Function</code></span><code class="p">(</code><span class="pd_red"><code class="s2">"value"</code></span><code class="p">,</code> <span class="pd_red"><code class="s2">"return value;"</code></span><code class="p">);</code></pre><p>This code defines the <code class="literal">reflect()</code> function, which returns any value passed to it. Even in the case of this simple function, the literal form is easier to write and understand than the constructor form. Further, there <a id="iddle1006" class="indexterm"/><a id="iddle1038" class="indexterm"/><a id="iddle1092" class="indexterm"/><a id="iddle1180" class="indexterm"/><a id="iddle1268" class="indexterm"/><a id="iddle1320" class="indexterm"/><a id="iddle1321" class="indexterm"/><a id="iddle1338" class="indexterm"/>is no good way to debug functions that are created in the constructor form: These functions aren’t recognized by JavaScript debuggers and therefore act as a black box in your application.</p></div><div class="sect2" title="Regular Expression Literals"><div class="titlepage"><div><div><h3 class="title" id="regular_expression_literals">Regular Expression Literals</h3></div></div></div><p>JavaScript also has <span class="emphasis"><em>regular expression literals</em></span> that allow you to define regular expressions without using the <code class="literal">RegExp</code> constructor. Regular expression literals look very similar to regular expressions in Perl: The pattern is contained between two slashes, and any additional options are single characters following the second slash. For example:</p><a id="pro_id00021"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">numbers</code> <span class="pd_ash"><code class="o">=</code></span> <span class="red1"><code class="sr">/\d+/g</code></span><code class="p">;</code>

<span class="pd_green1"><code class="c1">// is the same as</code></span>

<span class="pd_green"><code class="kd">var</code></span> <code class="nx">numbers</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">RegExp</code></span><code class="p">(</code><span class="pd_red"><code class="s2">"\\d+"</code></span><code class="p">,</code> <span class="pd_red"><code class="s2">"g"</code></span><code class="p">);</code></pre><p>The literal form of regular expressions in JavaScript is a bit easier to deal with than the constructor form because you don’t need to worry about escaping characters within strings. When using the <code class="literal">RegExp</code> constructor, you pass the pattern in as a string, so you have to escape any backslashes. (That’s why <code class="literal">\d</code> is used in the literal and <code class="literal">\\d</code> is used in the constructor.) Regular expression literals are preferred over the constructor form in JavaScript except when the regular expression is being constructed dynamically from one or more strings.</p><p>That said, with the exception of <code class="literal">Function</code>, there really isn’t any right or wrong way to instantiate built-in types. Many developers prefer literals, while some prefer constructors. Choose whichever method you find more comfortable to use.</p></div></div><div class="sect1" title="Property Access"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="property_access">Property Access</h2></div></div></div><p>Properties are name/value pairs that are stored on an object. Dot notation is the most common way to access properties in JavaScript (as in many object-oriented languages), but you can also access properties on JavaScript objects by using bracket notation with a string.</p><p>For example, you could write this code, which uses dot notation:</p><a id="pro_id00022"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">array</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">[];</code>
<code class="nx">array</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><span class="pd_ash"><code class="mi">12345</code></span><code class="p">);</code></pre><p>With bracket notation, the name of the method is now included in a string enclosed by square brackets, as in this example:</p><a id="pro_id00023"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">array</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">[];</code>
<code class="nx">array</code><code class="p">[</code><span class="pd_red"><code class="s2">"push"</code></span><code class="p">](</code><span class="pd_ash"><code class="mi">12345</code></span><code class="p">);</code></pre><p><a id="iddle1154" class="indexterm"/><a id="iddle1317" class="indexterm"/><a id="iddle1371" class="indexterm"/>This syntax is very useful when you want to dynamically decide which property to access. For example, here bracket notation allows you to use a variable instead of the string literal to specify the property to access.</p><a id="pro_id00024"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">array</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">[];</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">method</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"push"</code></span><code class="p">;</code>
<code class="nx">array</code><code class="p">[</code><code class="nx">method</code><code class="p">](</code><span class="pd_ash"><code class="mi">12345</code></span><code class="p">);</code></pre><p>In this listing, the variable <code class="literal">method</code> has a value of <code class="literal">"push"</code>, so <code class="literal">push()</code> is called on the array. This capability is quite useful, as you’ll see throughout this book. The point to remember is that, other than syntax, the only difference—performance or otherwise—between dot notation and bracket notation is that bracket notation allows you to use special characters in property names. Developers tend to find dot notation easier to read, so you’ll see it used more frequently than bracket notation.</p></div><div class="sect1" title="Identifying Reference Types"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="identifying_reference_types">Identifying Reference Types</h2></div></div></div><p>A function is the easiest reference type to identify because when you use the <code class="literal">typeof</code> operator on a function, the operator should return <code class="literal">"function"</code>:</p><a id="pro_id00025"/><pre class="programlisting"><span class="pd_green"><code class="kd">function</code></span> <code class="nx">reflect</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <span class="pd_green"><code class="k">return</code></span> <code class="nx">value</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">typeof</code></span> <code class="nx">reflect</code><code class="p">);</code>    <span class="pd_green1"><code class="c1">// "function"</code></span></pre><p>Other reference types are trickier to identify because, for all reference types other than functions, <code class="literal">typeof</code> returns <code class="literal">"object"</code>. That’s not very helpful when you’re dealing with a lot of different types. To identify reference types more easily, you can use JavaScript’s <code class="literal">instanceof</code> operator.</p><p>The <code class="literal">instanceof</code> operator takes an object and a constructor as parameters. When the value is an instance of the type that the constructor specifies, <code class="literal">instanceof</code> returns <code class="literal">true</code>; otherwise, it returns <code class="literal">false</code>, as you can see here:</p><a id="pro_id00026"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">items</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">[];</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">object</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{};</code>

<span class="pd_green"><code class="kd">function</code></span> <code class="nx">reflect</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <span class="pd_green"><code class="k">return</code></span> <code class="nx">value</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">items</code> <span class="pd_green"><code class="k">instanceof</code> <code class="nb">Array</code></span><code class="p">);</code>       <span class="pd_green1"><code class="c1">// true</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">object</code> <span class="pd_green"><code class="k">instanceof</code> <code class="nb">Object</code></span><code class="p">);</code>     <span class="pd_green1"><code class="c1">// true</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">reflect</code> <span class="pd_green"><code class="k">instanceof</code> <code class="nb">Function</code></span><code class="p">);</code>  <span class="pd_green1"><code class="c1">// true</code></span></pre><p><a id="iddle1022" class="indexterm"/><a id="iddle1025" class="indexterm"/><a id="iddle1114" class="indexterm"/><a id="iddle1164" class="indexterm"/><a id="iddle1383" class="indexterm"/><a id="iddle1386" class="indexterm"/>In this example, several values are tested using <code class="literal">instanceof</code> and a constructor. Each reference type is correctly identified by using <code class="literal">instanceof</code> and the constructor that represents its true type (even though the constructor wasn’t used in creating the variable).</p><p>The <code class="literal">instanceof</code> operator can identify inherited types. That means every object is actually an instance of <code class="literal">Object</code> because every reference type inherits from <code class="literal">Object</code>.</p><p>To demonstrate, the following listing examines the three references previously created with <code class="literal">instanceof</code>:</p><a id="pro_id00027"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">items</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">[];</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">object</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{};</code>

<span class="pd_green"><code class="kd">function</code></span> <code class="nx">reflect</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <span class="pd_green"><code class="k">return</code></span> <code class="nx">value</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">items</code> <span class="pd_green"><code class="k">instanceof</code> <code class="nb">Array</code></span><code class="p">);</code>        <span class="pd_green1"><code class="c1">// true</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">items</code> <span class="pd_green"><code class="k">instanceof</code> <code class="nb">Object</code></span><code class="p">);</code>       <span class="pd_green1"><code class="c1">// true</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">object</code> <span class="pd_green"><code class="k">instanceof</code> <code class="nb">Object</code></span><code class="p">);</code>      <span class="pd_green1"><code class="c1">// true</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">object</code> <span class="pd_green"><code class="k">instanceof</code> <code class="nb">Array</code></span><code class="p">);</code>       <span class="pd_green1"><code class="c1">// false</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">reflect</code> <span class="pd_green"><code class="k">instanceof</code> <code class="nb">Function</code></span><code class="p">);</code>   <span class="pd_green1"><code class="c1">// true</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">reflect</code> <span class="pd_green"><code class="k">instanceof</code> <code class="nb">Object</code></span><code class="p">);</code>     <span class="pd_green1"><code class="c1">// true</code></span></pre><p>Each reference type is correctly identified as an instance of <code class="literal">Object</code>, from which all reference types inherit.</p></div><div class="sect1" title="Identifying Arrays"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="identifying_arrays">Identifying Arrays</h2></div></div></div><p>Although <code class="literal">instanceof</code> can identify arrays, there is one exception that affects web developers: JavaScript values can be passed back and forth between frames in the same web page. This becomes a problem only when you try to identify the type of a reference value, because each web page has its own global context—its own version of <code class="literal">Object</code>, <code class="literal">Array</code>, and all other built-in types. As a result, when you pass an array from one frame to another, <code class="literal">instanceof</code> doesn’t work because the array is actually an instance of <code class="literal">Array</code> from a different frame.</p><p>To solve this problem, ECMAScript 5 introduced <code class="literal">Array.isArray()</code>, which definitively identifies the value as an instance of <code class="literal">Array</code> regardless of the value’s origin. This method should return <code class="literal">true</code> when it receives a value that is a native array from any context. If your environment is ECMAScript 5 compliant, <code class="literal">Array.isArray()</code> is the best way to identify arrays:</p><a id="pro_id00028"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">items</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">[];</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="nb">Array</code></span><code class="p">.</code><code class="nx">isArray</code><code class="p">(</code><code class="nx">items</code><code class="p">));</code>      <span class="pd_green1"><code class="c1">// true</code></span></pre><p><a id="iddle1031" class="indexterm"/><a id="iddle1035" class="indexterm"/><a id="iddle1207" class="indexterm"/><a id="iddle1262" class="indexterm"/><a id="iddle1344" class="indexterm"/><a id="iddle1387" class="indexterm"/>The <code class="literal">Array.isArray()</code> method is supported in most environments, both in browsers and in Node.js. This method isn’t supported in Internet Explorer 8 and earlier.</p></div><div class="sect1" title="Primitive Wrapper Types"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="primitive_wrapper_types">Primitive Wrapper Types</h2></div></div></div><p>Perhaps one of the most confusing parts of JavaScript is the concept of <span class="emphasis"><em>primitive wrapper types</em></span>. There are three primitive wrapper types (<code class="literal">String</code>, <code class="literal">Number</code>, and <code class="literal">Boolean</code>). These special reference types exist to make working with primitive values as easy as working with objects. (It would be very confusing if you had to use a different syntax or switch to a procedural style just to get a substring of text.)</p><p>The primitive wrapper types are reference types that are automatically created behind the scenes whenever strings, numbers, or Booleans are read. For example, in the first line of this listing, a primitive string value is assigned to <code class="literal">name</code>. The second line treats <code class="literal">name</code> like an object and calls <code class="literal">charAt(0)</code> using dot notation.</p><a id="pro_id00029"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">;</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">firstChar</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">name</code><code class="p">.</code><code class="nx">charAt</code><code class="p">(</code><span class="pd_ash"><code class="mi">0</code></span><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">firstChar</code><code class="p">);</code>                 <span class="pd_green1"><code class="c1">// "N"</code></span></pre><p>This is what happens behind the scenes:</p><a id="pro_id00030"/><pre class="programlisting"><span class="pd_green1"><code class="c1">// what the JavaScript engine does</code></span>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">;</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">temp</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">String</code></span><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">firstChar</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">temp</code><code class="p">.</code><code class="nx">charAt</code><code class="p">(</code><span class="pd_ash"><code class="mi">0</code></span><code class="p">);</code>
<code class="nx">temp</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kc">null</code></span><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">firstChar</code><code class="p">);</code>                 <span class="pd_green1"><code class="c1">// "N"</code></span></pre><p>Because the second line uses a string (a primitive) like an object, the JavaScript engine creates an instance of <code class="literal">String</code> so that <code class="literal">charAt(0)</code> will work. The <code class="literal">String</code> object exists only for one statement before it’s destroyed (a process called <span class="emphasis"><em>autoboxing</em></span>). To test this out, try adding a property to a string as if it were a regular object:</p><a id="pro_id00031"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">;</code>
<code class="nx">name</code><code class="p">.</code><code class="nx">last</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"Zakas"</code></span><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">name</code><code class="p">.</code><code class="nx">last</code><code class="p">);</code>                 <span class="pd_green1"><code class="c1">// undefined</code></span></pre><p>This code attempts to add the property <code class="literal">last</code> to the string <code class="literal">name</code>. The code itself is just fine except that the property disappears. What happened? When working with regular objects, you can add properties at any time and they stay until you manually remove them. With primitive wrapper types, properties seem to disappear because the object on which the property was assigned is destroyed immediately afterward.</p><p><a id="iddle1034" class="indexterm"/><a id="iddle1073" class="indexterm"/><a id="iddle1155" class="indexterm"/><a id="iddle1272" class="indexterm"/><a id="iddle1357" class="indexterm"/>Here’s what’s actually happening in the JavaScript engine:</p><a id="pro_id00032"/><pre class="programlisting"><span class="pd_green1"><code class="c1">// what the JavaScript engine does</code></span>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">;</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">temp</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">String</code></span><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
<code class="nx">temp</code><code class="p">.</code><code class="nx">last</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"Zakas"</code></span><code class="p">;</code>
<code class="nx">temp</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kc">null</code></span><code class="p">;</code>                           <span class="pd_green1"><code class="c1">// temporary object destroyed</code></span>

<span class="pd_green"><code class="kd">var</code></span> <code class="nx">temp</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">String</code></span><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">temp</code><code class="p">.</code><code class="nx">last</code><code class="p">);</code>                <span class="pd_green1"><code class="c1">// undefined</code></span>
<code class="nx">temp</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kc">null</code></span><code class="p">;</code></pre><p>Instead of assigning a new property to a string, the code actually creates a new property on a temporary object that is then destroyed. When you try to access that property later, a different object is temporarily created and the new property doesn’t exist there. Although reference values are created automatically for primitive values, when <code class="literal">instanceof</code> checks for these types of values the result is <code class="literal">false</code>:</p><a id="pro_id00033"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">;</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">count</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_ash"><code class="mi">10</code></span><code class="p">;</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">found</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kc">false</code></span><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">name</code> <code class="k">instanceof</code> <code class="nb">String</code><code class="p">);</code>    <span class="pd_green1"><code class="c1">// false</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">count</code> <code class="k">instanceof</code> <code class="nb">Number</code><code class="p">);</code>   <span class="pd_green1"><code class="c1">// false</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">found</code> <code class="k">instanceof</code> <code class="nb">Boolean</code><code class="p">);</code>  <span class="pd_green1"><code class="c1">// false</code></span></pre><p>The <code class="literal">instanceof</code> operator returns <code class="literal">false</code> because a temporary object is created only when a value is read. Because <code class="literal">instanceof</code> doesn’t actually read anything, no temporary objects are created, and it tells us the values aren’t instances of primitive wrapper types. You can create primitive wrapper types manually, but there are certain side effects:</p><a id="pro_id00034"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">String</code></span><code class="p">(</code><span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">);</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">count</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">Number</code></span><code class="p">(</code><span class="pd_ash"><code class="mi">10</code></span><code class="p">);</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">found</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">Boolean</code></span><code class="p">(</code><span class="pd_green"><code class="kc">false</code></span><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">typeof</code></span> <code class="nx">name</code><code class="p">);</code>           <span class="pd_green1"><code class="c1">// "object"</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">typeof</code></span> <code class="nx">count</code><code class="p">);</code>          <span class="pd_green1"><code class="c1">// "object"</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">typeof</code></span> <code class="nx">found</code><code class="p">);</code>          <span class="pd_green1"><code class="c1">// "object"</code></span></pre><p>As you can see, creating an instance of the primitive wrapper type just creates another object, which means that <code class="literal">typeof</code> can’t identify the type of data you intend to store.</p><p>In addition, you can’t use <code class="literal">String</code>, <code class="literal">Number</code>, and <code class="literal">Boolean</code> objects as you would primitive values. For example, the following code uses a <code class="literal">Boolean</code> object. The <code class="literal">Boolean</code> object is <code class="literal">false</code>, yet <code class="literal">console.log("Found")</code> still executes because an object is always considered <code class="literal">true</code> inside a conditional statement. It doesn’t matter that the object represents <code class="literal">false</code>; it’s an object, so it evaluates to <code class="literal">true</code>.</p><a id="pro_id00035"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">found</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">Boolean</code></span><code class="p">(</code><span class="pd_green"><code class="kc">false</code></span><code class="p">);</code>

<span class="pd_green"><code class="k">if</code></span> <code class="p">(</code><code class="nx">found</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="err">"</code><code class="nx">F</code><span class="pd_red"><code class="nx">ound</code><code class="err">"</code><code class="p">);</code></span>       <span class="pd_green1"><code class="c1">// this executes</code></span>
<code class="p">}</code></pre><p><a id="iddle1103" class="indexterm"/><a id="iddle1162" class="indexterm"/>Manually instantiating primitive wrappers can also be confusing in other ways, so unless you find a special case where it makes sense to do so, you should avoid it. Most of the time, using primitive wrapper objects instead of primitives only leads to errors.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id00001">Summary</h2></div></div></div><p>While JavaScript doesn’t have classes, it does have types. Each variable or piece of data is associated with a specific primitive or reference type. The five primitive types (strings, numbers, Booleans, <code class="literal">null</code>, and <code class="literal">undefined</code>) represent simple values stored directly in the variable object for a given context. You can use <code class="literal">typeof</code> to identify primitive types with the exception of <code class="literal">null</code>, which must be compared directly against the special value <code class="literal">null</code>.</p><p>Reference types are the closest thing to classes in JavaScript, and objects are instances of reference types. You can create new objects using the <code class="literal">new</code> operator or a reference literal. You access properties and methods primarily using dot notation, but you can also use bracket notation. Functions are objects in JavaScript, and you can identify them with the <code class="literal">typeof</code> operator. You should use <code class="literal">instanceof</code> with a constructor to identify objects of any other reference type.</p><p>To make primitives seem more like references, JavaScript has three primitive wrapper types: <code class="literal">String</code>, <code class="literal">Number</code>, and <code class="literal">Boolean</code>. JavaScript creates these objects behind the scenes so that you can treat primitives like regular objects, but the temporary objects are destroyed as soon as the statement using them is complete. Although you can create your own instances of primitive wrappers, it’s best not to do that because it can be confusing.</p></div></section></body></html>