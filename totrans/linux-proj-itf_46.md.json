["```\n#include <sys/types.h>        /* For portability */\n#include <sys/msg.h>\n\nint `msgget`(key_t *key*, int *msgflg*);\n```", "```\n`svmsg/svmsg_create.c`\n#include <sys/types.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n#include <sys/stat.h>\n#include \"tlpi_hdr.h\"\n\nstatic void             /* Print usage info, then exit */\nusageError(const char *progName, const char *msg)\n{\n    if (msg != NULL)\n        fprintf(stderr, \"%s\", msg);\n    fprintf(stderr, \"Usage: %s [-cx] {-f pathname | -k key | -p} \"\n                            \"[octal-perms]\\n\", progName);\n    fprintf(stderr, \"    -c           Use IPC_CREAT flag\\n\");\n    fprintf(stderr, \"    -x           Use IPC_EXCL flag\\n\");\n    fprintf(stderr, \"    -f pathname  Generate key using ftok()\\n\");\n    fprintf(stderr, \"    -k key       Use 'key' as key\\n\");\n    fprintf(stderr, \"    -p           Use IPC_PRIVATE key\\n\");\n    exit(EXIT_FAILURE);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int numKeyFlags;            /* Counts -f, -k, and -p options */\n    int flags, msqid, opt;\n    unsigned int perms;\n    long lkey;\n    key_t key;\n\n    /* Parse command-line options and arguments */\n\n    numKeyFlags = 0;\n    flags = 0;\n\n    while ((opt = getopt(argc, argv, \"cf:k:px\")) != -1) {\n        switch (opt) {\n        case 'c':\n            flags |= IPC_CREAT;\n            break;\n\n        case 'f':               /* -f pathname */\n            key = ftok(optarg, 1);\n            if (key == -1)\n                errExit(\"ftok\");\n            numKeyFlags++;\n            break;\n\n        case 'k':               /* -k key (octal, decimal or hexadecimal) */\n            if (sscanf(optarg, \"%li\", &lkey) != 1)\n                cmdLineErr(\"-k option requires a numeric argument\\n\");\n            key = lkey;\n            numKeyFlags++;\n            break;\n\n        case 'p':\n            key = IPC_PRIVATE;\n            numKeyFlags++;\n            break;\n\n        case 'x':\n            flags |= IPC_EXCL;\n            break;\n\n        default:\n            usageError(argv[0], \"Bad option\\n\");\n        }\n    }\n\n    if (numKeyFlags != 1)\n        usageError(argv[0], \"Exactly one of the options -f, -k, \"\n                            \"or -p must be supplied\\n\");\n\n    perms = (optind == argc) ? (S_IRUSR | S_IWUSR) :\n                getInt(argv[optind], GN_BASE_8, \"octal-perms\");\n\n    msqid = msgget(key, flags | perms);\n    if (msqid == -1)\n        errExit(\"msgget\");\n\n    printf(\"%d\\n\", msqid);\n    exit(EXIT_SUCCESS);\n}\n      `svmsg/svmsg_create.c`\n```", "```\nstruct mymsg {\n    long mtype;                 /* Message type */\n    char mtext[];               /* Message body */\n}\n```", "```\n#include <sys/types.h>        /* For portability */\n#include <sys/msg.h>\n\nint `msgsnd`(int *msqid*, const void **msgp*, size_t *msgsz*, int *msgflg*);\n```", "```\n`svmsg/svmsg_send.c`\n#include <sys/types.h>\n#include <sys/msg.h>\n#include \"tlpi_hdr.h\"\n\n#define MAX_MTEXT 1024\n\nstruct mbuf {\n    long mtype;                         /* Message type */\n    char mtext[MAX_MTEXT];              /* Message body */\n};\n\nstatic void             /* Print (optional) message, then usage description */\nusageError(const char *progName, const char *msg)\n{\n    if (msg != NULL)\n        fprintf(stderr, \"%s\", msg);\n    fprintf(stderr, \"Usage: %s [-n] msqid msg-type [msg-text]\\n\", progName);\n    fprintf(stderr, \"    -n       Use IPC_NOWAIT flag\\n\");\n    exit(EXIT_FAILURE);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int msqid, flags, msgLen;\n    struct mbuf msg;                    /* Message buffer for msgsnd() */\n    int opt;                            /* Option character from getopt() */\n\n    /* Parse command-line options and arguments */\n\n    flags = 0;\n    while ((opt = getopt(argc, argv, \"n\")) != -1) {\n        if (opt == 'n')\n            flags |= IPC_NOWAIT;\n        else\n            usageError(argv[0], NULL);\n    }\n\n    if (argc < optind + 2 || argc > optind + 3)\n        usageError(argv[0], \"Wrong number of arguments\\n\");\n\n    msqid = getInt(argv[optind], 0, \"msqid\");\n    msg.mtype = getInt(argv[optind + 1], 0, \"msg-type\");\n\n    if (argc > optind + 2) {            /* 'msg-text' was supplied */\n        msgLen = strlen(argv[optind + 2]) + 1;\n        if (msgLen > MAX_MTEXT)\n            cmdLineErr(\"msg-text too long (max: %d characters)\\n\", MAX_MTEXT);\n\n        memcpy(msg.mtext, argv[optind + 2], msgLen);\n\n    } else {                            /* No 'msg-text' ==> zero-length msg */\n        msgLen = 0;\n    }\n\n    /* Send message */\n\n    if (msgsnd(msqid, &msg, msgLen, flags) == -1)\n        errExit(\"msgsnd\");\n\n    exit(EXIT_SUCCESS);\n}\n      `svmsg/svmsg_send.c`\n```", "```\n#include <sys/types.h>        /* For portability */\n#include <sys/msg.h>\n\nssize_t `msgrcv`(int *msqid*, void **msgp*, size_t *maxmsgsz*, long\n *msgtyp*, int *msgflg*);\n```", "```\nmsgrcv(id, &msg, maxmsgsz, -300, 0);\n```", "```\n$ `./svmsg_create -p`\n32769                                               *ID of message queue*\n$ `./svmsg_send 32769 20 \"I hear and I forget.\"`\n$ `./svmsg_send 32769 10 \"I see and I remember.\"`\n$ `./svmsg_send 32769 30 \"I do and I understand.\"`\n```", "```\n$ `./svmsg_receive -t -20 32769`\nReceived: type=10; length=22; body=I see and I remember.\n$ `./svmsg_receive -t -20 32769`\nReceived: type=20; length=21; body=I hear and I forget.\n$ `./svmsg_receive -t -20 32769`\n```", "```\n*Type Control-C to terminate program*\n$ `./svmsg_receive 32769`\nReceived: type=30; length=23; body=I do and I understand.\n```", "```\n`svmsg/svmsg_receive.c`\n#define _GNU_SOURCE     /* Get definition of MSG_EXCEPT */\n#include <sys/types.h>\n#include <sys/msg.h>\n#include \"tlpi_hdr.h\"\n\n#define MAX_MTEXT 1024\n\nstruct mbuf {\n    long mtype;                 /* Message type */\n    char mtext[MAX_MTEXT];      /* Message body */\n};\n\nstatic void\nusageError(const char *progName, const char *msg)\n{\n    if (msg != NULL)\n        fprintf(stderr, \"%s\", msg);\n    fprintf(stderr, \"Usage: %s [options] msqid [max-bytes]\\n\", progName);\n    fprintf(stderr, \"Permitted options are:\\n\");\n    fprintf(stderr, \"    -e       Use MSG_NOERROR flag\\n\");\n    fprintf(stderr, \"    -t type  Select message of given type\\n\");\n    fprintf(stderr, \"    -n       Use IPC_NOWAIT flag\\n\");\n#ifdef MSG_EXCEPT\n    fprintf(stderr, \"    -x       Use MSG_EXCEPT flag\\n\");\n#endif\n    exit(EXIT_FAILURE);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int msqid, flags, type;\n    ssize_t msgLen;\n    size_t maxBytes;\n    struct mbuf msg;            /* Message buffer for msgrcv() */\n    int opt;                    /* Option character from getopt() */\n\n    /* Parse command-line options and arguments */\n\n    flags = 0;\n    type = 0;\n    while ((opt = getopt(argc, argv, \"ent:x\")) != -1) {\n        switch (opt) {\n        case 'e':       flags |= MSG_NOERROR;   break;\n        case 'n':       flags |= IPC_NOWAIT;    break;\n        case 't':       type = atoi(optarg);    break;\n#ifdef MSG_EXCEPT\n        case 'x':       flags |= MSG_EXCEPT;    break;\n#endif\n        default:        usageError(argv[0], NULL);\n        }\n    }\n\n    if (argc < optind + 1 || argc > optind + 2)\n        usageError(argv[0], \"Wrong number of arguments\\n\");\n\n    msqid = getInt(argv[optind], 0, \"msqid\");\n    maxBytes = (argc > optind + 1) ?\n                getInt(argv[optind + 1], 0, \"max-bytes\") : MAX_MTEXT;\n\n    /* Get message and display on stdout */\n\n    msgLen = msgrcv(msqid, &msg, maxBytes, type, flags);\n    if (msgLen == -1)\n        errExit(\"msgrcv\");\n\n    printf(\"Received: type=%ld; length=%ld\", msg.mtype, (long) msgLen);\n    if (msgLen > 0)\n        printf(\"; body=%s\", msg.mtext);\n    printf(\"\\n\");\n\n    exit(EXIT_SUCCESS);\n}\n      `svmsg/svmsg_receive.c`\n```", "```\n#include <sys/types.h>        /* For portability */\n#include <sys/msg.h>\n\nint `msgctl`(int *msqid*, int *cmd*, struct msqid_ds **buf*);\n```", "```\n`svmsg/svmsg_rm.c`\n#include <sys/types.h>\n#include <sys/msg.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int j;\n\n    if (argc > 1 && strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s [msqid...]\\n\", argv[0]);\n\n    for (j = 1; j < argc; j++)\n        if (msgctl(getInt(argv[j], 0, \"msqid\"), IPC_RMID, NULL) == -1)\n            errExit(\"msgctl %s\", argv[j]);\n\n    exit(EXIT_SUCCESS);\n}\n      `svmsg/svmsg_rm.c`\n```", "```\nstruct msqid_ds {\n    struct ipc_perm msg_perm;           /* Ownership and permissions */\n    time_t          msg_stime;          /* Time of last msgsnd() */\n    time_t          msg_rtime;          /* Time of last msgrcv() */\n    time_t          msg_ctime;          /* Time of last change */\n    unsigned long   __msg_cbytes;       /* Number of bytes in queue */\n    msgqnum_t       msg_qnum;           /* Number of messages in queue */\n    msglen_t        msg_qbytes;         /* Maximum bytes in queue */\n    pid_t           msg_lspid;          /* PID of last msgsnd() */\n    pid_t           msg_lrpid;          /* PID of last msgrcv() */\n};\n```", "```\n`svmsg/svmsg_chqbytes.c`\n#include <sys/types.h>\n#include <sys/msg.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    struct msqid_ds ds;\n    int msqid;\n    if (argc != 3 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s msqid max-bytes\\n\", argv[0]);\n\n    /* Retrieve copy of associated data structure from kernel */\n\n    msqid = getInt(argv[1], 0, \"msqid\");\n    if (msgctl(msqid, IPC_STAT, &ds) == -1)\n        errExit(\"msgctl\");\n\n    ds.msg_qbytes = getInt(argv[2], 0, \"max-bytes\");\n\n    /* Update associated data structure in kernel */\n\n    if (msgctl(msqid, IPC_SET, &ds) == -1)\n        errExit(\"msgctl\");\n\n    exit(EXIT_SUCCESS);\n}\n      `svmsg/svmsg_chqbytes.c`\n```", "```\n$ `cd /proc/sys/kernel`\n$ `cat msgmni`\n748\n$ `cat msgmax`\n8192\n$ `cat msgmnb`\n16384\n```", "```\nstruct msginfo buf;\n\nmsgctl(0, IPC_INFO, (struct msqid_ds *) &buf);\n```", "```\n$ `./svmsg_ls`\nmaxind: 4\n\nindex     ID       key      messages\n   2    98306  0x00000000       0\n   4   163844  0x000004d2       2\n$ `ipcs -q`                               *Check above against output of ipcs*\n\n------ Message Queues --------\nkey        msqid      owner    perms    used-bytes   messages\n0x00000000 98306      mtk      600      0            0\n0x000004d2 163844     mtk      600      12           2\n```", "```\n`svmsg/svmsg_ls.c`\n#define _GNU_SOURCE\n#include <sys/types.h>\n#include <sys/msg.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int maxind, ind, msqid;\n    struct msqid_ds ds;\n    struct msginfo msginfo;\n\n    /* Obtain size of kernel 'entries' array */\n\n    maxind = msgctl(0, MSG_INFO, (struct msqid_ds *) &msginfo);\n    if (maxind == -1)\n        errExit(\"msgctl-MSG_INFO\");\n\n    printf(\"maxind: %d\\n\\n\", maxind);\n    printf(\"index     id       key      messages\\n\");\n\n    /* Retrieve and display information from each element of 'entries' array */\n\n    for (ind = 0; ind <= maxind; ind++) {\n        msqid = msgctl(ind, MSG_STAT, &ds);\n        if (msqid == -1) {\n            if (errno != EINVAL && errno != EACCES)\n                errMsg(\"msgctl-MSG_STAT\");              /* Unexpected error */\n            continue;                                   /* Ignore this item */\n        }\n\n        printf(\"%4d %8d  0x%08lx %7ld\\n\", ind, msqid,\n                (unsigned long) ds.msg_perm.__key, (long) ds.msg_qnum);\n    }\n\n    exit(EXIT_SUCCESS);\n}\n      `svmsg/svmsg_ls.c`\n```", "```\n`svmsg/svmsg_file.h`\n#include <sys/types.h>\n#include <sys/msg.h>\n#include <sys/stat.h>\n#include <stddef.h>                       /* For definition of offsetof() */\n#include <limits.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include \"tlpi_hdr.h\"\n\n#define SERVER_KEY 0x1aaaaaa1             /* Key for server's message queue */\n\nstruct requestMsg {                       /* Requests (client to server) */\n    long mtype;                           /* Unused */\n    int  clientId;                        /* ID of client's message queue */\n    char pathname[PATH_MAX];              /* File to be returned */\n};\n\n/* REQ_MSG_SIZE computes size of 'mtext' part of 'requestMsg' structure.\n   We use offsetof() to handle the possibility that there are padding\n   bytes between the 'clientId' and 'pathname' fields. */\n\n#define REQ_MSG_SIZE (offsetof(struct requestMsg, pathname) - \\\n                      offsetof(struct requestMsg, clientId) + PATH_MAX)\n\n#define RESP_MSG_SIZE 8192\n\nstruct responseMsg {                      /* Responses (server to client) */\n    long mtype;                           /* One of RESP_MT_* values below */\n    char data[RESP_MSG_SIZE];             /* File content / response message */\n};\n\n/* Types for response messages sent from server to client */\n\n#define RESP_MT_FAILURE 1                 /* File couldn't be opened */\n#define RESP_MT_DATA    2                 /* Message contains file data */\n#define RESP_MT_END     3                 /* File data complete */\n     `svmsg/svmsg_file.h`\n```", "```\n`svmsg/svmsg_file_server.c`\n    #include \"svmsg_file.h\"\n\n    static void             /* SIGCHLD handler */\n    grimReaper(int sig)\n    {\n        int savedErrno;\n\n        savedErrno = errno;                 /* waitpid() might change 'errno' */\n    while (waitpid(-1, NULL, WNOHANG) > 0)\n            continue;\n        errno = savedErrno;\n    }\n\n        static void             /* Executed in child process: serve a single client */\n serveRequest(const struct requestMsg *req)\n    {\n        int fd;\n        ssize_t numRead;\n        struct responseMsg resp;\n\n        fd = open(req->pathname, O_RDONLY);\n        if (fd == -1) {                     /* Open failed: send error text */\n        resp.mtype = RESP_MT_FAILURE;\n            snprintf(resp.data, sizeof(resp.data), \"%s\", \"Couldn't open\");\n            msgsnd(req->clientId, &resp, strlen(resp.data) + 1, 0);\n            exit(EXIT_FAILURE);              /* and terminate */\n        }\n\n        /* Transmit file contents in messages with type RESP_MT_DATA. We don't\n           diagnose read() and msgsnd() errors since we can't notify client. */\n    resp.mtype = RESP_MT_DATA;\n        while ((numRead = read(fd, resp.data, RESP_MSG_SIZE)) > 0)\n            if (msgsnd(req->clientId, &resp, numRead, 0) == -1)\n                break;\n\n        /* Send a message of type RESP_MT_END to signify end-of-file */\n    resp.mtype = RESP_MT_END;\n        msgsnd(req->clientId, &resp, 0, 0);         /* Zero-length mtext */\n    }\n\n    int\n    main(int argc, char *argv[])\n    {\n        struct requestMsg req;\n        pid_t pid;\n        ssize_t msgLen;\n        int serverId;\n        struct sigaction sa;\n\n        /* Create server message queue */\n\n        serverId = msgget(SERVER_KEY, IPC_CREAT | IPC_EXCL |\n                                S_IRUSR | S_IWUSR | S_IWGRP);\n        if (serverId == -1)\n            errExit(\"msgget\");\n\n        /* Establish SIGCHLD handler to reap terminated children */\n\n        sigemptyset(&sa.sa_mask);\n        sa.sa_flags = SA_RESTART;\n        sa.sa_handler = grimReaper;\n    if (sigaction(SIGCHLD, &sa, NULL) == -1)\n            errExit(\"sigaction\");\n\n            /* Read requests, handle each in a separate child process */\n\n        for (;;) {\n            msgLen = msgrcv(serverId, &req, REQ_MSG_SIZE, 0, 0);\n            if (msgLen == -1) {\n            if (errno == EINTR)         /* Interrupted by SIGCHLD handler? */\n                    continue;               /* ... then restart msgrcv() */\n                errMsg(\"msgrcv\");           /* Some other error */\n                break;                      /* ... so terminate loop */\n            }\n        pid = fork();                   /* Create child process */\n            if (pid == -1) {\n                errMsg(\"fork\");\n                break;\n            }\n\n            if (pid == 0) {                 /* Child handles request */\n                serveRequest(&req);\n            _exit(EXIT_SUCCESS);\n            }\n\n            /* Parent loops to receive next client request */\n        }\n\n        /* If msgrcv() or fork() fails, remove server MQ and exit */\n\n        if (msgctl(serverId, IPC_RMID, NULL) == -1)\n            errExit(\"msgctl\");\n        exit(EXIT_SUCCESS);\n    }\n         `svmsg/svmsg_file_server.c`\n```", "```\n`svmsg/svmsg_file_client.c`\n    #include \"svmsg_file.h\"\n\n    static int clientId;\n\n    static void\n    removeQueue(void)\n    {\n        if (msgctl(clientId, IPC_RMID, NULL) == -1)\n        errExit(\"msgctl\");\n    }\n\n    int\n    main(int argc, char *argv[])\n    {\n        struct requestMsg req;\n        struct responseMsg resp;\n        int serverId, numMsgs;\n        ssize_t msgLen, totBytes;\n\n        if (argc != 2 || strcmp(argv[1], \"--help\") == 0)\n            usageErr(\"%s pathname\\n\", argv[0]);\n\n        if (strlen(argv[1]) > sizeof(req.pathname) - 1)\n            cmdLineErr(\"pathname too long (max: %ld bytes)\\n\",\n                    (long) sizeof(req.pathname) - 1);\n\n        /* Get server's queue identifier; create queue for response */\n\n        serverId = msgget(SERVER_KEY, S_IWUSR);\n        if (serverId == -1)\n            errExit(\"msgget - server message queue\");\n    clientId = msgget(IPC_PRIVATE, S_IRUSR | S_IWUSR | S_IWGRP);\n        if (clientId == -1)\n            errExit(\"msgget - client message queue\");\n    if (atexit(removeQueue) != 0)\n            errExit(\"atexit\");\n\n        /* Send message asking for file named in argv[1] */\n\n        req.mtype = 1;                      /* Any type will do */\n        req.clientId = clientId;\n        strncpy(req.pathname, argv[1], sizeof(req.pathname) - 1);\n        req.pathname[sizeof(req.pathname) - 1] = '\\0';\n                                            /* Ensure string is terminated */\n    if (msgsnd(serverId, &req, REQ_MSG_SIZE, 0) == -1)\n            errExit(\"msgsnd\");\n            /* Get first response, which may be failure notification */\n\n        msgLen = msgrcv(clientId, &resp, RESP_MSG_SIZE, 0, 0);\n        if (msgLen == -1)\n            errExit(\"msgrcv\");\n    if (resp.mtype == RESP_MT_FAILURE) {\n            printf(\"%s\\n\", resp.data);      /* Display msg from server */\n            if (msgctl(clientId, IPC_RMID, NULL) == -1)\n                errExit(\"msgctl\");\n            exit(EXIT_FAILURE);\n        }\n\n        /* File was opened successfully by server; process messages\n           (including the one already received) containing file data */\n\n        totBytes = msgLen;                  /* Count first message */\n    for (numMsgs = 1; resp.mtype == RESP_MT_DATA; numMsgs++) {\n            msgLen = msgrcv(clientId, &resp, RESP_MSG_SIZE, 0, 0);\n            if (msgLen == -1)\n                errExit(\"msgrcv\");\n\n            totBytes += msgLen;\n        }\n\n        printf(\"Received %ld bytes (%d messages)\\n\", (long) totBytes, numMsgs);\n\n        exit(EXIT_SUCCESS);\n    }\n         `svmsg/svmsg_file_client.c`\n```", "```\n$ `./svmsg_file_server &`                   *Run server in background*\n[1] 9149\n$ `wc -c /etc/services`\n                     *Show size of file that client will request*\n764360 /etc/services\n$ `./svmsg_file_client /etc/services`\nReceived 764360 bytes (95 messages)       *Bytes received matches size above*\n$ `kill %1`                                 *Terminate server*\n[1]+  Terminated        ./svmsg_file_server\n```"]