<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="ch3" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch3">
<span class="CN"><span aria-label=" Page 69. " epub:type="pagebreak" id="pg_69" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">REFERENCE AND VALUE PARAMETERS</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" height="191" src="../images/opener-img.png" width="191"/>
</figure>
<p class="COS">In this chapter, we’ll look at how method parameters and arguments relate to reference and value types. We’ll revisit the idea that all variables have a value, regardless of their type, and see how to pass values of different types <i>by value</i> or <i>by reference</i> as arguments for methods.</p>
<p class="TX">We’ll explore the following:</p>
<ul class="BL">
<li class="BL">How <i>reference</i> and <i>by reference</i> differ in meaning</li>
<li class="BL">Why aliasing and mutability are so closely related</li>
<li class="BL">How avoiding side effects can make our code clearer</li>
<li class="BL">When to pass values by reference as an optimization</li>
</ul>
<p class="TX">Passing method parameters by value or by reference isn’t the same as those parameters being value or reference types. In other words, the parameter’s type (value or reference) differs from how the method uses that parameter (by value or by reference). <i>Passing</i> in this context refers to <span aria-label=" Page 70. " epub:type="pagebreak" id="pg_70" role="doc-pagebreak"/>the mechanism for supplying values to a method’s parameters and receiving the result the method returns.</p>
<p class="TX">Before we get into those distinctions in detail, let’s look at how method parameters and arguments work.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h-55"/><samp class="SANS_Futura_Std_Bold_B_11">Method Parameters and Arguments</samp></h2>
<p class="TNI">As explained in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, method parameters are a particular kind of variable. A parameter variable is declared with a name and explicit type in the method’s definition and goes out of scope when the method ends. If the method is defined in a generic type or the method itself is generic, the parameter type can be generic. When we call the method, we pass arguments to each parameter.</p>
<p class="TX">C# has four kinds of method parameters:</p>
<p class="ListHead"><b>Value parameters</b></p>
<p class="ListPlainFirst">The most common kind of parameter, value parameters, behave as if they’re local variables in the method. A value parameter is initialized with the value of the argument passed to it.</p>
<p class="ListHead"><b>Reference parameters</b></p>
<p class="ListPlainFirst">These parameters take the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier, signifying that they’re passed by reference. The arguments passed also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier to reinforce that the argument and the parameter both refer to the same memory location.</p>
<p class="ListHead"><b>Output parameters</b></p>
<p class="ListPlainFirst">These are parameters that use the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> modifier, meaning they’re given a new value by the method. Output parameters are also passed by reference. As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier for reference parameters, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> modifier for both the argument being passed and the parameter.</p>
<p class="ListHead"><b>Input parameters</b></p>
<p class="ListPlainFirst">This special kind of reference parameter uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier to indicate that its value doesn’t change within the method. Unlike <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters, the argument passed to an input parameter doesn’t require the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier, because <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> is designed to be transparent to calling code.</p>
<p class="TX">Reference, output, and input parameters are special variables in that they indicate a level of indirection to an actual variable. They are known collectively as <i>by-reference parameters</i>.</p>
<p class="TX">When we call a method, the arguments we pass populate the parameters we’ve declared for that method. When the parameter is a value parameter, our argument for it is passed by value. When the parameter is any of the by-reference parameters, our argument is passed by reference.</p>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H2" id="sec2"><span id="h-56"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reference Types vs. By-Reference Parameters</samp></h3>
<p class="TNI">By-reference parameters are sometimes confused with reference type variables, in part because the phrase <i>pass by reference</i> is often used along with its <span aria-label=" Page 71. " epub:type="pagebreak" id="pg_71" role="doc-pagebreak"/>companion, <i>pass by value</i>, to describe how reference types differ from value types. Consider Microsoft’s guide to framework design (<a href="http://msdn.microsoft.com/en-us/library/ms229017.aspx"><i>http://<wbr/>msdn<wbr/>.microsoft<wbr/>.com<wbr/>/en<wbr/>-us<wbr/>/library<wbr/>/ms229017<wbr/>.aspx</i></a>), which includes the following statement:</p>
<blockquote>
<p class="EX">Reference types are passed by reference, whereas value types are passed by value.</p>
</blockquote>
<p class="TX">This is a not-quite-accurate description of the mechanics of passing by reference. To say that reference types are passed by reference is conflating the concepts of type and passing. Arguments for by-reference parameters are passed by reference, no matter the argument’s type. Put another way, arguments of either reference or value type may be passed either by reference or by value, according to the presence or absence of a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier for the method’s parameters. A by-reference parameter is not itself a reference, but the variable it refers to might be. Terminology is fun, isn’t it?</p>
<p class="TX">In <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a>,</span> we explored how reference types and value types have different copy semantics, and passing arguments and copying variable values are related ideas. In particular, when we pass an argument by value, we make a copy of its value. The Microsoft documentation article quoted earlier goes on to say this:</p>
<blockquote>
<p class="EX">Changes to an instance of a reference type affect all references pointing to the instance. [...] When an instance of a value type is changed, it of course does not affect any of its copies.</p>
</blockquote>
<p class="TX">The operative word here is <i>instance</i>. We can have multiple references to a single instance of a reference type. Copying a reference doesn’t make a copy of the <i>instance</i>, just a copy of the reference’s value. By contrast, a copy of a value type variable is a new instance, independent of the original value. The value <i>is</i> the instance.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H2" id="sec3"><span id="h-57"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Value Types and Parameters</samp></h3>
<p class="TNI">A <i>value type variable</i> directly contains the data represented by the member fields of the type. This is true whether the variable is a local instance, a field stored in another object, or a parameter for a method. Consider the simple value type in <a href="#list3-1">Listing 3-1</a> representing a two-dimensional coordinate.</p>
<pre id="list3-1"><code>public readonly struct Coordinate&#13;
{&#13;
    public int X {get; init;}&#13;
    public int Y {get; init;}&#13;
}&#13;
var position = new Coordinate {X = 10, Y = 20};</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-1: A simple Coordinate value type</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> type has two <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> fields, each of which takes up a single location in memory. A variable of this type, such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> variable in <a href="#list3-1">Listing 3-1</a>, will directly contain the entire instance. The memory used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> variable would look more or less like <a href="#fig3-1">Figure 3-1</a>.</p><span aria-label=" Page 72. " epub:type="pagebreak" id="pg_72" role="doc-pagebreak"/>
<figure class="IMG"><img alt="" class="img50" height="163" id="fig3-1" src="../images/Figure3-1.png" width="301"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: Memory representation of a simple value</samp></p></figcaption>
</figure>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> variable doesn’t refer to the data in memory but rather stores the contents of each field of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> directly in place. If a type has multiple fields, those fields are stored in consecutive locations. If we copy <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> into another variable, each field’s value in the new variable is an independent copy of the corresponding field’s value in the original <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> variable.</p>
<p class="TX">If we pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> value as an argument to a method’s value parameter, the whole value is copied into the parameter. In <a href="#list3-2">Listing 3-2</a>, we have a method, <samp class="SANS_TheSansMonoCd_W5Regular_11">Difference</samp>, with two <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> value parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp>, and we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> variable as an argument to both parameters.</p>
<pre id="list3-2"><code>public Coordinate Difference(Coordinate start, Coordinate end)&#13;
{&#13;
    <var>--snip--</var>&#13;
}&#13;
var position = new Coordinate {X = 10, Y = 20};&#13;
<b>var distance</b> <b>=</b> <b>Difference(position, position);</b></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-2: A method with two value parameters</samp></p>
<p class="TX">Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Difference</samp> method’s parameters are both taken by value, each parameter receives its own copy that’s independent of the original value. The result looks something like <a href="#fig3-2">Figure 3-2</a> in memory.</p>
<figure class="IMG"><img alt="" class="img60" height="245" id="fig3-2" src="../images/Figure3-2.png" width="436"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: Memory representation of a copied value</samp></p></figcaption>
</figure>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp> parameters are initialized with the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> argument passed to them, and each has its own copy within the method itself.</p>
<p class="TX"><span aria-label=" Page 73. " epub:type="pagebreak" id="pg_73" role="doc-pagebreak"/>When we assign one value to another or pass a value type instance as an argument by value, we copy the value. Two value type variables are always independent instances. This is the essence of <i>copy-by-value</i> semantics.</p>
<p class="TX">Reference type variables behave differently because their value is a reference. A reference’s value is used to identify an instance of the type on the heap or is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H2" id="sec4"><span id="h-58"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Value of a Reference</samp></h3>
<p class="TNI">When we create an instance of a reference type, memory is allocated on the heap, and a reference identifying the location of that memory is stored in the variable. Syntactically, it appears that the type of a reference variable is the type of the instance to which it refers, as illustrated here with a <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> variable:</p>
<pre><code>string name = "Alfred";</code></pre>
<p class="TX">We’d normally refer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> variable as a string. However, that’s not completely accurate. It’s more precise to say that <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> is a variable whose <i>type</i> is <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> and whose <i>value</i> is a <i>reference</i> to an instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> type. The type of a reference variable need not exactly match the type of the instance. For example, we can use a base class reference variable, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, to refer to a more specific reference type instance, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>.</p>
<p class="TX">A reference’s value is an opaque handle used by the Common Language Runtime (CLR) to identify an object. We’re not really interested in what the value of a reference is; references are just the mechanism by which we access and manipulate instances of a reference type, as illustrated in <a href="#fig3-3">Figure 3-3</a>.</p>
<figure class="IMG"><img alt="" class="img90" height="278" id="fig3-3" src="../images/Figure3-3.png" width="577"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: Memory representation of a string reference</samp></p></figcaption>
</figure>
<p class="TX">In <a href="#fig3-3">Figure 3-3</a>, <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> is a variable whose value is a reference. A reference does not itself have a distinct type (certainly not one we can name), but it does have a value. The value of a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference is a handle to an area of memory allocated on the heap that contains the instance of a reference type.</p>
<p class="TX"><span aria-label=" Page 74. " epub:type="pagebreak" id="pg_74" role="doc-pagebreak"/>This precision matters because when we’re talking about passing or copying variables, we really mean passing or copying <i>values</i>. For value types, this distinction doesn’t exist: the value of a struct variable <i>is</i> the instance. However, reference variables are distinct from the instances they refer to—when we copy a reference variable’s value, we’re making a copy of the reference, not the instance.</p>
<p class="TX">Some languages use pointers to objects in memory, but a reference isn’t quite the same as a pointer. References can’t be used for just anything in memory. They’re specifically used to access reference type objects on the heap and to track those objects when they move around as a result of garbage collection and memory compaction. The details of those processes are hidden from us and handled automatically as part of the memory management for reference types.</p>
<p class="TX">We can think of the value of a reference as being a kind of address. In this respect, a reference value behaves very much like a value type instance. Like a value type variable, a reference type variable directly contains its value (an address) and lives within the scope of its parent, which might be the stack frame for the local variables of a method.</p>
<p class="TX">With that in mind, consider this: <i>all</i> variables, whether they represent reference or value types, have values that may be copied. More than that, by default, all variable values are copied—and passed—<i>by value</i>.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H2" id="sec5"><span id="h-59"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reference Variables and Aliasing</samp></h3>
<p class="TNI"><i>Aliasing</i> refers to accessing a single memory location via multiple variables. As you’ve seen, when we copy one reference to another, such as when we pass a reference as an argument to a method, we create two aliasing references—the argument variable and the parameter variable—to the same object in memory.</p>
<p class="TX">In contrast, when we pass a value type instance as an argument, the argument variable and parameter variable are identical but independent copies of each other. The difference between reference types and values in this respect is most significant when the instances are mutable (that is, their state can be altered).</p>
<p class="TX">Aliasing can be intentional and useful, such as when we want changes to an object to be observable by all references to it, wherever they might be. For example, see the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> classes in <a href="#list3-3">Listing 3-3</a>; we create an instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> type by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateCommand</samp> method of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> object stores a reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> instance used to create the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> instance.</p>
<pre id="list3-3"><code>public class Command&#13;
{&#13;
    public Command(DataStore store)&#13;
        =&gt; Connection = store;&#13;
    <b>public DataStore Connection {get;}</b>&#13;
}&#13;
<span aria-label=" Page 75. " epub:type="pagebreak" id="pg_75" role="doc-pagebreak"/>&#13;
public class DataStore&#13;
{&#13;
    public enum ConnectionState {Closed, Open}&#13;
    <b>public Command CreateCommand()</b>&#13;
        <b>=&gt;</b> <b>new Command(this);</b>&#13;
    public void Open() =&gt; State = ConnectionState.Open;&#13;
    public void Close() =&gt; State = ConnectionState.Closed;&#13;
    public ConnectionState State {get; private set;}&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-3: Storing a reference to a DataStore as a property of Command</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateCommand</samp> method returns a reference to the newly created <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> object, with its reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> instance. We can <i>mutate</i>—change the state of—the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> object by using its <samp class="SANS_TheSansMonoCd_W5Regular_11">Open</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Close</samp> methods, and whether we use a local <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> variable or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Connection</samp> property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> object returned from <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateCommand</samp>, we’ll update the same <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> instance because both references are aliases for the same object, as demonstrated in <a href="#list3-4">Listing 3-4</a>.</p>
<pre id="list3-4"><code>var store <var>=</var> new DataStore(…);&#13;
Command command = store.CreateCommand();&#13;
// Open the connection.&#13;
<b>command.Connection.Open();</b>&#13;
Assert.That(store.State, Is.EqualTo(ConnectionState.Open));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-4: Mutating the DataStore instance via an alias</samp></p>
<p class="TX">We call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Open</samp> method by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Connection</samp> property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">command</samp> variable and test that the state of the local variable named <samp class="SANS_TheSansMonoCd_W5Regular_11">store</samp> has been changed.</p>
<p class="TX">Value type variables are never aliases for a single instance, so changes to an instance are visible only in the variable used to make the change. Value type instances are copied by value, so each copy is an independent instance. This process is analogous to me sending you a document as an email attachment: we both have our own copy of the document, so if I change my copy, your copy is unaffected, and vice versa.</p>
<p class="TX">However, if I instead send a link to a shared document that we can both edit, any change either of us makes will be visible to us both via that link. The link is similar to a reference; it’s a kind of address for the document, but it’s not the document itself. The link represents a level of indirection to the real document. In exactly the same way, a reference variable doesn’t contain an object but instead a reference, and the object’s instance is accessed indirectly via that reference.</p>
</section>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h2 class="H1" id="sec6"><span id="h-60"/><span aria-label=" Page 76. " epub:type="pagebreak" id="pg_76" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Mutable By-Reference Parameters</samp></h2>
<p class="TNI">By default, method parameters are value parameters, meaning that arguments passed to them are passed by value, regardless of the argument’s type. In this section, we’ll look at the <i>mutable by-reference parameters</i>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>, which cause arguments to be passed instead by reference.</p>
<p class="TX">Value type instances and references can both be passed by reference by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> modifiers, so it’s important to understand that by-reference parameters are different from reference type <i>value</i> parameters. When we pass a reference as an argument to a reference type value parameter, the same object instance is referenced by both the argument and parameter variables, and any change to the instance is visible via either variable. A by-reference parameter, in contrast, is an alias for the value of the argument variable, whether that value is a reference or value type instance.</p>
<p class="TX">The presence of a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> modifier on a parameter means that when we call the method, the address of the argument’s value is passed rather than a copy of the value. This extra level of indirection means that regardless of the argument’s type, both the caller and the method directly access the same value. If the argument’s value is a reference, we can change it to refer to a new instance or assign <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> to it, and that change is visible via both the argument and the parameter variables.</p>
<p class="TX">To illustrate the difference between reference variables and by-reference parameters, consider <a href="#list3-5">Listing 3-5</a>, where we pass a reference by value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp> method that attempts to change its <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> parameter.</p>
<pre id="list3-5"><code>public void AutoAppend(<b>string name</b>, string extension)&#13;
{&#13;
    if(!name.EndsWith(extension))&#13;
        <b>name</b> <b>+=</b> <b>extension;</b>&#13;
}&#13;
var saveName = "Alfred";&#13;
AutoAppend(saveName, ".docx");&#13;
Assert.That(saveName, Is.EqualTo("Alfred.docx"));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-5: Creating a new instance versus changing an instance</samp></p>
<p class="TX">This test fails, even though <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> is a reference type. Although the <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> operator appears as though it’s mutating the string, it actually creates a new string with the updated contents and returns a new reference to it. The new reference and instance are visible within the <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp> method but not outside it. The original string is unchanged.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp> method isn’t changing the shared <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> instance, but rather the <i>value</i> of its <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> parameter. Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> here changes the reference to refer to a new, different instance. The <samp class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp> variable used as an argument for <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp> still refers to the original, unchanged instance.</p>
<p class="TX">This demonstrates clearly that when we pass a reference as an argument, it is, by default, passed by value. For the <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp> method in <a href="#list3-5">Listing 3-5</a> to work as expected, we need to pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp> reference by reference so <span aria-label=" Page 77. " epub:type="pagebreak" id="pg_77" role="doc-pagebreak"/>that when the method alters the value of the reference <i>variable</i>, the change is visible to the calling code.</p>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H2" id="sec7"><span id="h-61"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Passing References by Reference</samp></h3>
<p class="TNI">The most direct way to make our test in <a href="#list3-5">Listing 3-5</a> pass is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier to make <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> a by-reference parameter. <a href="#list3-6">Listing 3-6</a> shows the same <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp> method as <a href="#list3-5">Listing 3-5</a>, except in this version we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> parameter by reference by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier on it.</p>
<pre id="list3-6"><code>public void AutoAppend(<b>ref string name</b>, string extension)&#13;
{&#13;
    if(!name.EndsWith(extension))&#13;
        name += extension;&#13;
}&#13;
var saveName = "Alfred";&#13;
AutoAppend(<b>ref saveName</b>, ".docx");&#13;
Assert.That(saveName, Is.EqualTo("Alfred.docx"));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-6: Using the ref modifier to pass name by reference</samp></p>
<p class="TX">We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier on both the method’s parameter and the argument we pass to it because we’re passing a reference to a variable. The test now passes because the changes that the <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp> method makes to the value of the reference variable are visible via the <samp class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp> variable in the calling code.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> parameter is, in effect, an alias for the <samp class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp> variable, as illustrated in <a href="#fig3-4">Figure 3-4</a>.</p>
<figure class="IMG"><img alt="" class="img90" height="321" id="fig3-4" src="../images/Figure3-4.png" width="572"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-4: A by-reference parameter aliases a variable.</samp></p></figcaption>
</figure>
<p class="TX">The consequence of using a by-reference parameter is that the argument and the parameter variables don’t just refer to the same instance—they’re effectively the same reference. We can still use the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> parameter to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> instance (for example, to access properties or call <span aria-label=" Page 78. " epub:type="pagebreak" id="pg_78" role="doc-pagebreak"/>methods), and the compiler hides the extra level of indirection afforded by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier on the parameter.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="H2" id="sec8"><span id="h-62"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Passing Values by Reference</samp></h3>
<p class="TNI">We can pass value type variables by reference too. Keep in mind that passing arguments by reference doesn’t imply that the parameter is a reference variable.</p>
<p class="TX">When we pass a value type instance as an argument to a method, the method normally gets a copy of the instance because of the copy-by-value semantics of value types. As you’ve seen previously, any changes made to the fields of the instance inside the method aren’t visible to the calling code.</p>
<p class="TX">If we require those changes to be visible outside the method, we need to pass the value by reference. In <a href="#list3-7">Listing 3-7</a>, we introduce an <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> method that takes a mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value type parameter by reference and changes its value. Value types like <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> should almost always be immutable, and you’ll see in <span class="Xref">“Mutation vs. Creation” on <a href="#sec22">page 89</a></span> how to express this differently. This example merely demonstrates that the mechanism for passing value types by reference is identical to passing references by reference.</p>
<pre id="list3-7"><code>public struct Speed&#13;
{&#13;
    public double InMetersPerSecond {get; set;}&#13;
}&#13;
public void Increment(ref Speed initial, double amount)&#13;
    <b>=&gt;</b> <b>initial.InMetersPerSecond</b> <b>+=</b> <b>amount;</b></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-7: Value type by-reference parameters</samp></p>
<p class="TX">When we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> method, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier to pass the argument for the <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp> parameter by reference, just as we did for the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> parameter in <a href="#list3-6">Listing 3-6</a>. As a result, the change to <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>’s <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> property within <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> is visible to the calling code, as shown in <a href="#list3-8">Listing 3-8</a>.</p>
<pre id="list3-8"><code>var speed = new Speed {InMetersPerSecond = 50.0};&#13;
<b>Increment(ref speed, 20);</b>&#13;
Assert.That(speed.InMetersPerSecond, Is.EqualTo(70.0));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-8: Using the ref modifier to pass speed by reference</samp></p>
<p class="TX">Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> variable is passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> by reference, <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> is aliased in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> method. Both the calling code and <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> are effectively using the same variable, so any changes to the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp> parameter are visible within both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> method and the code that calls it. The test shows that we’re expecting the value to be changed.</p><span aria-label=" Page 79. " epub:type="pagebreak" id="pg_79" role="doc-pagebreak"/>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>To reiterate, by-reference parameters aren’t the same as reference type variables. A</i> <span class="Roman">reference type variable</span> <i>refers to an instance of a reference type, whereas a</i> <span class="Roman">by-reference parameter</span> <i>refers to a variable, which can be either a reference type or a value type.</i></p>
<p class="TX">References can refer only to an object on the heap. If we assign a reference type variable to an instance of a value type, the value is boxed onto the heap, and the variable refers to the boxed copy. A by-reference parameter adds an extra level of indirection to a variable’s value. When we pass a value type instance by reference, the value is neither boxed nor copied.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="H2" id="sec9"><span id="h-63"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Working with Output Parameters</samp></h3>
<p class="TNI"><i>Output parameters</i>, designated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> modifier, are mutable by-reference parameters and are usually used when we require a method to create a new instance of an object for that parameter variable. They’re similar to reference parameters in that they, too, alias the variable used as the argument. The argument we pass to the method is usually uninitialized, and the method will initialize it by assigning a value to populate the output parameter variable.</p>
<p class="TX">More formally, the difference between a reference parameter and an output parameter is that a reference argument must be definitely assigned before it’s passed, whereas an output argument may or may not be initialized when it’s passed, but the parameter must be assigned a value within the method either way.</p>
<p class="TX">Output parameters are typically used when acquiring a new instance of an object could fail without the failure being a fatal or even serious problem. Examples include parsing a string for a specifically formatted value, connecting to an unreliable service, and reading a value from a shared resource such as a queue, which could be empty. In cases like these, we often want a way to attempt the process and be able to either ignore a failure or retry the operation. If the operation succeeds, we receive a valid object as a result.</p>
<p class="TX">The common approach to this use case is to define a method that takes at least one output parameter and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> indicating success or failure. If the method succeeds, the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter is initialized with a new object, and the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>, indicating that the argument passed has been successfully initialized. If the operation is unsuccessful, the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>, indicating to the caller that the output argument’s value should be ignored. This is a common technique in C# known as <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>.</p>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="H3" id="sec10"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using the TryXXX Idiom</samp></h4>
<p class="TNI">The Standard Library has several examples of using <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> to parse a string for a specific kind of value, such as a <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> object. The <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime.TryParse</samp> method takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> parameter and an output parameter for a <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> value. If the parse fails, the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>. If the parse succeeds, the <span aria-label=" Page 80. " epub:type="pagebreak" id="pg_80" role="doc-pagebreak"/><samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> value will contain the date parsed from the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>. <a href="#list3-9">Listing 3-9</a> demonstrates how we might use this idiom.</p>
<pre id="list3-9"><code>string logTime = <var>--snip--</var>&#13;
if(DateTime.TryParse(logTime, out DateTime timeStamp))&#13;
{&#13;
    var elapsed = DateTime.Now - timeStamp;&#13;
    <var>--snip--</var></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-9: The Try</samp><span class="TheSansMonoCd_W5Regular_11">XXX</span> <samp class="SANS_Futura_Std_Book_Oblique_I_11">idiom</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">logTime</samp> variable passed as an argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp> may come from an unreliable source, such as user input or a file. Incorrectly formatted dates are an error but shouldn’t be considered an exceptional case. A successful call to <samp class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp> means the <samp class="SANS_TheSansMonoCd_W5Regular_11">timeStamp</samp> variable is a valid <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> instance. If <samp class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp> returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">timeStamp</samp> variable is default-initialized instead.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>The documentation for DateTime specifies that the failure case initializes the variable to the value of the MinValue property, but that’s equivalent to a default DateTime.</i></p>
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> methods often have a companion version that <i>will</i> throw an exception when the operation fails. The exception version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime.TryParse</samp> method, for example, is <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime.Parse</samp>, which returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> value upon success and throws a <samp class="SANS_TheSansMonoCd_W5Regular_11">FormatException</samp> error upon failure. Handling exceptions can be intrusive, and failing to parse a string for a valid <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> is the kind of error we’d probably want to handle as soon as it occurs.</p>
<p class="TX">If we had used the plain <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> method, we might have wrapped the call in a <samp class="SANS_TheSansMonoCd_W5Regular_11">try…catch</samp> block, but this could become cumbersome if we had several strings to parse: to catch a failure on any one value, we’d have to wrap <i>each call</i> in its own <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp> block. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp> instead is more direct and less verbose.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="H3" id="sec11"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Making a Definite Assignment</samp></h4>
<p class="TNI">The underlying mechanism for <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters is identical in the CIL, which has native support for by-reference parameters and arguments. They differ in the semantics imposed by the compiler: a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter is considered initially assigned within the method, meaning a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> argument must be definitely assigned before being passed; an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter, on the other hand, is considered initially unassigned within the method, regardless of whether it had been assigned a value before the call. We must therefore definitely assign all <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters before the method returns. Not doing so results in a compile-time failure, as shown by this method, which attempts to return before the <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> parameter has been assigned:</p>
<pre><code><span aria-label=" Page 81. " epub:type="pagebreak" id="pg_81" role="doc-pagebreak"/>public bool TryRemote(string address, out DataStore connection)&#13;
{&#13;
    if(string.IsNullOrEmpty(address))&#13;
        <b>return false;</b>&#13;
    <var>--snip--</var></code></pre>
<p class="TX">We receive this error:</p>
<pre><code>[CS0177] The out parameter 'connection' must be assigned to before control&#13;
leaves the current method</code></pre>
<p class="TX">The most straightforward way to avoid the error in this example would be to preemptively assign <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> to the <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> parameter before returning <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>. By convention, an argument passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> method should be considered to have a valid value in the calling code only if the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.</p>
<p class="TX">The target <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> variables in the calling code are considered definitely assigned only after a <i>normal</i> return from a method. It’s possible for control to leave the method <i>abnormally</i> by throwing an exception before all of its <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters have been assigned. If the method exits with an exception, the variables used as <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> arguments that weren’t definitely assigned prior to the method call remain not definitely assigned. Any arguments that were already definitely assigned before the call remain definitely assigned, although they may still have been given a new value within the method before the exception was thrown.</p>
<p class="TX">However, we’d usually use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> idiom to <i>avoid</i> exceptions, as most users will expect such methods to not throw any exceptions.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="H3" id="sec12"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Selecting Operations</samp></h4>
<p class="TNI">Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> idiom with an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter, like that shown in <a href="#list3-9">Listing 3-9</a>, is appealing because the method can be used inline in a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement to test the return value and capture the required output argument’s value all in one place. In <a href="#list3-10">Listing 3-10</a>, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp> method to determine how to obtain a list of results, using the ternary conditional operator <samp class="SANS_TheSansMonoCd_W5Regular_11">?:</samp> rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp> blocks. The <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> output variable is declared inline in the argument list for the method.</p>
<pre id="list3-10"><code>List&lt;Record&gt; results = TryRemote(remoteName, <b>out DataStore connection</b>)&#13;
    ? connection.LoadData()&#13;
    : LoadFromCache();</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-10: Using a simple out parameter</samp></p>
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp> returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>, the branch following <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> is taken, and we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> output variable in the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>. If the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>, indicating the connection to the remote resource failed, our code takes the branch following the <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> and loads the results from a cache instead.</p>
<p class="TX"><span aria-label=" Page 82. " epub:type="pagebreak" id="pg_82" role="doc-pagebreak"/>Note that we can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> to declare the type of the inline <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> argument, in which case the compiler will determine its type according to the type of the parameter in the method’s definition. The <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp> method allows us to handle the failure to connect without the extra cost and complexity of handling an exception, and to attempt a different approach to obtain the list of results.</p>
<p class="TX">We can think of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> method as returning multiple values: a <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> to indicate the success or failure of attempting to obtain a resource, and the resource itself when its acquisition succeeds.</p>
</section>
</section>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h2 class="H1" id="sec13"><span id="h-64"/><samp class="SANS_Futura_Std_Bold_B_11">Limitations of By-Reference Parameters</samp></h2>
<p class="TNI">While methods with by-reference parameters are well suited for certain situations, such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> technique, by-reference parameters are not appropriate for every case, and the rules around definite assignment can sometimes require a different approach. Other restrictions can also affect where we can use these parameters. We’ll look at these restrictions in this section.</p>
<section aria-labelledby="sec14" epub:type="division">
<h3 class="H2" id="sec14"><span id="h-65"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Property Values</samp></h3>
<p class="TNI">The result of getting a property or indexer value can’t be used directly as a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> argument. In <a href="#list3-11">Listing 3-11</a>, we attempt to pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> instance as an argument to a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter.</p>
<pre id="list3-11"><code>public readonly struct Velocity&#13;
{&#13;
    public Speed Speed {get;}&#13;
    public Angle Direction {get;}&#13;
}&#13;
public void Increment(ref Speed initial, double amount)&#13;
    =&gt; initial.InMetersPerSecond += amount;&#13;
var start = new Velocity (<var>--snip--)</var>;&#13;
Increment(<b>ref start.Speed</b>, 25);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-11: Passing properties to ref parameters</samp></p>
<p class="TX">The compiler rejects this code with the following error:</p>
<pre><code>[CS0206] A property or indexer may not be passed as an out or ref parameter</code></pre>
<p class="TX">The compiler doesn’t allow this code because a property result is a value and not a variable. In <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a>,</span> you saw how variables can be assigned to, but values can’t. Accessing a property is exactly the same as reading the return value from a method call—something we look at in detail in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>—and methods return values, not variables. We usually use a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter when we expect the called method to modify its argument, but because a property isn’t a variable, it <i>can’t</i> be modified.</p>
<p class="TX"><span aria-label=" Page 83. " epub:type="pagebreak" id="pg_83" role="doc-pagebreak"/>It makes no difference whether <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> is a reference type or a value type. Passing a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> argument is essentially passing the address of the argument, and we can’t pass the address of a nonvariable.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h3 class="H2" id="sec15"><span id="h-66"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overloading on By-Reference Parameters</samp></h3>
<p class="TNI">By-reference parameter modifiers are part of the signature of a method. A reference or output parameter is effectively a different type than its value parameter equivalent. If we have a method that takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter, we can overload it with a method that takes that parameter by value.</p>
<p class="TX">Method overloads can have different return types, so we can write a method that takes its parameters by value and returns a new object, and overload it with a version taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter that modifies the object in place, as shown in <a href="#list3-12">Listing 3-12</a>.</p>
<pre id="list3-12"><code>public Speed Increment(<b>Speed initial</b>, double amount)&#13;
    =&gt; new Speed {InMetersPerSecond = initial.InMetersPerSecond + amount};&#13;
public void Increment(<b>ref Speed initial</b>, double amount)&#13;
    =&gt; initial.InMetersPerSecond += amount;</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-12: Overloading on by-reference modifiers</samp></p>
<p class="TX">When we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> method, the compiler selects the correct overload based on whether we modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> argument with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> keyword to pass it by reference or omit the modifier to call the version with a value parameter.</p>
<p class="TX">We can’t, however, overload a method when the only difference is the kind of by-reference modifier for its parameters, as we try to do in <a href="#list3-13">Listing 3-13</a>.</p>
<pre id="list3-13"><code>public void Increment(<b>ref Speed initial</b>, double amount)&#13;
    =&gt; initial.InMetersPerSecond += amount;&#13;
public void Increment(<b>out Speed initial</b>, double amount)&#13;
    =&gt; initial = new Speed {InMetersPerSecond = amount};</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-13: Overloading on different modifiers</samp></p>
<p class="TX">This might seem an arbitrary restriction. After all, calling code must differentiate between passing a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> argument and passing an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> argument. However, the compiler rejects this overload because the Common Language Infrastructure (CLI) has no way to distinguish between <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> in the method signature. Both are just by-reference parameters, so the two overloads have the same signature, as far as the CLI is concerned, resulting in ambiguity.</p>
<p class="TX">The same restriction applies with <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters, which we cover in <span class="Xref">“Read-Only References and Returning by Reference” on <a href="#sec24">page 92</a></span>. As with <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters, an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter is simply another kind of by- reference parameter, as far as the CLI is concerned.</p>
<p class="TX"><span aria-label=" Page 84. " epub:type="pagebreak" id="pg_84" role="doc-pagebreak"/>Overloading a method based purely on whether one or more parameters is taken by reference or by value is probably best avoided in any case. Anyone calling such a method needs a thorough knowledge of this somewhat arcane corner of overloading rules, so such code could easily be confusing.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h3 class="H2" id="sec16"><span id="h-67"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Fields</samp></h3>
<p class="TNI">Making a field a by-reference variable is impossible. Again, this might seem arbitrary, but otherwise a by-reference field could become a <i>dangling</i> reference—that is, it could refer to an object that no longer exists.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>As of C# v11.0, by-reference fields are permitted within ref struct types, which are specialized value types intended for high-performance applications. Numerous restrictions on ref struct types make them less suitable for most general-purpose code, so we don’t cover them in this book.</i></p>
<p class="TX">Consider a class like <samp class="SANS_TheSansMonoCd_W5Regular_11">Reminder</samp> in <a href="#list3-14">Listing 3-14</a>, which attempts to store a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter in a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> field.</p>
<pre id="list3-14"><code>public class Reminder&#13;
{&#13;
    public Reminder(ref DateTime start)&#13;
        =&gt; time = start;&#13;
    private readonly ref DateTime time;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-14: A hypothetical Reminder class that stores a field by reference</samp></p>
<p class="TX">Although this approach might seem attractive in principle—say, if we want the <samp class="SANS_TheSansMonoCd_W5Regular_11">Reminder</samp> class to deliberately alias the argument to its constructor, or we want to avoid copying the <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> instance—this code doesn’t compile. The compiler rejects it as simply invalid syntax because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Reminder</samp> instance could be used after the referenced <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> variable has gone out of scope, meaning the field would become a reference to memory that no longer exists or, perhaps worse, memory that has been allocated to something else. The <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp> field would be a dangling reference, something the rules of C# go to great lengths to prevent.</p>
<p class="TX">Although reference types have different lifetimes and enjoy automatic memory management, allowing <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> fields only for reference types would indeed be arbitrary and a source of potential confusion and error. This capability would also serve little purpose because reference variables already exhibit aliasing behavior, and by-reference variables are the same size as references for the purposes of copying, so the compiler forbids it.</p>
<section aria-labelledby="sec17" epub:type="division">
<h4 class="H3" id="sec17"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Closures</samp></h4>
<p class="TNI">The prohibition of <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> fields is also the reason we can’t use a by-reference parameter inside a closure. A <i>closure</i> is a method that encapsulates <span aria-label=" Page 85. " epub:type="pagebreak" id="pg_85" role="doc-pagebreak"/>behavior along with its <i>context</i>—that is, the state of any variables declared outside the method’s own scope but used within its implementation. Those external variables are said to have been <i>closed over</i> by the method, hence the term <i>closure</i>. <a href="#list3-15">Listing 3-15</a> shows a method trying to use a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter inside a lambda expression.</p>
<pre id="list3-15"><code>public static Reminder&#13;
NextAppointment(<b>ref DateTime time</b>, IEnumerable&lt;Reminder&gt; items)&#13;
{&#13;
    var results = items.Where(<b>item</b> <b>=&gt;</b> <b>item.Date</b> <b>==</b> <b>time.Date</b>);&#13;
    return results.FirstOrDefault();&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-15: Anonymous closure capturing a ref parameter</samp></p>
<p class="TX">The compiler rejects the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextAppointment</samp> method, giving us the following error:</p>
<pre><code>[CS1628] Cannot use ref, out, or in parameter 'time' inside an anonymous method, lambda&#13;
expression, query expression, or local function</code></pre>
<p class="TX">The closure in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextAppointment</samp> method is the lambda expression used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Where</samp> method. The lambda is an anonymous method that uses the captured <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp> parameter, which belongs to the scope of <samp class="SANS_TheSansMonoCd_W5Regular_11">NextAppointment</samp>. Closure functions are implemented by the compiler as a small, unnamable class with fields for each of the closed-over variables. In this example, the variable being captured is a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter, which, as you saw in <a href="#list3-14">Listing 3-14</a>, isn’t a valid field.</p>
<p class="TX">As the error message indicates, the same problem applies equally to nested local functions and anonymous methods, which can also capture the outer method’s variables, including its parameters. Anonymous methods, lambda expressions, and local functions are all implemented the same way: using a hidden class synthesized by the compiler. Any captured variables become fields of that class.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h4 class="H3" id="sec18"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Iterator Blocks</samp></h4>
<p class="TNI">An <i>iterator block</i> is a compiler-generated class that implements the standard <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable&lt; T &gt;</samp> interface to iterate over the elements of a sequence, such as an array or a <samp class="SANS_TheSansMonoCd_W5Regular_11">List&lt; T &gt;</samp>, using deferred execution. Also known as <i>lazy enumeration</i>, <i>deferred execution</i> means that the next element is obtained from the sequence only when the user requests it; the sequence is produced on demand and theoretically may even be infinite.</p>
<p class="TX">An iterator block is created whenever we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">yield</samp> statement, as shown in <a href="#list3-16">Listing 3-16</a>. However, the compiler rejects the <samp class="SANS_TheSansMonoCd_W5Regular_11">AppointmentsForDay</samp> method because it has a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter.</p>
<pre id="list3-16"><code>public static IEnumerable&lt;Reminder&gt;&#13;
AppointmentsForDay(<b>ref DateTime time</b>, IEnumerable&lt;Reminder&gt; items)&#13;
{&#13;
    foreach (var item in items)&#13;
    {&#13;
        if(item.Time.Date == time.Date)&#13;
            <b>yield return item;</b>&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-16: A ref parameter in an iterator</samp></p>
<p class="TX">Here the <samp class="SANS_TheSansMonoCd_W5Regular_11">AppointmentsForDay</samp> method is attempting to filter the <samp class="SANS_TheSansMonoCd_W5Regular_11">items</samp> sequence passed as a parameter for elements that match the <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp> parameter. However, like closures, methods that use iterator blocks can’t have by-reference parameters, so the method in <a href="#list3-16">Listing 3-16</a> fails to compile, with this error:</p>
<pre><code>[CS1623] Iterators cannot have ref, in or out parameters</code></pre>
<p class="TX">Each time the method yields a value, control returns to the calling code. When the next item is requested, the method must continue at the statement following the <samp class="SANS_TheSansMonoCd_W5Regular_11">yield</samp> and must do so with the same state. The compiler transforms the <samp class="SANS_TheSansMonoCd_W5Regular_11">yield</samp> statement to return an instance of the iterator block class that captures the state between requests for each element, similar to the way closures work.</p>
<p class="TX">The compiler-generated class needs to capture <i>all</i> the method parameters and any local variables as fields to preserve the method’s state between each request for a value, which is why iterator methods can’t have by-reference parameters.</p>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h4 class="H3" id="sec19"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Asynchronous Methods</samp></h4>
<p class="TNI">Lastly, and for exactly the same reason as closures and iterator blocks, we can’t declare by-reference parameters for <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp> methods like the <samp class="SANS_TheSansMonoCd_W5Regular_11">TryGetResponse</samp> method in <a href="#list3-17">Listing 3-17</a>.</p>
<pre id="list3-17"><code>public static async Task&lt;bool&gt; TryGetResponse(<b>out string response</b>)&#13;
{&#13;
    response = <b>await Task.Run(()</b> <b>=&gt;</b> <b>GetUserInput())</b>;&#13;
    return !string.IsNullOrEmpty(response);&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-17: An out parameter in an asynchronous method</samp></p>
<p class="TX">This method fails to compile with the following error:</p>
<pre><code>[CS1988] Async methods cannot have ref, in or out parameters</code></pre>
<p class="TX">In this instance, the compiler synthesizes a hidden class to manage the asynchronous invocation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Task.Run</samp> method. Asynchronous methods return control to their caller when the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> statement is reached, and so, like iterator blocks, they must preserve the state of <i>all</i> their variables. The compiler-generated class captures all local variables and parameters as <span aria-label=" Page 87. " epub:type="pagebreak" id="pg_87" role="doc-pagebreak"/>fields, so by-reference parameters aren’t allowed for any method that has the <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp> modifier.</p>
</section>
</section>
<section aria-labelledby="sec20" epub:type="division">
<h3 class="H2" id="sec20"><span id="h-68"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extension Methods</samp></h3>
<p class="TNI">We can use by-reference parameters in any method that doesn’t use a closure, an iterator block, or asynchronous operations using the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> keyword. However, caveats exist for <i>extension methods</i>, static methods that extend the interface of another type. The first parameter of an extension method is of the type being extended and uses the special <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> modifier. Extension methods have some restrictions on using by-reference parameters for the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameter. First, the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameter of an extension method can’t be an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter, as demonstrated by <a href="#list3-18">Listing 3-18</a>.</p>
<pre id="list3-18"><code>public static void&#13;
FormatConnection(<b>out this string connString</b>, string host, string source)&#13;
{&#13;
    connString = $"Server={host};Database={source};Trusted_Connection=True;";&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-18: Extension method using an out parameter</samp></p>
<p class="TX">This code produces the following error message:</p>
<pre><code>[CS8328] The parameter modifier 'this' cannot be used with 'out'</code></pre>
<p class="TX">If this syntax were permitted, code using the <samp class="SANS_TheSansMonoCd_W5Regular_11">FormatConnection</samp> method could <i>appear</i> to call a method using an uninitialized variable, like this:</p>
<pre><code>string connection;  // uninitialized variable&#13;
connection.FormatConnection(host, source);</code></pre>
<p class="TX">Most users would probably find this code confusing because using an uninitialized variable to invoke a method isn’t allowed in any other circumstances. In any case, we have much better alternatives to achieve the same result, and the syntax for <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameters is also an error. We can use an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> modifier with any of the other parameters, just as we can with any regular method, but we can’t make <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> an output parameter.</p>
<p class="TX">Using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> for the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameter is permitted if the parameter is a value type, but not if it’s a reference type. This restriction might also seem unreasonable at first glance, but it’s intended to explicitly prohibit code like the following:</p>
<pre><code>public static void Nullify(ref this string val)&#13;
    =&gt; val = null;</code></pre>
<p class="TX">The compiler rejects the <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullify</samp> method with the following error:</p>
<pre><code>[CS8337] The first parameter of a 'ref' extension method 'Nullify' must be a value type or a&#13;
generic type constrained to struct.</code></pre>
<p class="TX"><span aria-label=" Page 88. " epub:type="pagebreak" id="pg_88" role="doc-pagebreak"/>If this code were permitted, the variable used to call the method could refer to a different variable, or—as in this example—be set to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> after the method returned. Most users would likely be surprised by such behavior, so, once again, the compiler forbids it.</p>
<p class="TX">We can use <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> for the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameter when the parameter is a value type, which avoids copying the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> argument’s value. While there’s no benefit to avoiding the copy of a reference, copying a large value might be relatively expensive. A value type variable can’t be assigned the value <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, but the method can assign a new value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref this</samp> parameter, thus changing the argument’s value. Again, doing so would likely surprise most users of the method, so even though the syntax is legal, we should avoid using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref this</samp> parameters. If we really want to avoid copying the argument for a <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameter, then instead of using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier to make <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> a read-only reference parameter, as discussed in more detail in <span class="Xref">“Read-Only References and Returning by Reference” on <a href="#sec24">page 92</a></span>.</p>
<p class="TX">In spite of their limitations, by-reference parameters are a core part of C#, and understanding their semantics is important. None of these restrictions is particularly onerous, not least because the use cases for these parameters are limited. The use of <samp class="SANS_TheSansMonoCd_W5Regular_11">ref this</samp> value type parameters in extension methods would be considered unusual by most programmers and is a niche-enough feature that it’s probably best avoided in any case.</p>
<p class="TX">Fields <i>must</i> be real variables, and C# provides no way to store a by-reference variable as a field of a general-purpose type. Every other example in this section can be expressed differently to achieve the same result.</p>
</section>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h2 class="H1" id="sec21"><span id="h-69"/><samp class="SANS_Futura_Std_Bold_B_11">Side Effects and Direct Effects</samp></h2>
<p class="TNI">Methods with by-reference parameters intentionally alias variables in the calling code, and therefore changes made to those parameters within the method are visible outside the method’s scope. Altering the state of an aliased object is an example of a <i>side effect</i>, which is more generally defined as any change of state that’s visible to code outside the scope where the change occurs.</p>
<p class="TX">Side effects aren’t intrinsically bad, but programs that depend on them heavily can be more difficult to follow than those that rely only on direct effects. The <i>direct effect</i> of a method is whatever it returns, normally referred to as the method’s output, with the inputs being the method’s formal parameters. By-reference parameters, especially <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters, blur the distinction between the inputs and outputs of a method, since side effects may alter state that is unrelated to the method’s direct effect.</p>
<p class="TX">Consider how <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> methods are commonly used to initialize variables, as shown in <a href="#list3-19">Listing 3-19</a>.</p>
<pre id="list3-19"><code>if(TryRemote(remoteName, out var connection))&#13;
{&#13;
    // Perform activities using connection&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-19 Using TryRemote with an output parameter to initialize the connection variable</samp></p>
<p class="TX"><span aria-label=" Page 89. " epub:type="pagebreak" id="pg_89" role="doc-pagebreak"/>The direct effect of the <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp> method is the <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> return value indicating the success or failure of initializing its output parameter. We use the return value to determine whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> variable has been initialized; in other words, the direct effect tells us whether the side effect was successful. In this case, a connection exists between the side and direct effects of <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>, but, as with other <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> methods, the direct effect seems secondary to the side effect!</p>
<p class="TX">Methods with by-reference parameters, and more generally those that rely substantially on operating by side effect, often result in very procedural code comprising a set of logical steps or instructions to accomplish a task. Procedural solutions are described as <i>imperative code</i> because they’re an explicit sequence of instructions to be processed to achieve a result. The contrasting approach is <i>declarative code</i>, which emphasizes outcomes over specific implementation. A more declarative approach pulls the focus away from <i>how</i> things get done and allows us to concentrate instead on the outcomes.</p>
<p class="TX">One aspect of a declarative style is that we attach more importance to the direct effect of a method and make a clear separation between a method’s inputs and its output.</p>
<p class="TX">We could make our <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp> method in <a href="#list3-19">Listing 3-19</a> more declarative by removing the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter and returning the required <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> reference directly; since <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> is a reference type, we can return <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> if the <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp> method fails. However, the side effects associated with by-reference parameters aren’t really an issue when those parameters are reference types. Reference types are often mutable—by design, and for good reason—and the fact that multiple variables can refer to a single instance is often desirable behavior, as you saw in <span class="Xref">“Reference Variables and Aliasing” on <a href="#sec5">page 74</a></span>. The benefits of declarative code are much more important when we’re using value types, which should be immutable.</p>
<section aria-labelledby="sec22" epub:type="division">
<h3 class="H2" id="sec22"><span id="h-70"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Mutation vs. Creation</samp></h3>
<p class="TNI">A method that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters is giving a strong signal that those parameters will change within the method. Since such parameters are aliases for the variables passed as arguments to them, we need to pay attention to which variables may be changed. Unexpected modifications to variables can cause errors that are hard to identify, especially in code that uses multiple threads. If we follow the common advice to make our own value types immutable, we reduce the likelihood of such problems occurring, which means we should also avoid mutable by-reference parameters of value type. Then, there’s only one way that a value type variable can change: by assignment.</p>
<p class="TX">If we have an instance of a value and require an instance with different properties, we simply create a new one with the state we want, leaving the original unchanged. Compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp> method in <a href="#list3-20">Listing 3-20</a> with the similar <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> method in <a href="#list3-7">Listing 3-7</a>.</p>
<pre id="list3-20"><code><span aria-label=" Page 90. " epub:type="pagebreak" id="pg_90" role="doc-pagebreak"/>public Speed Incremented(Speed initial, double amount)&#13;
    =&gt; Speed.FromMetersPerSecond(initial.InMetersPerSecond + amount);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-20: Creating a new value rather than mutating an existing variable</samp></p>
<p class="TX">We create and return a new instance of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> that’s initialized using the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> property of a parameter variable, instead of altering the properties of a value that has been passed by reference. Note that the method name is <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp> rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>. The name <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> is a direct verb and might imply that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> parameter was somehow being altered. In contrast, the name <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp> is an adjective describing the result. Using adjectives for nonmutating methods is another indication that no state is being altered. Other examples of this naming convention include <samp class="SANS_TheSansMonoCd_W5Regular_11">Sorted</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">UpperCased</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Rounded</samp>.</p>
<p class="TX">To call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp> method, we pass an existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value along with a numeric amount by which to increment its value, as shown here:</p>
<pre><code>var speed = Speed.FromMetersPerSecond(50.0);&#13;
var newSpeed = Incremented(speed, 20);&#13;
Assert.That(speed.InMetersPerSecond, Is.EqualTo(50));&#13;
Assert.That(newSpeed.InMetersPerSecond, Is.EqualTo(70));</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> variable in the calling code isn’t changed; the <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp> method returns a <i>new</i> <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance with the required value. We assign the new value to a different variable here, but we could have overwritten the original <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> variable with the new instance instead.</p>
<p class="TX">Not all objects are values, and sometimes it’s convenient for certain objects to be mutable; the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> object you saw earlier has mutable state that can be changed via its <samp class="SANS_TheSansMonoCd_W5Regular_11">Open</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Close</samp> methods.</p>
<p class="TX">Aliasing is useful when we require changes to an object to be visible via all <i>references</i> to that object, but the benefits of such side effects aren’t so clear for value types. Side effects aren’t limited to output parameters. They occur anytime we can modify the state of an object that’s visible outside the scope in which we make the change, including via a plain reference variable.</p>
<p class="TX">Changing the state of any object requires special care and attention, especially in the presence of multiple threads, so if we limit the need to modify our objects, we reduce the potential for problems. If we make all value types immutable, we reduce the prevalence of side effects, which can be difficult to identify and sometimes make our logic less clear.</p>
<p class="TX">An alternative approach to creating a new value based on the properties of an existing instance is to use the non-destructive mutation syntax, introduced in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>. <a href="#list3-21">Listing 3-21</a> uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> keyword to copy an existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> variable and provide a new value for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Direction</samp> property of the copy.</p>
<pre id="list3-21"><code>public readonly struct Velocity&#13;
{&#13;
    public Speed Speed {get; init;}&#13;
    public Angle Direction {get; init;}&#13;
}&#13;
<span aria-label=" Page 91. " epub:type="pagebreak" id="pg_91" role="doc-pagebreak"/>&#13;
var velocity = new Velocity&#13;
    {&#13;
        Speed = Speed.FromMetersPerSecond(10),&#13;
        Direction = Angle.FromRadians(.88)&#13;
    };&#13;
<b>var copy</b> <b>=</b> <b>velocity with {Direction</b> <b>=</b> <b>Angle.FromRadians(.99)};</b></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-21: Copying an instance as a template</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> accessors on each property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> type enable us to copy an instance and change selected properties for the new instance by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> keyword. Non-destructive mutation was introduced for record types in C# v9.0, and since C# v10.0, we can also use it with structs and record structs, and even anonymous types.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> accessor also allows us to give a property a value by using object initialization (as shown for the <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity</samp> variable in <a href="#list3-21">Listing 3-21</a>) or via a constructor, but once its value is set via <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>, the property is immutable. If we’d used <samp class="SANS_TheSansMonoCd_W5Regular_11">private set</samp> accessors for the properties instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>, the object initialization and non-destructive mutation syntax wouldn’t be possible. Non-destructive mutation and object initialization both require either a public <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> or public <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor.</p>
<p class="TX">Copying selected properties of immutable values is another aspect of a declarative approach to problem-solving, and in some circumstances makes it simpler and more direct to create new values by using existing variables as a kind of template.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h3 class="H2" id="sec23"><span id="h-71"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declarative Code and Performance</samp></h3>
<p class="TNI">Using a declarative style can lead to code that is clearer and more direct but often results in more copies of variables being created, adding storage expense. This is particularly relevant for value types for which the cost of copying large instances may impact a program’s performance. Up to this point, we have considered only quite small instances, which would be unlikely to negatively impact performance significantly. While reference variables are always all the same size, values can be any size. To an extent, size matters when we’re copying values around. A value type that simply wraps a single <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> field will be cheaper to copy than one that has lots of fields, which is why we’re often advised to keep value types small.</p>
<p class="TX">The definition of <i>small</i> varies but is commonly between 16 and 24 bytes. Note that on a 64-bit architecture, references are 8 bytes each, so it’s not hard to imagine a useful value type that exceeds the recommended size limit. We’ll explore some of the performance characteristics of large value types in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>.</p>
<p class="TX">Nevertheless, the size of a value type shouldn’t be the primary motivation for choosing a class or record over a struct or record struct. If we want instances of a type to have value semantics, we should make it a value type, regardless of how large it might be. When we pass value type variables as arguments for <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters, no copy of the instance is made because <span aria-label=" Page 92. " epub:type="pagebreak" id="pg_92" role="doc-pagebreak"/>those arguments are passed by reference. Might the preference for returning values over using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters affect the efficiency of our code?</p>
<p class="TX">For values with several fields, avoiding the copying might well represent a net performance gain, but we should also consider the impact of our choices on <i>human</i> readers. It might seem attractive to use by-reference parameters to avoid copying large values, except that using a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter strongly implies that the argument passed is likely to change. If we want our code to be as self-documenting as possible, using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameters as an <i>optimization</i> might be surprising.</p>
<p class="TX">Rather than using the mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameters, we can use <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters, which are <i>immutable</i> by-reference parameters. Arguments for <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters are passed by reference in exactly the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> arguments, but an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter variable is read-only within the method. In the next section, we’ll explore how to avoid copying value type method arguments by using read-only reference parameters, as well as how to return values by reference.</p>
</section>
</section>
<section aria-labelledby="sec24" epub:type="division">
<h2 class="H1" id="sec24"><span id="h-72"/><samp class="SANS_Futura_Std_Bold_B_11">Read-Only References and Returning by Reference</samp></h2>
<p class="TNI">Read-only references and returning by reference are related concepts, and both can help us reduce the number of copies of value type instances in our code. First we’ll look at read-only reference parameters, which we denote using the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> keyword on a method parameter. The <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier, like the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> modifiers, makes a by-reference parameter, but, unlike <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters, it prevents the value of the underlying variable from being changed. In other words, an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter variable is immutable. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters when we’re passing large value type instances as arguments might be beneficial because we avoid copying the instance.</p>
<p class="TX">Technically, we can also pass a reference to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter, but there’s no reason to do so. Passing a reference by reference is useful only if we need to change the reference to refer to a new instance. For that to work, we need a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter. No performance benefit is associated with passing a reference by reference, as there may be with value types.</p>
<p class="TX"><a href="#list3-22">Listing 3-22</a> shows a simple expression-bodied method, <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp>, that calculates a distance from its <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp> parameter values, both of which are value types.</p>
<pre id="list3-22"><code>public double DistanceInKm(<b>in Speed speed</b>, <b>in TimeSpan time</b>)&#13;
    =&gt; speed.InKmh * time.TotalHours;</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-22: Read-only reference parameters</samp></p>
<p class="TX">Both the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp> variables use the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier, making them read-only reference parameters in the <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp> method. Since the parameter variables are read-only, the compiler will reject any attempt to set mutable properties, change public fields, or assign a new value to either of them.</p>
<p class="TX"><span aria-label=" Page 93. " epub:type="pagebreak" id="pg_93" role="doc-pagebreak"/>When we call a method that has a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter, we must also modify the argument we’re passing with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> keyword. By contrast, arguments passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters do <i>not</i> require the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier, as shown here:</p>
<pre><code>var time = TimeSpan.FromHours(2.5);&#13;
var speed = Speed.FromKmh(20);&#13;
var distance = <b>DistanceInKm(speed, time)</b>;&#13;
Assert.That(distance, Is.EqualTo(50.0));</code></pre>
<p class="TX">As with reference and output parameters, we can overload <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp> with a version that has value parameters. The overload <i>without</i> modifiers takes precedence in overload resolution if we don’t specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier for the argument. We can explicitly use <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> for an argument passed to an input parameter to select the version taking its parameters by reference. As mentioned earlier in the chapter, overloading methods based solely on whether a parameter is passed by reference or by value is likely to be a source of confusion.</p>
<p class="TX">Read-only reference parameters are designed to be transparent in the calling code; that is, passing an argument to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter appears the same as passing an argument by value. One consequence is that a method may be modified to receive its parameters by read-only reference instead of by value, but without requiring changes to the calling code. Arguments that were previously passed by value would then be passed by reference. This matters only if the <i>argument</i> variables may change—perhaps within a different thread. Bear in mind that only the parameter variables within the method are read-only; the argument variables usually aren’t. Since the argument passed to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter is passed by reference, any change to the argument’s value will be reflected in the value of the parameter variable inside the method. <a href="#list3-23">Listing 3-23</a> demonstrates that it’s possible to modify the value of an argument passed to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter even without multiple threads.</p>
<pre id="list3-23"><code>void ModifyByCallback(in int value, Action callback)&#13;
{&#13;
  <span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> var temp = value;&#13;
  <span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> callback();&#13;
    Assert.That(value, Is.Not.EqualTo(temp));&#13;
}&#13;
int input = 100;&#13;
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> ModifyByCallback(value: input, callback: () =&gt; input = 200);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-23: Modifying a read-only parameter’s value via a callback delegate</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp> method takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> value by read-only reference and an <samp class="SANS_TheSansMonoCd_W5Regular_11">Action</samp> delegate. A <i>delegate</i> is a variable that refers to a method; here, <span aria-label=" Page 94. " epub:type="pagebreak" id="pg_94" role="doc-pagebreak"/>we use the standard <samp class="SANS_TheSansMonoCd_W5Regular_11">Action</samp> type for the delegate that represents a method with no parameters and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>. Within the <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp> method, we copy the <i>value</i> of the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> parameter into a temporary variable <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Then we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">callback</samp> delegate before testing that the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> parameter’s value is now different from the value copied to <samp class="SANS_TheSansMonoCd_W5Regular_11">temp</samp> before we called the delegate <span aria-label="annotation2" class="CodeAnnotation">❷</span>. When we call <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp>, we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp> value along with a lambda for the <samp class="SANS_TheSansMonoCd_W5Regular_11">callback</samp> parameter. The lambda closes over the <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp> variable, whose value is changed by the lambda <span aria-label="annotation3" class="CodeAnnotation">❸</span>.</p>
<p class="TX">The test within the <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp> method passes because the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> parameter is an alias to the calling code’s <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp> variable. When the <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp> variable’s value changes inside the lambda, the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> parameter’s value is also changed. We should therefore be cautious of methods that have both <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters and delegate parameters. More generally, we should be suspicious of code that changes the values of any variable passed as an argument to a method, especially if the method and calling code can run on different threads of execution. The potential errors caused by changing an apparently read-only variable could be difficult to track down.</p>
<section aria-labelledby="sec25" epub:type="division">
<h3 class="H2" id="sec25"><span id="h-73"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Returning Values by Reference</samp></h3>
<p class="TNI">Although instances of value type aren’t generally copied by reference, we can return a value type instance by reference, and receive the returned reference by using a by-reference variable. This can be useful if we’re particularly sensitive to the cost of copying large instances, although the technique is sufficiently complex that we probably shouldn’t use it routinely. <a href="#list3-24">Listing 3-24</a> shows a struct whose instances will be larger than a reference variable.</p>
<pre id="list3-24"><code>public readonly struct Address&#13;
{&#13;
    public Address(string street, string city, string state, string zip)&#13;
        =&gt; (Street, City, State, Zip) = (street, city, state, zip);&#13;
    public string Street {get;}&#13;
    public string City   {get;}&#13;
    public string State  {get;}&#13;
    public string Zip    {get;}&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-24: An Address struct with multiple fields</samp></p>
<p class="TX">This <samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp> struct has four <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> backing fields, so an instance of the struct is somewhat larger and more expensive to copy than a single reference. If huge numbers of instances were being copied around, we might want to address the cost of some of those copies. However, returning by reference isn’t guaranteed to be cheaper than returning even large values by value, and may even represent a performance cost. Even so, if careful performance analysis identified instance copying as an issue, returning values by reference might prove beneficial.</p>
<p class="TX">When we access a property, we inadvertently make a copy of the property’s value. We can avoid making this copy by returning the value by <span aria-label=" Page 95. " epub:type="pagebreak" id="pg_95" role="doc-pagebreak"/>reference, known as a <i>reference return value</i>, or simply a <i>ref return</i>. We mark a value as being a ref return by adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> keyword, as we do when modifying by-reference method parameters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp> class in <a href="#list3-25">Listing 3-25</a> has a <samp class="SANS_TheSansMonoCd_W5Regular_11">Destination</samp> property that returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp> field value by reference.</p>
<pre id="list3-25"><code>public sealed class Mail&#13;
{&#13;
    public Mail(string name, Address address)&#13;
        =&gt; (Addressee, destination) = (name, address);&#13;
    public string Addressee {get;}&#13;
    <b>public ref Address Destination</b> <b>=&gt;</b> <b>ref destination;</b>&#13;
    private Address destination;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-25: The Destination property returning the destination field value by reference</samp></p>
<p class="TX">Note that we need to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> keyword to the property and to the variable being returned by reference.</p>
<p class="TX">When we access a property that returns its value by reference, we can also receive that value by reference without copying it at all. A <i>by-reference variable</i>, or <i>ref local</i>, is a local variable that refers to the same variable as the ref return. This is best illustrated with a simple example. In <a href="#list3-26">Listing 3-26</a>, we receive the ref return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail.Destination</samp> by using a local reference variable.</p>
<pre id="list3-26"><code>var address = new Address ("62 West Wallaby Street",&#13;
                           "Wigan", "Lancashire", "WG7 7FU");&#13;
var letter = new Mail("G Lad Esq.", address);&#13;
<b>ref var local</b> <b>=</b> <b>ref letter.Destination;</b></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-26: Consuming a value returned by reference</samp></p>
<p class="TX">This <samp class="SANS_TheSansMonoCd_W5Regular_11">local</samp> variable is an alias to the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp> field within the <samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp> instance, not a copy of its value. Again, note that we have to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier on both the target variable and the property access; if we forget either, the compiler will give us an error. If we omit both, we simply copy the property’s value by value into a normal variable.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">
<h3 class="H2" id="sec26"><span id="h-74"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Preventing Modifications to Data</samp></h3>
<p class="TNI">Just as with by-reference parameters, ref return values and ref locals introduce an alias to a value. If we modify a value through such an alias, we need to make sure we know where those changes will be visible.</p>
<p class="TX">We can use the ref local reference to mutate the field in <samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp> too, although in this example we can only assign it a completely new value, since <samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp> is a read-only struct. <a href="#list3-27">Listing 3-27</a> demonstrates that modifying the ref local also changes the field of the <samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp> variable.</p>
<pre id="list3-27"><code><span aria-label=" Page 96. " epub:type="pagebreak" id="pg_96" role="doc-pagebreak"/>var letter = new Mail("G Lad Esq.",&#13;
    new ("62 West Wallaby Street", "Wigan", "Lancashire", "WG7 7FU"));&#13;
<b>ref var address</b> <b>=</b> <b>ref letter.Destination;</b>&#13;
Assert.That(address.Street, Is.EqualTo("62 West Wallaby Street"));&#13;
address = new Address("1619 Pine Street", "Boulder", "CO", "80302");&#13;
<b>Assert.That(letter.Destination.Street,</b>&#13;
    <b>Is.EqualTo("1619 Pine Street"));</b></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-27: Mutating a field by using a ref local variable</samp></p>
<p class="TX">Being able to modify a <i>private</i> field of an instance in this way might not be desirable. First, it violates the encapsulation of the field in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp> class, and second, as with any alias, directly altering an object would likely cause problems in multithreaded code. A <i>race condition</i> occurs whenever an object’s state can be altered by multiple threads simultaneously, or when one thread can read an object before another thread has finished changing it. The size of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp> type means that assigning a new value won’t be an atomic operation, meaning that a second thread could read a partly initialized instance.</p>
<p class="TX">One common approach to addressing race conditions is to protect access to a variable from multiple threads by using a lock. Locking access to the data within the property itself isn’t sufficient in this situation because the underlying data can be modified outside the property definition; we’d need to lock every use of the property, which would likely hamper our code’s performance. Fortunately, we have a less intrusive solution: we can simply make the property immutable. Sharing immutable state has none of the drawbacks associated with changing data from multiple threads.</p>
<p class="TX">To protect the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp> field in <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp> from modifications, we can change the <samp class="SANS_TheSansMonoCd_W5Regular_11">Destination</samp> property to return a read-only reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp> field. If we return such a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp> variable, the calling code needs to also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> keyword for the target variable, as <a href="#list3-28">Listing 3-28</a> shows.</p>
<pre id="list3-28"><code>public sealed class Mail&#13;
{&#13;
    <var>--snip--</var>&#13;
    public ref readonly Address Destination =&gt; ref destination;&#13;
    private readonly Address destination;&#13;
}&#13;
var address = new Address ("62 West Wallaby Street", "Wigan", "Lancashire", "WG7 7FU");&#13;
var letter = new Mail("G Lad Esq.", address);&#13;
ref readonly var local = ref letter.Destination;</code></pre>
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-28: Preventing mutation of a ref return</samp></p>
<p class="TX"><span aria-label=" Page 97. " epub:type="pagebreak" id="pg_97" role="doc-pagebreak"/>The compiler won’t allow any modifications via the read-only <samp class="SANS_TheSansMonoCd_W5Regular_11">local</samp> reference variable. We’ve also made the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp> field read-only in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp> class. This means that we <i>must</i> use a read-only reference if we return a reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp> field. If we attempt to return a read-only field by reference without the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly ref</samp> modifier, the compiler gives us this error:</p>
<pre><code>[CS8160] A readonly field cannot be returned by writable reference</code></pre>
<p class="TX">We can assign one <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> variable to another by using the same syntax as assigning a ref local to the result of a property. Note that a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp> variable can be assigned from a non-read-only reference. An automatic and implicit conversion occurs from a plain—or <i>writable</i>—ref return or a ref local <i>to</i> a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp> variable, but not in the other direction. A read-only reference can’t be assigned to a writable ref local. Doing so would break the immutability guarantees of a read-only reference.</p>
</section>
<section aria-labelledby="sec27" epub:type="division">
<h3 class="H2" id="sec27"><span id="h-75"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Keeping By-Reference Variables Within Scope</samp></h3>
<p class="TNI">Methods can return values by reference too, and the syntax is the same as for properties. However, the lifetime of the variable returned by reference must be guaranteed to last at least as long as the reference’s lifetime. More formally, the scope of the variable being referenced must <i>include</i> the method or property that returns a reference to that variable.</p>
<p class="TX">One implication of this rule is that we can’t return a reference to a local variable, because the variable will go out of scope as soon as the method or property implementation returns. This is most clearly apparent for value types. The lifetime of a value ends when the scope ends, so its lifetime is <i>shorter</i> than that of the reference. The method in <a href="#list3-29">Listing 3-29</a> fails to compile because it’s attempting to return a reference to a local variable.</p>
<pre id="list3-29"><code>public ref Address Get()&#13;
{&#13;
    var val = new Address();&#13;
    <b>return ref val;</b>&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-29: Trying to return a reference to a local variable</samp></p>
<p class="TX">If we <i>could</i> return a reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp> variable, the code calling this method would get a reference to a value that no longer exists. The compiler prevents such a situation by refusing to compile the code, giving this error:</p>
<pre><code>[CS8168] Cannot return local 'val' by reference because it is not a ref local</code></pre>
<p class="TX">This rule applies regardless of whether the value of the local variable is a reference or an instance of a struct. The <i>variable</i> still goes out of scope, even when the <i>instance</i> exists on the heap. By-reference variables and by-reference returns are references to variables, not instances, in exactly the same way as by-reference parameters.</p>
<section aria-labelledby="sec28" epub:type="division">
<h4 class="H3" id="sec28"><span aria-label=" Page 98. " epub:type="pagebreak" id="pg_98" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Instance Fields of Value Types</samp></h4>
<p class="TNI">The compiler will prevent us from returning a variable by reference if it can’t guarantee that the variable will be valid for at least as long as any reference to it. A less obvious consequence of this rule is that a method or property of a value type can’t return a reference to one of that type’s instance fields. The code in <a href="#list3-30">Listing 3-30</a>, for instance, won’t compile.</p>
<pre id="list3-30"><code>public readonly struct Color&#13;
{&#13;
    --<var>snip--</var>&#13;
    public ref readonly uint Rgb =&gt; ref rgbValue;&#13;
    private readonly uint rgbValue;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-30: Returning a struct field by reference</samp></p>
<p class="TX">The compiler gives us this error message:</p>
<pre><code>[CS8170] Struct members cannot return 'this' or other instance members by reference</code></pre>
<p class="TX">This operation is prohibited because the compiler can’t easily determine that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instance will outlive any reference to a field within it. <a href="#list3-31">Listing 3-31</a> shows a pathological example to demonstrate why that might be a problem.</p>
<pre id="list3-31"><code>public ref readonly uint DefaultRgb()&#13;
{&#13;
    var source = new Color();&#13;
    ref readonly var rgb = ref source.Rgb;&#13;
    return ref rgb;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-31: Invalid code returning a reference to a struct’s field</samp></p>
<p class="TX">If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct in <a href="#list3-30">Listing 3-30</a> could legally return one of its fields by reference, the <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultRgb</samp> method in <a href="#list3-31">Listing 3-31</a> would be returning a reference to a field of an object that has gone out of scope. This is a similar problem to returning a reference to a local variable, but this time the problem is directly related to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> being a struct. When a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> variable goes out of scope, each of its fields goes out of scope too. The compiler forbids returning any instance field of a value type by reference to avoid even the possibility of this happening.</p>
<p class="TX">Member methods and properties of a value type are also prevented from returning <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> by reference. It’s disallowed for exactly the same reason as for instance fields: if it were permitted, we would be returning a reference to a local value—an instance of the type—that goes out of scope.</p>
</section>
<section aria-labelledby="sec29" epub:type="division">
<h4 class="H3" id="sec29"><span aria-label=" Page 99. " epub:type="pagebreak" id="pg_99" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">References to References</samp></h4>
<p class="TNI">When a reference variable goes out of scope, the instance it represented still exists on the heap until it is garbage collected. We can, therefore, safely return a reference to an instance field from a property or method of a class or a record. In fact, holding such a by-reference variable <i>prevents</i> the instance from being garbage collected. In <a href="#list3-32">Listing 3-32</a>, we take a reference to an instance field of a local reference type object and return it.</p>
<pre id="list3-32"><code>public ref readonly Address GetAddress()&#13;
{&#13;
    var local = new Mail("G Lad Esq.",&#13;
        new ("62 West Wallaby Street", "Wigan", "Lancashire", "WG7 7FU"));&#13;
    <b>ref readonly var address</b> <b>=</b> <b>ref local.Destination;</b>&#13;
    <b>return ref address;</b>&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-32: Returning a reference to a field of a local object</samp></p>
<p class="TX">The compiler accepts this code, and it’s safe to use this method, although we should certainly be cautious because this technique relies on a somewhat esoteric feature of the garbage collector. When <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp> returns, the <samp class="SANS_TheSansMonoCd_W5Regular_11">local</samp> variable goes out of scope, leaving no live reference variables directly to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp> instance created inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp> method. Normally, that instance would then become eligible for garbage collection, making the by-reference return value a dangling reference. However, the returned by-reference variable is enough to prevent the garbage collector from destroying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp> instance, so holding a by-reference variable to one of its fields remains valid.</p>
<p class="TX">Behind the scenes, a by-reference variable or parameter to a field within a class or record instance represents a managed pointer. <i>Managed pointers</i> are an implementation detail of the CLR, but the takeaway here is that they’re tracked by the garbage collector and considered <i>object roots</i>—simply put, references or managed pointers to objects known to be live when the garbage collector runs. Those objects, in turn, may contain references to other objects on the heap, so the chain of references forms a graph of objects currently in use at the time the garbage collector runs.</p>
<p class="TX">The garbage collector uses object roots to determine whether object instances can be collected: any instance it can’t reach from an object root by following the object graph is eligible for collection, and any object that <i>is</i> reachable survives. Storing a ref local variable is enough to keep the owning object from being garbage collected.</p>
<p class="TX">We can always safely return a by-reference parameter variable by reference because the variable aliased by the parameter must be in scope for the calling code. Strictly, the scope of the variable includes the method accepting the parameter by reference, as shown in <a href="#list3-33">Listing 3-33</a>.</p>
<pre id="list3-33"><code><span aria-label=" Page 100. " epub:type="pagebreak" id="pg_100" role="doc-pagebreak"/>public ref Color RemoveRed(ref Color color)&#13;
{&#13;
    color = new Color(0, color.Green, color.Blue);&#13;
    return ref color;&#13;
}&#13;
var hasRed = new Color(0x77, 0xFF, 0x11);&#13;
ref var noRed = ref RemoveRed(ref hasRed);&#13;
Assert.That(noRed.Red, Is.EqualTo(0));&#13;
Assert.That(hasRed.Red, Is.EqualTo(0));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-33: Returning a ref parameter by reference</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoveRed</samp> method’s <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp> parameter can be returned by reference because the reference can’t outlive the variable underlying it, since the scope of the <samp class="SANS_TheSansMonoCd_W5Regular_11">hasRed</samp> variable in the calling code <i>includes</i> <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoveRed</samp>. <a href="#list3-34">Listing 3-34</a> shows that the same is true of <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters, even though they look like they’re returning a reference to a local variable.</p>
<pre id="list3-34"><code>public ref Color CreateColor(out Color result)&#13;
{&#13;
    result = new Color();&#13;
    return ref result;&#13;
}&#13;
ref var created = ref CreateColor(out Color color);&#13;
Assert.That(created.Red, Is.EqualTo(0));&#13;
Assert.That(color.Red, Is.EqualTo(0));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-34: Returning an out parameter by reference</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> parameter in the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateColor</samp> method is a reference to a variable in the calling code, whose scope also includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateColor</samp> method itself.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>Returning out parameters by reference is prohibited as of C# v11.0, although returning ref parameters by reference is still permitted.</i></p>
<p class="TX">We can also return <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters by reference, but they must be returned as <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp>, because an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter is immutable. If we forget to make the returned reference <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>, the compiler gives us a predictable error:</p>
<pre><code>[CS8333] Cannot return variable 'in Color' by writable reference because it is a readonly&#13;
variable</code></pre>
<p class="TX">Given that the variable used to populate the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter must already be part of the calling code and we can’t modify it in any way, returning an <span aria-label=" Page 101. " epub:type="pagebreak" id="pg_101" role="doc-pagebreak"/><samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter by reference typically isn’t useful. We can pass the variable to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter to avoid copying it, but the method could just as easily return <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> because the calling code must already know about the variable, which could not be modified by the method.</p>
</section>
<section aria-labelledby="sec30" epub:type="division">
<h4 class="H3" id="sec30"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Mutable Immutable Properties</samp></h4>
<p class="TNI">Properties that return by reference can’t have a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor and thus are apparently immutable. However, ref returns have a peculiarity: if we return by <i>writable</i> reference, as shown in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> property in <a href="#list3-35">Listing 3-35</a>, we can use the reference to mutate the underlying value, just as we would use a setter for the property.</p>
<pre id="list3-35"><code>public class Brush&#13;
{&#13;
    public Brush(Color c) =&gt; color = c;&#13;
    <b>public ref Color Color</b> <b>=&gt;</b> <b>ref color;</b>&#13;
    private Color color;&#13;
}&#13;
var brush = new Brush(new Color(0x77, 0x33, 0xFF));&#13;
<b>brush.Color</b> <b>=</b> <b>new Color();</b>&#13;
Assert.That(brush.Color.Red, Is.EqualTo(0));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-35: Setting a new value for a writable reference property</samp></p>
<p class="TX">It may look like we’re setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">brush</samp> variable to a new instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, but in fact we’re assigning a new value to the <i>field</i> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> class directly, by reference. The semantic difference is somewhat subtle. Part of the purpose of a property is to <i>encapsulate</i> access to a value, but here we deliberately sidestep that encapsulation by returning a reference to the field.</p>
<p class="TX">If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> property returned a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp>, this code wouldn’t compile because we’d be attempting to modify a read-only variable. A <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> property would enable us to change its value, but permitting a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor for something that is read-only seems perverse.</p>
</section>
</section>
<section aria-labelledby="sec31" epub:type="division">
<h3 class="H2" id="sec31"><span id="h-76"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Considering Performance vs. Simplicity</samp></h3>
<p class="TNI">Ref returns, used in conjunction with ref locals, may be beneficial when we’d otherwise be copying large value type instances around, particularly if <i>many</i> copies would be generated. Ref locals and ref returns are a relatively complex optimization feature and need to be introduced with care. When the values are small, creating references to them carries no benefit and might even result in added cost due to the extra indirection required to access the value. We can use ref returns and ref locals for reference <span aria-label=" Page 102. " epub:type="pagebreak" id="pg_102" role="doc-pagebreak"/>variables too, but, again, doing so provides no advantage; C# allows it just for the symmetry.</p>
<p class="TX">We need to be aware of the costs of <i>all</i> by-reference variables, whether they’re parameters, return values, or locals. Any by-reference variable introduces extra indirection in order to obtain the <i>actual</i> underlying value.</p>
</section>
</section>
<section aria-labelledby="sec32" epub:type="division">
<h2 class="H1" id="sec32"><span id="h-77"/><samp class="SANS_Futura_Std_Bold_B_11">Final Word on Mutable By-Reference Parameters</samp></h2>
<p class="TNI">As mentioned previously, using the mutable by-reference parameter types <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> often indicates very procedural code. In general, if we prefer a more declarative style, we make our code more self-describing and often more compact. However, output parameters have one use in modern C# that supports that same declarative approach. The term of art is <i>object deconstruction</i>, although the relevance of <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters here may not be immediately obvious.</p>
<p class="TX">We begin with the value tuple, introduced in C# v7.0 to simplify the creation of lightweight aggregate types such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp> variable in <a href="#list3-36">Listing 3-36</a>.</p>
<pre id="list3-36"><code>var point = (X: 30, Y: 50);&#13;
Assert.That(point.X, Is.EqualTo(30));&#13;
Assert.That(point.Y, Is.EqualTo(50));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-36: A value tuple for a point</samp></p>
<p class="TX">This <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp> variable is a <i>named tuple</i>, where we give a name to each component. The tests show how we use those names like properties to obtain their respective values. Value tuples support deconstruction: we can decompose the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp> variable into individual variables with names unrelated to the names we gave the components. <a href="#list3-37">Listing 3-37</a> uses the deconstruction syntax to assign two separate variables from the fields of the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp> tuple from <a href="#list3-36">Listing 3-36</a>.</p>
<pre id="list3-37"><code><b>var (horizontal, vertical)</b> <b>=</b> <b>point;</b>&#13;
Assert.That(horizontal, Is.EqualTo(30));&#13;
Assert.That(vertical, Is.EqualTo(50));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-37: Tuple deconstruction</samp></p>
<p class="TX">In this code, the types of the <samp class="SANS_TheSansMonoCd_W5Regular_11">horizontal</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">vertical</samp> variables are inferred from the components of the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp> value tuple, and we use them individually without needing to refer to <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp> at all. We can support this same syntax in our own types by writing a public <samp class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp> method, which uses <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters to take all of its parameters by reference. <a href="#list3-38">Listing 3-38</a> shows a <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> struct type with such a method.</p>
<pre id="list3-38"><code>public readonly struct Coordinate&#13;
{&#13;
    public Coordinate(int x, int y) =&gt; (X, Y) = (x, y);&#13;
<span aria-label=" Page 103. " epub:type="pagebreak" id="pg_103" role="doc-pagebreak"/>&#13;
    int X {get; init;}&#13;
    int Y {get; init;}&#13;
    <b>public void Deconstruct(out int x, out int y)</b>&#13;
    <b>{</b>&#13;
        <b>x</b> <b>=</b> <b>X;</b>&#13;
        <b>y</b> <b>=</b> <b>Y;</b>&#13;
    <b>}</b>&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-38: User-defined type deconstruction</samp></p>
<p class="TX">We can use identical syntax to that shown in <a href="#list3-37">Listing 3-37</a> to deconstruct a <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> value into individual variables:</p>
<pre><code>var point = new Coordinate(30, 50);&#13;
var (horizontal, vertical) = point;</code></pre>
<p class="TX">The compiler translates this code to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp> method of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> struct, so the calling code has no mention of <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> arguments, or even a call to a method. The compiler’s support for object deconstruction allows the code using <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> to access its properties as individual variables in a compact and clear way.</p>
<p class="TX">The same syntax for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp> method is also supported for classes. The compiler generates a <samp class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp> method for both records and record structs, saving us from having to define our own implementation of it.</p>
<p class="TX">Simple value types like <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp> value tuple are common in functional programs because they encapsulate simple abstractions with a minimum of syntactical overhead. They also present little or no performance overhead, allowing us to write expressive and efficient programs more simply.</p>
</section>
<section aria-labelledby="sec33" epub:type="division">
<h2 class="H1" id="sec33"><span id="h-78"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<blockquote epub:type="epigraph" role="doc-epigraph">
<p class="EP"><i>How do we convince people that in programming simplicity and clarity [...] are not a dispensable luxury, but a crucial matter that decides between success and failure?</i></p>
<footer class="EPS">—Edsger W. Dijkstra, <i>Selected Writings on Computing: A Personal Perspective</i></footer></blockquote>
<p class="BodyContinued">The concept of pass-by-reference, and how it differs from pass-by-value, is much less straightforward than a first glance might suggest. The common explanation—that value types are passed by value and reference types by reference—is misleading. We don’t pass types around; we pass values. What’s more, by default all values are passed by value.</p>
<p class="TX">Understanding what the value of a variable actually <i>is</i> helps us more precisely define what passing by reference really entails. Passing by value is merely the default; we have to actively choose to pass a value by reference. Reference and value types differ semantically because the value of a <span aria-label=" Page 104. " epub:type="pagebreak" id="pg_104" role="doc-pagebreak"/>reference variable isn’t the same as the instance of the type it represents. For value type variables, however, the value and the instance are the same thing.</p>
<p class="TX">Moreover, we can pass a variable by reference in several ways, each with different behavior and restrictions. We’ve looked at using by-reference method parameters to change variables in different ways, as well as at alternatives that can make our programs more direct and comprehensible by avoiding side effects and making values immutable. Immutability is an important aspect of avoiding problems associated with unwanted aliasing, even when by-reference variables are being used. If we use read-only properties and read-only structs judiciously, we can take advantage of some of the performance benefits of passing by reference, without suffering from the complications of managing access to shared mutable data.</p>
<p class="TX">When an immutable value is shared by several references, aliasing can never present a problem. This is the basic principle behind <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters and read-only local references, but it’s also a consideration when we want value semantics for a type but also want the benefits of reference semantics for performance.</p>
<p class="TX">However, passing by reference isn’t without cost. Every access to a by-reference parameter involves an extra level of indirection. This cost is likely to be negligible but could adversely affect performance if the method is used in “hot paths” through the code. As with any performance optimization, we must measure the outcome to determine whether the optimization is worthwhile.</p>
</section>
</section>
</div></body></html>