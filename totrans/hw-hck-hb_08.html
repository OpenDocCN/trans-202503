<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="245" id="Page_245"/>8</span><br/>
<span class="ChapterTitle">I’ve Got the Power: Introduction to Power Analysis</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">You’ll often hear that cryptographic algorithms are unbreakable, regardless of the huge advances in computing power. That is true. However, as you’ll learn in this chapter, the key to finding vulnerabilities in cryptographic algorithms lies in their implementation, no matter how “military grade” they are.</p>
<p>That said, we won’t be discussing crypto implementation errors, such as failed bounds checks, in this chapter. Instead, we’ll exploit the very nature of digital electronics using side channels to break algorithms that, on paper, appear to be secure. A <em>side channel</em> is some observable aspect of a system that reveals secrets held within that system. The techniques we describe leverage vulnerabilities that arise from the physical implementation of these algorithms in hardware, primarily in the way that digital devices use power. We’ll start with data-dependent execution time, which we can determine by monitoring power consumption, and then we’ll move on to monitoring power consumption as a means to identify key bits in cryptographic processing functions.</p>
<p><span epub:type="pagebreak" title="246" id="Page_246"/>Considerable historical precedence exists for side-channel analysis. For example, during the Second World War, the British were interested in estimating the number of tanks being produced by the Germans. The most reliable way to do so turned out to be a statistical analysis of the sequence of serial numbers from captured or disabled tanks, assuming that serial numbers typically increment in a straightforward manner. The attacks we’ll present in this chapter mirror this so-called <em>German Tank Problem</em>: they combine statistics with assumptions and ultimately use a small amount of data that our adversary unknowingly leaked to us.</p>
<p>Other historical side-channel attacks monitor unintended electronic signals emanating from the hardware. In fact, almost as soon as electronic systems were used to pass secure messages, they were subject to attack. One such famous early attack was the TEMPEST attack, launched by Bell Labs scientists in WWII to decode electronic typewriter key presses from 80 feet away with a 75 percent accuracy (see “TEMPEST: A Signal Problem” by the USA’s National Security Agency). TEMPEST has since been used to reproduce what is being displayed on a computer monitor by picking up the monitor’s radio signal emissions from outside the building (see, for instance, Wim van Eck’s “Electromagnetic Radiation from Video Display Units: An Eavesdropping Risk?”). And while the original TEMPEST attack used CRT-type monitors, this same vulnerability has been demonstrated on more recent LCD displays by Markus G. Kuhn in “Electromagnetic Eavesdropping Risks of Flat-Panel Displays,” so it’s far from outdated.</p>
<p>We’ll show you something even more surreptitious than TEMPEST, though: a way to use unintended emissions from hardware to break otherwise secure cryptographic algorithms. This strategy covers both software running on hardware (such as firmware on a microcontroller) and pure hardware implementations of the algorithms (such as cryptographic accelerators). We’ll describe how to measure, how to process your measurement to improve leakage, and how to extract secrets. We’ll cover topics that have their roots in areas ranging all the way from chip and printed circuit board (PCB) design, through electronics, electromagnetism, and (digital) signal processing, to statistics, cryptography, and even to common sense.</p>
<h2 id="h1-278748c08-0001">Timing Attacks</h2>
<p class="BodyFirst">Timing is everything. Consider what happens when implementing a personal identification number (PIN) code check, like one you’d find on a wall safe or door alarm. The designer allows you to enter the complete PIN (say, four digits) before comparing the entered PIN with the stored secret code. In C code, it could look something like <a href="#listing8-1" id="listinganchor8-1">Listing 8-1</a>.</p>
<pre><code>int checkPassword() {
    int user_pin[] = {1, 1, 1, 1};
    int correct_pin[] = {5, 9, 8, 2};

    // Disable the error LED
    error_led_off();
<span epub:type="pagebreak" title="247" id="Page_247"/>
    // Store four most recent buttons
    for(int i = 0; i &lt; 4; i++) {
        user_pin[i] = read_button();
    }

    // Wait until user presses 'Valid' button
    while(valid_pressed() == 0);

    // Check stored button press with correct PIN
    for(int i = 0; i &lt; 4; i++) {
        if(user_pin[i] != correct_pin[i]) {
            error_led_on();
            return 0;
        }
    }

    return 1;
}</code></pre>
<p class="CodeListingCaption"><a id="listing8-1">Listing 8-1</a>: Sample PIN code check written in C</p>
<p>It looks like a pretty reasonable piece of code, right? We read in four digits. If they match the secret code, the function returns a <code>1</code>; otherwise, it returns a <code>0</code>. Ultimately, we can use this return value to open a safe or disarm the security system by pressing the valid button after the four digits have been entered. A red error LED illuminates to show that the PIN is incorrect.</p>
<p>How might this safe be attacked? Assuming that the PIN accepts the numbers 0 through 9, testing all possible combinations would require a total of 10 × 10 × 10 × 10 = 10,000 guesses. On average, we would have to perform 5,000 guesses to find the PIN, but that would take a long time, and the system might limit the speed at which we can repeatedly enter guesses.</p>
<p>Fortunately, we can reduce the number of guesses to 40 using a technique called a <em>timing attack</em>. Assume we have the keypad shown in <a href="#figure8-1" id="figureanchor8-1">Figure 8-1</a>. The C key (for clear) clears the entry, and the V key (for valid) validates it.</p>
<figure>
<img src="image_fi/278748c08/f08001.png" alt="f08001"/>
<figcaption><p><a id="figure8-1">Figure 8-1</a>: A simple keypad</p></figcaption>
</figure>
<p>To perform the attack, we connect two oscilloscope probes to the keypad: one to the connecting wire on the V button and the other to the connecting wire on the error LED. We then enter PIN 0000. (Of course, we are assuming we have access to a copy of this PIN pad that we’ve now dissected.) We press the V button, watch our oscilloscope trace, and measure the time <span epub:type="pagebreak" title="248" id="Page_248"/>difference between the V button being pressed and the error LED illuminating. The execution of the loop in <a href="#listing8-1">Listing 8-1</a> tells us that the function will take longer to return a failed result if the first three numbers in the PIN are correct and only the final check fails than it would take if the first number had been incorrect from the start.</p>
<p>The attack cycles through all possibilities for the first digit of the PIN (0000, 1000, 2000, through 9000) while recording the time delay between pressing the V button and the error LED illuminating. <a href="#figure8-2" id="figureanchor8-2">Figure 8-2</a> shows the timing sequence.</p>
<figure>
<img src="image_fi/278748c08/f08002.png" alt="f08002"/>
<figcaption><p><a id="figure8-2">Figure 8-2</a>: Determination of loop delay time</p></figcaption>
</figure>
<p>We expect that when the first PIN digit is correct (let’s say it’s a 1), the delay will increase before the error LED goes high, which happens only after the second digit has been compared to <code>correct_pin[]</code>. We now know the correct first digit. The top part of <a href="#figure8-2">Figure 8-2</a> shows that when the valid button is pressed after a completely incorrect sequence, the error LED turns on within a short amount of time (t<sub>bad</sub>). Compare this to the valid button being pressed after a partially correct sequence (the first button was correct in this partial sequence). Now the error LED takes a longer amount of time (t<sub>correct</sub>) since the first number was correct, but upon comparing the second number, it turns on the error LED.</p>
<p>We continue the attack by trying every possibility for the second digit: entering 1000, 1100, 1200 through 1900. Once again, we expect that for the correct digit (let’s say it’s 3), the delay will increase before the error LED goes high.</p>
<p>Repeating this attack for the third digit, we determine that the first three digits are 133. Now it’s a simple matter of guessing the final digit and seeing which one unlocks the system (let’s say it’s 7). The PIN combination is, thus, 1337. (Considering the audience of this book, we realize we may have just published your PIN. Change it now.)</p>
<p><span epub:type="pagebreak" title="249" id="Page_249"/>The advantage to this method is that we discover the digits incrementally by knowing the position in the PIN sequence of the incorrect digit. This little bit of information has a big impact. Instead of a maximum of 10 × 10 × 10 × 10 guesses, we now need to make no more than 10 + 10 + 10 + 10 = 40 guesses. If we are locked out after three unsuccessful attempts, the probability of guessing the PIN has been improved from 3/1000 (0.3 percent) to 3/40 (7.5 percent). Further, assuming the PIN is selected randomly (which in reality is a poor assumption), we would on average <em>find</em> the guess halfway through our guessing sequence. This means, on average, we need to guess only five numbers for each digit, so we have an average total of 20 guesses with our assisted attack.</p>
<p>We call this a <em>timing attack</em>. We measured only the time between two events and used that information to recover part of the secret. Can it really be as easy in practice? Here’s a real-life example.</p>
<h3 id="h2-278748c08-0001">Hard Drive Timing Attack</h3>
<p class="BodyFirst">Consider a hard drive enclosure with a PIN-protected partition—in particular, the Vantec Vault, model number NSTV290S2.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Although this product is no longer available in stores, you may still find some old stock. For full details of this attack, see the freely available PoC || GTFO 0x04, available from online mirrors such as <a href="https://archive.org/stream/pocorgtfo04#page/n36/mode/1up/" class="LinkURL">https://archive.org/stream/pocorgtfo04#page/n36/mode/1up/</a> (and also available in bound format from No Starch Press in <em>PoC</em><em> </em><em>||</em><em> </em><em>GTFO</em>).</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The Vault hard drive enclosure works by messing with the drive’s partition table so that it doesn’t appear in the host operating system; the enclosure doesn’t actually encrypt anything. When the correct PIN is entered into the Vault, valid partition information is made accessible to the operating system.</p>
<p>The most obvious way to attack the Vault might be to repair the partition table manually on the drive, but we can also use a timing attack against its PIN-entry logic—one that’s more in line with our side-channel power analysis.</p>
<p>Unlike the PIN pad example discussed earlier, we first need to determine when a button is <em>read</em>, because in this device, the microcontroller only occasionally <em>scans</em> the buttons. Each scan requires checking the status of each button to determine whether it has been pressed. This scanning technique is standard in hardware that must receive input from buttons. It frees the microcontroller in the hardware to do work in the 100ms or so between checking for button presses, which maintains the illusion of instantaneous response to us comparatively slow and clumsy humans.</p>
<p>When performing a scan, the microcontroller sets some line to a positive voltage (high). We can use this transition as a trigger to indicate when a button is being read. While a button is pressed, the time delay from this line going high to the <em>error</em> event gives us the timing information we need for our attack. <a href="#figure8-3" id="figureanchor8-3">Figure 8-3</a> shows that line B goes high only when the <span epub:type="pagebreak" title="250" id="Page_250"/>microcontroller is reading the button status <em>and</em> the button is being pressed at the same time. Our primary challenge is to trigger the capture when that high value propagates through the button, not just when the button is pushed.</p>
<figure>
<img src="image_fi/278748c08/f08003.png" alt="f08003"/>
<figcaption><p><a id="figure8-3">Figure 8-3</a>: Hard drive attack timing diagram</p></figcaption>
</figure>
<p>This simple example shows how the microcontroller checks the state of the button only every 50ms, as shown by the upper timing line A. It can detect the button press only during brief high pulses at those 50ms intervals. The presence of a button press is indicated by the correspondingly brief high pulse that the A line pulse allows through onto the B line.</p>
<p><a href="#figure8-4" id="figureanchor8-4">Figure 8-4</a> shows the buttons along the right-hand side of the hard drive enclosure by which a six-digit PIN code is entered. Only once the entire correct PIN is entered does the hard drive reveal its contents to the operating system.</p>
<p>It so happens that the correct PIN code in our hard drive is 123456 (the same combination as on our luggage), and <a href="#figure8-5" id="figureanchor8-5">Figure 8-5</a> demonstrates how we can read this out.</p>
<p>The top line is the error signal, and the bottom line is the button scan signal. The vertical cursors are aligned to the rising edge of the button scan signal and to the falling edge of the error<em> </em>signal. We’re interested in the time difference between those cursors, which corresponds to the time the microcontroller needs to process the PIN entry before it responds with an error.</p>
<p>Looking at the top part of the figure, we see the timing information where the first digit is incorrect. The time delay between the first rising edge of the button scan and the falling edge of the error<em> </em>signal gives us the processing time. By comparison, the bottom part of the figure shows the same waveforms when the first digit is correct. Notice that the time delay is<em> </em>slightly longer. This longer delay is due to the password-checking loop accepting the first digit and then going to check the next digit. In this way, we can identify the first digit of the password.</p>
<span epub:type="pagebreak" title="251" id="Page_251"/><figure>
<img src="image_fi/278748c08/f08004.png" alt="f08004"/>
<figcaption><p><a id="figure8-4">Figure 8-4</a>: Vantec Vault NSTV290S2 hard drive enclosure</p></figcaption>
</figure>
<figure>
<img src="image_fi/278748c08/f08005.png" alt="f08005"/>
<figcaption><p><a id="figure8-5">Figure 8-5</a>: Hard drive timing measurement</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="252" id="Page_252"/>The next stage of the attack is to iterate through all options for the second digit (that is, testing 106666, 116666 . . . 156666, 166666) and looking for a similar jump in processing delay. This jump in delay again indicates that we have found the correct value of a digit and can then attack the next digit.</p>
<p>We can use a timing attack to guess the password for the Vault in (at most) 60 guesses (10 + 10 + 10 + 10 + 10 + 10), which should take no longer than 10 minutes doing it manually. Yet, the manufacturer claims that the Vault has one million combinations (10 × 10 × 10 × 10 × 10 × 10), which is true when entering guesses of the PIN. However, our timing attack reduces the number of combinations we actually need to try to 0.006 percent of the total number of combinations. No countermeasures such as random delays complicate our attack, and the drive doesn’t provide a lock-out mechanism that prevents the user from entering an unlimited number of guesses.</p>
<h3 id="h2-278748c08-0002">Power Measurements for Timing Attacks</h3>
<p class="BodyFirst">Let’s say that in an attempt to thwart a timing attack, someone has inserted a small random delay before illuminating the error LED. The underlying password check is the same as that in <a href="#listing8-1">Listing 8-1</a>, but now the time delay between pressing the V button and the error LED illuminating no longer clearly indicates the position of an incorrect digit.</p>
<p>Now assume we’re able to measure the power consumption of the microcontroller that’s executing the code. (We’ll explain how to do this in the section “Preparing the Oscilloscope” in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>.) The power consumption might look something like <a href="#figure8-6" id="figureanchor8-6">Figure 8-6</a>, which shows the power trace of a device while it’s performing an operation.</p>
<figure>
<img src="image_fi/278748c08/f08006.png" alt="f08006"/>
<figcaption><p><a id="figure8-6">Figure 8-6</a>: A sample power consumption trace of a device performing an operation</p></figcaption>
</figure>
<p>Notice the repetitive nature of the power consumption trace. Oscillations will occur at a rate similar to the microcontroller’s operating frequency. Most transistor-switching activity on the chip happens at the edges of the clock, and thus the power consumption also spikes close to those moments. The same principle applies even to high-speed devices, such as Arm microcontrollers or custom hardware.</p>
<p>We can glean some information about what a device is doing based on this power signature. For example, if the random delay discussed earlier is implemented as a simple <code>for</code> loop that counts from 0 to a random number <em>n</em>, it will appear as a pattern that is repeated <em>n</em> times. In window B of <a href="#figure8-6">Figure 8-6</a>, a pattern (in this case, the simple pulse) is repeated four times, so if we expect a random delay, that sequence of four pulses may be the delay. If we record a few of these power traces using the same PIN, and <span epub:type="pagebreak" title="253" id="Page_253"/>all patterns are the same except for different numbers of pulses similar to window B, that would indicate a random process around window B. This randomness could be either a truly random process or some pseudorandom process (pseudorandom normally being a purely deterministic process generating the “randomness”). For example, if you reset the device, you might see the same consecutive repetitions in window B, which indicates it’s not truly random. But of more interest, if we vary the PIN and see the number of patterns that look like those in window A change, we have a good idea that the power sequence around window A represents the comparison function. Thus, we can focus our timing attack on that section of the power trace.</p>
<p>The difference between this approach and previous timing attacks is that we don’t have to measure timing over an entire algorithm but instead can choose specific parts of an algorithm that happen to have a characteristic signal. We can use similar techniques to break cryptographic implementations, as we’ll describe next.</p>
<h2 id="h1-278748c08-0002">Simple Power Analysis</h2>
<p class="BodyFirst">Everything is relative, and so is the simplicity of <em>simple power analysis (SPA)</em> with respect to <em>differential power analysis (DPA)</em>. The term <em>simple power analysis</em> has its origins in the 1998 paper “Differential Power Analysis” by Paul Kocher, Joshua Jaffe, and Benjamin Jun, where SPA was coined along with the more complex DPA. Bear in mind, however, that performing SPA can sometimes be more complex than performing DPA in some leakage scenarios. You can perform an SPA attack by observing a single execution of the algorithm, whereas a DPA attack involves multiple executions of an algorithm with varying data. DPA generally analyzes statistical differences between hundreds to billions of traces. While you can perform SPA in a single trace, it may involve a few to thousands of traces—the additional traces are included to reduce noise. The most basic example of an SPA attack is to inspect power traces visually, which can break weak cryptographic implementations or PIN verifications, as shown earlier in this chapter.</p>
<p>SPA relies on the observation that each microcontroller instruction has its own characteristic appearance in power consumption traces. For example, a multiplication operation can be distinguished from a load instruction: microcontrollers use different circuitry to handle multiplication instructions from the circuitry they use when performing load instructions. The result is a unique power consumption signature for each process.</p>
<p>SPA differs from the timing attack discussed in the previous section, in that SPA allows you to examine the execution of an algorithm. You can analyze the timing of both individual operations and identifiable power profiles of operations. If any operation depends on a secret key, you may be able to determine that key. You can even use SPA attacks to recover secrets when you can’t interact with a device and can observe it only while it’s performing the cryptographic operation.</p>
<h3 id="h2-278748c08-0003"><span epub:type="pagebreak" title="254" id="Page_254"/>Applying SPA to RSA</h3>
<p class="BodyFirst">Let’s apply the SPA technique to a cryptographic algorithm. We’ll concentrate on asymmetric encryption, where we’ll look at operations using the private key. The first algorithm to consider will be the RSA cryptosystem, where we’ll investigate a decryption operation. At the core of the RSA cryptosystem is the modular exponentiation algorithm, which calculates <em>m</em><sub><em>e</em></sub> = <em>c</em> mod <em>n</em>, where <em>m</em> is the message, <em>c</em> is the ciphertext, and mod <em>n</em> is the modulus operation. If you aren’t familiar with RSA, we recommend picking up <em>Serious Cryptography</em> by Jean-Philippe Aumasson (also published by No Starch Press), which covers the theory in an approachable manner. We also provided a quick overview of RSA in Chapter 6, but for the following side-channel work, you don’t need to understand anything about RSA besides the fact that it processes data and a secret key.</p>
<p>This secret key is part of the processing done in the modular exponentiation algorithm, and <a href="#listing8-2" id="listinganchor8-2">Listing 8-2</a> shows one possible implementation of a modular exponentiation algorithm.</p>
<pre><code>unsigned int do_magic(unsigned int secret_data, unsigned int m, unsigned int n) {
    unsigned int P = 1;
    unsigned int s = m;
    unsigned int i;

    for(i = 0; i &lt; 10; i++) {
        if (i &gt; 0)
            s = (s * s) % n;

        if (secret_data &amp; 0x01)
            P = (P * s) % n;

        secret_data = secret_data &gt;&gt; 1;
    }

    return P;
}</code></pre>
<p class="CodeListingCaption"><a id="listing8-2">Listing 8-2</a>: An implementation of the square-and-multiply algorithm</p>
<p>This algorithm happens to be at the heart of an RSA implementation you might find as taught from a classic textbook. This particular algorithm is called a <em>square-and-multiply exponentiation</em>, hard-coded for a 10-bit secret key, represented by the <code>secret_data</code> variable. (Usually the <code>secret_data</code> would be a much longer key in the range of thousands of bits, but for this example, we’ll keep it short.) Variable <code>m</code> is the message we are trying to decrypt. The system defenses will have been penetrated at the point when an attacker determines the value of <code>secret_data</code>. Side-channel analysis on this algorithm is a tactic that can break the system. Note that we skip the square on the first iteration. The first <code>if (i &gt; 0)</code> is not part of the leakage we are attacking; it’s just part of the algorithm construction.</p>
<p>SPA can be used to look at the execution of this algorithm and determine its code path. If we can recognize whether <code>P * s</code> has been executed, <span epub:type="pagebreak" title="255" id="Page_255"/>we can find the value of one bit of <code>secret_data</code>. If we can recognize this for every iteration of the loop, we may be able to literally read the secret from a power consumption oscilloscope trace during code execution (see <a href="#figure8-7" id="figureanchor8-7">Figure 8-7</a>).</p>
<p>Before we explain how to read this trace, take a good look at the trace and try to map the execution of the algorithm onto it.</p>
<figure>
<img src="image_fi/278748c08/f08007.png" alt="f08007"/>
<figcaption><p><a id="figure8-7">Figure 8-7</a>: Power consumption trace of a square-and-multiply execution</p></figcaption>
</figure>
<p>Notice some interesting patterns between roughly 5ms and 12ms (between 50 and 120 on the 100µs unit x-axis): blocks of approximately 0.9ms and 1.1ms interspersed among each other. We can refer to the shorter blocks as Q (quick) and to the longer blocks as L (long). Q occurs 10 times, and L occurs four times; in sequence, they are QLQQQQLQLQQQQL. This is the visualization part of SPA signal analysis.</p>
<p>Now we need to interpret this information by relating it to something secret. If we assume that <code>s * s</code> and <code>P * s</code> are the computationally expensive operations, we should see two variations of the outer loop: some with only a square (S,<code> (s * s)</code>) and others that are both a square and a multiply (SM,<code> (s * s)</code> followed by<code> (P * s)</code>). We’ve carefully ignored the <code>i = 0</code> case, which doesn’t have <code>(s * s)</code>, but we’ll get to that.</p>
<p>We know that S is executed when a bit is 0, and SM is executed when a bit equals 1. There is just one missing piece: does each block in the trace equate to a single S or single M operation, or does each block in the trace equate to a single loop iteration, and thus either a single S or combined SM operation? In other words, is our mapping {Q → S, L → M} or {Q → S, L → SM}?</p>
<p>A hint to the answer lies in the sequence QLQQQQLQLQQQQL. Note that every L is preceded by a Q, and there are no LL sequences. Per the algorithm, every M has to be preceded by an S (except in the first iteration), and there are no MM sequences. This indicates {Q → S, L → M} is the right mapping as the {Q → S, L → SM} mapping would likely have also given rise to an LL sequence.</p>
<p>This allows us to map the patterns to operations and operations to secret bits, which means QLQQQQLQLQQQQL becomes the operations SM,S,S,S,SM,SM,S,S,S,SM. The first bit processed by the algorithm is the least significant bit of the key, and the first sequence we observe is SM. Since the algorithm skips the S for the least significant bit, we know the initial SM must come from the next loop iteration and thus the next bit. With that knowledge, we can reconstruct the key: 10001100010.</p>
<h3 id="h2-278748c08-0004"><span epub:type="pagebreak" title="256" id="Page_256"/>Applying SPA to RSA, Redux</h3>
<p class="BodyFirst">The implementation of modular exponentiation in RSA implementations will vary, and some variants may require more effort to break. But fundamentally, finding differences in processing a 0 or 1 bit is the starting point for an SPA attack. As an example, the RSA implementation of ARM’s open source MBED-TLS library uses something called <em>windowing</em>. It processes multiple bits of the secret at a time (a <em>window</em>), which theoretically means the attack is more complicated because the algorithm does not process individual bits. Praveen Kumare Vadnala and Lukasz Chmielewski’s “Attacking OpenSSL Using Side-Channel Attacks: The RSA Case Study” describes a complete attack on the windowing implementation used by MBED-TLS.</p>
<p>We specifically call out that having a simple model is a good starting point, even when the implementation isn’t exactly the same as the model, because even the best implementations may have flaws that can be explained/exploited by the simple model. The implementation of the windowing modular exponentiation function used by MBED-TLS version 2.26.0 in the RSA decryption is such an example. In the following discussion, we’ve taken the <em>bignum.c</em> file from MBED-TLS and simplified part of the <code>mbedtls_mpi_exp_mod</code> function to produce the code in <a href="#listing8-3" id="listinganchor8-3">Listing 8-3</a>, which assumes we have a <code>secret_key</code> variable holding the secret key, and a <code>secret_key_size</code> variable holding the number of bits to process.</p>
<pre><code>   int ei, state = 0;
 <span class="CodeAnnotationCode" aria-label="annotation1">1</span> for( int i = 0; i &lt; secret_key_size; i++ ){
     <span class="CodeAnnotationCode" aria-label="annotation2">2</span> ei = (secret_key &gt;&gt; i) &amp; 1;
     <span class="CodeAnnotationCode" aria-label="annotation3">3</span> if( ei == 0 &amp;&amp; state == 0 )
           // Do nothing, loop for next bit
       else
         <span class="CodeAnnotationCode" aria-label="annotation4">4</span> state = 2;
<em>   </em>}
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing8-3">Listing 8-3</a>: Pseudocode of <em>bignum.c</em> showing part of the <code>mbedtls_mpi_exp_mod</code> implementation flow</p>
<p>We’ll refer you to original line numbers of the <em>bignum.c</em> file in MBED-TLS version 2.26.0 in case you want to find the specific implementation. To start, the outer <code>for()</code> loop <span class="CodeAnnotation" aria-label="annotation1">1</span> from <a href="#listing8-3">Listing 8-3</a> is implemented as a <code>while(1)</code> loop in MBED-TLS and can be found at line 2227.</p>
<p>One bit of the secret key is loaded into the <code>ei</code> variable <span class="CodeAnnotation" aria-label="annotation2">2</span> (line 2241 in original file). As part of the modular exponentiation implementation, the function will process the secret key bits until the first bit with a value of 1 is reached. To perform this processing, the <code>state</code> variable is a flag indicating whether we are done processing all the leading zeros. We can see the comparison at <span class="CodeAnnotation" aria-label="annotation3">3</span>, which skips to the next iteration of the loop if <code>state == 0</code> (meaning we haven’t seen a 1 bit yet) and the current secret key bit (<code>ei</code>) is 0.</p>
<p>Interestingly, the order of operations in the comparison <span class="CodeAnnotation" aria-label="annotation3">3</span> turns out to be a completely fatal flaw for this function. The trusty C compiler will <em>often</em> first perform the <code>ei == 0</code> comparison before the <code>state == 0</code> comparison. The <code/><span epub:type="pagebreak" title="257" id="Page_257"/>ei comparison <em>always</em> leaks the value of the secret key bit <span class="CodeAnnotation" aria-label="annotation4">4</span>, for all of the key bits. It turns out you can pick this up with SPA.</p>
<p>If the <code>state</code> comparison was done first instead, the comparison would never even reach the point of checking the <code>ei</code> value once the <code>state</code> variable was nonzero (the <code>state</code> variable becomes nonzero after processing the first secret key bit set to 1). The simple fix (which may not work with every compiler) is to swap the order of the comparison to be <code>state == 0 &amp;&amp; ei == 0</code>. This example shows the importance of checking your implementation as a developer and the value in making basic assumptions as an attacker.</p>
<p>As you can see, SPA exploits the fact that different operations introduce differences in power consumption. In practice, you should easily be able to see different instruction paths when they differ by a few dozen clock cycles, but those differences will become harder to see as the instruction paths get closer to taking only a single cycle. The same limitation holds for data-dependent power consumption: if the data affects many clock cycles, you should be able to read the path, but if the difference is just a small power variation at an individual instruction, you’ll see it only on particularly leaky targets. Yet, if these operations directly link to secrets, as in <a href="#figure8-7">Figure 8-7</a>, you should still be able to learn those secrets.</p>
<p>Once the power variations dip below the noise level, SPA has one more trick up its sleeve before you may want to switch to DPA: <em>signal processing</em>. If your target executes its critical operations in a constant time with constant data and a constant execution path, you can rerun the SPA operations many times and average the power measurements in order to counter noise. We’ll discuss more elaborate filtering in Chapter 11. However, sometimes the leakage is so small that we need heavy statistics to detect it, and that’s where DPA comes in. You’ll learn more about DPA in Chapter 10.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Cryptographic Timing Attacks</h2>
<p class="BoxBodyFirst">Just as the PIN code example shown in <a href="#listing8-1">Listing 8-1</a> has an execution time that depends on the input data (and thus leaks internal secret variables), cryptographic algorithms also can be vulnerable to timing attacks. We are concentrating on power side-channel analysis in this chapter instead of on pure timing techniques, so we’ll give only brief overview of cryptographic timing attacks here.</p>
<p>A great reference for cryptographic timing attacks is a paper by Paul Kocher released in 1996, titled “Timing Attacks on Implementations of Diffie Hellman, RSA, DSS, and Other Systems.” The timing attack uses the fact that the execution time of certain operations depends on the <em>key bits</em> (the secret data). For example, <a href="#listing8-2">Listing 8-2</a> presents a chunk of code that might be found in an RSA implementation. Notice that the execution path branches differently depending on whether bits are set, which therefore likely affects the total execution time. Timing attacks exploit this branching to determine which key bits have been set.</p>
<p><span epub:type="pagebreak" title="258" id="Page_258"/>Also very relevant in more complex systems are cache timing attacks. Specifically, algorithms that use lookup tables for certain operations can leak information revealing which element is being accessed when a timing variation analysis is performed. The basic premise is that the time it takes to access a certain memory address depends on whether that address is in a memory cache. If we can measure that time and relate memory accesses to secrets being processed, we’re in business. Daniel J. Bernstein’s 2005 paper “Cache-Timing Attacks on AES” demonstrates an attack against an OpenSSL implementation of AES. This attack vector can be completely executed from software, presenting an opportunity for not only the attacker of physically accessible hardware, but also for attacks over remote networks.</p>
<p>Later we’ll see a better way to determine the encryption key bits for this same algorithm using simple power analysis, so we won’t discuss further details of the timing attack in this chapter. For most embedded system hardware, it’s much more practical and effective to attack using power analysis.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside><h3 id="h2-278748c08-0005">SPA on ECDSA </h3>
<p class="BodyFirst">This section uses the companion notebook for this chapter (available at <a href="https://nostarch.com/hardwarehacking/" class="LinkURL">https://nostarch.com/hardwarehacking/</a>). Keep it handy, as we’ll reference it throughout this section. The section titles in this book match the section titles in the notebook.</p>
<h4 id="h3-278748c08-0001">Goal and Notation</h4>
<p class="BodyFirst">The <em>Elliptic Curve Digital Signature Algorithm (ECDSA)</em> uses <em>elliptic curve cryptography (ECC)</em> to generate and verify secure signature keys. In this context, a digital <em>signature</em> applied to a computer-based document is used to verify cryptographically that a message is from a trusted source or hasn’t been modified by a third party.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	ECC is becoming a more popular alternative to RSA-based crypto, mostly because ECC keys can be much shorter while maintaining cryptographic strength. The math behind ECC is way beyond the scope of this book, but you don’t need to understand it fully in order to perform an SPA attack on it. Case in point: neither of the authors fully understand ECC. We just need to know the implementation to understand the attack.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The goal is to use SPA to recover the private key <code>d</code> from the execution of an ECDSA signature algorithm so that we can use it to sign messages purporting to be the sender. At a high level, the inputs to an ECDSA signature are the private key <code>d</code>, the public point <code>G</code>, and a message <code>m</code>, and the output is a signature <code>(r,s)</code>. One weird thing about ECDSA is that the signatures are different every time, even for the same message. (You’ll see why in a moment.) The ECDSA <em>verification </em>algorithm verifies a message by taking the <span epub:type="pagebreak" title="259" id="Page_259"/>public point <code>G</code>, public key <code>pd</code>, message <code>m</code>, and the signature <code>(r,s)</code> as inputs. A <em>point</em> is nothing more than a set of xy-coordinates on a <em>curve</em>—hence the C in ECDSA.</p>
<p>In developing our attack, we rely on the fact that the ECDSA signature algorithm internally uses a random number <code>k</code>. This number must be kept secret, because if the value of <code>k</code> of a given signature <code>(r,s)</code> is revealed, you can solve for <code>d</code>. We’re going to extract <code>k</code> using SPA and then solve for <code>d</code>. We’ll refer to <code>k</code> as a <em>nonce</em>, because besides requiring secrecy, it must also remain unique (<em>nonce</em> is short for “number used once”).</p>
<p>As you can see in the notebook, a few basic functions implement ECDSA signing and verification, and some lines exercise these functions. For the remainder of this notebook, we create a random public/private key <code>pd/d</code>. We also create a random message hash <code>e</code> (skipping the actual hashing of a message <code>m</code>, which is not relevant here). We perform a signing operation and verification operation, just to check that all is well. From here on, we’ll use only the public values, plus a simulated power trace, to recover the private values.</p>
<h4 id="h3-278748c08-0002">Finding a Leaky Operation</h4>
<p class="BodyFirst">Now, let’s tickle your brain. Check the functions <code>leaky_scalar_mul()</code> and <code>ecdsa_sign_leaky()</code>. As you know, we’re after nonce <code>k</code>, so try to find it in the code. Pay specific attention to how nonce <code>k</code> is processed by the algorithm and come up with some hypotheses on how it may leak into a power trace. This is an SPA exercise, so try to spot the secret-dependent operations.</p>
<p>As you may have figured out, we’ll attack the calculation of the nonce <code>k</code><em> </em>multiplied by public point <code>G</code>. In ECC, this operation is called a <em>scalar multiplication</em> because it multiplies a scalar <code>k</code> with a point <code>G</code>.</p>
<p>The textbook algorithm for scalar multiplication takes the bits of <code>k</code> one by one, as implemented in <code>leaky_scalar_mul()</code>. If the bit is 0, only a point-doubling is executed. If the bit is 1, both a point-addition and a point-doubling are executed. This is much like textbook RSA modular exponentiation, and as such, it also leads to an SPA leak. If you can differentiate between point-doubling only and point-addition followed by point-doubling, you can find the individual bits of <code>k</code>. As mentioned before, we can then calculate the full private key <code>d</code>.</p>
<h4 id="h3-278748c08-0003">Simulating SPA Traces of a Leaky ECDSA</h4>
<p class="BodyFirst">In the notebook, <code>ecdsa_sign_leaky()</code> signs a given message with a given private key. In doing so, it leaks the simulated timing of the loop iterations in the scalar multiplication implemented in <code>leaky_scalar_mul()</code>. We’re obtaining this timing by randomly sampling a normal distribution. In a real target, the timing characteristics will be different from what we do here. However, any measurable timing difference between the operations will be exploitable in the same way.</p>
<p>Next, we turn the timings into a simulated power trace using the function <code>timeleak_to_trace()</code>. The start of such a trace will be plotted in the notebook; <a href="#figure8-8" id="figureanchor8-8">Figure 8-8</a> also shows an example.</p>
<span epub:type="pagebreak" title="260" id="Page_260"/><figure>
<img src="image_fi/278748c08/f08008.png" alt="f08008"/>
<figcaption><p><a id="figure8-8">Figure 8-8</a>: Simulated ECDSA power consumption trace showing nonce bits</p></figcaption>
</figure>
<p>In this simulated trace, you can see an SPA timing leakage where the loops performing point-doublings (secret nonce <code>k</code> bit = 0) are shorter in duration than loops that perform both point-addition and point-doubling (secret nonce <code>k</code> bit = 1).</p>
<h4 id="h3-278748c08-0004">Measuring Scalar Multiplication Loop Duration</h4>
<p class="BodyFirst">When attacking an unknown nonce, we’ll have a power trace, but we don’t know the bits for <code>k</code>. Therefore, we analyze the distances between the peaks using <code>trace_to_difftime()</code> in the notebook. This function first applies a vertical threshold to the traces to get rid of amplitude noise and turn the power trace into a “binary” trace. The power trace is now a sequence of 0 (low) and 1 (high) samples.</p>
<p>We’re interested in the duration of all sequences of ones because they measure the duration of the scalar multiplication loop. For example, the <span epub:type="pagebreak" title="261" id="Page_261"/>sequence [1, 1, 1, 1, 1, 0, 1, 0, 1, 1] turns into the durations [5, 1, 2], corresponding to the number of sequential ones. We apply some NumPy magic (explained in more detail in the notebook) to accomplish this conversion. Next, we plot these durations on top of the binary trace; <a href="#figure8-9" id="figureanchor8-9">Figure 8-9</a> shows the result.</p>
<figure>
<img src="image_fi/278748c08/f08009.png" alt="f08009"/>
<figcaption><p><a id="figure8-9">Figure 8-9</a>: Binary ECDSA power consumption trace showing SPA timing leakage</p></figcaption>
</figure>
<h4 id="h3-278748c08-0005">From Durations to Bits</h4>
<p class="BodyFirst">In an ideal world, we would have “long” and “short” durations as well as one cutoff that correctly separates the two. If a duration is below the cutoff, we would have only point-doubling (secret bit 0), or as shown earlier, we would have both point-addition and point-doubling (secret bit 1). Alas, in reality, timing jitter will cause this naive SPA to fail because the cutoff is not able to separate the two distributions perfectly. You can see this effect in the notebook and <a href="#figure8-10" id="figureanchor8-10">Figure 8-10</a>.</p>
<span epub:type="pagebreak" title="262" id="Page_262"/><figure>
<img src="image_fi/278748c08/f08010.png" alt="f08010"/>
<figcaption><p><a id="figure8-10">Figure 8-10</a>: The distribution of the durations for a double-only (left) and a double-and-add (right) overlap, disallowing the duration to be a perfect predictor.</p></figcaption>
</figure>
<p>How do you solve for this? An important insight is that we have a good idea of which bits are likely incorrect: namely, the ones that are closest to the cutoff. In the notebook, the <code>simple_power_analysis()</code> function analyzes the duration for each operation. Based on this analysis, it generates a guessed value for <code>k</code> and a list of bits in <code>k</code> that are closest to the cutoff. The cutoff is determined as the mean of the 25th and 75th percentiles in the duration distribution, as this is more stable than taking the average.</p>
<h4 id="h3-278748c08-0006">Brute-Forcing the Way Out</h4>
<p class="BodyFirst">Since we have an initial guess of <code>k</code> and the bits closest to the cutoff, we can simply brute-force those bits. In the notebook, we do this in the <code>bruteforce()</code> function. For all candidates for <code>k</code>, a value of the private key <code>d</code> is calculated.</p>
<p>The function has two means of verifying whether it found the correct <code>d</code>. If it has access to the correct <code>d</code>, it can cheat by comparing the calculated <code>d</code> with the correct <code>d</code>. If it doesn’t have access to the correct <code>d</code>, it calculates the <span epub:type="pagebreak" title="263" id="Page_263"/>signature <code>(r,s)</code> from the guessed <code>k</code> and calculated <code>d</code> and then checks that this signature is correct. This process is much, much slower, but it’s something you’ll face when doing this for real.</p>
<p>Even this brute-force attack won’t always yield the correct nonce, so we’ve put it in a giant loop for you. Let it run for a while, and it will recover the private key simply from only SPA timings. After some time, you’ll see something like <a href="#listing8-4" id="listinganchor8-4">Listing 8-4</a>.</p>
<pre><code>Attempt 16
Guessed k: 0b111111110001100101011110000110101100011100000011001111010011001111010001000010110110110010011001001100000011101000110111010101011010001110011000010001100000010100001101111010000000010010010000110110111100001101001111010110001000110011101000010010100101101
Actual k:  0b111111110001100101011110000110101100011100001011001111010011001111010001000010110110110010011111001100000011101000110111010101011010001110011000010001100000010100001101111010000000010010010000111110111100001101001111010110001000110011101000010010100101101
Bit errors: 4
Bruteforcing bits: [241  60 209 160 161 212  34  21]
No key for you.


Attempt 17
Guessed k: 0b11111011101110001001010000100001101011000000100111000001011010011010010000110110000110010010011111000110110111011100110001110101010110000000100110001111101000110010001101001100011101101010111000110111110011101001011110010100011101100011100011011000100
Actual k:  0b11111011101110001001010000100001101011000000110111000001011010011010010000110110000110010110011111000110110111011101110001110101010110000000100110011111101000111010001101001100011101101010111000110111110011101001011110010100011101101011100011011000100
Bit errors: 6
Bruteforcing bits: [103 185 135 205  18 161  90  98]
Yeash! Key found:0b110101001000000000010001100011000010100101101011100001101001100010111011101111000011100111101101000010100000111001001111110010111100001010001001010010111100110100100000001001110001010111100100000100101010010101110101001110110100010011100000001100101110</code></pre>
<p class="CodeListingCaption"><a id="listing8-4">Listing 8-4</a>: Output of the Python ECDSA SPA attack</p>
<p>Once you see this, the SPA algorithm has successfully recovered the key only from some noisy measurements of the simulated durations of the scalar multiplication.</p>
<p>This algorithm has been written to be fairly portable to other ECC (or RSA) implementations. If you’re going after a real target, first creating a simulation like this notebook that mimics the implementation is recommended just to show that you can positively do key extraction. Otherwise, you’ll never know whether your SPA failed because of the noise or because you have a bug somewhere.</p>
<h2 id="h1-278748c08-0003"><span epub:type="pagebreak" title="264" id="Page_264"/>Summary</h2>
<p class="BodyFirst">Power analysis is a powerful form of a side-channel attack. The most basic type of power analysis is a simple extension of a timing side-channel attack, which gives better visibility into what a program is executing internally. In this chapter, we showed how simple power analysis could break not only password checks but also some real cryptographic systems, including RSA and ECDSA implementations.</p>
<p>Performing this theoretical and simulated trace might not be enough to convince you that power analysis really is a threat to a secure system. Before going further, next we’ll take you through the setup for a basic lab. You’ll get your hands on some hardware and perform basic SPA attacks, allowing you to see the effect of changing instructions or program flow in the power trace. After exploring how power analysis measurement works, we’ll look at advanced forms of power analysis in subsequent chapters.</p>
</section>
</body></html>