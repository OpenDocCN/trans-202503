<html><head></head><body>
<p id="filepos69411" class="calibre_"><span class="calibre6"><span class="bold">
</span></span><span class="calibre1"><span class="bold">1</span></span><br class="calibre5"/><span class="calibre6"><span class="bold">C# CRASH COURSE</span></span></p><p class="calibre_12"><img src="images/00010.jpg" class="calibre_13"/></p><p class="calibre_6">Unlike other languages, such as Ruby, Python, and Perl, C# programs can be run by default on all modern Windows machines. In addition, running programs written in C# on a Linux system such as Ubuntu, Fedora, or another flavor couldn’t be easier, especially since Mono can quickly be installed by most Linux package managers like <span class="calibre4">apt</span> or <span class="calibre4">yum</span>. This puts C# in a better position to meet cross-platform needs than most languages, with the benefit of an easy and powerful standard library at your fingertips. All in all, C# and the Mono/.NET libraries make a compelling framework for anyone wanting to write cross-platform tools quickly and easily.</p><p id="filepos70424" class="calibre_10"><span class="calibre3"><span class="bold">Choosing an IDE</span></span></p><p class="calibre_11">Most who want to learn C# will use an integrated development environment (IDE) like Visual Studio for writing and compiling their code. Visual Studio by Microsoft is the de facto standard for C# development around the globe. Free versions such as Visual Studio Community Edition are available for personal use and can be downloaded from Microsoft’s website at <a href="https://www.visualstudio.com/downloads/"><span class="italic">https://www.visualstudio.com/downloads/</span></a>.</p><p class="calibre_6">During the development of this book, I used MonoDevelop and Xamarin Studio depending on whether I was on Ubuntu or OS X, respectively. On Ubuntu, you can easily install MonoDevelop using the <span class="calibre4">apt</span> package manager. MonoDevelop is maintained by Xamarin, the company that also maintains Mono. To install it, use the following command: $ <span class="bold">sudo apt-get install monodevelop</span> Xamarin Studio is the OS X brand of the MonoDevelop IDE. Xamarin Studio and MonoDevelop have the same functionality, but with slightly different user interfaces. You can download the installer for the Xamarin Studio IDE from the Xamarin website at <a href="https://www.xamarin.com/download-it/"><span class="italic">https://www.xamarin.com/download-it/</span></a>.</p><p class="calibre_6">Any of these three IDEs will fulfill our needs in this book. In fact, if you just want to use <span class="calibre4">vim</span>, you don’t even need an IDE! We’ll also soon cover how to compile a simple example using the command line C# compiler shipped with Mono instead of an IDE.</p><p id="filepos72135" class="calibre_10"><span class="calibre3"><span class="bold">A Simple Example</span></span></p><p class="calibre_11">To anyone who’s used C or Java, the C# syntax will seem very familiar. C# is a strongly typed language, like C and Java, which means that a variable you declare in your code can be only one type (an integer, string, or Dog class, for example) and will always be that type, no matter what. Let’s start by taking a quick look at the Hello World example in <a href="#filepos73487">Listing 1-1</a>, which shows some basic C# types and syntax.</p><blockquote class="calibre_14"><span class="calibre4">using ➊System;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">namespace ➋ch1_hello_world</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> class ➌MainClass</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> public static void ➍Main(string[] ➎args)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ➏ string hello = "Hello World!";</span><br class="calibre5"/><span class="calibre4"> ➐ DateTime now = DateTime.Now;</span><br class="calibre5"/><span class="calibre4"> ➑ Console.Write(hello);</span><br class="calibre5"/><span class="calibre4"> ➒ Console.WriteLine(" The date is " + now.ToLongDateString());</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos73487" class="calibre_15"><span class="calibre4"><span class="italic">Listing 1-1: A basic Hello World application</span></span></p><p class="calibre_6">Right off the bat, we need to import the namespaces we’ll use, and we do this with a <span class="calibre4">using</span> statement that imports the <span class="calibre4">System</span> namespace ➊. This enables access to libraries in a program, similar to <span class="calibre4">#include</span> in C, <span class="calibre4">import</span> in Java and Python, and <span class="calibre4">require</span> in Ruby and Perl. After declaring the library we want to use, we declare the namespace ➋ our classes will live in.</p><p class="calibre_6">Unlike C (and older versions of Perl), C# is an object-oriented language, similar to Ruby, Python, and Java. This means that we can build complex classes to represent data structures, along with the methods for those data structures, while writing code. Namespaces allow us to organize our classes and code as well as to prevent potential name collisions, such as when two programmers create two classes with the same name. If two classes with the same name are in different namespaces, there won’t be a problem. Every class is required to have a namespace.</p><p class="calibre_6">With the namespace out of the way, we can declare a class ➌ that will hold our <span class="calibre4">Main()</span> method ➍. As we stated previously, classes allow us to create complex data types as well as data structures that better fit real-world objects. In this example, the name of the class doesn’t actually matter; it’s just a container for our <span class="calibre4">Main()</span> method, which is what really matters because the <span class="calibre4">Main()</span> method is what will execute when we run our sample application. Every C# application requires a <span class="calibre4">Main()</span> method, just like in C and Java. If your C# application accepts arguments on the command line, you can use the <span class="calibre4">args</span> variable ➎ to access the arguments passed to the application.</p><p class="calibre_6">Simple data structures, such as strings ➏, exist in C#, and more complex ones, such as a class representing the date and time ➐, can also be created. The <span class="calibre4">DateTime</span> class is a core C# class for dealing with dates. In our example, we use it to store the current date and time (<span class="calibre4">DateTime.Now</span>) in the variable <span class="calibre4">now</span>. Finally, with our variables declared, we can print a friendly message using the <span class="calibre4">Console</span> class’s <span class="calibre4">Write()</span> ➑ and <span class="calibre4">WriteLine()</span> ➒ methods (the latter of which includes a newline character at the end).</p><p class="calibre_6">If you’re using an IDE, you can compile and run the code by clicking the Run button, which is in the top-left corner of the IDE and looks like a Play button, or by pressing the F5 key. However, if you would like to compile the source code from the command line with the Mono compiler, you can easily do that as well. From the directory with your C# class code, use the <span class="calibre4">mcs</span> tool shipped with Mono to compile your classes into an executable, like so: $ <span class="bold">mcs Main.cs -out:ch1_hello_world.exe</span> Running the code from <a href="#filepos73487">Listing 1-1</a> should print both the string <span class="calibre4">"Hello World!"</span> and the current date on the same line, as in <a href="#filepos77351">Listing 1-2</a>. On some Unix systems, you may need to run <span class="calibre4">mono ch1_hello_world.exe</span>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">./ch1_hello_world.exe</span></span><br class="calibre5"/><span class="calibre4">Hello World! The date is Wednesday, June 28, 2017</span></blockquote><p id="filepos77351" class="calibre_15"><span class="calibre4"><span class="italic">Listing 1-2: Running the Hello World application</span></span></p><p class="calibre_6">Congratulations on your first C# application!</p><p id="filepos77566" class="calibre_10"><span class="calibre3"><span class="bold"> Introducing Classes and Interfaces</span></span></p><p class="calibre_11">Classes and interfaces are used to create complex data structures that would be difficult to represent with just built-in structures. Classes and interfaces can have <span class="italic">properties</span>, which are variables that get or set values for a class or interface, and <span class="italic">methods</span>, which are like functions that execute on the class (or subclasses) or interface and are unique to it. Properties and methods are used to represent data about an object. For instance, a <span class="calibre4">Firefighter</span> class might need an <span class="calibre4">int</span> property to represent the firefighter’s pension or a method that tells the firefighter to drive to a place where there’s a fire.</p><p class="calibre_6">Classes can be used as blueprints to create other classes in a technique called <span class="italic">subclassing</span>. When a class subclasses another class, it inherits the properties and methods from that class (known as the <span class="italic">parent</span> class). Interfaces are used as a blueprint for new classes as well, but unlike classes, they don’t have inheritance. Thus a base class that implements an interface won’t pass down the interface’s properties and methods if it’s subclassed.</p><p id="filepos78910" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Creating a Class</span></span></span></p><p class="calibre_11">We’ll create the simple class shown in <a href="#filepos79605">Listing 1-3</a> as an example that represents a public servant data structure for someone who works every day to make our lives easier and better.</p><blockquote class="calibre_14"><span class="calibre4">public ➊abstract class PublicServant</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public int ➋PensionAmount { get; set; }</span><br class="calibre5"/><span class="calibre4"> public abstract void ➌DriveToPlaceOfInterest();</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos79605" class="calibre_15"><span class="calibre4"><span class="italic">Listing 1-3: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">PublicServant</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">abstract class</span></span></p><p class="calibre_6">The <span class="calibre4">PublicServant</span> class is a special kind of class. It is an <span class="italic">abstract</span> class ➊. Generally, you can just create a class like you do any other type of variable, and it is called an <span class="italic">instance</span> or an <span class="italic">object</span>. Abstract classes, though, cannot be instantiated like other classes; they can only be inherited through subclassing. There are many types of public servants—firefighters and police officers are two that come to mind immediately. It would therefore make sense to have a base class that these two types of public servants inherit from. In this case, if these two classes were subclasses of <span class="calibre4">PublicServant</span>, they would inherit a <span class="calibre4">PensionAmount</span> property ➋ and a <span class="calibre4">DriveToPlaceOfInterest</span> delegate ➌ that must be implemented by subclasses of <span class="calibre4">PublicServant</span>. There is no general “public servant” job that someone can apply for, so there isn’t a reason to create just a <span class="calibre4">PublicServant</span> instance.</p><p id="filepos80921" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Creating an Interface</span></span></span></p><p class="calibre_11">A complement to classes in C# are interfaces. <span class="italic">Interfaces</span> allow a programmer to force a class to implement certain properties or methods that aren’t inherited. Let’s create a simple interface to start with, as shown in <a href="#filepos81752">Listing 1-4</a>. This interface is called <span class="calibre4">IPerson</span> and will declare a couple of properties that people usually have.</p><blockquote class="calibre_14"><span class="calibre4"> public interface ➊IPerson</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> string ➋Name { get; set; }</span><br class="calibre5"/><span class="calibre4"> int ➌Age { get; set; }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos81752" class="calibre_15"><span class="calibre4"><span class="italic">Listing 1-4: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">IPerson</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">interface</span></span></p><p class="calibre_16"><span class="calibre3"><span class="bold"><span class="calibre_17"><span class="calibre_18">  NOTE </span></span></span></span></p><blockquote class="calibre_7"><span class="italic">Interfaces in C# are usually prefaced with an</span> I <span class="italic">to distinguish them from classes that may implement them. This</span> I <span class="italic">isn’t required, but it is a very common pattern used in mainstream C# development.</span></blockquote><p class="calibre_6">If a class were to implement the <span class="calibre4">IPerson</span> interface ➊, that class would need to implement both a <span class="calibre4">Name</span> ➋ and an <span class="calibre4">Age</span> ➌ property on its own. Otherwise, it wouldn’t compile. I’ll show exactly what this means when we implement the <span class="calibre4">Firefighter</span> class next, which implements the <span class="calibre4">IPerson</span> interface. For now, just know that interfaces are an important and useful feature of C#. Programmers familiar with interfaces in Java will feel right at home with them. C programmers can think of them as header files with function declarations that expect a <span class="italic">.c</span> file to implement the function. Those familiar with Perl, Ruby, or Python may find interfaces strange at first because there isn’t a comparable feature in those languages.</p><p id="filepos83277" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Subclassing from an Abstract Class and Implementing an Interface</span></span></span></p><p class="calibre_11">Let’s put our <span class="calibre4">PublicServant</span> class and <span class="calibre4">IPerson</span> interface to some use and solidify a bit of what we have talked about. We can create a class to represent our firefighters that inherits from the <span class="calibre4">PublicServant</span> class and implements the <span class="calibre4">IPerson</span> interface, as shown in <a href="#filepos85009">Listing 1-5</a>.</p><blockquote class="calibre_14"><span class="calibre4">public class ➊Firefighter : ➋PublicServant, ➌IPerson</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public ➍Firefighter(string name, int age)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.Name = name;</span><br class="calibre5"/><span class="calibre4"> this.Age = age;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> //implement the IPerson interface</span><br class="calibre5"/><span class="calibre4"> public string ➎Name { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int ➏Age { get; set; }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public override void ➐DriveToPlaceOfInterest()</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> GetInFiretruck();</span><br class="calibre5"/><span class="calibre4"> TurnOnSiren();</span><br class="calibre5"/><span class="calibre4"> FollowDirections();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> private void GetInFiretruck() {}</span><br class="calibre5"/><span class="calibre4"> private void TurnOnSiren() {}</span><br class="calibre5"/><span class="calibre4"> private void FollowDirections() {}</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos85009" class="calibre_15"><span class="calibre4"><span class="italic">Listing 1-5: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Firefighter</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">The <span class="calibre4">Firefighter</span> class ➊ is a bit more complex than anything we’ve implemented yet. First, note that the <span class="calibre4">Firefighter</span> class inherits from the <span class="calibre4">PublicServant</span> class ➋ and implements the <span class="calibre4">IPerson</span> interface ➌. This is done by listing the class and interface, separated by commas, after the <span class="calibre4">Firefighter</span> class name and a colon. We then create a new <span class="italic">constructor</span> ➍ that is used to set the properties of a class when a new class instance is created. The new constructor will accept the name and age of the firefighter as arguments, which will set the <span class="calibre4">Name</span> ➎ and <span class="calibre4">Age</span> ➏ properties required by the <span class="calibre4">IPerson</span> interface with the values passed. We then override the <span class="calibre4">DriveToPlaceOfInterest()</span> method ➐ inherited from the <span class="calibre4">PublicServant</span> class with one of our own, calling a few empty methods that we declare. We’re required to implement the <span class="calibre4">DriveToPlaceOfInterest()</span> method because it’s marked as abstract in the <span class="calibre4">PublicServant</span> class and abstract methods have to be overridden by subclasses.</p><p class="calibre_16"><span class="calibre3"><span class="bold"><span class="calibre_17"><span class="calibre_18">  NOTE </span></span></span></span></p><blockquote class="calibre_7"><span class="italic">Classes come with a default constructor that has no parameters to create instances. Creating a new constructor actually overrides the default constructor.</span></blockquote><p class="calibre_6">The <span class="calibre4">PublicServant</span> class and <span class="calibre4">IPerson</span> interface can be very flexible and can be used to create classes with completely different uses. We will implement one more class, a <span class="calibre4">PoliceOfficer</span> class, as shown in <a href="#filepos88910">Listing 1-6</a>, using <span class="calibre4">PublicServant</span> and <span class="calibre4">IPerson</span>.</p><blockquote class="calibre_14"><span class="calibre4">public class ➊PoliceOfficer : PublicServant, IPerson</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> private bool _hasEmergency;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public PoliceOfficer(string name, int age)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.Name = name;</span><br class="calibre5"/><span class="calibre4"> this.Age = age;</span><br class="calibre5"/><span class="calibre4"> _hasEmergency = ➋false;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> //implement the IPerson interface</span><br class="calibre5"/><span class="calibre4"> public string Name { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int Age { get; set; }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public bool ➌HasEmergency</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> get { return _hasEmergency; }</span><br class="calibre5"/><span class="calibre4"> set { _hasEmergency = value; }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public override void ➍DriveToPlaceOfInterest()</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> GetInPoliceCar();</span><br class="calibre5"/><span class="calibre4"> if (this.➎HasEmergency)</span><br class="calibre5"/><span class="calibre4"> TurnOnSiren();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> FollowDirections();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> private void GetInPoliceCar() {}</span><br class="calibre5"/><span class="calibre4"> private void TurnOnSiren() {}</span><br class="calibre5"/><span class="calibre4"> private void FollowDirections() {}</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos88910" class="calibre_15"><span class="calibre4"><span class="italic">Listing 1-6: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">PoliceOfficer</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">The <span class="calibre4">PoliceOfficer</span> class ➊ is similar to the <span class="calibre4">Firefighter</span> class, but there are a few differences. Most notably, a new property called <span class="calibre4">HasEmergency</span> ➌ is set in the constructor ➋. We also override the <span class="calibre4">DriveToPlaceOfInterest()</span> method ➍ as in the previous <span class="calibre4">Firefighter</span> class, but this time, we use the <span class="calibre4">HasEmergency</span> property ➎ to determine whether the officer should drive the car with the siren on. We can use the same combination of parent class and interface to create classes that function completely differently.</p><p id="filepos89821" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Tying Everything Together with the Main() Method</span></span></span></p><p class="calibre_11">We can use our new classes to test a few more features of C#. Let’s write a new <span class="calibre4">Main()</span> method to show off these new classes, as shown in <a href="#filepos92281">Listing 1-7</a>.</p><blockquote class="calibre_14"><span class="calibre4">using System;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">namespace ch1_the_basics</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public class MainClass</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Firefighter firefighter = new ➊Firefighter("Joe Carrington", 35);</span><br class="calibre5"/><span class="calibre4"> firefighter.➋PensionAmount = 5000;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> PrintNameAndAge(firefighter);</span><br class="calibre5"/><span class="calibre4"> PrintPensionAmount(firefighter);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> firefighter.DriveToPlaceOfInterest();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> PoliceOfficer officer = new PoliceOfficer("Jane Hope", 32);</span><br class="calibre5"/><span class="calibre4"> officer.PensionAmount = 5500;</span><br class="calibre5"/><span class="calibre4"> officer.➌HasEmergency = true;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➍PrintNameAndAge(officer);</span><br class="calibre5"/><span class="calibre4"> PrintPensionAmount(officer);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> officer.➎DriveToPlaceOfInterest();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> static void PrintNameAndAge(➏IPerson person)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Name: " + person.Name);</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Age: " + person.Age);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> static void PrintPensionAmount(➐PublicServant servant)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (servant is ➑Firefighter)</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Pension of firefighter: " + servant.PensionAmount);</span><br class="calibre5"/><span class="calibre4"> else if (servant is ➒PoliceOfficer)</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Pension of officer: " + servant.PensionAmount);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos92281" class="calibre_15"><span class="calibre4"><span class="italic">Listing 1-7: Tying together the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">PoliceOfficer</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">and</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Firefighter</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">classes with a</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">To use the <span class="calibre4">PoliceOfficer</span> and <span class="calibre4">Firefighter</span> classes, we must instantiate them using the constructors we defined in the respective classes. We do this first with the <span class="calibre4">Firefighter</span> class ➊, passing a name of <span class="calibre4">Joe Carrington</span> and an age of <span class="calibre4">35</span> to the class constructor and assigning the new class to the <span class="calibre4">firefighter</span> variable. We also set the firefighter <span class="calibre4">PensionAmount</span> property ➋ to <span class="calibre4">5000</span>. After the firefighter has been set up, we pass the object to the <span class="calibre4">PrintNameAndAge()</span> and <span class="calibre4">PrintPension()</span> methods.</p><p class="calibre_6">Note that the <span class="calibre4">PrintNameAndAge()</span> method takes the <span class="calibre4">IPerson</span> interface ➏ as an argument, not a <span class="calibre4">Firefighter</span>, <span class="calibre4">PoliceOfficer</span>, or <span class="calibre4">PublicServant</span> class. When a class implements an interface, you can create methods that accept that interface (in our case, <span class="calibre4">IPerson</span>) as an argument. If you pass <span class="calibre4">IPerson</span> to a method, the method only has access to the properties or methods that the interface requires instead of to the whole class. In our example, only the <span class="calibre4">Name</span> and <span class="calibre4">Age</span> properties are available, which is all we need for the method.</p><p class="calibre_6">Similarly, the <span class="calibre4">PrintPensionAmount()</span> method accepts <span class="calibre4">PublicServant</span> ➐ as its argument, so it only has access to the <span class="calibre4">PublicServant</span> properties and methods. We can use the C# <span class="calibre4">is</span> keyword to check whether an object is a certain type of class, so we do this to check whether our public servant is a <span class="calibre4">Firefighter</span> ➑ or a <span class="calibre4">PoliceOfficer</span> ➒, and we print a message depending on which it is.</p><p class="calibre_6">We do the same for the <span class="calibre4">PoliceOfficer</span> class as we did for <span class="calibre4">Firefighter</span>, creating a new class with a name of <span class="calibre4">Jane Hope</span> and an age of <span class="calibre4">32</span>; then we set her pension to <span class="calibre4">5500</span> and her <span class="calibre4">HasEmergency</span> property ➌ to <span class="calibre4">true</span>. After printing the name, age, and pension ➍, we call the officer’s <span class="calibre4">DriveToPlaceOfInterest()</span> method ➎.</p><p id="filepos95376" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Running the Main() Method</span></span></span></p><p class="calibre_11">Running the application should demonstrate how classes and methods interact with each other, as shown in <a href="#filepos96097">Listing 1-8</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">./ch1_the_basics.exe</span></span><br class="calibre5"/><span class="calibre4">Name: Joe Carrington</span><br class="calibre5"/><span class="calibre4">Age: 35</span><br class="calibre5"/><span class="calibre4">Pension of firefighter: 5000</span><br class="calibre5"/><span class="calibre4"> Name: Jane Hope</span><br class="calibre5"/><span class="calibre4">Age: 32</span><br class="calibre5"/><span class="calibre4">Pension of officer: 5500</span></blockquote><p id="filepos96097" class="calibre_15"><span class="calibre4"><span class="italic">Listing 1-8: Running the basics program’s</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">As you can see, the public servants’ names, ages, and pensions are printed to the screen, exactly as expected!</p><p id="filepos96490" class="calibre_10"><span class="calibre3"><span class="bold">Anonymous Methods</span></span></p><p class="calibre_11">The methods we have used so far have been class methods, but we can also use <span class="italic">anonymous methods</span>. This powerful feature of C# allows us to dynamically pass and assign methods using delegates. With a delegate, a delegate object is created that holds a reference to the method that will be called. We create this delegate in a parent class and then assign the delegate’s reference to anonymous methods in subclasses of the parent class. This way, we can dynamically assign a block of code in a subclass to the delegate instead of overriding the parent class’s method. To demonstrate how to use delegates and anonymous methods, we can build on the classes we have already created.</p><p id="filepos97315" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Assigning a Delegate to a Method</span></span></span></p><p class="calibre_11">Let’s update the <span class="calibre4">PublicServant</span> class to use a delegate for the method <span class="calibre4">DriveToPlaceOfInterest()</span>, as shown in <a href="#filepos98120">Listing 1-9</a>.</p><blockquote class="calibre_14"><span class="calibre4">public abstract class PublicServant</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public int PensionAmount { get; set; }</span><br class="calibre5"/><span class="calibre4"> public delegate void ➊DriveToPlaceOfInterestDelegate();</span><br class="calibre5"/><span class="calibre4"> public DriveToPlaceOfInterestDelegate ➋DriveToPlaceOfInterest { get; set; }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos98120" class="calibre_15"><span class="calibre4"><span class="italic">Listing 1-9: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">PublicServant</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class with a delegate</span></span></p><p class="calibre_6">In the previous <span class="calibre4">PublicServant</span> class, we needed to override the <span class="calibre4">DriveToPlaceOfInterest()</span> method if we wanted to change it. In the new <span class="calibre4">PublicServant</span> class, <span class="calibre4">DriveToPlaceOfInterest()</span> is replaced with a delegate ➊ and a property ➋ that allow us to call and assign <span class="calibre4">DriveToPlaceOfInterest()</span>. Now, any classes inheriting from the <span class="calibre4">PublicServant</span> class will have a delegate they can use to set their own anonymous method for <span class="calibre4">DriveToPlaceOfInterest()</span> instead of having to override the method within each class. Because they inherit from <span class="calibre4">PublicServant</span>, we’ll need to update our <span class="calibre4">Firefighter</span> and <span class="calibre4">PoliceOfficer</span> class constructors accordingly.</p><p id="filepos99248" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Updating the Firefighter Class</span></span></span></p><p class="calibre_11">We’ll update the <span class="calibre4">Firefighter</span> class first with the new delegate property. The constructor, shown in <a href="#filepos100265">Listing 1-10</a>, is the only change we make.</p><blockquote class="calibre_14"><span class="calibre4"> public ➊Firefighter(string name, int age)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.➋Name = name;</span><br class="calibre5"/><span class="calibre4"> this.➌Age = age;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> this.DriveToPlaceOfInterest ➍+= delegate</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Driving the firetruck");</span><br class="calibre5"/><span class="calibre4"> GetInFiretruck();</span><br class="calibre5"/><span class="calibre4"> TurnOnSiren();</span><br class="calibre5"/><span class="calibre4"> FollowDirections();</span><br class="calibre5"/><span class="calibre4"> };</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos100265" class="calibre_15"><span class="calibre4"><span class="italic">Listing 1-10: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Firefighter</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class using the delegate for the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">DriveToPlaceOfInterest()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">In the new <span class="calibre4">Firefighter</span> class constructor ➊, we assign the <span class="calibre4">Name</span> ➋ and <span class="calibre4">Age</span> ➌ like we did before. Next, we create the anonymous method and assign it to the <span class="calibre4">DriveToPlaceOfInterest</span> delegate property using the <span class="calibre4">+=</span> operator ➍ so that calling <span class="calibre4">DriveToPlaceOfInterest()</span> will call the anonymous method. This anonymous method prints <span class="calibre4">"Driving the firetruck"</span> and then runs the empty methods from the original class. This way, we can add the customized code we want to each method within a class without having to override it.</p><p id="filepos101357" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Creating Optional Arguments</span></span></span></p><p class="calibre_11">The <span class="calibre4">PoliceOfficer</span> class requires a similar change; we update the constructor as shown in <a href="#filepos103274">Listing 1-11</a>. Because we’re already updating this class, we can also change it to use an <span class="italic">optional argument</span>, which is a parameter in a constructor that does not have to be included when a new instance is created. We’ll create two anonymous methods and use an optional argument to determine which method to assign to the delegate.</p><blockquote class="calibre_14"><span class="calibre4"> public ➊PoliceOfficer(string name, int age, bool ➋hasEmergency = false)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.➌Name = name;</span><br class="calibre5"/><span class="calibre4"> this.➍Age = age;</span><br class="calibre5"/><span class="calibre4"> this.➎HasEmergency = hasEmergency;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (this.➏HasEmergency)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.DriveToPlaceOfInterest += delegate</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Driving the police car with siren");</span><br class="calibre5"/><span class="calibre4"> GetInPoliceCar();</span><br class="calibre5"/><span class="calibre4"> TurnOnSiren();</span><br class="calibre5"/><span class="calibre4"> FollowDirections();</span><br class="calibre5"/><span class="calibre4"> };</span><br class="calibre5"/><span class="calibre4"> } else</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.DriveToPlaceOfInterest += delegate</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Driving the police car");</span><br class="calibre5"/><span class="calibre4"> GetInPoliceCar();</span><br class="calibre5"/><span class="calibre4"> FollowDirections();</span><br class="calibre5"/><span class="calibre4"> };</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos103274" class="calibre_15"><span class="calibre4"><span class="italic">Listing 1-11: The new</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">PoliceOfficer</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">constructor</span></span></p><p class="calibre_6">In the new <span class="calibre4">PoliceOfficer</span> constructor ➊, we set the <span class="calibre4">Name</span> ➌ and <span class="calibre4">Age</span> ➍ properties as we did originally. This time, however, we also use an optional third argument ➋ to assign the <span class="calibre4">HasEmergency</span> property ➎. The third argument is optional because it does not need to be specified; it has a default value (<span class="calibre4">false</span>) when the constructor is provided with only the first two arguments. We then set the <span class="calibre4">DriveToPlaceOfInterest</span> delegate property with a new anonymous method, depending on whether <span class="calibre4">HasEmergency</span> is true ➏.</p><p id="filepos104214" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Updating the Main() Method</span></span></span></p><p class="calibre_11">With the new constructors, we can run an updated <span class="calibre4">Main()</span> method that is almost identical to the first. It’s detailed in <a href="#filepos105699">Listing 1-12</a>.</p><blockquote class="calibre_14"><span class="calibre4"> public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Firefighter firefighter = new Firefighter("Joe Carrington", 35);</span><br class="calibre5"/><span class="calibre4"> firefighter.PensionAmount = 5000;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> PrintNameAndAge(firefighter);</span><br class="calibre5"/><span class="calibre4"> PrintPensionAmount(firefighter);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> firefighter.DriveToPlaceOfInterest();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> PoliceOfficer officer = new ➊PoliceOfficer("Jane Hope", 32);</span><br class="calibre5"/><span class="calibre4"> officer.PensionAmount = 5500;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> PrintNameAndAge(officer);</span><br class="calibre5"/><span class="calibre4"> PrintPensionAmount(officer);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> officer.DriveToPlaceOfInterest();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> officer = new ➋PoliceOfficer("John Valor", 32, true);</span><br class="calibre5"/><span class="calibre4"> PrintNameAndAge(officer);</span><br class="calibre5"/><span class="calibre4"> officer.➌DriveToPlaceOfInterest();</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos105699" class="calibre_15"><span class="calibre4"><span class="italic">Listing 1-12: The updated</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method using our classes with delegates for driving to places of interest</span></span></p><p class="calibre_6">The only differences are in the last three lines, which demonstrate creating a new <span class="calibre4">PoliceOfficer</span> ➋ who has an emergency (the third argument to the constructor is <span class="calibre4">true</span>), as opposed to Jane Hope ➊, who has none. We then call <span class="calibre4">DriveToPlaceOfInterest()</span> on the John Valor <span class="calibre4">officer</span> ➌.</p><p id="filepos106399" class="calibre_10"><span class="calibre3"><span class="bold">
</span></span><span class="calibre3"><span class="italic"><span class="bold">Running the Updated Main() Method</span></span></span></p><p class="calibre_11">Running the new method shows how creating two <span class="calibre4">PoliceOfficer</span> classes—one with an emergency and one without—will print two different things, as demonstrated in <a href="#filepos107506">Listing 1-13</a>.</p><blockquote class="calibre_14"><span class="calibre4"> $ </span><span class="calibre4"><span class="bold">./ch1_the_basics_advanced.exe</span></span><br class="calibre5"/><span class="calibre4"> Name: Joe Carrington</span><br class="calibre5"/><span class="calibre4"> Age: 35</span><br class="calibre5"/><span class="calibre4"> Pension of firefighter: 5000</span><br class="calibre5"/><span class="calibre4"> Driving the firetruck</span><br class="calibre5"/><span class="calibre4"> Name: Jane Hope</span><br class="calibre5"/><span class="calibre4"> Age: 32</span><br class="calibre5"/><span class="calibre4"> Pension of officer: 5500</span><br class="calibre5"/><span class="calibre4">➊ Driving the police car</span><br class="calibre5"/><span class="calibre4"> Name: John Valor</span><br class="calibre5"/><span class="calibre4"> Age: 32</span><br class="calibre5"/><span class="calibre4">➋ Driving the police car with siren </span><a id="filepos107506"/><span class="calibre4"><span class="italic">Listing 1-13: Running the new</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method with classes using delegates</span></span></blockquote><p class="calibre_6">As you can see, creating a <span class="calibre4">PoliceOfficer</span> class with an emergency causes the officer to drive with the siren on ➋. Jane Hope, on the other hand, can drive without her siren on ➊ because she has no emergency.</p><p id="filepos108009" class="calibre_10"><span class="calibre3"><span class="bold">Integrating with Native Libraries</span></span></p><p class="calibre_11">Finally, sometimes you need to use libraries that are available only in standard operating system libraries, such as libc on Linux and user32.dll on Windows. If you plan to use code in a library that was written in C, C++, or another language that gets compiled down to native assembly, C# makes working with these <span class="italic">native</span> libraries very easy, and we will use this technique in <a href="index_split_009.html#filepos344540">Chapter 4</a> when making cross-platform Metasploit payloads. This feature is called Platform Invoke, or P/Invoke for short. Programmers often need to use native libraries because they are faster than a virtual machine such as used by .NET or Java. Programmers such as financial or scientific professionals who use code to do heavy math might write the code that they need to be fast in C (for example, code for interfacing directly with hardware) but use C# to handle code that requires less speed.</p><p class="calibre_6"><a href="#filepos110442">Listing 1-14</a> shows a simple application that uses P/Invoke to call the standard C function <span class="calibre4">printf()</span> in Linux or to pop up a message box using user32.dll on Windows.</p><blockquote class="calibre_14"><span class="calibre4">class MainClass</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> [➊DllImport("user32", CharSet=CharSet.Auto)]</span><br class="calibre5"/><span class="calibre4"> static extern int MessageBox(IntPtr hWnd, String text, String caption, int options);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> [DllImport("libc")]</span><br class="calibre5"/><span class="calibre4"> static extern void printf(string message);</span><br class="calibre5"/><span class="calibre4"> static void ➋Main(string[] args)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> OperatingSystem os = Environment.OSVersion;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (➌os.Platform == ➍PlatformID.Win32Windows||os.Platform == PlatformID.Win32NT)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ➎MessageBox(IntPtr.Zero, "Hello world!", "Hello world!", 0);</span><br class="calibre5"/><span class="calibre4"> } else</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ➏printf("Hello world!");</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos110442" class="calibre_15"><span class="calibre4"><span class="italic">Listing 1-14: Demonstrating P/Invoke with a simple example</span></span></p><p class="calibre_6">This example looks more complex than it is. We first declare two functions that will be looked up externally in different libraries. We do this using the <span class="calibre4">DllImport</span> attribute ➊. Attributes allow you to add extra information to methods (or classes, class properties, and so on) that is used at runtime by the .NET or Mono virtual machine. In our case, the <span class="calibre4">DllImport</span> attribute tells the runtime to look up the method we are declaring in another DLL, instead of expecting us to write it.</p><p class="calibre_6">We also declare the exact function names and the parameters the functions expect. For Windows, we can use the <span class="calibre4">MessageBox()</span> function, which expects a few parameters such as the title of the pop-up and the text to be displayed. For Linux, the <span class="calibre4">printf()</span> function expects a string to print. Both of these functions are looked up at runtime, which means we can compile this on any system because the function in the external library isn’t looked for until the program is running and the function is called. This lets us compile the application on any operating system, regardless of whether that system has either or both libraries.</p><p class="calibre_6">With our native functions declared, we can write a quick <span class="calibre4">Main()</span> method ➋ that checks the current operating system with an <span class="calibre4">if</span> statement using <span class="calibre4">os.Platform</span> ➌. The <span class="calibre4">Platform</span> property we use maps to the <span class="calibre4">PlatformID</span> enumeration ➍, which stores the available operating systems that the program could be running on. Using the <span class="calibre4">PlatformID</span> enumeration, we can test whether we are on Windows and then call the respective method: either <span class="calibre4">MessageBox()</span> ➎ on Windows or <span class="calibre4">printf()</span> ➏ on Unix. This application, when compiled, can be run on either a Windows machine or a Linux machine, no matter what operating system compiled it.</p><p id="filepos112712" class="calibre_10"><span class="calibre3"><span class="bold">Conclusion</span></span></p><p class="calibre_11">The C# language has many modern features that make it a great language for complex data and applications. We have only scratched the surface of some of the more powerful features like anonymous methods and P/Invoke. You’ll become intimate with the concepts of classes and interfaces, as well as many other advanced features, in the chapters to come. In addition, you’ll learn about many more of the core classes available to you, such as HTTP and TCP clients and much more.</p><p class="calibre_6">As we develop our own custom security tools throughout this book, you will also learn about general programming patterns, which are useful conventions for creating classes that make building on them easy and fast. Good examples of programming patterns are used in <a href="index_split_010.html#filepos420379">Chapters 5</a> and <a href="index_split_016.html#filepos761301">11</a> where we interface with APIs and RPCs of third-party tools such as Nessus and Metasploit.</p><p class="calibre_6">By the end of this book, we will have covered how C# can be used for every security practitioner’s job—from the security analyst to the engineer, and even the hobbyist researcher at home. C# is a beautiful and powerful language, and with cross-platform support from Mono bringing C# to phones and embedded devices, it is just as capable and usable as Java and other alternatives.</p><div class="mbp_pagebreak" id="calibre_pb_6"/>
</body></html>