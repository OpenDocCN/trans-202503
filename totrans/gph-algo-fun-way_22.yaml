- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">17</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CLIQUES,
    INDEPENDENT SETS, AND VERTEX COVERS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">17</samp> <samp class="SANS_Dogma_OT_Bold_B_11">团、独立集和顶点覆盖</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'In the previous chapter, we saw how the seemingly simple problem of assigning
    colors rapidly explodes into costly searches. Here, we consider the similarly
    challenging problems of assembling sets of nodes that satisfy various criteria:
    maximum cliques, maximum independent sets, and minimum vertex covers.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到看似简单的颜色分配问题会迅速膨胀成代价高昂的搜索。在这里，我们考虑类似的挑战性问题，即组装满足各种条件的节点集：最大团、最大独立集和最小顶点覆盖。
- en: For each of these problems, we want to find the largest or smallest set of nodes
    that fulfills some criteria based on immediate neighbors or adjacent edges. While
    it is easy to check whether a single proposed solution satisfies various constraints,
    it can be computationally expensive to find the best solution. Like the graph-coloring
    problem, these problems are classified as NP-hard. Again, we can attack these
    problems with either heuristic or exhaustive approaches.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些问题中的每一个，我们都希望找到满足某些基于邻接节点或边缘的条件的最大或最小节点集。虽然检查单一的提议解决方案是否满足各种约束条件很容易，但找到最佳解决方案可能需要大量计算。与图着色问题类似，这些问题被归类为
    NP-困难问题。同样，我们可以使用启发式方法或穷举法来解决这些问题。
- en: This chapter begins by returning to the exhaustive backtracking search with
    pruning that was introduced in the previous chapter, adapting it to exhaustively
    search for solutions to each of the three problems covered here. In addition,
    we consider a variety of greedy or heuristic approaches. We’ll also discuss real-world
    applications for each problem, from choosing office locations with cliques to
    avoiding grudges with independent sets to building guard towers with vertex covers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时回到了上一章介绍的带剪枝的穷举回溯搜索，并将其适应于对本章所涉及的三个问题进行穷举搜索。此外，我们还考虑了多种贪心或启发式方法。我们还将讨论每个问题的实际应用，从选择办公室位置的团到避免怨恨的独立集，再到利用顶点覆盖建立警卫塔。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Backtracking Search for Sets of Nodes</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">回溯搜索节点集</samp>
- en: For each of the problems in this chapter, we want to find a set of nodes that
    satisfies given constraints. We use a modified version of the backtracking search
    with pruning introduced in [Chapter 16](chapter16.xhtml) to find potential solutions
    by exploring the different assignments for whether each node is included in the
    set. As with their use in graph coloring, these backtracking searches enumerate
    all valid solutions. While they’ll check every possible valid assignment, they
    are rarely efficient.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中的每个问题，我们都希望找到满足给定约束的节点集。我们使用在[第16章](chapter16.xhtml)中介绍的带剪枝的回溯搜索的修改版本，通过探索是否将每个节点包含在集合中的不同分配来寻找潜在的解决方案。与图着色问题中的应用一样，这些回溯搜索会列举所有有效的解决方案。虽然它们会检查每一个可能的有效分配，但它们的效率很少高。
- en: The basic concept behind this search is to explore every possible set of nodes
    by considering the nodes one at a time and branching the search into two paths
    at each decision point. In the first path, the search explores the possible sets
    constructed without including the current node in the set. In the second path,
    it explores those possible sets constructed with the current node included in
    the set.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这种搜索的基本概念是通过一次考虑一个节点并在每个决策点将搜索分成两个路径，来探索每一个可能的节点集。在第一条路径中，搜索探索不包含当前节点的可能集合。在第二条路径中，搜索探索包含当前节点的可能集合。
- en: '[Figure 17-1](#fig17-1) shows this approach with each node’s inclusion in the
    set marked as <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> (included)
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> (excluded). The
    empty entries in the list indicate nodes we have yet to decide whether to include.
    At each level, the search considers the next unassigned node and branches out
    over both potential assignments.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 17-1](#fig17-1)展示了这种方法，每个节点在集合中的包含情况标记为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>（包含）或
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>（不包含）。列表中的空条目表示我们尚未决定是否包含该节点。在每个层次，搜索会考虑下一个未分配的节点，并在每个决策点分支出两个可能的分支。'
- en: '![A tree showing the branching for set assignment. At the top level, a five-element
    array has no items filled in. This array branches into two paths. The one on the
    left has F in the first element. The one on the right has T in the first element.](../images/f17001.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![一棵展示集合赋值分支的树。在顶层，一个五元素的数组没有填充任何项。该数组分为两条路径。左侧路径的第一个元素为F，右侧路径的第一个元素为T。](../images/f17001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-1: A backtracking
    search to exhaustively try all set assignments</samp>'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图17-1：回溯搜索，穷举尝试所有集合赋值</samp>
- en: Because we split each branch into two subbranches in [Figure 17-1](#fig17-1),
    the number of possible options doubles at each level. For a tree with *N* decisions,
    we explore 2*^N* full assignments. In the case of subsets of graph nodes, we consider
    each node as a separate decision, so *N* = |*V* | and we have 2^|*^V* ^| options
    to explore. While pruning invalid paths will help remove some obviously infeasible
    results, it will not save us from the full explosion of complexity this search
    can entail.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在[图17-1](#fig17-1)中我们将每个分支分成两个子分支，所以每一层的可能选项数量都会翻倍。对于一个有*N*个决策的树，我们探索2*^N*个完整的赋值。在图节点的子集的情况下，我们将每个节点视为一个单独的决策，因此*N*
    = |*V*|，我们有2^|*V*|种选项可以探索。虽然剪枝无效路径有助于去除一些明显不可行的结果，但它无法避免此搜索可能带来的复杂性全面爆炸。
- en: We can think of this search as a method of solving a puzzle in a magical dungeon.
    Upon entering the cold stone room, we find five massive switches along the wall.
    We know from our previous studies of magical dungeons that only one correct configuration
    of switches will unlock the door to where the treasure is hidden. Unfortunately,
    the dungeon’s designer was not simply trying to create a fun puzzle; they want
    to protect their treasure and therefore provide absolutely no hints. While it
    doesn’t take long to check any single guess, we might need to try every combination
    to find the right one.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这种搜索视为解决魔法地下城谜题的方法。当我们进入寒冷的石质房间时，发现墙上有五个巨大的开关。根据我们之前对魔法地下城的研究，我们知道只有一种正确的开关配置能打开通向藏有宝藏的门。不幸的是，地下城的设计师并不仅仅是在试图创造一个有趣的谜题；他们想要保护他们的宝藏，因此完全没有提供任何线索。虽然检查任何单一猜测并不需要很长时间，但我们可能需要尝试每一种组合才能找到正确的配置。
- en: Determined to get the treasure, we start with a guess for the leftmost switch
    (Off), then the second from the left (Off), and so forth until all the switches
    are in the Off position. When the vault door inevitably doesn’t open, we backtrack
    to the last decision point (where we had set the rightmost switch to Off) and
    try the On option. When that doesn’t work, we backtrack further (to the second
    rightmost switch), change that to On, and once again explore each possible setting
    for the final switch. We should consider ourselves lucky that the dungeon designer
    only had the budget for five switches, meaning we need to test only 2⁵ = 32 settings.
    But we find it hard to muster such positive thoughts as we backtrack again and
    again.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到宝藏，我们从最左侧的开关（关闭）开始猜测，然后是第二个左侧的开关（关闭），依此类推，直到所有开关都处于关闭位置。当宝库门不可避免地没有打开时，我们回溯到上一个决策点（我们将最右侧的开关设置为关闭）并尝试开启选项。当这样做无效时，我们继续回溯（回到第二个最右侧的开关），将其改为开启，再次尝试探索最后一个开关的每种可能设置。我们应该感到幸运，因为地下城设计师的预算只有五个开关，这意味着我们只需要测试2⁵
    = 32种设置。但每次回溯时，我们发现很难保持如此积极的心态。
- en: For all the algorithms in this chapter, we describe the same two algorithmic
    approaches for finding solutions. We start by describing an approximate greedy
    search to establish the fundamentals of the problem and the factors that impact
    the solutions. We then show how to adapt backtracking search for that problem
    and how to add pruning.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有算法，我们都描述了相同的两种算法方法来寻找解决方案。我们首先描述了一种近似的贪心搜索，以建立问题的基础和影响解决方案的因素。接着我们展示了如何将回溯搜索应用于该问题，并添加剪枝技术。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Cliques</samp>
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">团</samp>
- en: '*Cliques* are subsets of nodes within an undirected graph that are fully connected.
    Formally, we say that a clique is a set of nodes *V*′ ⊆ *V* such that:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*团*是无向图中完全连接的节点子集。形式上，我们说一个团是一个节点集*V*′ ⊆ *V*，满足以下条件：'
- en: (*u*, *v*) ∈ *E* for all *u* ∈ *V*′ and *v* ∈ *V*′
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: (*u*, *v*) ∈ *E* 对于所有 *u* ∈ *V*′ 和 *v* ∈ *V*′
- en: In a social network, a clique would be a set of people who are all friends with
    each other.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在社交网络中，一个团是指一群彼此都是朋友的人。
- en: '[Figure 17-2](#fig17-2) shows a graph with two shaded subsets of nodes. The
    shaded nodes {1, 2, 5} in [Figure 17-2(a)](#fig17-2) form a clique because the
    graph contains an edge between each pair of nodes in the subset. In contrast,
    the shaded nodes {0, 1, 4} in [Figure 17-2(b)](#fig17-2) do not form a clique,
    as there is no edge between nodes 0 and 4 nor between nodes 1 and 4.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 17-2](#fig17-2)展示了一个图形，其中有两个阴影子集节点。在[图 17-2(a)](#fig17-2)中，阴影节点{1, 2, 5}形成了一个团体，因为图中包含了子集中每一对节点之间的边。相比之下，在[图
    17-2(b)](#fig17-2)中，阴影节点{0, 1, 4}并未形成一个团体，因为节点0和4之间没有边，节点1和4之间也没有边。'
- en: '![A graph with six nodes and undirected edges (0, 1), (0, 3), (1, 2), (1, 5),
    (2, 5), (3, 4), and (4, 5). On the left, the shaded nodes 1, 2, and 5 all have
    edges between them. On the right, the shaded nodes 0, 1, 4 do not.>](../images/f17002.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含六个节点和无向边(0, 1)、(0, 3)、(1, 2)、(1, 5)、(2, 5)、(3, 4)和(4, 5)的图。在左侧，阴影节点1、2和5之间有边相连；在右侧，阴影节点0、1、4之间没有。](../images/f17002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-2: A graph with a
    subset of nodes forming a clique (a) and a non-clique subset of nodes (b)</samp>'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 17-2：一个包含节点子集形成团体（a）和非团体节点子集（b）的图</samp>
- en: We can determine whether a set of nodes forms a clique by checking each pair
    of nodes and confirming that an edge between them exists, as shown in [Listing
    17-1](#list17-1).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查每一对节点并确认它们之间是否存在边来判断一组节点是否形成了一个团体，正如在[清单 17-1](#list17-1)中所示。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-1: Checking if a
    set of nodes forms a valid clique</samp>'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 17-1：检查一组节点是否形成有效的团体</samp>
- en: The code uses a pair of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops to iterate over each pair of nodes in the list and check whether the corresponding
    edge exists. If the edge is missing, the code immediately returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
    If the code successfully examines all pairs of nodes in the list without finding
    any missing edges, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用一对<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环来遍历列表中的每一对节点，并检查是否存在相应的边。如果边缺失，代码会立即返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。如果代码成功检查完列表中的所有节点对而没有发现缺失的边，则返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。
- en: 'We can visualize this check as a nosy outsider in a social network. Hearing
    tales of the Great Friend Group within a high school, the skeptical outsider proclaims,
    “There’s no way they all actually like each other,” and sets out to expose the
    group’s hidden divisions. Firmly in junior detective mode, they corner each person
    and ask them about their relationship with all the other members of the group:
    “Are you really friends with Jonny? How about Suzy?” It is not until they have
    confirmed every pairing is genuine that they finally abandon their skepticism.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此检查可视化为社交网络中的一个好奇外人。在听到某高中“伟大朋友圈”的传言后，怀疑的外人宣称，“他们不可能真的都互相喜欢”，并着手揭示这个团体的隐藏分裂。外人以初学侦探的方式，逼问每个人关于他们与其他团体成员的关系：“你真的和Jonny是朋友吗？那Suzy呢？”直到他们确认每一对关系都是真实的，才放弃了他们的怀疑。
- en: While determining whether a given set of nodes forms a clique is straightforward,
    it’s significantly more difficult to build the largest possible clique in a graph.
    The problem of finding the *maximum clique* consists of finding the largest subset
    of nodes *V*′ ⊆ *V* in the graph that form a valid clique. This problem is significantly
    more difficult than finding an arbitrary clique in the graph because the validity
    of a node’s membership depends on the other nodes in the clique. If adding nodes
    one by one, early choices can take us in suboptimal directions and exclude later
    nodes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然判断一组给定的节点是否形成一个团体比较简单，但构建图中最大的可能团体则要困难得多。寻找*最大团体*的问题是指在图中找到最大的节点子集*V*′ ⊆ *V*，使其形成一个有效的团体。这个问题比在图中寻找任意团体要困难得多，因为一个节点是否有效的成员取决于团体中其他节点的关系。如果逐个添加节点，早期的选择可能会导致我们走向次优的方向并排除后续的节点。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Use Cases</samp>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用案例</samp>'
- en: We can visualize the importance of cliques by considering locations (nodes)
    that need to be directly joined by transportation routes (edges). The kingdom’s
    Guild of Adventurers, Explorers, and Cartographers is looking to set up regional
    headquarters in locations with magical dungeons. After spending hours debating
    the importance of various criteria, including such considerations as dungeon difficulty
    and access to fresh produce, they conclude that the number one priority is easy
    transportation between the offices. After all, the guild offices share a single
    list of open quests for their members. If an adventurer in the city of Old Melbourne
    learns of a promising quest at the Cliffs of Indecision, they will want to travel
    there directly. The guild leaders enlist their senior cartographers to find the
    largest set of cities such that each city is directly connected by a road. The
    cartographers, familiar with the problem of finding maximum cliques, set to work
    enumerating the possibilities.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过考虑需要由交通路线（边）直接连接的地点（节点）来形象化团体的重要性。王国的冒险者、探险家和制图师公会正在寻找在有魔法地牢的地方建立区域总部。在经过数小时关于各种标准的重要性讨论之后，包括地牢难度和新鲜农产品的可获取性，他们最终得出结论，首要优先事项是各办公室之间便捷的交通。毕竟，公会的各个办公室共享一份为会员开放的任务列表。如果老墨尔本市的一个冒险者得知“决策悬崖”处有一个有前景的任务，他们会希望直接前往那里。公会领导们召集资深制图师寻找最大的城市集，其中每个城市都通过一条公路直接相连。制图师们熟悉最大团体问题，开始枚举所有可能的组合。
- en: In a less fantastical world, we might want to use maximum clique detection to
    choose locations for businesses with direct transportation connections or computational
    nodes with direct links. Each of these problems consists of finding fully connected
    subsets within a graph.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个不那么幻想的世界里，我们可能希望使用最大团体检测来选择具有直接交通连接的商业地点或具有直接链接的计算节点。这些问题都涉及到在图中找到完全连接的子集。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Greedy Search</samp>
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">贪心搜索</samp>
- en: We can define a greedy algorithm for building cliques by starting with an arbitrary
    node as our clique and continually adding compatible nodes. We always choose to
    add new nodes that would keep our clique *valid*, which is any node that shares
    edges with each of the clique members.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从任意一个节点开始，将其作为我们的团体，并不断添加兼容的节点，来定义一个构建团体的贪心算法。我们总是选择添加那些能保持我们的团体*有效*的新节点，所谓有效节点，是指与团体中的每个节点都有边相连的节点。
- en: '[Listing 17-2](#list17-2) shows how to list the options for clique expansion
    by checking each node to see whether we could add it to the set and still have
    a valid clique.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 17-2](#list17-2)展示了如何通过检查每个节点，列出是否可以将其添加到集合中并保持团体有效的选项。'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-2: Checking which
    nodes can be added to a clique</samp>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 17-2：检查可以添加到团体中的节点</samp>
- en: The code iterates through each node in the graph and tests whether that node
    could be added to the clique, first checking whether the node is already part
    of the clique ❶. If not, the code checks a node’s validity by checking that it
    shares an edge with every node in the current clique ❷. If those tests pass for
    each node in the clique, the code adds the current node to the list of expansion
    options.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 代码遍历图中的每个节点，测试该节点是否可以被添加到团体中，首先检查该节点是否已经是团体的一部分 ❶。如果不是，代码通过检查该节点是否与团体中的每个节点都有边相连来验证其有效性
    ❷。如果每个团体节点的这些测试都通过，代码就会将当前节点添加到扩展选项列表中。
- en: This function could help the Great Friend Group identify prospective members.
    Every student in the school is a prospective candidate. For each student who is
    not already in the group, the friend group’s chosen representative asks every
    member of the group, “Are you two friends?” If the prospective member is already
    friends with all members of the existing group (there is an edge from the new
    node to every node in the group), the current members quickly welcome in their
    mutual friend.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以帮助“大朋友小组”识别潜在的成员。学校里的每个学生都是潜在候选人。对于每个还不在小组中的学生，小组的代表会询问每个成员：“你们是朋友吗？”如果潜在成员已经和所有现有成员是朋友（即新节点与小组中的每个节点都有边相连），那么现有成员会迅速欢迎他们的共同朋友加入。
- en: In [Listing 17-3](#list17-3), we construct a greedy algorithm that incrementally
    builds a clique one node at a time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 17-3](#list17-3)中，我们构建了一个贪心算法，逐步构建一个团体，每次添加一个节点。
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-3: A greedy algorithm
    to find cliques</samp>'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 17-3：寻找团的贪婪算法</samp>
- en: The code starts with an empty list to represent the clique being constructed.
    It uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to continually
    find a list of potential options with the <samp class="SANS_TheSansMonoCd_W5Regular_11">clique_expansion_options()</samp>
    function from [Listing 17-2](#list17-2) and adds the first option from the returned
    list to the clique ❶. It stops and returns the list when there are no more nodes
    that can be added to the current clique (<samp class="SANS_TheSansMonoCd_W5Regular_11">len(to_add)</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从一个空列表开始，表示正在构建的团。它使用一个<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环，持续调用[列表
    17-2](#list17-2)中的函数<sup class="SANS_TheSansMonoCd_W5Regular_11">clique_expansion_options()</sup>来找到潜在选项列表，并将返回列表中的第一个选项添加到团中❶。当没有更多节点可以添加到当前团时（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">len(to_add)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>），它停止并返回该列表。
- en: When adding nodes one at a time, we immediately run into the question, “Which
    node do we add next?” In the code in [Listing 17-3](#list17-3), we added just
    the first option, but this could be a *terrible* choice. Consider what happens
    if we apply this greedy algorithm to the graph in [Figure 17-3](#fig17-3). As
    written, the greedy algorithm would choose node 0 first and ultimately return
    {0, 1} instead of the larger clique {1, 2, 4, 5}.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当逐个添加节点时，我们立刻会遇到一个问题：“我们接下来应该添加哪个节点？”在[列表 17-3](#list17-3)中的代码中，我们只添加了第一个选项，但这可能是一个*糟糕*的选择。考虑一下，如果我们将这个贪婪算法应用于[图
    17-3](#fig17-3)中的图，结果会怎样。按原样，贪婪算法会首先选择节点 0，最终返回{0, 1}，而不是更大的团{1, 2, 4, 5}。
- en: '![A graph with six nodes and undirected edges (0, 1), (0, 3), (1, 2), (1, 4),
    (1, 5), (2, 4), (2, 5), (3, 4), and (4, 5).](../images/f17003.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含六个节点和无向边（0, 1）、（0, 3）、（1, 2）、（1, 4）、（1, 5）、（2, 4）、（2, 5）、（3, 4）和（4, 5）图](../images/f17003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-3: A graph for which
    the greedy search for a maximum clique fails</samp>'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 17-3：一个贪婪搜索最大团失败的图</samp>
- en: The greedy search is not guaranteed to find the maximum clique because decisions
    at each iteration of greedy search are not independent. Each time the algorithm
    adds a node *u* to the clique, this prevents it from adding any future nodes that
    do not have an edge to *u*. We can easily get stuck in a local maximum by adding
    the wrong node early on. We could improve our selection heuristics, such as by
    choosing nodes with the most edges, but this only helps so much. To build a maximum
    clique, we need a more comprehensive (and expensive) search.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 贪婪搜索无法保证找到最大团，因为贪婪搜索的每次迭代中的决策并不独立。每次算法将节点 *u* 添加到团中时，这会阻止它添加与 *u* 没有边的任何未来节点。我们很容易因为一开始就选择了错误的节点而陷入局部最大值。我们可以改进选择启发式方法，例如选择边最多的节点，但这也只能起到有限的作用。要构建一个最大团，我们需要进行更全面（且代价更高）的搜索。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Backtracking Search</samp>
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">回溯搜索</samp>
- en: '*Backtracking search* for a maximum clique recursively tries to set one node
    of the graph as either a member or non-member of the clique, as shown in [Listing
    17-4](#list17-4). At each level of recursion, the search function takes the clique
    built so far (<samp class="SANS_TheSansMonoCd_W5Regular_11">clique</samp>) and
    the next node to test (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>)
    and recursively tests all combinations of unassigned nodes, returning the biggest
    clique found down that branch of the search. This branching effectively tests
    all 2^|*^V* ^| possible subsets of nodes, while using pruning to cut off invalid
    options.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*回溯搜索* 最大团递归地尝试将图中的一个节点设置为团的成员或非成员，如[列表 17-4](#list17-4)所示。在每一层递归中，搜索函数使用当前已构建的团（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">clique</samp>）和下一个要测试的节点（<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>），并递归地测试所有未分配节点的组合，返回该分支搜索中找到的最大团。这个分支过程有效地测试了所有2^|*^V*
    ^|个可能的节点子集，同时利用剪枝方法切除无效的选项。'
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-4: Recursively exploring
    possible cliques</samp>'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 17-4：递归探索可能的团</samp>
- en: The code for backtracking search starts by checking whether it has reached the
    termination condition (iterated past the last node in the graph) ❶. If so, there
    is nothing left to check, and <samp class="SANS_TheSansMonoCd_W5Regular_11">clique</samp>
    is the largest subset down this branch of the search. The code returns a copy
    of the current clique to effectively snapshot the state and separate it from the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">clique</samp> object that it will
    continue to modify during the rest of the search.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯搜索的代码首先检查是否达到了终止条件（已迭代过图中的最后一个节点） ❶。如果是，那么就没有剩余需要检查的内容，<samp class="SANS_TheSansMonoCd_W5Regular_11">clique</samp>
    就是沿该分支搜索得到的最大子集。代码会返回当前团体的副本，以有效地快照当前状态，并将其与在搜索其余部分中会继续修改的 <samp class="SANS_TheSansMonoCd_W5Regular_11">clique</samp>
    对象分开。
- en: If the search has not reached the end of the recursion, the code tries building
    cliques both with and without <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>.
    It tests the subset without <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">maximum_clique_recursive()</samp>
    with the current <samp class="SANS_TheSansMonoCd_W5Regular_11">clique</samp> and
    the index of the next node ❷, then saves the best result down that branch for
    comparison.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果搜索尚未达到递归的终点，代码会尝试分别使用和不使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    来构建团体。它通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">maximum_clique_recursive()</samp>，以当前的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">clique</samp> 和下一个节点的索引 ❷ 来测试不带
    <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> 的子集，然后保存沿该分支获得的最佳结果以供比较。
- en: Before testing the subset with the current node, the code avoids exploring invalid
    subtrees by checking whether this node is compatible with the current <samp class="SANS_TheSansMonoCd_W5Regular_11">clique</samp>
    ❸. As with <samp class="SANS_TheSansMonoCd_W5Regular_11">clique_expansion_options()</samp>
    in [Listing 17-2](#list17-2), the <samp class="SANS_TheSansMonoCd_W5Regular_11">maximum_clique_recursive()</samp>
    function checks that the prospective node <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    has edges to all the nodes in the current clique. If even a single edge is missing,
    adding <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> would result
    in an invalid clique. The code skips recursive exploration on such invalid sets.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试包含当前节点的子集之前，代码通过检查该节点是否与当前的 <samp class="SANS_TheSansMonoCd_W5Regular_11">clique</samp>
    ❸ 兼容，避免探索无效的子树。与[清单 17-2](#list17-2)中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">clique_expansion_options()</samp>
    函数类似，<samp class="SANS_TheSansMonoCd_W5Regular_11">maximum_clique_recursive()</samp>
    函数会检查拟加入的节点 <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> 是否与当前团体中的所有节点都有边相连。如果缺少任何一条边，添加
    <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> 将导致无效的团体。代码会跳过对这种无效集的递归探索。
- en: If the current node is compatible with the current clique, the code tries adding
    it to the clique and recursively testing the remaining options. It then cleans
    up the <samp class="SANS_TheSansMonoCd_W5Regular_11">clique</samp> data by removing
    <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> so that the <samp class="SANS_TheSansMonoCd_W5Regular_11">clique</samp>
    list can continue to be used in other branches ❹. The code compares the results
    of the two branches and keeps the larger valid subset of nodes ❺.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前节点与当前团体兼容，代码会尝试将其添加到团体中，并递归测试剩余的选项。然后，它通过移除 <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    来清理 <samp class="SANS_TheSansMonoCd_W5Regular_11">clique</samp> 数据，以便该 <samp class="SANS_TheSansMonoCd_W5Regular_11">clique</samp>
    列表可以在其他分支中继续使用 ❹。代码会比较两个分支的结果，并保留较大的有效节点子集 ❺。
- en: 'We call the function in [Listing 17-4](#list17-4) with an initial <samp class="SANS_TheSansMonoCd_W5Regular_11">clique=[]</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">index=0</samp> or use a wrapper
    function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[清单 17-4](#list17-4)中调用该函数，初始值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">clique=[]</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">index=0</samp>，或者使用包装函数：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Figure 17-4](#fig17-4) shows a visualization of the search. Each level shows
    the algorithm branching on the inclusion (or not) of a single node. The first
    level considers whether to include node 0\. The second level considers including
    node 1\. Nodes assigned to the clique are shaded, excluded nodes are white, and
    unassigned nodes are dashed circles.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 17-4](#fig17-4) 显示了搜索的可视化。每一层都显示了算法在是否包含某个节点上的分支。第一层考虑是否包含节点 0。第二层考虑是否包含节点
    1。被分配到团体的节点用阴影表示，排除的节点为白色，未分配的节点为虚线圆圈。'
- en: '![A tree where each node corresponds to a four-node graph with undirected edges
    (0, 1), (0, 3), (1, 2), and (1, 3). At the root node all graph nodes are dashed.
    At each level of the tree, another node becomes either solid white or solid gray.](../images/f17004.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![一棵树，其中每个节点对应一个包含无向边（0, 1）、（0, 3）、（1, 2）和（1, 3）四个节点的图。在根节点处，所有图节点都是虚线的。在树的每一层，另一个节点变为实心白色或实心灰色。](../images/f17004.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-4: The steps of a
    backtracking search for the maximum clique</samp>'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 17-4：最大团体的回溯搜索步骤</samp>
- en: The subgraphs in [Figure 17-4](#fig17-4) show the state of the <samp class="SANS_TheSansMonoCd_W5Regular_11">clique</samp>
    list at the start of each function call. As you can see, the function follows
    only branches that contain valid cliques. For example, when evaluating <samp class="SANS_TheSansMonoCd_W5Regular_11">clique=[0]</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">index=2</samp>, the search cannot
    follow the right-hand branch because {0, 2} is not a valid clique. As a result,
    the search tests only 10 of the 16 possible full combinations, as shown in the
    final row.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 17-4](#fig17-4) 中的子图展示了每次函数调用开始时 <samp class="SANS_TheSansMonoCd_W5Regular_11">团体</samp>
    列表的状态。正如你所看到的，函数只跟踪包含有效团体的分支。例如，在评估 <samp class="SANS_TheSansMonoCd_W5Regular_11">clique=[0]</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">index=2</samp> 时，搜索无法跟随右侧分支，因为
    {0, 2} 不是一个有效的团体。因此，搜索只测试了 16 种可能的完整组合中的 10 种，如最后一行所示。'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Independent Sets</samp>
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">独立集</samp>
- en: 'An *independent set* is effectively the opposite of a clique. We define an
    independent set within an undirected graph as a subset of nodes such that no two
    nodes in the set are neighbors. Formally, an independent set is a set of nodes
    *V*′ ⊆ *V* such that:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *独立集* 实际上是一个团体的对立面。我们在一个无向图中定义独立集为一个节点的子集，保证该子集中的任何两个节点之间都没有邻接边。正式地说，独立集是一个节点集
    *V*′ ⊆ *V*，满足以下条件：
- en: (*u*, *v*) ∉ *E* for all *u* ∈ *V*′ and *v* ∈ *V*′
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: (*u*, *v*) ∉ *E* 对于所有 *u* ∈ *V*′ 和 *v* ∈ *V*′
- en: 'We can envision choosing an independent set as planning the world’s most awkward
    party: we invite a group of people from our school or office such that no one
    at the party likes anyone else.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将选择独立集想象成策划世界上最尴尬的聚会：我们邀请一群来自学校或办公室的人，确保聚会中的任何人都不喜欢其他人。
- en: '[Figure 17-5](#fig17-5) shows a graph with two shaded subsets of nodes. The
    shaded nodes {0, 2, 4} in [Figure 17-5(a)](#fig17-5) form an independent set because
    the graph does not contain any edges connecting these nodes. In contrast, the
    shaded nodes {0, 1, 4} in [Figure 17-5(b)](#fig17-5) do not form an independent
    set, as there is an edge between nodes 0 and 1.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 17-5](#fig17-5) 展示了一个包含两组阴影节点的图。在 [图 17-5(a)](#fig17-5) 中，阴影节点 {0, 2, 4}
    构成一个独立集，因为图中没有连接这些节点的边。相比之下，在 [图 17-5(b)](#fig17-5) 中，阴影节点 {0, 1, 4} 并不构成独立集，因为节点
    0 和 1 之间有一条边。'
- en: '![A graph with six nodes and undirected edges (0, 1), (0, 3), (1, 2), (1, 5),
    (2, 5), (3, 4), and (4, 5). On the left, the shaded nodes are 0, 2, and 4\. On
    the right, the shaded nodes are 0, 1, and 4.](../images/f17005.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含六个节点和无向边（0, 1）、（0, 3）、（1, 2）、（1, 5）、（2, 5）、（3, 4）和（4, 5）的图。在左侧，阴影节点为
    0、2 和 4。在右侧，阴影节点为 0、1 和 4。](../images/f17005.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-5: A graph with independent
    (a) and non-independent (b) subsets of nodes</samp>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 17-5：具有独立子集（a）和非独立子集（b）节点的图</samp>
- en: 'Determining whether a set of nodes forms an independent set requires us to
    check each pair of nodes and confirm there is no edge between them:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 确定一组节点是否构成独立集需要检查每对节点，并确认它们之间没有边：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code is almost identical to the clique-checking algorithm in [Listing 17-1](#list17-1).
    It iterates over each pair of nodes in the list and checks whether they violate
    the independent set criteria.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与 [清单 17-1](#list17-1) 中的团体检查算法几乎相同。它遍历列表中的每对节点，并检查它们是否违反了独立集的标准。
- en: In the context of our awkward party, the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_independent_set()</samp>
    function plays the role of another skeptical outsider. Unable to bear the silence,
    they insist, “Some people here must be friends.” They query every member of the
    party about their relationships with each other attendee, asking, “Are you sure
    you’re not friends with them?” and “How about them?” Only when every single question
    comes back that no pair are friends do they admit that the awkward atmosphere
    is understandable and that the host must be a bit of a jerk.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尴尬聚会的背景下，<samp class="SANS_TheSansMonoCd_W5Regular_11">is_independent_set()</samp>函数扮演着另一个持怀疑态度的外来者的角色。无法忍受寂静，他们坚持说：“这里一定有些人是朋友。”他们询问聚会中的每个成员与其他与会者的关系，问：“你确定你们不是朋友吗？”“那他们呢？”只有当每个问题的回答都是没有一对是朋友时，他们才承认，尴尬的气氛是可以理解的，主人可能有点傲慢。
- en: As with cliques, generating large independent sets can be difficult because
    adding a single node to our independent set may impact the validity of other nodes.
    The problem of finding the *maximum independent set* consists of finding the largest
    subset of nodes *V*′ ⊆ *V* in the graph that form a valid independent set.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 和团体一样，生成大的独立集可能很困难，因为向我们的独立集添加一个节点可能会影响其他节点的有效性。寻找*最大独立集*的问题就是在图中找到一个最大的节点子集*V*′
    ⊆ *V*，该子集构成一个有效的独立集。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Use Cases</samp>
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用案例</samp>
- en: We can visualize the importance of independent sets by considering a problem
    where we want to select people (nodes) without negative connections (edges). Imagine
    being tasked with building a functional project team in a highly dysfunctional
    organization. Every employee holds a collection of grudges against their coworkers
    for “misplaced” lunches or forgotten birthdays. In fact, the HR department has
    gone so far as to build a graph indicating pairwise grudges. Each node represents
    an employee and undirected edges indicate mutual ill will. The problem of finding
    a team of employees who do not dislike each other consists of finding a set of
    nodes within this graph such that no two share an edge.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过考虑一个问题来形象化独立集的重要性：我们希望选择一组没有负面联系（边）的人（节点）。想象一下，在一个高度功能失调的组织中，你被分配任务建立一个功能正常的项目团队。每个员工对同事都怀有怨恨，因为“错放”的午餐或被遗忘的生日。实际上，人力资源部门甚至已经建立了一个图，表示成对的怨恨关系。每个节点代表一名员工，无向边表示相互之间的恶意。寻找一个没有互相讨厌的员工团队的问题，就是在这个图中找到一组节点，使得这组节点之间没有共享边。
- en: Alternatively, we can visualize the independent set problem in the context of
    designing a magical dungeon. Aiming to provide adventurers with an appropriate
    but not impossible challenge, an evil wizard resolves not to include boss-level
    monsters in any two adjacent rooms. They model the dungeon level as a graph with
    nodes as rooms and the tunnels between them as edges. They then set about finding
    the largest possible independent set of rooms that will contain their boss-level
    monsters. The rest of the rooms can consist of low-level slimes to give the adventurers
    a break.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将独立集问题想象成设计一个神奇地下城的背景。为了给冒险者提供一个适当但不至于不可能完成的挑战，一位邪恶的巫师决定不在任何两个相邻的房间中放置BOSS级怪物。他们将地下城层级建模为一个图，节点表示房间，房间之间的隧道表示边。接下来，他们开始寻找包含BOSS级怪物的最大独立集房间。其余的房间可以安排低级史莱姆，以便给冒险者们休息一下。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Greedy Search</samp>
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">贪心搜索</samp>
- en: As with the clique algorithm, we can define a greedy algorithm that builds independent
    sets one node at a time by adding compatible nodes. We list the options for independent
    expansion by checking whether each node is valid, as shown in [Listing 17-5](#list17-5).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 和团体算法一样，我们可以定义一个贪心算法，通过逐个添加兼容节点来构建独立集。我们通过检查每个节点是否有效，列出独立扩展的选项，如[列表 17-5](#list17-5)所示。
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-5: Finding nodes
    that can be added to an independent set</samp>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 17-5：找到可以添加到独立集中的节点</samp>
- en: The code iterates through each node in the graph and tests whether that node
    could be added to the independent set. For this function, the code checks that
    the node under consideration does not share an edge with any node in the current
    set ❶. Only if those checks pass for every node in the set (and <samp class="SANS_TheSansMonoCd_W5Regular_11">valid</samp>
    is still <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>) does the code
    add the current node to the list of options.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 代码遍历图中的每个节点，并测试该节点是否可以添加到独立集合中。对于这个功能，代码检查考虑中的节点是否与当前集合中的任何节点共享边 ❶。只有当这些检查对于集合中的每个节点都通过（并且
    <samp class="SANS_TheSansMonoCd_W5Regular_11">valid</samp> 仍然为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>）时，代码才会将当前节点添加到候选节点列表中。
- en: Rather than choosing just any viable node, we can often extend greedy searches
    by choosing the next node with a heuristic. This heuristic will not guarantee
    correct results 100 percent of the time, but it can help guide the set construction
    in better directions. One reasonable heuristic for the independent set problem
    is to choose nodes with the fewest number of edges, which are likely to have fewer
    conflicts with other nodes and thus be more compatible with our needs. In the
    context of our dysfunctional organization, this corresponds to choosing team members
    who hold the fewest grudges.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过选择下一个符合启发式的节点来扩展贪婪搜索，而不是仅仅选择任何可行的节点。这个启发式方法不会保证 100% 的正确结果，但它可以帮助引导集合构建朝着更好的方向发展。对于独立集合问题，一个合理的启发式方法是选择边数最少的节点，这些节点可能与其他节点的冲突较少，因此更符合我们的需求。在我们功能失调的组织中，这相当于选择那些怀恨最少的团队成员。
- en: '[Listing 17-6](#list17-6) shows how we can codify this heuristic by modifying
    [Listing 17-5](#list17-5) to return the feasible node with the fewest number of
    edges.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 17-6](#list17-6) 展示了我们如何通过修改 [清单 17-5](#list17-5) 来编码这个启发式方法，从而返回具有最少边数的可行节点。'
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-6: Finding the node
    with the fewest edges that is compatible with the independent set</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 17-6：寻找与独立集合兼容的具有最少边数的节点</samp>
- en: The code largely mirrors that of [Listing 17-5](#list17-5) but tracks the best
    node seen (<samp class="SANS_TheSansMonoCd_W5Regular_11">best_option</samp>) and
    its number of edges (<samp class="SANS_TheSansMonoCd_W5Regular_11">best_num_edges</samp>).
    It starts by setting the best node seen to the invalid option <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    and the best number of edges to more than could be adjacent to a single node ❶.
    The code then uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to check each node for feasibility. However, before the feasibility test
    itself, the code checks whether the node under consideration has fewer edges than
    the best found so far ❷. If not, it does not matter whether the node is feasible,
    as the code will not be returning it anyway. It can therefore skip the feasibility
    test and move on to the next node.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在很大程度上与 [清单 17-5](#list17-5) 中的代码相似，但会跟踪看到的最佳节点（<samp class="SANS_TheSansMonoCd_W5Regular_11">best_option</samp>）及其边数（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">best_num_edges</samp>）。它首先将看到的最佳节点设置为无效选项
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>，并将最佳边数设置为大于单个节点可能相邻的数量
    ❶。然后，代码使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环检查每个节点的可行性。然而，在进行可行性测试之前，代码会先检查考虑中的节点是否比当前已找到的最佳节点具有更少的边
    ❷。如果没有，它是否可行就不重要，因为代码反正不会返回它。因此，它可以跳过可行性测试，继续检查下一个节点。
- en: The actual feasibility test is identical to that in [Listing 17-5](#list17-5)
    ❸. The code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    through the existing independent set to test each node against the current candidate
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>. Only if those checks pass
    for every node in the set does the code save the current node as the new <samp
    class="SANS_TheSansMonoCd_W5Regular_11">best_option</samp>. After exhausting all
    possible nodes, the code returns the best found.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的可行性测试与 [清单 17-5](#list17-5) 中的完全相同❸。代码使用一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环遍历现有的独立集合，测试每个节点是否与当前候选节点 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    兼容。只有当这些检查对于集合中的每个节点都通过时，代码才会将当前节点保存为新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">best_option</samp>。在遍历完所有可能的节点后，代码返回找到的最佳节点。
- en: 'We can build the greedy search by continually adding the best candidate to
    the independent set:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过不断将最佳候选节点添加到独立集合中来构建贪婪搜索：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code starts with an empty list <samp class="SANS_TheSansMonoCd_W5Regular_11">i_set</samp>
    and uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">independent_set _lowest_expansion()</samp>
    function from [Listing 17-6](#list17-6) to find the best-looking node to add.
    It uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to continually
    find and add nodes until no other nodes can be added.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: In the context of our dysfunctional organization example, the greedy search
    algorithm for finding independent sets consists of building a team one person
    at a time by always selecting the employee with the fewest grudges who is compatible
    with everyone previously selected. We start by selecting employees (nodes) who
    have no conflicts (no edges). We can always add these employees to an independent
    set. Next, we consider employees with only a single conflict, and so forth, always
    skipping employees who are incompatible with anyone on the current team.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Greedy search will not always find the maximum independent set. Despite the
    use of an informative heuristic, this greedy search can still make suboptimal
    choices that relegate the solution to a local minimum. Consider what happens if
    we apply this greedy algorithm to the graph in [Figure 17-6](#fig17-6).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with six nodes and undirected edges (0, 2), (0, 4), (1, 3), (1, 5),
    (2, 3), (2, 4), (2, 5), and (4, 5). (A) has nodes 0 and 1 shaded. (B) has nodes
    0, 3, and 5 shaded.](../images/f17006.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-6: The results of
    a greedy search for maximum independent sets (a) and the true maximum independent
    set (b)</samp>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in [Figure 17-6(a)](#fig17-6), the greedy search will choose node
    0 and then node 1, locking itself into a local minimum. If the search had instead
    selected node 3 as its second choice, as shown in [Figure 17-6(b)](#fig17-6),
    it would have found {0, 3, 5}.  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Backtracking
    Search</samp>'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The backtracking search for constructing a maximum independent set again tries
    to label each node a member or non-member of the set. This branching allows the
    function to test all combinations of nodes and return the largest independent
    set found through each branch of the search. At each level of recursion, the function
    in [Listing 17-7](#list17-7) takes the independent set (<samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp>)
    constructed so far and the next node to test (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-7: Recursively exploring
    possible independent sets</samp>'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Following the same pattern as the <samp class="SANS_TheSansMonoCd_W5Regular_11">maximum_clique_recursive()</samp>
    function from [Listing 17-4](#list17-4), the <samp class="SANS_TheSansMonoCd_W5Regular_11">maximum_independent_set_rec()</samp>
    function starts by testing whether it has reached the end of the recursion and
    there are no nodes left to check ❶. If so, it returns a copy of the current independent
    set as the best found down this branch.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: If the search has not reached the end of the recursion, it tries building out
    independent sets both with and without <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>.
    It tests the subset without <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    by calling the function with the current independent set and the index of the
    next node ❷. This effectively skips adding the current index and moves on to considering
    later nodes. The code saves the best result found down that branch as the baseline
    for other branches.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The code then checks whether the current node (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>)
    is compatible with the independent set under construction ❸. If the current node
    shares an edge with any node in <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp>,
    adding it would result in an invalid independent set. The code explores only paths
    that result in valid independent sets (<samp class="SANS_TheSansMonoCd_W5Regular_11">can_add</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: If the current node is compatible with the current set, the code tries adding
    the node to <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp> and recursively
    testing the remaining options ❹. Afterward, it cleans up the <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp>
    list by removing <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> so
    that it can continue to use the list in other branches ❺. The code compares the
    results of the two branches and keeps the larger valid subset of nodes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the function in [Listing 17-7](#list17-7) with an initial <samp class="SANS_TheSansMonoCd_W5Regular_11">current=[]</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">index=0</samp> or use a wrapper
    function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Figure 17-7](#fig17-7) shows a visualization of the search where each level
    depicts the algorithm branching on the inclusion (or not) of a single node. Nodes
    assigned to the independent set are shaded, nodes excluded are white, and unassigned
    nodes are dashed circles.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![A tree where each node corresponds to a four-node graph with undirected edges
    (0, 1), (0, 3), (1, 2), and (1, 3). At the root node, all graph nodes are dashed.
    At each level of the tree, another node become either solid white or solid gray.](../images/f17007.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-7: The exploration
    of a backtracking search for maximum independent sets</samp>'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The subgraphs in [Figure 17-7](#fig17-7) show the state of <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp>
    at the start of each function call. The first level considers whether to include
    node 0; the second considers including node 1\. Since the function explores only
    branches containing valid independent sets, it reaches only 7 of the 16 possible
    full assignments.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Vertex Cover</samp>
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whereas the problems of finding cliques and independent sets both focus on
    whether a pair of nodes are neighbors, the problem of *vertex cover* considers
    the edges that each node touches. We define a vertex cover within an undirected
    graph as a subset of nodes such that every edge has at least one endpoint in the
    set. In other words, each edge is covered by at least one vertex (node). Formally,
    the vertex cover is a set of nodes *V*′ ⊆ *V* such that:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: For every edge (*u*, *v*) ∈ *E*, we have *u* ∈ *V*′, *v* ∈ *V*′, or both.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: We can envision vertex covers in the context of a kingdom that consists of an
    archipelago of islands (nodes) connected by bridges (edges). To maintain security,
    the kingdom constructs tall watchtowers to survey each bridge. The watchtower
    on each island views every bridge touching the island, allowing the kingdom to
    be strategic about the towers’ locations. However, each bridge (edge) must end
    on at least one island containing a watchtower (selected node).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 17-8](#fig17-8) shows a graph with two shaded subsets of nodes. The
    shaded nodes {1, 3, 5} in [Figure 17-8(a)](#fig17-8) form a vertex cover because
    each edge touches at least one shaded node. In contrast, the shaded nodes {0,
    1, 4} in [Figure 17-8(b)](#fig17-8) do not form a vertex cover, as the edge (2,
    5) is not covered by any node in the set.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with six nodes and undirected edges (0, 1), (0, 3), (1, 2), (1, 5),
    (2, 5), (3, 4), and (4, 5). In (A), the shaded nodes are 1, 3, and 5\. In (B),
    the shaded nodes are 0, 1, and 4.](../images/f17008.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-8: A graph with a
    subset of nodes forming a vertex cover (a) and a subset of nodes that is not a
    vertex cover (b)</samp>'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Determining whether a set of nodes forms a vertex cover requires us to check
    whether each edge in the graph is covered by at least one node in the set:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code starts by creating a set of the included nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">node_set</samp>)
    to enable fast lookups by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    data structure instead of searching through a <samp class="SANS_TheSansMonoCd_W5Regular_11">list</samp>
    ❶. It then loops through each edge in the graph and checks whether both the origin
    and destination nodes are missing from the set ❷. If neither node is included
    in the set, the edge is not covered, and the function immediately returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. If the code makes it through
    all edges, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先创建一个包含节点的集合（<samp class="SANS_TheSansMonoCd_W5Regular_11">node_set</samp>），通过使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> 数据结构来实现快速查找，而不是通过 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">list</samp> 进行搜索 ❶。然后，它循环遍历图中的每一条边，检查源节点和目标节点是否都不在集合中
    ❷。如果这两个节点都不在集合中，那么该边就没有被覆盖，函数立即返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。如果代码能遍历所有的边，最后返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。
- en: The problem of finding the *minimum vertex cover* consists of finding the smallest
    subset of nodes *V*′ ⊆ *V* in the graph that form a vertex cover. This problem
    has direct analogies in cost savings. In the watchtower example, the kingdom wants
    to build the minimum number of watchtowers that will secure every bridge.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找*最小顶点覆盖*的问题就是找到图中最小的节点子集 *V*′ ⊆ *V*，该子集能形成一个顶点覆盖。这个问题与成本节省有直接的类比。在瞭望塔的例子中，王国希望建造最少数量的瞭望塔，以确保每座桥梁的安全。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Use Cases</samp>
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用案例</samp>
- en: The problem of vertex cover arises naturally in the context of maintenance.
    Imagine that an evil but tidy wizard has constructed a magical dungeon. Knowing
    that they cannot leave passages unswept or risk torches burning out, they need
    to station a crew of emergency-repair minions near each passage. After adventurers
    blunder down tunnels, knocking stones loose in their fights with monsters, the
    minions rush forth to repair the damage. For the sake of expediency, the wizard
    needs to station a crew in at least one of the two rooms at the end of each passage.
    To minimize costs, the wizard meticulously finds the smallest number of crews
    they can employ.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点覆盖问题在维护的背景下自然出现。假设一个邪恶但整洁的巫师建造了一个魔法地下城。知道自己不能让通道不清扫或冒着火把熄灭的风险，他们需要在每个通道附近安置一队紧急修理小兵。在冒险者跌跌撞撞地走过隧道，与怪物搏斗时打松了石块后，小兵们会冲过去修复损坏。为了效率，巫师需要在每个通道尽头的两个房间中至少安排一个队伍。为了尽量降低成本，巫师精心计算出他们可以雇佣的最少数量的队伍。
- en: In a non-magical context, we might be interested in employing maintenance crews
    or toll collectors for transportation networks. To keep costs low, we plan a single
    set of tollbooths through which all incoming and outgoing traffic to the island
    flows.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在非魔法环境下，我们可能会考虑雇佣维修队或收费员来管理交通网络。为了保持成本低廉，我们计划设置一个收费站，通过该收费站，所有进出岛屿的交通流量都会经过。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Greedy Search</samp>
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">贪心搜索</samp>
- en: We can build on the greedy algorithm presented for independent sets to create
    a greedy approach for finding a vertex cover using a subset of the nodes, as shown
    in [Listing 17-8](#list17-8). This time, we use the heuristic of selecting the
    node that covers the largest number of uncovered edges.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以基于为独立集提出的贪心算法，创建一个用于寻找顶点覆盖的贪心方法，方法是使用节点的子集，如[清单 17-8](#list17-8)所示。这一次，我们使用启发式方法，选择能够覆盖最多未覆盖边的节点。
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-8: Heuristically
    selecting a node to add to a vertex cover</samp>'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 17-8：启发式选择一个节点来添加到顶点覆盖中</samp>
- en: In comparison to the code in [Listing 17-6](#list17-6), this code does additional
    bookkeeping to track edges already covered in the set <samp class="SANS_TheSansMonoCd_W5Regular_11">edges_covered</samp>.
    It starts by creating an empty set of covered edges ❶. Because of our <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class’s implementation of undirected edges, the code adds each undirected edge
    in both directions to <samp class="SANS_TheSansMonoCd_W5Regular_11">edges_covered</samp>.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The main <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is similar
    to the heuristic for independent sets, where the code iterates through each node
    in the graph and checks its heuristic value. In this case, the code counts how
    many of the current node’s edges would be newly covered ❷, keeps the best option
    seen so far, and returns it. If there are no nodes that would increase the number
    of covered edges (that is, <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes</samp>
    already forms a valid vertex covering), the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a full greedy algorithm by putting a loop around the selection logic
    within [Listing 17-8](#list17-8):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code starts with an empty list of nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">nodes</samp>)
    to represent the current selection and uses <samp class="SANS_TheSansMonoCd_W5Regular_11">vertex_cover_greedy_choice()</samp>
    from [Listing 17-8](#list17-8) to add nodes one by one until it has constructed
    a valid vertex covering and no additions would increase the coverage.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Note that we could improve the efficiency of this greedy algorithm by maintaining
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">edges_covered</samp> set in
    the outer loop and passing it into the <samp class="SANS_TheSansMonoCd_W5Regular_11">vertex_cover_greedy_choice()</samp>
    function. This avoids the cost of recomputing it with each iteration. For the
    context of this description, we intentionally recompute <samp class="SANS_TheSansMonoCd_W5Regular_11">edges_covered</samp>
    so as to keep the selection function stand-alone.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: As was the case with all the other greedy algorithms in this chapter, the greedy
    algorithm for minimum vertex cover is not guaranteed to be optimal. A seemingly
    good-looking initial choice might prove to be suboptimal in the context of the
    entire graph.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Imagine the planner in our watchtower example working on the islands shown in
    [Figure 17-9](#fig17-9). Determined to keep costs low, the planner selects the
    island with the highest number of bridges (node 0) for first watchtower. This
    is generally a good strategy, as that node covers the most edges. However, in
    this case, it leads to the suboptimal solution shown in [Figure 17-9(a)](#fig17-9).
    By choosing node 0 first, the planner needs to choose three more islands to cover
    the rightmost edges. Worse, they will repeat this mistake again and again. As
    long as the greedy algorithm is using deterministic choices, it will always produce
    the same results.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with seven nodes and edges (0, 1), (0, 2), (0, 3), (1, 4), (2, 5),
    and (3, 6). In (A), nodes 0, 1, 2, and 3 are shaded. In (B), nodes 1, 2, and 3
    are shaded.](../images/f17009.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-9: The results of
    a non-optimal greedy search (a) compared to the optimal solution (b) on a minimum
    vertex cover problem</samp>'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, [Figure 17-9(b)](#fig17-9) shows a vertex cover that uses fewer
    nodes. Once we have included nodes 1, 2, and 3, we no longer need to include node
    0.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Backtracking Search</samp>
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While the backtracking search for minimum vertex cover follows a similar node-by-node
    approach to both maximum clique and independent set construction, constructing
    a vertex cover by adding nodes does not offer the same pruning opportunities.
    Our general pruning approach requires us to start with a valid solution and skip
    choices that make our candidate set invalid. However, a subset of a valid vertex
    cover may not cover each edge and thus may not be a valid vertex cover itself.
    We therefore cannot start with an empty set and build up from there.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: We regain the opportunity to prune if we start with a full set of nodes and
    remove them one by one, instead of adding nodes to a set. Since the set of all
    nodes is itself a valid vertex cover, we regain the constraint that we are following
    only branches that remain valid vertex covers.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: At each level of recursion, the backtracking search function takes the current
    vertex cover (<samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp>) and
    the next node to test for removal (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>)
    and explores the possibilities if it both does and does not remove that node,
    as shown in [Listing 17-9](#list17-9).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-9: Recursively exploring
    possible vertex covers</samp>'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The code starts by testing whether it has reached the end of the recursion and
    there are no nodes left to check ❶. If so, it returns a copy of the current vertex
    cover as the best found down this branch.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: If the function has not reached the end of the recursion, the code tries vertex
    covers with and without <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>.
    In contrast to the searches in Listings 17-4 and 17-7, however, it is considering
    whether to *remove* <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>.
    The default option is to leave <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    in the set by recursively calling the function with the current set and the index
    of the next node. The code saves the result of this branch as the baseline best
    result.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Before removing the node, the code checks whether this removal would break the
    vertex cover. For the set to remain valid without <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>,
    all the edges currently covered by that node must be covered by another node in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp> ❷. The code checks
    this by iterating over each of the current node’s edges and checking whether the
    corresponding neighbor (<samp class="SANS_TheSansMonoCd_W5Regular_11">edge.to_node</samp>)
    is in <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp>.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: If it is viable to remove the current node, the code tries removing <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp> and recursively
    testing the remaining options. It then cleans up the <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp>
    data by re-adding <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> so
    the set can be used in other branches ❸. The code compares the results of the
    two branches and keeps the smaller valid subset of nodes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the function in [Listing 17-9](#list17-9) with an initial <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp>
    equal to a set of all node indices and <samp class="SANS_TheSansMonoCd_W5Regular_11">index=0</samp>
    by using a wrapper function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Figure 17-10](#fig17-10) provides a visualization of this search where each
    level shows the algorithm branching on the removal (or not) of a single node.
    Nodes assigned to the vertex cover are shaded, excluded nodes are white, and unassigned
    nodes are dashed circles initially included in the vertex cover.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![A tree where each node corresponds to a four-node graph with undirected edges
    (0, 1), (0, 3), (1, 2), and (1, 3). At the root node, all graph nodes are dashed
    and gray. At each level of the tree, another node becomes either solid white or
    solid gray.](../images/f17010.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-10: A backtracking
    search for finding vertex covers</samp>'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The subgraphs in [Figure 17-10](#fig17-10) show the state of <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp>
    at the start of each function call. Since the function explores only branches
    containing valid vertex covers, it reaches only 7 of the possible 16 full assignments.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Randomized Algorithms</samp>
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another approach to solving the types of assignment problems discussed in this
    chapter is to evaluate solutions using *randomized algorithms*. Such algorithms
    use a random number generator to select which node to add to or remove from the
    set next. At first this might seem unlikely to work. Deterministically minded
    users might exclaim, “Why add a random node when we could add the best node with
    greedy search? Won’t we waste a lot of time on bad choices?” While randomized
    algorithms can and will explore suboptimal choices, they offer a few important
    advantages to consider.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: First, randomized algorithms avoid the local minima that can trap greedy algorithms.
    As we saw in [Figure 17-9(a)](#fig17-9), greedy searches can lead to suboptimal
    solutions by making each choice in isolation. In contrast, the randomized algorithm
    will occasionally guess a good solution, like the one in [Figure 17-9(b)](#fig17-9).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, a randomized algorithm lends itself well to parallelization: we can
    run many randomized searches in parallel (without significant coordination), then
    compare the best results found in each. This is equivalent to having multiple
    watchtower planners perform their own randomized searches and compare the results,
    perhaps as part of a kingdom-wide competition where contestants vie to produce
    the best watchtower plan. Each group can work in isolation without the need for
    kingdom-wide coordination.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: In its simplest form, there is nothing to prevent a randomized search from trying
    the same solution multiple times. While we could use additional tracking to avoid
    or at least discourage evaluating duplicate options, this adds complexity and,
    in the case of parallel searches, the need for coordination. In this section,
    we focus on the basics of how randomization works and thus keep the implementations
    simple.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Basic Randomized
    Search</samp>
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The simplest randomized search selects viable options completely at random.
    Let’s consider how this works in the context of finding maximum independent sets.
    We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">independent_set_expansion_options()</samp>
    function from [Listing 17-5](#list17-5) as follows to provide a list of feasible
    options:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The code starts with an empty independent set (<samp class="SANS_TheSansMonoCd_W5Regular_11">i_set</samp>)
    and a list of all nodes as potential options (<samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp>).
    The code operates by continuously choosing one of the feasible nodes at random
    ❶, adding it to the independent set, and rebuilding the set of feasible expansion
    options ❷. The code uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">randint()</samp>
    function from Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">random</samp>
    library to select a node, requiring the inclusion of <samp class="SANS_TheSansMonoCd_W5Regular_11">import
    random</samp> at the top of the file. The loop continues until there are no more
    options to add, at which point the code returns the current independent set.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite being randomized, this function is guaranteed to produce valid independent
    sets. During each iteration, the algorithm considers only expansions from a list
    of feasible options, meaning the independent set remains valid after each addition.
    We can use a loop to keep searching for a better solution until we hit some maximum
    number of iterations:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code starts with an empty independent set (<samp class="SANS_TheSansMonoCd_W5Regular_11">best_iset</samp>)
    as the best result seen so far. It then uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to generate and test more options. During each iteration, the code generates
    a random independent set using <samp class="SANS_TheSansMonoCd_W5Regular_11">independent_set_random()</samp>
    and compares its size to the best it has seen so far. It tracks the largest independent
    set seen as <samp class="SANS_TheSansMonoCd_W5Regular_11">best_iset</samp> and
    returns it after testing <samp class="SANS_TheSansMonoCd_W5Regular_11">iterations</samp>
    options.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: We can picture this search in the context of the earlier example of building
    teams in a dysfunctional organization. The planner is determined to build the
    biggest team but lacks the time to do an exhaustive search. Panicked by their
    tight deadline, they resolve to build 100 random but valid teams and present the
    best one to their boss. For each of their 100 attempts to create a team, they
    use random selection to make sure they at least have the possibility of trying
    options they have not previously considered. After 100 tries, they write up the
    best team and run to their boss’s office to meet the deadline.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Like the greedy search, the randomized search is not guaranteed to find the
    optimal solution. However, unlike the greedy search, the randomized search can
    avoid making the same mistake over and over.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Weighted Randomized
    Search</samp>
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One potential downside of completely randomized searches is that we have an
    equal probability of picking a promising node or a terrible node. While there
    must be some probability of selecting each node to fully explore the solution
    space, we are not constrained to selecting nodes with equal probability. There’s
    no reason we need to give the office diplomat (who has no interpersonal conflicts)
    and office troublemaker (who has ongoing feuds with half the company) equal shots
    at being on the team.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'A *weighted randomized algorithm* uses information about the problem structure
    to define a custom probability distribution for selecting nodes. As a simple example,
    consider selecting the next node in the maximum independent set problem. Given
    a subset of nodes *V*′ ⊆ *V* representing the current independent set, we can
    define a set of viable candidates *C* as the set of nodes that are not already
    in *V*′ and do not share an edge with a node in *V*′. Formally, we say:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'For each *u* ∈ *C* and *v* ∈ *V*′: *u* ≠ *v* and (*u*, *v*) ∉ *E*.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this candidate set *C,* we can define a probability distribution *p*(*v*)
    of selecting node *v* ∈ *V* where:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '*p*(*v*) = 0 if *v* ∉ *C*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: and
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: ∑v *p*(*v*) = 1
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: For example, we could assign each node a weight that is inversely proportional
    to the number of adjacent edges, making it more likely that we will select nodes
    with fewer neighbors.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For all the problems covered in this chapter and the previous one, it’s easy
    to evaluate a proposed solution but difficult to find the best solution. We’ve
    examined a variety of approaches for solving NP-hard graph assignment problems,
    including greedy searches, randomized searches, exhaustive searches, and customized
    (heuristic) algorithms. Yet no known approach is efficient for all cases.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: These problems represent only a subset of the NP-hard graph problems. While
    they do not have known general-purpose efficient algorithms, they often correspond
    to vital real-world questions. Therefore, it is important to understand not only
    the structure of the problems but also practical techniques for solving them.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'We presented two approaches for each of the problems in this chapter—an approximate
    greedy solution and an exhaustive solution using backtracking search—to illustrate
    the problems and the factors making them computationally difficult. These approaches
    barely scratch the surface of the range of techniques that have been studied.
    For example, the interested reader can find a bounded approximation algorithm
    for vertex cover in Cormen, Leiserson, Rivest, and Stein’s *Introduction to Algorithms*,
    4th edition (MIT Press, 2022). Russell and Norvig’s *Artificial Intelligence:
    A Modern Approach*, 4th edition (Pearson, 2020), provides a good introduction
    to the powerful world of constraint satisfaction algorithms and applying those
    to problems such as graph coloring.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, rather than selecting nodes for a set, we tackle the problem
    of choosing which edges to traverse as part of a tour through the graph.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
