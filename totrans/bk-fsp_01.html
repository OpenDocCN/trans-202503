<html><head></head><body><section class="chapter" title="Chapter&#xA0;1.&#xA0;Meet F#" epub:type="chapter" id="meet_fhash"><div class="titlepage"><div><div><h2 class="title">Chapter 1. Meet F#</h2></div></div></div><p><a id="iddle1648" class="indexterm"/><a id="iddle1685" class="indexterm"/>Originally developed at Microsoft Research, Cambridge, F# is a functional-first, multi-paradigm language. In plain terms, that means that while F#’s syntax and constructs emphasize writing code that applies functions to data, it’s also a full-featured, object-oriented language with a few imperative constructs tossed in for good measure.</p><p>F# dates back to 2002, but the first major release didn’t appear until Microsoft made version 1.0 available in 2005. F# is descended from the ML language and was heavily inspired by OCaml in particular. Early in its development, the F# team strived to maintain syntactic compatibility with ML, but over time the language has diverged a bit. Gradually, F# has found its place as a first-class citizen of Visual Studio, with project templates available out-of-the-box in every version starting with Visual Studio 2010. F#’s latest release accompanies Visual Studio 2013 and has been designated as version 3.1.</p><p><a id="iddle1125" class="indexterm"/><a id="iddle1418" class="indexterm"/><a id="iddle1564" class="indexterm"/><a id="iddle1784" class="indexterm"/><a id="iddle2012" class="indexterm"/>Despite its inclusion in Visual Studio, F# has developed an undeserved reputation as a niche language useful only in academia or highly specialized financial software. As a result, it has failed to secure widespread adoption, particularly in enterprise software, but that seems to be changing as developers are starting to understand the virtues of functional languages. The fact that F# is an open source language licensed under the Apache 2.0 license and there are compilers available on every major platform is also helping the language gain traction. Microsoft continues to contribute heavily to F#, but the language itself is managed by the independent F# Software Foundation.</p><p>The goal of this chapter is to give you an idea of how F# programs are organized at both the Visual Studio project and code levels. As you learn the language, you’ll find that F# truly is a general-purpose language capable of meeting the demands of most modern software development tasks.</p><p>Unless otherwise noted, the examples in this book were developed with F# 3.1 in Visual Studio 2013 (Professional and Ultimate editions). If, for any reason, you’re not using Visual Studio, don’t fret; the majority of the examples within this book are applicable no matter which platform you’re using.</p><div class="note" title="Note"><h3 class="title"><a id="ch01note01"/>Note</h3><p><span class="emphasis"><em>Although I don’t specifically cover them, if you intend to follow along with a development environment other than Visual Studio, the F# Software Foundation has plenty of resources to help you get started on its website at</em></span> <a class="ulink" href="http://fsharp.org/" target="_top">http://fsharp.org/</a><span class="emphasis"><em>. You can also try F# in your browser at</em></span> <a class="ulink" href="http://www.tryfsharp.org/" target="_top">http://www.tryfsharp.org/</a>.</p></div><div class="sect1" title="F# in Visual Studio"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="fhash_in_visual_studio">F# in Visual Studio</h2></div></div></div><p>Because this book is primarily intended for experienced .NET developers, I’ll assume you already know how to create projects in Visual Studio. I’ll go right into introducing the different F# project templates that are available to you and follow that with a brief discussion about file organization within an F# project.</p><div class="sect2" title="Project Templates"><div class="titlepage"><div><div><h3 class="title" id="project_templates">Project Templates</h3></div></div></div><p>Each of the Visual F# project templates is listed under the Visual F# category in the New Project dialog, but the category’s location within the list will vary according to your IDE settings. If the Visual F# category isn’t listed immediately under Installed Templates, check under the Other Languages node. If you still don’t see it, make sure the F# components are installed. <a class="xref" href="ch01.html#fhash_project_templates_in_visual_studio" title="Figure 1-1. F# project templates in Visual Studio 2013">Figure 1-1</a> shows each template as it would appear with the IDE configured for F# development and targeting .NET 4.0.</p><p>As you can see, there are five templates available. The template names are pretty intuitive, but here’s a rundown:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none"><p title="Console Application"><span class="title"><strong><span class="strong"><strong>Console Application</strong></span></strong></span>. Creates a new command-line application.</p></li><li class="listitem" style="list-style-type: none"><p title="Library"><span class="title"><strong><span class="strong"><strong>Library</strong></span></strong></span>. Creates a new library you can reference from other applications or libraries.</p><div class="figure"><a id="fhash_project_templates_in_visual_studio"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00003"/><img src="httpatomoreillycomsourcenostarchimages1981198.png.jpg" alt="F# project templates in Visual Studio 2013"/></div></div><div class="figure-title">Figure 1-1. F# project templates in Visual Studio 2013</div></div></li><li class="listitem" style="list-style-type: none"><p title="Tutorial"><span class="title"><strong><span class="strong"><strong>Tutorial</strong></span></strong></span>. Is a quick way to peek into what F# has to offer, but it’s not very useful for starting new projects.</p></li><li class="listitem" style="list-style-type: none"><p title="Portable Library"><span class="title"><strong><span class="strong"><strong>Portable Library</strong></span></strong></span>. Creates a portable class library that can be used by both .NET 4.5 and Windows Store applications.</p></li><li class="listitem" style="list-style-type: none"><p title="Portable Library (Legacy)"><span class="title"><strong><span class="strong"><strong>Portable Library (Legacy)</strong></span></strong></span>. Creates a portable class library that can be used by both .NET 4.0 and Silverlight applications.</p></li><li class="listitem" style="list-style-type: none"><p title="Silverlight Library"><span class="title"><strong><span class="strong"><strong>Silverlight Library</strong></span></strong></span>. Creates a new library you can reference in a Silverlight application.</p></li></ul></div><p>Once you’ve created a project with any of these templates, you should see the familiar Visual Studio interface with the text editor, Solution Explorer, and any other windows you may normally have open. Depending on whether you’ve previously experimented with F#, you may also see the F# Interactive window.</p><p>Among the templates that are conspicuously missing are those for Windows Forms applications, WPF applications, and ASP.NET applications. A key reason for the omission is that many of the designer tools haven’t been updated to support generating or understanding F# code. Despite the lack of built-in templates, you can still construct applications with F# using these technologies, but typically you have to do more manual work.</p><div class="note" title="Note"><h3 class="title"><a id="ch01note02"/>Note</h3><p><span class="emphasis"><em>The F# Community Templates repository on GitHub hosts a number of additional templates. At the time of this writing, the repository contains only a handful of templates for Visual Studio, but over time it’s likely that templates for other editors, such as Xamarin Studio, will be added to the mix. You can find the repository at</em></span> <a class="ulink" href="https://github.com/fsharp/FSharpCommunityTemplates/" target="_top">https://github.com/fsharp/FSharpCommunityTemplates/</a>.</p></div></div><div class="sect2" title="Project Organization"><div class="titlepage"><div><div><h3 class="title" id="project_organization">Project Organization</h3></div></div></div><p>When you first see Visual Studio’s project workspace after creating a project from one of the aforementioned templates, you may be tempted to think that an F# project is just like a C# or Visual Basic project. In some regards, it is. For instance, you can start executable projects by pressing F5, the Visual Studio debugger can step through F# code, and files are managed with Solution Explorer. However, project organization in F# is very different from that of the traditional .NET languages. In fact, you’ll probably find that F#’s code structure is almost as foreign as the language itself.</p><p>Traditional .NET projects generally follow the convention of one type per file; that is, individual data types are almost always stored in separate files and organized into a folder hierarchy that mirrors the project’s namespaces. Aside from avoiding circular assembly references, there are very few steadfast rules on how or when something can appear within a project. Barring any accessibility modifiers (public, private, and so on), types and members are free to reference each other and their members regardless of where they are defined in the project.</p><p>Some rules are meant to be broken, but in this case F# shredded the project organization rulebook and then burned the remains. It is incredibly prescriptive about how projects are organized, and for good reason: F# code is evaluated from top to bottom. This means that not only is the order of declarations within an individual code file significant, but the order of the files within your project is significant as well!</p><p>It’s common for new F# programmers to add a new file to the project, fill in some definitions, and then get compiler errors stating that the new definitions are missing. This is usually because the programmer forgot to move the newly created file above the files that will use the definitions. Fortunately, changing file order within an F# project is relatively painless because there are context menu items and hotkeys to move files up and down, as shown in <a class="xref" href="ch01.html#move_and_add_options_in_solution_explore" title="Figure 1-2. Move and Add options in Solution Explorer’s context menu">Figure 1-2</a>.</p><p>The other major implication of F#’s top-down evaluation order is that folders are not allowed. Folders wouldn’t necessarily break the evaluation order, but they certainly do complicate it, so there’s no option within the IDE to add them.</p><p>You might be wondering what advantage such an evaluation structure could possibly offer. The primary benefit is that the compiler can make more assumptions about your code and, as a result, give you type inference capabilities unrivaled by any other .NET language. Furthermore, this evaluation structure avoids inadvertent recursive definitions (when two or more <a id="iddle2115" class="indexterm"/>types depend on each other). This makes you think a bit more about how and where your types are used, and it forces you to be explicit about recursive definitions where they’re appropriate.</p><div class="figure"><a id="move_and_add_options_in_solution_explore"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00004"/><img src="httpatomoreillycomsourcenostarchimages1981200.png.jpg" alt="Move and Add options in Solution Explorer’s context menu"/></div></div><div class="figure-title">Figure 1-2. Move and Add options in Solution Explorer’s context menu</div></div></div></div><div class="sect1" title="Significance of Whitespace"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="significance_of_whitespace">Significance of Whitespace</h2></div></div></div><p>Newcomers to F# are usually quick to notice the absence of braces or <code class="literal">BEGIN</code> and <code class="literal">END</code> delimiters. Rather than relying on syntactic tokens to denote code blocks, the designers of F# decided to make whitespace significant.</p><p>Code that is inside a block must be indented farther than the line that opens the block. For example, when you define a function, the lines belonging to the function’s body must begin to the right of the first character of the function declaration. It doesn’t really matter how far the lines are indented, only that they are indented and that the indentation level is consistent for each line in a block.</p><p>With most programming languages, this is the point where the age-old debate of tabs versus spaces would flare up, but this is not the case in F#. The F# compiler rules with an iron fist on this matter and expressly forbids <a id="iddle1044" class="indexterm"/><a id="iddle1565" class="indexterm"/><a id="iddle1666" class="indexterm"/><a id="iddle1667" class="indexterm"/><a id="iddle1668" class="indexterm"/><a id="iddle1670" class="indexterm"/><a id="iddle2107" class="indexterm"/>tabs because the number of spaces that a given tab character represents is unknown. When you begin writing F#, you’ll probably want to configure the options for Visual Studio’s text editor to insert spaces in place of tabs.</p><div class="sidebar"><a id="one_syntax_to_rule_them_all"/><div class="sidebar-title">One Syntax to Rule them All</div><p>To say that F# requires consistent indentation or that it expressly forbids tabs isn’t completely accurate. F# actually has two syntax formats: verbose and lightweight. The verbose format requires you to be more explicit with your code but isn’t as sensitive to indentation. Under verbose syntax you denote the end of a code block not by decreasing the indentation level, but by using additional keywords like <code class="literal">end</code> and <code class="literal">done</code>.</p><p>In F#’s infancy, verbose format was the norm, but as the language has matured, the lightweight syntax has gained favor and is now the default. Of course, there are other differences between verbose and lightweight syntax, but they are beyond the scope of this book. None of the examples in this book use verbose syntax, but should you yearn to write more code, you can revert to verbose syntax by opening a code file with the <code class="literal">#light off</code> directive.</p></div></div><div class="sect1" title="Grouping Constructs"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="grouping_constructs">Grouping Constructs</h2></div></div></div><p>There are two primary ways to group code in F#: namespaces and modules. In single-file projects, declaring a namespace or module is optional, as the contents of the file will implicitly become a module with the same name as the file—for example, if your file is named <span class="emphasis"><em>Program.fs</em></span>, the module will automatically be named <code class="literal">Program</code>. In all other cases, though, each file must begin with a namespace or module declaration.</p><div class="sect2" title="Namespaces"><div class="titlepage"><div><div><h3 class="title" id="namespaces">Namespaces</h3></div></div></div><p>F# namespaces are the same as in C# and Visual Basic in that they allow you to group related code by a name to reduce the likelihood of a naming conflict. Namespaces can include modules and type definitions but cannot directly include any values or functions.</p><p>You declare namespaces with the <code class="literal">namespace</code> keyword followed by an identifier. For example, a namespace for the code in this book might look like this:</p><a id="pro_id00001"/><pre class="programlisting">namespace TheBookOfFSharp</pre><p>You can also declare more granular namespaces by nesting them. Nested namespaces are declared with fully qualified names, with each level separated by a dot (<code class="literal">.</code>). For instance, we could group all the code for this chapter in a nested namespace like this:</p><a id="pro_id00002"/><pre class="programlisting">namespace TheBookOfFSharp.Chapter1</pre><p><a id="iddle1493" class="indexterm"/><a id="iddle1649" class="indexterm"/><a id="iddle1650" class="indexterm"/><a id="iddle1651" class="indexterm"/><a id="iddle1652" class="indexterm"/><a id="iddle1654" class="indexterm"/><a id="iddle1669" class="indexterm"/><a id="iddle1671" class="indexterm"/><a id="iddle1688" class="indexterm"/>Just as in the other .NET languages, you can split namespaces across files and assemblies. You can also declare multiple namespaces within a single file, but you cannot nest them inline; each namespace declaration must be a top-level block.</p><p>In the event that you want to place code in .NET’s global namespace, you can declare the namespace with the <code class="literal">global</code> keyword as follows:</p><a id="pro_id00003"/><pre class="programlisting">namespace global</pre><p>Whenever you declare a namespace, other code already loaded into that namespace is immediately made available to your code. For all other cases, though, you must either fully qualify the type or module names or import them using the <code class="literal">open</code> keyword, as you would with a <code class="literal">using</code> directive in C# or an <code class="literal">Imports</code> statement in Visual Basic. The following snippet shows both approaches:</p><a id="pro_id00004"/><pre class="programlisting">// Fully qualified name
let now = System.DateTime.Now

// Imported namespace
open System
let today = DateTime.Now.Date</pre></div><div class="sect2" title="Modules"><div class="titlepage"><div><div><h3 class="title" id="modules">Modules</h3></div></div></div><p>Modules are similar to namespaces in that they allow you to logically group code. Unlike namespaces, however, they can directly contain values and functions. In practice, modules are more closely related to classes containing only static members in other .NET languages; in fact, that’s how they’re represented in the compiled assembly.</p><p>Modules fall into one of two categories: top-level and local. <span class="emphasis"><em>Top-level</em></span> modules contain all the code in a single implementation file. By contrast, <span class="emphasis"><em>local</em></span> modules are used when multiple modules or types not belonging to a module are defined in the same file.</p><p>You declare modules with the <code class="literal">module</code> keyword followed by an identifier, like this:</p><a id="pro_id00005"/><pre class="programlisting">module TheBookOfFSharp</pre><p>Unlike namespaces, module definitions cannot span multiple files, but you can define multiple modules within a single file. You can also nest modules directly within a parent module like this:</p><a id="pro_id00006"/><pre class="programlisting">module OuterModule
  module NestedModule =
    do ()</pre><p><a id="iddle1193" class="indexterm"/><a id="iddle1375" class="indexterm"/><a id="iddle1653" class="indexterm"/><a id="iddle1687" class="indexterm"/>When you want to use both a namespace and a top-level module, F# provides a convenient syntactic shortcut that combines them into a single declaration. To take advantage of this, simply include the fully qualified name before the module name, as shown here:</p><a id="pro_id00007"/><pre class="programlisting">module TheBookOfFSharp.Chapter1.QualifiedModule</pre><p>In the preceding snippet, we declare a module named <code class="literal">QualifiedModule</code> within the <code class="literal">TheBookOfFSharp.Chapter1</code> namespace.</p><p>As a final note, you can import module members through the <code class="literal">open</code> keyword as though they belong to a namespace. For instance, to import any types defined in <code class="literal">QualifiedModule</code>, we could write:</p><a id="pro_id00008"/><pre class="programlisting">open TheBookOfFSharp.Chapter1.QualifiedModule</pre><p>To simplify this process for commonly used modules, you can decorate the module with the <code class="literal">AutoOpen</code> attribute like this:</p><a id="pro_id00009"/><pre class="programlisting">[&lt;AutoOpen&gt;]
module TheBookOfFSharp.Chapter1.QualifiedModule</pre><p>By applying this attribute to a module, whenever you explicitly open the namespace containing the module, the module will also be opened.</p></div></div><div class="sect1" title="Expressions Are Everywhere"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="expressions_are_everywhere">Expressions Are Everywhere</h2></div></div></div><p>One of F#’s distinguishing characteristics is that it is an <span class="emphasis"><em>expression-based</em></span> language; that is, nearly everything that’s evaluated returns a result. As you learn F#, you’ll quickly discover that writing applications and libraries is an exercise in combining expressions to produce results. This is a stark contrast to languages like C#, where typically only methods (and operators) return a result. In F#, seemingly familiar constructs like <code class="literal">if...else</code> gain new life because, like all expressions, the <code class="literal">if...else</code> expression returns a result. Consider the following snippet, which uses C#’s <code class="literal">if...else</code> statement to print a string indicating whether a number is even or odd:</p><a id="pro_id00010"/><pre class="programlisting">// C#
var testNumber = 10;
string evenOrOdd;

if (testNumber % 2 == 0)
      evenOrOdd = "even";
else
      evenOrOdd = "odd";

Console.WriteLine(evenOrOdd);</pre><p><a id="iddle1333" class="indexterm"/><a id="iddle1334" class="indexterm"/><a id="iddle1613" class="indexterm"/><a id="iddle1858" class="indexterm"/>Now, compare that with this functionally equivalent code in F#, which uses the <code class="literal">if...else</code> expression instead:</p><a id="pro_id00011"/><pre class="programlisting">// F#
let testNumber = 10
let evenOrOdd = if testNumber % 2 = 0 then "even" else "odd"
Console.WriteLine evenOrOdd</pre><p>The first thing you probably noticed is that the F# version is more concise. What might not be immediately apparent, though, is that the F# version eliminates the mutable state that’s present in the C# version (<code class="literal">evenOrOdd</code> is uninitialized before it is assigned a value). This isn’t necessarily an issue in this simple example because the mutable state is isolated, but in larger applications, mutable state contributes to a fragile and often unpredictable code base.</p><p>You might argue (correctly) that we could write the C# code using C#’s conditional operator instead of the <code class="literal">if...else</code> statement to achieve the same effect as the F# code. But the main point of this example is that even seemingly familiar constructs return values in F#.</p></div><div class="sect1" title="Application Entry Point"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="application_entry_point">Application Entry Point</h2></div></div></div><p>In an F# application, the initializations defined in the last file of the project are used as the application’s entry point by default. For more control over how your application starts, you can define a <code class="literal">let</code> bound function as the application’s entry point by decorating it with the <code class="literal">EntryPoint</code> attribute. This allows you to use an arbitrary function for what would be the <code class="literal">Main</code> method or procedure in a C# or Visual Basic application, respectively. Accordingly, the decorated function must accept a string array and return an integer to be valid. Such a function would typically follow this pattern:</p><a id="pro_id00012"/><pre class="programlisting"><span class="strong"><strong>[&lt;EntryPoint&gt;]</strong></span>
let main argv =
  // initialization code
  0</pre></div><div class="sect1" title="Implicit Return Values"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="implicit_return_values">Implicit Return Values</h2></div></div></div><p>Because F# is a language steeped in expressions, the F# compiler can make more assumptions about your code. Because all expressions return a value and all functions are expressions, it is implied that all functions will return a value. Therefore, the compiler can assume that the last expression evaluated within a function is the function’s return value; you don’t need to explicitly state it as such with a keyword like <code class="literal">return</code>.</p><p>As an example, consider the <code class="literal">main</code> function from the previous section. In that function, <code class="literal">0</code> is implicitly returned because it’s the final expression evaluated in the function. Similarly, consider this function, which simply adds two integers:</p><a id="pro_id00013"/><pre class="programlisting">let add x y = x + y</pre><p>Here, the <code class="literal">add</code> function accepts two parameters, <code class="literal">x</code> and <code class="literal">y</code>, and contains only a single expression: an addition operation. Because the addition operation is the last expression evaluated when <code class="literal">add</code> is invoked, <code class="literal">add</code> implicitly returns the result of that operation.</p></div><div class="sect1" title="Your First F# Program"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="your_first_fhash_program">Your First F# Program</h2></div></div></div><p>Now that you’ve learned how to structure an F# project, it’s time to see some “real” F# code that goes beyond basic syntax. Although the instant gratification of a traditional “Hello world”–type application is a nice confidence booster when you’re starting out with a new language, I’ve decided to forego that approach in favor of an example that both is useful and provides a nice sampling of many of F#’s capabilities: a Reverse Polish Notation (RPN) calculator.</p><p>RPN is a postfix notation for mathematical expressions; that is, it’s a manner of expressing computations where each operator immediately follows its operands. For example, to express computing the sum of 1 and 2, we’d normally write <code class="literal">1 + 2</code>; when using RPN, however, we’d write <code class="literal">1 2 +</code>.</p><p>You typically implement RPN calculators by iterating over a sequence of numbers and operators. Each item is inspected and numbers are pushed onto a stack, whereas operators pop the appropriate number of operands from the stack, evaluate, and push the result back onto the stack. At the end of the process, the sole item remaining in the stack should be the expression’s result. <a class="xref" href="ch01.html#application_of_reverse_polish_notation" title="Figure 1-3. Application of Reverse Polish Notation">Figure 1-3</a> roughly illustrates how this process looks when applied to the expression <code class="literal">4 2 5 * +</code>.</p><div class="figure"><a id="application_of_reverse_polish_notation"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00005"/><img src="httpatomoreillycomsourcenostarchimages1981202.png" alt="Application of Reverse Polish Notation"/></div></div><div class="figure-title">Figure 1-3. Application of Reverse Polish Notation</div></div><p>Working from left to right, you can see how items are added to and removed from the stack, ultimately producing <code class="literal">14</code> as the result. As you’re about to see, though, implementing a basic RPN calculator in F# takes only a few lines of code and doesn’t even require managing a mutable stack!</p><p><a id="iddle1071" class="indexterm"/><a id="iddle1765" class="indexterm"/>If you’d like to follow along with this example in Visual Studio, create a new project using the F# Application template. When you’re ready, replace the text editor’s contents with the following code (note that F# is case sensitive):</p><a id="pro_id00014"/><pre class="programlisting">module TheBookOfFSharp.RpnCalculator

open System

let evalRpnExpr (s : string) =
  let solve items current =
    match (current, items) with
    | "+", y::x::t -&gt; (x + y)::t
    | "-", y::x::t -&gt; (x - y)::t
    | "*", y::x::t -&gt; (x * y)::t
    | "/", y::x::t -&gt; (x / y)::t
    | _ -&gt; (float current)::items
  (s.Split(' ') |&gt; Seq.fold solve []).Head

[&lt;EntryPoint&gt;]
let main argv =
  [ "4 2 5 * + 1 3 2 * + /"
    "5 4 6 + /"
    "10 4 3 + 2 * -"
    "2 3 +"
    "90 34 12 33 55 66 + * - + -"
    "90 3 -" ]
  |&gt; List.map (fun expr -&gt; expr, evalRpnExpr expr)
  |&gt; List.iter (fun (expr, result) -&gt; printfn "(%s) = %A" expr result)
  Console.ReadLine() |&gt; ignore
  0</pre><p>When you’ve finished entering the RPN calculator code, press F5 and observe the output. You should see the results depicted in <a class="xref" href="ch01.html#reverse_polish_notation_calculator_resul" title="Figure 1-4. Reverse Polish Notation calculator results">Figure 1-4</a>.</p><div class="figure"><a id="reverse_polish_notation_calculator_resul"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00006"/><img src="httpatomoreillycomsourcenostarchimages1981204.png.jpg" alt="Reverse Polish Notation calculator results"/></div></div><div class="figure-title">Figure 1-4. Reverse Polish Notation calculator results</div></div><p>Don’t be discouraged if the RPN calculator code doesn’t make much sense right now; that’s the point! For now it’s enough to recognize that the entire RPN calculation is contained within the <code class="literal">evalRpnExpr</code> function. I like starting with this example because it not only shows some idiomatic F# code, but it also demonstrates a number of important concepts, such as default immutability, functions as data, pattern matching, recursion, library functions, partial application, F# lists, and pipelining. These concepts work together to create highly expressive and predictable code. Throughout this book, you’ll explore each of these concepts and many more in detail. As you progress through the book, I encourage you to revisit this example periodically to see just how much functionality is contained within such a small program.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id00001">Summary</h2></div></div></div><p>Despite a reputation as a niche language, F# is an expressive, functional-first, multiparadigm language rooted in ML and useful for most modern software development activities. As you’ll see in the coming chapters, writing F# effectively is about learning how to combine the types, functions, and values you’ll define in namespaces and modules into expressions. That said, traditional .NET developers will have to adjust to some of the language’s nuances like top-down evaluation, whitespace significance, and implicit returns. Once you get over the initial learning curve, however, you’ll see how F#’s simple yet expressive syntax will enable you to solve complex problems while producing code that is more stable and predictable.</p></div></section></body></html>