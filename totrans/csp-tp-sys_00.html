<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="int" epub:type="introduction" role="doc-introduction">
<header>
<h1 class="FMH" id="int"><span aria-label=" Page xix. " epub:type="pagebreak" id="pg_xix" role="doc-pagebreak"/><samp class="SANS_Dogma_OT_Bold_B_11">INTRODUCTION</samp></h1>
</header>
<figure class="opener"><img alt="" class="opener" height="191" src="../images/opener-img.png" width="191"/>
</figure>
<p class="COS">According to the C# Language Specification, “C# is intended to be a simple, modern, general-purpose, object-oriented programming language.” C# may look simple on the surface, but it has hidden depths even in its most fundamental features. The type system is a central element of C# and is the foundation upon which all C# programs are built. This has been true from the earliest versions of C#, and will continue to be relevant as the language evolves. <i>The C# Type System</i> isn’t a gallery of the latest language features, and we won’t delve into every detail of the latest edition, because C# is constantly advancing; instead we’ll focus on the language’s rich support for creating your own types and examine how best to <span aria-label=" Page xx. " epub:type="pagebreak" id="pg_xx" role="doc-pagebreak"/>employ the type system to improve your designs and write clearer, simpler, more efficient programs.</p>
<p class="TX">Many languages allow users to define their own types, but C# is different in that it makes a clear distinction between classes, which are reference types, and value types. <i>Classes</i> are the default choice for implementing a design in C# and the general-purpose mechanism for custom types, as they support all the object-oriented features that C# has to offer. In contrast, <i>value types</i> are much more specialized, which is why they’re often misunderstood and dismissed as an advanced feature that’s irrelevant for most applications. It’s true that value types aren’t suitable for many custom types in an application, and they may not be necessary in every design, but they have several advantages that are frequently underappreciated.</p>
<p class="TX">Using typical real-world examples, this book will walk you through defining and implementing value types effectively and efficiently so that they work successfully with all the other types in your applications. Specifically, we’ll explore the following:</p>
<ul class="BL">
<li class="BL">Why C# distinguishes between value types and reference types, and what that means in practice</li>
<li class="BL">What makes value types different, both syntactically and semantically, from other types</li>
<li class="BL">How incorporating value types can improve your code and help you express designs more clearly</li>
<li class="BL">Which characteristics of value types, beyond those defined by the language, are most important to their role in an application</li>
<li class="BL">Where you can use value types to enhance an application’s performance</li>
</ul>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h-1"/><samp class="SANS_Futura_Std_Bold_B_11">Who Should Read This Book</samp></h2>
<p class="TNI">If you’ve learned the basics of C# and wish to expand your understanding of the language to become a better programmer, this book is for you. Nothing in the chapters that follow is particularly advanced, but the content is intended to help you understand some of the underlying features, principles, and concepts of C# programming. My hope is that this book will allow you to move beyond simply writing runnable programs using correct C# syntax to writing idiomatic and efficient C# programs that your colleagues can easily understand.</p>
<p class="TX">To follow the examples, you’ll need experience with creating your own classes; familiarity with constructors, methods, and properties; and a basic understanding of how virtual methods can be overridden by derived classes. Some practice with exceptions, both in employing them and handling them to manage errors, will also be useful. An appreciation of the mechanics of defining generic types and methods, although not essential, will also be helpful; in particular, some experience using the generic collection classes provided by the Standard Library will give <span aria-label=" Page xxi. " epub:type="pagebreak" id="pg_xxi" role="doc-pagebreak"/>you insight into how generics work in C#. <i>The C# Type System</i> isn’t a beginner’s guide and doesn’t discuss how to compile and run your code, but you aren’t expected to know the dark corners of the language. That said, I hope that some parts of this book will amuse and perhaps even surprise more advanced users.</p>
<p class="TX">When features are fundamental, we sometimes become complacent about them. With that in mind, many chapters in this book cover details that experienced C# programmers might consider introductory. Those topics are intended to set the scene for some less widely understood concepts that depend on them.</p>
<p class="TX">If you have more than just a passing familiarity with C# code or experience with another object-based language such as Java or C<span class="symbol">++</span>, I hope that the examples and commentary here will help you better understand C# syntax and semantics and better appreciate why C# is the language it has become.</p>
<p class="TX">The book doesn’t cover all aspects of C# programming; the focus is intentionally on the interactions between value types and reference types. In that discussion, we’ll venture into C# generics, collections, Language Integrated Query (LINQ), and threading, but only superficially. We <i>won’t</i> be discussing <samp class="SANS_TheSansMonoCd_W5Regular_11">unsafe</samp> code or C# pointers. (Actually, there’s one mention of <i>managed</i> pointers. Otherwise, we’re solid.)</p>
<p class="TX">We won’t cover how to create web services, interact with databases, or write distributed programs intended for deployment as cloud or microservice applications, but the techniques and underlying principles of C# presented will help improve the applications you create for those domains and others.</p>
<p class="TX">If you’ve asked or been asked when a value type would be a better choice than a reference type in a C# program and found yourself unable to give a satisfactory response, you should find this book useful.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h-2"/><samp class="SANS_Futura_Std_Bold_B_11">Organization and Requirements</samp></h2>
<p class="TNI">The book is organized into eight chapters, each presenting a different aspect of value types in action:</p>
<p class="RunInPara"><b><a href="chapter1.xhtml">Chapter 1</a>: Making the Most of the Type System</b>   Examines the importance of user-defined value types and how introducing even simple types in an application can make the code easier to read and understand. It covers the importance of accurate names, the benefits of encapsulating application-specific behavior, and ways to make your own types intuitive and simple to use.</p>
<p class="RunInPara"><b><a href="chapter2.xhtml">Chapter 2</a>: Value and Reference Types</b>   Looks at why C# has both reference types and value types and compares them in detail. We consider how different kinds of objects use memory, what that means for their lifetimes, and how the differences between types affect construction, equality, and copying. We review nullable value types and compare them with the newer nullable reference type feature.</p>
<p class="RunInPara"><span aria-label=" Page xxii. " epub:type="pagebreak" id="pg_xxii" role="doc-pagebreak"/><b><a href="chapter3.xhtml">Chapter 3</a>: Reference and Value Parameters</b>   Examines the four types of method parameters and how to pass arguments to them, as well as how passing behavior differs between value types and reference types. We distinguish between passing a reference type variable and passing an argument <i>by reference</i> and explore how that relates to mutability and side effects. We also consider how to pass value type instances by immutable reference to optimize performance.</p>
<p class="RunInPara"><b><a href="chapter4.xhtml">Chapter 4</a>: Implicit and Explicit Copying</b>   Discusses how values are copied in a program and how the differences in copy behavior between value types and reference types can have unintended consequences in our code. In particular, we distinguish between variables and values and explore how making value types immutable can help prevent some common copying-related errors. We also look at ways to mitigate the potential inefficiencies that copying can introduce.</p>
<p class="RunInPara"><b><a href="chapter5.xhtml">Chapter 5</a>: Types of Equality</b>   Covers the various ways that values can be compared for equality and what happens under the hood during these comparisons. Implementing value-based equality comparisons is a common source of error, so we’ll walk through how to do so safely and correctly, as well as how to take advantage of facilities provided by the compiler for this purpose.</p>
<p class="RunInPara"><b><a href="chapter6.xhtml">Chapter 6</a>: The Nature of Values</b>   Outlines the characteristics and roles of different types in an application and how a value type’s role is more than just being a convenient way to store data. We examine what <i>value semantics</i> means and what makes an object a good candidate to be a value type. We also consider the importance of ordering objects and distinguish between equality and equivalence.</p>
<p class="RunInPara"><b><a href="chapter7.xhtml">Chapter 7</a>: Value Types and Polymorphism</b>   Explores why inheritance isn’t an appropriate form of polymorphism for value types, working through an example to demonstrate the problems that can arise. We look in detail at the difference between subclassing and subtyping, and we discuss how other kinds of polymorphism are more suitable for working with values.</p>
<p class="RunInPara"><b><a href="chapter8.xhtml">Chapter 8</a>: Performance and Efficiency</b>   Considers how different types affect an application’s performance and how to precisely measure performance to make evidence-based decisions. The chapter covers how accepting default behavior can adversely affect our code’s performance, while also addressing common myths regarding compiler-generated code and efficiency.</p>
<p class="TX">Many of the code snippets use a simple test to demonstrate a behavior or language characteristic. The examples use NUnit fluent-style assertions, which provide a commonly understood and compact way to represent the concepts being discussed. Several other unit-testing frameworks are available for C#, and you should be able to easily translate the NUnit test snippets to other styles.</p>
<p class="TX">It won’t take long for you to discover that the code examples, on their own, usually don’t compile in the form in which they’re presented. For the <span aria-label=" Page xxiii. " epub:type="pagebreak" id="pg_xxiii" role="doc-pagebreak"/>sake of brevity, some details, such as importing namespaces or defining <samp class="SANS_TheSansMonoCd_W5Regular_11">Main</samp>, are omitted. The code examples are intended to focus your attention on a concept rather than to show a legal program.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h2 class="H1" id="sec3"><span id="h-3"/><samp class="SANS_Futura_Std_Bold_B_11">Modern Features</samp></h2>
<p class="TNI">In recent years the language designers have put a great deal of effort into enhancing C#’s support for creating efficient, high-performance applications. While the central ideas of the language have remained unchanged, new facilities have been added, particularly with respect to simple value types, and new features incorporated to enable C# programmers to take advantage of value types to maximize application performance. This book explores some of those features but in the context of <i>classic</i> C# programming, not just high-performance computing. Some of those features can make your programs clearer for human readers, as well as more efficient at run time.</p>
<p class="TX">Most of the code examples throughout the book demonstrate concepts that have been widely used in C# over several versions, some using features that have been part of C# since version 1.0. For more recently introduced features, the minimum compiler version is indicated.</p>
<p class="TX">Using value types effectively in your applications requires some additional thought on your part, not just about how those types are designed, but also about how they’re used. <i>The C# Type System</i> describes in detail how value types behave in a wide variety of scenarios, allowing you to write C# in a modern, idiomatic, and effective manner. Having a deeper understanding of how value types fit into the C# type system will help you enrich your designs and write better programs.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h2 class="H1" id="sec4"><span id="h-4"/><samp class="SANS_Futura_Std_Bold_B_11">Why Value Types?</samp></h2>
<p class="TNI">Whereas the <i>class</i> is the poster child of object-oriented programming and design, the humble <i>value type</i> is often overlooked. However, judicious use of value types can bring many benefits, including better performance. Value type instances aren’t individually allocated on the heap or subject to garbage collection. Allocating objects on the heap carries a small performance penalty since the garbage collector must inspect every object in memory, whether or not it’s in use, to ascertain whether it’s eligible for collection.</p>
<p class="TX">Reducing the heap-based memory of a program is likely to mean the garbage collector runs less often and has to do less work when it does run. Reducing heap memory pressure is likely to improve the speed of the code you write. Although the garbage-collection algorithm has been carefully tuned to minimize its impact on a running program, avoiding garbage collection altogether is even more efficient.</p>
<p class="TX">Making all your objects into value types almost certainly won’t magically improve your programs’ performance, but there’s much more to the value type story than simply performance, just as there’s more to source code than <span aria-label=" Page xxiv. " epub:type="pagebreak" id="pg_xxiv" role="doc-pagebreak"/>a program, and more to programming than typing. Understanding value semantics can help you determine where you might employ value types in a design and how to implement them to best achieve your goal. Equally importantly, understanding value semantics will help you determine where a value type would <i>not</i> be appropriate.</p>
<p class="TX">Over the course of this book, you’ll learn what value semantics means for C# programs, and how to use value types successfully and efficiently. Along the way, we’ll look in detail at both how and why value types behave as they do. First, though, we’ll explore using simple value types to make our code easier for humans to understand. Let’s get started.</p>
</section>
</section>
</div></body></html>