- en: '**5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTML INJECTION AND CONTENT SPOOFING**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Hypertext Markup Language (HTML) injection* and *content spoofing* are attacks
    that allow a malicious user to inject content into a site’s web pages. The attacker
    can inject HTML elements of their own design, most commonly as a `<form>` tag
    that mimics a legitimate login screen in order to trick targets into submitting
    sensitive information to a malicious site. Because these types of attacks rely
    on fooling targets (a practice sometimes called *social engineering*), bug bounty
    programs view content spoofing and HTML injection as less severe than other vulnerabilities
    covered in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: An HTML injection vulnerability occurs when a website allows an attacker to
    submit HTML tags, typically via some form input or URL parameters, which are then
    rendered directly on the web page. This is similar to cross-site scripting attacks,
    except those injections allow for the execution of malicious JavaScript, which
    I’ll discuss in [Chapter 7](ch07.xhtml#ch07).
  prefs: []
  type: TYPE_NORMAL
- en: HTML injection is sometimes referred to as *virtual defacement*. That’s because
    developers use the HTML language to define the structure of a web page. So if
    an attacker can inject HTML and the site renders it, the attacker can change what
    a page looks like. This technique of tricking users into submitting sensitive
    information through a fake form is referred to as *phishing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if a page renders content that you can control, you might be able
    to add a `<form>` tag to the page asking the user to reenter their username and
    password, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When a user submits this form, the information is sent to an attacker’s website
    *http://<attacker>.com/capture.php* via an `action` attribute ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Content spoofing is very similar to HTML injection except attackers can only
    inject plaintext, not HTML tags. This limitation is typically caused by sites
    either escaping any included HTML or HTML tags being stripped when the server
    sends the HTTP response. Although attackers can’t format the web page with content
    spoofing, they might be able to insert text, such as a message, that looks as
    though it’s legitimate site content. Such messages can fool targets into performing
    an action but rely heavily on social engineering. The following examples demonstrate
    how you can explore these vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '**Coinbase Comment Injection Through Character Encoding**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Low'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *https://coinbase.com/apps/*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/104543/](https://hackerone.com/reports/104543/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** December 10, 2015'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $200'
  prefs: []
  type: TYPE_NORMAL
- en: Some websites will filter out HTML tags to defend against HTML injection; however,
    you can sometimes get around this by understanding how character HTML entities
    work. For this vulnerability, the reporter identified that Coinbase was decoding
    HTML entities when rendering text in its user reviews. In HTML, some characters
    are *reserved* because they have special uses (such as angle brackets, `< >`,
    which start and end HTML tags), whereas *unreserved characters* are normal characters
    with no special meaning (such as letters of the alphabet). Reserved characters
    should be rendered using their HTML entity name; for example, the `>` character
    should be rendered by sites as `&gt;` to avoid injection vulnerabilities. But
    even an unreserved character can be rendered with its HTML encoded number; for
    example, the letter `a` can be rendered as `&#97;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this bug, the bug reporter first entered plain HTML into a text entry field
    made for user reviews:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Coinbase would filter the HTML and render this as plaintext, so the submitted
    text would post as a normal review. It would look exactly as entered with the
    HTML tags removed. However, if the user submitted text as HTML encoded values,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Coinbase wouldn’t filter out the tags and would decode this string into the
    HTML, which would result in the website rendering the `<h1>` tags in the submitted
    review:'
  prefs: []
  type: TYPE_NORMAL
- en: '**This is a test**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using HTML-encoded values, the reporting hacker demonstrated how he could make
    Coinbase render username and password fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This resulted in HTML that would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This rendered as text input forms that looked like a place to enter a username
    and password login. A malicious hacker could have used the vulnerability to trick
    users into submitting an actual form to a malicious website where they could capture
    credentials. However, this vulnerability depends on users being fooled into believing
    the login is real and submitting their information, which isn’t guaranteed. Consequently,
    Coinbase rewarded a lower payout compared to a vulnerability that wouldn’t have
    required user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you’re testing a site, check how it handles different types of input, including
    plaintext and encoded text. Be on the lookout for sites that accept URI-encoded
    values, like `%2F`, and render their decoded values, which in this case would
    be `/`.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find a great Swiss army knife that includes encoding tools at *[https://gchq.github.io/CyberChef/](https://gchq.github.io/CyberChef/)*.
    Check it out and try the different types of encoding it supports.
  prefs: []
  type: TYPE_NORMAL
- en: '**HackerOne Unintended HTML Inclusion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Medium'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *https://hackerone.com/reports/<report_id>/*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/110578/](https://hackerone.com/reports/110578/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** January 13, 2016'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $500'
  prefs: []
  type: TYPE_NORMAL
- en: This example and the following section require an understanding of Markdown,
    hanging single quotes, React, and the Document Object Model (DOM), so I’ll cover
    these topics first and then how they resulted in two related bugs.
  prefs: []
  type: TYPE_NORMAL
- en: '*Markdown* is a type of markup language that uses a specific syntax to generate
    HTML. For example, Markdown will accept and parse plaintext preceded by a hash
    symbol (`#`) to return HTML that is formatted into header tags. The markup `#
    Some Content` will generate the HTML `<h1>Some Content</h1>`. Developers often
    use Markdown in website editors because it’s an easy language to work with. In
    addition, on sites that allow users to submit input, developers don’t need to
    worry about malformed HTML because the editor handles generating the HTML for
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The bugs I’ll discuss here used Markdown syntax to generate an `<a>` anchor
    tag with a `title` attribute. Normally, the syntax for this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The text between the brackets becomes the displayed text, and the URL to link
    to is included in parentheses along with a `title` attribute, which is contained
    in a set of double quotes. This syntax creates the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In January 2016, the bug hunter Inti De Ceukelaire noticed that HackerOne’s
    Markdown editor was misconfigured; as a result, an attacker could inject a single
    hanging quote into Markdown syntax that would be included in the generated HTML
    anywhere HackerOne used the Markdown editor. Bug bounty program administration
    pages as well as reports were vulnerable. This was significant: if an attacker
    was able to find a second vulnerability in an administration page and inject a
    second hanging quote at the beginning of the page in a `<meta>` tag (either by
    injecting the `<meta>` tag or finding an injection in a `<meta>` tag), they could
    leverage browser HTML parsing to exfiltrate page content. The reason is that `<meta>`
    tags tell browsers to refresh pages via the URL defined in the `content` attribute
    of the tag. When rendering the page, browsers will perform a `GET` request to
    the identified URL. The content in the page can be sent as a parameter of the
    `GET` request, which the attacker can use to extract the target’s data. Here is
    what a malicious `<meta>` tag with an injected single quote might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `0` defines how long the browser waits before making the HTTP request to
    the URL. In this case, the browser would immediately make an HTTP request to *https://evil.com/log.php?text=*.
    The HTTP request would include all content between the single quote beginning
    with the `content` attribute and the single quote injected by the attacker using
    the Markdown parser on the web page. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The contents of the page from the first single quote after the `content` attribute
    at ➊ to the attacker-inputted single quote at ➋ would be sent to the attacker
    as part of the URL’s `text` parameter. Also included would be the sensitive cross-site
    request forgery (CSRF) token from the hidden input field.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, the risk of HTML injection wouldn’t have been an issue for HackerOne
    because it uses the React JavaScript framework to render its HTML. React is a
    Facebook library developed to dynamically update web page content without having
    to reload the entire page. Another benefit of using React is that the framework
    will escape all HTML unless the JavaScript function `dangerouslySetInnerHTML`
    is used to directly update the DOM and render the HTML (the *DOM* is an API for
    HTML and XML documents that allows developers to modify the structure, style,
    and content of a web page via JavaScript). As it turns out, HackerOne was using
    `dangerouslySetInnerHTML` because it trusted the HTML it was receiving from its
    servers; therefore, it was injecting HTML directly into the DOM without escaping
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Although De Ceukelaire couldn’t exploit the vulnerability, he did identify pages
    where he was able to inject a single quote after HackerOne was rendering a CSRF
    token. So conceptually, if HackerOne made a future code change that allowed an
    attacker to inject another single quote in a `<meta>` tag on the same page, the
    attacker could exfiltrate a target’s CSRF token and perform a CSRF attack. HackerOne
    agreed with the potential risk, resolved the report, and awarded De Ceukelaire
    $500.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Understanding the nuances of how browsers render HTML and respond to certain
    HTML tags opens up a vast attack surface. Although not all programs will accept
    reports about potential theoretical attacks, this knowledge will help you find
    other vulnerabilities. FileDescriptor has a great explanation about the `<meta>`
    refresh exploit at *[https://blog.innerht.ml/csp-2015/#contentexfiltration](https://blog.innerht.ml/csp-2015/#contentexfiltration)*,
    which I highly recommend you check out.
  prefs: []
  type: TYPE_NORMAL
- en: '**HackerOne Unintended HTML Include Fix Bypass**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Medium'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *https://hackerone.com/reports/<report_id>/*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/112935/](https://hackerone.com/reports/112935/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** January 26, 2016'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $500'
  prefs: []
  type: TYPE_NORMAL
- en: 'When an organization creates a fix and resolves a report, the feature won’t
    always end up bug-free. After reading De Ceukelaire’s report, I decided to test
    HackerOne’s fix to see how its Markdown editor was rendering unexpected input.
    To do so, I submitted the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Recall that in order to create an anchor tag with Markdown, you normally provide
    a URL and a `title` attribute surrounded by double quotes in parentheses. To parse
    the `title` attribute, Markdown needs to keep track of the opening double quote,
    the content following it, and the closing quote.
  prefs: []
  type: TYPE_NORMAL
- en: 'I was curious as to whether I could confuse Markdown with additional random
    double quotes and attributes and whether it would mistakenly begin to track those
    as well. This is the reason I added `ismap=` (a valid HTML attribute), `yyy=`
    (an invalid HTML attribute), and extra double quotes. After submitting this input,
    the Markdown editor parsed the code into the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the fix from De Ceukelaire’s report resulted in an unintended bug
    that caused the Markdown parser to generate arbitrary HTML. Although I couldn’t
    immediately exploit this bug, the inclusion of unescaped HTML was enough of a
    proof of concept for HackerOne to revert its previous fix and correct the issue
    using a different solution. The fact that someone could inject arbitrary HTML
    tags could lead to vulnerabilities, so HackerOne awarded me a $500 bounty.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just because code is updated doesn’t mean all vulnerabilities are fixed. Be
    sure to test changes—and be persistent. When a fix is deployed, it means there
    is new code, which could contain bugs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Within Security Content Spoofing**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Low'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[https://withinsecurity.com/wp-login.php](https://withinsecurity.com/wp-login.php)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/111094/](https://hackerone.com/reports/111094/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** January 16, 2016'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $250'
  prefs: []
  type: TYPE_NORMAL
- en: '*Within Security*, a HackerOne site meant to share security news, was built
    on WordPress and included a standard WordPress login path at the page *[withinsecurity.com/wp-login.php](http://withinsecurity.com/wp-login.php)*.
    A hacker noticed that during the login process, if an error occurred, *Within
    Security* would render an `access_denied` error message, which also corresponded
    to the `error` parameter in the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Noticing this behavior, the hacker tried modifying the `error` parameter. As
    a result, the site rendered values passed to the parameter as part of the error
    message presented to users, and even URI-encoded characters were decoded. Here
    is the modified URL the hacker used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The parameter rendered as an error message that displayed above the WordPress
    login fields. The message directed the user to contact an attacker-owned phone
    number and email.
  prefs: []
  type: TYPE_NORMAL
- en: The key here was noticing that the parameter in the URL was being rendered on
    the page. Simply testing whether you could change the `access_denied` parameter
    revealed this vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Keep an eye on URL parameters that are passed and rendered as site content.
    They may present opportunities for text injection vulnerabilities that attackers
    can use to phish targets. Controllable URL parameters rendered on a website sometimes
    result in cross-site scripting attacks, which I’ll cover in [Chapter 7](ch07.xhtml#ch07).
    Other times this behavior allows only less impactful content spoofing and HTML
    injection attacks. It’s important to keep in mind that although this report paid
    $250, it was the minimum bounty for *Within Security*. Not all programs value
    or pay for HTML injection and content spoofing reports because, similar to social
    engineering, they depend on targets being fooled by the injected text.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/05fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: The attacker was able to inject this “warning” into the WordPress
    admin page.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTML injection and content spoofing allow a hacker to input information and
    have an HTML page reflect that information back to a target. Attackers can use
    these attacks to phish users and trick them into visiting or submitting sensitive
    information to malicious websites.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering these types of vulnerabilities is not only about submitting plain
    HTML but also about exploring how a site might render your inputted text. Hackers
    should be on the lookout for opportunities to manipulate URL parameters that are
    directly rendered on a site.
  prefs: []
  type: TYPE_NORMAL
