<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="115" id="Page_115"/>6</span><br/>
<span class="ChapterTitle">Linear Memory</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="190" height="190"/>
</figure>
<p class="ChapterIntro">In this chapter, we’ll examine what linear memory is, how to use it to share data between JavaScript and WebAssembly code, and how to create it from within JavaScript. We’ll also update linear memory from WebAssembly and then use those updates from within the JavaScript code.</p>
<p>One common task in computer games is collision detection, detecting and appropriately reacting to two objects touching. The number of computations required grows exponentially as you add objects. Collision detection is a great candidate for building in WebAssembly. In this chapter, we’ll create a list of circles defined randomly in the JavaScript, and then add that circle data to the WebAssembly linear memory. Then we’ll use that data to determine whether any of those circles collide.</p>
<p>WebAssembly shines best when you can pass it tons of data that requires significant processing and let it run. A WebAssembly module can perform math faster than JavaScript. However, each interaction between JavaScript <span epub:type="pagebreak" title="116" id="Page_116"/>and the WebAssembly module has an associated cost. You can use linear memory to load significant amounts of data in JavaScript for processing within a WebAssembly module.</p>
<h2 id="h1-501737c06-0001">Linear Memory in WebAssembly</h2>
<p class="BodyFirst">Linear memory acts as one giant array of data that can be shared between WebAssembly and JavaScript. If you’re familiar with low-level programming, linear memory is similar to heap memory in native applications. If you’re familiar with JavaScript, think of it as one giant <code>ArrayBuffer</code> object. Languages like C and C++ create local variables by allocating memory on the computer’s stack. The stack-allocated local variables are released from memory as soon as the function finishes executing. This efficient process means that allocating and deallocating data on the stack is as simple as incrementing and decrementing a stack pointer. Your application simply increments the stack pointer, and voilà, you have a new allocated variable, as depicted in <a href="#figure6-1" id="figureanchor6-1">Figure 6-1</a>.</p>
<figure>
<img src="Images/f06001.png" alt="f06001" width="675" height="234"/>
<figcaption><p><a id="figure6-1">Figure 6-1</a>: The stack pointer</p></figcaption></figure>
<p>The stack works great for local variables. However, one limitation in WAT is that local variables that use the stack can only be one of four types, all of which are numeric. Sometimes, you might require more sophisticated data structures, such as strings, structures, arrays, and objects.</p>
<p>Allocation commands, like <code>malloc</code> in C and <code>new</code><code> </code>in C++ and JavaScript, allocate onto the heap, and the memory management libraries included with those languages must look for a free section of memory on the heap large enough to hold the required block of memory. Over time that might result in memory fragmentation, where allocated memory segments are separated by unallocated memory, as illustrated in <a href="#figure6-2" id="figureanchor6-2">Figure 6-2</a>.</p>
<p>WebAssembly linear memory is allocated in large chunks called <em>pages</em>, which, once allocated, cannot be deallocated. WebAssembly memory is also a bit more like assembly language memory management: once you’ve allocated your chosen number of pages to your WebAssembly module, you, as the programmer, must keep track of what you’re using memory for and where it is. In the next few sections, we’ll look more closely at how to use linear memory by exploring memory pages.</p>
<span epub:type="pagebreak" title="117" id="Page_117"/><figure>
<img src="Images/f06002.png" alt="f06002" width="675" height="438"/>
<figcaption><p><a id="figure6-2">Figure 6-2</a>: Linear memory passed data from JavaScript and WebAssembly</p></figcaption></figure>
<h3 id="h2-501737c06-0001">Pages</h3>
<p class="BodyFirst">Pages are the smallest chunk of data that can be allocated for a WebAssembly module. At the time of this writing, all WebAssembly pages are 64KB in size. In the current version, WebAssembly 1.0, you cannot change that size, although the WebAssembly Community Group has an ongoing proposal to make the page size variable based on the application’s needs. The maximum number of pages that an application can allocate at the time of this writing is 32,767, an overall maximum memory size of 2GB. This maximum memory allocation is plenty for web apps but is limiting for server-based applications. Increasing the page size could allow server apps to increase the maximum amount of linear memory they can allocate. For embedded WebAssembly applications, 64KB can be too large; for example, the ATmega328 only has 32KB of Flash memory. WebAssembly updates might remove this limitation by the time you read this.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The WebAssembly Community Group is currently working to increase the maximum number of pages to 65,535, which would allocate 4GB of memory. It’s likely that by the time this book is published, the maximum size of linear memory will be 4GB rather than 2GB.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>You can create the number of pages your app will use either inside the WebAssembly module or in the embedding environment for import.</p>
<h4 id="h3-501737c06-0001">Creating Pages in Your Code</h4>
<p class="BodyFirst">To allocate a page of linear memory in WAT, use a simple <code>(memory</code><code>)</code> expression, like the one in <a href="#listing6-1" id="listinganchor6-1">Listing 6-1</a>.</p>
<span epub:type="pagebreak" title="118" id="Page_118"/>
<pre><code>(memory 1)</code></pre>
<p class="CodeListingCaption"><a id="listing6-1">Listing 6-1</a>: Declaring a page of memory in WAT</p>
<p>Passing <code>1</code> into the memory expression instructs the module to set aside one page of linear memory. To allocate the maximum amount of memory you can currently allocate to a WebAssembly module at runtime, use the expression in <a href="#listing6-2" id="listinganchor6-2">Listing 6-2</a>.</p>
<pre><code>(memory 32_767)</code></pre>
<p class="CodeListingCaption"><a id="listing6-2">Listing 6-2</a>: Declaring the maximum number of memory pages</p>
<p>Attempting to pass <code>32_767</code> into the <code>(memory</code><code>)</code> expression results in a compile error. Memory created using the <code>(memory</code><code>)</code> expression isn’t accessible to the embedding environment unless you include an <code>(export</code><code>)</code> expression.</p>
<h4 id="h3-501737c06-0002">Creating Memory in the Embedded Environment</h4>
<p class="BodyFirst">The other way to create the linear memory is inside the embedding environment. If the embedding environment is JavaScript, the code to create that memory is <code>new WebAssembly.Memory</code> as in <a href="#listing6-3" id="listinganchor6-3">Listing 6-3</a>.</p>
<pre><code>const memory = new WebAssembly.Memory({initial: 1});</code></pre>
<p class="CodeListingCaption"><a id="listing6-3">Listing 6-3</a>: Creating a WebAssembly <code>Memory</code> object in JavaScript</p>
<p>You could then access it from the WebAssembly module using the <code>(import</code><code>)</code> expression in <a href="#listing6-4" id="listinganchor6-4">Listing 6-4</a>.</p>
<pre><code>(import "js" "mem" (memory 1))</code></pre>
<p class="CodeListingCaption"><a id="listing6-4">Listing 6-4</a>: Importing a page of memory allocated in JavaScript</p>
<p>Using <code>import</code> requires you to create a <code>Memory</code> object in JavaScript using the <code>WebAssembly.Memory</code> class, and then to pass it into the WebAssembly module when you initialize it through an <code>import</code> object. Create a file called <em>pointer.js</em> and add the JavaScript code in <a href="#listing6-5" id="listinganchor6-5">Listing 6-5</a>, which creates a WebAssembly <code>Memory</code> object.</p>
<p class="CodeLabel"><b>pointer.js</b></p>
<pre><code>const fs = require('fs');
const bytes = fs.readFileSync(__dirname + '/pointer.wasm');
const memory = new WebAssembly.Memory({<span class="CodeAnnotationCode" aria-label="annotation1">1</span>initial: 1, <span class="CodeAnnotationCode" aria-label="annotation2">2</span>maximum: 4});

const importObject = {
  env: {
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> mem: memory,
  }
};

( async () =&gt; {
<span epub:type="pagebreak" title="119" id="Page_119"/>  let obj = await WebAssembly.instantiate(new Uint8Array(bytes),
                                        <span class="CodeAnnotationCode" aria-label="annotation4">4</span> importObject);
  let pointer_value = obj.instance.exports.get_ptr();
  console.log(`pointer_value=${pointer_value}`);
})();</code></pre>
<p class="CodeListingCaption"><a id="listing6-5">Listing 6-5</a>: Initialize WebAssembly linear memory and pass it to the WebAssembly module.</p>
<p>On creation, this code passes in an object with two initialization values. The <code>initial</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> argument is required and by passing it <code>1</code>, we instruct the JavaScript engine to set aside one page of linear memory (64KB). The second value <code>maximum</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> is optional and lets the browser know that we’re likely to want to increase the size of the linear memory later, and we probably won’t want to grow memory to more than four pages. You can increase the size of linear memory by calling the <code>memory.grow</code> method. You don’t need to set a maximum value to grow your memory, but passing in a maximum value tells the browser to set aside more memory than the initial value because a call to grow is likely. If you attempt to grow your linear memory to more than the maximum value you pass in, the application will throw an error. After creating the memory object, we pass it to the WebAssembly module through the <code>importObject</code> in <code>env.mem</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>. The JavaScript passes <code>importObject</code> into the module on instantiation <span class="CodeAnnotation" aria-label="annotation4">4</span>.</p>
<h3 id="h2-501737c06-0002">Pointers</h3>
<p class="BodyFirst">A <em>pointer</em> is a variable that references a location in memory. Pointers have a variety of applications in computer science, but in this context, we’ll use them to point to data structures in linear memory. <a href="#figure6-3" id="figureanchor6-3">Figure 6-3</a> shows a pointer pointing to memory location 5, which has a value of 99.</p>
<figure>
<img src="Images/f06003.png" alt="f06003" width="675" height="306"/>
<figcaption><p><a id="figure6-3">Figure 6-3</a>: Pointer to the fifth byte in memory</p></figcaption></figure>
<p> WebAssembly pointers behave differently from those you might be familiar with in C or C++ that can point to local variables or variables on the heap. The C code in <a href="#listing6-6" id="listinganchor6-6">Listing 6-6</a> creates a pointer called <code>ptr</code> that points to the address of a local variable <code>x</code>.</p>
<span epub:type="pagebreak" title="120" id="Page_120"/>
<pre><code>int x = 25;
int *ptr = &amp;x;</code></pre>
<p class="CodeListingCaption"><a id="listing6-6">Listing 6-6</a>: Example of setting pointer values in C</p>
<p>The pointer <code>ptr</code> is set to the address of the <code>x</code> variable, which is a local variable that has an address on the stack. WebAssembly doesn’t have a distinct pointer type, such as C’s <code>int*</code> integer pointer type. WebAssembly’s linear memory is a large array of data. When you represent a pointer in WAT, you must put the data in the linear memory; the pointer is then an <code>i32</code> index to that data. The variable <code>x</code> in <a href="#listing6-6">Listing 6-6</a> receives an address in linear memory when compiling the program to WebAssembly. Unlike in C, WAT cannot create a pointer to a local or global variable. To get the C kind of pointer functionality in WebAssembly, you can set a global variable to a specific location in linear memory and use that global variable to set or retrieve the value stored in WebAssembly linear memory, as shown in <a href="#listing6-7" id="listinganchor6-7">Listing 6-7</a>.</p>
<p class="CodeLabel"><b>pointer.wat</b></p>
<pre><code>(module
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (memory 1)
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (global $pointer i32 (i32.const 128))
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> (func $init
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> (i32.store
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> (global.get $pointer)  <span class="LiteralGray">;; store at address $pointer</span>
  <span class="CodeAnnotationCode" aria-label="annotation6">6</span> (i32.const 99)        <span class="LiteralGray"> ;; value stored</span>
    )
  )
<span class="CodeAnnotationCode" aria-label="annotation7">7</span> (func (export "get_ptr") (result i32)
<span class="CodeAnnotationCode" aria-label="annotation8">8</span> (i32.load (global.get $pointer)) <span class="LiteralGray">;; return value at location $pointer</span>
  )
<span class="CodeAnnotationCode" aria-label="annotation9">9</span> (start $init)
)</code></pre>
<p class="CodeListingCaption"><a id="listing6-7">Listing 6-7</a>: Simulating pointers in WAT</p>
<p>This module creates a single page of linear memory <span class="CodeAnnotation" aria-label="annotation1">1</span> and a global <code>$pointer</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> that points to the memory location <code>128</code>. We create a function <code>$init</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> that sets the value of the memory location pointed to by <code>$pointer</code> to <code>99</code> using the <code>(i32.store</code><code>)</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> expression. The first parameter passed to <code>(i32.store</code><code>)</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> is the location in memory where the value is stored, and the second parameter <span class="CodeAnnotation" aria-label="annotation6">6</span> is the value you want to store. To retrieve the value from this pointer location, you use the <code>i32.load</code> <span class="CodeAnnotation" aria-label="annotation8">8</span> expression passing in the memory location you want to retrieve. We create a function <code>"get_ptr"</code> <span class="CodeAnnotation" aria-label="annotation7">7</span> to retrieve this value. Then the <code>(start</code><code> $init)</code> <span class="CodeAnnotation" aria-label="annotation9">9</span> statement calls <code>$init</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> as a module initialization function. The <code>start</code> statement declares a given function to be the initialization function for the module. This function will automatically execute when the module is instantiated. </p>
<p>Once you’ve compiled the <em>pointer.wasm</em> file and executed it with <code>node</code>, you should see the following output:</p>
<pre><code>pointer_value=99</code></pre>
<h2 id="h1-501737c06-0002"><span epub:type="pagebreak" title="121" id="Page_121"/>JavaScript Memory Object</h2>
<p class="BodyFirst">Now that we have some idea of how linear memory works, we’ll create a WebAssembly memory object, initialize the data from within a WebAssembly module, and then access that data from JavaScript. When you’re working with linear memory, there’s a good chance that you’ll want to access it from WebAssembly and the embedding environment. In this case, the embedding environment is JavaScript, so we’ll define the linear memory there to have access to it before the WebAssembly module is initialized. This WAT module is similar to <a href="#listing6-7">Listing 6-7</a> but will be importing linear memory from JavaScript.</p>
<h3 id="h2-501737c06-0003">Creating the WebAssembly Memory Object</h3>
<p class="BodyFirst">Create a file named <em>store_data.wat</em> and add the code in <a href="#listing6-8" id="listinganchor6-8">Listing 6-8</a> to it.</p>
<p class="CodeLabel"><b>store_data.wat</b></p>
<pre><code>(module
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (import "env" "mem" (memory 1))
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (global $data_addr (import "env" "data_addr") i32)
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> (global $data_count (import "env" "data_count") i32)

<span class="CodeAnnotationCode" aria-label="annotation4">4</span> (func $store_data (param $index i32) (param $value i32)
    (i32.store
     (i32.add
      (global.get $data_addr) <span class="LiteralGray">;; add $data_addr to the $index*4 (i32=4 bytes)</span>
      (i32.mul (i32.const 4) (local.get $index)) <span class="LiteralGray">;; multiply $index by 4</span>
     )
     (local.get $value) <span class="LiteralGray">;; value stored</span>
    )
  )


<span class="CodeAnnotationCode" aria-label="annotation5">5</span> (func $init
    (local $index i32)

  <span class="CodeAnnotationCode" aria-label="annotation6">6</span> (loop $data_loop
      local.get $index

      local.get $index
      i32.const 5
      i32.mul      

    <span class="CodeAnnotationCode" aria-label="annotation7">7</span> call $store_data <span class="LiteralGray">;; called with parameters $index and $index * 5</span>

      local.get $index
      i32.const 1
      i32.add          <span class="LiteralGray">;; $index++</span>

      local.tee $index
    <span class="CodeAnnotationCode" aria-label="annotation8">8</span> global.get $data_count
      i32.lt_u
      br_if $data_loop
    )

<span epub:type="pagebreak" title="122" id="Page_122"/>  <span class="CodeAnnotationCode" aria-label="annotation9">9</span> (call $store_data (i32.const 0) (i32.const 1))

  )

<span class="CodeAnnotationCode" aria-label="annotationa">a</span> (start $init)
)</code></pre>
<p class="CodeListingCaption"><a id="listing6-8">Listing 6-8</a>: Creating a linear memory object in WebAssembly</p>
<p>The module in <a href="#listing6-8">Listing 6-8</a> imports its linear memory <span class="CodeAnnotation" aria-label="annotation1">1</span> from the JavaScript embedding environment, which we’ll define in a moment. From JavaScript it imports the address of the data we’ll load in the global variable <code>$data_addr</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>. It also imports <code>$data_count</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, which contains the number of <code>i32</code> integers we’ll store when the module initializes. The <code>$store_data</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> function takes in an index and a value, and sets the data location (<code>$data_addr</code> + <code>$index</code> * 4) to <code>$value</code> (we multiply by 4 because the <code>i32</code> type is four bytes). Using <code>$data_addr</code>, an imported global variable, allows the JavaScript to decide the location in the memory module to store these values.</p>
<p>As in <a href="#listing6-6">Listing 6-6</a>, the <code>$init</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> function executes on module initialization because of the <code>(start</code><code> $init)</code> <span class="CodeAnnotation" aria-label="annotationa">a</span> statement. Unlike the prior <code>$init</code> function, this function initializes the data in a loop <span class="CodeAnnotation" aria-label="annotation6">6</span>. A loop can be a useful way to initialize data in certain parts of linear memory to the same value or some value that might be calculated in the loop. This loop sets several 32-bit integers based on the <code>$data_count</code> <span class="CodeAnnotation" aria-label="annotation8">8</span> global variable that the module imports from JavaScript. When this <code>loop</code> calls <code>$store_data</code> <span class="CodeAnnotation" aria-label="annotation7">7</span>, it passes in an index that is the number of times the <code>loop</code> has completed and a value that is <code>$index</code> * 5. I chose the value <code>$index</code> * 5 so when we display the data, you’ll see the data values counting up by 5.</p>
<p>After the <code>loop</code>, we add one more call to <code>$store_data</code> <span class="CodeAnnotation" aria-label="annotation9">9</span> to set the first data value in the array to <code>1</code>. If we don’t initialize it with a value, the memory buffer begins with all data set to <code>0</code>. Because the <code>loop</code> sets the first data value to <code>0</code>, it wouldn’t be clear where the set data begins when we look at the data in JavaScript. Setting it to <code>1</code> makes the beginning of the data set more apparent when we display it from the JavaScript in the next section.</p>
<p>After you’ve finished creating the <em>store_data.wat</em> file, compile it using <code>wat2wasm</code> to generate a <em>store_data.wasm</em> file. </p>
<h3 id="h2-501737c06-0004">Logging to the Console with Colors</h3>
<p class="BodyFirst">Before writing the <em>store_data.js </em>portion, let’s briefly look at a node module called <em>colors</em> that allows you to log lines to the console using your choice of colors. In later sections, we’ll use this package to make it easier to see different results in our output data. To install colors, use the <code>npm</code> command, as shown in <a href="#listing6-9" id="listinganchor6-9">Listing 6-9</a>.</p>
<pre><code>npm i colors</code></pre>
<p class="CodeListingCaption"><a id="listing6-9">Listing 6-9</a>: Using <code>npm</code> to install the colors module</p>
<p><span epub:type="pagebreak" title="123" id="Page_123"/>Now we can require our app to use it, which allows us to modify the string type in JavaScript to include attributes that set colors, bold text, and several other features. Create a file named <em>colors.js</em> and add the code in <a href="#listing6-10" id="listinganchor6-10">Listing 6-10</a>.</p>
<p class="CodeLabel"><b>colors.js</b></p>
<pre><code>const colors = require('colors');

console.log('RED COLOR'.red.bold);  <span class="LiteralGray">// logs bold red text</span>
console.log('blue color'.blue);<span class="LiteralGray">     // logs blue text</span></code></pre>
<p class="CodeListingCaption"><a id="listing6-10">Listing 6-10</a>: Log to console in color</p>
<p>When you run <em>colors.js</em> using <code>node</code>, as shown in <a href="#listing6-11" id="listinganchor6-11">Listing 6-11</a>, the logged output will appear with the colors we specified.</p>
<pre><code>node colors.js</code></pre>
<p class="CodeListingCaption"><a id="listing6-11">Listing 6-11</a>: Run <em>color.js</em> and log with colors to the console.</p>
<p>You should now see the output in <a href="#listing6-12" id="listinganchor6-12">Listing 6-12</a> with the first line in red and the second in blue.</p>
<pre><code><b>RED COLOR</b>
blue color</code></pre>
<p class="CodeListingCaption"><a id="listing6-12">Listing 6-12</a>: The colors module applied</p>
<p>We’ll use the colors module in future apps to improve the output’s appearance in the console. In the book, the red output will be black but in bold. Let’s move forward by creating a <em>store_data.js</em> file in the next section.</p>
<h3 id="h2-501737c06-0005">Creating the JavaScript in store_data.js</h3>
<p class="BodyFirst">Now we need a <em>store_data.js</em> JavaScript file to execute the <em>store_data.wasm </em>module. We create that JavaScript file using <a href="#listing6-13" id="listinganchor6-13">Listing 6-13</a>.</p>
<p class="CodeLabel"><b>store_data.js (part 1 of 2)</b></p>
<pre><code>  const colors = require('colors'); <span class="LiteralGray">// allow console logs with color</span>
  const fs = require('fs');
  const bytes = fs.readFileSync(__dirname + '/store_data.wasm');

<span class="LiteralGray">// allocate a 64K block of memory</span>
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> const memory = new WebAssembly.Memory({initial: 1 });
<span class="LiteralGray">// 32-bit data view of the memory buffer</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> const mem_i32 = new Uint32Array(memory.buffer);

<span class="CodeAnnotationCode" aria-label="annotation3">3</span> const data_addr = 32; <span class="LiteralGray">// the address of the first byte of our data</span>

<span class="LiteralGray">// The 32-bit index of the beginning of our data</span>
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> const data_i32_index = data_addr / 4;
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> const data_count = 16; <span class="LiteralGray">// the number of 32-bit integers to set</span>

<span class="CodeAnnotationCode" aria-label="annotation6">6</span> const importObject = { <span class="LiteralGray">// The objects WASM imports from JavaScript</span>
    env: {
      mem: memory,
<span epub:type="pagebreak" title="124" id="Page_124"/>      data_addr: data_addr,
      data_count: data_count
    }
  };
...</code></pre>
<p class="CodeListingCaption"><a id="listing6-13">Listing 6-13</a>: A WebAssembly linear memory buffer and <code>i</code><code>mport</code><code>Object</code> with global imports</p>
<p>We create three constants, the first of which creates a new <code>WebAssembly.Memory</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> object that we’ll use when we initialize the WebAssembly module. The constant <code>mem_i32</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> provides a 32-bit integer view into the memory buffer. It’s crucial to keep in mind that this isn’t a copy of the data in the buffer but instead is a specific way to view that buffer as an array of 32-bit unsigned integers. When we change the values in the memory buffer from inside the WebAssembly module, we can use this <code>mem_i32</code> view to look at the changes to those values. The constant <code>data_addr</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> is the byte location of the data we set in the WebAssembly module. This location is the <em>byte index m</em>,<em> </em>not the 32-bit integer array number.</p>
<p>Because a 32-bit integer is four bytes, we need a starting data index that is the <code>data_addr</code> constant divided by 4. We set that value in <code>data_i32_index</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>. Then we have the number of 32-bit integer values set in the module defined by <code>const data_count</code> <span class="CodeAnnotation" aria-label="annotation5">5</span>. The last <code>const</code> in this section of code is the <code>importObject</code> <span class="CodeAnnotation" aria-label="annotation6">6</span>. The <code>importObject</code> contains three imported data objects for the WebAssembly module.</p>
<p>The final portion of the JavaScript in <a href="#listing6-14" id="listinganchor6-14">Listing 6-14</a> uses an IIFE to instantiate the WebAssembly module and output the values in linear memory to the console.</p>
<p class="CodeLabel"><b>store_data.js (part 2 of 2)</b></p>
<pre><code>...
( async () =&gt; {
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> let obj = await WebAssembly.instantiate(new Uint8Array(bytes),
                                          importObject );

<span class="CodeAnnotationCode" aria-label="annotation2">2</span> for( let i = 0; i &lt; data_i32_index + data_count + 4; i++ ) {
    let data = mem_i32[i];
    if (data !== 0) {
    <span class="CodeAnnotationCode" aria-label="annotation3">3</span> console.log(`data[${i}]=${data}`.red.bold);
    }
    else {
    <span class="CodeAnnotationCode" aria-label="annotation4">4</span> console.log(`data[${i}]=${data}`);
    }
 
  }
})();</code></pre>
<p class="CodeListingCaption"><a id="listing6-14">Listing 6-14</a>: Outputting the data values inside linear memory after the IIFE instantiates the WebAssembly module</p>
<p>This final portion of the JavaScript instantiates the <em>store_data.wasm</em> <span class="CodeAnnotation" aria-label="annotation1">1</span> module, passing in the <code>importObject</code> we created in <a href="#listing6-13">Listing 6-13</a>. After initializing the WebAssembly module, the data in the memory buffer will change because the <code>$init</code> function within the WAT code runs during the <span epub:type="pagebreak" title="125" id="Page_125"/>initialization. We then loop <span class="CodeAnnotation" aria-label="annotation2">2</span> over the <code>mem_i32</code> array starting at the first address in the memory buffer and displaying four integers after the data is set. This loop displays the value in <code>mem_i32</code> in the browser by logging it to the console in red <span class="CodeAnnotation" aria-label="annotation3">3</span> if the value isn’t <code>0</code> and in the default console color <span class="CodeAnnotation" aria-label="annotation4">4</span> if it is.</p>
<p>Use <code>node</code> to run <em>store_data.js</em>; you should see the output in <a href="#listing6-15" id="listinganchor6-15">Listing 6-15</a> logged to the console.</p>
<pre><code>data[0]=0
data[1]=0
data[2]=0
data[3]=0
data[4]=0
data[5]=0
data[6]=0
data[7]=0
<b>data[8]=1</b>
<b>data[9]=5</b>
<b>data[10]=10</b>
<b>data[11]=15</b>
<b>data[12]=20</b>
<b>data[13]=25</b>
<b>data[14]=30</b>
<b>data[15]=35</b>
<b>data[16]=40</b>
<b>data[17]=45</b>
<b>data[18]=50</b>
<b>data[19]=55</b>
<b>data[20]=60</b>
<b>data[21]=65</b>
<b>data[22]=70</b>
<b>data[23]=75</b>
data[24]=0
data[25]=0
data[26]=0
data[27]=0</code></pre>
<p class="CodeListingCaption"><a id="listing6-15">Listing 6-15</a>: Data output</p>
<p>The first data element that was set by the WebAssembly module is <code>data[8]</code>, which is where the red output begins. The value <code>8</code> is the value in the <code>data_i32_index</code> constant, which is one fourth the value in <code>data_addr</code>. There are 16 integers set in the code, because we’ve set the <code>const data_count</code> to a value of <code>16</code>. In the data in <a href="#listing6-15">Listing 6-15</a>, all data elements that are <code>0</code> weren’t set in the WebAssembly module. You can see that the first eight numbers as well as the last four are <code>0</code>, and they all appear in the default console color.</p>
<h2 id="h1-501737c06-0003">Collision Detection</h2>
<p class="BodyFirst">Previously, we created the memory buffer object inside JavaScript, but we initialized it from the WebAssembly module. This time, we’ll initialize the memory buffer inside JavaScript with values generated in the JavaScript. We’ll also create more interesting data structures that will handle our <span epub:type="pagebreak" title="126" id="Page_126"/>collision detection data. When modifying the data in the WebAssembly memory buffer, we want to group the data into structures to make it manageable. We’ll create a set of random circle definitions in JavaScript, defined with an x- and y-coordinate, and a radius. The JavaScript will then set those values in the WebAssembly memory buffer. To organize objects in linear memory, you use a combination of a base address, a stride, and an offset.</p>
<h3 id="h2-501737c06-0006">Base Address, Stride, and Offset</h3>
<p class="BodyFirst">When working with linear memory inside our WebAssembly module, we need to understand our data structures at a low level. In our JavaScript, we work with the data in linear memory as a JavaScript typed array. Inside the WebAssembly module, linear memory is more like a memory heap, or a large array of bytes. When we want to create an array of data structures, we need to know the <em>starting address</em> (base address) of that array, the <em>stride</em><em> </em>(distance in bytes between each structure), and the <em>offset</em><em> </em>of any structure’s attributes (how far into a structure can we find our attribute). </p>
<p>We’ll work with a structure in our linear memory that has four attributes: an x- and y-coordinate, a radius, and a hit flag. We’ll set the stride as a <em>unit stride</em>, as shown in <a href="#figure6-4" id="figureanchor6-4">Figure 6-4</a>, which means that the distance between each structure in our array matches the size of the structure. </p>
<figure>
<img src="Images/f06004.png" alt="f06004" width="675" height="206"/>
<figcaption><p><a id="figure6-4">Figure 6-4</a>: Setting a unit stride</p></figcaption></figure>
<p>To get the memory address of the specific data structure we want to access, we multiply the structure’s index by the stride and add the base address. The <em>base address</em> is the starting address of our array of structures.</p>
<p>As an alternative to unit stride, you could pad your stride. If a developer decided to align their structure addresses to power-of-two, they might add unused bytes (called <em>padding</em>) to the end of their structures. For example, if we wanted our structure to align with 16-byte addresses, we could add four bytes of padding to the end of our structure, giving it a stride of 16, as shown in <a href="#figure6-5" id="figureanchor6-5">Figure 6-5</a>.</p>
<p>However, we have no need for padding in this example. Each attribute of our data structure has an offset. For example, say we have two 32-bit integer attributes, <code>x</code> and <code>y</code>, that are the first two attributes in the data structure, respectively. The first attribute, <code>x</code>, is at the beginning of the data structure and so has an offset of <code>0</code>. Because the <code>x</code> attribute is a 32-bit integer, it takes up the first four bytes of the data structure. That means the <code>y</code> offset begins <span epub:type="pagebreak" title="127" id="Page_127"/>on the fifth byte with an offset of <code>4</code> (bytes 0, 1, 2, and 3). Using a base address (the starting address of our data structure), stride, and offset for each attribute, we can construct an array of data structures.</p>
<figure>
<img src="Images/f06005.png" alt="f06005" width="664" height="203"/>
<figcaption><p><a id="figure6-5">Figure 6-5</a>: Padding a stride</p></figcaption></figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The syntax for <code>load</code> and <code>store</code>has a modifier called <code>offset</code>, which allows you to offset the address parameter by some constant integer value. This isn’t quite the same as the attribute offset we refer to here.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-501737c06-0007">Loading Data Structures from JavaScript</h3>
<p class="BodyFirst">Let’s start by creating the JavaScript file for a new example app named <em>data_structures.js</em>. In this app, we’ll create data structures that represent circles in memory. Later, we’ll perform a collision detection check between those circles. Add the code in <a href="#listing6-16" id="listinganchor6-16">Listing 6-16</a> to <em>data_structures.js</em>.</p>
<p class="CodeLabel"><b>data_structures.js  (part 1 of 3)</b></p>
<pre><code>const colors = require('colors'); <span class="LiteralGray">// allow console logs with color</span>
const fs = require('fs');
const bytes = fs.readFileSync(__dirname + '/data_structures.wasm');
<span class="LiteralGray">  // allocate a 64K block of memory</span>
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> const memory = new WebAssembly.Memory({initial: 1});

<span class="LiteralGray">  // 32-bit view of memory buffer</span>
  const mem_i32 = new Uint32Array(memory.buffer);

  const obj_base_addr = 0; <span class="LiteralGray">// the address of the first byte of our data</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> const obj_count = 32;    <span class="LiteralGray">// the number of structures</span>
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> const obj_stride = 16;   <span class="LiteralGray">// 16-byte stride</span>

  <span class="LiteralGray">// structure attribute offsets</span>
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> const x_offset = 0;
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> const y_offset = 4;
  const radius_offset = 8;			
  const collision_offset = 12;			

  <span class="LiteralGray">// 32-bit integer indexes</span>
  const obj_i32_base_index = obj_base_addr / 4; <span class="LiteralGray">// 32-bit data index</span>
  const obj_i32_stride = obj_stride / 4;        <span class="LiteralGray">// 32-bit stride</span>

<span class="LiteralGray">  // offsets in the 32-bit integer array</span>
<span class="CodeAnnotationCode" aria-label="annotation6">6</span> const x_offset_i32 = x_offset / 4;
  const y_offset_i32 = y_offset / 4;
<span epub:type="pagebreak" title="128" id="Page_128"/>  const radius_offset_i32 = radius_offset / 4;
  const collision_offset_i32 = collision_offset / 4;

<span class="CodeAnnotationCode" aria-label="annotation7">7</span> const importObject = { <span class="LiteralGray">// The objects WASM imports from JavaScript</span>
    env: {
      mem: memory,
      obj_base_addr: obj_base_addr,
      obj_count: obj_count,
      obj_stride: obj_stride,
      x_offset: x_offset,			
      y_offset: y_offset,
      radius_offset: radius_offset,
      collision_offset: collision_offset,
    }
  };
...</code></pre>
<p class="CodeListingCaption"><a id="listing6-16">Listing 6-16</a>: Setting the constants to define the structure of the collision detection program</p>
<p>First, we create a series of <code>const</code> values used to create structures in the WebAssembly memory buffer. As in <a href="#listing6-16">Listing 6-16</a>, this code creates a single 64KB page of WebAssembly memory <span class="CodeAnnotation" aria-label="annotation1">1</span> and a 32-bit unsigned integer view into that data. The <code>obj_base_addr</code> constant sets the base address of the data structures to <code>0</code>, the very first byte of memory in the page.</p>
<p>We set the <code>obj_count</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> <code>const</code> to the number of structures set in this code. The <code>obj_stride</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> constant holds the number of bytes in the structure. We set this to <code>16</code> because we have four 32-bit integers in this structure, which is 16 bytes. The next group of <code>const</code> declarations contains the attribute offsets.</p>
<p>The <code>x_offset</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> is the offset of <code>x</code> from the start of the structure, so is the number of bytes into each structure in the <code>x</code> value location. The <code>y_offset</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> is the number of bytes into the structure in the <code>y</code> value location, and has a value of <code>4</code> because the <code>x</code> value is a 32-bit integer, pushing the <code>y </code>value into the fifth byte in the structure. We then set the offset for the <code>radius</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> attribute and <code>collision</code> <span class="CodeAnnotation" aria-label="annotation7">7</span> attribute.</p>
<p>We calculate the integer index and stride by dividing the byte address by 4 and the stride by 4. The reason is that the byte address and stride are the number of bytes, and the integer index is 32-bit integers (4 bytes). We also need to find the indexes into the integer array, which we calculate by dividing the byte indexes by 4 <span class="CodeAnnotation" aria-label="annotation6">6</span> as well. The <code>importObject</code> <span class="CodeAnnotation" aria-label="annotation7">7</span> has been modified to include the new <code>const</code> values we’ve added.</p>
<p>With the constants defined, we’ll create a series of randomly sized circles for the program to use. As mentioned earlier, a circle is defined by x- and y-coordinates and a radius. We’ll randomly define the circles’ x- and y-coordinates with values from 0 to 99 and a radius that is between 1 and 11. The code in <a href="#listing6-17" id="listinganchor6-17">Listing 6-17</a> loops over the memory object, setting values in the memory buffer to random values for each of the structures.</p>
<p class="CodeLabel"><b>data_structures.js (part 2 of 3)</b></p>
<pre><code>...
  for( let i = 0; i &lt; obj_count; i++ ) {
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> let index = obj_i32_stride * i + obj_i32_base_index;

<span epub:type="pagebreak" title="129" id="Page_129"/>  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> let x = Math.floor( Math.random() * 100 );
    let y = Math.floor( Math.random() * 100 );
    let r = Math.ceil( Math.random() * 10 );

  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> mem_i32[index + x_offset_i32] = x;
    mem_i32[index + y_offset_i32] = y;
    mem_i32[index + radius_offset_i32] = r;
  }
...</code></pre>
<p class="CodeListingCaption"><a id="listing6-17">Listing 6-17</a>: Initializing the circles with random x- and y-coordinates and a radius</p>
<p>The loop gets an index for each of the structures <span class="CodeAnnotation" aria-label="annotation1">1</span> for the collision detection circles. The <code>x</code>, <code>y</code>, and radius <code>r</code> values <span class="CodeAnnotation" aria-label="annotation2">2</span> are set to random values. Those random values are then used to set the memory values <span class="CodeAnnotation" aria-label="annotation3">3</span> based on the object index and the attribute offsets.</p>
<h3 id="h2-501737c06-0008">Displaying the Results</h3>
<p class="BodyFirst">Next, we need to instantiate the <em>data_structures.wasm</em> module, which runs the <code>$init</code> function, which runs collision detection between each of the circles we randomly generated in this data test. <a href="#listing6-18" id="listinganchor6-18">Listing 6-18</a> shows the code added to <em>data_structures.js</em>.</p>
<p class="CodeLabel"><b>data_structures.js (part 3 of 3)</b></p>
<pre><code>...
( async () =&gt; {
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> let obj = await WebAssembly.instantiate(new Uint8Array(bytes),
                                          importObject );

<span class="CodeAnnotationCode" aria-label="annotation2">2</span> for( let i = 0; i &lt; obj_count; i++ ) {
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> let index = obj_i32_stride * i + obj_i32_base_index;

  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> let x = mem_i32[index+x_offset_i32].toString().padStart(2, ' ');
    let y = mem_i32[index+y_offset_i32].toString().padStart(2, ' ');
    let r = mem_i32[index+radius_offset_i32].toString()
                   .padStart(2,' ');
    let i_str = i.toString().padStart(2, '0');
    let c = !!mem_i32[index + collision_offset_i32];

    if (c) {
    <span class="CodeAnnotationCode" aria-label="annotation5">5</span> console.log(`obj[${i_str}] x=${x} y=${y} r=${r} collision=${c}`
          .red.bold);
    }
    else {
    <span class="CodeAnnotationCode" aria-label="annotation6">6</span> console.log(`obj[${i_str}] x=${x} y=${y} r=${r} collision=${c}`
          .green);
    }
  }
})();</code></pre>
<p class="CodeListingCaption"><a id="listing6-18">Listing 6-18</a>: After WebAssembly runs, the code loops over linear memory looking for circle collisions.</p>
<p><span epub:type="pagebreak" title="130" id="Page_130"/>This IIFE function instantiates the WebAssembly module <span class="CodeAnnotation" aria-label="annotation1">1</span> and then loops over the objects in the <code>mem_i32 </code>array <span class="CodeAnnotation" aria-label="annotation2">2</span>. This loop gets an index for the structure using the stride, the index, and the base index value <span class="CodeAnnotation" aria-label="annotation3">3</span>. We then use this calculated index to get the <code>x</code>, <code>y</code>, radius, and collision values from the <code>mem_i32</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> array. These values are logged to the console in red <span class="CodeAnnotation" aria-label="annotation5">5</span> if there was a collision or green <span class="CodeAnnotation" aria-label="annotation6">6</span> if there wasn’t.</p>
<p>We now have JavaScript that loads a series of structures that define circles with x- and y-coordinates randomly chosen with values between 0 and 100. Each circle also has a radius with a value randomly chosen between 1 and 10. The WebAssembly memory buffer is initialized with these values. The JavaScript will set the appropriate offset and stride values in the <code>importObject</code>. In addition to the <code>x</code>, <code>y</code>, and radius in each structure, there are four bytes set aside to hold a collision value. This value is <code>1</code> if the circle collides with another circle and <code>0</code> if it doesn’t. The WebAssembly module’s initialization <code>(start</code><code>)</code> function calculates the collisions. Once the WebAssembly module initializes, the console displays the results of this collision check. At this point, we’ve not yet defined the WebAssembly module. Let’s do that next.</p>
<h3 id="h2-501737c06-0009">Collision Detection Function</h3>
<p class="BodyFirst">In other sections, we’ve defined the WAT code before the JavaScript. In this section, the JavaScript initializes the values that define the circles in the array of structures. For that reason, we’ll be writing the JavaScript first in this section. When you’re doing collision detection between two circles, you use the Pythagorean theorem to determine whether the distance between the centers of your circles is greater than the sum of the circles’ radii. The WAT code in this section loops over each of the circles we’ve defined in the WebAssembly memory, comparing it to every other circle to see whether they collide. The details of collision detection aren’t the focus of this section, so we won’t go into it too deeply. It’s simply a means to demonstrate how you can separate your data into structures and use that data to perform computations with your WAT code.</p>
<p>The first portion of the WAT code defines the imports from the JavaScript. <a href="#listing6-19" id="listinganchor6-19">Listing 6-19</a> shows the beginning of the WAT module.</p>
<p class="CodeLabel"><b>data_structures.wat (part 1 of 6)</b></p>
<pre><code>(module
  (import "env" "mem" (memory 1))           
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (global $obj_base_addr  (import "env" "obj_base_addr") i32)
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (global $obj_count    (import "env" "obj_count") i32)
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> (global $obj_stride   (import "env" "obj_stride") i32)
 
<span class="LiteralGray">  ;; attribute offset locations</span>
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> (global $x_offset     (import "env" "x_offset") i32)
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> (global $y_offset     (import "env" "y_offset") i32)
<span class="CodeAnnotationCode" aria-label="annotation6">6</span> (global $radius_offset  (import "env" "radius_offset") i32)
<span class="CodeAnnotationCode" aria-label="annotation7">7</span> (global $collision_offset (import "env" "collision_offset") i32)
...</code></pre>
<p class="CodeListingCaption"><a id="listing6-19">Listing 6-19</a>: Importing global variables that define the data structure</p>
<p><span epub:type="pagebreak" title="131" id="Page_131"/>The global variables passed into the WebAssembly module define the layout of the linear memory and the data structures within it. The <code>$obj_base_addr</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> global variable is the location in memory where the circle structures are defined. The <code>$obj_count</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> global variable is the number of circles defined in linear memory. The <code>$obj_stride</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> global variable is the number of bytes between each of the circle definitions. Then we import values for each of the attributes. The <code>$x_offset</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>, <code>$y_offset</code> <span class="CodeAnnotation" aria-label="annotation5">5</span>, <code>$radius_offset</code> <span class="CodeAnnotation" aria-label="annotation6">6</span>, and <code>$collision_offset</code> <span class="CodeAnnotation" aria-label="annotation7">7</span> are the number of bytes between the start of the object’s <code>x</code>, <code>y</code>, radius, and collision flag values. These must be set inside this module.</p>
<p>Next, we’ll define the <code>$collision_check</code> function. The details of how this function works are only valuable if you’re interested in how circle collision detection works. But as an overview, it uses the Pythagorean theorem to determine whether the distance between two circles is less than the sum of the circle’s radii. To briefly explain, let’s label the radius of the first circle R<sub>1</sub>, the radius of the second circle R<sub>2</sub>, and the distance between the circles D, as shown in <a href="#figure6-6" id="figureanchor6-6">Figure 6-6</a>. No collision occurs if R<sub>1</sub> + R<sub>2</sub> is less than D.</p>
<figure>
<img src="Images/f06007.png" alt="f06007" width="670" height="681"/>
<figcaption><p><a id="figure6-6">Figure 6-6</a>: There is no collision if R<sub>1</sub> + R<sub>2</sub> is less than the distance between the circles.</p></figcaption></figure>
<p><span epub:type="pagebreak" title="132" id="Page_132"/>If the distance is less than R<sub>1</sub> + R<sub>2</sub>, we have a collision, as shown in <a href="#figure6-7" id="figureanchor6-7">Figure 6-7</a>.</p>
<figure>
<img src="Images/f06008.png" alt="f06008" width="599" height="594"/>
<figcaption><p><a id="figure6-7">Figure 6-7</a>: R<sub>1</sub> + R<sub>2</sub> is greater than the distance between the circles.</p></figcaption></figure>
<p><a href="#listing6-20" id="listinganchor6-20">Listing 6-20</a> shows the code for the <code>$collision_check</code> function.</p>
<p class="CodeLabel"><b>data_structures.wat (part 2 of 6)</b></p>
<pre><code>...
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (func $collision_check
    (param $x1 i32) (param $y1 i32) (param $r1 i32)
    (param $x2 i32) (param $y2 i32) (param $r2 i32)
    (result i32)

    (local $x_diff_sq i32)
    (local $y_diff_sq i32)
    (local $r_sum_sq i32)

    local.get $x1
    local.get $x2
    i32.sub
    local.tee $x_diff_sq
    local.get $x_diff_sq
    i32.mul
      <span class="CodeAnnotationCode" aria-label="annotation2">2</span> local.set $x_diff_sq  <span class="LiteralGray">;; ($x1 - $x2) * ($x1 - $x2)</span>

    local.get $y1
<span epub:type="pagebreak" title="133" id="Page_133"/>    local.get $y2
    i32.sub
    local.tee $y_diff_sq
    local.get $y_diff_sq
    i32.mul
      <span class="CodeAnnotationCode" aria-label="annotation3">3</span> local.set $y_diff_sq  <span class="LiteralGray">;; ($y1 - $y2) * ($y1 - $y2)</span>

    local.get $r1
    local.get $r2
    i32.add
    local.tee $r_sum_sq
    local.get $r_sum_sq
    i32.mul
      <span class="CodeAnnotationCode" aria-label="annotation4">4</span> local.tee $r_sum_sq   <span class="LiteralGray">;; ($r1 + $r2) * ($r1 + $r2)</span>

    local.get $x_diff_sq
    local.get $y_diff_sq
      <span class="CodeAnnotationCode" aria-label="annotation5">5</span> i32.add  <span class="LiteralGray">;; pythagorean theorem A squared + B squared = C squared</span>
  
      <span class="CodeAnnotationCode" aria-label="annotation6">6</span> i32.gt_u <span class="LiteralGray">;; if distance is less than sum of the radii return true</span>
)
...</code></pre>
<p class="CodeListingCaption"><a id="listing6-20">Listing 6-20</a>: A WebAssembly collision detection function</p>
<p>This function takes in the <code>x</code>, <code>y</code>, and radius attributes of two circles <span class="CodeAnnotation" aria-label="annotation1">1</span> and then returns <code>1</code> if they overlap and <code>0</code> if they don’t. It first finds the <code>x</code> distance between the two circles by subtracting <code>$x2</code> from <code>$x1</code>. It then squares that value and stores it in <code>$x_diff_sq</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>; then it finds the <code>y</code> distance between the two circles by subtracting <code>$y2</code> from <code>$y1</code>. It squares the result of that subtraction and stores it in <code>$y_diff_sq</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>. What we’re building toward is the Pythagorean theorem A<sup>2</sup> + B<sup>2</sup> = C<sup>2 </sup><span class="CodeAnnotation" aria-label="annotation5">5</span>. In this scenario, <code>$x_diff_sq</code> is A<sup>2</sup>, and <code>$y_diff_sq</code> is B<sup>2</sup>. The sum of these two values is C<sup>2</sup>, which is compared with the sum of the radii squared <span class="CodeAnnotation" aria-label="annotation4">4</span>. If radius<sup>2</sup> is greater than C<sup>2</sup>, the circles overlap and the function returns <code>1</code>; otherwise, the function returns <code>0</code>. The function makes this decision using the <code>i32.gt_u</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> expression.</p>
<p>After the <code>$collision_check</code> function, we need a few helper functions. The <code>$get_attr</code> helper function takes an object base address parameter and an attribute offset parameter and returns the value in linear memory at that address location. <a href="#listing6-21" id="listinganchor6-21">Listing 6-21</a> shows that function.</p>
<p class="CodeLabel"><b>data_structures.wat (part 3 of 6)</b></p>
<pre><code>...
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (func $get_attr (param $obj_base i32) (param $attr_offset i32)
    (result i32)
    local.get $obj_base
    local.get $attr_offset
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> i32.add         <span class="LiteralGray">;; add attribute offset to base address</span>
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> i32.load        <span class="LiteralGray">;; load the address and return it</span>
  )
...</code></pre>
<p class="CodeListingCaption"><a id="listing6-21">Listing 6-21</a>: Retrieving an object attribute from linear memory</p>
<p><span epub:type="pagebreak" title="134" id="Page_134"/>In the function definition <span class="CodeAnnotation" aria-label="annotation1">1</span>, the <code>$obj_base</code> parameter is the base address for the object, and <code>$attr_offset</code> is the offset of the specific attribute we want to retrieve. The function adds those values together <span class="CodeAnnotation" aria-label="annotation2">2</span>. Then it loads the value from that address <span class="CodeAnnotation" aria-label="annotation3">3</span> to return it as a result.</p>
<p>The next helper function is <code>$set_collision</code>, which sets the collision flag for two of the circle objects to true. <a href="#listing6-22" id="listinganchor6-22">Listing 6-22</a> shows that function.</p>
<p class="CodeLabel"><b>data_structures.wat (part 4 of 6)</b></p>
<pre><code>...
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> (func $set_collision
    (param $obj_base_1 i32) (param $obj_base_2 i32)
    local.get $obj_base_1
    global.get $collision_offset
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> i32.add   <span class="LiteralGray">;; address = $obj_base_1 + $collision_offset</span>
    i32.const 1
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> i32.store <span class="LiteralGray">;; store 1 as true in the collision attribute for this object</span>

    local.get $obj_base_2
    global.get $collision_offset
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> i32.add   <span class="LiteralGray">;; address = $obj_base_2 + $collision_offset</span>
    i32.const 1
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> i32.store <span class="LiteralGray">;; store 1 as true in the collision attribute for this object</span>
  )
...</code></pre>
<p class="CodeListingCaption"><a id="listing6-22">Listing 6-22</a>: Set the collision attribute for a given object</p>
<p>This function takes in two object base parameters <span class="CodeAnnotation" aria-label="annotation1">1</span> to set the collision flags for those objects in memory. It does this by adding <code>$obj_base_1</code> to <code>$collision_offset</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> and then setting the value in linear memory at that location to <code>1</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>. It then adds <code>$obj_base_2</code> to <code>$collision_offset</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> and sets the value at that location to <code>1</code> <span class="CodeAnnotation" aria-label="annotation5">5</span>.</p>
<p>Now that we have the other functions defined, we can add the <code>$init</code> function to the WAT code, as shown in <a href="#listing6-23" id="listinganchor6-23">Listing 6-23</a>.</p>
<p class="CodeLabel"><b>data_structures.wat (part 5 of 6)</b></p>
<pre><code>...
(func $init
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (local $i i32)     <span class="LiteralGray">;; outer loop counter</span>
  (local $i_obj i32) <span class="LiteralGray">;; address of ith object</span>
  (local $xi i32)(local $yi i32)(local $ri i32) <span class="LiteralGray">;; x,y,r for object i</span>

<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (local $j i32)     <span class="LiteralGray">;; inner loop counter</span>
  (local $j_obj i32) <span class="LiteralGray">;; address of the jth object</span>
  (local $xj i32)(local $yj i32)(local $rj i32) <span class="LiteralGray">;; x,y,r for object j</span>

  (loop $outer_loop
  (local.set $j (i32.const 0))  <span class="LiteralGray">;; $j = 0</span>

  (loop $inner_loop
    (block $inner_continue
   <span class="LiteralGray"> ;; if $i == $j continue</span>
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> (br_if $inner_continue (i32.eq (local.get $i) (local.get $j) ) )

<span epub:type="pagebreak" title="135" id="Page_135"/> <span class="LiteralGray">   ;; $i_obj = $obj_base_addr + $i * $obj_stride</span>
    (i32.add (global.get $obj_base_addr)
           <span class="CodeAnnotationCode" aria-label="annotation4">4</span> (i32.mul (local.get $i) (global.get $obj_stride) ) )

<span class="LiteralGray">    ;; load $i_obj + $x_offset and store in $xi</span>
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> (call $get_attr (local.tee $i_obj) (global.get $x_offset) )
    local.set $xi    
    
<span class="LiteralGray">    ;; load $i_obj + $y_offset and store in $yi</span>
    (call $get_attr (local.get $i_obj) (global.get $y_offset) )
    local.set $yi    

<span class="LiteralGray">    ;; load $i_obj + $radius_offset and store in $ri</span>
    (call $get_attr (local.get $i_obj) (global.get $radius_offset) )
    local.set $ri    

<span class="LiteralGray">    ;; $j_obj = $obj_base_addr + $j * $obj_stride</span>
  <span class="CodeAnnotationCode" aria-label="annotation6">6</span> (i32.add (global.get $obj_base_addr)
             (i32.mul (local.get $j)(global.get $obj_stride)))

<span class="LiteralGray">    ;; load $j_obj + $x_offset and store in $xj</span>
    (call $get_attr (local.tee $j_obj) (global.get $x_offset) )
    local.set $xj    

<span class="LiteralGray">    ;; load $j_obj + $y_offset and store in $yj</span>
    (call $get_attr (local.get $j_obj) (global.get $y_offset) )
    local.set $yj    
     
<span class="LiteralGray">    ;; load $j_obj + $radius_offset and store in $rj</span>
    (call $get_attr (local.get $j_obj) (global.get $radius_offset) )
    local.set $rj    

<span class="LiteralGray">    ;; check for collision between ith and jth objects</span>
  <span class="CodeAnnotationCode" aria-label="annotation7">7</span> (call $collision_check
      (local.get $xi)(local.get $yi)(local.get $ri)
      (local.get $xj)(local.get $yj)(local.get $rj))

    if <span class="LiteralGray">;; if there is a collision</span>
    <span class="CodeAnnotationCode" aria-label="annotation8">8</span> (call $set_collision (local.get $i_obj) (local.get $j_obj))
    end
  )

  <span class="CodeAnnotationCode" aria-label="annotation9">9</span> (i32.add (local.get $j) (i32.const 1)) <span class="LiteralGray">;; $j++</span>
    
<span class="LiteralGray">    ;; if $j &lt; $obj_count loop</span>
    (br_if $inner_loop
      (i32.lt_u (local.tee $j) (global.get $obj_count)))
  )
   
  <span class="CodeAnnotationCode" aria-label="annotationa">a</span> (i32.add (local.get $i) (i32.const 1))<span class="LiteralGray"> ;; $i++</span>
   
<span class="LiteralGray">  ;; if $i &lt; $obj_count loop</span>
  (br_if $outer_loop
<span epub:type="pagebreak" title="136" id="Page_136"/>    (i32.lt_u (local.tee $i) (global.get $obj_count) ) )
 )
)
...</code></pre>
<p class="CodeListingCaption"><a id="listing6-23">Listing 6-23</a>: A double loop that checks for a collision between every object in linear memory</p>
<p>The function begins with two groups of local variables. One group contains a counter, the address of the objects, and the <code>x</code>, <code>y</code>, and <code>r</code> local variables for use with the outer loop <span class="CodeAnnotation" aria-label="annotation1">1</span>. The second batch of local variables is for use within the inner <code>loop</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>. The meat of this function is a double loop that compares every circle with every other circle in the linear memory looking for circles that collide with each other. The beginning of the inner loop checks whether <code>$i</code> is the same value as <code>$j</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>. If it is, the code skips the check on this particular <code>$j</code> object, because otherwise, every circle would collide with itself.</p>
<p> The next line of code calculates the linear memory address of the <code>i</code>th object <span class="CodeAnnotation" aria-label="annotation4">4</span> as <code>$obj_base_addr</code> + <code>$i</code> * <code>$obj_stride</code>. It then sets the value of <code>$i_obj</code> using the <code>local.tee</code> expression in the <code>(call</code><code> $get_attr)</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> expression in the next line. This call to <code>$getattr</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> retrieves the value for <code>x</code> from the <code>i</code>th object and then sets <code>$xi</code>.</p>
<p>The next four lines load values into <code>$yi</code> and <code>$ri</code> in the same way. Then <code>$xj</code>, <code>$yj</code>, and <code>$rj</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> are set using a call to <code>$get_attr</code> as well. These values are passed into a call to <code>$collision_check</code> <span class="CodeAnnotation" aria-label="annotation7">7</span>, which returns <code>1</code> if the <code>$i</code> and <code>$j</code> circles collide and <code>0</code> if they don’t. The <code>if</code> statement that follows executes a <code>call</code> to <code>$set_collision</code> <span class="CodeAnnotation" aria-label="annotation8">8</span> if there was a collision, which then sets the collision flags on those two objects to <code>1</code>. The end of the loop increments <code>$j</code> <span class="CodeAnnotation" aria-label="annotation9">9</span> and branches back to the top of the inner <code>loop</code> if <code>$j</code> is less than <code>$obj_count</code>. The end of the outer <code>loop</code> increments <code>$i</code> <span class="CodeAnnotation" aria-label="annotationa">a</span> and branches back to the top of the outer <code>loop</code> if <code>$i</code> is less than <code>$obj_count</code>.</p>
<p>The last item we call in this module is the <code>(start</code><code> $init)</code> statement, as shown in <a href="#listing6-24" id="listinganchor6-24">Listing 6-24</a>, which executes the <code>$init</code> function when the module is initialized.</p>
<p class="CodeLabel"><b>data_structures.wat (part 6 of 6)</b></p>
<pre><code>...
  (start $init)
)</code></pre>
<p class="CodeListingCaption"><a id="listing6-24">Listing 6-24</a>: The <code>start</code> indicates the function that will execute when the module is initialized.</p>
<p>Now that we have all the code in the <em>data_structures.wat</em> file, we can compile the WebAssembly file using <code>wat2wasm</code>, as shown in <a href="#listing6-25" id="listinganchor6-25">Listing 6-25</a>.</p>
<pre><code>wat2wasm data_structures.wat</code></pre>
<p class="CodeListingCaption"><a id="listing6-25">Listing 6-25</a>: Compile <em>data_structures.wat</em></p>
<p><span epub:type="pagebreak" title="137" id="Page_137"/>Once we have a compiled <em>data_structures.wasm</em> file, we can run <em>data_structures.js</em> using <code>node</code>, as shown in <a href="#listing6-26" id="listinganchor6-26">Listing 6-26</a>.</p>
<pre><code>node data_structures.js</code></pre>
<p class="CodeListingCaption"><a id="listing6-26">Listing 6-26</a>: Run <em>data_structures.js</em>.</p>
<p>The output will look something like <a href="#listing6-27" id="listinganchor6-27">Listing 6-27</a>.</p>
<pre><code><b>obj[00] x=48 y=65 r= 4 collision=true</b>
<b>obj[01] x=46 y=71 r= 6 collision=true</b>
<b>obj[02] x=12 y=75 r= 3 collision=true</b>
obj[03] x=54 y=43 r= 2 collision=false
obj[04] x=16 y= 6 r= 1 collision=false
<b>obj[05] x= 5 y=21 r= 9 collision=true</b>
obj[06] x=71 y=50 r= 5 collision=false
<b>obj[07] x=11 y=13 r= 5 collision=true</b>
<b>obj[08] x=43 y=70 r= 7 collision=true</b>
obj[09] x=88 y=60 r= 9 collision=false
<b>obj[10] x=96 y=21 r= 9 collision=true</b>
<b>obj[11] x= 5 y=87 r= 2 collision=true</b>
obj[12] x=64 y=39 r= 3 collision=false
<b>obj[13] x=75 y=74 r= 6 collision=true</b>
<b>obj[14] x= 2 y=74 r= 8 collision=true</b>
<b>obj[15] x=12 y=85 r= 7 collision=true</b>
obj[16] x=60 y=27 r= 5 collision=false
<b>obj[17] x=43 y=67 r= 2 collision=true</b>
obj[18] x=38 y=53 r= 3 collision=false
obj[19] x=34 y=39 r= 5 collision=false
<b>obj[20] x=42 y=62 r= 2 collision=true</b>
obj[21] x=72 y=93 r= 7 collision=false
<b>obj[22] x=78 y=79 r= 8 collision=true</b>
obj[23] x=50 y=96 r= 7 collision=false
<b>obj[24] x=34 y=18 r=10 collision=true</b>
obj[25] x=19 y=44 r= 8 collision=false
<b>obj[26] x=92 y=82 r= 7 collision=true</b>
obj[27] x=59 y=56 r= 3 collision=false
<b>obj[28] x=41 y=75 r= 9 collision=true</b>
<b>obj[29] x=28 y=29 r= 6 collision=true</b>
<b>obj[30] x=32 y=10 r= 1 collision=true</b>
<b>obj[31] x=83 y=15 r= 6 collision=true</b></code></pre>
<p class="CodeListingCaption"><a id="listing6-27">Listing 6-27</a>: Output from <em>data_structures.js</em></p>
<p>In the actual output, any circle that collides with another circle should be in red text, and any circle that collides with no other circles should be in green text. We now have an application that uses JavaScript to load randomly generated data for circles into WebAssembly linear memory. The initialization function in the WebAssembly module then loops over all of that data and updates the linear memory wherever one of those circles collides with another circle. Collision detection is a great use case for WebAssembly because it allows you to load a lot of data into linear memory and let your WebAssembly module work in a fast and efficient way.</p>
<h2 id="h1-501737c06-0004"><span epub:type="pagebreak" title="138" id="Page_138"/>Summary</h2>
<p class="BodyFirst">In this chapter, you learned what WebAssembly linear memory is and how to create it from within the WebAssembly module or JavaScript. Next, we initialized the linear data from within the WebAssembly module and accessed it from JavaScript. Then we created data structures within linear memory using a base address, stride, and attribute offsets, and initialized these data structures from within JavaScript using random data.</p>
<p>The final project was an array of circle data structures with x- and y-coordinates and a radius. These were passed into a WebAssembly module, which used a double loop to loop over the circle data structures looking for circles that overlap with each other. If two circles were found to overlap, the WebAssembly module set a collision flag inside the linear memory for both circles. JavaScript then looped over all of those circles, displaying their x- and y-coordinates, their radius, and whether they collided with any other circles. </p>
<p>At this point, you should understand how to manipulate and set linear memory from within WAT and JavaScript. You should also be able to use linear memory from within your applications to create data structures and process large quantities of data in WebAssembly that you can then display using JavaScript. In the next chapter, we’ll look at how to manipulate the Document Object Model (DOM) from WebAssembly.</p>
</section>
</div></body></html>