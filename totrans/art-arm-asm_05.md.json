["```\n.equ `symbol`, `constantExpression`\n```", "```\n.equ MaxIndex, 15\n```", "```\nlea  x0, ReadOnlyVar\nstr  x1, [x0]\n```", "```\nstr  x1, MaxIndex\n```", "```\nstr  x1, #15\n```", "```\n.set `label`, `expression`\n```", "```\n`label` = `expression`\n```", "```\nmaxLen = 10\n\n`At this point in the code, Gas will replace maxLen with 10.`\n\nmaxLen = 256\n\n`In this section of the code, maxLen gets replaced by 256.`\n```", "```\n.equiv `symbol, expression`\n```", "```\nptrVar:  .dword  .   // Stores the address of ptrVar in ptrVar\n```", "```\nsomeStr:  .ascii  \"Who wants to manually count the characters\"\n          .asciz  \"in this string to determine its length?\"\nssLen     =       .-someStr\n```", "```\n .text\n    .align 2\nwv: .word  0\n      .\n      .\n      .\n    ldr   w0, wv  // Yes, this one's \"type correct.\"\n    ldr   x0, wv  // Loads more data than is present\n```", "```\nM: array [0..1023] of integer;\n```", "```\ni := 0; (* Assume \"i\" is an integer variable. *)\nM [i] := 100;\n```", "```\ni := 5;      (* Assume all variables are integers. *)\nj := 10;\nk := 50;\nM [i*j-k] := 100;\n```", "```\nM [1] := 0;\nM [M [1]] := 100;\n```", "```\nlea x0, p      // Load X0 with the \nldr x0, [x0]   // value of pointer p. \nldr x1, [x0]   // Fetch the data at which p points. \n```", "```\nlea x1, varAtAddress1000_0000 \nldr x1, [x1] \n```", "```\n lea x0, i \n    lea x1, p      // Set p = address of i. \n    str x0, [x1] \n\n`Some code that sets or clears the carry flag ...` \n\n    bcc skipSetp \n\n lea x0, j \n       lea x1, p   // Set p = address of j. \n       str x0, [x1] \n        . \n        . \n        . \n\nskipSetp:          // Assume both code paths wind up \n    lea x0, p      // down here. \n    ldr x0, [x0]   // Load p into X0\\. \n    ldr x1, [x0]   // X1 = i or j, depending on path here. \n```", "```\n .data \nbb:        .byte   .-.  // Uninitialized \n           .align  3 \nd:         .dword  .-.  // Uninitialized \npByteVar:  .dword  bb   // Initialized with the address of bb \npDWordVar: .dword  d    // Initialized with the address of d \n```", "```\n`StaticVarName` + `PureConstantExpression` \n`StaticVarName` - `PureConstantExpression` \n```", "```\n// Listing4-1.S \n//\n// Pointer constant demonstration \n\n#include \"aoaa.inc\"\n\n          .section  .rodata, \"\"\nttlStr:   .asciz    \"Listing 4-1\"\nfmtStr:   .ascii    \"pb's value is %p\\n\"\n          .asciz    \"*pb's value is %d\\n\"\n\n          .data \nbb:       .byte     0 \n          .byte     1, 2, 3, 4, 5, 6, 7 \n\n❶ pb        =         bb + 2     // Address of \"2\" in bb \n\n❷ pbVar:   .dword     pb \n\npbValue: .word      0 \n\n         .text \n         .align     2 \n         .extern    printf \n\n// Return program title to C++ program: \n\n         .global    getTitle \ngetTitle: \n         lea        x0, ttlStr \n         ret \n\n// Here is the asmMain function: \n\n        .global     asmMain \nasmMain: \n        sub     sp, sp, #64     // Reserve space on stack. \n        str     lr, [sp, #56]   // Save return address. \n\n        lea     x0, pbVar       // Get pbVar. \n        ldr     x0, [x0] \n        ldrb    w0, [x0]        // Fetch data at *pbVar. \n      ❸ lea     x1, pbValue     // Save in pbValue for now. \n        str     w0, [x1] \n\n// Print the results: \n\n        lea     x0, fmtStr \n      ❹ vparm2  pbVar \n      ❺ vparm3  pbValue \n        bl      printf \n\n        ldr     lr, [sp, #56]   // Restore return address. \n        add     sp, sp, #64 \n        ret     // Returns to caller \n```", "```\n$ ./build Listing4-1 \n$ ./Listing4-1 \nCalling Listing4-1: \npb's value is 0x411042 \n*pb's value is 2 \nListing4-1 terminated \n```", "```\n// Listing4-2.S \n//\n// Demonstration of calls \n// to C stdlib malloc \n// and free functions \n\n#include \"aoaa.inc\"\n\n            .section    .rodata, \"\"\nttlStr:     .asciz      \"Listing 4-2\"\nfmtStr:     .asciz      \"Addresses returned by malloc: %p, %p\\n\"\n\n            .data \nptrVar:     .dword      .-. \nptrVar2:    .dword      .-. \n\n            .text \n            .align      2 \n            .extern     printf \n            .extern     malloc \n            .extern     free \n\n// Return program title to C++ program: \n\n            .global     getTitle \ngetTitle: \n            lea         x0, ttlStr \n            ret \n\n// Here is the \"asmMain\" function: \n\n            .global     asmMain \nasmMain: \n            sub         sp, sp, #64     // Space on stack \n            str         lr, [sp, #56]   // Save return address. \n\n// C stdlib malloc function \n//\n// ptr = malloc(byteCnt); \n//\n// Note: malloc has only a single parameter; it \n// is passed in X0 as per ARM/macOS ABI. \n\n          ❶ mov         x0, #256        // Allocate 256 bytes. \n            bl          malloc \n            lea         x1, ptrVar      // Store pointer into \n            str         x0, [x1]        // ptrVar variable. \n\n            mov         x0, #1024       // Allocate 1,024 bytes. \n            bl          malloc \n            lea         x1, ptrVar2     // Store pointer into \n            str         x0, [x1]        // ptrVar2 variable. \n\n// Print the addresses of the two malloc'd blocks: \n\n            lea         x0, fmtStr \n            vparm2      ptrVar \n            vparm3      ptrVar2 \n            bl          printf \n\n// Free the storage by calling \n// C stdlib free function. \n//\n// free(ptrToFree); \n//\n// Once again, the single parameter gets passed in X0\\. \n\n          ❷ lea         x0, ptrVar \n            ldr         x0, [x0] \n            bl          free \n\n            lea         x0, ptrVar2 \n            ldr         x0, [x0] \n            bl          free \n\n            ldr         lr, [sp, #56]   // Get return address. \n            add         sp, sp, #64     // Clean up stack. \n            ret \n```", "```\n$ ./build Listing4-2 \n$ ./Listing4-2 \nCalling Listing4-2: \nAddresses returned by malloc: 0x240b46b0, 0x240b47c0 \nListing4-2 terminated \n```", "```\n// Listing4-3.S \n//\n// Uninitialized pointer demonstration \n// This program will not run properly. \n\n#include \"aoaa.inc\"\n\n            .section    .rodata, \"\"\nttlStr:     .asciz      \"Listing 4-3\"\nfmtStr:     .asciz      \"Pointer value= %p\\n\"\n\n            .data \n❶ ptrVar:     .dword      .-.   // \".-.\" means uninitialized. \n\n            .text \n            .align      2 \n            .extern     printf \n\n// Return program title to C++ program: \n\n            .global     getTitle \ngetTitle: \n lea         x0, ttlStr \n            ret \n\n// Here is the \"asmMain\" function: \n\n            .global     asmMain \nasmMain: \n            sub         sp, sp, #64     // Stack storage \n            str         lr, [sp, #56]   // Save return address. \n\n          ❷ lea         x0, ptrVar \n            ldr         x1, [x0]        // Get ptrVar into X1\\. \n            ldr         x2, [x1]        // Will crash the system \n\n            ldr         lr, [sp, #56]   // Retrieve return adrs. \n            add         sp, sp, #64     // Restore stack. \n            ret \n```", "```\nmov  x0, #256 \nbl   malloc       // Allocate some storage. \nlea  x1, ptrVar \nstr  x0, [x1]     // Save address away in ptrVar. \n . \n .    ` Code that uses the pointer variable ptrVar` \n . \nlea  x0, ptrVar   // Pass ptrVar's value to free. \nldr  x0, [x0] \nbl   free         // Free storage associated with ptrVar. \n . \n .    `Code that does not change the value in ptrVar` \n . \nlea  x0, ptrVar \nldr  x1, [x0] \nstrb w2, [x1] \n```", "```\nmov  x0, #256 \nbl   malloc \nlea  x1, ptrVar \nstr  x0, [x1] \n\n`Code that uses ptrVar` \n`This code does not free up the storage` \n`associated with ptrVar.` \n\nmov  x0, #512 \nbl   malloc \nlea  x1, ptrVar \nstr  x0, [x1] \n\n// At this point, there is no way to reference the original \n// block of 256 bytes pointed at by ptrVar. \n```", "```\n// Listing4-4.S \n//\n// Demonstration of lack of type \n// checking in assembly language \n// pointer access \n\n#include \"aoaa.inc\"\n\nmaxLen       =          256 \n\n            .section    .rodata, \"\"\nttlStr:     .asciz      \"Listing 4-4\"\nprompt:     .asciz      \"Input a string: \"\nfmtStr:     .asciz      \"%d: Hex value of char read: %x\\n\"\n\n            .data \nvalToPrint: .word       .-. \nbufIndex:   .dword      .-. \nbufPtr:     .dword      .-. \nbytesRead:  .dword      .-. \n\n            .text \n            .align      2 \n            .extern     readLine \n            .extern     printf \n            .extern     malloc \n            .extern     free \n\n// Return program title to C++ program: \n\n            .global     getTitle \ngetTitle: \n            lea         x0, ttlStr \n            ret \n\n// Here is the asmMain function: \n\n            .global     asmMain \nasmMain: \n\n            sub     sp, sp, #64     // Reserve stack space. \n            str     lr, [sp, #56]   // Save return address. \n\n// C stdlib malloc function \n// Allocate sufficient characters \n// to hold a line of text input \n// by the user: \n\n            mov     x0, #maxLen     // Allocate 256 bytes. \n            bl      malloc \n            lea     x1, bufPtr      // Save pointer to buffer. \n            str     x0, [x1] \n\n// Read a line of text from the user and place in \n// the newly allocated buffer: \n\n        lea     x0, prompt      // Prompt user to input \n        bl      printf          // a line of text. \n\n        lea     x0, bufPtr \n        ldr     x0, [x0]        // Pointer to input buffer \n        mov     x1, #maxLen     // Maximum input buffer length \n        bl      readLine        // Read text from user. \n        cmp     x0, #-1         // Skip output if error. \n        beq     allDone \n        lea     x1, bytesRead \n        str     x0, [x1]        // Save number of chars read. \n\n// Display the data input by the user: \n\n        mov     x1, #0          // Set index to 0\\. \n        lea     x0, bufIndex \n        str     x1, [x0] \ndispLp: lea     x0, bufIndex    // Get buffer index \n        ldr     x1, [x0]        // into X1\\. \n        lea     x2, bufPtr      // Get pointer to buffer. \n        ldr     x2, [x2] \n        ldr     w0, [x2, x1]    // Read word rather than byte! \n        lea     x1, valToPrint \n        str     w0, [x1] \n        lea     x0, fmtStr \n        vparm2  bufIndex \n        vparm3  valToPrint \n        bl      printf \n\n        lea     x0, bufIndex    // Increment index by 1\\. \n        ldr     x1, [x0] \n        add     x1, x1, #1 \n        str     x1, [x0] \n\n        lea     x0, bytesRead   // Repeat until \n        ldr     x0, [x0]        // you've processed \"bytesRead\"\n        cmp     x1, x0          // bytes. \n        blo     dispLp \n\n// Free the storage by calling \n// C stdlib free function. \n//\n// free(bufPtr) \n\nallDone: \n        lea     x0, bufPtr \n        ldr     x0, [x0] \n        bl      free \n\n        ldr     lr, [sp, #56]   // Restore return address. \n        add     sp, sp, #64 \n        ret     // Returns to caller \n```", "```\n$ ./build Listing4-4 \n$ ./Listing4-4 \nCalling Listing4-4: \nInput a string: Hello world \n0: Hex value of char read: 6c6c6548 \n1: Hex value of char read: 6f6c6c65 \n2: Hex value of char read: 206f6c6c \n3: Hex value of char read: 77206f6c \n4: Hex value of char read: 6f77206f \n5: Hex value of char read: 726f7720 \n6: Hex value of char read: 6c726f77 \n7: Hex value of char read: 646c726f \n8: Hex value of char read: 646c72 \n9: Hex value of char read: 646c \n10: Hex value of char read: 64 \n11: Hex value of char read: 0 \nListing4-4 terminated \n```", "```\n .data \nzeroString: .asciz  \"This is the zero-terminated string\"\n```", "```\n .data \nlongZString: .ascii  \"This is the first line\"\n             .ascii  \"This is the second line\"\n             .asciz  \"This is the last line\"\n```", "```\n .data \nlongZString: .ascii  \"This is the first line\"\n             .ascii  \"This is the second line\"\n             .ascii  \"This is the last line\"\n             .byte   0 \n```", "```\n lea   x1, longZString \n          mov   x2, x1         // Save pointer to string. \nwhileLp:  ldrb  w0, [x1], #1   // Fetch next char and inc X1\\. \n          cmp   w0, #0         // See if 0 byte. \n          bne   whileLp        // Repeat while not 0\\. \n          sub   x0, x1, x2     // X0 = X1 - X2 \n          sub   x0, x0, #1     // Adjust for extra increment. \n\n// String length is now in X0\\. \n```", "```\n .data \nlengthPrefixedString: .byte   3 \n                      .ascii \"abc\"\n```", "```\n .data \nlengthPrefixedString: .byte  lpsLen \n                      .ascii \"abc\"\nlpsLen                =      . - lengthPrefixedString - 1 \n```", "```\n. - lengthPrefixedString \n```", "```\n// Listing4-5.S \n//\n// Calling C stdlib string functions\n\n#include \"aoaa.inc\"\n\nmaxLen      =           256 \nsaveLR      =           56 \n\n            .section    .rodata, \"\"\nttlStr:     .asciz      \"Listing 4-5\"\nprompt:     .asciz      \"Input a string: \"\nfmtStr1:    .asciz      \"After strncpy, resultStr='%s'\\n\"\nfmtStr2:    .asciz      \"After strncat, resultStr='%s'\\n\"\nfmtStr3:    .asciz      \"After strcmp (3), W0=%d\\n\"\nfmtStr4:    .asciz      \"After strcmp (4), W0=%d\\n\"\nfmtStr5:    .asciz      \"After strcmp (5), W0=%d\\n\"\nfmtStr6:    .asciz      \"After strchr, X0='%s'\\n\"\nfmtStr7:    .asciz      \"After strstr, X0='%s'\\n\"\nfmtStr8:    .asciz      \"resultStr length is %d\\n\"\n\nstr1:       .asciz      \"Hello, \"\nstr2:       .asciz      \"World!\" \nstr3:       .asciz      \"Hello, World!\" \nstr4:       .asciz      \"hello, world!\" \nstr5:       .asciz      \"HELLO, WORLD!\" \n\n            .data \nstrLength:  .dword      .-. \nresultStr:  .space      maxLen, .-. \nresultPtr:  .dword      resultStr \ncmpResult:  .dword      .-. \n\n            .text \n            .align      2 \n            .extern     readLine \n            .extern     printf \n            .extern     malloc \n            .extern     free \n\n// Some C stdlib string functions: \n//\n// size_t strlen(char *str) \n\n            .extern     strlen \n\n// char *strncat(char *dest, const char *src, size_t n) \n\n            .extern     strncat \n\n// char *strchr(const char *str, int c) \n\n            .extern     strchr \n\n// int strcmp(const char *str1, const char *str2) \n\n            .extern     strcmp \n\n// char *strncpy(char *dest, const char *src, size_t n) \n\n            .extern     strncpy \n\n// char *strstr(const char *inStr, const char *search4) \n\n            .extern     strstr \n\n// Return program title to C++ program: \n\n            .global     getTitle \ngetTitle: \n            lea         x0, ttlStr \n            ret \n\n// Here is the \"asmMain\" function. \n\n            .global     asmMain \nasmMain: \n        sub     sp, sp, #64         // Allocate stack space. \n        str     lr, [sp, #saveLR]   // Save return address. \n\n// Demonstrate the strncpy function to copy a \n// string from one location to another: \n\n        lea     x0, resultStr   // Destination string \n        lea     x1, str1        // Source string \n        mov     x2, #maxLen     // Max number of chars to copy \n        bl      strncpy \n\n        lea     x0, fmtStr1 \n        vparm2  resultPtr \n        bl      printf \n\n// Demonstrate the strncat function to concatenate str2 to \n// the end of resultStr: \n\n        lea     x0, resultStr \n        lea     x1, str2 \n        mov     x2, #maxLen \n        bl      strncat \n\n        lea     x0, fmtStr2 \n        vparm2  resultPtr \n        bl      printf \n\n// Demonstrate the strcmp function to compare resultStr \n// with str3, str4, and str5: \n\n        lea     x0, resultStr \n        lea     x1, str3 \n        bl      strcmp \n        lea     x1, cmpResult \n        str     x0, [x1] \n\n        lea     x0, fmtStr3 \n        vparm2  cmpResult \n        bl      printf \n\n        lea     x0, resultStr \n        lea     x1, str4 \n        bl      strcmp \n lea     x1, cmpResult \n        str     x0, [x1] \n\n        lea     x0, fmtStr4 \n        vparm2  cmpResult \n        bl      printf \n\n        lea     x0, resultStr \n        lea     x1, str5 \n        bl      strcmp \n        lea     x1, cmpResult \n        str     x0, [x1] \n\n        lea     x0, fmtStr5 \n        vparm2  cmpResult \n        bl      printf \n\n// Demonstrate the strchr function to search for \n// ',' in resultStr: \n\n        lea     x0, resultStr \n        mov     x1, #',' \n        bl      strchr \n        lea     x1, cmpResult \n        str     x0, [x1] \n\n        lea     x0, fmtStr6 \n        vparm2  cmpResult \n        bl      printf \n\n// Demonstrate the strstr function to search for \n// str2 in resultStr: \n\n        lea     x0, resultStr \n        lea     x1, str2 \n        bl      strstr \n        lea     x1, cmpResult \n        str     x0, [x1] \n\n        lea     x0, fmtStr7 \n        vparm2  cmpResult \n        bl      printf \n\n// Demonstrate a call to the strlen function: \n\n        lea     x0, resultStr \n        bl      strlen \n        lea     x1, cmpResult \n        str     x0, [x1] \n\n        lea     x0, fmtStr8 \n        vparm2  cmpResult \n        bl      printf \n\n ldr     lr, [sp, #saveLR]   // Restore return address. \n        add     sp, sp, #64         // Deallocate storage. \n        ret     // Returns to caller \n```", "```\n$ ./build Listing4-5 \n$ ./Listing4-5 \nCalling Listing4-5: \nAfter strncpy, resultStr='Hello, ' \nAfter strncat, resultStr='Hello, World!' \nAfter strcmp (3), W0 = 0 \nAfter strcmp (4), W0=-128 \nAfter strcmp (5), W0 = 128 \nAfter strchr, X0=', World!' \nAfter strstr, X0='World!' \nresultStr length is 13 \nListing4-5 terminated \n```", "```\n`Element_Address` =\n `Base_Address` + `((Index` - `Initial_Index)` × `Element_Size)` \n```", "```\n`ArrayName`: .fill  `n`, `element_size`, `initial_value` \n```", "```\nwordArray:   .fill    16, 4 \n```", "```\n`ArrayName:`  .space `size`, `fill` \n```", "```\nwordArray:   .space    16 * (4)   // word wordArray[16] \n```", "```\nwordArray:    .word   0, 1, 2, 3, 4, 5, 6, 7 \n              .word   8, 9, 10, 11, 12, 13, 14, 15 \n```", "```\n`Element_Address` = `Base_Address` + `index` × `Element_Size` \n```", "```\nlea x1, `Base_Address` \n```", "```\n`Element_Address` = wordArray + (`index` × 4) \n```", "```\nlea x1, index   // Assume index is a 32-bit integer. \nldr w1, [x1]    // Get index into W1\\. \nlea x2, wordArray \nldr w0, [x2, w1, uxtw #2] // index * 4 and zero-extended \n```", "```\nldr w0, [x2, w1, uxtw #2] \n```", "```\n// Listing4-6.S \n//\n// A simple bubble sort example \n\n#include \"aoaa.inc\"\n```", "```\n// Listing4-6.S (cont.) \n\nstackAlloc  =   64   // Space to allocate on stack \nsaveLR      =   56   // Save LR here (index into stack frame). \n```", "```\n// Listing4-6.S (cont.) \n\nx19Save     =   saveLR - 8   // Save X19 here. \nx20Save     =   x19Save - 8  // Save X20 here. \n```", "```\n// Listing4-6.S (cont.) \n\nmaxLen      =   256 \ntrue        =   1 \nfalse       =   0 \n```", "```\n// Listing4-6.S (cont.) \n\n            .section    .rodata, \"\"\nttlStr:     .asciz      \"Listing 4-6\"\nfmtStr:     .asciz      \"Sortme[%d] = %d\\n\"\n\n            .data \n\n// sortMe - A 16-element array to sort: \n\nsortMe: \n            .word   1, 2, 16, 14 \n            .word   3, 9, 4,  10 \n            .word   5, 7, 15, 12 \n            .word   8, 6, 11, 13 \nsortSize    =       (. - sortMe) / 4   // Number of elements \n\n// Holds the array element during printing: \n\nvalToPrint: .word   .-. \ni:          .word   .-. \n\n            .text \n            .align  2 \n            .extern printf \n\n// Return program title to C++ program: \n\n            .global getTitle \ngetTitle: \n            lea     x0, ttlStr \n            ret \n```", "```\n// Listing4-6.S (cont.) \n//\n// Here's the bubble-sort function. \n//\n//       sort(dword *array, qword count) \n//\n// Note: this is not an external (C) \n// function, nor does it call any \n// external functions, so it will \n// dispense with some of the OS-calling-\n// sequence stuff. \n//\n// array- Address passed in X0 \n// count- Element count passed in X1 \n//\n// Locals: \n//\n// W2 is \"didSwap\" Boolean flag. \n// X3 is index for outer loop. \n// W4 is index for inner loop. \n```", "```\n// Listing4-6.S (cont.) \n\n#define array   x0 \n#define count   x1 \n#define didSwap w2 \n#define index   x3 \n```", "```\n// Listing4-6.S (cont.) \n\nsort:\n\n        sub     count, count, #1   // numElements - 1 \n        lsl     count, count, #2   // Make byte count. \n```", "```\n// Listing4-6.S (cont.) \n//\n// Outer loop \n\nouter:  mov     didSwap, #false \n\n        mov     index, #0          // Outer loop index \ninner:  cmp     index, count       // while outer < count - 1 \n        bhs     xInner \n\n        add     x5, array, index   // W5 = &array[index] \n        ldr     w6, [x5]           // W6 = array[index] \n        ldr     w7, [x5, #4]       // W7 = array[index + 1] \n        cmp     w6, w7             // If W5 > W \n        bls     dontSwap           // then swap. \n\n        // sortMe[index] > sortMe[index + 1], so swap elements. \n\n        str     w6, [x5, #4] \n        str     w7, [x5] \n        mov     didSwap, #true \n\ndontSwap: \n        add     index, index, #4    // Next word \n        b.al    inner \n\n// Exited from inner loop, test for repeat \n// of outer loop: \n\nxInner: cmp     didSwap, #true \n        beq     outer \n\n        ret \n```", "```\n// Listing4-6.S (cont.) \n//\n// Here is the asmMain function: \n\n            .global asmMain \nasmMain: \n\n            sub     sp, sp, #stackAlloc   // Allocate stack space. \n            str     lr, [sp, #saveLR]     // Save return address. \n            str     x19, [sp, #x19Save]   // Save nonvolatile \n            str     x20, [sp, #x20Save]   // X19 and X20\\. \n```", "```\n// Listing4-6.S (cont.) \n//\n// Sort the \"sortMe\" array: \n\n            lea     x0, sortMe \n            mov     x1, #sortSize   // 16 elements in array \n            bl      sort \n```", "```\n// Listing4-6.S (cont.) \n//\n// Display the sorted array. \n\n            lea     x19, sortMe \n            mov     x20, xzr                 // X20 = 0 (index) \ndispLp:     ldr     w0, [x19, x20, lsl #2]   // W0 = sortMe[X20] \n            lea     x1, valToPrint \n            str     w0, [x1] \n            lea     x1, i \n            str     x20, [x1] \n\n            lea     x0, fmtStr      // Print the index \n            vparm2  i               // and array element \n            vparm3  valToPrint      // on this loop iteration. \n            bl      printf \n\n            add     x20, x20, #1    // Bump index by 1\\. \n            cmp     x20, #sortSize  // Are we done yet? \n            blo     dispLp \n```", "```\n// Listing4-6.S (cont.) \n\n            ldr     x19, [sp, #x19Save]  // Restore nonvolatile \n            ldr     x20, [sp, #x20Save]  // registers. \n            ldr     lr, [sp, #saveLR]    // Restore rtn adrs. \n            add     sp, sp, #stackAlloc  // Restore stack. \n            ret     // Returns to caller \n```", "```\n$ ./build Listing4-6 \n$ ./Listing4-6 \nCalling Listing4-6: \nSortme[0] = 1 \nSortme[1] = 2 \nSortme[2] = 3 \nSortme[3] = 4 \nSortme[4] = 5 \nSortme[5] = 6 \nSortme[6] = 7 \nSortme[7] = 8 \nSortme[8] = 9 \nSortme[9] = 10 \nSortme[10] = 11 \nSortme[11] = 12 \nSortme[12] = 13 \nSortme[13] = 14 \nSortme[14] = 15 \nSortme[15] = 16 \nListing4-6 terminated \n```", "```\nA:array[0..3,0..3] of char; \n```", "```\n`Element_Address` =\n    `Base_Address` +\n      (`colindex` × `row_size` + `rowindex`) × `Element_Size` \n```", "```\nColumn          Row             Offset \nIndex                           into Array \n0               0               0 \n0               1               1 \n0               2               2 \n0               3               3 \n1               0               4 \n1               1               5 \n1               2               6 \n1               3               7 \n2               0               8 \n2               1               9 \n2               2               10 \n2               3               11 \n3               0               12 \n3               1               13 \n3               2               14 \n3               3               15 \n```", "```\n`Address` =\n    `Base` + ((`depthindex` × `col_size` + `colindex`) × `row_size` +\n             `rowindex`) × `Element_Size` \n```", "```\n`type` A[i][j][k]; \n```", "```\n`type` A[i][j][k][m]; \n```", "```\n`Address` =\n    `Base` +\n      (((`LeftIndex` × `depth_size` + `depthindex`) × `col_size` +\n         `colindex`) × `row_size` + `rowindex`) × `Element_Size` \n```", "```\nA: array [0..3] of `sometype`; \n```", "```\n`Element_Address` = `Base` + `Index` × `Element_Size` \n```", "```\nA:array [0..3, 0..3, 0..3, 0..3, 0..3] of char; \n```", "```\ntype \n OneD = array[0..3] of char; \n TwoD = array[0..3] of OneD; \n ThreeD = array[0..3] of TwoD; \n FourD = array[0..3] of ThreeD; \nvar \n A: array[0..3] of FourD; \n```", "```\n`Element_Address` = `Base_Address` +\n                (`rowindex` × `col_size` + `colindex`) × `Element_Size` \n```", "```\n`Address` = `Base` + ((`rowindex` × `col_size` + `colindex`) ×\n        `depth_size` + `depthindex`) × `Element_Size` \n```", "```\n`Address` =\n    `Base` + (((`rowindex` × `col_size` + `colindex`) × `depth_size` +\n      `depthindex`) × `Left_size` + `Leftindex`) × `Element_Size` \n```", "```\n`ArrayName`: .space `size`1 * `size`2 * `size`3 * ... * `size`n * (`Element_Size`) \n```", "```\nGameGrid: .space 4 * 4 // `Element_Size` is 1\\. \n```", "```\nNameItems: .space 2 * 3 * 3 * (8)  // dword NameItems[2, 3, 3] \n```", "```\nGameGrid: .byte 'a', 'b', 'c', 'd' \n          .byte 'e', 'f', 'g', 'h' \n          .byte 'i', 'j', 'k', 'l' \n          .byte 'm', 'n', 'o', 'p' \n```", "```\nmul  `reg`d`, reg`1`, reg`r  // `reg`d = `reg`l * `reg`r \nmadd `reg`d`, reg`l`, reg`r`, reg`a   // `reg`d = `reg`l * `reg`r + `reg`a \n```", "```\n .data \ni:       .word  .-. \nj:       .word  .-. \nTwoD:    .word  4 * 8  * (4) \n           . \n           . \n           . \n// To perform the operation TwoD[i,j] := 5; \n// you'd use code like the following. \n// Note that the array index computation is (i * 4 + j) * 4\\. \n\n         lea x0, i \n         ldr w0, [x0]    // Clears HO bits of X0 \n         lsl x0, x0, #2  // Multiply i by 4\\. \n         lea x1, j \n         ldr w1, [x1] \n         add w0, w0, w1  // W0 = i * 4 + j \n         lea x1, TwoD    // X1 = base \n         mov w2, #5      // [TwoD + (i * 4 + j) * 4] = 5 \n         str w2, [x1, x0, lsl #2] // Scaled by 4 (element size) \n```", "```\n .data \ni:      .word  .-. \nj:      .word  .-. \nk:      .word  .-. \nThreeD: .space 3 * 4 * 5 * (4) // word ThreeD[3, 4, 5] \n          . \n          . \n          . \n// To perform the operation ThreeD[i,j,k] := W7; \n// you'd use the following code that computes \n// ((i * 4 + j) * 5 + k) * 4 as the address of ThreeD[i,j,k]. \n\n          lea  x0, i \n          ldr  w0, [x0] \n          lsl  w0, w0, #2  // Four elements per column \n          lea  x1, j       // Add in j. \n          ldr  w1, [x1] \n          add  w0, w0, w1 \n          mov  w1, #5      // Five elements per row \n          lea  x2, k \n          ldr  w2, [x2] \n          madd w0, w0, w1, w2 // ((i * 4 + j) * 5 + k) \n          lea  x1, ThreeD \n          str  w7, [x1, w0, uxtw #2] // ThreeD[i,j,k] = W7 \n```", "```\nstudent =\n     record \n          sName:    string[64]; \n          Major:    integer; \n          SSN:      string[11]; \n          Midterm1: integer; \n          Midterm2: integer; \n          Final:    integer; \n          Homework: integer; \n          Projects: integer; \n     end; \n```", "```\nldrh  w0, [x0, #65] \n```", "```\n.equ sName, 0 \n.equ Major, 65 \n.equ SSN, 67 \n.equ Mid1, 79 \n.equ Mid2, 81 \n.equ Final, 83 \n.equ Homework, 85 \n.equ Projects, 87 \n```", "```\nstruct student \n    byte  sName, 65 // Includes zero-terminating byte \n    hword Major \n    byte  SSN, 12   // Includes zero-terminating byte \n    hword Midterm1 \n    hword Midterm2 \n    hword Final \n    hword Homework \n    hword Projects \nends student \n```", "```\nstudent John \n```", "```\nlea  x0, John \nldrh w1, [x0, #Midterm1] \nldrh w2, [x0, #Midterm2] \nldrh w3, [x0, #Final]   // And so on ... \n```", "```\nstruct student \n    byte  student.sName, 65 \n    hword student.Major \n byte  student.SSN, 12 \n    hword student.Midterm1 \n    hword student.Midterm2 \n    hword student.Final \n    hword student.Homework \n    hword student.Projects \nends student \n```", "```\nJohn:  .fill student.size \n```", "```\nstruct HLAstring, -4 \nword   HLAstring.len \nbyte   HLAstring.chars, 256 \nends   HLAstring \n```", "```\n HLAstring myString \n         // Expands to \n           .fill      4 \nmyString:  .fill      256 \n```", "```\nJohn:    .asciz  \"John Somebody\"   // sName \n         .space  65 - (.-John)     // Must be 65 bytes long! \n         .hword  0                 // Major \n         .asciz  \"123-45-6578\"     // SSN-Exactly 12 bytes long \n         .hword  75                // Midterm1 \n         .hword  82                // Midterm2 \n         .hword  90                // Final \n         .hword  72                // Homework \n         .hword  80                // Projects \n```", "```\nnumStudents = 30 \n   . \n   . \n   . \nClass:  .fill student.size * numStudents \n```", "```\n// Access field Final, of element i of class: \n// X1 := i * student.size + offset Final \n\n    lea  x1, i \n    ldr  x1, [x1] \n    mov  x2, #student.size \n    mov  x3, #student.Final \n    madd x1, x1, x2, x3   // Include offset to field. \n    lea  x2, class \n    ldrh w0, [x2, x1]     // Accesses class[i].Final \n```", "```\n .data \n\nnumStudents = 30 \nnumClasses  = 2 \n\n// student Instructor[numClasses][numStudents] \n\nInstructor:   .fill  numStudents * numClasses * (student.size) \nwhichClass:   .dword 1 \nwhichStudent: .dword 10 \n          . \n          . \n          . \n// Access element [whichClass,whichStudent] of class \n// and load Major into W0: \n\n     lea  x0, whichClass \n     ldr  x1, [x0] \n     mov  x2, #numStudents    // X1 = whichClass * numStudents \n     mul  x1, x1, x2 \n     lea  x0, whichStudent \n     ldr  x2, [x0]            // X1 = (whichClass * numStudents +\n     add  x1, x1, x2          //  numStudents) \n     mov  x2, #student.size   //   * sizeStudent + offset Major \n     mov  x3, #Major \n     madd x1, x1, x2, x3 \n\n     lea  x0, Instructor // W0 =  Instructor[whichClass] \n     ldrh w0, [x0, x1]   //         [whichStudent].Major \n```", "```\nstruct tst \nbyte bb \nsalign 2   // Aligns offset to next 4-byte boundary \nbyte c \nends tst \n```", "```\nstruct numericRec \n       word  i \n       word  u \n       dword q \nends   numericRec \n```"]