<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch16"><span epub:type="pagebreak" id="page_323"/><strong><span class="big">16</span><br/>BITWISE LOGIC, MULTIPLICATION, AND DIVISION INSTRUCTIONS</strong></h2>&#13;
<div class="image1"><img src="../images/pg297_Image_276.jpg" alt="Image" width="192" height="195"/></div>&#13;
<p class="noindentz">Now that you’ve learned about program organization, let’s turn our attention to computation. I’ll start by explaining the logic operators, which can be used to change individual bits in a value using a technique called <em>masking</em>.</p>&#13;
<p class="indent">Then I’ll move on to shift operations, which provide a way to multiply or divide by powers of two. In the last two sections of this chapter, I’ll cover arithmetic multiplication and division of integers.</p>&#13;
<h3 class="h3" id="ch16lev1sec1"><strong>Bitmasking</strong></h3>&#13;
<p class="indent">It’s often better to think of data items as patterns of bits rather than numerical entities. For example, if you look back at <a href="ch02.xhtml#ch2tab5">Table 2-5</a> in <a href="ch02.xhtml">Chapter 2</a>, you’ll see that the only difference between uppercase and lowercase alphabetic characters in ASCII is bit number 5, which is <span class="literal">1</span> for lowercase and <span class="literal">0</span> for upper-case. The ASCII code for <span class="literal">m</span>, for instance, is <span class="literal">0x6d</span>, and for <span class="literal">M</span>, it’s <span class="literal">0x4d</span>. If you wanted to write a function that changed the case of a string of alphabetic characters from lowercase to uppercase, you could view this as a numerical <span epub:type="pagebreak" id="page_324"/>difference of 32. You would need to determine the current case of the character and then decide whether to change it by subtracting 32.</p>&#13;
<p class="indent">But there’s a faster way. We can change bit patterns by using logical bitwise operations and a mask, or bitmask. A <em>mask</em> is a specific pattern of bits that can be used to make specified bits in a variable either <span class="literal">1</span> or <span class="literal">0</span>, or to invert them. For example, to make sure an alphabetic character is uppercase, we need to ensure its bit number 5 is <span class="literal">0</span>, giving the mask <span class="literal">11011111</span> = <span class="literal">0xdf</span>. Then, using the previous example of <span class="literal">m</span>, <span class="literal">0x6d</span><em>∧</em> <span class="literal">0xdf</span> = <span class="literal">0x4d</span>, which is <span class="literal">M</span>. If the character is already uppercase, then <span class="literal">0x4d</span><em>∧</em> <span class="literal">0xdf</span> = <span class="literal">0x4d</span>, leaving it as uppercase. This solution avoids checking for the case before the conversion.</p>&#13;
<p class="indent">We can use similar logic for other operations. To make a bit <span class="literal">1</span>, place a <span class="literal">1</span> in the appropriate bit position in the mask and use the bitwise OR operation. To produce a <span class="literal">0</span> in a bit position, place a <span class="literal">0</span> in that position and a <span class="literal">1</span> in each of the other bit positions in the mask and then use the bitwise AND operation. You can invert bits by placing a <span class="literal">1</span> in each bit position you want to invert and a <span class="literal">0</span> in all other positions and using the bitwise XOR operation.</p>&#13;
<h4 class="h4" id="ch16lev2sec1"><em><strong>Bitmasking in C</strong></em></h4>&#13;
<p class="noindent">The program in <a href="ch16.xhtml#ch16list1">Listings 16-1</a> to <a href="ch16.xhtml#ch16list3">16-3</a> shows how to use a mask to convert all lowercase alphabetic characters in a text string to uppercase.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>uppercase.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Make an alphabetic text string uppercase.&#13;
&#13;
   #include &lt;stdio.h&gt;&#13;
   #include "to_upper.h"&#13;
   #include "write_str.h"&#13;
   #include "write_char.h"&#13;
   #include "read_str.h"&#13;
<span class="ent">➊</span> #define MAX 50&#13;
<span class="ent">➋</span> #define ARRAY_SZ MAX+1&#13;
   &#13;
   int main(void)&#13;
   {&#13;
       char my_string[ARRAY_SZ];&#13;
&#13;
       write_str("Enter up to 50 alphabetic characters: ");&#13;
    <span class="ent">➌</span> read_str(my_string, MAX);&#13;
   &#13;
       to_upper(my_string, my_string);&#13;
       write_str("All upper: ");&#13;
       write_str(my_string);&#13;
       write_char('\n');&#13;
   &#13;
       return 0;&#13;
   }</pre>&#13;
   <p class="list" id="ch16list1"><em>Listing 16-1: A program to make an alphabetic text string uppercase</em></p>&#13;
<span epub:type="pagebreak" id="page_325"/>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>This program, and many that follow in the book, uses the</em> <span class="codeitalic">read_str</span> , <span class="codeitalic">write_char</span> <em>, and</em> <span class="codeitalic">write_str</span> <em>functions that you were asked to write in “Your Turn” <a href="ch14.xhtml#ch14exe4">exercise 14.4</a> on <a href="ch14.xhtml#ch14you1">page 293</a>. If you want to, you can instead use the</em> <span class="codeitalic">gets</span> , <span class="codeitalic">putchar</span> <em>, and</em> <span class="codeitalic">puts</span> <em>functions, respectively, in the C standard library, but you’ll need to make the appropriate changes in the book’s functions that call them because their behavior is a little different.</em></p>&#13;
</div>&#13;
<p class="indent">In <a href="ch16.xhtml#ch16list1">Listing 16-1</a>, we use <span class="literal">#define</span> to give a symbolic name to the maximum number of characters allowed <span class="ent">❶</span>. The <span class="literal">char</span> array needs to have one more element to allow for the terminating <span class="literal">NUL</span> character <span class="ent">❷</span>. The two instances of <span class="literal">#define</span> allow us to easily change the length in one place and make sure that the <span class="literal">char</span> array is the correct length and the correct value gets passed to the <span class="literal">read_str</span> function.</p>&#13;
<p class="indent">You learned in <a href="ch14.xhtml">Chapter 14</a> that when an argument’s name is used to pass a variable to a function, it’s passed by value; a copy of the variable’s value is passed to the called function. If we wanted to pass the address of the variable, we would need to use the <span class="literal">&amp;</span> (address of) operator. C treats array names differently. When the name of an argument is an array, C uses pass by pointer; the address of the beginning of the array is passed to the function instead of a copy of all the values in the array. So, we <em>do not</em> use the <span class="literal">&amp;</span> operator when passing an array as an argument to a function <span class="ent">❸</span>. You’ll learn more about how arrays are implemented in <a href="ch17.xhtml">Chapter 17</a>.</p>&#13;
<p class="indent">Nothing else is new in this <span class="literal">main</span> function, so we’ll move on to the <span class="literal">to_upper</span> subfunction. <a href="ch16.xhtml#ch16list2">Listing 16-2</a> shows the header file for this function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>to_upper.h</em></p>&#13;
</div>&#13;
<pre class="pre">// Convert alphabetic letters in a C string to uppercase.&#13;
&#13;
#ifndef TO_UPPER_H&#13;
#define TO_UPPER_H&#13;
int to_upper(char *dest_ptr, char *src_ptr);&#13;
#endif</pre>&#13;
<p class="list" id="ch16list2"><em>Listing 16-2: The header file for the</em> <span class="codeitalic">to_upper</span> <em>function</em></p>&#13;
<p class="indent">The first argument, <span class="literal">src_ptr</span>, is the address of the text string to be converted, and the second argument, <span class="literal">dest_ptr</span>, is the address where the result of the conversion will be stored. In <a href="ch16.xhtml#ch16list1">Listing 16-1</a>, we passed the same array as both the source and destination arrays, so <span class="literal">to_upper</span> will replace the characters stored in the array with the new values.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16list3">Listing 16-3</a> gives the definition of <span class="literal">to_upper</span>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>to_upper.c</em></p>&#13;
</div>&#13;
<pre class="pre">   // Convert alphabetic letters in a C string to uppercase.&#13;
&#13;
   #include "to_upper.h"&#13;
<span class="ent">➊</span> #define UPMASK 0xdf&#13;
   #define NUL '\0'&#13;
   &#13;
   int to_upper(char *dest_ptr, char *src_ptr)&#13;
   {&#13;
       int count = 0;&#13;
       while (*src_ptr != NUL) {&#13;
        <span class="ent">➋</span> *dest_ptr = *src_ptr &amp; UPMASK;&#13;
           src_ptr++;&#13;
           dest_ptr++;&#13;
           count++;&#13;
       }&#13;
    <span class="ent">➌</span> *dest_ptr = *src_ptr;   // Include NUL&#13;
   &#13;
       return count;&#13;
}</pre>&#13;
<span epub:type="pagebreak" id="page_326"/>&#13;
<p class="list" id="ch16list3"><em>Listing 16-3: A function to convert lowercase alphabetic characters to uppercase</em></p>&#13;
<p class="indent">To make sure bit 5 is <span class="literal">0</span>, we use a mask that has a <span class="literal">0</span> in bit position 5 and <span class="literal">1</span>s elsewhere <span class="ent">❶</span>. While the current character is not the <span class="literal">NUL</span> character, we perform a bitwise AND with the character in the source array, which masks out bit 5 and allows all the other bits to remain the same in the result <span class="ent">❷</span>. The result of this AND operation is stored in the destination array. Don’t forget to include the <span class="literal">NUL</span> character from the input text string <span class="ent">❸</span>! Forgetting to do so is a programming error that won’t show up in testing if the byte in memory following where the output is stored happens to be <span class="literal">0x00</span> (the <span class="literal">NUL</span> character). If you change the length of the input text string, the next byte in memory may not be <span class="literal">0x00</span>. This error might therefore show up in a seemingly random way.</p>&#13;
<p class="indent">Although this function returns a count of the number of characters processed, our <span class="literal">main</span> function does nothing with the value. A calling function doesn’t need to use a returned value, but I usually include a counting algorithm in functions like this for debugging purposes.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16list4">Listing 16-4</a> shows the assembly language the compiler generates for the <span class="literal">to_upper</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>to_upper.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "to_upper.c"&#13;
        .text&#13;
        .align  2&#13;
        .global to_upper&#13;
        .type   to_upper, %function&#13;
to_upper:&#13;
        sub     sp, sp, #32&#13;
        str     x0, [sp, 8]       /// Save destination address&#13;
        str     x1, [sp]          /// Save source address&#13;
        str     wzr, [sp, 28]     /// count = 0;&#13;
        b       .L2&#13;
.L3:&#13;
        ldr     x0, [sp, 8]&#13;
        ldrb    w0, [x0]&#13;
     <span class="ent">➊</span> and     w0, w0, -33       /// -33 = 0xffffffdf&#13;
        and     w1, w0, 255       /// 255 = 0x000000ff&#13;
        ldr     x0, [sp]&#13;
        strb    w1, [x0]&#13;
        ldr     x0, [sp, 8]&#13;
        add     x0, x0, 1&#13;
        str     x0, [sp, 8]&#13;
        ldr     x0, [sp]&#13;
        add     x0, x0, 1&#13;
        str     x0, [sp]&#13;
        ldr     w0, [sp, 28]&#13;
        add     w0, w0, 1&#13;
        str     w0, [sp, 28]&#13;
.L2:&#13;
        ldr     x0, [sp, 8]&#13;
        ldrb    w0, [x0]&#13;
        cmp     w0, 0&#13;
        bne     .L3&#13;
     <span class="ent">➋</span> ldr     x0, [sp, 8]       /// Copy NUL char&#13;
        ldrb    w1, [x0]&#13;
        ldr     x0, [sp]&#13;
        strb    w1, [x0]&#13;
        ldr     w0, [sp, 28]&#13;
        add     sp, sp, 32&#13;
        ret&#13;
        .size   to_upper, .-to_upper&#13;
        .ident  "GCC: (Debian 12.2.0-14) 12.2.0"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<span epub:type="pagebreak" id="page_327"/>&#13;
<p class="list" id="ch16list4"><em>Listing 16-4: The compiler-generated assembly language for the function in <a href="ch16.xhtml#ch16list3">Listing 16-3</a></em></p>&#13;
<p class="indent">You might notice that our compiler structures <span class="literal">while</span> loops such that it is unnecessary to copy the <span class="literal">NUL</span> character after the loop terminates <span class="ent">❷</span>. But we still need to write correct C code, because another compiler might use a different structure for <span class="literal">while</span> loops.</p>&#13;
<p class="indent">After loading the current character from the source <span class="literal">char</span> array, the first <span class="literal">and</span> instruction masks the word in <span class="literal">w0</span> with <span class="literal">-33</span> = <span class="literal">0xffffffdf</span>, which leaves bit 5 equal to <span class="literal">0</span>, thus making sure the character is uppercase <span class="ent">❶</span>. The second <span class="literal">and</span> instruction uses the <span class="literal">0x000000ff</span> mask to leave us with an 8-bit <span class="literal">char</span> in <span class="literal">w0</span>.</p>&#13;
<p class="indent">Treating the characters as bit patterns rather than as numerical values allows us to convert lowercase characters to uppercase while leaving upper-case characters unchanged, without using an <span class="literal">if</span> statement to first test the case of the character.</p>&#13;
<p class="indent">You might be wondering why the compiler used two <span class="literal">and</span> instructions instead of simply using <span class="literal">0xdf</span> as the mask with one <span class="literal">and</span> instruction. To answer this question, let’s look at the basic logic instructions in more detail.</p>&#13;
<h4 class="h4" id="ch16lev2sec2"><em><strong>Basic Logic Instructions</strong></em></h4>&#13;
<p class="noindent"><em>Logic instructions</em> work bitwise—that is, they operate on the individual bits in the corresponding bit positions of the two operands. The three basic logic <span epub:type="pagebreak" id="page_328"/>instructions are for the AND, OR, or XOR operations. The A64 instruction set includes two versions for each operation. The shifted register versions allow you to shift one of the source operands before applying the operation. The immediate data versions allow only certain bit patterns, which I’ll explain after describing the instructions:</p>&#13;
<h5 class="h5" id="ch16lev3sec1"><span class="codestrong">and</span><strong>—AND shifted register</strong></h5>&#13;
<p class="noindentin"><span class="literal">and w</span><span class="codeitalic">d</span> <span class="literal">, w</span><span class="codeitalic">s1</span> <span class="literal">, w</span><span class="codeitalic">s2</span> <span class="literal">{,</span> <span class="codeitalic">shft amnt</span> <span class="literal">}</span> performs a bitwise AND between the values in <span class="literal">w</span><span class="codeitalic">s1</span> and <span class="literal">w</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">w</span><span class="codeitalic">d</span>. The value from <span class="literal">w</span><span class="codeitalic">s2</span> can be shifted 0 to 31 bits before the AND operation using the <span class="codeitalic">shft amnt</span> option.</p>&#13;
<p class="noindentin"><span class="literal">and x</span><span class="codeitalic">d</span> <span class="literal">, x</span><span class="codeitalic">s1</span> <span class="literal">, x</span><span class="codeitalic">s2</span> <span class="literal">{,</span> <span class="codeitalic">shft amnt</span> <span class="literal">}</span> performs a bitwise AND between the values in <span class="literal">x</span><span class="codeitalic">s1</span> and <span class="literal">x</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">x</span><span class="codeitalic">d</span>. The value from <span class="literal">x</span><span class="codeitalic">s2</span> can be shifted 0 to 63 bits before the AND operation using the <span class="codeitalic">shft amnt</span> option.</p>&#13;
<h5 class="h5" id="ch16lev3sec2"><span class="codestrong">and</span><strong>—AND immediate</strong></h5>&#13;
<p class="noindentin"><span class="literal">and w</span><span class="codeitalic">d</span> <span class="literal">, w</span><span class="codeitalic">s</span> <span class="literal">,</span> <span class="codeitalic">imm</span> performs a bitwise AND between the 32-bit pattern of <span class="codeitalic">imm</span> and the value in <span class="literal">w</span><span class="codeitalic">s</span> and stores the result in <span class="literal">w</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">and x</span><span class="codeitalic">d</span> <span class="literal">, x</span><span class="codeitalic">s</span> <span class="literal">,</span> <span class="codeitalic">imm</span> performs a bitwise AND between the 64-bit pattern of <span class="codeitalic">imm</span> and the value in <span class="literal">x</span><span class="codeitalic">s</span> and stores the result in <span class="literal">x</span><span class="codeitalic">d</span>.</p>&#13;
<h5 class="h5" id="ch16lev3sec3"><span class="codestrong">orr</span><strong>—Inclusive OR shifted register</strong></h5>&#13;
<p class="noindentin"><span class="literal">orr w</span><span class="codeitalic">d</span> <span class="literal">, w</span><span class="codeitalic">s1</span> <span class="literal">, w</span><span class="codeitalic">s2</span> <span class="literal">{,</span> <span class="codeitalic">shft amnt</span> <span class="literal">}</span> performs a bitwise OR between the values in <span class="literal">w</span><span class="codeitalic">s1</span> and <span class="literal">w</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">w</span><span class="codeitalic">d</span>. The value from <span class="literal">w</span><span class="codeitalic">s2</span> can be shifted 0 to 31 bits before the OR operation using the <span class="codeitalic">shft amnt</span> option.</p>&#13;
<p class="noindentin"><span class="literal">orr x</span><span class="codeitalic">d</span> <span class="literal">, x</span><span class="codeitalic">s1</span> <span class="literal">, x</span><span class="codeitalic">s2</span> <span class="literal">{,</span> <span class="codeitalic">shft amnt</span> <span class="literal">}</span> performs a bitwise OR between the values in <span class="literal">x</span><span class="codeitalic">s1</span> and <span class="literal">x</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">x</span><span class="codeitalic">d</span>. The value from <span class="literal">x</span><span class="codeitalic">s2</span> can be shifted 0 to 63 bits before the OR operation using the <span class="codeitalic">shft amnt</span> option.</p>&#13;
<h5 class="h5" id="ch16lev3sec4"><span class="codestrong">orr</span><strong>—Inclusive OR immediate</strong></h5>&#13;
<p class="noindentin"><span class="literal">orr w</span><span class="codeitalic">d</span> <span class="literal">, w</span><span class="codeitalic">s</span> <span class="literal">,</span> <span class="codeitalic">imm</span> performs a bitwise OR between the 32-bit pattern of <span class="codeitalic">imm</span> and the value in <span class="literal">w</span><span class="codeitalic">s</span> and stores the result in <span class="literal">w</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">orr x</span><span class="codeitalic">d</span> <span class="literal">, x</span><span class="codeitalic">s</span> <span class="literal">,</span> <span class="codeitalic">imm</span> performs a bitwise OR between the 64-bit pattern of <span class="codeitalic">imm</span> and the value in <span class="literal">x</span><span class="codeitalic">s</span> and stores the result in <span class="literal">x</span><span class="codeitalic">d</span>.</p>&#13;
<h5 class="h5" id="ch16lev3sec5"><span class="codestrong">eor</span><strong>—Exclusive OR shifted register</strong></h5>&#13;
<p class="noindentin"><span class="literal">eor w</span><span class="codeitalic">d</span> <span class="literal">, w</span><span class="codeitalic">s1</span> <span class="literal">, w</span><span class="codeitalic">s2</span> <span class="literal">{,</span> <span class="codeitalic">shft amnt</span> <span class="literal">}</span> performs a bitwise XOR between the values in <span class="literal">w</span><span class="codeitalic">s1</span> and <span class="literal">w</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">w</span><span class="codeitalic">d</span>. The value from <span class="literal">w</span><span class="codeitalic">s2</span> can be shifted 0 to 31 bits before the XOR operation using the <span class="codeitalic">shft amnt</span> option.</p>&#13;
<p class="noindentin"><span class="literal">eor x</span><span class="codeitalic">d</span> <span class="literal">, x</span><span class="codeitalic">s1</span> <span class="literal">, x</span><span class="codeitalic">s2</span> <span class="literal">{,</span> <span class="codeitalic">shft amnt</span> <span class="literal">}</span> performs a bitwise XOR between the values in <span class="literal">x</span><span class="codeitalic">s1</span> and <span class="literal">x</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">x</span><span class="codeitalic">d</span>. The value from <span class="literal">x</span><span class="codeitalic">s2</span> can be shifted 0 to 63 bits before the XOR operation using the <span class="codeitalic">shft amnt</span> option.</p>&#13;
<h5 class="h5" id="ch16lev3sec6"><span class="codestrong">eor</span><strong>—Exclusive OR immediate</strong></h5>&#13;
<p class="noindentin"><span class="literal">eor w</span><span class="codeitalic">d</span> <span class="literal">, w</span><span class="codeitalic">s</span> <span class="literal">,</span> <span class="codeitalic">imm</span> performs a bitwise XOR between the 32-bit pattern of <span class="codeitalic">imm</span> and the value in <span class="literal">w</span><span class="codeitalic">s</span> and stores the result in <span class="literal">w</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">eor x</span><span class="codeitalic">d</span> <span class="literal">, x</span><span class="codeitalic">s</span> <span class="literal">,</span> <span class="codeitalic">imm</span> performs a bitwise XOR between the 64-bit pattern of <span class="codeitalic">imm</span> and the value in <span class="literal">x</span><span class="codeitalic">s</span> and stores the result in <span class="literal">x</span><span class="codeitalic">d</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_329"/><a href="ch16.xhtml#ch16tab1">Table 16-1</a> lists the allowable values for the <span class="codeitalic">shft</span> option.</p>&#13;
<p class="tabcap" id="ch16tab1"><strong>Table 16-1:</strong> Allowable Values for <span class="codeitalic">shft</span> in Shifted Register Logic Instructions</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><span class="codestrongitalic">shft</span></th>&#13;
<th class="tab_th"><strong>Effect</strong></th></tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">lsl</span></td>&#13;
<td class="bg1">Logical shift left</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">lsr</span></td>&#13;
<td class="bg">Logical shift right</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">asr</span></td>&#13;
<td class="bg1">Arithmetic shift right</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">ror</span></td>&#13;
<td class="bg">Rotate right</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">A logical shift fills the vacated bits with <span class="literal">0</span>s. An arithmetic shift fills the vacated bits with copies of the high-order bit of the value being shifted. A right rotation shifts all the bits to the right, moving the low-order bits to the high-order positions. The 32-bit versions of these logic instructions do not change the 32 high-order bits in the destination register, so a shift or rotation of a <span class="literal">w</span><span class="codeitalic">s</span> register applies only to the low-order 32 bits of the corresponding <span class="literal">x</span><span class="codeitalic">s</span> register.</p>&#13;
<p class="indent">You learned in <a href="ch12.xhtml">Chapter 12</a> that the <span class="codeitalic">imm</span> values in these logic instructions cannot be 32 or 64 bits. To see how these three instructions encode the <span class="codeitalic">imm</span> value, let’s take a look at the machine code for the first <span class="literal">and</span> instruction in <a href="ch16.xhtml#ch16list4">Listing 16-4</a>, shown in <a href="ch16.xhtml#ch16fig1">Figure 16-1</a>.</p>&#13;
<div class="image"><img id="ch16fig1" src="../images/pg357_Image_283.jpg" alt="Image" width="668" height="82"/></div>&#13;
<p class="figcap"><em>Figure 16-1: The machine code for the</em> <span class="codeitalic">and w0, w0, -33</span> <em>instruction in <a href="ch16.xhtml#ch16list4">Listing 16-4</a></em></p>&#13;
<p class="indent">The <span class="literal">0</span> in the <span class="literal">N</span> field specifies a 32-bit operation. A <span class="literal">1</span> would specify a 64-bit operation.</p>&#13;
<p class="indent">The <span class="literal">imms</span> field specifies two numbers: the number of bits in a repeating pattern and the number of consecutive <span class="literal">1</span>s in the pattern. I’ll use <a href="ch16.xhtml#ch16tab2">Table 16-2</a> to explain how this works.</p>&#13;
<p class="tabcap" id="ch16tab2"><strong>Table 16-2:</strong> Encoding <span class="literal">imms</span> Values in Immediate Logic Instructions</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><span class="codestrong">N</span></th>&#13;
<th class="tab_th"><span class="codestrong">imms</span></th>&#13;
<th class="tab_th"><strong>Pattern size (bits)</strong></th>&#13;
<th class="tab_th"><strong>Number of <span class="codestrong">1</span>s</strong></th></tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">11110x</span></td>&#13;
<td class="bg1">2</td>&#13;
<td class="bg1">1</td></tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1110xx</span></td>&#13;
<td class="bg">4</td>&#13;
<td class="bg">1–3</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">110xxx</span></td>&#13;
<td class="bg1">8</td>&#13;
<td class="bg1">1–7</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">10xxxx</span></td>&#13;
<td class="bg">16</td>&#13;
<td class="bg">1–15</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0xxxxx</span></td>&#13;
<td class="bg1">32</td>&#13;
<td class="bg1">1–31</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">xxxxxx</span></td>&#13;
<td class="bg">64</td>&#13;
<td class="bg">1–63</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_330"/>For the rows with <span class="literal">0</span> in the <span class="literal">N</span> column, the location of the first <span class="literal">0</span> in the <span class="literal">imms</span> column (reading from the left) specifies the number of bits in the pattern. The <span class="literal">1</span> in the <span class="literal">N</span> column specifies a 64-bit pattern.</p>&#13;
<p class="indent">In each row, the binary number in the <span class="literal">x</span> positions plus 1 specifies the number of consecutive <span class="literal">1</span>s in the pattern, starting from the right-hand side. For example, if <span class="literal">N</span> is <span class="literal">0</span> and <span class="literal">imms</span> is <span class="literal">110010</span>, this specifies an 8-bit pattern with three consecutive <span class="literal">1</span>s. This would result in the 32-bit mask <span class="literal">0x07070707</span>.</p>&#13;
<p class="indent">The 6-bit number in the <span class="literal">immr</span> field of the <span class="literal">and</span> instruction that’s shown in <a href="ch16.xhtml#ch16fig1">Figure 16-1</a> specifies the number of right rotations to be applied to the mask before the logical operation.</p>&#13;
<p class="indent">The mask specified in this instruction starts with a 32-bit pattern with 31 consecutive <span class="literal">1</span>s, <span class="literal">0x7fffffff</span>, that occurs only once. This pattern then gets rotated 26 bits to the right to give <span class="literal">0xffffffdf</span> for the mask that is used in the AND operation.</p>&#13;
<p class="indent">Next, I’ll show you a way to write this program directly in assembly language.</p>&#13;
<h4 class="h4" id="ch16lev2sec3"><em><strong>Bitmasking in Assembly Language</strong></em></h4>&#13;
<p class="noindent">We’ll use the same masking algorithm in our assembly language version, but we’ll use identifiers that make it easier to see what’s going on. <a href="ch16.xhtml#ch16list5">Listing 16-5</a> shows the <span class="literal">main</span> function written in assembly language.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>uppercase.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Make an alphabetic text string uppercase.&#13;
        .arch armv8-a&#13;
// Useful constant&#13;
        .equ    MAX,50                    // Character limit&#13;
// Stack frame&#13;
        .equ    the_string, 16&#13;
      <span class="ent">➊</span> .equ    FRAME, 80                 // Allows &gt;51 bytes&#13;
// Code&#13;
        .text&#13;
        .section  .rodata&#13;
        .align  3&#13;
prompt:&#13;
        .string "Enter up to 50 alphabetic characters: "&#13;
result:&#13;
        .string "All upper: "&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
        stp     fp, lr, [sp, -FRAME]! // Create stack frame&#13;
        mov     fp, sp                // Set our frame pointer&#13;
        adr     x0, prompt            // Prompt message&#13;
        bl      write_str             // Ask for input&#13;
&#13;
        add     x0, sp, the_string    // Place to store string&#13;
        mov     w1, MAX               // Limit number of input chars&#13;
        bl      read_str              // Get from keyboard&#13;
&#13;
        add     x1, sp, the_string    // Address of string&#13;
     <span class="ent">➋</span> mov     x0, x1                // Replace the string&#13;
        bl      to_upper              // Do conversion&#13;
&#13;
        adr     x0, result            // Show result&#13;
        bl      write_str&#13;
        add     x0, sp, the_string    // Converted string&#13;
        bl      write_str&#13;
        mov     w0, '\n'              // Nice formatting&#13;
        bl      write_char&#13;
&#13;
        mov     w0, 0                 // Return 0&#13;
        ldp     x29, x30, [sp], FRAME // Delete stack frame&#13;
        ret</pre>&#13;
<span epub:type="pagebreak" id="page_331"/>&#13;
<p class="list" id="ch16list5"><em>Listing 16-5: A program to make a text string uppercase</em></p>&#13;
<p class="indent">We have allocated 50 bytes on the stack for our character array. Adding 16 bytes to save <span class="literal">sp</span> and <span class="literal">fp</span> takes us to a frame size of at least 66 bytes. To keep the stack pointer properly aligned on a 16-byte boundary, we allocate 80 bytes for the stack frame <span class="ent">❶</span>.</p>&#13;
<p class="indent">We pass the address of our <span class="literal">char</span> array to the <span class="literal">to_upper</span> function as both the source and the destination, so it will replace the original values in the array with the new ones <span class="ent">❷</span>.</p>&#13;
<p class="indent">I’ll use the same masking algorithm as the compiler to write <span class="literal">to_upper</span> in assembly language, but I’ll structure the function differently. <a href="ch16.xhtml#ch16list6">Listing 16-6</a> shows the code.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>to_upper.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Convert alphabetic letters in a C string to uppercase.&#13;
// Calling sequence:&#13;
//    x0 &lt;- pointer to result&#13;
//    x1 &lt;- pointer to string to convert&#13;
//    Return number of characters converted.&#13;
        .arch armv8-a&#13;
// Useful constant&#13;
     <span class="ent">➊</span> .equ    UPMASK, 0xdf&#13;
// Program code&#13;
        .text&#13;
        .align  2&#13;
        .global to_upper&#13;
        .type   to_upper, %function&#13;
to_upper:&#13;
        mov     w2, wzr               // counter = 0&#13;
loop:&#13;
     <span class="ent">➋</span> ldrb    w3, [x1]              // Load character&#13;
        cbz     w3, allDone           // All done if NUL char&#13;
     <span class="ent">➌</span> movz    w4, UPMASK            // If not, do masking&#13;
        and     w3, w3, w4            // Mask to upper&#13;
        strb    w3, [x0]              // Store result&#13;
        add     x0, x0, 1             // Increment destination pointer,&#13;
        add     x1, x1, 1             //   source pointer,&#13;
        add     w2, w2, 1             //   and counter,&#13;
        b       loop                  //   and continue&#13;
done:&#13;
        strb    w3, [x0]              // Terminating NUL got us here&#13;
        mov     w0, w2                // Return count&#13;
        ret                           // Back to caller</pre>&#13;
<span epub:type="pagebreak" id="page_332"/>&#13;
<p class="list" id="ch16list6"><em>Listing 16-6: A program to convert text to uppercase</em></p>&#13;
<p class="indent">We’re using registers <span class="literal">w2</span>, <span class="literal">w3</span>, and <span class="literal">w4</span> for our local variables instead of placing them in our stack frame. The standard says we don’t need to save the contents of these registers for the calling function.</p>&#13;
<p class="indent">The <span class="literal">ldrb</span> instruction loads a character into a <span class="literal">w</span> register <span class="ent">❷</span>. We need to use a 32-bit mask to match the width of the register. The correct mask for this algorithm is <span class="literal">0x000000df</span> <span class="ent">❶</span>. The compiler uses two masks to achieve the correct result:</p>&#13;
<pre class="pre">and     w3, w3, -33&#13;
and     w3, w3, 255</pre>&#13;
<p class="indent">The <span class="literal">ldrb</span> instruction zeros the 24 high-order bits in the register, so we could use only the first instruction. But this might confuse a person maintaining this code, since the algorithm works with bit patterns, not integers, and writing the instruction as</p>&#13;
<pre class="pre">and     w3, w3, 0xffffffdf</pre>&#13;
<p class="noindent">could be even more confusing.</p>&#13;
<p class="indent">Our use of the <span class="literal">movz</span> instruction to load the correct mask into a register clearly shows our intent <span class="ent">❸</span>. Then, we use the register form of the <span class="literal">and</span> instruction to mask out the lowercase bit in the character. In the next section, I’ll show you ways to shift bits to multiply or divide a value by powers of two.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch16exe1">16.1     Write a program in assembly language that converts all alphabetic characters to lowercase.</p>&#13;
<p class="box-list1" id="ch16exe2">16.2     Write a program in assembly language that changes the case of all alphabetic characters to the opposite case.</p>&#13;
<p class="box-list1"><span epub:type="pagebreak" id="page_333"/>16.3     Write a program in assembly language that converts all alphabetic characters to uppercase and to lowercase. Your program should also show the user’s original input string after displaying both the upper-case and lowercase conversions.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch16lev1sec2"><strong>Shifting Bits</strong></h3>&#13;
<p class="noindent">It’s sometimes useful to be able to shift all the bits in a variable to the left or to the right. If the variable is an integer, shifting all the bits one position to the left effectively multiplies the integer by two, and shifting them one position to the right effectively divides it by two. Using left/right shifts to do multiplication/division by powers of two is very efficient.</p>&#13;
<h4 class="h4" id="ch16lev2sec4"><em><strong>In C</strong></em></h4>&#13;
<p class="noindent">I’ll cover shifts by showing you a program that reads an integer entered in hexadecimal from the keyboard and stores it as a <span class="literal">long int</span>. The program reads up to eight hexadecimal characters, <span class="literal">0</span>, <span class="literal">1</span>, . . . , <span class="literal">f</span>, each in 8-bit ASCII code and representing a 4-bit integer: 0, 1, . . . , 15.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16list7">Listing 16-7</a> shows the <span class="literal">main</span> function for this program.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>convert_hex.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Get a hex number from the user and store it as an int.&#13;
&#13;
#include &lt;stdio.h&gt;&#13;
#include "write_str.h"&#13;
#include "read_str.h"&#13;
#include "hex_to_int.h"&#13;
&#13;
#define MAX 8&#13;
#define ARRAY_SZ MAX+1&#13;
&#13;
int main()&#13;
{&#13;
    char the_string[ARRAY_SZ];&#13;
    int the_int;&#13;
&#13;
    write_str("Enter up to 8 hex characters: ");&#13;
    read_str(the_string, MAX);&#13;
&#13;
    hex_to_int(&amp;the_int, the_string);&#13;
    printf("0x%x = %i\n", the_int, the_int);&#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch16list7"><em>Listing 16-7: A program to convert hexadecimal input to an</em> <span class="codeitalic">int</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_334"/>In “Your Turn” <a href="ch14.xhtml#ch14exe4">exercise 14.4</a> on <a href="ch14.xhtml#ch14you1">page 293</a>, you designed the <span class="literal">read_str</span> function to limit the number of characters it will store in the <span class="literal">char</span> array passed to it. If the user enters more than eight characters, <span class="literal">read_str</span> will terminate the string with a <span class="literal">NUL</span> character and discard the excess characters.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16list8">Listing 16-8</a> shows the header file for the <span class="literal">hex_to_int</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>hex_to_int.h</em></p>&#13;
</div>&#13;
<pre class="pre">// Convert a hex character string to an int.&#13;
// Return number of characters.&#13;
&#13;
#ifndef HEX_TO_INT_H&#13;
#define HEX_TO_INT_H&#13;
int hex_to_int(int *int_ptr, char *string_ptr);&#13;
#endif</pre>&#13;
<p class="list" id="ch16list8"><em>Listing 16-8: The header file for the</em> <span class="codeitalic">hex_to_int</span> <em>function</em></p>&#13;
<p class="indent">The header file declares the <span class="literal">hex_to_int</span> function, which takes two pointers. The <span class="literal">char</span> pointer is the input, and the <span class="literal">long int</span> pointer is the location for the primary output. The <span class="literal">hex_to_int</span> function also returns an <span class="literal">int</span> that gives the number of characters it converted.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16list9">Listing 16-9</a> shows the definition of the <span class="literal">hex_to_int</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>hex_to_int.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Convert a hex character string to an int.&#13;
// Return number of characters.&#13;
&#13;
#include "hex_to_int.h"&#13;
#define GAP 0x07&#13;
#define INTPART 0x0f  // Also works for lowercase&#13;
#define NUL '\0'&#13;
&#13;
int hex_to_int(int *int_ptr, char *string_ptr)&#13;
{&#13;
    char current;&#13;
    int result;&#13;
    int count;&#13;
&#13;
    count = 0;&#13;
 <span class="ent">➊</span> result = 0;&#13;
    current = *string_ptr;&#13;
    while (current != NUL) {&#13;
     <span class="ent">➋</span> if (current &gt; '9') {&#13;
            current -= GAP;&#13;
        }&#13;
     <span class="ent">➌</span> current = current &amp; INTPART;&#13;
     <span class="ent">➍</span> result = result &lt;&lt; 4;&#13;
     <span class="ent">➎</span> result |= current;&#13;
        string_ptr++;&#13;
        count++;&#13;
        current = *string_ptr;&#13;
    }&#13;
&#13;
    *int_ptr = result;&#13;
    return count;&#13;
}</pre>&#13;
<span epub:type="pagebreak" id="page_335"/>&#13;
<p class="list" id="ch16list9"><em>Listing 16-9: The</em> <span class="codeitalic">hex_to_int</span> <em>function in C</em></p>&#13;
<p class="indent">Our program first sets the 32-bit output to <span class="literal">0</span> <span class="ent">❶</span>. Then, starting with the most significant hexadecimal character (the first one entered by the user), the program converts each 8-bit ASCII code to its corresponding 4-bit integer.</p>&#13;
<p class="indent">Looking at <a href="ch02.xhtml#ch2tab4">Tables 2-4</a> and <a href="ch02.xhtml#ch2tab5">2-5</a> in <a href="ch02.xhtml">Chapter 2</a>, we see that the ASCII codes for the numeric characters range from <span class="literal">0x30</span> to <span class="literal">0x39</span>, and for the lowercase alphabetic characters, they range from <span class="literal">0x61</span> to <span class="literal">0x66</span>. Subtracting this <span class="literal">0x27</span> gap from the alphabetic characters gives us the bit patterns <span class="literal">0x30</span>, <span class="literal">0x31</span>, . . . , <span class="literal">0x39</span>, <span class="literal">0x3a</span>, . . . , <span class="literal">0x3f</span> for the characters entered <span class="ent">❷</span>. Of course, the user may enter uppercase alphabetic characters, which range from <span class="literal">0x41</span> to <span class="literal">0x46</span>. Subtracting <span class="literal">0x27</span> then gives us <span class="literal">0x30</span>, <span class="literal">0x31</span>, . . . , <span class="literal">0x39</span>, <span class="literal">0x1a</span>, . . . , <span class="literal">0x1f</span>. Each hexadecimal character represents 4 bits, and if we look at the low-order 4 bits after subtracting <span class="literal">0x27</span>, they are the same whether the user enters lowercase or uppercase alphabetic characters. We can convert the character code to a 4-bit integer by masking off the upper 4 bits with the bit pattern <span class="literal">0x0f</span> using <span class="literal">&amp;</span>, the C bitwise AND operator <span class="ent">❸</span>.</p>&#13;
<p class="indent">Next, we shift all the bits in the accumulated value 4 bits to the left to make room for the next 4 bits represented by the hexadecimal character <span class="ent">❹</span>. The left shift leaves <span class="literal">0</span>s in the four least significant bit positions, so we can copy the 4 bits in <span class="literal">current</span> into these positions using <span class="literal">|</span>, the bitwise OR operator <span class="ent">❺</span>.</p>&#13;
<p class="indent">The type of the <span class="literal">current</span> variable is <span class="literal">char</span>, and the type of <span class="literal">result</span> is <span class="literal">int</span>. In C, the width of a narrower value will automatically be extended to match the width of a wider value for arithmetic and logic operations <span class="ent">❺</span>.</p>&#13;
<p class="indent">Let’s look at the assembly language the compiler generates for the <span class="literal">hex_to_int</span> function, shown in <a href="ch16.xhtml#ch16list10">Listing 16-10</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>hex_to_int.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "hex_to_int.c"&#13;
        .text&#13;
        .align  2&#13;
        .global hex_to_int&#13;
        .type   hex_to_int, %function&#13;
hex_to_int:&#13;
        sub     sp, sp, #32&#13;
        str     x0, [sp, 8]&#13;
        str     x1, [sp]&#13;
        str     wzr, [sp, 20]&#13;
        str     wzr, [sp, 24]&#13;
        ldr     x0, [sp]&#13;
        ldrb    w0, [x0]&#13;
        strb    w0, [sp, 31]&#13;
        b       .L2&#13;
.L4:&#13;
        ldrb    w0, [sp, 31]&#13;
        cmp     w0, 57        /// &gt; '9'?&#13;
        bls     .L3&#13;
        ldrb    w0, [sp, 31]  /// Yes&#13;
        sub     w0, w0, #7    /// Remove gap&#13;
        strb    w0, [sp, 31]&#13;
.L3:&#13;
     <span class="ent">➊</span> ldrb    w0, [sp, 31]&#13;
     <span class="ent">➋</span> and     w0, w0, 15    /// Leave only 4 bits&#13;
        strb    w0, [sp, 31]&#13;
        ldr     w0, [sp, 24]&#13;
     <span class="ent">➌</span> lsl     w0, w0, 4     /// Room for 4 bits&#13;
        str     w0, [sp, 24]&#13;
        ldrb    w0, [sp, 31]&#13;
        ldr     w1, [sp, 24]&#13;
        orr     w0, w1, w0    /// Copy new 4 bits&#13;
        str     w0, [sp, 24]&#13;
        ldr     x0, [sp]&#13;
        add     x0, x0, 1&#13;
        str     x0, [sp]&#13;
        ldr     w0, [sp, 20]&#13;
        add     w0, w0, 1&#13;
        str     w0, [sp, 20]&#13;
        ldr     x0, [sp]&#13;
        ldrb    w0, [x0]&#13;
        strb    w0, [sp, 31]&#13;
.L2:&#13;
        ldrb    w0, [sp, 31]&#13;
        cmp     w0, 0         /// NUL&#13;
        bne     .L4&#13;
        ldr     x0, [sp, 8]&#13;
        ldr     w1, [sp, 24]&#13;
        str     w1, [x0]&#13;
        ldr     w0, [sp, 20]&#13;
        add     sp, sp, 32&#13;
        ret&#13;
        .size   hex_to_int, .-hex_to_int&#13;
        .ident  "GCC: (Debian 12.2.0-14) 12.2.0"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<span epub:type="pagebreak" id="page_336"/>&#13;
<p class="list" id="ch16list10"><em>Listing 16-10: The compiler-generated assembly language for the C function in <a href="ch16.xhtml#ch16list9">Listing 16-9</a></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_337"/>The compiler uses the <span class="literal">ldrb</span> instruction to load characters into a <span class="literal">w</span> register <span class="ent">❶</span>. This sets bits 8 through 31 to <span class="literal">0</span>, effectively typecasting the 8-bit <span class="literal">char</span> to a 32-bit <span class="literal">int</span>. This would have occurred even without our explicit type-casting in the C code in <a href="ch16.xhtml#ch16list9">Listing 16-9</a>, but the explicit typecasting more clearly shows our intent and doesn’t affect the efficiency of our code.</p>&#13;
<p class="indent">The mask in this algorithm is four sequential <span class="literal">1</span>s, so the immediate data form of the <span class="literal">and</span> instruction can be used <span class="ent">❷</span>.</p>&#13;
<p class="indent">We see a new instruction here, <span class="literal">lsl</span> <span class="ent">❸</span>. As you can probably guess, this instruction shifts the value in <span class="literal">x0</span> 4 bits to the left and loads the result into <span class="literal">x1</span>. Let’s look at some common shift instructions:</p>&#13;
<h5 class="h5" id="ch16lev3sec7"><span class="codestrong">lsl</span><strong>—Logically shift left immediate</strong></h5>&#13;
<p class="noindentin"><span class="literal">lsl w</span><span class="codeitalic">d</span> <span class="literal">, w</span><span class="codeitalic">s</span> <span class="literal">,</span> <span class="codeitalic">amnt</span> shifts the value in <span class="literal">w</span><span class="codeitalic">s</span> by <span class="codeitalic">amnt</span> bits to the left, with <span class="literal">0</span>s in the vacated bits, and loads the result into <span class="literal">w</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">lsl x</span><span class="codeitalic">d</span> <span class="literal">, x</span><span class="codeitalic">s</span> <span class="literal">,</span> <span class="codeitalic">amnt</span> shifts the value in <span class="literal">x</span><span class="codeitalic">s</span> by <span class="codeitalic">amnt</span> bits to the left, with <span class="literal">0</span>s in the vacated bits, and loads the result into <span class="literal">x</span><span class="codeitalic">d</span>.</p>&#13;
<h5 class="h5" id="ch16lev3sec8"><span class="codestrong">lsr</span><strong>—Logically shift right immediate</strong></h5>&#13;
<p class="noindentin"><span class="literal">lsr w</span><span class="codeitalic">d</span> <span class="literal">, w</span><span class="codeitalic">s</span> <span class="literal">,</span> <span class="codeitalic">amnt</span> shifts the value in <span class="literal">w</span><span class="codeitalic">s</span> by <span class="codeitalic">amnt</span> bits to the right, with <span class="literal">0</span>s in the vacated bits, and loads the result into <span class="literal">w</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">lsr x</span><span class="codeitalic">d</span> <span class="literal">, x</span><span class="codeitalic">s</span> <span class="literal">,</span> <span class="codeitalic">amnt</span> shifts the value in <span class="literal">x</span><span class="codeitalic">s</span> by <span class="codeitalic">amnt</span> bits to the right, with <span class="literal">0</span>s in the vacated bits, and loads the result into <span class="literal">x</span><span class="codeitalic">d</span>.</p>&#13;
<h5 class="h5" id="ch16lev3sec9"><span class="codestrong">asr</span><strong>—Arithmetic shift right immediate</strong></h5>&#13;
<p class="noindentin"><span class="literal">asr w</span><span class="codeitalic">d</span> <span class="literal">, w</span><span class="codeitalic">s</span> <span class="literal">,</span> <span class="codeitalic">amnt</span> shifts the value in <span class="literal">w</span><span class="codeitalic">s</span> by <span class="codeitalic">amnt</span> bits to the right, copying the highest-order bit into the vacated bits, and loads the result into <span class="literal">w</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">asr x</span><span class="codeitalic">d</span> <span class="literal">, x</span><span class="codeitalic">s</span> <span class="literal">,</span> <span class="codeitalic">amnt</span> shifts the value in <span class="literal">x</span><span class="codeitalic">s</span> by <span class="codeitalic">amnt</span> bits to the right, copying the highest-order bit into the vacated bits, and loads the result into <span class="literal">x</span><span class="codeitalic">d</span>.</p>&#13;
<h5 class="h5" id="ch16lev3sec10"><span class="codestrong">ror</span><strong>—Rotate right immediate</strong></h5>&#13;
<p class="noindentin"><span class="literal">ror w</span><span class="codeitalic">d</span> <span class="literal">, w</span><span class="codeitalic">s</span> <span class="literal">,</span> <span class="codeitalic">amnt</span> shifts the value in <span class="literal">w</span><span class="codeitalic">s</span> by <span class="codeitalic">amnt</span> bits to the right, copying the low-order bits into the vacated high-order bits, and loads the result into <span class="literal">w</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">ror x</span><span class="codeitalic">d</span> <span class="literal">, x</span><span class="codeitalic">s</span> <span class="literal">,</span> <span class="codeitalic">amnt</span> shifts the value in <span class="literal">x</span><span class="codeitalic">s</span> by <span class="codeitalic">amnt</span> bits to the right, copying the low-order bits into the vacated high-order bits, and loads the result into <span class="literal">x</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentt">Next, I’ll take a similar approach to writing the hexadecimal-to-integer conversion program in assembly language as I did for the earlier case conversion C program.</p>&#13;
<h4 class="h4" id="ch16lev2sec5"><em><strong>In Assembly Language</strong></em></h4>&#13;
<p class="noindent">I’ll start the design for our <span class="literal">convert_hex</span> program with a diagram of the stack frame for the <span class="literal">main</span> function, shown in <a href="ch16.xhtml#ch16fig2">Figure 16-2</a>.</p>&#13;
<span epub:type="pagebreak" id="page_338"/>&#13;
<div class="image"><img id="ch16fig2" src="../images/pg366_Image_284.jpg" alt="Image" width="534" height="197"/></div>&#13;
<p class="figcap"><em>Figure 16-2: The stack frame for the</em> <span class="codeitalic">convert_hex</span> <em>program</em></p>&#13;
<p class="indent">With this diagram, the assembly language design of the <span class="literal">main</span> function is straightforward, as shown in <a href="ch16.xhtml#ch16list11">Listing 16-11</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>convert_hex.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Get a hex number from the user and store it as an int.&#13;
        .arch armv8-a&#13;
// Useful constant&#13;
        .equ    MAX, 8&#13;
// Stack frame&#13;
        .equ    the_int, 16&#13;
        .equ    the_string, 20&#13;
     <span class="ent">➊</span> .equ    FRAME, 32&#13;
// Code&#13;
        .text&#13;
        .section  .rodata&#13;
        .align  3&#13;
prompt:&#13;
        .string "Enter up to 8 hex characters: "&#13;
format:&#13;
        .string "0x%x = %i\n"&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
        stp     fp, lr, [sp, -FRAME]! // Create stack frame&#13;
        mov     fp, sp                // Our frame pointer&#13;
&#13;
        adr     x0, prompt            // Prompt message&#13;
        bl      write_str             // Ask for input&#13;
&#13;
        add     x0, sp, the_string    // Place to store string&#13;
        mov     w1, MAX               // Limit number of input chars&#13;
        bl      read_str              // Get from keyboard&#13;
&#13;
        add     x1, sp, the_string    // Address of string&#13;
        add     x0, sp, the_int       // Place to store int&#13;
        bl      hex_to_int            // Do conversion&#13;
&#13;
        ldr     w2, [sp, the_int]     // Load int&#13;
        ldr     w1, [sp, the_int]     // printf shows this copy in hex&#13;
        adr     x0, format            // Format string&#13;
        bl      printf&#13;
&#13;
        mov     w0, 0                 // Return 0&#13;
        ldp     x29, x30, [sp], FRAME // Delete stack frame&#13;
        ret</pre>&#13;
<span epub:type="pagebreak" id="page_339"/>&#13;
<p class="list" id="ch16list11"><em>Listing 16-11: The assembly language</em> <span class="codeitalic">main</span> <em>function for converting a hex value to an</em> <span class="codeitalic">int</span></p>&#13;
<p class="indent">There is nothing new in this <span class="literal">main</span> function. In addition to the 16 bytes for saving the <span class="literal">fp</span> and <span class="literal">lr</span> registers and 4 bytes for the <span class="literal">int</span>, we need to allocate 9 bytes in our stack frame for the hexadecimal text string, giving a frame size of at least 29 bytes. The frame size must be a multiple of 16 to keep the stack pointer properly aligned, so we use 32 <span class="ent">❶</span>.</p>&#13;
<p class="indent">We’ll use registers for the variables in our assembly language version of <span class="literal">hex_to_int</span>. Our stack frame will be simple, so we won’t need a diagram to design it. Figure 16-12 shows our function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>hex_to_int.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Convert a hex character string to an int.&#13;
// Calling sequence:&#13;
//    x0 &lt;- pointer to int result&#13;
//    x1 &lt;- pointer to hex character string to convert&#13;
//    Return number of characters converted.&#13;
        .arch armv8-a&#13;
// Useful constants&#13;
        .equ    INTPART, 0x0f         // Also works for lowercase&#13;
        .equ    GAP, 0x07             // Between numerals and alpha&#13;
// Program code&#13;
        .text&#13;
        .align  2&#13;
        .global hex_to_int&#13;
        .type   hex_to_int, %function&#13;
hex_to_int:&#13;
        mov     w2, wzr               // result = 0&#13;
        mov     w3, wzr               // counter = 0&#13;
convert:&#13;
        ldrb    w4, [x1]              // Load character&#13;
        cbz     w4, done              // NUL character?&#13;
        cmp     w4, '9                // Numeral?&#13;
        b.ls    no_gap                // Yes&#13;
        sub     w4, w4, GAP           // No, remove gap&#13;
no_gap:&#13;
        and     w4, w4, INTPART       // 4-bit integer&#13;
        lsl     w2, w2, 4             // Make room for it&#13;
        orr     w2, w2, w4            // Insert new 4-bit integer&#13;
        add     x1, x1, 1             // Increment source pointer&#13;
        add     w3, w3, 1             //   and counter&#13;
        b       convert               //   and continue&#13;
done:&#13;
        str     w2, [x0]              // Output result&#13;
        mov     w0, w3                // Return count&#13;
        ret                           // Back to caller</pre>&#13;
<span epub:type="pagebreak" id="page_340"/>&#13;
<p class="list" id="ch16list12"><em>Listing 16-12: The assembly language version of the</em> <span class="codeitalic">hex_to_int</span> <em>function</em></p>&#13;
<p class="indent">Shifts are good for multiplying and dividing by powers of two, but we also need to be able to multiply and divide by other numbers. We’ll look at multiplying and dividing by arbitrary integers in the next two sections, deferring consideration of fractional and floating-point values until <a href="ch19.xhtml">Chapter 19</a>.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch16exe4">16.4     Modify the C <span class="literal">main</span> function in <a href="ch16.xhtml#ch16list7">Listing 16-7</a> so it displays the number of hexadecimal characters converted. Use the assembly language <span class="literal">hex_to_int</span> function in <a href="ch16.xhtml#ch16list12">Listing 16-12</a> for the conversion.</p>&#13;
<p class="box-list1" id="ch16exe5">16.5     Write a program in assembly language that converts octal input to a <span class="literal">long int</span>.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch16lev1sec3"><strong>Multiplication</strong></h3>&#13;
<p class="noindent">In this section, I’ll cover multiplication by integers that are not powers of two. It can be done using loops, but most general-purpose CPUs include multiply instructions.</p>&#13;
<h4 class="h4" id="ch16lev2sec6"><em><strong>In C</strong></em></h4>&#13;
<p class="noindent">Let’s modify the C program in <a href="ch16.xhtml#ch16list7">Listings 16-7</a> to <a href="ch16.xhtml#ch16list9">16-9</a> to convert decimal number text strings into unsigned integers. When converting from hexadecimal text strings, we shifted the accumulated value 4 bits to the left, thus multiplying it by 16. We’ll use the same algorithm for converting decimal text strings, but this time we’ll multiply by 10 instead of 16.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16list13">Listings 16-13</a> to <a href="ch16.xhtml#ch16list15">16-15</a> show the C program.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>convert_dec.c</em></p>&#13;
</div>&#13;
<pre class="pre">   // Get a decimal number from the user and store it as an int.&#13;
&#13;
   #include &lt;stdio.h&gt;&#13;
   #include "write_str.h"&#13;
   #include "read_str.h"&#13;
   #include "dec_to_int.h"&#13;
<span class="ent">➊</span> #define MAX 11&#13;
   #define ARRAY_SZ MAX+1&#13;
   &#13;
   int main(void)&#13;
   {&#13;
       char the_string[ARRAY_SZ];&#13;
       int the_int;&#13;
   &#13;
       write_str("Enter an integer: ");&#13;
       read_str(the_string, MAX);&#13;
   &#13;
       dec_to_int(&amp;the_int, the_string);&#13;
       printf("\"%s\" is stored as 0x%x\n", the_string, the_int);&#13;
   &#13;
       return 0;&#13;
   }</pre>&#13;
<span epub:type="pagebreak" id="page_341"/>&#13;
<p class="list" id="ch16list13"><em>Listing 16-13: A program to convert decimal input to an</em> <span class="codeitalic">int</span></p>&#13;
<p class="indent">This <span class="literal">main</span> function is very similar to the one for converting hexadecimal input to an <span class="literal">int</span>, but the maximum number of characters in an <span class="literal">int</span> is 10. We need to set <span class="literal">MAX</span> to 11 characters to allow for the possible + or – sign preceding the integer <span class="ent">❶</span>.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16list14">Listing 16-14</a> shows the header file for the <span class="literal">dec_to_int</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>hex_to_int.h</em></p>&#13;
</div>&#13;
<pre class="pre">// Convert a decimal character string to an int.&#13;
// Return number of decimal characters.&#13;
&#13;
#ifndef DEC_TO_INT_H&#13;
#define DEC_TO_INT_H&#13;
int dec_to_int(int *int_ptr, char *string_ptr);&#13;
#endif</pre>&#13;
<p class="list" id="ch16list14"><em>Listing 16-14: The header file for the</em> <span class="codeitalic">dec_to_int</span> <em>function</em></p>&#13;
<p class="indent">The header file declares the <span class="literal">dec_to_int</span> function, which takes two pointers: the <span class="literal">char</span> pointer is the input, and the <span class="literal">int</span> pointer is the location for the primary output. The <span class="literal">dec_to_int</span> function also returns an <span class="literal">int</span> that gives the number of characters it converted.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16list15">Listing 16-15</a> shows the definition of the <span class="literal">dec_to_int</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>dec_to_int.c</em></p>&#13;
</div>&#13;
<pre class="pre">   // Convert a decimal character string to an unsigned int.&#13;
   // Return number of characters.&#13;
   &#13;
   #include &lt;stdio.h&gt;&#13;
   #include &lt;stdbool.h&gt;&#13;
   #include "dec_to_int.h"&#13;
   #define INTMASK 0x0f&#13;
   #define RADIX 10&#13;
   #define NUL '\0'&#13;
<span class="ent">➊</span> int dec_to_int(int *int_ptr, char *string_ptr)&#13;
   {&#13;
       bool negative = false;       // Assume positive&#13;
       int result = 0;&#13;
       int count = 0;&#13;
   &#13;
    <span class="ent">➋</span> if (*string_ptr == '-') {&#13;
           negative = true;&#13;
           string_ptr++;&#13;
    <span class="ent">➌</span> } else if (*string_ptr == '+') {&#13;
           string_ptr++;&#13;
       }&#13;
   &#13;
       while (*string_ptr != NUL) {&#13;
        <span class="ent">➍</span> result = RADIX * result;&#13;
        <span class="ent">➎</span> result += (int)(*string_ptr &amp; INTMASK);&#13;
           string_ptr++;&#13;
           count++;&#13;
       }&#13;
   &#13;
       if (negative) {&#13;
           result = -result;&#13;
       }&#13;
       *int_ptr = result;&#13;
       return count;&#13;
   }</pre>&#13;
<span epub:type="pagebreak" id="page_342"/>&#13;
<p class="list" id="ch16list15"><em>Listing 16-15: The</em> <span class="codeitalic">dec_to_int</span> <em>function in C</em></p>&#13;
<p class="indent">The first thing we need to do is check for a possible + or – sign preceding the number. If there’s a – sign, we set the <span class="literal">negative</span> flag to <span class="literal">true</span> <span class="ent">❷</span>. It’s typical for users to enter positive numbers without a + sign, but we still need to increment the pointer to the first numerical character in the string if there is one <span class="ent">❸</span>.</p>&#13;
<p class="indent">The <span class="literal">RADIX</span> constant is not a power of two, so we can’t do multiplication with a simple left shift <span class="ent">❹</span>.</p>&#13;
<p class="indent">The <span class="literal">string_ptr</span> variable points to a <span class="literal">char</span> <span class="ent">❶</span>. The <span class="literal">char</span> is being masked and added to <span class="literal">result</span>, which is an <span class="literal">int</span>. Most compilers will promote a <span class="literal">char</span> value when it’s assigned to an <span class="literal">int</span> variable, but I prefer to explicitly typecast the value <span class="ent">❺</span>.</p>&#13;
<p class="indent">Let’s look at how the compiler does the multiplication by 10. This is shown in <a href="ch16.xhtml#ch16list16">Listing 16-16</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>dec_to_int.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "dec_to_int.c"&#13;
        .text&#13;
        .align  2&#13;
        .global dec_to_int&#13;
        .type   dec_to_int, %function&#13;
dec_to_int:&#13;
        sub     sp, sp, #32&#13;
        str     x0, [sp, 8]     /// Save int_ptr&#13;
        str     x1, [sp]        /// Save string_ptr&#13;
        strb    wzr, [sp, 31]   /// negative = false;&#13;
        str     wzr, [sp, 24]   /// result = 0;&#13;
        str     wzr, [sp, 20]   /// count = 0;&#13;
        ldr     x0, [sp]&#13;
        ldrb    w0, [x0]&#13;
        cmp     w0, 45&#13;
        bne     .L2&#13;
        mov     w0, 1&#13;
        strb    w0, [sp, 31]&#13;
        ldr     x0, [sp]&#13;
        add     x0, x0, 1&#13;
        str     x0, [sp]&#13;
        b       .L4&#13;
.L2:&#13;
        ldr     x0, [sp]&#13;
        ldrb    w0, [x0]&#13;
        cmp     w0, 43&#13;
        bne     .L4&#13;
        ldr     x0, [sp]&#13;
        add     x0, x0, 1&#13;
        str     x0, [sp]&#13;
        b       .L4&#13;
.L5:&#13;
        ldr     w1, [sp, 24]&#13;
        mov     w0, w1&#13;
     <span class="ent">➊</span> lsl     w0, w0, 2       /// 4 * result&#13;
        add     w0, w0, w1      /// (4 * result) + result&#13;
        lsl     w0, w0, 1       /// 2 * ((4 * result) + result)&#13;
        str     w0, [sp, 24]    /// result = 10 * result;&#13;
        ldr     x0, [sp]&#13;
        ldrb    w0, [x0]&#13;
        and     w0, w0, 15&#13;
        ldr     w1, [sp, 24]&#13;
        add     w0, w1, w0&#13;
        str     w0, [sp, 24]&#13;
        ldr     x0, [sp]&#13;
        add     x0, x0, 1&#13;
        str     x0, [sp]&#13;
        ldr     w0, [sp, 20]&#13;
        add     w0, w0, 1&#13;
        str     w0, [sp, 20]&#13;
.L4:&#13;
        ldr     x0, [sp]&#13;
        ldrb    w0, [x0]&#13;
        cmp     w0, 0&#13;
        bne     .L5&#13;
        ldrb    w0, [sp, 31]    /// Check negative flag&#13;
        cmp     w0, 0&#13;
        beq     .L6&#13;
        ldr     w0, [sp, 24]&#13;
     <span class="ent">➋</span> neg     w0, w0&#13;
        str     w0, [sp, 24]&#13;
.L6:&#13;
        ldr     x0, [sp, 8]&#13;
        ldr     w1, [sp, 24]&#13;
        str     w1, [x0]&#13;
        ldr     w0, [sp, 20]&#13;
        add     sp, sp, 32&#13;
        ret&#13;
        .size   dec_to_int, .-dec_to_int&#13;
        .ident  "GCC: (Debian 12.2.0-14) 12.2.0"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<span epub:type="pagebreak" id="page_343"/>&#13;
<span epub:type="pagebreak" id="page_344"/>&#13;
<p class="list" id="ch16list16"><em>Listing 16-16: The compiler-generated assembly language for the</em> <span class="codeitalic">dec_to_int</span> <em>function in <a href="ch16.xhtml#ch16list15">Listing 16-15</a></em></p>&#13;
<p class="indent">The multiplication instruction usually takes longer for the CPU to execute, so the compiler used a combination of shifting and adding to multiply <span class="literal">result</span> by 10 <span class="ent">❶</span>. This four-instruction sequence is equivalent to the following C statement:</p>&#13;
<pre class="pre">result = 2 * ((4 * result) + result);</pre>&#13;
<p class="noindent">The two multiplications in this statement are by powers of two, so they are done by simple left shifts.</p>&#13;
<p class="indent">Notice that the arithmetic in this conversion algorithm is unsigned. We checked for a – sign at the beginning of the number string, and we negate the converted result at the end if there was a – sign <span class="ent">❷</span>.</p>&#13;
<p class="indent">Using shifts and adds to multiply is limited. To see how the multiplication instructions work, we’ll use one to rewrite our decimal conversion program in assembly language.</p>&#13;
<h4 class="h4" id="ch16lev2sec7"><em><strong>In Assembly Language</strong></em></h4>&#13;
<p class="noindent">The A64 architecture has over a dozen variations of multiply instructions. I’ll show you only a few of them in this book; you can read about the others in the manual.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16fig3">Figure 16-3</a> shows the stack frame design for our assembly language version of the <span class="literal">main</span> function of the program to convert a decimal text string to an <span class="literal">int</span>.</p>&#13;
<span epub:type="pagebreak" id="page_345"/>&#13;
<div class="image"><img id="ch16fig3" src="../images/pg373_Image_285.jpg" alt="Image" width="532" height="197"/></div>&#13;
<p class="figcap"><em>Figure 16-3: The stack frame for the</em> <span class="codeitalic">convert_dec</span> <em>program</em></p>&#13;
<p class="indent">Our assembly language version of the <span class="literal">main</span> function is similar to the C version; it’s shown in <a href="ch16.xhtml#ch16list17">Listing 16-17</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>convert_dec.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Get a decimal number from the user and store it as an int.&#13;
        .arch armv8-a&#13;
// Useful constant&#13;
        .equ    MAX, 12               // Character storage limit&#13;
// Stack frame&#13;
        .equ    the_int, 16&#13;
        .equ    the_string, 20&#13;
        .equ    FRAME, 32&#13;
// Code&#13;
        .text&#13;
        .section  .rodata&#13;
        .align  3&#13;
prompt:&#13;
        .string "Enter an integer: "&#13;
        .align  3&#13;
format:&#13;
        .string "\"%s\" is stored as 0x%x\n"&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
        stp     fp, lr, [sp, -FRAME]! // Create stack frame&#13;
        mov     fp, sp                // Our frame pointer&#13;
        adr     x0, prompt            // Prompt message&#13;
        bl      write_str             // Ask for input&#13;
&#13;
        mov     w1, MAX               // Limit number of input chars&#13;
        add     x0, sp, the_string    // Place to store string&#13;
        bl      read_str              // Get from keyboard&#13;
&#13;
        add     x1, sp, the_string    // Address of string&#13;
        add     x0, sp, the_int       // Place to store the int&#13;
        bl      dec_to_int            // Do conversion&#13;
        ldr     w2, [sp, the_int]     // Load the int&#13;
        add     x1, sp, the_string    // Input text string&#13;
        adr     x0, format            // Format message&#13;
        bl      printf                // Show results&#13;
        mov     w0, wzr               // Return 0&#13;
        ldp     x29, x30, [sp], FRAME // Delete stack frame&#13;
        ret</pre>&#13;
<span epub:type="pagebreak" id="page_346"/>&#13;
<p class="list" id="ch16list17"><em>Listing 16-17: A program to convert decimal values to</em> <span class="codeitalic">int</span> <em>s in assembly language</em></p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16list18">Listing 16-18</a> shows our assembly language version of <span class="literal">dec_to_int</span>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>dec_to_int.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Convert a decimal text string to an int.&#13;
// Calling sequence:&#13;
//    x0 &lt;- place to store int&#13;
//    x1 &lt;- pointer to string&#13;
//    Return number of characters.&#13;
        .arch armv8-a&#13;
// Useful constants&#13;
        .equ    RADIX,10&#13;
        .equ    INTMASK,0x0f&#13;
// Program code&#13;
        .text&#13;
        .align  2&#13;
        .global dec_to_int&#13;
        .type   dec_to_int, %function&#13;
dec_to_int:&#13;
        mov     w2, wzr               // count = 0&#13;
        mov     w3, wzr               // result = 0&#13;
        mov     w4, wzr               // negative = false&#13;
        mov     w5, RADIX             // Handy to have in reg&#13;
&#13;
        ldrb    w6, [x1]              // Load first character&#13;
        cmp     w6, '-                // Minus sign?&#13;
        b.ne    check_pos             // No, check for plus sign&#13;
        mov     x4, 1                 // Yes, negative = true&#13;
        add     x1, x1, 1             // Increment string pointer&#13;
        b       convert               //   and convert numerals&#13;
check_pos:&#13;
        cmp     w6, '+                // Plus sign?&#13;
        b.ne    convert               // No, convert numerals&#13;
        add     x1, x1, 1             // Yes, skip over it&#13;
&#13;
convert:&#13;
        ldrb    w6, [x1]              // Load character&#13;
        cbz     w6, check_sign        // NUL char?&#13;
        and     w6, w6, INTMASK       // No, mask to integer&#13;
     <span class="ent">➊</span> mul     w3, w3, w5            // result * RADIX&#13;
        add     w3, w3, w6            // Add new integer&#13;
        add     w2, w2, 1             // count++&#13;
        add     x1, x1, 1             // string_ptr++&#13;
        b       convert               //   and continue&#13;
check_sign:&#13;
        cbz     w4, positive          // Check negative flag&#13;
        neg     w3, w3                // Negate if flag is true&#13;
positive:&#13;
        str     w3, [x0]              // Output result&#13;
        mov     w0, w2                // Return count&#13;
        ret                           // Back to caller</pre>&#13;
<span epub:type="pagebreak" id="page_347"/>&#13;
<p class="list" id="ch16list18"><em>Listing 16-18: The</em> <span class="codeitalic">dec_to_int</span> <em>function in assembly language</em></p>&#13;
<p class="indent">Instead of using a shift-and-add algorithm to multiply by 10, we’re using the <span class="literal">mul</span> instruction <span class="ent">❶</span>. Let’s look at some variations of this instruction:</p>&#13;
<h5 class="h5" id="ch16lev3sec11"><span class="codestrong">mul</span><strong>—Multiply register</strong></h5>&#13;
<p class="noindentin"><span class="literal">mul w</span><span class="codeitalic">d</span> <span class="literal">, w</span><span class="codeitalic">s1</span> <span class="literal">, w</span><span class="codeitalic">s2</span> multiplies the values in <span class="literal">w</span><span class="codeitalic">s1</span> and <span class="literal">w</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">w</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">mul x</span><span class="codeitalic">d</span> <span class="literal">, x</span><span class="codeitalic">s1</span> <span class="literal">, x</span><span class="codeitalic">s2</span> multiplies the values in <span class="literal">x</span><span class="codeitalic">s1</span> and <span class="literal">x</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">x</span><span class="codeitalic">d</span>.</p>&#13;
<p class="indentgt">When multiplying two <em>n</em>-bit integers, the product can be up to 2<em>n</em> bits wide. Without offering a formal proof here, you can probably be convinced by considering the largest 3-bit number, <span class="literal">111</span>. Add <span class="literal">1</span> to get <span class="literal">1000</span>. From <span class="literal">1000 * 1000 = 1000000</span>, we can conclude that <span class="literal">111 * 111 &lt;= 111111</span>. More precisely, <span class="literal">111 * 111 = 110001</span>.</p>&#13;
<p class="indent">If the result of the <span class="literal">mul</span> instruction exceeds the width of the destination register, the high-order bits are lost. For example, if <span class="literal">w2</span> contains <span class="literal">0xcccccccc</span> and <span class="literal">w1</span> contains <span class="literal">0x00000002</span>, then <span class="literal">mul w0, w1, w2</span> will give <span class="literal">0x0000000099999998</span> in the <span class="literal">x0</span> register. The correct result is <span class="literal">0x0000000199999998</span> if we’re treating these values as unsigned integers and <span class="literal">0xffffffff99999998</span> if we’re treating these values as signed. But when an instruction writes to the <span class="literal">w</span> portion of a register, the high-order 32 bits of that register are set to <span class="literal">0</span>. Thus, the <span class="literal">mul</span> instruction yields an incorrect result if the product of two 32-bit integers is not within the range 0<em>≤ product≤</em> 4,294,967,295 if we’re using unsigned integers and –2,147,483,648<em>≤ product≤</em> +2,147,483,647 if we’re using signed integers.</p>&#13;
<p class="indent">To deal with this size problem, the A64 architecture includes two multiplication instructions that use a 64-bit destination register for the case when the result of multiplying two 32-bit numbers exceeds the range of 32 bits:</p>&#13;
<h5 class="h5" id="ch16lev3sec12"><span class="codestrong">umull</span><strong>—Unsigned multiply long</strong></h5>&#13;
<p class="noindentin"><span class="literal">umull x</span><span class="codeitalic">d</span> <span class="literal">, w</span><span class="codeitalic">s1</span> <span class="literal">, w</span><span class="codeitalic">s2</span> multiplies the values in <span class="literal">w</span><span class="codeitalic">s1</span> and <span class="literal">w</span><span class="codeitalic">s2</span> and loads the result in <span class="literal">x</span><span class="codeitalic">d</span>. If the magnitude of the result doesn’t take up the full 64 bits of <span class="literal">x</span><span class="codeitalic">d</span>, the unoccupied high-order bits are filled with <span class="literal">0</span>s.</p>&#13;
<h5 class="h5" id="ch16lev3sec13"><span class="codestrong">smull</span><strong>—Signed multiply long</strong></h5>&#13;
<p class="noindentin"><span class="literal">smull x</span><span class="codeitalic">d</span> <span class="literal">, w</span><span class="codeitalic">s1</span> <span class="literal">, w</span><span class="codeitalic">s2</span> multiplies the values in <span class="literal">w</span><span class="codeitalic">s1</span> and <span class="literal">w</span><span class="codeitalic">s2</span> and loads the result in <span class="literal">x</span><span class="codeitalic">d</span>. If the magnitude of the result doesn’t take up the full 64 bits <span epub:type="pagebreak" id="page_348"/>of <span class="literal">x</span><span class="codeitalic">d</span>, the unoccupied high-order bits are each filled with a copy of the highest-order bit of the result, thus providing sign extension.</p>&#13;
<p class="indentgt">Continuing with our example, if <span class="literal">w2</span> contains <span class="literal">0xcccccccc</span> and <span class="literal">w1</span> contains <span class="literal">0x00000002</span>, then <span class="literal">umull x0, w1, w2</span> will give <span class="literal">0x0000000199999998</span> in <span class="literal">x0</span> and <span class="literal">smull x0, w1, w2</span> will give <span class="literal">0xffffffff99999998</span>.</p>&#13;
<p class="indent">If we’re using 64-bit <span class="literal">long int</span>s and cannot prove that the result of the multiplication can never exceed 64 bits, the A64 architecture includes two multiplication instructions that will give the high-order 64 bits when multiplying two 64-bit numbers:</p>&#13;
<h5 class="h5" id="ch16lev3sec14"><span class="codestrong">umulh</span><strong>—Unsigned multiply high</strong></h5>&#13;
<p class="noindentin"><span class="literal">umulh x</span><span class="codeitalic">d</span> <span class="literal">, x</span><span class="codeitalic">s1</span> <span class="literal">, x</span><span class="codeitalic">s2</span> multiplies the values in <span class="literal">x</span><span class="codeitalic">s1</span> and <span class="literal">x</span><span class="codeitalic">s2</span> and loads the high-order 64 bits of the result into <span class="literal">x</span><span class="codeitalic">d</span> with zero extension.</p>&#13;
<h5 class="h5" id="ch16lev3sec15"><span class="codestrong">smulh</span><strong>—Signed multiply high</strong></h5>&#13;
<p class="noindentin"><span class="literal">smulh x</span><span class="codeitalic">d</span> <span class="literal">, x</span><span class="codeitalic">s1</span> <span class="literal">, x</span><span class="codeitalic">s2</span> multiplies the values in <span class="literal">x</span><span class="codeitalic">s1</span> and <span class="literal">x</span><span class="codeitalic">s2</span> and loads the high-order 64 bits of the result into <span class="literal">x</span><span class="codeitalic">d</span> with sign extension.</p>&#13;
<p class="indentgt">Thus, the multiplication of two 64-bit integers requires two instructions. We would use the following two instructions if we were treating two integers in <span class="literal">x0</span> and <span class="literal">x1</span> as unsigned:</p>&#13;
<pre class="pre">mul     x3, x0, x1&#13;
umulh   x2, x0, x1</pre>&#13;
<p class="noindent">And we would use the following two instructions if we were treating two integers in <span class="literal">x0</span> and <span class="literal">x1</span> as signed:</p>&#13;
<pre class="pre">mul     x3, x0, x1&#13;
smulh   x2, x0, x1</pre>&#13;
<p class="indent">In both cases, the result is a 128-bit integer with the high-order 64 bits in register <span class="literal">x2</span> and the low-order 64 bits in <span class="literal">x3</span>.</p>&#13;
<p class="indent">The multiply instructions don’t affect the condition flags in the <span class="literal">nzcv</span> register. We need to carefully analyze our algorithms for all possible values and use the appropriate instructions.</p>&#13;
<p class="indent">Next, I’ll cover division, the inverse of multiplication.</p>&#13;
<div class="box">&#13;
<p class="box-title" id="ch16you1"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch16exe6">16.6     Write a <span class="literal">dec_to_uint</span> function in assembly language that converts an unsigned decimal number from its text string format to its <span class="literal">unsigned int</span> format.</p>&#13;
<p class="box-list1" id="ch16exe7">16.7     I asserted that the C statement <span class="literal">result = 2 * ((4 * result) + result);</span> is equivalent to the <span class="literal">result = RADIX * result</span>; statement in <a href="ch16.xhtml#ch16list15">Listing 16-15</a>. Make that change in <a href="ch16.xhtml#ch16list15">Listing 16-15</a> and compare the compiler-generated assembly language with that in <a href="ch16.xhtml#ch16list16">Listing 16-16</a>.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch16lev1sec4"><span epub:type="pagebreak" id="page_349"/><strong>Division</strong></h3>&#13;
<p class="noindent">When multiplying two <em>n</em>-bit numbers, we were concerned about the result being 2<em>n</em> bits wide. In division, the quotient will never be wider than the dividend, but division takes much longer than multiplication. In this section, you’ll learn about an algorithm that can speed up division when the divisor is a constant. Integer division can give a remainder, which may also need to be computed.</p>&#13;
<p class="indent">I’ll start with a C function that converts an <span class="literal">int</span> to the numerical text string it represents, the inverse of the earlier <span class="literal">dec_to_int</span> function.</p>&#13;
<h4 class="h4" id="ch16lev2sec8"><em><strong>In C</strong></em></h4>&#13;
<p class="noindent">Our <span class="literal">main</span> function will read an integer from the user, subtract 123 from it, and show the result. Our subfunction, <span class="literal">int_to_dec</span>, will use a division algorithm to convert a 32-bit <span class="literal">int</span> to the text string that represents it so that the <span class="literal">main</span> function can display the result. <a href="ch16.xhtml#ch16list19">Listings 16-19</a> through <a href="ch16.xhtml#ch16list21">16-21</a> show the complete program.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>sub_123.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Read an int from the user, subtract 123, and display the result.&#13;
&#13;
#include "write_str.h"&#13;
#include "write_char.h"&#13;
#include "read_str.h"&#13;
#include "dec_to_int.h"&#13;
#include "int_to_dec.h"&#13;
#define MAX 11&#13;
#define ARRAY_SZ MAX+1&#13;
&#13;
int main(void)&#13;
{&#13;
    char the_string[ARRAY_SZ];&#13;
    int the_int;&#13;
&#13;
    write_str("Enter an integer: ");&#13;
    read_str(the_string, MAX);&#13;
&#13;
    dec_to_int(&amp;the_int, the_string);&#13;
    the_int -= 123;&#13;
    int_to_dec(the_string, the_int);&#13;
&#13;
    write_str("The result is: ");&#13;
    write_str(the_string);&#13;
    write_char('\n');&#13;
&#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch16list19"><em>Listing 16-19: A program to subtract 123 from an</em> <span class="codeitalic">int</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_350"/>The <span class="literal">main</span> function for this program is quite simple. We use the assembly language version of <span class="literal">dec_to_int</span> in <a href="ch16.xhtml#ch16list18">Listing 16-18</a> to convert the user’s input to an <span class="literal">int</span>. We then subtract 123 from the <span class="literal">int</span>, convert the resulting number to its text string representation, and display the result.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16list20">Listing 16-20</a> shows the header file for the <span class="literal">int_to_dec</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>int_to_dec.h</em></p>&#13;
</div>&#13;
<pre class="pre">// Convert an int to its decimal text string representation.&#13;
// Return number of characters.&#13;
&#13;
#ifndef INT_TO_DEC_H&#13;
#define INT_TO_DEC_H&#13;
int int_to_dec(char *dec_string, int the_int);&#13;
#endif</pre>&#13;
<p class="list" id="ch16list20"><em>Listing 16-20: The header file for the</em> <span class="codeitalic">int_to_dec</span> <em>function</em></p>&#13;
<p class="indent">The header file declares the <span class="literal">int_to_dec</span> function. The <span class="literal">int</span> is the input, and the <span class="literal">char</span> pointer is the location for the primary output. The <span class="literal">int_to_dec</span> function also returns an <span class="literal">int</span> that gives the number of characters in the output string.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16list21">Listing 16-21</a> shows the definition of the <span class="literal">int_to_dec</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>int_to_dec.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Convert an int to its decimal text string representation.&#13;
// Return number of characters.&#13;
&#13;
#include "int_to_dec.h"&#13;
#define ARRAY_SZ 12&#13;
#define ASCII 0x30&#13;
#define RADIX 10&#13;
#define NUL '\0'&#13;
&#13;
int int_to_dec(char *dec_string, int the_int)&#13;
{&#13;
    char reverse[ARRAY_SZ];&#13;
    char digit;&#13;
    char *_ptr;&#13;
    unsigned int working;&#13;
    int count = 0;&#13;
&#13;
 <span class="ent">➊</span> if (the_int &lt; 0) {&#13;
        the_int = -the_int;&#13;
        *dec_string = '-';&#13;
        count++;&#13;
        decString++;&#13;
    }&#13;
    ptr = reverse;                   // Point to local char array&#13;
 <span class="ent">➋</span> *ptr = NUL;                      // Start with termination char&#13;
 <span class="ent">➌</span> working = (unsigned int)the_int; // Use unsigned arithmetic&#13;
    do {&#13;
        ptr++;&#13;
     <span class="ent">➍</span> digit = (char)(working % RADIX);&#13;
        *ptr = ASCII | digit;&#13;
        working = working / RADIX;&#13;
    } while (working &gt; 0);&#13;
&#13;
    count = 0;&#13;
    if (negative) {&#13;
        *dec_string = '-';&#13;
        count++;&#13;
        dec_string++;&#13;
    }&#13;
 <span class="ent">➎</span> do {                            // Reverse string&#13;
        *dec_string = *ptr;&#13;
        count++;&#13;
        dec_string++;&#13;
        ptr--;&#13;
     <span class="ent">➏</span> } while (*ptr != NUL);&#13;
    *dec_string = *ptr;             // Copy termination char&#13;
&#13;
    return count;&#13;
}</pre>&#13;
<span epub:type="pagebreak" id="page_351"/>&#13;
<p class="list" id="ch16list21"><em>Listing 16-21: The</em> <span class="codeitalic">int_to_dec</span> <em>function in C</em></p>&#13;
<p class="indent">The algorithm we’re using to find the characters that represent the <span class="literal">int</span> in decimal involves the repeated integer division of the <span class="literal">int</span> by 10. The <span class="literal">%</span> operator computes the remainder from the division <span class="ent">❹</span>. For positive integers, the remainder will be a 32-bit <span class="literal">int</span> in the range 0 through 9, or <span class="literal">0x00000000</span> through <span class="literal">0x00000009</span>, which is the value of the lowest-order decimal digit.</p>&#13;
<p class="indent">However, for negative integers, the remainder will be an <span class="literal">int</span> in the range 0 through –9, or <span class="literal">0x00000000</span> through <span class="literal">0xfffffff7</span>. The negative values in this range require a different algorithm to convert them to their corresponding ASCII numeric character. The solution we’re using here is to negate an input negative integer, prepend the resulting text string with a – sign, and convert the positive result <span class="ent">❶</span>.</p>&#13;
<p class="indent">This works for all but one 32-bit negative number: –2,147,483,648. There is no 32-bit +2,147,483,648 in two’s complement format; negating –2,147,483,648 gives –2,147,483,648. Our solution is to convert the negated <span class="literal">int</span> to an <span class="literal">unsigned int</span> <span class="ent">❸</span>. This doesn’t change the bit pattern of the value, <span class="literal">0x80000000</span>, but it tells the compiler to use unsigned <span class="literal">%</span> and <span class="literal">/</span> operations. So, for 2,147,483,648, the <span class="literal">working % RADIX</span> operation will give us <span class="literal">0x00000008</span>.</p>&#13;
<p class="indent">We convert the <span class="literal">unsigned int</span> from the <span class="literal">%</span> operation to a <span class="literal">char</span> with <span class="literal">(char)</span>, the <em>cast operator</em> <span class="ent">❹</span>. The parentheses are part of the syntax for a cast operator. Then, we use a bitwise OR operation to convert the <span class="literal">char</span> to its corresponding numeric character in ASCII code.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_352"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Be careful when using a cast operator to convert the type of a value. We’re converting from a 32-bit value to an 8-bit one, which may cause a loss of information. In this case, we know the information will be encoded in 4 bits, so the conversion is safe.</em></p>&#13;
</div>&#13;
<p class="indent">Since this algorithm works from right to left, the characters are stored in reverse order. So, we need to reverse the order of the text string for the calling function <span class="ent">❺</span>. Storing the <span class="literal">NUL</span> character first <span class="ent">❷</span> provides a way to know when the entire text string has been completely copied in reverse order <span class="ent">❻</span>.</p>&#13;
<p class="indent">Next, we’ll look at the assembly language generated by the compiler, shown in <a href="ch16.xhtml#ch16list22">Listing 16-22</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>int_to_dec.s</em></p>&#13;
</div>&#13;
<pre class="pre">.arch armv8-a&#13;
        .file   "int_to_dec.c"&#13;
        .text&#13;
        .align  2&#13;
        .global int_to_dec&#13;
        .type   int_to_dec, %function&#13;
int_to_dec:&#13;
        sub     sp, sp, #48&#13;
        str     x0, [sp, 8]&#13;
        str     w1, [sp, 4]&#13;
        str     wzr, [sp, 32]&#13;
        ldr     w0, [sp, 4]&#13;
        cmp     w0, 0               /// Check for negative&#13;
        bge     .L2&#13;
        ldr     w0, [sp, 4]&#13;
        neg     w0, w0&#13;
        str     w0, [sp, 4]&#13;
        ldr     x0, [sp, 8]&#13;
        mov     w1, 45&#13;
        strb    w1, [x0]&#13;
        ldr     w0, [sp, 32]&#13;
        add     w0, w0, 1&#13;
        str     w0, [sp, 32]&#13;
        ldr     x0, [sp, 8]&#13;
        add     x0, x0, 1&#13;
        str     x0, [sp, 8]&#13;
.L2:&#13;
        add     x0, sp, 16&#13;
        str     x0, [sp, 40]        /// ptr&#13;
        ldr     x0, [sp, 40]&#13;
        strb    wzr, [x0]           /// *ptr = NUL;&#13;
        ldr     w0, [sp, 4]&#13;
        str     w0, [sp, 36]        /// working = the_int;&#13;
.L3:&#13;
        ldr     x0, [sp, 40]&#13;
        add     x0, x0, 1&#13;
        str     x0, [sp, 40]&#13;
        ldr     w2, [sp, 36]&#13;
     <span class="ent">➊</span> mov     w0, 52429           /// 0xcccd&#13;
        movk    w0, 0xcccc, lsl 16  /// 0xcccccccd&#13;
     <span class="ent">➋</span> umull   x0, w2, w0          /// Multiply by 0.1&#13;
        lsr     x0, x0, 32          /// Divide by 2^35&#13;
        lsr     w1, w0, 3&#13;
        mov     w0, w1&#13;
     <span class="ent">➌</span> lsl     w0, w0, 2&#13;
        add     w0, w0, w1&#13;
        lsl     w0, w0, 1&#13;
     <span class="ent">➍</span> sub     w1, w2, w0          /// working % RADIX&#13;
        mov     w0, w1&#13;
        strb    w0, [sp, 31]&#13;
        ldrb    w0, [sp, 31]&#13;
     <span class="ent">➎</span> orr     w0, w0, 48          /// Convert to ASCII&#13;
        and     w1, w0, 255&#13;
        ldr     x0, [sp, 40]&#13;
        strb    w1, [x0]            /// *ptr = ASCII | digit&#13;
        ldr     w1, [sp, 36]&#13;
     <span class="ent">➏</span> mov     w0, 52429&#13;
        movk    w0, 0xcccc, lsl 16&#13;
        umull   x0, w1, w0&#13;
        lsr     x0, x0, 32&#13;
        lsr     w0, w0, 3&#13;
        str     w0, [sp, 36]        /// working = working / RADIX;&#13;
        ldr     w0, [sp, 36]&#13;
        cmp     w0, 0&#13;
        bne     .L3&#13;
.L4:&#13;
        ldr     x0, [sp, 40]&#13;
        ldrb    w1, [x0]&#13;
        ldr     x0, [sp, 8]&#13;
        strb    w1, [x0]&#13;
        ldr     w0, [sp, 32]&#13;
        add     w0, w0, 1&#13;
        str     w0, [sp, 32]&#13;
        ldr     x0, [sp, 8]&#13;
        add     x0, x0, 1&#13;
        str     x0, [sp, 8]&#13;
        ldr     x0, [sp, 40]&#13;
        sub     x0, x0, #1&#13;
        str     x0, [sp, 40]&#13;
        ldr     x0, [sp, 40]&#13;
        ldrb    w0, [x0]&#13;
        cmp     w0, 0&#13;
        bne     .L4&#13;
        ldr     x0, [sp, 40]&#13;
        ldrb    w1, [x0]&#13;
        ldr     x0, [sp, 8]&#13;
        strb    w1, [x0]&#13;
        ldr     w0, [sp, 32]&#13;
        add     sp, sp, 48&#13;
        ret&#13;
        .size   int_to_dec, .-int_to_dec&#13;
        .ident  "GCC: (Debian 12.2.0-14) 12.2.0"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<span epub:type="pagebreak" id="page_353"/>&#13;
<span epub:type="pagebreak" id="page_354"/>&#13;
<p class="list" id="ch16list22"><em>Listing 16-22: The compiler-generated assembly language for the</em> <span class="codeitalic">int_to_dec</span> <em>function in <a href="ch16.xhtml#ch16list21">Listing 16-21</a></em></p>&#13;
<p class="indent">The C algorithm involves division by 10, but the compiler uses a <span class="literal">umull</span> instruction to perform the remainder (<span class="literal">%</span>) operation <span class="ent">❷</span>. This is because division takes much more time than multiplication. Since we’re dividing by a constant, the compiler uses the following arithmetic:</p>&#13;
<p class="center"><img src="../images/pg382_Image_286.jpg" alt="Image" width="124" height="119"/></p>&#13;
<p class="indent">The compiler uses <em>n</em> = 35, giving the constant 2<sup>35</sup>/10 = 3,435,973,836.8. Rounding this to the nearest integer gives 3,435,973,837 = <span class="literal">0xcccccccd</span> <span class="ent">❶</span>. After multiplying the <span class="literal">working</span> integer by this constant, the algorithm shifts the result 35 bits to the right to divide by 2<sup>35</sup>.</p>&#13;
<p class="indent">The compiler then uses the shift-and-add algorithm to multiply this quotient by 10 <span class="ent">❸</span>. Subtracting the result from the original dividend leaves us with the remainder <span class="ent">❹</span>, which is converted to the corresponding ASCII character <span class="ent">❺</span>.</p>&#13;
<p class="indent">The compiler implements the <span class="literal">/</span> operation with the same multiply-and-shift algorithm that it used for the <span class="literal">%</span> operation <span class="ent">❻</span>.</p>&#13;
<p class="indent">Using multiplication and shifts to divide is limited. To see how the division instructions work, we’ll use a divide instruction for our assembly language version of the <span class="literal">int_to_dec</span> function.</p>&#13;
<h4 class="h4" id="ch16lev2sec9"><em><strong>In Assembly Language</strong></em></h4>&#13;
<p class="noindent">We didn’t look at the compiler-generated assembly language for the <span class="literal">main</span> function in the C version of our <span class="literal">sub_123</span> program (<a href="ch16.xhtml#ch16list19">Listing 16-19</a>). It’s similar to our assembly language version, which is shown in <a href="ch16.xhtml#ch16list23">Listing 16-23</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>sub_123.s</em></p>&#13;
</div>&#13;
<pre class="pre">   // Subtract 123 from an integer.&#13;
           .arch armv8-a&#13;
   // Useful constants&#13;
           .equ    CONSTANT, 123         // Number to subtract&#13;
           .equ    MAX, 11               // Maximum digits&#13;
<span class="ent">➊</span> // Stack frame&#13;
           .equ    the_int, 16&#13;
           .equ    the_string, 20&#13;
           .equ    FRAME, 32&#13;
   // Code&#13;
           .text&#13;
           .section  .rodata&#13;
           .align  3&#13;
           prompt:&#13;
           .string "Enter an integer: "&#13;
   message:&#13;
           .string "The result is: "&#13;
           .text&#13;
           .align  2&#13;
           .global main&#13;
           .type   main, %function&#13;
   main:&#13;
           stp     fp, lr, [sp, -FRAME]! // Create stack frame&#13;
           mov     fp, sp                // Our frame pointer&#13;
   &#13;
           adr     x0, prompt            // Prompt message&#13;
           bl      write_str             // Ask for input&#13;
           add     x0, sp, the_string&#13;
           mov     w1, MAX&#13;
           bl      read_str&#13;
   &#13;
           add     x1, sp, the_string    // Input&#13;
           add     x0, sp, the_int       // Place for output&#13;
           bl      dec_to_int            // Convert to int&#13;
   &#13;
           ldr     w1, [sp, the_int]&#13;
           sub     w1, w1, CONSTANT      // Subtract our constant&#13;
           add     x0, sp, the_string    // Place for output&#13;
           bl      int_to_dec            // Convert to text string&#13;
   &#13;
           adr     x0, message           // Tell user that&#13;
           bl      write_str&#13;
           add     x0, sp, the_string    //   this is the result&#13;
           bl      write_str&#13;
           mov     w0, '\n'&#13;
           bl      write_char&#13;
   &#13;
           mov     w0, wzr               // Return 0&#13;
           ldp     fp, lr, [sp], FRAME   // Delete stack frame&#13;
           ret                           // Back to caller</pre>&#13;
<span epub:type="pagebreak" id="page_355"/>&#13;
<p class="list" id="ch16list23"><em>Listing 16-23: The assembly language version of the</em> <span class="codeitalic">main</span> <em>function for the</em> <span class="codeitalic">sub_123</span>  <em>program</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_356"/>There isn’t anything new in the <span class="literal">main</span> function; we can use the same stack frame design from <a href="ch16.xhtml#ch16fig3">Figure 16-3</a> <span class="ent">❶</span>.</p>&#13;
<p class="indent"><a href="ch16.xhtml#ch16list24">Listing 16-24</a> shows our assembly language version of the <span class="literal">int_to_dec</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>int_to_dec.s</em></p>&#13;
</div>&#13;
<pre class="pre">   // Convert an int to its decimal text string representation.&#13;
   // Calling sequence:&#13;
   //    x0 &lt;- place to store string&#13;
   //    w1 &lt;- the int&#13;
   //    Return number of characters in the string.&#13;
           .arch armv8-a&#13;
   // Useful constants&#13;
           .equ    RADIX, 10             // Number base&#13;
           .equ    INT2CHAR, 0x30        // ASCII zero&#13;
           .equ    MINUS, '-             // Minus sign&#13;
<span class="ent">➊</span> // Stack frame&#13;
           .equ    reverse, 0&#13;
           .equ    FRAME, 16&#13;
   // Code&#13;
           .text&#13;
           .align  2&#13;
           .global int_to_dec&#13;
           .type   int_to_dec, %function&#13;
   int_to_dec:&#13;
           sub     sp, sp, FRAME         // Local string on stack&#13;
   &#13;
           cmp     w1, wzr               // =&gt; 0?&#13;
           tbz     w1, 31, non_negative  // Yes, go to conversion&#13;
           neg     w1, w1                // No, negate int&#13;
           mov     w2, MINUS&#13;
           strb    w2, [x0]              // Start with minus sign&#13;
           add     x0, x0, 1             // Increment pointer&#13;
   non_negative:&#13;
           add     x3, sp, reverse       // Pointer to local string storage&#13;
           strb    wzr, [x3]             // Create end with NUL&#13;
           mov     w2, RADIX             // Put in register&#13;
   do_while:&#13;
           add     x3, x3, 1             // Increment local pointer&#13;
        <span class="ent">➋</span> udiv    w4, w1, w2            // Quotient = dividend / RADIX&#13;
        <span class="ent">➌</span> msub    w5, w4, w2, w1        // Rem. = dividend - RADIX * quot.&#13;
           orr     w5, w5, INT2CHAR      // Convert to ASCII&#13;
           strb    w5, [x3]              // Store character&#13;
        <span class="ent">➍</span> mov     w1, w4                // Remove remainder&#13;
           cbnz    w1, do_while          // Continue if more left&#13;
   &#13;
           mov     w6, wzr               // count = 0&#13;
   copy:&#13;
           ldrb    w5, [x3]              // Load character&#13;
           strb    w5, [x0]              // Store it&#13;
           add     x0, x0, 1             // Increment to pointer&#13;
           sub     x3, x3, 1             // Decrement from pointer&#13;
           add     w6, w6, 1             // Increment counter&#13;
           cbnz    w5, copy              // Continue until NUL char&#13;
           strb    w5, [x0]              // Store NUL character&#13;
   &#13;
           mov     w0, w6                // Return count&#13;
           add     sp, sp, FRAME         // Delete stack frame&#13;
           ret                           // Back to caller</pre>&#13;
<span epub:type="pagebreak" id="page_357"/>&#13;
<p class="list" id="ch16list24"><em>Listing 16-24: The assembly language version of the</em> <span class="codeitalic">int_to_dec</span> <em>function</em></p>&#13;
<p class="indent">Since this is a leaf function, we don’t need a frame record, but we do need space on the stack for storing the text string locally as we generate it in reverse order <span class="ent">❶</span>.</p>&#13;
<p class="indent">Rather than using a multiply-and-shift algorithm like the compiler did, we use the <span class="literal">udiv</span> instruction to divide by 10 <span class="ent">❷</span>. This gives us the quotient in the <span class="literal">w4</span> register. Then, we use the <span class="literal">msub</span> instruction to multiply the quotient (register <span class="literal">w4</span>) by RADIX (register <span class="literal">w2</span>) and subtract that product from the dividend (register <span class="literal">w1</span>), leaving the remainder in register <span class="literal">w5</span> <span class="ent">❸</span>. Since we already have the quotient in register <span class="literal">w4</span>, we can use that for the next iteration of this loop <span class="ent">❹</span>.</p>&#13;
<p class="indent">In <a href="ch16.xhtml#ch16list24">Listing 16-24</a>, we see two new instructions: <span class="literal">msub</span> and <span class="literal">udiv</span>. I’ll also describe <span class="literal">sdiv</span> here:</p>&#13;
<h5 class="h5" id="ch16lev3sec16"><span class="codestrong">msub</span><strong>—Multiply and subtract</strong></h5>&#13;
<p class="noindentin"><span class="literal">msub w</span><span class="codeitalic">d</span> <span class="literal">, w</span><span class="codeitalic">s1</span> <span class="literal">, w</span><span class="codeitalic">s2</span> <span class="literal">, w</span><span class="codeitalic">s3</span> multiplies <span class="literal">w</span><span class="codeitalic">s1</span> by <span class="literal">w</span><span class="codeitalic">s2</span>, subtracts the value in <span class="literal">w</span><span class="codeitalic">s3</span> from the product, and loads the result in <span class="literal">w</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">msub x</span><span class="codeitalic">d</span> <span class="literal">, x</span><span class="codeitalic">s1</span> <span class="literal">, x</span><span class="codeitalic">s2</span> <span class="literal">, x</span><span class="codeitalic">s3</span> multiplies <span class="literal">x</span><span class="codeitalic">s1</span> by <span class="literal">x</span><span class="codeitalic">s2</span>, subtracts the value in <span class="literal">x</span><span class="codeitalic">s3</span> from the product, and loads the result in <span class="literal">x</span><span class="codeitalic">d</span>.</p>&#13;
<h5 class="h5" id="ch16lev3sec17"><span class="codestrong">udiv</span><strong>—Unsigned divide</strong></h5>&#13;
<p class="noindentin"><span class="literal">udiv w</span><span class="codeitalic">d</span> <span class="literal">, w</span><span class="codeitalic">s1</span> <span class="literal">, w</span><span class="codeitalic">s2</span> divides <span class="literal">w</span><span class="codeitalic">s1</span> by <span class="literal">w</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">w</span><span class="codeitalic">d</span>. It treats all values as unsigned numbers.</p>&#13;
<p class="noindentin"><span class="literal">udiv x</span><span class="codeitalic">d</span> <span class="literal">, x</span><span class="codeitalic">s1</span> <span class="literal">, x</span><span class="codeitalic">s2</span> divides <span class="literal">x</span><span class="codeitalic">s1</span> by <span class="literal">x</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">x</span><span class="codeitalic">d</span>. It treats all values as unsigned numbers.</p>&#13;
<h5 class="h5" id="ch16lev3sec18"><span class="codestrong">sdiv</span><strong>—Signed divide</strong></h5>&#13;
<p class="noindentin"><span class="literal">sdiv w</span><span class="codeitalic">d</span> <span class="literal">, w</span><span class="codeitalic">s1</span> <span class="literal">, w</span><span class="codeitalic">s2</span> divides <span class="literal">w</span><span class="codeitalic">s1</span> by <span class="literal">w</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">w</span><span class="codeitalic">d</span>. If <span class="literal">w</span><span class="codeitalic">s1</span> and <span class="literal">w</span><span class="codeitalic">s2</span> are of the same sign, the value in <span class="literal">w</span><span class="codeitalic">d</span> will be positive. If they are of opposite signs, the value in <span class="literal">w</span><span class="codeitalic">d</span> will be negative.</p>&#13;
<p class="noindentin"><span class="literal">sdiv x</span><span class="codeitalic">d</span> <span class="literal">, x</span><span class="codeitalic">s1</span> <span class="literal">, x</span><span class="codeitalic">s2</span> divides <span class="literal">x</span><span class="codeitalic">s1</span> by <span class="literal">x</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">x</span><span class="codeitalic">d</span>. If <span class="literal">x</span><span class="codeitalic">s1</span> and <span class="literal">x</span><span class="codeitalic">s2</span> are of the same sign, the value in <span class="literal">x</span><span class="codeitalic">d</span> will be positive. If they are of opposite signs, the value in <span class="literal">x</span><span class="codeitalic">d</span> will be negative.</p>&#13;
<p class="indentgt"><span epub:type="pagebreak" id="page_358"/>The divide instructions don’t affect the condition flags in the <span class="literal">nzcv</span> register. They don’t even give an error if you divide by zero; they load 0 into the destination register. You need to carefully analyze your algorithms for all possible values to make sure you never divide by zero.</p>&#13;
<div class="box">&#13;
<p class="box-title" id="ch16you2"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch16exe8">16.8     Write the two functions <span class="literal">put_int</span> and <span class="literal">get_int</span> in assembly language. The <span class="literal">put_int</span> function takes one argument, a 32-bit signed integer, and displays it on the screen. The <span class="literal">get_int</span> function returns a 32-bit signed integer, which it reads from keyboard input. Write a <span class="literal">main</span> function in C to test <span class="literal">put_int</span> and <span class="literal">get_int</span>. We’ll be using <span class="literal">put_int</span> and <span class="literal">get_int</span> in subsequent chapters for displaying and reading integers.</p>&#13;
<p class="box-list1" id="ch16exe9">16.9     Write the two functions <span class="literal">put_uint</span> and <span class="literal">get_uint</span> in assembly language. The <span class="literal">put_uint</span> function takes one argument, a 32-bit unsigned integer, and displays it on the screen. The <span class="literal">get_uint</span> function returns a 32-bit unsigned integer, which it reads from keyboard input. Use the <span class="literal">dec_to_uint</span> function from <a href="ch16.xhtml#ch16exe6">exercise 16.6</a> on <a href="ch16.xhtml#ch16you1">page 348</a>, and write the function <span class="literal">uint_to_dec</span>. Write a <span class="literal">main</span> function in C to test <span class="literal">put_uint</span> and <span class="literal">get_uint</span>. We’ll be using <span class="literal">put_uint</span> and <span class="literal">get_uint</span> in subsequent chapters for displaying and reading integers.</p>&#13;
<p class="box-list1" id="ch16exe10">16.10   Write a program in assembly language that allows a user to enter two signed decimal integers. The program will add, subtract, multiply, and divide the two integers. It will display the sum, difference, product, quotient, and remainder resulting from these operations.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch16lev1sec5"><strong>What You’ve Learned</strong></h3>&#13;
<p class="noindentin"><strong>Bitmasking</strong> We can use bitwise logic instructions to directly change bit patterns in variables.</p>&#13;
<p class="noindentin"><strong>Bit shifting</strong> Bits in variables can be shifted left or right, effectively multiplying or dividing by multiples of 2.</p>&#13;
<p class="noindentin"><strong>Multiplication</strong> The multiply instructions allow us to perform signed or unsigned multiplication. Multiplying large 64-bit values requires two instructions for the 128-bit result.</p>&#13;
<p class="noindentin"><strong>Faster multiplication</strong> When multiplying by a constant, a combination of adding and shifting can be faster than a multiply instruction.</p>&#13;
<p class="noindentin"><strong>Division</strong> The divide instructions allow us to perform signed or unsigned division.</p>&#13;
<p class="noindentin"><strong>Faster division</strong> When dividing by a constant, a combination of multiplying and shifting can be faster than a divide instruction.</p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_359"/><strong>Converting numbers between binary storage and character display</strong> Arithmetic operations are easier when numbers are stored in the binary system, but keyboard input and screen display use the corresponding character format.</p>&#13;
<p class="indentgt">We’ve now covered ways to organize program flow and perform arithmetic or logic operations on data items. In the next chapter, we’ll explore two of the most fundamental ways to organize data: arrays and records.<span epub:type="pagebreak" id="page_360"/></p>&#13;
</div>
</div>
</body></html>