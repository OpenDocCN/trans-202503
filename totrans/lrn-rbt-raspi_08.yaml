- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: 'COMPUTER VISION: FOLLOW A COLORED BALL'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机视觉：跟踪一个彩色球
- en: AS HUMANS, WE USE OUR EYES AND BRAINS TO SEE AND COMPREHEND THE WORLD AROUND
    US. ALTHOUGH THIS HAPPENS AUTOMATICALLY FOR US, VISION IS ACTUALLY AN IMMENSELY
    COMPLICATED SERIES OF PROCESSES.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为人类，我们通过眼睛和大脑来看待和理解周围的世界。虽然这一过程对我们来说是自动发生的，但视觉实际上是一个极为复杂的过程。
- en: '*Computer vision* is an advanced field of computer science and engineering
    that aims to enable computers and machines to see and understand their surroundings
    at least as well as humans, if not better. In this chapter you’ll learn some principles
    of computer vision, and then I’ll show you how to use a camera to enable your
    robot to recognize and follow a colored ball.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算机视觉*是计算机科学和工程的一个高级领域，旨在使计算机和机器能够像人类一样，甚至更好地“看”和理解周围环境。在本章中，你将学习一些计算机视觉的原理，然后我会展示如何使用摄像头让你的机器人识别并跟踪一个彩色球。'
- en: THE COMPUTER VISION PROCESS
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算机视觉过程
- en: Consider the process behind seeing, recognizing, and reacting to a colorful
    item. First, the image of that item passes through your eye and strikes your retina.
    The retina does some elementary analysis and then converts the received light
    into neural signals, which are sent to your brain and analyzed thoroughly by your
    visual cortex. Your brain then identifies the item and gives instructions to your
    muscles.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下观察、识别和反应于一个彩色物体的过程。首先，物体的图像通过你的眼睛传到视网膜。视网膜进行一些基础分析，然后将接收到的光转化为神经信号，这些信号被发送到大脑，并由视觉皮层进行彻底分析。然后，大脑识别出物体并发出指令给你的肌肉。
- en: What is remarkable is that this all happens in a fraction of a second and with
    no conscious effort.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，这一切发生在极短的时间内，并且不需要任何意识上的努力。
- en: Even with that simplified explanation, you can appreciate the complexity of
    vision. Getting computers to complete a similar series of tasks is something that
    people in the field of computer vision have worked on tirelessly for *decades*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是这样简化的解释，你也能感受到视觉的复杂性。让计算机完成类似的任务，正是计算机视觉领域的专家们不懈努力的目标，*几十年来*他们都在为此奋斗。
- en: 'There are three distinct tasks any computer vision system must be able to do:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 任何计算机视觉系统必须能够完成三项任务：
- en: '**See** Biological beings generally see through their eyes. Com­puters must
    use their digital equivalent: cameras. Cameras work by using a lens to focus light
    onto a digital sensor. This sensor then converts the light into digital information:
    an image or frame of a video.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**看** 生物体通常通过眼睛来看。计算机必须使用它们的数字等价物：摄像头。摄像头通过镜头将光线聚焦到数字传感器上。该传感器随后将光线转化为数字信息：图像或视频帧。'
- en: '**Process** After the input has been captured, it must be processed to extract
    information, recognize patterns, and manipulate data. In nature, this is the role
    of the brain. For computer vision, it is the role of code and algorithms.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理** 输入捕获后，必须对其进行处理以提取信息、识别模式和操作数据。在自然界中，这是大脑的功能。对于计算机视觉来说，这由代码和算法来完成。'
- en: '**Understand** The information must then be understood. The computer may have
    detected and processed a pattern, but what is the pattern and what does it mean?
    Again, this important step relies on code and algorithms.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解** 然后，信息必须被理解。计算机可能已经检测并处理了一个模式，但这个模式是什么，它意味着什么？同样，这个重要步骤依赖于代码和算法。'
- en: 'When these three elements work together, the computer can handle all sorts
    of vision-based problems, including the one we’re going to tackle in this chapter:
    we’ll give your robot the ability to detect, recognize, and move toward a colored
    ball that might be anywhere in its surrounding environment.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当这三个元素协同工作时，计算机就能处理各种基于视觉的问题，包括我们在本章中要解决的问题：我们将赋予你的机器人检测、识别并朝着一个可能出现在其周围环境中的彩色球移动的能力。
- en: THE PARTS LIST
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部件清单
- en: 'You’ll need two new items for this next project:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为下一个项目准备两样新物品：
- en: A colored ball
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个彩色球
- en: Standard Pi Camera Module
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准 Pi 摄像头模块
- en: Initially, you’ll also need access to another computer to remotely view images
    taken by the Pi Camera Module during the configuration stage of this project.
    This can be the computer you’re using to SSH into your Pi. If you haven’t been
    using SSH over the course of this book, then you can just hook up your Pi to an
    HDMI display during the configuration.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，你还需要访问另一台计算机来远程查看在本项目配置阶段通过 Pi 摄像头模块拍摄的图像。这可以是你用来通过 SSH 连接到 Pi 的计算机。如果你在本书的过程中没有使用过
    SSH，那么你可以在配置时直接将 Pi 连接到 HDMI 显示器上。
- en: Let’s take a closer look at the new parts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看新的部件。
- en: 'The Target: A Colored Ball'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 目标：彩色球
- en: First you’ll need a colored ball to act as the target your robot will seek out
    and follow. Your ball should be a bright color that doesn’t appear much elsewhere
    in the room, to help your robot differentiate it from other objects. I’d recommend
    something distinctive and not too large, like the balls shown in [Figure 8-1](ch08.xhtml#ch08fig1).
    The one I’m using is a bright yellow stress ball roughly 2 inches in diameter.
    You probably already have something suitable lying around your house, but if not,
    you should be able to pick up a similar one online for a few dollars.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要一个彩色球作为你的机器人要寻找并跟随的目标。你的球应该是一个明亮的颜色，在房间里不常见，以帮助你的机器人将其与其他物体区分开来。我建议使用一些独特且不太大的球，比如[图8-1](ch08.xhtml#ch08fig1)中显示的球。我使用的是一个大约2英寸直径的亮黄色减压球。你可能已经有类似的物品放在家里，如果没有，你应该能在网上以几美元的价格买到一个类似的。
- en: '![image](../images/f167-01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f167-01.jpg)'
- en: '**FIGURE 8-1** Example colored balls for targets; I’m using the yellow one
    on the left.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8-1** 作为目标的彩色球示例；我使用的是左边的黄色球。'
- en: The Official Raspberry Pi Camera Module
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 官方树莓派相机模块
- en: To give your robot the ability to see, you will need a camera. In this project,
    we’ll be using the official Raspberry Pi Camera Module, shown in [Figure 8-2](ch08.xhtml#ch08fig2).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你的机器人具备视觉能力，你需要一台相机。在这个项目中，我们将使用官方的树莓派相机模块，如[图8-2](ch08.xhtml#ch08fig2)所示。
- en: '![image](../images/f168-01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f168-01.jpg)'
- en: '**FIGURE 8-2** The official Raspberry Pi Camera Module'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8-2** 官方树莓派相机模块'
- en: 'The Camera Module is a Raspberry Pi add-on board designed and produced by the
    Raspberry Pi Foundation. The latest model features an 8-megapixel sensor and is
    less than 1 inch square in size! Not only does it take great still photos, but
    the Camera Module is also able to shoot full-HD 1080p video at 30 frames per second.
    If you have the older 5-megapixel model, don’t worry: it is fully compatible with
    this project and used in exactly the same way.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 相机模块是一个由树莓派基金会设计和生产的树莓派扩展板。最新型号配备了一个800万像素的传感器，尺寸不到1英寸见方！它不仅能够拍摄出色的静态照片，还可以以每秒30帧的速度录制全高清视频。如果你使用的是旧款500万像素的型号，不用担心：它完全兼容这个项目，并且用法完全相同。
- en: The 6-inch ribbon cable on the Camera Module attaches to the CSI (Camera Serial
    Interface) port on the Raspberry Pi, shown in [Figure 8-3](ch08.xhtml#ch08fig3).
    It is compatible with all models, including the latest version of the Pi Zero.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 相机模块上的6英寸带状电缆连接到树莓派上的CSI（相机串行接口）端口，如[图8-3](ch08.xhtml#ch08fig3)所示。它与所有模型兼容，包括最新版本的Pi
    Zero。
- en: '![image](../images/f168-02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f168-02.jpg)'
- en: '**FIGURE 8-3** The CSI interface port on the Raspberry Pi'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**图8-3** 树莓派上的CSI接口端口'
- en: '**NOTE**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The Pi Zero has a mini-CSI connector rather than the full-size one found on
    all other Raspberry Pi models. To connect a Camera Module to the Zero, you’ll
    need to also purchase a mini-CSI-to-CSI cable. These are branded online as “Pi
    Zero Camera Cables” and cost around $5\. Keep in mind that this project requires
    intense image processing and code that will run better on the faster full-size
    Raspberry Pi models than it will on the Zero or original Raspberry Pi models.*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pi Zero采用的是迷你CSI接口，而不是其他所有树莓派型号上常见的标准尺寸接口。为了将相机模块连接到Pi Zero，你还需要购买一个迷你CSI到CSI的连接线。这些通常在网上被标记为“Pi
    Zero相机电缆”，价格大约是5美元。请记住，这个项目需要强大的图像处理能力和代码，运行速度较快的标准尺寸树莓派模型比Zero或原始树莓派模型表现得更好。*'
- en: You can buy the official Raspberry Pi Camera Module online at the usual retailers.
    It costs approximately $30.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过常规的零售商在线购买官方树莓派相机模块，价格大约为30美元。
- en: 'When looking online you may notice that there are actually two different official
    Camera Modules: the normal camera and the *NoIR* version, which can be used for
    night vision. You need the *standard* Camera Module. You can easily tell the two
    boards apart by their color difference: the circuit board of the normal Camera
    Module is green, whereas the NoIR is black.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在网上查看时，你可能会注意到实际上有两种不同的官方相机模块：普通相机和*NoIR*版本，后者可以用于夜视。你需要的是*标准*相机模块。通过颜色差异，你可以轻松区分这两个板子：普通相机模块的电路板是绿色的，而NoIR模块是黑色的。
- en: CONNECTING AND SETTING UP YOUR CAMERA MODULE
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接和设置你的相机模块
- en: 'Before you attach the Camera Module, ensure that your Pi is switched off. Then
    follow this process:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装相机模块之前，请确保你的树莓派已经关闭。然后按照以下步骤进行操作：
- en: Locate the CSI port on your Raspberry Pi. For all the full-size models of Raspberry
    Pi, this is found between the HDMI port and the 3.5 mm audio jack, and is helpfully
    labeled CAMERA.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位树莓派上的 CSI 接口。对于所有全尺寸的树莓派模型，它位于 HDMI 接口和 3.5 毫米音频插孔之间，并且清晰标注为 CAMERA。
- en: Next, open up the port by gently but firmly grabbing it from either side and
    pulling it upward (see [Figure 8-4](ch08.xhtml#ch08fig4)). This can be a delicate
    operation, and it often helps to get your fingernails underneath the sides.![image](../images/f169-01.jpg)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过轻轻但坚定地从两侧抓住接口并向上拉，打开端口（请参见 [图 8-4](ch08.xhtml#ch08fig4)）。这是一个细致的操作，通常最好将指甲插到两侧下方。[image](../images/f169-01.jpg)
- en: '**FIGURE 8-4** The CSI port opened for cable insertion'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 8-4** 打开的 CSI 接口，用于插入电缆'
- en: 'Insert the ribbon cable on your Camera Module all the way into the CSI port
    with the silver contacts facing *away* from the 3.5 mm audio jack and Ethernet
    port (see [Figure 8-5](ch08.xhtml#ch08fig5)). This orientation is critical: if
    you insert the Module’s cable the other way around, it won’t be connected properly
    and you will not be able to use it!![image](../images/f170-01.jpg)'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相机模块的排线完全插入 CSI 接口，银色接触点朝 *远离* 3.5 毫米音频插孔和以太网端口的一侧（请参见 [图 8-5](ch08.xhtml#ch08fig5)）。这个方向非常关键：如果您反方向插入模块的电缆，它将无法正确连接，您将无法使用它！！[image](../images/f170-01.jpg)
- en: '**FIGURE 8-5** CSI port with the Camera Module’s ribbon cable inserted in the
    correct direction'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 8-5** CSI 接口，正确方向插入相机模块的排线'
- en: Then, while holding the ribbon cable in place, place a finger on both sides
    of the CSI port and push it back down at the same time. If both sides don’t close
    simultaneously, then one side will not close properly and the cable may come loose.
    [Figure 8-6](ch08.xhtml#ch08fig6) shows a properly attached ribbon cable. Notice
    that a fraction of the silver contacts are just visible, and they’re all parallel
    with the board.![image](../images/f170-02.jpg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在保持排线固定的同时，用手指按住 CSI 接口的两侧，同时将其压回到原位。如果两侧没有同时关闭，则一侧可能无法正确关闭，电缆也可能会松动。[图 8-6](ch08.xhtml#ch08fig6)
    显示了一个正确连接的排线。请注意，银色接触点的一部分刚好可见，并且它们与板子平行。[image](../images/f170-02.jpg)
- en: '**FIGURE 8-6** My correctly connected Camera Module ribbon cable'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 8-6** 我的正确连接的相机模块排线'
- en: Finally, to ensure that the Camera Module is connected properly, give the ribbon
    cable a gentle tug near the CSI port. It should stay rigidly in place. If the
    cable comes detached or slips, don’t worry—just remove it and repeat these steps.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了确保相机模块正确连接，轻轻拉一下接近 CSI 接口的排线。它应该保持固定不动。如果电缆松脱或滑动，不要担心——只需将其取下并重复这些步骤。
- en: If you want to connect the Camera Module to a Raspberry Pi Zero, the process
    is similar. Find the mini-CSI port on the right-hand side of the board and open
    it using a finger on either side of it. Then, make sure the silver contacts face
    downward toward the board when you insert the Pi Zero camera cable. See [Figure
    8-7](ch08.xhtml#ch08fig7).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将相机模块连接到树莓派 Zero，过程类似。找到板子右侧的 mini-CSI 接口，并用手指从两侧将其打开。然后，确保在插入 Pi Zero 相机电缆时，银色接触点朝下，朝向板子。请参见
    [图 8-7](ch08.xhtml#ch08fig7)。
- en: '![image](../images/f171-01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f171-01.jpg)'
- en: '**FIGURE 8-7** The correct orientation of the camera cable for the mini-CSI
    port on Pi Zero models'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-7** 树莓派 Zero 型号上 mini-CSI 接口的相机电缆正确插入方向'
- en: Mounting Your Camera
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装您的相机
- en: Now that you have the camera connected to the Pi on your robot, you need to
    mount it in an appropriate position. I recommend using some sticky tack to affix
    it to the front of your robot, relatively low to ensure it will have a clear view.
    To do this, I’ve used a 2 × 2 LEGO brick to create some mounting space (see [Figure
    8-8](ch08.xhtml#ch08fig8)). Also make sure that your camera is positioned the
    correct way up, like mine is in the picture.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，相机已经连接到机器人上的树莓派，您需要将其安装在合适的位置。我建议使用一些粘土将其固定在机器人前方，放置较低的位置以确保有清晰的视野。为此，我使用了一个
    2 × 2 的 LEGO 积木来创建安装空间（请参见 [图 8-8](ch08.xhtml#ch08fig8)）。同时，确保相机的方向与我的照片中一样正确。
- en: '![image](../images/f171-02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f171-02.jpg)'
- en: '**FIGURE 8-8** My Camera Module mounted on my Raspberry Pi robot'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-8** 我的相机模块安装在我的树莓派机器人上'
- en: 'The Camera Module is quite delicate, so handle it with caution. Try not to
    contort the cable too much and make sure to not leave any kinks in it. If at any
    point the ribbon cable comes loose from the Raspberry Pi, just reattach it the
    same way as before. If it comes loose from the connector on the actual module
    then you can also just reattach it. This is done in the same way: use your fingers
    to lever open the module’s CSI port and then insert the cable with the silver
    contacts facing down and toward the PCB.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 相机模块非常脆弱，请小心处理。尽量避免扭曲电缆，并确保不要使电缆出现弯折。如果在任何时候，排线从树莓派松脱，您可以按照原来的方式重新连接。如果它从相机模块上的连接器松脱，您也可以重新连接，方法与之前相同：使用手指轻轻打开模块的CSI端口，然后将电缆插入，确保银色接触点朝下并朝向PCB。
- en: Enabling the Camera and VNC, and Setting the Screen Resolution
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启用相机和VNC，并设置屏幕分辨率
- en: To use the camera in Raspbian, you first need to enable it. If you followed
    all of the instructions in [Chapter 1](ch01.xhtml#ch01), you’ll already have done
    part of this. On top of that, we’ll need to enable VNC for this project and manually
    set up the right screen resolution. Here’s the full process.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Raspbian中使用相机，首先需要启用它。如果您按照[第1章](ch01.xhtml#ch01)中的所有步骤操作，您已经完成了部分工作。此外，我们还需要启用VNC并手动设置正确的屏幕分辨率。以下是完整的操作流程。
- en: 'To do this setup, we’ll use the configuration tool, `raspi-config`. Open the
    command line and enter the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行此设置，我们将使用配置工具`raspi-config`。打开命令行并输入以下命令：
- en: pi@raspberrypi:~/robot $ sudo raspi-config
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ sudo raspi-config
- en: You should see the same blue configuration screen you met when configuring the
    audio output of your Raspberry Pi a few chapters ago. Using the arrow keys, scroll
    down to **Interfacing Options** and then press ENTER. This opens up a new menu
    shown in [Figure 8-9](ch08.xhtml#ch08fig9).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到您之前配置树莓派音频输出时看到的相同的蓝色配置屏幕。使用箭头键向下滚动至**接口选项**，然后按ENTER键。这将打开一个新的菜单，如[图
    8-9](ch08.xhtml#ch08fig9)所示。
- en: '![image](../images/f172-01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f172-01.jpg)'
- en: '**FIGURE 8-9** The Interfacing Options menu of the `raspi-config` tool'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-9** `raspi-config`工具的接口选项菜单'
- en: Select **Camera** by pressing ENTER again. Then, when asked whether you’d like
    to enable the camera interface, use the left/right arrow keys to select **Yes**
    (see [Figure 8-10](ch08.xhtml#ch08fig10)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 再次按ENTER键选择**相机**。然后，系统会询问是否启用相机接口，使用左右箭头键选择**是**（见[图 8-10](ch08.xhtml#ch08fig10)）。
- en: '![image](../images/f173-01.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f173-01.jpg)'
- en: '**FIGURE 8-10** Enabling the camera using `raspi-config`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-10** 使用`raspi-config`启用相机'
- en: You’ll see a message confirming that the camera interface has been enabled and
    then you’ll return to the original menu.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一条确认消息，表示相机接口已启用，然后您将返回原始菜单。
- en: While you are in the `raspi-config` tool, it is also important to ensure that
    VNC is enabled. VNC will be fully explained in the next section, but for now just
    scroll down to **Interfacing Options** again, and then select **VNC** (see [Figure
    8-11](ch08.xhtml#ch08fig11)). Press ENTER to enable it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`raspi-config`工具中时，确保VNC已经启用也非常重要。VNC将在下一节中进行详细说明，但现在只需再次向下滚动至**接口选项**，然后选择**VNC**（见[图
    8-11](ch08.xhtml#ch08fig11)）。按ENTER键启用它。
- en: '![image](../images/f173-02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f173-02.jpg)'
- en: '**FIGURE 8-11** Selecting VNC from Interfacing Options'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-11** 从接口选项中选择VNC'
- en: 'You’ll be sent back to the original menu. Before you can exit the configuration
    tool, you have to do one last thing: manually set the screen resolution of your
    Pi. This will ensure that when we use VNC later, the screen will be set up in
    the right way. To set the resolution, from the original menu, scroll down to **Advanced
    Options**, and then scroll down and select **Resolution** (see [Figure 8-12](ch08.xhtml#ch08fig12)).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会将您带回原始菜单。在您退出配置工具之前，必须做最后一件事：手动设置您的树莓派的屏幕分辨率。这将确保在稍后使用VNC时，屏幕能够以正确的方式显示。要设置分辨率，从原始菜单中，向下滚动至**高级选项**，然后继续向下滚动并选择**分辨率**（见[图
    8-12](ch08.xhtml#ch08fig12)）。
- en: '![image](../images/f174-01.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f174-01.jpg)'
- en: '**FIGURE 8-12** The screen resolution option inside Advanced Options'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-12** 高级选项中的屏幕分辨率设置'
- en: '**NOTE**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you know that the resolution of your PC’s screen is* lower *than full HD,
    then set the screen resolution of your Pi to the closest lower option in the menu.
    You can always run* raspi-config *again to change the resolution at a later point*.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你知道你电脑屏幕的分辨率* 低于 *全高清，请将 Pi 的屏幕分辨率设置为菜单中最接近的较低选项。你可以随时再次运行* raspi-config
    *来更改分辨率。*'
- en: You will then be prompted to choose a screen resolution. Use the arrow keys
    to scroll down to the full HD option. It will look something like “DMT Mode 82
    1920x1080 60Hz 16:9.” Press ENTER on this option, and your screen resolution should
    now be set! You’ll be returned to the original menu.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，系统会提示你选择一个屏幕分辨率。使用箭头键向下滚动，选择全高清选项。它看起来像是“DMT 模式 82 1920x1080 60Hz 16:9”。按下
    ENTER 键选择这个选项，屏幕分辨率应该已经设置好了！你将返回到原始菜单。
- en: Exit the configuration tool by pressing the right arrow key twice (highlighting
    **Finish**) and then pressing ENTER. Reboot your Raspberry Pi if prompted to do
    so.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 按右箭头键两次（高亮显示 **完成**），然后按 ENTER 键退出配置工具。如果提示，请重新启动你的 Raspberry Pi。
- en: TAKING A TEST PHOTO
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拍摄测试照片
- en: With your Camera Module connected and enabled, let’s test it by taking a photo.
    This is easy to do from a remote terminal with a simple command, but by using
    that method you won’t be able to view the image it took in the text-based environment!
    This is where VNC, the option you enabled previously, comes in.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 连接并启用相机模块后，我们来测试一下拍照。这可以通过远程终端用一个简单的命令轻松完成，但通过这种方式你无法在基于文本的环境中查看拍摄的图片！这时，VNC——你之前启用的选项——派上了用场。
- en: Controlling Your Pi’s Desktop Remotely with VNC
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 VNC 远程控制 Pi 的桌面
- en: '*VNC* stands for *Virtual Network Computing*. It allows you to remotely view
    and control your Raspberry Pi’s desktop from another computer, a little bit like
    what you’ve been doing with SSH, but for the full graphical user interface (GUI)
    rather than just the terminal. Since we can view the Pi’s GUI using VNC, you’ll
    easily be able to see any photos that you take with the Raspberry Pi Camera Module
    using Raspbian’s built-in image viewer.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*VNC* 代表 *虚拟网络计算*。它允许你远程查看和控制 Raspberry Pi 的桌面，就像你之前使用 SSH 连接时一样，但它是针对完整的图形用户界面（GUI），而不仅仅是终端。由于我们可以通过
    VNC 查看 Pi 的图形界面，你将能够轻松查看你用 Raspberry Pi 相机模块拍摄的任何照片，使用 Raspbian 内置的图像查看器。'
- en: '**NOTE**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’ve been following along with this book and not using your Raspberry
    Pi wirelessly over SSH, don’t worry! You can still follow the steps after this
    section and view the results with your Pi connected to a monitor over HDMI.*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你按照本书的步骤操作，并且没有通过 SSH 无线连接 Raspberry Pi，不用担心！你仍然可以继续按照本节后的步骤操作，并在 Pi 连接到
    HDMI 显示器后查看结果。*'
- en: Installing and Making a Connection with VNC Viewer
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装并使用 VNC Viewer 进行连接
- en: 'You have everything set up on the Raspberry Pi end, and now you need to download
    a VNC viewer on the computer you want to view the images on. We’ll use some free
    software called *VNC Viewer* from RealVNC, which is compatible with Windows, Mac,
    Linux, and more. To install the software, follow this process on your machine:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在 Raspberry Pi 端完成了所有设置，现在你需要在要查看图像的电脑上下载 VNC Viewer。我们将使用 RealVNC 提供的免费软件
    *VNC Viewer*，它兼容 Windows、Mac、Linux 等平台。要安装该软件，请在你的机器上按照以下步骤操作：
- en: On your computer, open a web browser and go to *[https://www.realvnc.com/en/connect/download/viewer/](https://www.realvnc.com/en/connect/download/viewer/)*.
    You should see the download page for the VNC Viewer software, shown in [Figure
    8-13](ch08.xhtml#ch08fig13).![image](../images/f175-01.jpg)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的电脑上，打开一个网页浏览器并访问 *[https://www.realvnc.com/en/connect/download/viewer/](https://www.realvnc.com/en/connect/download/viewer/)*。你应该会看到
    VNC Viewer 软件的下载页面，如 [图 8-13](ch08.xhtml#ch08fig13) 所示。![image](../images/f175-01.jpg)
- en: '**FIGURE 8-13** The VNC Viewer software download page'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 8-13** VNC Viewer 软件下载页面'
- en: From here, select your operating system and click the **Download** button. Once
    the software has downloaded, go through the installation wizard and agree to the
    terms of service. A few minutes later, everything should be installed and ready!
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，选择你的操作系统并点击 **下载** 按钮。软件下载完成后，按照安装向导进行操作，并同意服务条款。几分钟后，一切应该安装完毕并准备就绪！
- en: With VNC Viewer now installed, run it. You should see a window with a box at
    the top ([Figure 8-14](ch08.xhtml#ch08fig14)); here, you’ll enter the IP address
    of your Raspberry Pi, which you should already know since you’ve been using it
    to connect to your Pi over SSH.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经安装了 VNC Viewer，运行它。你应该会看到一个窗口，顶部有一个框（[图 8-14](ch08.xhtml#ch08fig14)）；在这里，你需要输入
    Raspberry Pi 的 IP 地址，你应该已经知道这个地址，因为你一直在通过 SSH 连接到你的 Pi。
- en: An authentication box will appear asking you for a username and password. Enter
    the login details of your Raspberry Pi and click **OK**. If you haven’t changed
    the default user, then the username will be `pi` and the password will be whatever
    you set it to in [Chapter 1](ch01.xhtml#ch01).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 会弹出一个认证框，要求你输入用户名和密码。输入你的树莓派登录信息，然后点击**确定**。如果你没有更改默认用户，那么用户名是`pi`，密码是你在[第1章](ch01.xhtml#ch01)中设置的密码。
- en: '![image](../images/f176-01.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f176-01.jpg)'
- en: '**FIGURE 8-14** Setting up VNC Viewer to connect to my Raspberry Pi'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-14** 设置VNC查看器以连接我的树莓派'
- en: A new window will appear displaying your Pi’s desktop (see [Figure 8-15](ch08.xhtml#ch08fig15)).
    Here you can access and use everything just the same as if your Pi were plugged
    into an HDMI monitor.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新窗口将显示你的树莓派桌面（见[图 8-15](ch08.xhtml#ch08fig15)）。在这里，你可以像树莓派接入HDMI显示器一样访问和使用所有功能。
- en: '![image](../images/f176-02.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f176-02.jpg)'
- en: '**FIGURE 8-15** A terminal and file manager in my Raspberry Pi desktop environment,
    viewed with VNC'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-15** 在树莓派桌面环境中，通过VNC查看的终端和文件管理器'
- en: Taking and Viewing a Photo Using the Raspberry Pi Camera Module
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用树莓派摄像头模块拍照和查看照片
- en: 'Now that you have everything set up, you can take your test photo! We’ll use
    a built-in command-line tool called `raspistill`. Open up a terminal, either through
    an SSH connection or by using a terminal window in the desktop environment over
    your VNC connection, and enter the following command to take a photo:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置好了一切，接下来可以拍摄测试照片了！我们将使用一个内置的命令行工具，叫做`raspistill`。通过SSH连接或者使用VNC连接中的终端窗口打开一个终端，输入以下命令拍照：
- en: pi@raspberrypi:~ $ raspistill –o test.jpg
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~ $ raspistill –o test.jpg
- en: After a 5-second delay (to make sure you can get in front of your camera or
    frame your shot), this command will complete. If you see no output, that’s great
    news! There is no success message for this particular command. This instruction
    takes a picture and saves it as *test.jpg* in the directory where the command
    was run—in this case, the default home directory.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在5秒钟的延迟后（确保你可以站到相机前面或者调整好镜头），命令会执行完毕。如果你没有看到任何输出，说明一切正常！这个命令没有成功消息。这个指令会拍照并将照片保存为*test.jpg*，保存在命令运行的目录中——在本例中，是默认的主目录。
- en: To view the image in the VNC desktop, click the **File Manager** icon in the
    VNC desktop environment (it looks like a collection of folders, as shown in [Figure
    8-16](ch08.xhtml#ch08fig16)).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要在VNC桌面中查看图像，点击VNC桌面环境中的**文件管理器**图标（它看起来像一个文件夹集合，如[图 8-16](ch08.xhtml#ch08fig16)所示）。
- en: CAMERA TROUBLESHOOTING
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 相机故障排除
- en: If running the `raspistill` command gives you a scary error similar to the following,
    don’t worry!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行`raspistill`命令时出现类似以下的可怕错误，不用担心！
- en: '[PRE0]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You most likely just haven’t connected your camera properly. If you get this
    error message, or any other, check the ribbon cable connections between the Camera
    Module and your Pi. Also ensure that you have enabled the camera interface properly—turn
    back to [page 172](ch08.xhtml#page_172) for guidance.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能只是没有正确连接相机。如果你收到这个错误消息，或者其他任何错误，检查一下相机模块和树莓派之间的排线连接。同时，确保你已经正确启用了相机接口——返回[第172页](ch08.xhtml#page_172)查阅指导。
- en: '![image](../images/f178-01.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f178-01.jpg)'
- en: '**FIGURE 8-16** The File Manager icon'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-16** 文件管理器图标'
- en: Navigate to the directory you ran the `raspistill` command from (I ran mine
    in the default home directory), locate *test.jpg*, and double-click it. You should
    see the photo that you just took in the Image Viewer (see [Figure 8-17](ch08.xhtml#ch08fig17)).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到运行`raspistill`命令的目录（我是在默认的主目录中运行的），找到*test.jpg*文件并双击它。你应该能够在图像查看器中看到你刚拍的照片（见[图
    8-17](ch08.xhtml#ch08fig17)）。
- en: '![Image](../images/f178-02.jpg)![Image](../images/f178-03.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f178-02.jpg)![Image](../images/f178-03.jpg)'
- en: '**FIGURE 8-17** The *test.jpg* image in Raspbian’s Image Viewer over VNC (top);
    the *test.jpg* image, which features a stapler, Carl Sagan’s *Cosmos*, and two
    colored balls for use later (bottom)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-17** Raspbian图像查看器中的*test.jpg*图像（上图）；展示了一个订书机、卡尔·萨根的*宇宙*以及两个稍后使用的彩色球（下图）'
- en: MAKE YOUR ROBOT SEEK AND FOLLOW A BALL
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让你的机器人寻找并追踪一个球
- en: 'Now you have your camera hooked up and a successful image test under your belt,
    it’s time to move on to the advanced project in this chapter: making your robot
    recognize and follow a colored ball. But first: a quick lesson in some important
    theory.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经连接好相机并成功完成了图像测试，是时候进入本章的高级项目：让你的机器人识别并跟踪一个彩色球了。但在此之前：我们先来快速了解一些重要的理论。
- en: Understanding the Theory Behind Colored-Object Recognition
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解彩色物体识别的原理
- en: How do we get a robot incapable of independent thought as we know it to detect
    and identify a particular object?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何让一个无法独立思考的机器人识别并识别出特定的物体呢？
- en: As your robot moves around, the position of the ball relative to your robot
    will be constantly changing, so the first thing we need is a continually refreshing
    view of what is in front of your robot. The Camera Module provides this view through
    a stream of images, often referred to as *video frames* or just *frames*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的机器人移动时，球相对于机器人的位置会不断变化，因此我们首先需要的是一个不断刷新的视图，显示机器人前方的情况。相机模块通过一系列图像提供这个视图，这些图像通常被称为*视频帧*或简称*帧*。
- en: Each image, like the one in [Figure 8-18](ch08.xhtml#ch08fig18), will need to
    be analyzed to identify whether or not it contains your colored ball. To do this,
    we will apply various image processing techniques.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每一张图像，如 [图 8-18](ch08.xhtml#ch08fig18) 中的图像，都需要进行分析，以确定它是否包含你的彩色球。为此，我们将应用各种图像处理技术。
- en: '![image](../images/f179-01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f179-01.jpg)'
- en: '**FIGURE 8-18** An untouched image from the Camera Module, ready to be analyzed'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-18** 来自相机模块的未处理图像，准备进行分析'
- en: The first step is to convert the image, which is in an RGB format, into an *HSV*
    format. We discussed RGB in [Chapter 6](ch06.xhtml#ch06), but I’ll briefly summarize
    here. *RGB* stands for red, green, and blue. Each pixel of the image from the
    Camera Module in [Figure 8-18](ch08.xhtml#ch08fig18) is made out of a combination
    of these three colors, represented as three numbers between 0 and 255—for example,
    [100,200,150].
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将图像从 RGB 格式转换为*HSV* 格式。我们在 [第六章](ch06.xhtml#ch06)中讨论了 RGB，但我在这里简要总结一下。*RGB*
    代表红色、绿色和蓝色。来自 [图 8-18](ch08.xhtml#ch08fig18) 中相机模块的每个像素都是这三种颜色的组合，表示为三个介于 0 到
    255 之间的数字——例如，[100,200,150]。
- en: Computers use RGB for *displaying* colors, but for processing images and the
    color data they contain, the HSV color format is much more appropriate. *HSV*
    stands for hue, saturation, and value, and it is just another way of digitally
    representing color with three parameters. HSV is a bit more complicated to understand
    and represent than RGB, but it is often easiest to get your head around when viewed
    as a cylinder (see [Figure 8-19](ch08.xhtml#ch08fig19)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机使用 RGB 来*显示*颜色，但在处理图像及其包含的颜色数据时，HSV 颜色格式更为合适。*HSV* 代表色相、饱和度和值，它是以三种参数数字化表示颜色的另一种方式。HSV
    比 RGB 更难理解和表示，但当把它看作一个圆柱体时（见 [图 8-19](ch08.xhtml#ch08fig19)），通常最容易理解。
- en: '![image](../images/f180-01.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f180-01.jpg)'
- en: '**FIGURE 8-19** An HSV cylinder'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-19** HSV 圆柱体'
- en: '*Hue* is the color portion of the HSV model, and it is expressed as a number
    from 0 to 360 degrees. Different sections of this range represent the different
    colors (see [Table 8-1](ch08.xhtml#ch08tab1)).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*色相* 是 HSV 模型中的颜色部分，它表示为 0 到 360 度之间的数字。这个范围的不同部分代表不同的颜色（见 [表 8-1](ch08.xhtml#ch08tab1)）。'
- en: '**TABLE 8-1** The Hue Ranges of HSV'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-1** HSV 的色相范围'
- en: '| **COLOR** | **ANGLE** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **颜色** | **角度** |'
- en: '| Red | 0–60 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 红色 | 0–60 |'
- en: '| Yellow | 60–120 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 黄色 | 60–120 |'
- en: '| Green | 120–180 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 绿色 | 120–180 |'
- en: '| Cyan | 180–240 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 青色 | 180–240 |'
- en: '| Blue | 240–300 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 蓝色 | 240–300 |'
- en: '| Magenta | 300–360 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 品红色 | 300–360 |'
- en: '*Saturation* is the level of white in a color, from 0 to 100%. *Value* works
    alongside saturation and can be thought of as brightness; it describes the intensity
    of the color from 0 to 100%.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*饱和度* 是颜色中的白色程度，范围从 0 到 100%。*值* 与饱和度一起工作，可以看作是亮度；它描述了颜色的强度，范围从 0 到 100%。'
- en: By converting each image into an HSV format, your Pi is able to separate just
    the color component (hue) for further analysis. This means that the computer should
    still be able to recognize a colored object, regardless of the environment and
    its lighting effects. This would be incredibly difficult to achieve in an RGB
    color space. [Figure 8-20](ch08.xhtml#ch08fig20) shows an RGB implementation of
    the HSV data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将每张图像转换为 HSV 格式，你的 Pi 可以将颜色成分（色相）分离出来进行进一步分析。这意味着，无论环境和光照效果如何，计算机仍然能够识别彩色物体。这在
    RGB 颜色空间中是非常难以实现的。[图 8-20](ch08.xhtml#ch08fig20) 显示了 HSV 数据的 RGB 实现。
- en: '![image](../images/f181-01.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f181-01.jpg)'
- en: '**FIGURE 8-20** HSV data of the image'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-20** 图像的 HSV 数据'
- en: As you can see in [Figure 8-20](ch08.xhtml#ch08fig20), the yellow ball my robot
    will follow is now clear and distinctive. There is no possible way that it could
    be confused with the red ball behind it, or any of the other objects in the frame.
    Remember, though, that this is an RGB *implementation* of HSV color. The hue value
    of a color is not something that we can see in the same way with our own eyes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 8-20](ch08.xhtml#ch08fig20)所示，我的机器人将跟随的黄色球现在清晰可见，且非常独特。它不可能与背后的红球或画面中的其他物体混淆。不过，请记住，这是
    HSV 颜色模型的 RGB *实现*。颜色的色调值是我们无法像用眼睛看到的那样直接识别的。
- en: The next stage in the process is to look for and identify any color that matches
    the one we are searching for. In my case, I want to match all the parts of the
    image that are the same color as my yellow ball. This forms a *mask* (see [Figure
    8-21](ch08.xhtml#ch08fig21)) that simply keeps the parts of the image we want
    and removes the parts we don’t want. You can see that it keeps only the areas
    that contain my desired color, yellow.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是查找并识别任何与我们搜索的颜色匹配的区域。在我的案例中，我想匹配图像中与我的黄色球颜色相同的所有部分。这形成了一个*遮罩*（参见[图 8-21](ch08.xhtml#ch08fig21)），它仅保留我们需要的图像部分，去除我们不需要的部分。你可以看到，它只保留了包含我想要的黄色颜色的区域。
- en: '![image](../images/f182-01.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f182-01.jpg)'
- en: '**FIGURE 8-21** Masking out the colors and areas of the image that are not
    the same shade of yellow as the ball. Notice that there are areas on the ball
    (bright reflections/shadowy regions) that aren’t picked up!'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-21** 遮罩掉图像中与球的黄色色调不同的颜色和区域。注意，球上有一些区域（亮反射/阴影区域）没有被拾取！'
- en: Now that the relevant colored objects have been isolated, the next step in the
    process is to identify the largest patch of color. Notice how there are other
    (albeit small) readings of yellow in [Figure 8-21](ch08.xhtml#ch08fig21)? If you
    don’t program this right, your robot might get confused and head toward those
    instead of the desired ball. This could be disastrous—after all, you don’t want
    it to get distracted by distant bananas!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，相关的彩色物体已经被分离出来，接下来的步骤是识别出最大的颜色块。注意在[图 8-21](ch08.xhtml#ch08fig21)中还有其他（虽然较小的）黄色区域吗？如果你没有正确编程，机器人可能会被这些区域混淆，朝它们而不是目标球移动。这可能会造成灾难——毕竟，你不希望它被远处的香蕉分散注意力！
- en: Assuming that the largest part of the mask is the colored ball, the next stage
    is to actually find that largest area. We do so by drawing a contour (like an
    outline; see [Figure 8-22](ch08.xhtml#ch08fig22)) around each detected object
    in the mask. We can work out the area of each contour using some basic mathematics.
    The largest area is then identified and assumed to be our target ball!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 假设遮罩中最大的部分是彩色球，下一步是实际找到这个最大区域。我们通过在遮罩中的每个检测到的物体周围绘制一个轮廓（类似轮廓线；参见[图 8-22](ch08.xhtml#ch08fig22)）来实现。我们可以通过一些基本的数学计算出每个轮廓的面积。然后，识别出最大区域，并假定它就是我们要找的目标球！
- en: '![image](../images/f182-02.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f182-02.jpg)'
- en: '**FIGURE 8-22** Contour drawn around the largest single object in the mask'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-22** 在遮罩中绘制的围绕最大单个物体的轮廓'
- en: After this, we simply need to program the robot to move toward the object. If
    the target is to the right of the robot, move right. If it is to the left of the
    robot, move left. If it is in front of the robot, move forward.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此步骤后，我们只需编程让机器人朝向物体移动。如果目标在机器人的右侧，则向右移动。如果它在机器人的左侧，则向左移动。如果它在机器人的前方，则向前移动。
- en: And that’s all there is to making a ball-following computer vision system with
    your Raspberry Pi! It’s time to put it into practice.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是用你的树莓派制作一个跟踪球的计算机视觉系统！现在是时候付诸实践了。
- en: Installing the Software
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装软件
- en: You’ll need a couple of Python libraries to enable computer vision. Most notably,
    we will be using OpenCV, a free and open source library of programming functions
    for real-time computer vision. You will also need the PiCamera Python library
    to manipulate and handle the Camera Module in Python, though this is included
    by default in the latest versions of Raspbian.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要几个 Python 库来启用计算机视觉。最重要的是，我们将使用 OpenCV，这是一个免费的开源实时计算机视觉编程函数库。你还需要 PiCamera
    Python 库来操作和处理树莓派相机模块，尽管在最新版本的 Raspbian 中默认已包含此库。
- en: 'To install the dependencies for the OpenCV Python 3 library, enter the following
    command into the terminal:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 OpenCV Python 3 库的依赖项，请在终端中输入以下命令：
- en: pi@raspberrypi:~ $ sudo apt-get install libblas-dev
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~ $ sudo apt-get install libblas-dev
- en: libatlas-base-dev libjasper-dev libqtgui4 libqt4-test
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: libatlas-base-dev libjasper-dev libqtgui4 libqt4-test
- en: '**NOTE**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you get any errors during this installation process, or it just doesn’t
    look like it has gone correctly, visit the book’s website at [https://nostarch.com/raspirobots](https://nostarch.com/raspirobots)
    to check for any changes and get further guidance.*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在安装过程中遇到任何错误，或者安装似乎没有正确进行，请访问本书的网站[https://nostarch.com/raspirobots](https://nostarch.com/raspirobots)查看任何更改并获得进一步指导。*'
- en: When prompted as to whether you want to continue, press Y and then ENTER. This
    command will take a few minutes to execute.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统提示是否继续时，按Y然后按ENTER。这条命令执行需要几分钟。
- en: 'Now, you can use `pip` (the Python software management tool we have used previously)
    to install OpenCV for Python 3\. Enter the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`pip`（我们之前使用过的Python软件管理工具）来为Python 3安装OpenCV。输入以下命令：
- en: pi@raspberrypi:~ $ sudo pip3 install opencv-python
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~ $ sudo pip3 install opencv-python
- en: 'After the OpenCV installation has finished, check that you have the PiCamera
    library installed with the following command. It will most likely inform you that
    you already have the newest version, but if not, proceed with the installation:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV安装完成后，使用以下命令检查是否已安装PiCamera库。它很可能会告知你已经安装了最新版本，但如果没有，请继续安装：
- en: pi@raspberrypi:~ $ sudo apt-get install python3-picamera
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~ $ sudo apt-get install python3-picamera
- en: And that’s all you will need!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你所需要的全部！
- en: Identifying the HSV Color of Your Colored Ball
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 识别你彩色球的HSV颜色
- en: To identify a ball of a specific color, your Raspberry Pi robot needs the HSV
    value of that color. The Pi will use this value to compare each part of each image
    to see whether it is the color of the ball that you want your robot to follow.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别特定颜色的球，你的树莓派机器人需要该颜色的HSV值。树莓派将使用这个值来比较每张图片的各个部分，以查看它是否是你希望机器人跟随的球的颜色。
- en: Your ball is probably a different color than mine, so you’ll need to find out
    the exact HSV value for yours. Even if you have a yellow ball as I do, it may
    be a slightly different shade from mine!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你的球可能和我的颜色不同，因此你需要找出你球的确切HSV值。即使你和我一样有一个黄色的球，它的色调也可能与你的有所不同！
- en: There are various ways to identify the hue value you’ll need, but I’ve found
    that the best method is to try out various values on your Raspberry Pi and observe
    the effects. The aim is to find the one that matches your particular colored ball.
    To help you do this, I have created a test program, *hsv_tester.py*, which you
    can find in the software bundled with this book ([*https://nostarch.com/raspirobots/*](https://nostarch.com/raspirobots/)).
    The next section will walk you through running the program.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以识别你需要的色调值，但我发现最好的方法是尝试不同的值，看看效果如何。目的是找到一个与你特定颜色球匹配的值。为了帮助你完成这一点，我创建了一个测试程序*hsv_tester.py*，你可以在本书随附的软件包中找到它（[*https://nostarch.com/raspirobots/*](https://nostarch.com/raspirobots/)）。下一部分将带你通过运行该程序。
- en: Running the HSV Test Program
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行HSV测试程序
- en: 'Place your robot in a well-lit environment, with your colored ball approximately
    a meter in front of it. Then boot up the Pi on your robot and view its desktop
    remotely over VNC. Next, open up a terminal application in the desktop, locate
    the *hsv_tester.py* program, and run it using the command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的机器人放置在一个光线良好的环境中，彩色球大约在它前方一米的位置。然后启动机器人上的树莓派，通过VNC远程查看其桌面。接着，在桌面上打开一个终端应用，找到*hsv_tester.py*程序，并使用以下命令运行它：
- en: '**NOTE**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I won’t go into the specifics of how this tester program works, because it’s
    very similar to the actual ball-following code that you will use in a few pages.
    I’ll follow that code up with the usual detailed explanation.*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*我不会详细介绍这个测试程序是如何工作的，因为它与接下来几页中你将使用的实际球跟踪代码非常相似。我会在代码之后进行通常的详细解释。*'
- en: pi@raspberrypi:~/robot $ python3 hsv_tester.py
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ python3 hsv_tester.py
- en: You’ll see a prompt asking you for a hue value between 10 and 245\. Try approximating
    the hue value of your ball; the ranges in [Table 8-1](ch08.xhtml#ch08tab1) should
    give you a rough idea of what end of the spectrum to start at. Mine is yellow,
    so I’m going to guess 40\. When you enter the value, you’ll see four new windows
    appear, showing you the different stages of image processing discussed previously
    (see [Figure 8-23](ch08.xhtml#ch08fig23)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个提示，要求你输入10到245之间的色调值。试着估算你球的色调值；[表8-1](ch08.xhtml#ch08tab1)中的范围应该能大致告诉你从哪个光谱端开始。我的球是黄色的，所以我会猜测40。输入这个值后，你将看到四个新窗口显示之前讨论的图像处理的不同阶段（参见[图8-23](ch08.xhtml#ch08fig23)）。
- en: '![image](../images/f184-01.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f184-01.jpg)'
- en: '**FIGURE 8-23** The four different windows of the HSV tester program'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-23** HSV测试程序的四个不同窗口'
- en: The first window, titled *Camera Output*, is a raw RGB video output directly
    from the Camera Module ➊. The second window, titled *HSV*, is the same video converted
    into HSV format ➋. Then, the window titled *Color Mask* displays the parts of
    the image that match the hue number you provided ➌. Finally, the window titled
    *Final Result* overlays the color mask with the original video feed, showing you
    the isolated area ➍.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个窗口，标题为*摄像头输出*，是直接从摄像头模块➊获取的原始RGB视频输出。第二个窗口，标题为*HSV*，是将同一视频转换为HSV格式➋。接着，标题为*颜色遮罩*的窗口显示了与您提供的色调值匹配的图像部分➌。最后，标题为*最终结果*的窗口将颜色遮罩与原始视频流叠加，显示出隔离的区域➍。
- en: If the mask in the Final Result window is more or less ball-shaped, you have
    your hue!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最终结果窗口中的遮罩大致呈球形，你就找到了你的色调值！
- en: It is unlikely that you’ll get your hue value correct the first time, just as
    I haven’t—the hue didn’t match my ball but instead it got parts of the stapler
    in the frame! To try again, select any of the output windows (but not the terminal
    window), and press Q on your keyboard. This will freeze the video output, and
    you can then go back to the terminal and enter another value to try.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你不太可能第一次就能准确得到色调值，就像我一样——色调没有匹配到我的球，而是匹配到画面中的订书机！若要重试，选择任何一个输出窗口（但不要选择终端窗口），然后按键盘上的Q键。这将冻结视频输出，你可以返回终端并输入另一个值进行尝试。
- en: Play around and tweak the hue until you get a definitive match for your colored
    ball. After a little while, I found that my magic number was 28\. When you have
    found yours, you should see that the majority of your ball and not much else is
    left in the frame, like mine in [Figure 8-24](ch08.xhtml#ch08fig24).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 多尝试并调整色调值，直到你找到与你的彩色球完全匹配的色调。经过一段时间，我发现我的魔法数字是28。找到你的值后，你应该能看到大部分球体而其他部分几乎不在画面中，就像我在[图
    8-24](ch08.xhtml#ch08fig24)中的样子。
- en: '![image](../images/f185-01.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f185-01.jpg)'
- en: '**FIGURE 8-24** My output windows after I correctly identified my hue number
    as around 28'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-24** 我正确识别出我的色调值约为28时的输出窗口'
- en: Make a note of the value, as you’ll need it soon. After you’ve found the right
    number, close the HSV tester program by pressing CTRL-C in the terminal window.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 记下这个值，因为你很快就需要它。在找到正确的数字后，通过在终端窗口按CTRL-C来关闭HSV测试程序。
- en: Programming Your Raspberry Pi to Follow a Ball
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编程让你的树莓派跟随一个球
- en: 'With all of the groundwork in place, you can now program your Raspberry Pi
    robot to follow a ball! The program we’ll be using is relatively long and more
    advanced than anything you’ve met so far, so I recommend downloading it from the
    software bundle rather than copying it from this book to minimize typos. The program
    is called *ball_follower.py* and you can check it out with the command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有基础工作完成后，你现在可以编程让你的树莓派机器人跟随一个球！我们将使用的程序相对较长，并且比你目前遇到的任何程序都要复杂，所以我建议从软件包中下载它，而不是从这本书中复制，以减少输入错误。该程序名为*ball_follower.py*，你可以通过以下命令查看它：
- en: pi@raspberrypi:~/robot $ nano ball_follower.py
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ nano ball_follower.py
- en: This program is 75 lines long, so for the explanation I’ve split it into sections
    and will explain how each part works. If you’re more interested in just running
    the code first and understanding how it works later, skip ahead to the next section
    on [page 193](ch08.xhtml#page_193).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序有75行，因此在解释时我将它分成几个部分，并说明每个部分的工作原理。如果你更希望先运行代码并稍后理解它的工作方式，可以跳到[第193页](ch08.xhtml#page_193)的下一节。
- en: Importing Packages and Setting Up the Camera Module
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 导入包并设置摄像头模块
- en: First we’ll import the packages we need and set a few things up, as shown in
    [Listing 8-1](ch08.xhtml#ch08list1).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将导入所需的包并进行一些设置，如[清单 8-1](ch08.xhtml#ch08list1)所示。
- en: '[PRE1]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**LISTING 8-1** Importing libraries and setting up the Camera Module'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 8-1** 导入库并设置摄像头模块'
- en: The first lines of the program ➊ import the necessary libraries, including various
    parts of the PiCamera library needed to allow us to use the Camera Module in Python.
    We also import the OpenCV library, `cv2`; `gpiozero` as usual; and the NumPy library,
    `np`. NumPy is a Python package used for scientific computing and will be useful
    for manipulating the image data later.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的前几行➊导入了必要的库，包括PiCamera库的各个部分，这些部分使我们能够在Python中使用摄像头模块。我们还导入了OpenCV库`cv2`，像往常一样导入`gpiozero`，以及NumPy库`np`。NumPy是一个用于科学计算的Python包，稍后在处理图像数据时会非常有用。
- en: 'At ➋, we initiate a PiCamera object and assign it to the `camera` variable
    for use throughout the program. Next we define the size ➌ and resolution ➍ of
    the images being fed from the camera. We won’t need full-HD video frames and they
    would just slow down speed and performance, so we downgrade the resolution to
    standard definition: 640×480 pixels. On the lines following this, we specify the
    frame rate of the camera and the raw capture setup.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➋ 处，我们初始化一个 PiCamera 对象，并将其分配给 `camera` 变量，在整个程序中使用。接下来，我们定义相机捕获的图像的大小 ➌ 和分辨率
    ➍。我们不需要全高清视频帧，因为它们会降低速度和性能，所以我们将分辨率降到标准清晰度：640×480 像素。在接下来的几行中，我们指定了相机的帧率和原始捕获设置。
- en: The two lines at ➎ work out where the center of the image is. This information
    will be used later to determine and compare where the ball is in the frame.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 处的两行代码计算出图像的中心位置。稍后将使用这些信息来确定并比较球体在图像中的位置。
- en: Then at ➏, we set a minimum and maximum area for the colored ball. This prevents
    your robot from detecting and following any colored object smaller than 250 square
    pixels or larger than 100,000 square pixels. These are arbitrary numbers that
    I’ve found work pretty well, but if you want to change them later, feel free!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 ➏ 处，我们为彩色球设置了最小和最大面积。这可以防止你的机器人检测到小于 250 平方像素或大于 100,000 平方像素的任何彩色物体。这些是我发现效果相当不错的任意数字，但如果你想稍后更改它们，随时可以！
- en: Setting Up the Robot and Color Values
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置机器人和颜色值
- en: This section deals with the final part of the setup process, shown in [Listing
    8-2](ch08.xhtml#ch08list2).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本节内容涉及设置过程的最后部分，如 [Listing 8-2](ch08.xhtml#ch08list2) 所示。
- en: '[PRE2]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**LISTING 8-2** Setting up the robot and color values'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**LISTING 8-2** 设置机器人和颜色值'
- en: We set up the robot and its motor pins as before and then define two variables
    for both the forward and turning speeds ➊, with the values 0.3 and 0.2, respectively.
    This will limit the speed of your robot when it moves toward your colored ball.
    Again, these are arbitrary numbers, so you can change them if you find that higher
    or lower values work better for you and your robot.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像之前一样设置机器人及其电机引脚，然后定义两个变量，分别用于前进速度和转向速度 ➊，值分别为 0.3 和 0.2。这将限制机器人朝向彩色球体时的移动速度。同样，这些是任意的数字，如果你发现更高或更低的值对你和你的机器人更有效，随时可以更改它们。
- en: At ➋, we set the number for the hue. This is a value you *must change* to the
    value you found earlier using the HSV tester program. I have set mine to 28.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➋ 处，我们设置了色调的数值。这是一个你*必须更改*的值，需要使用之前通过 HSV 测试程序找到的值。我将我的设置为 28。
- en: Next we set a range of values for the robot to check for instead of a precise
    one ➌. That way, changes in the environment, like the room’s lighting and how
    bright it is, will still fall within this small range and therefore the ball will
    continue to be detected. We do this by using arrays to create the upper and lower
    bounds of the color in HSV format.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置了一个值的范围供机器人检查，而不是一个精确的数值 ➌。这样，环境的变化，比如房间的照明和亮度变化，仍会保持在这个小范围内，因此球体会继续被检测到。我们通过使用数组来创建
    HSV 格式下颜色的上下限来实现这一点。
- en: In programming, an *array* is a collection of information where each piece of
    data in the array has an *index*, or location, associated with it. Arrays can
    be as long as you like and can store anything you want, from people’s names to
    types of animal to lists of numbers. In Python, the first piece of data in an
    array has an index of 0, the second piece has an index of 1, the third piece has
    an index of 2, and so on—in other words, Python starts counting the items in an
    array at 0\. This means that, in a Python program, you could ask for the piece
    of information stored in the array at index 3, for example, and it would return
    the data found in the fourth position.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，*数组*是一个信息集合，其中每个数据项都有一个*索引*或位置与之相关联。数组可以根据需要长得无限大，可以存储你想要的任何东西，从人名到动物种类，再到数字列表。在
    Python 中，数组中的第一个数据项的索引是 0，第二个数据项的索引是 1，第三个数据项的索引是 2，以此类推——换句话说，Python 从 0 开始计算数组中的项目。这意味着，在
    Python 程序中，你可以请求数组中索引为 3 的数据项，它将返回在第四个位置的那项数据。
- en: In this situation, we use arrays to represent the HSV format, as each HSV color
    can be described with three numbers (the hue, saturation, and value). Notice that
    we actually search for hues ±10 in either direction, and that the range for the
    saturation and value components of the color goes from 100 to 255\. This ensures
    that the robot will look for a broader range of colors in each frame from the
    camera and improves the odds that it will detect the target colored ball.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用数组表示HSV格式，因为每种HSV颜色都可以用三个数字来描述（色调、饱和度和亮度）。注意，我们实际上搜索的是色调±10的范围，并且饱和度和亮度的范围是从100到255。这确保机器人在每帧图像中会寻找更广泛的颜色范围，提高了它检测目标彩色球的概率。
- en: These arrays are available to use through the NumPy library we imported. We
    use NumPy here because it is a highly optimized library for fast array calculations.
    This gives us the speed necessary to access and analyze each pixel of each frame.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数组可以通过我们导入的NumPy库使用。我们在这里使用NumPy，因为它是一个经过高度优化的库，专门用于快速数组计算。这为我们提供了必要的速度，以便访问和分析每一帧中的每一个像素。
- en: Analyzing the Camera Frames
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 分析相机帧
- en: The third section of the program is shown in [Listing 8-3](ch08.xhtml#ch08list3).
    This is where the bulk of the code and computer vision process starts.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第三部分显示在[Listing 8-3](ch08.xhtml#ch08list3)中。这是代码和计算机视觉过程的主要部分。
- en: '[PRE3]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**LISTING 8-3** Starting capture `for` loop, converting image, and finding
    contours'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**LISTING 8-3** 开始捕获`for`循环，图像转换，和寻找轮廓'
- en: 'At ➊, we initiate a `for` loop that, translated into plain English, reads:
    “for each frame from the Camera Module, do this.”'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们启动了一个`for`循环，翻译成通俗的英语就是：“对于相机模块的每一帧，执行以下操作。”
- en: Next, the information from the current frame is saved to the variable `image`
    as an array ➋. The RGB data of image is then converted into an HSV format ➌ using
    an OpenCV function, `cvtColor()`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当前帧的信息被保存到变量`image`中，作为一个数组 ➋。然后，图像的RGB数据通过OpenCV的`cvtColor()`函数转换为HSV格式
    ➌。
- en: Once the HSV data has been acquired, the color mask, which keeps *only* your
    desired color, is created ➍. We use OpenCV’s `inRange()` function so that the
    mask keeps all of the colors that fall between the lower and upper bounds of your
    color choice.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取到HSV数据，就会创建色彩遮罩，该遮罩*仅保留*你希望的颜色，步骤为 ➍。我们使用OpenCV的`inRange()`函数，以便遮罩保留所有位于你选择的颜色上下限之间的颜色。
- en: The next stage of the process is to draw lines around each distinct object in
    the mask so that the area of each detected object can be compared later. We do
    this at ➎, using OpenCV’s `findContours()` function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 过程的下一阶段是为每个独立的物体在遮罩上绘制边框，这样就可以在后续对每个检测到的物体的区域进行比较。我们在➎步骤中使用OpenCV的`findContours()`函数来完成这一操作。
- en: Comparing Contours to Find Your Ball
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 比较轮廓以找到你的球
- en: Next up is [Listing 8-4](ch08.xhtml#ch08list4), which compares each contour
    and identifies the largest one.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是[Listing 8-4](ch08.xhtml#ch08list4)，它比较每个轮廓并识别出最大的一个。
- en: '[PRE4]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**LISTING 8-4** Comparing and finding the largest contour'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**LISTING 8-4** 比较并找到最大轮廓'
- en: We create three variables ➊ that will later be used to store the largest object’s
    area and center coordinates. Initially we set these to zero.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了三个变量➊，这些变量稍后将用来存储最大物体的面积和中心坐标。最初，我们将它们设置为零。
- en: 'At ➋ we start a `for` loop that will loop through each and every detected contour.
    The code at ➌ will draw a rectangular box around a contour to approximate its
    shape. This is known as a *bounding box*, and it just makes the objects easier
    to work with. We assign the details of this bounding box to four new variables:
    `x`, `y`, `width`, and `height`. As you’d expect, `width` and `height` represent
    the width and height of the rectangle; `x` and `y` represent the x- and y-coordinates
    of the *top left* of the box.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在➋处，我们开始了一个`for`循环，它会遍历每个检测到的轮廓。代码在➌处会为一个轮廓绘制一个矩形框来近似它的形状。这被称为*边界框*，它让物体处理起来更简单。我们将这个边界框的细节赋值给四个新变量：`x`、`y`、`width`和`height`。如你所料，`width`和`height`代表矩形的宽度和高度；`x`和`y`代表矩形左上角的x和y坐标。
- en: 'Next, we calculate and store the area of the current contour using the formula
    for the area of a rectangle: width × height ➍. Then we figure out the center coordinates
    of the current contour ➎ to let the program know where in the frame this particular
    object is located. Knowing the coordinates of the center of the object is far
    more useful than knowing where its top-left corner is.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用矩形面积公式（宽度 × 高度 ➍）计算并存储当前轮廓的面积。然后我们计算并确定当前轮廓的中心坐标 ➎，让程序知道这个物体在帧中的位置。知道物体中心的坐标比知道它的左上角要有用得多。
- en: At ➏ we compare the current contour’s area with the previous largest area already
    found. If the current contour is larger than the previous one, we assume that
    the larger area is most likely your colored ball. Consequently, the previous contour’s
    information is discarded, and the details of the new contour are overwritten on
    the three variables used to store the largest object’s area and center coordinates.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➏ 处，我们将当前轮廓的面积与之前找到的最大面积进行比较。如果当前轮廓的面积比之前的大，我们假设较大的面积很可能就是你的彩色球。因此，之前的轮廓信息会被丢弃，新的轮廓的详细信息会覆盖用于存储最大物体面积和中心坐标的三个变量。
- en: Once the `for` loop ➋ has finished, and all of the contours have been compared,
    the program verifies that a suitable contour has been found and uses an `if` statement
    ➐ to check whether the area of the contour is larger than 0\. If it is, the largest
    contour, and therefore probably the ball, has been found and its exact details
    are saved in a list (a type of basic array) to a variable called `ball_location`.
    If a contour hasn’t been found, the variable `ball_location` is set to `None`
    in the `else` clause ➑.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`for`循环 ➋ 完成，所有轮廓都被比较过，程序会验证是否找到了合适的轮廓，并通过`if`语句 ➐ 检查该轮廓的面积是否大于0。如果是，说明找到了最大的轮廓，因此可能就是球，并将其详细信息保存在一个名为`ball_location`的列表（即一种基本数组）中。如果没有找到轮廓，`ball_location`变量将在`else`子句
    ➑ 中被设置为`None`。
- en: Making Your Robot React to the Ball
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 让你的机器人对球做出反应
- en: The last part of the program, found in [Listing 8-5](ch08.xhtml#ch08list5),
    deals with making your robot move depending on where the colored ball has been
    detected in the frame.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后一部分，在[Listing 8-5](ch08.xhtml#ch08list5)中，处理了让机器人根据在帧中检测到的彩色球的位置来移动。
- en: '[PRE5]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**LISTING 8-5** Making the robot move depending on where the ball is found'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**LISTING 8-5** 根据球的位置让机器人移动'
- en: This part of the code features a lot of `if`, `elif`, and `else` statements
    and jumps around, so go through it carefully and pay attention to the indentation
    to understand how each statement is constructed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分代码包含了许多`if`、`elif`和`else`语句，并且跳转较多，因此需要仔细阅读，特别注意缩进，以理解每个语句是如何构建的。
- en: We declare a simple `if` statement ➊ that translates to “if there was a ball
    found, do this.” If there is no ball found, the program skips right down to the
    `else` statement ➑. The program then tells the user that a suitable target wasn’t
    found and commands your robot to turn left in order to search for the ball in
    the surrounding environment.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个简单的`if`语句 ➊，意思是“如果找到了球，就做这个”。如果没有找到球，程序会直接跳到`else`语句 ➑。程序随后会告诉用户没有找到合适的目标，并指示机器人左转，以便在周围环境中搜索球。
- en: If a ball was found in the current frame, an `if` statement ➋ detects whether
    the size of the ball (stored in the `ball_location` list at index 0) is within
    the area values you defined at the start of the program. If the object detected
    is too small, the robot starts to turn to see if it can find a larger target ➏.
    If the object detected is too large (caught by the `else` statement ➐), the robot
    moves no closer to the ball and stops.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在当前帧中发现了一个球，`if`语句 ➋ 会检测球的大小（存储在`ball_location`列表的索引0处）是否在程序开始时定义的区域值范围内。如果检测到的物体太小，机器人会开始转动，看看是否能找到更大的目标
    ➏。若检测到的物体太大（被`else`语句 ➐ 捕获），机器人不会再接近球并停止。
- en: If the ball *is* in frame and the robot *does* need to move, the code through
    ➏ handles this. At ➌ we use an `if` statement to detect whether the x-coordinate
    of the ball in the frame is greater than the center point *plus a third of the
    image width*. If this is the case, the ball must be in the right-hand side of
    the frame and consequently the robot moves right.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果球*在*帧中，并且机器人*确实*需要移动，代码通过 ➏ 处理这一情况。在 ➌ 处，我们使用`if`语句来检测帧中球的x坐标是否大于中心点*加上图像宽度的三分之一*。如果是这种情况，球一定在帧的右侧，机器人因此向右移动。
- en: The code at ➍ does the same thing but sees whether the x-coordinate of the ball
    in the frame is less than the center point *plus a third of the image width*.
    In this case, the robot turns left.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 位置 ➍ 的代码做的是相同的事情，但它会查看球在帧中的 x 坐标是否小于中心点*加上图像宽度的三分之一*。在这种情况下，机器人会向左转。
- en: Finally, if the ball is not in either the left or right of the image, it must
    be in front of your robot and therefore the robot is instructed to move forward
    ➎.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果球不在图像的左侧或右侧，它一定在你机器人前面，因此机器人会被指示向前移动➎。
- en: 'As you can see in [Figure 8-25](ch08.xhtml#ch08fig25), the camera frame is
    essentially being split into three different areas by this code: left, right,
    and forward. We use a third of the whole frame’s width on either side of the center
    point to be the middle section. This means that the middle section represents
    two-thirds of each frame. If the ball is found here, the robot moves forward.
    If it’s found on either side, the robot moves left or right. The left and right
    sections are a sixth of each frame, respectively.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 8-25](ch08.xhtml#ch08fig25)所示，这段代码基本上将摄像头帧分成了三个不同的区域：左侧、右侧和前方。我们使用整个帧宽度的三分之一作为中心点两侧的中间部分。也就是说，中间部分代表了每帧的三分之二。如果球出现在这里，机器人就会向前移动。如果球出现在任一侧，机器人就会向左或向右移动。左侧和右侧区域分别是每帧的六分之一。
- en: And that’s all there is to the ball-following program! The code may have appeared
    complicated at first, but as with most things in computer science, if you break
    it down and look at it carefully, you’ll find it is made out of the same simple
    concepts you’ve used before.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是跟随球体程序的全部内容！刚开始看起来代码可能有些复杂，但和计算机科学中的大多数事情一样，如果你分解开并仔细观察，你会发现它由之前用过的简单概念构成。
- en: '![image](../images/f192-01.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f192-01.jpg)'
- en: '**FIGURE 8-25** A diagram of how the frames are split into three areas for
    movement'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-25** 一张显示如何将帧分割为三个区域以便进行移动的示意图'
- en: 'Running Your Program: Make Your Robot Follow a Colored Ball!'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行程序：让你的机器人跟随一个彩色球！
- en: 'Now you can get to the exciting part of this project: actually making your
    robot follow your colored ball. Power your robot with its batteries and place
    it on the floor or another large flat surface. Also place your colored ball somewhere
    in this environment, as shown in [Figure 8-26](ch08.xhtml#ch08fig26).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以进入这个项目的激动人心的部分了：让你的机器人真正开始跟随你的彩色球。给机器人安装电池，并将其放置在地面或其他大型平坦的表面上。同时将彩色球放置在这个环境中的某个地方，如[图
    8-26](ch08.xhtml#ch08fig26)所示。
- en: '![image](../images/f192-02.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f192-02.jpg)'
- en: '**FIGURE 8-26** My robot, ready to hunt my yellow ball!'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8-26** 我的机器人，准备去追寻我的黄色球！'
- en: 'When you have everything set up, run the program with this command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切设置好后，使用以下命令运行程序：
- en: pi@raspberrypi:~/robot $ python3 ball_follower.py
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ python3 ball_follower.py
- en: Your robot should spring to life and start hunting down your colored ball. Play
    a game of fetch with your new smart pet!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你的机器人应该会活跃起来，开始追踪你的彩色球。和你新智能的宠物玩一场取球游戏吧！
- en: As usual, press CTRL-C to stop this program.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，按CTRL-C停止程序。
- en: EXPERIMENTING WITH IMAGE PROCESSING
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 实验图像处理
- en: As with the line-following project in the previous chapter, computer vision
    and image processing are areas of computer science and robotics that lend themselves
    to fine-tuning in order to improve results and capabilities. Here are some suggestions
    for you to play around with.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一章中的跟随线项目一样，计算机视觉和图像处理是计算机科学和机器人领域的两个方向，这些领域往往需要精细调节，以改善结果和能力。这里有一些建议，供你进行实验。
- en: Color and Object
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色与物体
- en: While your colored ball is a great starting target for your robot, you can easily
    take it even further. For example, why not introduce a second color by scanning
    each frame for a secondary set of HSV values? Make your robot follow both yellow
    and red objects, for example. Remember that you can go back to the HSV tester
    program to work out the hue and color codes of other shades!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你的彩色球是机器人一个很好的起始目标，但你可以轻松地将其扩展。例如，为什么不通过扫描每一帧来引入第二种颜色，寻找一组次要的HSV值呢？让你的机器人跟随黄色和红色物体，比如说。记得你可以回到HSV测试程序，找出其他颜色的色调和颜色代码！
- en: You’re also not just restricted to balls. You can make your robot follow or
    seek anything that is primarily a single color. Experiment with other objects
    that you have lying around!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅仅局限于球体。你可以让你的机器人跟随或寻找任何主要是单一颜色的物体。尝试用你周围的其他物品做实验吧！
- en: Speed
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 速度
- en: 'How fast your robot moves does have a big effect on the quality of its image
    processing: usually, the faster it goes, the more likely it is to miss your colored
    object. That said, feel free to play around with the speed values defined at the
    start of the ball-following program—you may be able to fine-tune and improve your
    robot’s performance!'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人移动的速度对图像处理的质量有很大的影响：通常来说，速度越快，错过目标颜色物体的可能性越大。话虽如此，欢迎你尝试调整在追踪球程序开始时定义的速度值——你可能会调试并改善机器人的表现！
- en: Minimum/Maximum Area of Object
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 目标物体的最小/最大面积
- en: Experiment with the minimum and maximum area of the target object. Remember
    that your robot by default will not move toward anything smaller than 250 square
    pixels, and it will stop at anything larger than 100,000 square pixels.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 试验目标物体的最小和最大面积。记住，默认情况下，你的机器人不会朝小于250平方像素的物体移动，而且会停在大于100,000平方像素的物体前。
- en: By changing these numbers, you can make your robot move toward targets that
    are potentially smaller or even stop closer to the target. A fun idea is to increase
    the maximum area to a point where your robot won’t stop when it gets close to
    your colored ball. The result is that your robot usually ends up bumping into
    the ball and “kicking” it . . . only to trundle after it again and repeat the
    process!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改这些数值，你可以让机器人朝着可能较小的目标移动，甚至在离目标更近时停下。一个有趣的想法是增加最大面积，直到机器人在接近你的彩色球时不会停下。结果就是，机器人通常会撞上球并“踢”它……然后再跟着它滚动，重复这个过程！
- en: Remember that each frame of the video feed from your Camera Module measures
    640×480 pixels, so a value of 307,200 is the maximum number of square pixels possible.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你的摄像头模块每一帧视频的分辨率是640×480像素，因此307,200是可能的最大平方像素数。
- en: Avoidance Behavior
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 避免行为
- en: At the moment, your robot loves your colored ball, but what if you made it so
    the opposite was true? Try editing the program so that your robot runs away from
    the object, rather than toward it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，机器人喜欢你的彩色球，但如果你改变它的行为，让它害怕彩色球会怎么样呢？尝试编辑程序，让机器人跑开，而不是朝球移动。
- en: An extension of this would be to make your robot move toward certain colored
    balls, but run away from others. For example, it could love red balls but be terrified
    of yellow ones!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的扩展可以让你的机器人朝某些颜色的球移动，而避免其他颜色的球。例如，它可以喜欢红色的球，但对黄色的球感到害怕！
- en: SUMMARY
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you’ve given your robot the advanced ability to seek out, recognize,
    and follow a colored ball. You have learned the basics of image processing and
    implemented an entire computer vision process in Python using the official Raspberry
    Pi Camera Module.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你赋予了机器人寻找到、识别并追踪彩色球的高级能力。你已经学习了图像处理的基础，并使用官方的树莓派摄像头模块在Python中实现了整个计算机视觉过程。
- en: And with that you have completed the projects section of this book! Your little
    robot is now all grown up, and you’re its proud parent. This isn’t the end of
    the line though; check out “Next Steps” on [page 195](bm01.xhtml#page_195) for
    some guidance and suggestions for continuing your adventures in robotics, programming,
    and Raspberry Pi.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，你已经完成了本书的项目部分！你的小机器人现在已经长大，而你就是它骄傲的父母。不过，这并不是终点；请查看[第195页](bm01.xhtml#page_195)的“下一步”部分，获取继续进行机器人、编程和树莓派冒险的指导和建议。
