- en: '**14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**14**'
- en: SIGNAL AND IMAGE PROCESSING**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号与图像处理**'
- en: '*I studied Latin in high school, and I was reading stuff from Cicero. And that
    signal took a few thousand years to get to me. But I was still interested in what
    he had to say.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在高中学习了拉丁语，并且我当时在阅读西塞罗的作品。这个信号花了几千年才传到我这里。不过，我仍然对他所说的内容感兴趣。*'
- en: —Seth Shostak
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —Seth Shostak
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'This chapter contains examples from problems in both signal and image processing.
    The two subjects are usually considered germane to unrelated areas of research:
    signal processing interests the audio or electrical engineer, while image processing
    is relevant to biologists and astronomers. However, they belong together because
    they use many of the same techniques, and the relevant tools have the same mathematical
    foundations. For many purposes, we can think of an image as just a two-dimensional
    signal, and apply similar algorithms to transform, smooth, filter, and more, extending
    the single time dimension to two (or three) space dimensions.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含了来自信号和图像处理问题的示例。这两个学科通常被认为与不相关的研究领域相关：信号处理吸引音频或电子工程师，而图像处理则与生物学家和天文学家相关。然而，它们是紧密相连的，因为它们使用许多相同的技术，并且相关的工具有着相同的数学基础。对于许多用途，我们可以把图像看作只是一个二维信号，并应用类似的算法来进行转换、平滑、滤波等，将单一的时间维度扩展到两个（或三个）空间维度。
- en: We’ll first look at one-dimensional signals, considering the common case of
    an independent coordinate representing time. After that, we’ll explore Julia’s
    packages for image processing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将研究一维信号，考虑独立坐标表示时间的常见情况。之后，我们将探索Julia的图像处理包。
- en: '**Signals in Time**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**时间中的信号**'
- en: Sound comes to us as a time-varying air pressure, and we store it as a record
    of amplitude versus time, where the amplitude may represent direct measurements
    of pressure or its conversion to electrical voltages or some other quantity by
    our measuring apparatus. We’ll explore signal processing in Julia by working with
    a sound from nature.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 声音以时变的气压形式传入我们的耳朵，我们将其存储为幅度与时间的记录，其中幅度可能代表压力的直接测量，或是通过我们的测量设备将其转换为电压或其他某种量。我们将通过在Julia中处理来自自然的声音来探讨信号处理。
- en: '***Exploring a Sound Sample***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***探索声音样本***'
- en: 'Our real-life sound is the call of the endangered cactus ferruginous pygmy
    owl (*Glaucidium brasilianum cactorum*), a native of Arizona. I found the sound
    sample at [*http://www.naturesongs.com/falcstri.html#cobo*](http://www.naturesongs.com/falcstri.html#cobo)
    and saved it on disk with the filename *cfpo1.wav*. The sample is a WAV file:
    a common file format for audio that nearly any music playback or sound editing
    software, on any operating system, can play. Listening to the sample reveals a
    call consisting of a short, medium-high-pitched vocalization repeated about three
    times per second for about 12 total seconds.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现实生活中的声音是濒危的铁锈小型仙人掌猫头鹰（*Glaucidium brasilianum cactorum*）的叫声，它是亚利桑那州的本土物种。我在[*http://www.naturesongs.com/falcstri.html#cobo*](http://www.naturesongs.com/falcstri.html#cobo)
    找到了这个声音样本，并将其保存为文件名为 *cfpo1.wav* 的磁盘文件。这个样本是一个WAV文件：一种常见的音频文件格式，几乎任何音乐播放或声音编辑软件、在任何操作系统下都能播放。听这个样本可以听到一个叫声，由一个简短的、中等偏高音的发声组成，大约每秒重复三次，总共持续约12秒。
- en: '**NOTE**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*WAV files are often described erroneously as “uncompressed” audio. The audio
    data they contain is almost always compressed using one of a handful of available
    lossless compression algorithms (similar to the compression used in the ZIP family
    of file compression utilities). They take up far more space than the same sound
    compressed using a perceptual encoder such as that used for MP3 files, but such
    files are not useful for scientific signal processing and analysis.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*WAV文件常被错误地描述为“无压缩”的音频。它们包含的音频数据几乎总是使用少数几种无损压缩算法进行压缩（类似于ZIP文件压缩工具所使用的压缩）。它们占用的空间比使用感知编码器（例如MP3文件所用的压缩方式）压缩的同一声音要大得多，但这种文件对于科学信号处理和分析没有用处。*'
- en: 'In a Linux terminal, we can get some information about the file using the `file`
    command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux终端中，我们可以使用 `file` 命令获取有关文件的一些信息：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The output reflects the most common file format; the data is little-endian because
    the WAV format was invented at Microsoft. The third clause names the compression
    algorithm; Microsoft PCM is the most common. The rest of the output means that
    the samples were saved with 8 bits of precision, providing 2⁸ = 256 available
    amplitude levels per point, and that we have one channel sampled at 8,000 samples
    per second.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 输出反映了最常见的文件格式；数据采用小端格式，因为 WAV 格式是在微软发明的。第三个子句指定了压缩算法；Microsoft PCM 是最常见的格式。其余输出表示样本以
    8 位精度保存，每个点提供 2⁸ = 256 个可用的幅度级别，并且我们有一个以每秒 8,000 次采样的通道。
- en: 'Back in the Julia REPL, let’s read in the sample, assign it to `cfpo`, and
    plot the waveform:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 Julia REPL，我们来读取样本，将其赋值给 `cfpo`，并绘制波形：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First we import two convenient packages for signal analysis. All the other examples
    in this section assume this `using` statement. The `SignalAnalysis.Units` package
    provides time and frequency unit abbreviations, and a handy form of time-based
    indexing that we’ll use later.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入两个便捷的信号分析包。本节的所有其他示例都假设使用了这一 `using` 语句。`SignalAnalysis.Units` 包提供了时间和频率单位的缩写，并提供了一种便捷的基于时间的索引形式，我们稍后将使用它。
- en: The `signal()` function has many methods. When supplied with a string, it loads
    the named file and packages the data into a type defined in the package. The `SignalAnalysis`
    package also extends `Plots` to be able to plot signals directly. [Figure 14-1](ch14.xhtml#ch14fig1)
    shows the waveform of the owl call.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`signal()` 函数有很多方法。当传入一个字符串时，它会加载指定的文件，并将数据打包成包中定义的类型。`SignalAnalysis` 包还扩展了
    `Plots`，使其能够直接绘制信号。[图 14-1](ch14.xhtml#ch14fig1) 显示了猫头鹰叫声的波形。'
- en: '![Image](../images/ch14fig01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch14fig01.jpg)'
- en: '*Figure 14-1: The call of the cactus ferruginous pygmy owl*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-1：仙人掌铁锈小猫头鹰的叫声*'
- en: As the sound sample contains 100,558 elements, plotting is not instantaneous.
    The plot recipe uses information about the sample rate to create a correct time
    axis, and labels the axis as well. The `signal()` function rescales the 8-bit
    samples to `Float64` numbers ranging from –1.0 to 1.0.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于声音样本包含 100,558 个元素，绘图不是即时的。图表配方使用采样率信息来创建正确的时间轴，并对轴进行标注。`signal()` 函数将 8 位样本重新缩放为
    `Float64` 数字，范围从 -1.0 到 1.0。
- en: 'The `SignalAnalysis` package supplies several functions for extracting information
    about the signal. The following are the most important of these:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`SignalAnalysis` 包提供了几个用于提取信号信息的函数。以下是其中最重要的几个：'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The term `nframes` refers to samples and `duration()` reports the length of
    the signal in seconds.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`nframes` 这个术语指的是样本数，而 `duration()` 则报告信号的时长（单位为秒）。'
- en: '[Figure 14-1](ch14.xhtml#ch14fig1) shows the three-chirps-per-second structure
    of the owl call clearly, but we can’t tell what note the owl is singing. Let’s
    zoom in:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-1](ch14.xhtml#ch14fig1) 清晰地展示了猫头鹰叫声的每秒三声啼叫结构，但我们无法判断猫头鹰在唱什么音符。让我们放大一下：'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first two plot statements take advantage of the convenient time-based indexing
    that the `SignalAnalysis` package enables. It frees us from having to convert
    between time and index number of the signal data. The indexing works only with
    seconds and only with a range of floats. To access the single frame at two seconds,
    we can write `cfpo[2.0:2.0s]`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个绘图语句利用了 `SignalAnalysis` 包所提供的便捷基于时间的索引功能。它让我们无需在信号数据的时间和索引号之间进行转换。该索引仅适用于秒，并且仅适用于浮动范围。要访问两秒时的单帧数据，我们可以写作
    `cfpo[2.0:2.0s]`。
- en: '[Figure 14-2](ch14.xhtml#ch14fig2) shows the combined plot: two segments of
    the signal at two different scales. The plot recipe always labels the plots beginning
    at `t = 0`, but we can always define `xticks` to reference the original time interval
    if desired.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-2](ch14.xhtml#ch14fig2) 显示了组合图：信号的两个不同尺度的两个片段。图表配方总是从 `t = 0` 开始标记图表，但我们始终可以定义
    `xticks` 来引用原始时间区间（如果需要）。'
- en: '![Image](../images/ch14fig02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch14fig02.jpg)'
- en: '*Figure 14-2: Two magnified segments of the owl call*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：猫头鹰叫声的两个放大片段*'
- en: The bottom plot in [Figure 14-2](ch14.xhtml#ch14fig2) is in the middle of one
    of the chirps, and is sufficiently magnified to allow us to count cycles easily.
    There appear to be about 3.25 cycles in 2.5 ms (most easily counted from *t* =
    5.0 ms, where a peak of the wave happens to align exactly with a grid line, to
    *t* = 7.5 ms), which is a frequency of 3.25/2.5e–3 = 1,300.0 Hz, which is very
    close to the musical note E[6].
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-2](ch14.xhtml#ch14fig2)中的底部图位于其中一个啁啾信号的中间，并且被足够放大，以便我们轻松数出周期。在2.5毫秒的时间内大约有3.25个周期（从
    *t* = 5.0毫秒开始数，波形的峰值恰好与网格线对齐，到 *t* = 7.5毫秒），这对应的频率是3.25/2.5e–3 = 1,300.0 Hz，非常接近音乐音符
    E[6]。'
- en: '***Analyzing Frequencies***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***频率分析***'
- en: One of the senses of the word *analysis* is the separating of something into
    component parts. We’ll perform two types of frequency analysis of signals. The
    first type converts the signal, a function of amplitude versus time, into a function
    of amplitude versus frequency. This is the purpose of the Fourier transform, which
    assumes that the signal is periodic, and analyzes it into a sum of periodic functions
    (sines and cosines of various amplitudes, sines or cosines of various phases and
    amplitudes, or complex exponentials—all equivalent representations). The representation
    as a sum of frequencies is the signal’s *spectrum*. The second type combines temporal
    and frequency information into a *spectrogram*. Here we no longer assume that
    the signal is periodic. The spectrogram shows us the spectrum as it varies in
    time.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*分析* 这个词的一个含义是将某物分解为组成部分。我们将对信号进行两种频率分析。第一种类型将信号（振幅对时间的函数）转化为振幅对频率的函数。这就是傅里叶变换的目的，它假设信号是周期性的，并将其分析为周期函数的和（正弦波和余弦波的不同振幅，或不同相位和振幅的正弦余弦，或者是复指数函数——这些都是等效的表示）。作为频率之和的表示就是信号的*频谱*。第二种类型将时间和频率信息结合成*频谱图*。在这里，我们不再假设信号是周期性的。频谱图展示了信号频谱随时间变化的情况。'
- en: 'The `SignalAnalysis` package provides several plotting routines we can use
    to visualize both types of frequency analysis. The `psd()` function plots the
    *power spectral density* of a signal based on its Fourier transform. Its interpretation
    is straightforward when applied to a periodic signal, which describes the owl
    call pretty well:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`SignalAnalysis` 包提供了几种绘图例程，可以用来可视化这两种类型的频率分析。`psd()` 函数绘制了信号的*功率谱密度*，这是基于其傅里叶变换的。它在应用于周期信号时，解释起来比较直观，这也很好地描述了猫头鹰的叫声：'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since `psd()` uses the `Plots` package, we can supply the familiar keyword arguments.
    [Figure 14-3](ch14.xhtml#ch14fig3) shows the spectrum.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `psd()` 使用了 `Plots` 包，我们可以提供熟悉的关键字参数。[图14-3](ch14.xhtml#ch14fig3) 显示了频谱。
- en: '![Image](../images/ch14fig03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch14fig03.jpg)'
- en: '*Figure 14-3: Fourier spectrum of the call of an owl*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：猫头鹰叫声的傅里叶频谱*'
- en: The spectrum has a peak just barely below 1,300 Hz, which agrees with our estimate
    from counting cycles of the waveform. We can also see peaks close to the second
    and third harmonics (twice and thrice 1,300 Hz).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 频谱在接近1,300 Hz的位置有一个峰值，这与我们通过数周期得到的估计一致。我们还可以看到接近第二和第三谐波的峰值（1,300 Hz的两倍和三倍）。
- en: Displays such as [Figure 14-3](ch14.xhtml#ch14fig3) are useful analytic and
    diagnostic tools, but they don’t convey a full idea of the nature of the signal
    under investigation. We can see that the signal is dominated by a 1,300 Hz frequency,
    with two strong overtones, but there’s no hint of the rapid staccato performance.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图14-3](ch14.xhtml#ch14fig3) 所示，显示图像是有用的分析和诊断工具，但它们并不能完全传达所研究信号的特性。我们可以看到信号以1,300
    Hz为主频，有两个强的泛音，但没有呈现出快速的断奏效果。
- en: 'For a fuller analysis, we turn to the spectrogram. The `SignalAnalysis` package
    also provides a function to create these visualizations easily:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行更全面的分析，我们转向频谱图。`SignalAnalysis` 包也提供了一个函数，可以轻松创建这些可视化图像：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Figure 14-4](ch14.xhtml#ch14fig4) contains the spectrogram, and clearly shows
    the frequency distribution of energy in the signal: the strong component near
    1,300 Hz and the two higher harmonics at lower amplitudes. We can also see the
    temporal structure; the chirps repeating at about three times per second are obvious.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-4](ch14.xhtml#ch14fig4)包含了频谱图，并清楚地显示了信号中能量的频率分布：1,300 Hz附近的强分量和两个较低振幅的高阶谐波。我们还可以看到时间结构；大约每秒三次重复的啁啾声音非常明显。'
- en: '![Image](../images/ch14fig04.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch14fig04.jpg)'
- en: '*Figure 14-4: Spectrogram of the owl call*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：猫头鹰叫声的频谱图*'
- en: Spectrograms use Fourier transforms and a *window* sliding over the signal to
    calculate the spectrum as it evolves, resulting in a visualization combining frequency
    and time information. They’re more informative than a `psd()`-type plot for any
    except periodic signals. Practical Fourier transform routines, such as the ones
    used by `psd()`, also use windowing, but for the purpose of eliminating the inevitable
    discontinuities at the edges of the signal and the resulting “leakage” of spurious
    high-frequency components.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 声谱图使用傅里叶变换和*窗口*在信号上滑动来计算其演变过程中的频谱，从而生成一个结合了频率和时间信息的可视化图。对于除周期信号外的任何信号，它们比`psd()`类型的图更具信息量。实际的傅里叶变换例程，如`psd()`使用的那些，也使用了窗口函数，但目的是消除信号边缘不可避免的断点以及由此产生的伪高频分量的“泄漏”。
- en: '**NOTE**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This section presents the quickest and most convenient methods for signal
    analysis, with an emphasis on getting to the visualizations that interest most
    scientists. For more control, or to obtain direct access to spectra, import the*
    DSP.jl *package. The* SignalAnalysis *package wraps many of its routines, but
    importing* DSP *grants access to its definitions for various Fourier transform
    windows and other details that we can invoke with keyword arguments to the higher-level*
    SignalAnalysis *routines such as* psd()*.*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*本节介绍了信号分析的最快和最便捷的方法，重点是获取大多数科学家感兴趣的可视化效果。如果需要更多控制，或直接获取频谱数据，请导入* DSP.jl *包。*
    SignalAnalysis *包封装了许多其例程，但导入* DSP *包可访问其各种傅里叶变换窗口的定义，以及其他可以通过关键字参数调用的细节，这些都能在更高级别的*
    SignalAnalysis *例程（如* psd() *）中使用。*'
- en: Now that we’ve dealt with two ways to examine the frequency spectra of signals,
    in the next section we’ll explore methods for transforming the signal by altering
    the spectrum.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了两种检查信号频谱的方法，在下一节中，我们将探讨通过改变频谱来转换信号的方法。
- en: '***Filtering***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***滤波***'
- en: A *filter* in the context of signal processing is a circuit, device, or, in
    our case, a computation, that attenuates some of the frequencies present in a
    signal. Perhaps the most familiar examples are the crossover circuits in speakers
    that route the high frequencies to the tweeters and the low frequencies to the
    woofers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在信号处理的上下文中，*滤波器*是一个电路、设备，或在我们的情况下是一个计算，能够衰减信号中某些频率。最常见的例子可能是扬声器中的分频电路，它将高频信号传送给高音扬声器，将低频信号传送给低音扬声器。
- en: Filters are also important in empirical science—for example, in reducing noise
    in measurements. Imagine a sensor that records the variations in depth of a waterway.
    We might be interested in measuring the effect of tides, and detecting any long-term
    change in the average depth. These changes occur on the timescales of hours and
    longer. However, the measurements will be polluted by the more rapid changes caused
    by wind, weather, and passing boats. Using filtering, we can seek to erase the
    irrelevant data from the signal by eliminating frequencies faster than, say, one
    cycle per hour.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 滤波器在经验科学中也很重要——例如，用于减少测量中的噪声。假设有一个传感器记录水道深度的变化。我们可能有兴趣测量潮汐的影响，检测任何长期的平均深度变化。这些变化发生在小时或更长的时间尺度上。然而，测量将被风、天气和经过的船只造成的更快速变化污染。通过使用滤波器，我们可以通过去除比每小时一次的周期更快的频率，来消除信号中的无关数据。
- en: This strategy suggested in the previous paragraph is called a *low-pass* filter,
    because it attenuates frequencies *above* a specified cutoff, allowing those below
    the cutoff to pass. An example of a *high-pass* filter would be the crossover
    circuit leading to a speaker’s tweeter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段建议的策略称为*低通*滤波器，因为它衰减高于指定截止频率的频率，并允许低于截止频率的频率通过。*高通*滤波器的一个例子就是指向扬声器高音扬声器的分频电路。
- en: 'Another type of filtering common in scientific instrumentation is a *notch*
    filter: one that attenuates frequencies near a target frequency. Notch filters
    are useful for eliminating 60 or 50 Hz power line noise from instruments through
    which the signal passes (but are only useful if the signal doesn’t contain information
    near the power line frequency).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在科学仪器中常见的滤波类型是*陷波*滤波器：它衰减接近目标频率的信号。陷波滤波器对于消除通过信号通过的仪器中 60 Hz 或 50 Hz 电源噪声非常有用（但只有在信号不包含接近电源频率的信息时才有效）。
- en: A *band-pass* filter attenuates anything outside a narrow band around a target
    frequency.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*带通*滤波器会衰减目标频率周围狭窄频带以外的信号。'
- en: '**Making Filters with fir()**'
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 fir() 创建滤波器**'
- en: The `SignalAnalysis` package makes it easy to construct any of these types of
    filters and apply them to signals. In each case we begin with the `fir()` function
    to construct the filter. Its basic use involves three positional arguments and
    an optional keyword argument named `fs`, giving the sampling frequency of the
    signal.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`SignalAnalysis`包使得构建这些类型的滤波器并将其应用于信号变得容易。在每种情况下，我们从`fir()`函数开始构建滤波器。其基本用法包括三个位置参数和一个名为`fs`的可选关键字参数，表示信号的采样频率。'
- en: The first argument is an integer number of *taps*, which is related to the number
    of terms retained in the polynomial that describes the filter. Essentially, a
    greater number of taps causes the filter to be more selective and its response
    to be smoother. The second and third arguments are the lower and upper bounds
    of the unfiltered frequency range. If we provide the `fs` keyword, we supply these
    arguments in `Hz`, `kHz`, or another unit from `SignalAnalysis.Units`. For example,
    [Listing 14-1](ch14.xhtml#ch14lis1) shows how to make a low-pass filter that filters
    out everything above 2,000 Hz.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个整数*抽头*的数量，与描述滤波器的多项式中保留的项数相关。基本上，更多的抽头使得滤波器更加选择性，响应更加平滑。第二和第三个参数是未滤波频率范围的下限和上限。如果我们提供`fs`关键字，我们将这些参数以`Hz`、`kHz`或来自`SignalAnalysis.Units`的其他单位提供。例如，[清单
    14-1](ch14.xhtml#ch14lis1)展示了如何制作一个过滤掉2,000 Hz以上频率的低通滤波器。
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 14-1: Constructing a low-pass filter*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-1：构造低通滤波器*'
- en: The example makes a 127-tap filter, which is a typical value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例创建了一个127抽头的滤波器，这是一个典型值。
- en: The lower bound for a low-pass filter is 0, as in the example. To make a high-pass
    filter, we pass `nothing` as the upper bound.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 低通滤波器的下限为0，如本示例所示。要创建一个高通滤波器，我们将`nothing`作为上限传递。
- en: 'The `SignalAnalysis` package provides a plotting function to visualize the
    filters created with `fir()`. To see a plot of the frequency response of the `lpf`
    filter defined previously, we need simply enter:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`SignalAnalysis`包提供了一个绘图函数，用于可视化通过`fir()`创建的滤波器。要查看先前定义的`lpf`滤波器的频率响应图，我们只需输入：'
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This creates the plot shown in [Figure 14-5](ch14.xhtml#ch14fig5).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成[图 14-5](ch14.xhtml#ch14fig5)中所示的图形。
- en: '![Image](../images/ch14fig05.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch14fig05.jpg)'
- en: '*Figure 14-5: Frequency response of a low-pass filter*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：低通滤波器的频率响应*'
- en: The top graph in [Figure 14-5](ch14.xhtml#ch14fig5) indicates the amount by
    which the frequency component, given on the horizontal axis, will be reduced when
    the filter is applied to a signal. The units are in dB (decibels), which is conventional
    in signal processing. [Figure 14-5](ch14.xhtml#ch14fig5) shows 0 dB, or no change,
    to the frequencies until we approach 2,000 Hz, when the signal is rapidly attenuated.
    For normal sounds, a reduction of 20 dB effectively silences the component it’s
    applied to; therefore, the oscillations in the filter response below –50 dB have
    no audible effect.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-5](ch14.xhtml#ch14fig5)中的顶部图表显示了在将滤波器应用于信号时，水平轴上给定的频率分量会被降低的程度。单位为dB（分贝），这是信号处理中常用的单位。[图
    14-5](ch14.xhtml#ch14fig5)显示，直到接近2,000 Hz时，频率没有变化，信号迅速衰减。对于普通声音，20 dB的减少会有效地使其应用到的频率分量静音；因此，滤波器响应中低于–50
    dB的振荡对声音没有可听的影响。'
- en: The bottom graph shows the phase shifts created by the filter. These are usually
    inaudible, but may or may not be relevant, depending on one’s plans for the filtered
    signal.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 底部图表显示了滤波器所产生的相位变化。这些变化通常是听不见的，但根据对滤波信号的使用计划，它们可能相关，也可能无关。
- en: '**NOTE**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For more detailed control over the filter characteristics, we can import*
    DSP.jl *and pass a* method *keyword to* fir() *using one of the filter construction
    methods described at* [https://docs.juliadsp.org/stable/filters/](https://docs.juliadsp.org/stable/filters/).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了更详细地控制滤波器特性，我们可以导入* DSP.jl *并使用* method *关键字传递给* fir() *，并使用* [https://docs.juliadsp.org/stable/filters/](https://docs.juliadsp.org/stable/filters/)
    *中描述的滤波器构造方法之一。*'
- en: The dB numbers in the frequency response plot are directly added to the values
    of frequency component peaks displayed in the `psd()` plot of a signal, which
    are also displayed in dB. To calculate the change in amplitude of the signal itself,
    we use the formula
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 频率响应图中的dB值直接加到信号的`psd()`图中显示的频率分量峰值，这些峰值也以dB显示。为了计算信号本身的幅度变化，我们使用公式：
- en: '![Image](../images/437math.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/437math.jpg)'
- en: 'where *V* is the amplitude of the component in the input signal and *V*[*f*]
    is the filtered amplitude. Therefore, a 6 dB reduction halves the amplitude:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*V*是输入信号中成分的振幅，*V*[*f*]是滤波后的振幅。因此，6 dB的减少意味着振幅减半：
- en: '![Image](../images/437math1.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/437math1.jpg)'
- en: 'To see the effect of larger tap values, we can make two additional low-pass
    filters with the same frequency ranges but with more taps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了观察更大的抽头值的效果，我们可以制作两个额外的低通滤波器，具有相同的频率范围，但有更多的抽头：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A higher tap number will produce a filter with a response closer to ideal, as
    [Figure 14-6](ch14.xhtml#ch14fig6) shows.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 更高的抽头数会产生更接近理想响应的滤波器，如[Figure 14-6](ch14.xhtml#ch14fig6)所示。
- en: '![Image](../images/ch14fig06.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch14fig06.jpg)'
- en: '*Figure 14-6: A low-pass filter using different tap numbers*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 14-6: 使用不同抽头数的低通滤波器*'
- en: Although using a higher tap number creates a cleaner filter with a sharper cutoff,
    it leads to a more expensive filtering calculation. The added calculation time
    makes no difference for our example, using a stored signal of moderate length,
    but it can be a consideration with real-time filtering, for example.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用更高的抽头数会产生具有更锐利截止的更干净滤波器，但它会导致计算开销增加。对于我们的示例（使用中等长度的存储信号）来说，增加的计算时间没有影响，但在实时滤波的情况下，这可能是一个需要考虑的问题。
- en: '**Applying Filters**'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**应用滤波器**'
- en: 'To filter the signal, we can use the function `sfilt()`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要对信号进行滤波，我们可以使用`sfilt()`函数：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This applies the low-pass filter defined in [Listing 14-1](ch14.xhtml#ch14lis1)
    to the owl sample and assigns the result, a new signal, to `cfpo_lp`. Plotting
    the power spectrum of the filtered signal using `psd()` shows the effect of the
    filtering (see [Figure 14-7](ch14.xhtml#ch14fig7)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将[Listing 14-1](ch14.xhtml#ch14lis1)中定义的低通滤波器应用于猫头鹰样本，并将结果（一个新的信号）赋值给`cfpo_lp`。使用`psd()`绘制滤波信号的功率谱，展示了滤波效果（见[Figure
    14-7](ch14.xhtml#ch14fig7)）。
- en: '![Image](../images/ch14fig07.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch14fig07.jpg)'
- en: '*Figure 14-7: The filtered owl call*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 14-7: 滤波后的猫头鹰叫声*'
- en: This plot displays the original, unfiltered spectrum using a dotted line and
    the filtered spectrum with a thicker, solid line. The spectrum below the low-pass
    cutoff at 2 kHz is untouched, while all frequencies above have been eliminated.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此图使用虚线显示原始的未滤波谱图，使用较粗的实线显示滤波后的谱图。低通截止频率2 kHz以下的频谱未受到影响，而所有高于此频率的部分已被消除。
- en: 'We create [Figure 14-7](ch14.xhtml#ch14fig7) with the following commands:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令创建[Figure 14-7](ch14.xhtml#ch14fig7)：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It’s necessary to repeat some of the keyword arguments when adding to `psd()`
    plots because the plotting recipe resets them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在向`psd()`绘图时需要重复某些关键字参数，因为绘图公式会重置它们。
- en: The spectrogram of the filtered signal in [Figure 14-8](ch14.xhtml#ch14fig8)
    also shows the elimination of the second and third harmonics with the preservation
    of the signal otherwise.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 14-8](ch14.xhtml#ch14fig8)中的滤波信号的频谱图还显示了第二和第三谐波的消除，同时保持了信号的其他部分。'
- en: '![Image](../images/ch14fig08.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch14fig08.jpg)'
- en: '*Figure 14-8: Spectrogram of the filtered owl call*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 14-8: 滤波后猫头鹰叫声的频谱图*'
- en: '**Synthetic Signals**'
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**合成信号**'
- en: In order to ensure that we understand, quantitatively, signal analysis and filtering,
    let’s start with a signal synthesized from known frequency components. Another
    method of `signal()` creates a signal with embedded sampling rate information
    from a normal vector. In [Listing 14-2](ch14.xhtml#ch14lis2), we create a vector
    consisting of the addition of two sine waves, representing data with two components
    at 1,000 and 2,050 Hz sampled at 8 kHz. We then package the data into a signal.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们定量地理解信号分析和滤波，我们从一个由已知频率成分合成的信号开始。`signal()`的另一种方法是通过一个正常的向量创建一个包含采样率信息的信号。在[Listing
    14-2](ch14.xhtml#ch14lis2)中，我们创建了一个由两个正弦波叠加而成的向量，表示采样率为8 kHz的1,000 Hz和2,050 Hz两种频率成分的数据。然后，我们将数据打包成一个信号。
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 14-2: Creating a synthetic signal*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-2: 创建合成信号*'
- en: We assigned the result to `sin1000_2050`. The second argument to `signal()`
    gives the sampling rate. The component at 2,050 Hz has half the amplitude of the
    component at 1,000 Hz. The power spectrum should show two peaks, with the higher-frequency
    peak 6 dB lower than the lower-frequency peak. [Figure 14-9](ch14.xhtml#ch14fig9)
    shows the result of [Listing 14-3](ch14.xhtml#ch14lis3).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将结果赋值给`sin1000_2050`。`signal()`的第二个参数指定采样率。2,050 Hz处的成分的振幅是1,000 Hz处成分的一半。功率谱应该显示两个峰值，较高频率的峰值比低频率的峰值低6
    dB。[Figure 14-9](ch14.xhtml#ch14fig9)展示了[Listing 14-3](ch14.xhtml#ch14lis3)的结果。
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 14-3: Spectrum of a synthetic signal*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-3: 合成信号的频谱*'
- en: Because the signal contains embedded sampling rate information, `psd()` is able
    to scale the plot correctly.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因为信号包含嵌入的采样率信息，`psd()`能够正确地缩放图谱。
- en: '![Image](../images/ch14fig09.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch14fig09.jpg)'
- en: '*Figure 14-9: Spectrum of a synthetic signal with two frequency components*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：合成信号的频谱，具有两个频率分量*'
- en: '[Figure 14-9](ch14.xhtml#ch14fig9) shows the power spectrum with two narrow
    peaks where we put them, and the correct 6 dB difference in their amplitudes.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-9](ch14.xhtml#ch14fig9)显示了功率谱，其中两个窄峰分别出现在我们指定的位置，并且它们的幅度差为正确的6 dB。'
- en: 'Now let’s measure the effect of filtering. We’ll use the `lpf` filter defined
    in [Listing 14-1](ch14.xhtml#ch14lis1), but first we need to take a closer look
    at it near its cutoff frequency:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来测量滤波的效果。我们将使用在[清单14-1](ch14.xhtml#ch14lis1)中定义的`lpf`滤波器，但首先我们需要在其截止频率附近更仔细地观察它：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The expanded plot of the filter response in [Figure 14-10](ch14.xhtml#ch14fig10)
    (with the phase response omitted) shows that the filter should reduce the 2,050
    Hz component by 16 dB.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-10](ch14.xhtml#ch14fig10)中的滤波器响应扩展图（省略了相位响应）显示，滤波器应该将2,050 Hz分量减少16 dB。'
- en: '![Image](../images/ch14fig10.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch14fig10.jpg)'
- en: '*Figure 14-10: The cutoff region of the low-pass filter*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：低通滤波器的截止区域*'
- en: 'We can check whether the filter is working as expected by overlaying the power
    spectrum of the filtered signal onto the plot created in [Listing 14-3](ch14.xhtml#ch14lis3):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将滤波后的信号的功率谱叠加到[清单14-3](ch14.xhtml#ch14lis3)中创建的图谱上，检查滤波器是否按预期工作：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Figure 14-11](ch14.xhtml#ch14fig11) shows that the higher-frequency peak is
    reduced by 16 dB while the lower-frequency peak is unchanged.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-11](ch14.xhtml#ch14fig11)显示，高频峰值被减少了16 dB，而低频峰值保持不变。'
- en: '![Image](../images/ch14fig11.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch14fig11.jpg)'
- en: '*Figure 14-11: Power spectrum of the filtered synthetic signal*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：滤波后的合成信号的功率谱*'
- en: This little exercise shows that the filters have predictable effects, altering
    the spectra without introducing artifacts.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小练习展示了滤波器具有可预测的效果，改变了频谱而没有引入伪影。
- en: '**Saving Signals**'
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**保存信号**'
- en: 'We can read a WAV file from disk into a signal using the `signal()` function,
    but saving a signal as a WAV file requires importing the `WAV.jl` package:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`signal()`函数从磁盘读取WAV文件到信号中，但将信号保存为WAV文件需要导入`WAV.jl`包：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The keyword arguments select a compression format and word size that’s compatible
    with a wide variety of software. After making the `wavwrite()` call, a WAV file
    called *cfpo_lp.wav* will exist on the disk drive.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数选择一个压缩格式和词大小，这些与各种软件兼容。在调用`wavwrite()`后，磁盘上将生成一个名为*cfpo_lp.wav*的WAV文件。
- en: 'If we want to save our `sin1000_2050` signal as a WAV file, we first have to
    scale it to have unit amplitude:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将`sin1000_2050`信号保存为WAV文件，首先需要将其缩放到单位幅度：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then we save it using `wavwrite()` as before and play it using any audio software.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们像之前一样使用`wavwrite()`保存它，并使用任何音频软件播放它。
- en: '**Image Processing**'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**图像处理**'
- en: 'Let’s consider an image interpretation task common in medicine and laboratory
    biology: how many blood cells are in a photograph of a blood sample taken through
    a microscope? The traditional method of acquiring this “blood count” was to enumerate
    the cells manually, a tiresome and errorprone process. We’ll see how to use various
    image processing techniques with Julia to automate the procedure. The result will
    be a faster and more accurate count that doesn’t require tedious labor. However,
    the techniques we’ll investigate here aren’t limited to blood counts. We could
    apply them to everything from counting bacteria to analyzing satellite reconnaissance.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个在医学和实验室生物学中常见的图像解释任务：在显微镜下拍摄的血液样本照片中，有多少个血细胞？传统的“血细胞计数”方法是手动列举细胞，这是一项繁琐且容易出错的过程。我们将看看如何使用Julia中的各种图像处理技术来自动化这个过程。结果将是一个更快速、更准确的计数，不需要繁重的体力劳动。然而，我们在这里研究的技术不仅限于血细胞计数。我们可以将其应用于从细菌计数到分析卫星侦察的所有任务。
- en: '***Loading and Converting Images***'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加载与转换图像***'
- en: 'The command `using Images` imports the file and image input-output functions,
    including optimized routines for most image types:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`using Images`导入了文件和图像输入输出函数，包括对大多数图像类型的优化例程：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After the import, a simple `load()` command reads the file into an image, which
    in Julia is an array of pixels.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 导入后，简单的`load()`命令将文件读取为图像，在Julia中，图像是一个像素数组。
- en: When working in a notebook, such as Pluto, the results of image operations are
    displayed as images; in the terminal REPL, they’re displayed similarly to other
    arrays. For graphical image display from the REPL, the `ImageView` package supplies
    the `imshow()` function. The window opened by `imshow()` features a few GUI powers,
    the most useful of which is a display of pixel address and color value in response
    to moving the mouse pointer over the image.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用笔记本，如Pluto时，图像操作的结果以图像的形式显示；在终端REPL中，它们以类似其他数组的方式显示。对于REPL中的图形图像显示，`ImageView`包提供了`imshow()`函数。`imshow()`打开的窗口具有一些GUI功能，其中最有用的是在鼠标指针移动到图像上时显示像素地址和颜色值。
- en: 'Images can be matrices of numbers or pixel types. There are several types of
    pixels, but the ones we’ll be using are `RGB` and `Gray` pixels. Since we loaded
    the `frog_blood` image from a color picture, it’s an array of `RGB` (red-green-blue)
    pixels:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图像可以是数字矩阵或像素类型。有几种像素类型，但我们将使用的是`RGB`和`Gray`像素。由于我们从彩色图片中加载了`frog_blood`图像，它是一个`RGB`（红-绿-蓝）像素的数组：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is clearly a parametric type (see “Parametric Types” on [page 248](ch08.xhtml#ch08lev6)).
    The parameter `N0f8` is another (parametric) type that maps unsigned 8-bit integers
    to floats in the range `[0.0, 1.0]`. An element of `frog_blood` looks like the
    following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一个参数化类型（参见[第248页](ch08.xhtml#ch08lev6)的“参数化类型”）。参数`N0f8`是另一个（参数化）类型，它将无符号8位整数映射到范围为`[0.0,
    1.0]`的浮点数。`frog_blood`的一个元素如下所示：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This would be purple: nearly equal amounts of red and blue and almost no green.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是紫色：几乎相等的红色和蓝色量，几乎没有绿色。
- en: 'If we want to replace the extreme upper-left pixel with pure green, we could
    execute:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想用纯绿色替换极左上角的像素，可以执行以下操作：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: However, we won’t.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会这么做。
- en: 'We can convert the color image to a grayscale version by broadcasting `Gray()`
    as a conversion function to the image array:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`Gray()`作为转换函数广播到图像数组，将彩色图像转换为灰度版本：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The listing also shows how to save images in files. The `save()` function converts
    image data to the file format indicated by the filename extension. Here we’ve
    saved two versions of the same image, one as a *.jpg* file and one as a *.png*
    file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码片段还展示了如何将图像保存到文件中。`save()`函数将图像数据转换为由文件名扩展名指定的文件格式。这里我们保存了两种版本的相同图像，一种是*.jpg*文件，另一种是*.png*文件。
- en: '[Figure 14-12](ch14.xhtml#ch14fig12) shows the grayscaled image.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-12](ch14.xhtml#ch14fig12)展示了灰度化图像。'
- en: '![Image](../images/ch14fig12.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch14fig12.jpg)'
- en: '*Figure 14-12: The frog blood image converted to grayscale. Original image
    by Wayne Large (CC BY-ND 2.0). Available from* [https://flic.kr/p/cBDUEG](https://flic.kr/p/cBDUEG).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：青蛙血液图像转为灰度图像。原始图像由Wayne Large提供（CC BY-ND 2.0）。可从* [https://flic.kr/p/cBDUEG](https://flic.kr/p/cBDUEG)
    获取。'
- en: Other useful color conversion functions are `red()`, `green()`, and `blue()`,
    which extract the named color channels from an `RGB` pixel and can also, of course,
    be broadcast to entire images to separate them into their color channels.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有用的颜色转换函数包括`red()`、`green()`和`blue()`，它们从`RGB`像素中提取指定的颜色通道，当然也可以广播到整个图像，将其分离为各个颜色通道。
- en: 'In order to compare two, or several, versions of an image, perhaps to eyeball
    the effect of a transformation or processing step, the `mosaicview()` function
    is handy:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较两张或多张图像的不同版本，可能是为了直观查看某个转换或处理步骤的效果，`mosaicview()`函数非常有用：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This command creates four images showing the three color channels of the original
    `frog_blood` image and the composite grayscale version, sticks them together in
    a grid, then displays them. If working in a notebook, we don’t need the `imshow()`
    call. The `ncol` argument specifies the numbers of columns in the image grid (an
    `nrows` is also available), and the `npad` argument puts a border of the specified
    number of pixels between the images.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令创建四个图像，显示原始`frog_blood`图像的三个颜色通道和合成的灰度版本，将它们按网格排列并显示。如果在笔记本中工作，我们不需要`imshow()`调用。`ncol`参数指定图像网格中的列数（也有`nrows`可用），`npad`参数在图像之间添加指定数量的像素边框。
- en: '[Figure 14-13](ch14.xhtml#ch14fig13) shows what `mosaicview()` produces.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-13](ch14.xhtml#ch14fig13)展示了`mosaicview()`的输出。'
- en: '![Image](../images/ch14fig13.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch14fig13.jpg)'
- en: '*Figure 14-13: The red, green, blue, and all channels (top to bottom, left
    to right) of the frog blood image*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：青蛙血液图像的红色、绿色、蓝色和所有通道（从上到下，左到右）*'
- en: The original image, containing all of the color channels, is in the lower-right
    quadrant.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 原始图像，包含所有颜色通道，位于右下角。
- en: '***Counting Cells Using an Area Fraction***'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用面积分数计数细胞***'
- en: Our first attempt at automating the counting of blood cells will use the `ImageBinarization`
    package. This package contains a handful of algorithms for separating an image
    into a “foreground” and a “background,” coloring the foreground pure black and
    the background pure white. In other words, each pixel in the original image is
    assigned either 0.0 or 1.0, depending on the results of the algorithm invoked.
    The package documentation displays examples of the results of all the available
    algorithms on a variety of image types.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次尝试自动计数血细胞将使用`ImageBinarization`包。这个包包含了一些用于将图像分为“前景”和“背景”的算法，将前景染成纯黑色，背景染成纯白色。换句话说，原始图像中的每个像素都会根据调用的算法结果被分配为0.0或1.0。该包的文档展示了各种算法在不同类型图像上的结果示例。
- en: 'The goal is to generate an image that separates the blood cells from everything
    else, as much as possible. This binary image will then be a good starting point
    for further analysis. We’ve already made some progress in this direction through
    the color separations shown in [Figure 14-13](ch14.xhtml#ch14fig13). The blue
    channel, at the bottom, seems to have increased the contrast between the (larger)
    red blood cells and the other particles. Instead of binarizing the original color
    image, we’ll start with the blue channel:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是生成一张尽可能将血细胞与其他所有物体分离的图像。这个二值图像将成为进一步分析的良好起点。通过[图14-13](ch14.xhtml#ch14fig13)所示的颜色分离，我们已经在这方面取得了一些进展。底部的蓝色通道似乎增强了（较大的）红细胞与其他颗粒之间的对比度。我们不会直接对原始彩色图像进行二值化，而是从蓝色通道开始：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `binarize()` function takes the image as the first argument and the name
    of the binarization algorithm as the second argument, and returns the binarized
    image. The documentation describes the details of the `Intermodes` algorithm.
    For our purposes, it does a good job at detecting discrete structures, such as
    cells, against a plain background.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`binarize()`函数将图像作为第一个参数，二值化算法的名称作为第二个参数，并返回二值化后的图像。文档描述了`Intermodes`算法的详细信息。就我们的目的而言，它能够很好地检测出与背景对比明显的离散结构，如细胞。'
- en: '[Figure 14-14](ch14.xhtml#ch14fig14) shows the binarized image.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-14](ch14.xhtml#ch14fig14)展示了二值化后的图像。'
- en: '![Image](../images/ch14fig14.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch14fig14.jpg)'
- en: '*Figure 14-14: The blue channel of the frog blood slide after binarization*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-14：青蛙血液幻灯片经过二值化后的蓝色通道*'
- en: We’ll use this image as the basis for the blood count.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这张图像作为血细胞计数的基础。
- en: If we knew the average area of the blood cells in the image, we could divide
    that into the total area occupied by all blood cells to arrive at an estimate
    of the number of cells. The cells appear to be approximately elliptical (in this
    two-dimensional image).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道图像中血细胞的平均面积，就可以将其除以所有血细胞所占的总面积，从而估算细胞的数量。细胞似乎大致呈椭圆形（在这个二维图像中）。
- en: Using the GUI in the `imshow()` window, I used the pixel readout to measure
    the major and minor axis lengths of four typical cells at 26.8 pixels and a typical
    minor axis at 24.5 pixels. Using *A* = *πr*[1]*r*[2] for the area of an ellipse
    with radii *r*[1] and *r*[2], the average of the four areas was 511.3 square pixels.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在`imshow()`窗口中使用GUI时，我使用像素读数来测量四个典型细胞的长轴和短轴长度，长轴为26.8像素，短轴为24.5像素。使用*A* = *πr*[1]*r*[2]计算椭圆面积，其中*r*[1]和*r*[2]是椭圆的半径，四个面积的平均值为511.3平方像素。
- en: Finding the total blood fraction is simple using the binarized image. In `frog_blood_b1`,
    the cells are black, with a pixel value of 0, and the background is white, with
    a value of 1\. The total cell count is therefore `sum(1 .- frog_blood_b1)`, which
    evaluates to 255,029.0\. Dividing this result by the average cell area yields
    499 cells.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二值化图像来计算总的血细胞比例非常简单。在`frog_blood_b1`中，细胞是黑色的，像素值为0，背景是白色的，像素值为1。因此，细胞的总数为`sum(1
    .- frog_blood_b1)`，其值为255,029.0。将此结果除以平均细胞面积得到499个细胞。
- en: '***Counting Cells by Recognizing Features***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过识别特征计数细胞***'
- en: We can improve on the estimate in the previous section by exploiting algorithms
    that search for features with particular shapes in the image. The Hough transform
    (see “Further Reading” on [page 465](ch14.xhtml#fur14) for background) is one
    such class of algorithms that can be specialized to various shapes. The `ImageFeatures`
    package, which we’ll assume is imported in the following examples, offers implementations
    for detecting lines and circles. As the features we need to detect resemble circles,
    we’ll use the `hough_circle_gradient()` function, an implementation of the Hough
    transform for circles.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过利用搜索图像中特定形状特征的算法，改进上一节中的估计。霍夫变换（有关背景知识，请参见[第465页](ch14.xhtml#fur14)的“进一步阅读”部分）就是这样一类可以专门用于各种形状的算法。我们假设以下示例中已经导入了`ImageFeatures`包，它提供了检测直线和圆形的实现。由于我们需要检测的特征类似于圆形，因此我们将使用`hough_circle_gradient()`函数，这是霍夫变换在圆形上的一种实现。
- en: Before applying the algorithm, we’ll process the image to make its task easier
    and produce a more accurate result. One problem with the image is that the cells
    we want to count are not circles, but elongated. Hough transforms for ellipses
    do exist, but are not yet available in the `ImageFeatures` package. Another problem
    is that many cells are touching, and a few are overlapping. The Hough transform
    can deal with touching and overlapping circles, but it has a better time with
    cleanly separated shapes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用算法之前，我们将处理图像，以使其任务更容易，并产生更准确的结果。图像中的一个问题是，我们想要计数的细胞不是圆形的，而是拉长的。虽然霍夫变换有针对椭圆形的实现，但`ImageFeatures`包中尚未提供此功能。另一个问题是，许多细胞是接触的，还有一些是重叠的。霍夫变换可以处理接触和重叠的圆形，但它对清晰分开的形状效果更好。
- en: 'Nature has provided some assistance with the second problem: each cell has
    a nucleus, clearly delineated in the picture. Even when blood cells are in contact
    or overlapping, their nuclei are separated. If we could eliminate most of everything
    except the nuclei from the image, we could simply count those to get the blood
    count.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 大自然在第二个问题上提供了一些帮助：每个细胞都有一个核，在图像中清晰可见。即使血细胞接触或重叠，它们的细胞核依然分开。如果我们能从图像中去除除了细胞核以外的大部分内容，我们就可以通过计数细胞核来得到血细胞数量。
- en: 'Here we are fortunate: the color of the nuclei makes them easy to distinguish
    from everything else in the image. This may not be apparent to the eye, but by
    placing the mouse cursor on the nuclei in the `imshow()` window, and comparing
    with other locations, we can see that the nuclei are unique in having a green
    value close to 0 while having a red value > 0.2\. We can confirm this in other
    ways—for example, by plotting the three color components along lines through the
    image.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很幸运：细胞核的颜色使它们在图像中与其他部分容易区分。这可能不容易通过肉眼察觉，但通过将鼠标光标放在`imshow()`窗口中的细胞核上，并与其他位置进行比较，我们可以看到，细胞核的绿色值接近
    0，同时红色值大于 0.2。我们可以通过其他方式确认这一点——例如，通过沿图像中的直线绘制三个颜色分量。
- en: 'The following array comprehension creates a new image from the original pixel
    by pixel, by leaving the pixels within the nucleus color range unchanged, while
    turning the others white:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的数组推导式通过逐个像素地从原始图像创建新图像，它保留细胞核颜色范围内的像素不变，同时将其他像素变为白色：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We also transform the result into a grayscale image for further processing and
    printing. [Figure 14-15](ch14.xhtml#ch14fig15) shows the result.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将结果转换为灰度图像，以便进一步处理和打印。[图14-15](ch14.xhtml#ch14fig15)显示了结果。
- en: '![Image](../images/ch14fig15.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch14fig15.jpg)'
- en: '*Figure 14-15: Frog blood nuclei isolated by color*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-15：通过颜色隔离的青蛙血细胞核*'
- en: We’ve managed to isolate the nuclei pretty well and eliminate some of the particles
    that are something other than blood cells.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经很好地隔离了细胞核，并去除了部分不是血细胞的颗粒。
- en: '[Figure 14-15](ch14.xhtml#ch14fig15) is a good candidate for the circle-finding
    algorithm, but we must complete two preliminary steps first. The `hough_circle_gradient()`
    function doesn’t operate on actual images, but on maps of *edges* and *phases*.
    The edge map is the output of an edge-detection algorithm, transforming the image
    into, essentially, a line drawing tracing its shapes. The map of phases is a matrix
    of angles calculated from the edge map, giving the direction at every point of
    its gradient, as an angle from *–π* to π.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-15](ch14.xhtml#ch14fig15)是圆形检测算法的一个很好的候选者，但我们首先必须完成两个初步步骤。`hough_circle_gradient()`函数并不作用于实际图像，而是作用于*边缘*和*相位*的映射。边缘映射是边缘检测算法的输出，将图像转换为基本上是描绘其形状的线条。相位映射是从边缘映射计算出的角度矩阵，给出每个梯度点的方向，角度范围从*–π*到π。'
- en: 'The `canny()` function is an excellent edge detector:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`canny()`函数是一个出色的边缘检测器：'
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Its second argument is a tuple of thresholds used for defining an edge from
    the input image (which must be grayscale). I arrived at the values it contains
    through trial and error, aiming for a set of edges that captured the nuclei while
    ignoring most of the scattering of white blood cells and other particles. [Figure
    14-16](ch14.xhtml#ch14fig16) shows the output of the `canny()` function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 它的第二个参数是一个阈值元组，用于定义从输入图像（必须是灰度图像）中检测到的边缘。我通过反复试验得到了这些值，目标是捕获细胞核的边缘，同时忽略大多数白细胞和其他颗粒的散射。[图14-16](ch14.xhtml#ch14fig16)显示了`canny()`函数的输出。
- en: '![Image](../images/ch14fig16.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch14fig16.jpg)'
- en: '*Figure 14-16: Edge detection of the nuclei image*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-16：细胞核图像的边缘检测*'
- en: This is a pretty clean result, and is what we were aiming for.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当干净的结果，正是我们所追求的。
- en: 'The phase calculation itself requires two steps—first the gradient map itself
    and then the phases derived from it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 相位计算本身需要两步——首先是计算梯度图，然后从中推导出相位：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With the edges and phases computed, we can run the Hough transform:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算了边缘和相位之后，我们可以运行霍夫变换：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: After this call, `centers` contains a vector of indices giving the locations
    of each circle and `radii` a vector of their corresponding radii. The length of
    either vector gives the number of circles found. In this case, the length is 534,
    which is in reasonable agreement with the estimate of 499 we arrived at earlier.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个调用之后，`centers`包含一个索引向量，给出每个圆形的位置，`radii`包含它们对应的半径向量。任何一个向量的长度都表示检测到的圆形数量。在这种情况下，长度为534，与我们之前得出的499个血细胞的估计值相吻合。
- en: The third argument to `hough_circle_gradient()` gives the allowed range for
    the circle radii, in pixels. The `min_dist` keyword argument is the minimum allowed
    distance between circle centers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`hough_circle_gradient()`的第三个参数给出了圆形半径允许的范围，单位是像素。`min_dist`关键字参数是圆心之间的最小允许距离。'
- en: 'To see how well the circle fitting did, and how much confidence we should lend
    to the estimate of 534 blood cells, we can use the `centers` array to draw circles
    directly on the original image where the `hough_circle_gradient()` function says
    they should be:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看圆形拟合的效果，以及我们应该对534个血细胞估计的信心程度如何，我们可以使用`centers`数组直接在原始图像上绘制出`hough_circle_gradient()`函数认为应该出现的圆形位置：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `draw!()` function, provided by `ImageDraw`, mutates its first argument
    by drawing shapes on it, in white by default. The `CirclePointRadius()` in the
    second argument creates a circle at point `p` with radius 15; the `fill=false`
    creates an open circle with perimeter thickness controlled by the `thickness`
    keyword.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw!()`函数由`ImageDraw`提供，通过在其第一个参数上绘制形状来修改该参数，默认颜色为白色。第二个参数中的`CirclePointRadius()`在点`p`处创建一个半径为15的圆；`fill=false`会创建一个开放的圆，其边界厚度由`thickness`关键字控制。'
- en: '[Figure 14-17](ch14.xhtml#ch14fig17) shows the result of drawing the circles
    on top of the (grayscale version of) the original image.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-17](ch14.xhtml#ch14fig17)显示了将圆形绘制在（灰度版本的）原始图像上的结果。'
- en: '![Image](../images/ch14fig17.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch14fig17.jpg)'
- en: '*Figure 14-17: Circles detected by a Hough transform*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-17：霍夫变换检测到的圆形*'
- en: '[Figure 14-17](ch14.xhtml#ch14fig17) shows that the Hough transform did an
    excellent job. Nearly every blood cell is marked with a circle, and most of the
    other objects are ignored. There are a few misses and a few false detections,
    but, on the whole, the count of 534 is quite accurate.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-17](ch14.xhtml#ch14fig17)显示了霍夫变换的良好效果。几乎每个血细胞都被标记为一个圆形，其他大多数物体被忽略。虽然有少量漏检和误检，但整体上534个血细胞的数量相当准确。'
- en: The image processing pipeline described in this section would be practical for
    automating blood counts, although the specific parameters would need to be adjusted
    for different types of samples, different stains, and so on. The approach is far
    faster and probably more accurate than manual counting.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述的图像处理管道对于自动化血液计数非常实用，尽管需要根据不同类型的样本、不同的染色方式等调整具体参数。与手动计数相比，这种方法要快得多，可能也更准确。
- en: '***Applying Advanced Array Concepts***'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***应用高级数组概念***'
- en: As an image is an array, various advanced array concepts available in Julia
    can make their manipulation more convenient and concise. This section explores
    techniques for dealing with arrays that we haven’t used directly up to now, although
    we’ve seen how they’re used in several packages. Placed within an image processing
    context, their use becomes easier to visualize.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图像本质上是一个数组，Julia 提供的各种高级数组概念可以使其操作更加方便和简洁。本节探讨了处理数组的技巧，虽然我们在多个包中看到了它们的应用，但我们直到现在才直接使用它们。在图像处理的上下文中，使用这些技巧变得更容易理解。
- en: '**Views**'
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**视图**'
- en: 'A *view* is a reference to another array or to a section of another array.
    The other array is called the *parent*. A view is a kind of virtual array, which
    occupies almost no memory: it shares memory with the parent, so modifying one
    modifies the other.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*视图* 是对另一个数组或另一个数组部分的引用。另一个数组被称为*父数组*。视图是一种虚拟数组，几乎不占用内存：它与父数组共享内存，因此修改一个会同时修改另一个。'
- en: '**NOTE**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It is dangerous to alter the shape of the parent array after creating a view.
    Subsequent operation on the view may create out-of-bounds memory accesses or segmentation
    faults.*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*在创建视图后，修改父数组的形状是危险的。对视图的后续操作可能会导致越界内存访问或段错误。*'
- en: 'To see how views work, we’ll create a small grid of middle-gray values and
    a view pointing to every other element in the grid:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解视图的工作原理，我们将创建一个中灰色值的小网格，并创建一个视图指向网格中的每个其他元素：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The second line shows how to create a view with the `@view` macro. The `checkers`
    view, defined by selecting alternate squares of the parent array, forms a checkerboard
    pattern. Its size is half that of the parent. After setting all its elements to
    0.0 ➊, the corresponding elements in the parent are likewise modified. We can
    change the values of elements in the view repeatedly, and these updates are reflected
    in the parent. [Figure 14-18](ch14.xhtml#ch14fig18) shows the outcome.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行展示了如何使用 `@view` 宏创建视图。通过选择父数组的交替方格来定义 `checkers` 视图，形成一个棋盘模式。它的大小是父数组的一半。在将所有元素设置为
    0.0 ➊ 后，父数组中的相应元素也被修改。我们可以反复更改视图中的元素值，这些更新会反映在父数组中。[图14-18](ch14.xhtml#ch14fig18)
    显示了结果。
- en: '![Image](../images/ch14fig18.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch14fig18.jpg)'
- en: '*Figure 14-18: Patterns created using a view*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-18：使用视图创建的模式*'
- en: This example shows how views can simplify certain expressions. They’re also
    useful as an aid to memory parsimony. If a computation uses parts of arrays as
    intermediate containers, which we don’t need in the final result, we can avoid
    allocating memory to hold these temporary structures by using views instead.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了视图如何简化某些表达式。它们也作为内存节约的工具非常有用。如果计算过程中使用了数组的部分内容作为中间容器，而我们在最终结果中不需要这些容器，我们可以通过使用视图来避免为这些临时结构分配内存。
- en: 'As an illustration, here are two versions of a little function that returns
    the difference between the sums of alternate elements in an array:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，这里有两个版本的小函数，它们返回数组中交替元素和的差值：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `@views` macro ➊ transforms all slice operations in the expression to its
    right into view operations. The first version of the program creates two arrays
    and computes the sum of odd and even indexed elements. The second performs the
    same computation, but by creating views instead of new arrays. The timing runs
    show that using views cut the memory consumption in half while also decreasing
    runtime by a third. Avoiding unnecessary array copying by using views where possible
    is an easy optimization.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`@views` 宏 ➊ 将表达式右侧的所有切片操作转换为视图操作。程序的第一个版本创建了两个数组，并计算了奇数和偶数索引元素的和。第二个版本执行相同的计算，但通过创建视图而不是新数组来完成。计时结果显示，使用视图将内存消耗减少了一半，同时运行时间也减少了三分之一。通过在可能的情况下使用视图来避免不必要的数组复制，是一种简单的优化方法。'
- en: '**AxisArrays**'
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**轴数组**'
- en: With the `AxisArrays` package, we can give names to array dimensions and axes,
    give units to arrays, and enjoy more flexible indexing. Dataframes (see “Dataframes”
    on [page 333](ch10.xhtml#ch10lev1sec7)) also allow us to name rows and columns,
    but are limited to two dimensions.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`AxisArrays`包，我们可以为数组维度和轴命名，给数组加上单位，并享受更灵活的索引方式。数据框（见“数据框”章节中的[第333页](ch10.xhtml#ch10lev1sec7)）也允许我们为行和列命名，但仅限于二维。
- en: 'The following example shows how to name the rows and columns of a matrix:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下例子展示了如何为矩阵的行和列命名：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With this definition, we can index using the numbers that we’re used to or
    the names that we’ve assigned to the axes, or mix them up:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个定义，我们可以使用我们习惯的数字索引，或者使用我们为轴命名的名称，或者两者混合：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The example shows that we can slice with our custom names ➊ as we do with numerical
    indices, and that, if we use the names of the dimensions, we can supply indices
    in any order ➋. We can use any names where we use `row` and `col` here. They’re
    defined only within index expressions; they don’t exist as variables outside the
    brackets.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了我们可以像使用数字索引一样，使用我们自定义的名称进行切片 ➊，并且如果我们使用维度的名称，我们可以以任意顺序提供索引 ➋。我们在这里使用`row`和`col`，它们在索引表达式内定义；它们在括号外并不存在作为变量。
- en: 'The next example shows how to incorporate units into the definition of an array:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子展示了如何将单位纳入数组定义中：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This shows the use of the `Axis{}()` constructor, and, in the final line, various
    ways we can index into the array, including mixing numerical and unit indices.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了`Axis{}()`构造函数的使用，并且在最后一行展示了我们可以以不同的方式对数组进行索引，包括混合使用数字索引和单位索引。
- en: 'We can use an ellipsis, from the automatically imported `EllipsisNotation`
    package, to represent ranges of units:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用省略号，它来自自动导入的`EllipsisNotation`包，来表示单位范围：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This illustrates two properties of dimension ranges. We can use equivalent units,
    here using 10 mm = 1 cm, and the endpoints of the intervals need not lie exactly
    on an element of the array. Beware that the indexing rounds *down* and not to
    the nearest element.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了维度范围的两个特性。我们可以使用等效的单位，这里使用10毫米=1厘米，并且区间的端点不需要恰好位于数组的某个元素上。需要注意的是，索引是向*下*取整，而不是取最接近的元素。
- en: 'Let’s define a rectangle using ranges of lengths, paint it white, and plot
    the resulting array:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过定义一个长度范围的矩形，绘制它并将其涂成白色，然后绘制结果数组：
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The plotting command is an example of custom labeled ticks. [Figure 14-19](ch14.xhtml#ch14fig19)
    shows the new state of `rgin`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图命令是自定义标签刻度的一个例子。[图14-19](ch14.xhtml#ch14fig19)展示了`rgin`的新状态。
- en: '![Image](../images/ch14fig19.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/ch14fig19.jpg)'
- en: '*Figure 14-19: We paint this white rectangle by specifying physical lengths.*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-19：我们通过指定物理长度来绘制这个白色矩形。*'
- en: The direct use of physical dimensions to index arrays frees us from the mental
    or programmatic labor of constantly translating between integer indices and the
    quantities that they represent in our models.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用物理尺寸来索引数组，让我们不再需要不断地在整数索引和它们在模型中代表的量之间进行转换，无论是通过思维还是编程方式。
- en: '**OffsetArrays**'
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**偏移数组（OffsetArrays）**'
- en: Those with experience in Python or C, when encountering Julia for the first
    time, sometimes complain about its 1-based indexing, whereas old Fortran hands
    know that it’s a better choice. The former group may be pleased to know that in
    Julia, as in Fortran, we can make arrays that start anywhere.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有经验的Python或C开发者在第一次接触Julia时，常常会抱怨其基于1的索引，而老一辈的Fortran开发者知道这其实是更好的选择。前者可能会高兴地发现，在Julia中，和Fortran一样，我们可以使数组从任何位置开始。
- en: '**DON’T ASSUME 1-BASED INDEXING**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要假设1基索引**'
- en: 'Assuming that an array passed to a function will be 1-based is a source of
    occasional bugs in public packages. The existence of `OffsetArrays` is the reason
    for our earlier warning not to iterate over arrays with:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 假设传递给函数的数组是基于1的索引，这会是公共包中的偶发错误源。`OffsetArrays`的存在就是我们之前提醒不要通过以下方式迭代数组的原因：
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Instead, use `eachindex(A)` or another construction that generates legal indices.
    But there is another reason: using `eachindex()` generates more efficient memory
    accesses for certain types of arrays.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 代替使用`eachindex(A)`或其他生成合法索引的构造。不过还有一个原因：使用`eachindex()`会为某些类型的数组生成更高效的内存访问。
- en: 'The `OffsetArrays` package provides several ways to create an `OffsetArray`.
    We can call the `OffsetArray()` function with the source array and each dimension’s
    *offset* as positional arguments. A dimension’s offset is how far its indices
    are shifted from their normal position. An offset of 0 means no shift, and an
    offset of –2 means that the dimension’s index runs from –1 to two less than its
    length. To illustrate how an `OffsetArray` works, we’ll start with our random
    gray matrix again:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`OffsetArrays`包提供了多种创建`OffsetArray`的方法。我们可以使用`OffsetArray()`函数，传入源数组和每个维度的*偏移量*作为位置参数。一个维度的偏移量是其索引从正常位置的偏移程度。偏移量为0表示没有偏移，偏移量为-2表示该维度的索引从-1开始，到比其长度少2的位置结束。为了说明`OffsetArray`的工作原理，我们将再次使用我们的随机灰度矩阵：'
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, we use a seeded random number generator (see “Random Numbers
    in Julia” on [page 307](ch10.xhtml#ch10lev2)) so that the results will be identical
    for readers trying these commands. The `(-2, 3)` position of `rgi_offset` corresponds
    to the `(1, 1)` position of `rgi`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了一个带有种子的随机数生成器（详见 [第 307 页](ch10.xhtml#ch10lev2)的《Julia中的随机数》），这样读者在尝试这些命令时，结果将是相同的。`rgi_offset`的`(-2,
    3)`位置对应于`rgi`的`(1, 1)`位置。
- en: This use of `OffsetArray()` creates a view, rather than a copy of the original,
    as shown in [Listing 14-4](ch14.xhtml#ch14lis4).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`OffsetArray()`创建的这是一个视图，而不是原始数组的副本，正如[代码清单 14-4](ch14.xhtml#ch14lis4)中所示。
- en: '[PRE38]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 14-4:* OffsetArrays *are views.*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 14-4：* OffsetArrays *是视图*。'
- en: 'Since the two arrays share memory, modifying `rgi_offset` modifies `rgi`. Of
    course, we can make a new array using `copy()` if needed:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个数组共享内存，修改`rgi_offset`会同时修改`rgi`。当然，如果需要，我们可以使用`copy()`创建一个新数组：
- en: '[PRE39]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Painting part of the array white illustrates that ranges work as before, taking
    into account the offsets:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组的部分区域涂成白色，说明范围与之前一样有效，考虑了偏移量：
- en: '[PRE40]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[Figure 14-20](ch14.xhtml#ch14fig20) shows the image of the array, with the
    black element set in [Listing 14-4](ch14.xhtml#ch14lis4) and the white rectangle
    set in this example. The plotting grid for heatmaps is centered on the elements,
    so we can examine which elements were changed to verify that we understand the
    indexing ranges.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-20](ch14.xhtml#ch14fig20) 显示了数组的图像，其中黑色元素设置在[代码清单 14-4](ch14.xhtml#ch14lis4)中，白色矩形设置在本示例中。热图的绘制网格以元素为中心，因此我们可以检查哪些元素发生了变化，以验证我们是否理解了索引范围。'
- en: '![Image](../images/ch14fig20.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch14fig20.jpg)'
- en: '*Figure 14-20: The white rectangle was defined as an* OffsetArray.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-20：白色矩形被定义为一个* OffsetArray。'
- en: Plotting with `heatmap()` doesn’t work with `OffsetArrays` unless we explicitly
    supply coordinate vectors. In other words, we can call `heatmap(rgi)`, but must
    use `heatmap(1:10, 1:10, rgi_offset)` to prevent the plotting routine from getting
    confused. The two calls produce the same image in this case, as the two arrays
    share memory.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`heatmap()`绘图时，除非我们明确提供坐标向量，否则它与`OffsetArrays`无法正常工作。换句话说，我们可以调用`heatmap(rgi)`，但必须使用`heatmap(1:10,
    1:10, rgi_offset)`来防止绘图例程混淆。在这种情况下，这两个调用会产生相同的图像，因为这两个数组共享内存。
- en: '`OffsetArray()` provides another syntax, using ranges of indices rather than
    single offsets. This method is convenient when extracting a subset of an existing
    array:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`OffsetArray()`提供了另一种语法，使用索引范围而不是单一偏移量。当从现有数组中提取子集时，这种方法很方便：'
- en: '[PRE41]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First we load a color photograph, convert it to grayscale, and then to a floating-point
    array, assigning the result to the `passage`. Since we plan to inspect the images
    in this example using `heatmap()`, we flip the image vertically for convenience
    to undo the effect of the orientation of the vertical axis.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们加载一张彩色照片，将其转换为灰度图像，然后转化为浮点数组，并将结果赋值给`passage`。由于我们计划使用`heatmap()`来检查这些图像，我们为方便起见将图像垂直翻转，以抵消垂直轴方向的影响。
- en: 'Using `OffsetArray()`, we extract a square portion of the image and assign
    it to `middle_passage` ➊. This line shows another way to establish the offset
    indices: instead of a single integer offset, we supply the range of indices indexing
    the array. We choose these to be identical to the indices used to extract the
    sub-image, so that a pixel addressed in the extracted part will correspond to
    the pixel in the original image with the same indices. This technique greatly
    simplifies programs where we want to maintain a correspondence between an array
    and a sub-array, eliminating the need to constantly translate indices. The `middle_passage`
    matrix is a new array, not a view, because the index ranges create a copy.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`OffsetArray()`，我们提取图像的一个方形部分并将其赋值给`middle_passage`➊。这一行展示了另一种建立偏移索引的方法：我们不使用单一的整数偏移量，而是提供一个索引数组的范围。我们选择这些索引与提取子图像时使用的索引相同，以便提取部分中的像素与原始图像中相同索引的像素对应。这种技术极大地简化了我们想要保持数组与子数组之间一致性的程序，消除了不断转换索引的需求。`middle_passage`矩阵是一个新的数组，而不是视图，因为索引范围会创建一个副本。
- en: The next line paints the square region, from which we took the extract, black.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行将我们提取的方形区域涂成黑色。
- en: In the final line, we replace a portion of the black square with a portion of
    the extracted part of the image ➋. Since the index ranges in both arrays are identical,
    the replaced part of the image will exactly correspond to what was there originally.
    The result is a black frame around a part of the image, with nothing else altered,
    as [Figure 14-21](ch14.xhtml#ch14fig21) shows.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行中，我们用提取自图像的一部分替换了黑色方块的部分➋。由于两个数组中的索引范围是相同的，替换后的图像部分将与原始部分完全对应。结果是图像的一部分被一个黑色框架包围，其他部分未做任何更改，正如[图14-21](ch14.xhtml#ch14fig21)所示。
- en: '![Image](../images/ch14fig21.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch14fig21.jpg)'
- en: '*Figure 14-21:* OffsetArrays *make many image manipulations easier. Original
    photograph taken inside a Titan missile facility by Lee Phillips (CC BY-ND 2.0).*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-21:* OffsetArrays *使许多图像操作变得更简单。原始照片由Lee Phillips在Titan导弹设施内拍摄（CC BY-ND
    2.0）。*'
- en: The use of offset indices makes this code easier to write and read, and less
    prone to errors. With conventional arrays we would have been forced to add lines
    performing array arithmetic to translate between pixel ranges in the large and
    extracted images, or construct the frame from pieces.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用偏移索引使得这段代码更容易编写和阅读，也更不容易出错。使用常规数组时，我们将不得不添加执行数组运算的代码行来转换大图像和提取图像之间的像素范围，或者从各个部分构建框架。
- en: 'The `OffsetArrays` package proves two additional ways to construct array offsets
    automatically, both of which can be convenient in image processing. We can order
    up an `OffsetArray` centered on an array:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`OffsetArrays`包提供了另外两种自动构建数组偏移量的方法，这两种方法在图像处理中非常方便。我们可以创建一个以数组中心为中心的`OffsetArray`：'
- en: '[PRE42]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `center()` function ➊ from `OffsetArrays` returns the index of the center
    of an array (if the array has an odd number of elements along some dimension,
    it rounds down). The package’s `centered()` function ➋ creates an `OffsetArray`
    with the index `[0, 0]` at its center. We usually need to qualify these function
    names with the package name because of collisions.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`center()`函数➊来自`OffsetArrays`，它返回数组中心的索引（如果数组在某一维度上元素数量为奇数，它会向下取整）。该包的`centered()`函数➋创建一个以索引`[0,
    0]`为中心的`OffsetArray`。由于存在命名冲突，我们通常需要用包名来限定这些函数名。'
- en: 'Having the center of index space at the center of an array is helpful in the
    common situation where the array represents a quantity in physical space, or in
    space and time, where we often use a coordinate system with the origin at the
    center. Here’s another visual example, where having the `[0, 0]` point at the
    center of an image simplifies calculations:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将索引空间的中心设置在数组的中心对于常见的情况非常有帮助，在这种情况下，数组表示的是物理空间中的某个量，或是时空中的某个量，我们通常使用以中心为原点的坐标系。这里是另一个视觉示例，其中将`[0,
    0]`点置于图像的中心简化了计算：
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We’ve set `dmax` to the distance from the center to end along the shorter dimension.
    Then we multiply each pixel by a decreasing function of distance from the center.
    [Figure 14-22](ch14.xhtml#ch14fig22) shows the result, a centered circular frame
    darkening toward the edges.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`dmax`设置为从中心到较短维度边缘的距离。然后，我们将每个像素乘以一个关于距离中心递减的函数。[图14-22](ch14.xhtml#ch14fig22)展示了结果，一个向边缘逐渐变暗的居中圆形框架。
- en: '![Image](../images/ch14fig22.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch14fig22.jpg)'
- en: '*Figure 14-22:* OffsetArrays *make it easy to reference the center of an array.*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-22:* OffsetArrays *使得引用数组的中心变得容易。*'
- en: Using a centered `OffsetArray` simplifies the code, allowing us to dispense
    with the index arithmetic usually needed to reference the center of an array.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用居中的`OffsetArray`简化了代码，使我们无需编写通常需要的索引运算来引用数组的中心。
- en: '**Cartesian Indices**'
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**笛卡尔索引**'
- en: Julia’s *cartesian indices* are a powerful tool that can greatly simplify all
    kinds of computations with arrays. The two relevant types built into Julia are
    the `CartesianIndex` and `CartesianIndices`. A `CartesianIndex` represents an
    address of an element in an array of any size. `CartesianIndices` are iterators
    that span a rectangular region, of any dimensionality, within an array.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的*笛卡尔索引*是一个强大的工具，可以大大简化与数组相关的各种计算。Julia内置的两个相关类型是`CartesianIndex`和`CartesianIndices`。`CartesianIndex`表示数组中任意大小元素的地址。`CartesianIndices`是跨越数组中任意维度的矩形区域的迭代器。
- en: For concreteness, and so that we can look at pictures, we’ll concentrate on
    two-dimensional arrays, as shown in [Listing 14-5](ch14.xhtml#ch14lis5).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更加具体，也方便我们查看图示，我们将重点关注二维数组，如[Listing 14-5](ch14.xhtml#ch14lis5)所示。
- en: '[PRE44]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 14-5: Iterating over* CartesianIndices'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-5: 遍历* CartesianIndices'
- en: 'This example shows how using `CartesianIndices` simplifies iterating over a
    rectangular region. First we assign the `CartesianIndex` corresponding to the
    index `[1, 1]` to `ci`. Then we iterate from `CartesianIndex(5, 5)`, represented
    as `5ci`, to `8ci`, using `collect()` to instantiate the iteration so we can inspect
    it. The power is in how a linear iteration is expanded into a nested iteration
    over both dimensions, spanning the rectangle between the two corners `[5, 5]`
    and `[8, 8]`. We can use this type of iteration in any number of dimensions:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了如何使用`CartesianIndices`简化对矩形区域的迭代。首先，我们将与索引`[1, 1]`对应的`CartesianIndex`赋值给`ci`。然后，我们从`CartesianIndex(5,
    5)`（表示为`5ci`）迭代到`8ci`，并使用`collect()`来实例化迭代过程，以便我们检查它。关键在于，线性迭代是如何扩展成对两个维度的嵌套迭代的，覆盖了两个角落`[5,
    5]`和`[8, 8]`之间的矩形区域。我们可以在任何数量的维度中使用这种类型的迭代：
- en: '[PRE45]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here the iteration represents a cube. Without `CartesianIndices`, we would have
    to write it as three nested loops, but here it’s a simple range expression.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的迭代代表一个立方体。如果没有`CartesianIndices`，我们需要将其写成三个嵌套循环，但这里它只是一个简单的范围表达式。
- en: 'In fact, `CartesianIndices` are more general than what’s shown in these examples.
    They need not represent contiguous rectangular regions:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`CartesianIndices`比这些例子展示的更为通用。它们不必代表连续的矩形区域：
- en: '[PRE46]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Their utility is in compactly representing nested iterations, and in constructing
    “portable” ranges of indices we can use in different arrays. [Listing 14-6](ch14.xhtml#ch14lis6)
    illustrates this idea.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的实用性在于紧凑地表示嵌套迭代，并构造“可移植”的索引范围，我们可以在不同的数组中使用。[Listing 14-6](ch14.xhtml#ch14lis6)阐明了这个思想。
- en: '[PRE47]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 14-6: Using* CartesianIndices *to construct "portable" ranges of indices*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-6: 使用* CartesianIndices *构造“可移植”索引范围*'
- en: 'Here we’ve assigned a `CartesianIndices` iterator to `by2`, which we then used
    to extract nine noncontiguous elements from a 10×10 matrix. This example also
    shows a more compact way to define the iterators, suggested to us by the form
    of the result returned on the first line:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们将一个`CartesianIndices`迭代器赋值给`by2`，然后用它从一个10×10矩阵中提取了九个不连续的元素。这个例子还展示了一种更简洁的定义迭代器的方法，这种方法是根据第一行返回结果的形式得到的：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To help visualize `CartesianIndices`, we’ll start with a 100×100 version of
    our random gray matrix and select a rectangle within it by iterating over multiples
    of `ci`, defined in [Listing 14-6](ch14.xhtml#ch14lis6):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助可视化`CartesianIndices`，我们将从一个100×100版本的随机灰度矩阵开始，并通过遍历`ci`的倍数，在矩阵中选择一个矩形区域，定义见[Listing
    14-6](ch14.xhtml#ch14lis6)：
- en: '[PRE49]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[Figure 14-23](ch14.xhtml#ch14fig23) shows what this does to `rgi`.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 14-23](ch14.xhtml#ch14fig23)展示了这对`rgi`的作用。'
- en: '![Image](../images/ch14fig23.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch14fig23.jpg)'
- en: '*Figure 14-23: Defining a rectangular region with* CartesianIndices'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 14-23: 用* CartesianIndices *定义矩形区域*'
- en: 'Julia’s `CartesianIndices` equip us with a way to define a rectangular region
    that we can perform direct arithmetic on, to, for example, shift it to various
    locations around an array. This kind of “moving window” operates behind the scenes
    in the fast Fourier transform and spectrogram functions that we used earlier in
    this chapter. It’s also a big part of solving partial differential equations on
    a grid, a major enterprise in computational science. Those with experience programming
    such stencil operations in a traditional language such as Fortran know how tricky
    the process can be. Here we’ll apply the idea to a photograph, by sliding a square
    window around the image to create a blurred, pixel-averaged version:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的`CartesianIndices`为我们提供了一种定义矩形区域的方法，我们可以在该区域上执行直接的算术运算，例如将其移动到数组周围的不同位置。这种“移动窗口”在我们之前使用的快速傅里叶变换和声谱图函数中后台运作。这也是在网格上求解偏微分方程的一个重要部分，这是计算科学中的一项主要工作。那些有经验在传统语言如Fortran中编写此类模板操作的人，知道这个过程有多么棘手。在这里，我们将这一思想应用于一张照片，通过滑动一个方形窗口在图像上来创建一个模糊的、像素平均化的版本：
- en: '[PRE50]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: After loading the image, we initialize an array to hold the averaged version
    using `similar()` ➊, which makes a copy of an array with the same size and types.
    We’ll use the `cim` variable to iterate over the entire original image. The size
    of the moving square window is assigned to `ws`, which is used to define its extent
    ➋. The `for` loop visits each point in the original, replacing it with the average
    of all the pixels in the square window centered on that point.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 加载图像后，我们使用`similar()` ➊初始化一个数组，用来保存平均化后的版本，该函数会复制一个大小和类型相同的数组。我们将使用`cim`变量来遍历整个原始图像。移动方形窗口的大小被赋值给`ws`，它用于定义窗口的范围➋。`for`循环遍历原图中的每个点，将其替换为以该点为中心的方形窗口内所有像素的平均值。
- en: 'The purpose of the `max()` and `min()` calls is to handle the border regions,
    where the moving window would extend beyond the edge of the matrix. This works
    because of how `max()` and `min()` treat `CartesianIndex` types:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()`和`min()`调用的目的是处理边界区域，在这些区域中，移动窗口会扩展超出矩阵的边界。这之所以可行，是因为`max()`和`min()`如何处理`CartesianIndex`类型：'
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The functions return a new `CartesianIndex` where each dimensional index is
    individually maximized or minimized; therefore, we need only refer to the corners
    of the original array to ensure that no index component is too large or too small.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数返回一个新的`CartesianIndex`，其中每个维度的索引都被单独最大化或最小化；因此，我们只需要参考原始数组的角落，以确保没有索引分量过大或过小。
- en: 'The functions act differently on tuples:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数在元组（tuple）上有不同的作用：
- en: '[PRE52]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here the tuples (or vectors) are ordered by their first elements, and the return
    value is always one of the arguments.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，元组（或向量）按其第一个元素排序，返回值始终是其中一个参数。
- en: '[Figure 14-24](ch14.xhtml#ch14fig24) shows the original image and the results
    of averaging over 1, 4, and 8 pixels.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-24](ch14.xhtml#ch14fig24)展示了原图以及经过1、4和8像素平均化后的结果。'
- en: '![Image](../images/ch14fig24.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch14fig24.jpg)'
- en: '*Figure 14-24: Thelonious Monk, 1947\. Original and with averaging over 1,
    4, and 8 pixels, left to right and top to bottom. Photo by William Gottlieb (public
    domain*, [http://hdl.loc.gov/loc.music/gottlieb.06191](http://hdl.loc.gov/loc.music/gottlieb.06191)).'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-24：西奥诺留斯·蒙克，1947年。原图和经过1、4和8像素平滑处理后的图像，从左到右、从上到下。照片由威廉·戈特利布拍摄（公有领域*，[http://hdl.loc.gov/loc.music/gottlieb.06191](http://hdl.loc.gov/loc.music/gottlieb.06191))。'
- en: The result is an increasing softening of the original image, the result of a
    simple form of low-pass filtering.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是原图逐渐变得更加柔和，这是简单的低通滤波的结果。
- en: 'We can use a similar technique to create a reduced image—for example, by a
    factor of two in each dimension:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似的方法创建一个缩小的图像——例如，在每个维度上缩小一倍：
- en: '[PRE53]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: After initializing an array half the size of the original to hold the reduced
    image, we create a `CartesianIndices` iterator spanning it, assigned to `cism`.
    The outer loop iterates over the smaller array and sets each of its elements to
    the average of the pixels surrounding the corresponding pixel in the original.
    The indexing ➊ is due to the fact that for location `[i, j]` in the reduced image,
    the corresponding location in the original is `[2i, 2j]`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化一个大小为原图一半的数组来存放缩小版图像后，我们创建一个覆盖该数组的`CartesianIndices`迭代器，并将其赋值给`cism`。外层循环遍历这个较小的数组，并将其每个元素设置为对应位置在原图中相邻像素的平均值。索引➊之所以如此，是因为对于缩小版图像中的位置`[i,
    j]`，在原图中的对应位置是`[2i, 2j]`。
- en: '[Figure 14-25](ch14.xhtml#ch14fig25) shows the original alongside the reduced
    version.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-25](ch14.xhtml#ch14fig25)展示了原图与减少版的对比。'
- en: '![Image](../images/ch14fig25.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch14fig25.jpg)'
- en: '*Figure 14-25: Piano four hands: reducing an image with pixel averaging*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-25：钢琴四手联弹：通过像素平均化缩减图像*'
- en: Of course, we could also create a quick reduced image with `original[1:2:dy,
    1:2:dx]`, but averaging pixels leads to a better outcome, especially in the appearance
    of diagonal lines. Professional image reduction algorithms usually employ a larger
    window with a sampling method more elaborate than the simple arithmetic mean in
    this example.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以使用`original[1:2:dy, 1:2:dx]`快速创建一个缩减图像，但像素平均化会带来更好的结果，特别是在斜线的表现上。专业的图像缩减算法通常采用更大的窗口，采样方法也比这个例子中的简单算术平均更复杂。
- en: '**Conclusion**'
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: In this chapter, we’ve analyzed and manipulated artifacts from the physical
    world of sounds and images. We’ve explored a variety of tools from packages for
    signal and image processing, but also found that the power of Julia’s facilities
    for array manipulation make difficult jobs easy, allowing us to write short and
    simple programs that perform complex tasks.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析和处理了来自声音和图像的物理世界中的伪影。我们探索了信号和图像处理包中的各种工具，也发现，Julia 强大的数组处理功能使得困难的任务变得简单，让我们能够编写简短而简单的程序来完成复杂的工作。
- en: '**FURTHER READING**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: Documentation for `SignalAnalysis.jl` is available at [*https://org-arl.github.io/SignalAnalysis.jl/stable/*](https://org-arl.github.io/SignalAnalysis.jl/stable/).
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SignalAnalysis.jl` 的文档可以在 [*https://org-arl.github.io/SignalAnalysis.jl/stable/*](https://org-arl.github.io/SignalAnalysis.jl/stable/)
    查阅。'
- en: For details about the WAV file format, visit [*https://docs.fileformat.com/audio/wav/*](https://docs.fileformat.com/audio/wav/).
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关WAV文件格式的详细信息，请访问 [*https://docs.fileformat.com/audio/wav/*](https://docs.fileformat.com/audio/wav/)。
- en: 'JuliaImages is a starting place to find various image processing packages for
    Julia and their documentation: [*https://juliaimages.org/stable*](https://juliaimages.org/stable).'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JuliaImages 是查找各种 Julia 图像处理包及其文档的起点：[*https://juliaimages.org/stable*](https://juliaimages.org/stable)。
- en: For some background about the Hough transform, start with [*https://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm*](https://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm).
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于霍夫变换的背景知识，请访问 [*https://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm*](https://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm)。
- en: 'Cartesian indices . . . what are they good for? Tim Holy explains: [*https://julialang.org/blog/2016/02/iteration/*](https://julialang.org/blog/2016/02/iteration/).
    This article inspired the image reduction used in this chapter.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笛卡尔指标……它们有什么用？Tim Holy 解释道：[*https://julialang.org/blog/2016/02/iteration/*](https://julialang.org/blog/2016/02/iteration/)。这篇文章启发了本章中使用的图像缩减方法。
