- en: '**14'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SIGNAL AND IMAGE PROCESSING**
  prefs: []
  type: TYPE_NORMAL
- en: '*I studied Latin in high school, and I was reading stuff from Cicero. And that
    signal took a few thousand years to get to me. But I was still interested in what
    he had to say.*'
  prefs: []
  type: TYPE_NORMAL
- en: —Seth Shostak
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter contains examples from problems in both signal and image processing.
    The two subjects are usually considered germane to unrelated areas of research:
    signal processing interests the audio or electrical engineer, while image processing
    is relevant to biologists and astronomers. However, they belong together because
    they use many of the same techniques, and the relevant tools have the same mathematical
    foundations. For many purposes, we can think of an image as just a two-dimensional
    signal, and apply similar algorithms to transform, smooth, filter, and more, extending
    the single time dimension to two (or three) space dimensions.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first look at one-dimensional signals, considering the common case of
    an independent coordinate representing time. After that, we’ll explore Julia’s
    packages for image processing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Signals in Time**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sound comes to us as a time-varying air pressure, and we store it as a record
    of amplitude versus time, where the amplitude may represent direct measurements
    of pressure or its conversion to electrical voltages or some other quantity by
    our measuring apparatus. We’ll explore signal processing in Julia by working with
    a sound from nature.
  prefs: []
  type: TYPE_NORMAL
- en: '***Exploring a Sound Sample***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our real-life sound is the call of the endangered cactus ferruginous pygmy
    owl (*Glaucidium brasilianum cactorum*), a native of Arizona. I found the sound
    sample at [*http://www.naturesongs.com/falcstri.html#cobo*](http://www.naturesongs.com/falcstri.html#cobo)
    and saved it on disk with the filename *cfpo1.wav*. The sample is a WAV file:
    a common file format for audio that nearly any music playback or sound editing
    software, on any operating system, can play. Listening to the sample reveals a
    call consisting of a short, medium-high-pitched vocalization repeated about three
    times per second for about 12 total seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*WAV files are often described erroneously as “uncompressed” audio. The audio
    data they contain is almost always compressed using one of a handful of available
    lossless compression algorithms (similar to the compression used in the ZIP family
    of file compression utilities). They take up far more space than the same sound
    compressed using a perceptual encoder such as that used for MP3 files, but such
    files are not useful for scientific signal processing and analysis.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Linux terminal, we can get some information about the file using the `file`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The output reflects the most common file format; the data is little-endian because
    the WAV format was invented at Microsoft. The third clause names the compression
    algorithm; Microsoft PCM is the most common. The rest of the output means that
    the samples were saved with 8 bits of precision, providing 2⁸ = 256 available
    amplitude levels per point, and that we have one channel sampled at 8,000 samples
    per second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the Julia REPL, let’s read in the sample, assign it to `cfpo`, and
    plot the waveform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: First we import two convenient packages for signal analysis. All the other examples
    in this section assume this `using` statement. The `SignalAnalysis.Units` package
    provides time and frequency unit abbreviations, and a handy form of time-based
    indexing that we’ll use later.
  prefs: []
  type: TYPE_NORMAL
- en: The `signal()` function has many methods. When supplied with a string, it loads
    the named file and packages the data into a type defined in the package. The `SignalAnalysis`
    package also extends `Plots` to be able to plot signals directly. [Figure 14-1](ch14.xhtml#ch14fig1)
    shows the waveform of the owl call.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: The call of the cactus ferruginous pygmy owl*'
  prefs: []
  type: TYPE_NORMAL
- en: As the sound sample contains 100,558 elements, plotting is not instantaneous.
    The plot recipe uses information about the sample rate to create a correct time
    axis, and labels the axis as well. The `signal()` function rescales the 8-bit
    samples to `Float64` numbers ranging from –1.0 to 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SignalAnalysis` package supplies several functions for extracting information
    about the signal. The following are the most important of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The term `nframes` refers to samples and `duration()` reports the length of
    the signal in seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-1](ch14.xhtml#ch14fig1) shows the three-chirps-per-second structure
    of the owl call clearly, but we can’t tell what note the owl is singing. Let’s
    zoom in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first two plot statements take advantage of the convenient time-based indexing
    that the `SignalAnalysis` package enables. It frees us from having to convert
    between time and index number of the signal data. The indexing works only with
    seconds and only with a range of floats. To access the single frame at two seconds,
    we can write `cfpo[2.0:2.0s]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-2](ch14.xhtml#ch14fig2) shows the combined plot: two segments of
    the signal at two different scales. The plot recipe always labels the plots beginning
    at `t = 0`, but we can always define `xticks` to reference the original time interval
    if desired.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Two magnified segments of the owl call*'
  prefs: []
  type: TYPE_NORMAL
- en: The bottom plot in [Figure 14-2](ch14.xhtml#ch14fig2) is in the middle of one
    of the chirps, and is sufficiently magnified to allow us to count cycles easily.
    There appear to be about 3.25 cycles in 2.5 ms (most easily counted from *t* =
    5.0 ms, where a peak of the wave happens to align exactly with a grid line, to
    *t* = 7.5 ms), which is a frequency of 3.25/2.5e–3 = 1,300.0 Hz, which is very
    close to the musical note E[6].
  prefs: []
  type: TYPE_NORMAL
- en: '***Analyzing Frequencies***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the senses of the word *analysis* is the separating of something into
    component parts. We’ll perform two types of frequency analysis of signals. The
    first type converts the signal, a function of amplitude versus time, into a function
    of amplitude versus frequency. This is the purpose of the Fourier transform, which
    assumes that the signal is periodic, and analyzes it into a sum of periodic functions
    (sines and cosines of various amplitudes, sines or cosines of various phases and
    amplitudes, or complex exponentials—all equivalent representations). The representation
    as a sum of frequencies is the signal’s *spectrum*. The second type combines temporal
    and frequency information into a *spectrogram*. Here we no longer assume that
    the signal is periodic. The spectrogram shows us the spectrum as it varies in
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SignalAnalysis` package provides several plotting routines we can use
    to visualize both types of frequency analysis. The `psd()` function plots the
    *power spectral density* of a signal based on its Fourier transform. Its interpretation
    is straightforward when applied to a periodic signal, which describes the owl
    call pretty well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Since `psd()` uses the `Plots` package, we can supply the familiar keyword arguments.
    [Figure 14-3](ch14.xhtml#ch14fig3) shows the spectrum.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Fourier spectrum of the call of an owl*'
  prefs: []
  type: TYPE_NORMAL
- en: The spectrum has a peak just barely below 1,300 Hz, which agrees with our estimate
    from counting cycles of the waveform. We can also see peaks close to the second
    and third harmonics (twice and thrice 1,300 Hz).
  prefs: []
  type: TYPE_NORMAL
- en: Displays such as [Figure 14-3](ch14.xhtml#ch14fig3) are useful analytic and
    diagnostic tools, but they don’t convey a full idea of the nature of the signal
    under investigation. We can see that the signal is dominated by a 1,300 Hz frequency,
    with two strong overtones, but there’s no hint of the rapid staccato performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a fuller analysis, we turn to the spectrogram. The `SignalAnalysis` package
    also provides a function to create these visualizations easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 14-4](ch14.xhtml#ch14fig4) contains the spectrogram, and clearly shows
    the frequency distribution of energy in the signal: the strong component near
    1,300 Hz and the two higher harmonics at lower amplitudes. We can also see the
    temporal structure; the chirps repeating at about three times per second are obvious.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Spectrogram of the owl call*'
  prefs: []
  type: TYPE_NORMAL
- en: Spectrograms use Fourier transforms and a *window* sliding over the signal to
    calculate the spectrum as it evolves, resulting in a visualization combining frequency
    and time information. They’re more informative than a `psd()`-type plot for any
    except periodic signals. Practical Fourier transform routines, such as the ones
    used by `psd()`, also use windowing, but for the purpose of eliminating the inevitable
    discontinuities at the edges of the signal and the resulting “leakage” of spurious
    high-frequency components.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This section presents the quickest and most convenient methods for signal
    analysis, with an emphasis on getting to the visualizations that interest most
    scientists. For more control, or to obtain direct access to spectra, import the*
    DSP.jl *package. The* SignalAnalysis *package wraps many of its routines, but
    importing* DSP *grants access to its definitions for various Fourier transform
    windows and other details that we can invoke with keyword arguments to the higher-level*
    SignalAnalysis *routines such as* psd()*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve dealt with two ways to examine the frequency spectra of signals,
    in the next section we’ll explore methods for transforming the signal by altering
    the spectrum.
  prefs: []
  type: TYPE_NORMAL
- en: '***Filtering***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *filter* in the context of signal processing is a circuit, device, or, in
    our case, a computation, that attenuates some of the frequencies present in a
    signal. Perhaps the most familiar examples are the crossover circuits in speakers
    that route the high frequencies to the tweeters and the low frequencies to the
    woofers.
  prefs: []
  type: TYPE_NORMAL
- en: Filters are also important in empirical science—for example, in reducing noise
    in measurements. Imagine a sensor that records the variations in depth of a waterway.
    We might be interested in measuring the effect of tides, and detecting any long-term
    change in the average depth. These changes occur on the timescales of hours and
    longer. However, the measurements will be polluted by the more rapid changes caused
    by wind, weather, and passing boats. Using filtering, we can seek to erase the
    irrelevant data from the signal by eliminating frequencies faster than, say, one
    cycle per hour.
  prefs: []
  type: TYPE_NORMAL
- en: This strategy suggested in the previous paragraph is called a *low-pass* filter,
    because it attenuates frequencies *above* a specified cutoff, allowing those below
    the cutoff to pass. An example of a *high-pass* filter would be the crossover
    circuit leading to a speaker’s tweeter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another type of filtering common in scientific instrumentation is a *notch*
    filter: one that attenuates frequencies near a target frequency. Notch filters
    are useful for eliminating 60 or 50 Hz power line noise from instruments through
    which the signal passes (but are only useful if the signal doesn’t contain information
    near the power line frequency).'
  prefs: []
  type: TYPE_NORMAL
- en: A *band-pass* filter attenuates anything outside a narrow band around a target
    frequency.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making Filters with fir()**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `SignalAnalysis` package makes it easy to construct any of these types of
    filters and apply them to signals. In each case we begin with the `fir()` function
    to construct the filter. Its basic use involves three positional arguments and
    an optional keyword argument named `fs`, giving the sampling frequency of the
    signal.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is an integer number of *taps*, which is related to the number
    of terms retained in the polynomial that describes the filter. Essentially, a
    greater number of taps causes the filter to be more selective and its response
    to be smoother. The second and third arguments are the lower and upper bounds
    of the unfiltered frequency range. If we provide the `fs` keyword, we supply these
    arguments in `Hz`, `kHz`, or another unit from `SignalAnalysis.Units`. For example,
    [Listing 14-1](ch14.xhtml#ch14lis1) shows how to make a low-pass filter that filters
    out everything above 2,000 Hz.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-1: Constructing a low-pass filter*'
  prefs: []
  type: TYPE_NORMAL
- en: The example makes a 127-tap filter, which is a typical value.
  prefs: []
  type: TYPE_NORMAL
- en: The lower bound for a low-pass filter is 0, as in the example. To make a high-pass
    filter, we pass `nothing` as the upper bound.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SignalAnalysis` package provides a plotting function to visualize the
    filters created with `fir()`. To see a plot of the frequency response of the `lpf`
    filter defined previously, we need simply enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This creates the plot shown in [Figure 14-5](ch14.xhtml#ch14fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Frequency response of a low-pass filter*'
  prefs: []
  type: TYPE_NORMAL
- en: The top graph in [Figure 14-5](ch14.xhtml#ch14fig5) indicates the amount by
    which the frequency component, given on the horizontal axis, will be reduced when
    the filter is applied to a signal. The units are in dB (decibels), which is conventional
    in signal processing. [Figure 14-5](ch14.xhtml#ch14fig5) shows 0 dB, or no change,
    to the frequencies until we approach 2,000 Hz, when the signal is rapidly attenuated.
    For normal sounds, a reduction of 20 dB effectively silences the component it’s
    applied to; therefore, the oscillations in the filter response below –50 dB have
    no audible effect.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom graph shows the phase shifts created by the filter. These are usually
    inaudible, but may or may not be relevant, depending on one’s plans for the filtered
    signal.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For more detailed control over the filter characteristics, we can import*
    DSP.jl *and pass a* method *keyword to* fir() *using one of the filter construction
    methods described at* [https://docs.juliadsp.org/stable/filters/](https://docs.juliadsp.org/stable/filters/).'
  prefs: []
  type: TYPE_NORMAL
- en: The dB numbers in the frequency response plot are directly added to the values
    of frequency component peaks displayed in the `psd()` plot of a signal, which
    are also displayed in dB. To calculate the change in amplitude of the signal itself,
    we use the formula
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/437math.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'where *V* is the amplitude of the component in the input signal and *V*[*f*]
    is the filtered amplitude. Therefore, a 6 dB reduction halves the amplitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/437math1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To see the effect of larger tap values, we can make two additional low-pass
    filters with the same frequency ranges but with more taps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A higher tap number will produce a filter with a response closer to ideal, as
    [Figure 14-6](ch14.xhtml#ch14fig6) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: A low-pass filter using different tap numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: Although using a higher tap number creates a cleaner filter with a sharper cutoff,
    it leads to a more expensive filtering calculation. The added calculation time
    makes no difference for our example, using a stored signal of moderate length,
    but it can be a consideration with real-time filtering, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '**Applying Filters**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To filter the signal, we can use the function `sfilt()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This applies the low-pass filter defined in [Listing 14-1](ch14.xhtml#ch14lis1)
    to the owl sample and assigns the result, a new signal, to `cfpo_lp`. Plotting
    the power spectrum of the filtered signal using `psd()` shows the effect of the
    filtering (see [Figure 14-7](ch14.xhtml#ch14fig7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: The filtered owl call*'
  prefs: []
  type: TYPE_NORMAL
- en: This plot displays the original, unfiltered spectrum using a dotted line and
    the filtered spectrum with a thicker, solid line. The spectrum below the low-pass
    cutoff at 2 kHz is untouched, while all frequencies above have been eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create [Figure 14-7](ch14.xhtml#ch14fig7) with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It’s necessary to repeat some of the keyword arguments when adding to `psd()`
    plots because the plotting recipe resets them.
  prefs: []
  type: TYPE_NORMAL
- en: The spectrogram of the filtered signal in [Figure 14-8](ch14.xhtml#ch14fig8)
    also shows the elimination of the second and third harmonics with the preservation
    of the signal otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: Spectrogram of the filtered owl call*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synthetic Signals**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In order to ensure that we understand, quantitatively, signal analysis and filtering,
    let’s start with a signal synthesized from known frequency components. Another
    method of `signal()` creates a signal with embedded sampling rate information
    from a normal vector. In [Listing 14-2](ch14.xhtml#ch14lis2), we create a vector
    consisting of the addition of two sine waves, representing data with two components
    at 1,000 and 2,050 Hz sampled at 8 kHz. We then package the data into a signal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-2: Creating a synthetic signal*'
  prefs: []
  type: TYPE_NORMAL
- en: We assigned the result to `sin1000_2050`. The second argument to `signal()`
    gives the sampling rate. The component at 2,050 Hz has half the amplitude of the
    component at 1,000 Hz. The power spectrum should show two peaks, with the higher-frequency
    peak 6 dB lower than the lower-frequency peak. [Figure 14-9](ch14.xhtml#ch14fig9)
    shows the result of [Listing 14-3](ch14.xhtml#ch14lis3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-3: Spectrum of a synthetic signal*'
  prefs: []
  type: TYPE_NORMAL
- en: Because the signal contains embedded sampling rate information, `psd()` is able
    to scale the plot correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Spectrum of a synthetic signal with two frequency components*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-9](ch14.xhtml#ch14fig9) shows the power spectrum with two narrow
    peaks where we put them, and the correct 6 dB difference in their amplitudes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s measure the effect of filtering. We’ll use the `lpf` filter defined
    in [Listing 14-1](ch14.xhtml#ch14lis1), but first we need to take a closer look
    at it near its cutoff frequency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The expanded plot of the filter response in [Figure 14-10](ch14.xhtml#ch14fig10)
    (with the phase response omitted) shows that the filter should reduce the 2,050
    Hz component by 16 dB.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: The cutoff region of the low-pass filter*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check whether the filter is working as expected by overlaying the power
    spectrum of the filtered signal onto the plot created in [Listing 14-3](ch14.xhtml#ch14lis3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 14-11](ch14.xhtml#ch14fig11) shows that the higher-frequency peak is
    reduced by 16 dB while the lower-frequency peak is unchanged.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Power spectrum of the filtered synthetic signal*'
  prefs: []
  type: TYPE_NORMAL
- en: This little exercise shows that the filters have predictable effects, altering
    the spectra without introducing artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving Signals**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can read a WAV file from disk into a signal using the `signal()` function,
    but saving a signal as a WAV file requires importing the `WAV.jl` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The keyword arguments select a compression format and word size that’s compatible
    with a wide variety of software. After making the `wavwrite()` call, a WAV file
    called *cfpo_lp.wav* will exist on the disk drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to save our `sin1000_2050` signal as a WAV file, we first have to
    scale it to have unit amplitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Then we save it using `wavwrite()` as before and play it using any audio software.
  prefs: []
  type: TYPE_NORMAL
- en: '**Image Processing**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s consider an image interpretation task common in medicine and laboratory
    biology: how many blood cells are in a photograph of a blood sample taken through
    a microscope? The traditional method of acquiring this “blood count” was to enumerate
    the cells manually, a tiresome and errorprone process. We’ll see how to use various
    image processing techniques with Julia to automate the procedure. The result will
    be a faster and more accurate count that doesn’t require tedious labor. However,
    the techniques we’ll investigate here aren’t limited to blood counts. We could
    apply them to everything from counting bacteria to analyzing satellite reconnaissance.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Loading and Converting Images***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The command `using Images` imports the file and image input-output functions,
    including optimized routines for most image types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: After the import, a simple `load()` command reads the file into an image, which
    in Julia is an array of pixels.
  prefs: []
  type: TYPE_NORMAL
- en: When working in a notebook, such as Pluto, the results of image operations are
    displayed as images; in the terminal REPL, they’re displayed similarly to other
    arrays. For graphical image display from the REPL, the `ImageView` package supplies
    the `imshow()` function. The window opened by `imshow()` features a few GUI powers,
    the most useful of which is a display of pixel address and color value in response
    to moving the mouse pointer over the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Images can be matrices of numbers or pixel types. There are several types of
    pixels, but the ones we’ll be using are `RGB` and `Gray` pixels. Since we loaded
    the `frog_blood` image from a color picture, it’s an array of `RGB` (red-green-blue)
    pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is clearly a parametric type (see “Parametric Types” on [page 248](ch08.xhtml#ch08lev6)).
    The parameter `N0f8` is another (parametric) type that maps unsigned 8-bit integers
    to floats in the range `[0.0, 1.0]`. An element of `frog_blood` looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be purple: nearly equal amounts of red and blue and almost no green.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to replace the extreme upper-left pixel with pure green, we could
    execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: However, we won’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can convert the color image to a grayscale version by broadcasting `Gray()`
    as a conversion function to the image array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The listing also shows how to save images in files. The `save()` function converts
    image data to the file format indicated by the filename extension. Here we’ve
    saved two versions of the same image, one as a *.jpg* file and one as a *.png*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-12](ch14.xhtml#ch14fig12) shows the grayscaled image.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: The frog blood image converted to grayscale. Original image
    by Wayne Large (CC BY-ND 2.0). Available from* [https://flic.kr/p/cBDUEG](https://flic.kr/p/cBDUEG).'
  prefs: []
  type: TYPE_NORMAL
- en: Other useful color conversion functions are `red()`, `green()`, and `blue()`,
    which extract the named color channels from an `RGB` pixel and can also, of course,
    be broadcast to entire images to separate them into their color channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to compare two, or several, versions of an image, perhaps to eyeball
    the effect of a transformation or processing step, the `mosaicview()` function
    is handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This command creates four images showing the three color channels of the original
    `frog_blood` image and the composite grayscale version, sticks them together in
    a grid, then displays them. If working in a notebook, we don’t need the `imshow()`
    call. The `ncol` argument specifies the numbers of columns in the image grid (an
    `nrows` is also available), and the `npad` argument puts a border of the specified
    number of pixels between the images.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-13](ch14.xhtml#ch14fig13) shows what `mosaicview()` produces.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The red, green, blue, and all channels (top to bottom, left
    to right) of the frog blood image*'
  prefs: []
  type: TYPE_NORMAL
- en: The original image, containing all of the color channels, is in the lower-right
    quadrant.
  prefs: []
  type: TYPE_NORMAL
- en: '***Counting Cells Using an Area Fraction***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our first attempt at automating the counting of blood cells will use the `ImageBinarization`
    package. This package contains a handful of algorithms for separating an image
    into a “foreground” and a “background,” coloring the foreground pure black and
    the background pure white. In other words, each pixel in the original image is
    assigned either 0.0 or 1.0, depending on the results of the algorithm invoked.
    The package documentation displays examples of the results of all the available
    algorithms on a variety of image types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal is to generate an image that separates the blood cells from everything
    else, as much as possible. This binary image will then be a good starting point
    for further analysis. We’ve already made some progress in this direction through
    the color separations shown in [Figure 14-13](ch14.xhtml#ch14fig13). The blue
    channel, at the bottom, seems to have increased the contrast between the (larger)
    red blood cells and the other particles. Instead of binarizing the original color
    image, we’ll start with the blue channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `binarize()` function takes the image as the first argument and the name
    of the binarization algorithm as the second argument, and returns the binarized
    image. The documentation describes the details of the `Intermodes` algorithm.
    For our purposes, it does a good job at detecting discrete structures, such as
    cells, against a plain background.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-14](ch14.xhtml#ch14fig14) shows the binarized image.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-14: The blue channel of the frog blood slide after binarization*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use this image as the basis for the blood count.
  prefs: []
  type: TYPE_NORMAL
- en: If we knew the average area of the blood cells in the image, we could divide
    that into the total area occupied by all blood cells to arrive at an estimate
    of the number of cells. The cells appear to be approximately elliptical (in this
    two-dimensional image).
  prefs: []
  type: TYPE_NORMAL
- en: Using the GUI in the `imshow()` window, I used the pixel readout to measure
    the major and minor axis lengths of four typical cells at 26.8 pixels and a typical
    minor axis at 24.5 pixels. Using *A* = *πr*[1]*r*[2] for the area of an ellipse
    with radii *r*[1] and *r*[2], the average of the four areas was 511.3 square pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the total blood fraction is simple using the binarized image. In `frog_blood_b1`,
    the cells are black, with a pixel value of 0, and the background is white, with
    a value of 1\. The total cell count is therefore `sum(1 .- frog_blood_b1)`, which
    evaluates to 255,029.0\. Dividing this result by the average cell area yields
    499 cells.
  prefs: []
  type: TYPE_NORMAL
- en: '***Counting Cells by Recognizing Features***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can improve on the estimate in the previous section by exploiting algorithms
    that search for features with particular shapes in the image. The Hough transform
    (see “Further Reading” on [page 465](ch14.xhtml#fur14) for background) is one
    such class of algorithms that can be specialized to various shapes. The `ImageFeatures`
    package, which we’ll assume is imported in the following examples, offers implementations
    for detecting lines and circles. As the features we need to detect resemble circles,
    we’ll use the `hough_circle_gradient()` function, an implementation of the Hough
    transform for circles.
  prefs: []
  type: TYPE_NORMAL
- en: Before applying the algorithm, we’ll process the image to make its task easier
    and produce a more accurate result. One problem with the image is that the cells
    we want to count are not circles, but elongated. Hough transforms for ellipses
    do exist, but are not yet available in the `ImageFeatures` package. Another problem
    is that many cells are touching, and a few are overlapping. The Hough transform
    can deal with touching and overlapping circles, but it has a better time with
    cleanly separated shapes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nature has provided some assistance with the second problem: each cell has
    a nucleus, clearly delineated in the picture. Even when blood cells are in contact
    or overlapping, their nuclei are separated. If we could eliminate most of everything
    except the nuclei from the image, we could simply count those to get the blood
    count.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we are fortunate: the color of the nuclei makes them easy to distinguish
    from everything else in the image. This may not be apparent to the eye, but by
    placing the mouse cursor on the nuclei in the `imshow()` window, and comparing
    with other locations, we can see that the nuclei are unique in having a green
    value close to 0 while having a red value > 0.2\. We can confirm this in other
    ways—for example, by plotting the three color components along lines through the
    image.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following array comprehension creates a new image from the original pixel
    by pixel, by leaving the pixels within the nucleus color range unchanged, while
    turning the others white:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We also transform the result into a grayscale image for further processing and
    printing. [Figure 14-15](ch14.xhtml#ch14fig15) shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-15: Frog blood nuclei isolated by color*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve managed to isolate the nuclei pretty well and eliminate some of the particles
    that are something other than blood cells.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-15](ch14.xhtml#ch14fig15) is a good candidate for the circle-finding
    algorithm, but we must complete two preliminary steps first. The `hough_circle_gradient()`
    function doesn’t operate on actual images, but on maps of *edges* and *phases*.
    The edge map is the output of an edge-detection algorithm, transforming the image
    into, essentially, a line drawing tracing its shapes. The map of phases is a matrix
    of angles calculated from the edge map, giving the direction at every point of
    its gradient, as an angle from *–π* to π.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `canny()` function is an excellent edge detector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Its second argument is a tuple of thresholds used for defining an edge from
    the input image (which must be grayscale). I arrived at the values it contains
    through trial and error, aiming for a set of edges that captured the nuclei while
    ignoring most of the scattering of white blood cells and other particles. [Figure
    14-16](ch14.xhtml#ch14fig16) shows the output of the `canny()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-16: Edge detection of the nuclei image*'
  prefs: []
  type: TYPE_NORMAL
- en: This is a pretty clean result, and is what we were aiming for.
  prefs: []
  type: TYPE_NORMAL
- en: 'The phase calculation itself requires two steps—first the gradient map itself
    and then the phases derived from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With the edges and phases computed, we can run the Hough transform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: After this call, `centers` contains a vector of indices giving the locations
    of each circle and `radii` a vector of their corresponding radii. The length of
    either vector gives the number of circles found. In this case, the length is 534,
    which is in reasonable agreement with the estimate of 499 we arrived at earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The third argument to `hough_circle_gradient()` gives the allowed range for
    the circle radii, in pixels. The `min_dist` keyword argument is the minimum allowed
    distance between circle centers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how well the circle fitting did, and how much confidence we should lend
    to the estimate of 534 blood cells, we can use the `centers` array to draw circles
    directly on the original image where the `hough_circle_gradient()` function says
    they should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `draw!()` function, provided by `ImageDraw`, mutates its first argument
    by drawing shapes on it, in white by default. The `CirclePointRadius()` in the
    second argument creates a circle at point `p` with radius 15; the `fill=false`
    creates an open circle with perimeter thickness controlled by the `thickness`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-17](ch14.xhtml#ch14fig17) shows the result of drawing the circles
    on top of the (grayscale version of) the original image.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-17: Circles detected by a Hough transform*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-17](ch14.xhtml#ch14fig17) shows that the Hough transform did an
    excellent job. Nearly every blood cell is marked with a circle, and most of the
    other objects are ignored. There are a few misses and a few false detections,
    but, on the whole, the count of 534 is quite accurate.'
  prefs: []
  type: TYPE_NORMAL
- en: The image processing pipeline described in this section would be practical for
    automating blood counts, although the specific parameters would need to be adjusted
    for different types of samples, different stains, and so on. The approach is far
    faster and probably more accurate than manual counting.
  prefs: []
  type: TYPE_NORMAL
- en: '***Applying Advanced Array Concepts***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As an image is an array, various advanced array concepts available in Julia
    can make their manipulation more convenient and concise. This section explores
    techniques for dealing with arrays that we haven’t used directly up to now, although
    we’ve seen how they’re used in several packages. Placed within an image processing
    context, their use becomes easier to visualize.
  prefs: []
  type: TYPE_NORMAL
- en: '**Views**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *view* is a reference to another array or to a section of another array.
    The other array is called the *parent*. A view is a kind of virtual array, which
    occupies almost no memory: it shares memory with the parent, so modifying one
    modifies the other.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*It is dangerous to alter the shape of the parent array after creating a view.
    Subsequent operation on the view may create out-of-bounds memory accesses or segmentation
    faults.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how views work, we’ll create a small grid of middle-gray values and
    a view pointing to every other element in the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The second line shows how to create a view with the `@view` macro. The `checkers`
    view, defined by selecting alternate squares of the parent array, forms a checkerboard
    pattern. Its size is half that of the parent. After setting all its elements to
    0.0 ➊, the corresponding elements in the parent are likewise modified. We can
    change the values of elements in the view repeatedly, and these updates are reflected
    in the parent. [Figure 14-18](ch14.xhtml#ch14fig18) shows the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-18: Patterns created using a view*'
  prefs: []
  type: TYPE_NORMAL
- en: This example shows how views can simplify certain expressions. They’re also
    useful as an aid to memory parsimony. If a computation uses parts of arrays as
    intermediate containers, which we don’t need in the final result, we can avoid
    allocating memory to hold these temporary structures by using views instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an illustration, here are two versions of a little function that returns
    the difference between the sums of alternate elements in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `@views` macro ➊ transforms all slice operations in the expression to its
    right into view operations. The first version of the program creates two arrays
    and computes the sum of odd and even indexed elements. The second performs the
    same computation, but by creating views instead of new arrays. The timing runs
    show that using views cut the memory consumption in half while also decreasing
    runtime by a third. Avoiding unnecessary array copying by using views where possible
    is an easy optimization.
  prefs: []
  type: TYPE_NORMAL
- en: '**AxisArrays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: With the `AxisArrays` package, we can give names to array dimensions and axes,
    give units to arrays, and enjoy more flexible indexing. Dataframes (see “Dataframes”
    on [page 333](ch10.xhtml#ch10lev1sec7)) also allow us to name rows and columns,
    but are limited to two dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to name the rows and columns of a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With this definition, we can index using the numbers that we’re used to or
    the names that we’ve assigned to the axes, or mix them up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The example shows that we can slice with our custom names ➊ as we do with numerical
    indices, and that, if we use the names of the dimensions, we can supply indices
    in any order ➋. We can use any names where we use `row` and `col` here. They’re
    defined only within index expressions; they don’t exist as variables outside the
    brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example shows how to incorporate units into the definition of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This shows the use of the `Axis{}()` constructor, and, in the final line, various
    ways we can index into the array, including mixing numerical and unit indices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use an ellipsis, from the automatically imported `EllipsisNotation`
    package, to represent ranges of units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This illustrates two properties of dimension ranges. We can use equivalent units,
    here using 10 mm = 1 cm, and the endpoints of the intervals need not lie exactly
    on an element of the array. Beware that the indexing rounds *down* and not to
    the nearest element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define a rectangle using ranges of lengths, paint it white, and plot
    the resulting array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The plotting command is an example of custom labeled ticks. [Figure 14-19](ch14.xhtml#ch14fig19)
    shows the new state of `rgin`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-19: We paint this white rectangle by specifying physical lengths.*'
  prefs: []
  type: TYPE_NORMAL
- en: The direct use of physical dimensions to index arrays frees us from the mental
    or programmatic labor of constantly translating between integer indices and the
    quantities that they represent in our models.
  prefs: []
  type: TYPE_NORMAL
- en: '**OffsetArrays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Those with experience in Python or C, when encountering Julia for the first
    time, sometimes complain about its 1-based indexing, whereas old Fortran hands
    know that it’s a better choice. The former group may be pleased to know that in
    Julia, as in Fortran, we can make arrays that start anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: '**DON’T ASSUME 1-BASED INDEXING**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that an array passed to a function will be 1-based is a source of
    occasional bugs in public packages. The existence of `OffsetArrays` is the reason
    for our earlier warning not to iterate over arrays with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, use `eachindex(A)` or another construction that generates legal indices.
    But there is another reason: using `eachindex()` generates more efficient memory
    accesses for certain types of arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OffsetArrays` package provides several ways to create an `OffsetArray`.
    We can call the `OffsetArray()` function with the source array and each dimension’s
    *offset* as positional arguments. A dimension’s offset is how far its indices
    are shifted from their normal position. An offset of 0 means no shift, and an
    offset of –2 means that the dimension’s index runs from –1 to two less than its
    length. To illustrate how an `OffsetArray` works, we’ll start with our random
    gray matrix again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use a seeded random number generator (see “Random Numbers
    in Julia” on [page 307](ch10.xhtml#ch10lev2)) so that the results will be identical
    for readers trying these commands. The `(-2, 3)` position of `rgi_offset` corresponds
    to the `(1, 1)` position of `rgi`.
  prefs: []
  type: TYPE_NORMAL
- en: This use of `OffsetArray()` creates a view, rather than a copy of the original,
    as shown in [Listing 14-4](ch14.xhtml#ch14lis4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-4:* OffsetArrays *are views.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the two arrays share memory, modifying `rgi_offset` modifies `rgi`. Of
    course, we can make a new array using `copy()` if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Painting part of the array white illustrates that ranges work as before, taking
    into account the offsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 14-20](ch14.xhtml#ch14fig20) shows the image of the array, with the
    black element set in [Listing 14-4](ch14.xhtml#ch14lis4) and the white rectangle
    set in this example. The plotting grid for heatmaps is centered on the elements,
    so we can examine which elements were changed to verify that we understand the
    indexing ranges.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-20: The white rectangle was defined as an* OffsetArray.'
  prefs: []
  type: TYPE_NORMAL
- en: Plotting with `heatmap()` doesn’t work with `OffsetArrays` unless we explicitly
    supply coordinate vectors. In other words, we can call `heatmap(rgi)`, but must
    use `heatmap(1:10, 1:10, rgi_offset)` to prevent the plotting routine from getting
    confused. The two calls produce the same image in this case, as the two arrays
    share memory.
  prefs: []
  type: TYPE_NORMAL
- en: '`OffsetArray()` provides another syntax, using ranges of indices rather than
    single offsets. This method is convenient when extracting a subset of an existing
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: First we load a color photograph, convert it to grayscale, and then to a floating-point
    array, assigning the result to the `passage`. Since we plan to inspect the images
    in this example using `heatmap()`, we flip the image vertically for convenience
    to undo the effect of the orientation of the vertical axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `OffsetArray()`, we extract a square portion of the image and assign
    it to `middle_passage` ➊. This line shows another way to establish the offset
    indices: instead of a single integer offset, we supply the range of indices indexing
    the array. We choose these to be identical to the indices used to extract the
    sub-image, so that a pixel addressed in the extracted part will correspond to
    the pixel in the original image with the same indices. This technique greatly
    simplifies programs where we want to maintain a correspondence between an array
    and a sub-array, eliminating the need to constantly translate indices. The `middle_passage`
    matrix is a new array, not a view, because the index ranges create a copy.'
  prefs: []
  type: TYPE_NORMAL
- en: The next line paints the square region, from which we took the extract, black.
  prefs: []
  type: TYPE_NORMAL
- en: In the final line, we replace a portion of the black square with a portion of
    the extracted part of the image ➋. Since the index ranges in both arrays are identical,
    the replaced part of the image will exactly correspond to what was there originally.
    The result is a black frame around a part of the image, with nothing else altered,
    as [Figure 14-21](ch14.xhtml#ch14fig21) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-21:* OffsetArrays *make many image manipulations easier. Original
    photograph taken inside a Titan missile facility by Lee Phillips (CC BY-ND 2.0).*'
  prefs: []
  type: TYPE_NORMAL
- en: The use of offset indices makes this code easier to write and read, and less
    prone to errors. With conventional arrays we would have been forced to add lines
    performing array arithmetic to translate between pixel ranges in the large and
    extracted images, or construct the frame from pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OffsetArrays` package proves two additional ways to construct array offsets
    automatically, both of which can be convenient in image processing. We can order
    up an `OffsetArray` centered on an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `center()` function ➊ from `OffsetArrays` returns the index of the center
    of an array (if the array has an odd number of elements along some dimension,
    it rounds down). The package’s `centered()` function ➋ creates an `OffsetArray`
    with the index `[0, 0]` at its center. We usually need to qualify these function
    names with the package name because of collisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having the center of index space at the center of an array is helpful in the
    common situation where the array represents a quantity in physical space, or in
    space and time, where we often use a coordinate system with the origin at the
    center. Here’s another visual example, where having the `[0, 0]` point at the
    center of an image simplifies calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We’ve set `dmax` to the distance from the center to end along the shorter dimension.
    Then we multiply each pixel by a decreasing function of distance from the center.
    [Figure 14-22](ch14.xhtml#ch14fig22) shows the result, a centered circular frame
    darkening toward the edges.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-22:* OffsetArrays *make it easy to reference the center of an array.*'
  prefs: []
  type: TYPE_NORMAL
- en: Using a centered `OffsetArray` simplifies the code, allowing us to dispense
    with the index arithmetic usually needed to reference the center of an array.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cartesian Indices**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Julia’s *cartesian indices* are a powerful tool that can greatly simplify all
    kinds of computations with arrays. The two relevant types built into Julia are
    the `CartesianIndex` and `CartesianIndices`. A `CartesianIndex` represents an
    address of an element in an array of any size. `CartesianIndices` are iterators
    that span a rectangular region, of any dimensionality, within an array.
  prefs: []
  type: TYPE_NORMAL
- en: For concreteness, and so that we can look at pictures, we’ll concentrate on
    two-dimensional arrays, as shown in [Listing 14-5](ch14.xhtml#ch14lis5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-5: Iterating over* CartesianIndices'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example shows how using `CartesianIndices` simplifies iterating over a
    rectangular region. First we assign the `CartesianIndex` corresponding to the
    index `[1, 1]` to `ci`. Then we iterate from `CartesianIndex(5, 5)`, represented
    as `5ci`, to `8ci`, using `collect()` to instantiate the iteration so we can inspect
    it. The power is in how a linear iteration is expanded into a nested iteration
    over both dimensions, spanning the rectangle between the two corners `[5, 5]`
    and `[8, 8]`. We can use this type of iteration in any number of dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here the iteration represents a cube. Without `CartesianIndices`, we would have
    to write it as three nested loops, but here it’s a simple range expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, `CartesianIndices` are more general than what’s shown in these examples.
    They need not represent contiguous rectangular regions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Their utility is in compactly representing nested iterations, and in constructing
    “portable” ranges of indices we can use in different arrays. [Listing 14-6](ch14.xhtml#ch14lis6)
    illustrates this idea.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-6: Using* CartesianIndices *to construct "portable" ranges of indices*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we’ve assigned a `CartesianIndices` iterator to `by2`, which we then used
    to extract nine noncontiguous elements from a 10×10 matrix. This example also
    shows a more compact way to define the iterators, suggested to us by the form
    of the result returned on the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To help visualize `CartesianIndices`, we’ll start with a 100×100 version of
    our random gray matrix and select a rectangle within it by iterating over multiples
    of `ci`, defined in [Listing 14-6](ch14.xhtml#ch14lis6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 14-23](ch14.xhtml#ch14fig23) shows what this does to `rgi`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-23: Defining a rectangular region with* CartesianIndices'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia’s `CartesianIndices` equip us with a way to define a rectangular region
    that we can perform direct arithmetic on, to, for example, shift it to various
    locations around an array. This kind of “moving window” operates behind the scenes
    in the fast Fourier transform and spectrogram functions that we used earlier in
    this chapter. It’s also a big part of solving partial differential equations on
    a grid, a major enterprise in computational science. Those with experience programming
    such stencil operations in a traditional language such as Fortran know how tricky
    the process can be. Here we’ll apply the idea to a photograph, by sliding a square
    window around the image to create a blurred, pixel-averaged version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: After loading the image, we initialize an array to hold the averaged version
    using `similar()` ➊, which makes a copy of an array with the same size and types.
    We’ll use the `cim` variable to iterate over the entire original image. The size
    of the moving square window is assigned to `ws`, which is used to define its extent
    ➋. The `for` loop visits each point in the original, replacing it with the average
    of all the pixels in the square window centered on that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of the `max()` and `min()` calls is to handle the border regions,
    where the moving window would extend beyond the edge of the matrix. This works
    because of how `max()` and `min()` treat `CartesianIndex` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The functions return a new `CartesianIndex` where each dimensional index is
    individually maximized or minimized; therefore, we need only refer to the corners
    of the original array to ensure that no index component is too large or too small.
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions act differently on tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here the tuples (or vectors) are ordered by their first elements, and the return
    value is always one of the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-24](ch14.xhtml#ch14fig24) shows the original image and the results
    of averaging over 1, 4, and 8 pixels.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-24: Thelonious Monk, 1947\. Original and with averaging over 1,
    4, and 8 pixels, left to right and top to bottom. Photo by William Gottlieb (public
    domain*, [http://hdl.loc.gov/loc.music/gottlieb.06191](http://hdl.loc.gov/loc.music/gottlieb.06191)).'
  prefs: []
  type: TYPE_NORMAL
- en: The result is an increasing softening of the original image, the result of a
    simple form of low-pass filtering.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a similar technique to create a reduced image—for example, by a
    factor of two in each dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: After initializing an array half the size of the original to hold the reduced
    image, we create a `CartesianIndices` iterator spanning it, assigned to `cism`.
    The outer loop iterates over the smaller array and sets each of its elements to
    the average of the pixels surrounding the corresponding pixel in the original.
    The indexing ➊ is due to the fact that for location `[i, j]` in the reduced image,
    the corresponding location in the original is `[2i, 2j]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-25](ch14.xhtml#ch14fig25) shows the original alongside the reduced
    version.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch14fig25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-25: Piano four hands: reducing an image with pixel averaging*'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we could also create a quick reduced image with `original[1:2:dy,
    1:2:dx]`, but averaging pixels leads to a better outcome, especially in the appearance
    of diagonal lines. Professional image reduction algorithms usually employ a larger
    window with a sampling method more elaborate than the simple arithmetic mean in
    this example.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we’ve analyzed and manipulated artifacts from the physical
    world of sounds and images. We’ve explored a variety of tools from packages for
    signal and image processing, but also found that the power of Julia’s facilities
    for array manipulation make difficult jobs easy, allowing us to write short and
    simple programs that perform complex tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation for `SignalAnalysis.jl` is available at [*https://org-arl.github.io/SignalAnalysis.jl/stable/*](https://org-arl.github.io/SignalAnalysis.jl/stable/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For details about the WAV file format, visit [*https://docs.fileformat.com/audio/wav/*](https://docs.fileformat.com/audio/wav/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JuliaImages is a starting place to find various image processing packages for
    Julia and their documentation: [*https://juliaimages.org/stable*](https://juliaimages.org/stable).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For some background about the Hough transform, start with [*https://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm*](https://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cartesian indices . . . what are they good for? Tim Holy explains: [*https://julialang.org/blog/2016/02/iteration/*](https://julialang.org/blog/2016/02/iteration/).
    This article inspired the image reduction used in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
