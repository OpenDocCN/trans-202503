<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="appE">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_971" aria-label="971"/>&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="appE">&#13;
<span class="APN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">E</span></span>&#13;
<span class="APT"><span class="SANS_Dogma_OT_Bold_B_11">USEFUL C LANGUAGE FUNCTIONS</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="378" height="378"/>&#13;
</figure>&#13;
<p class="ChapterIntro">This appendix contains a list of several C functions from the C stdlib (and Unix system library) that may be useful to assembly language programmers.</p>&#13;
<p class="TX">The macOS variants of these functions use an external name that begins with an underscore. For example, under macOS, <span class="SANS_TheSansMonoCd_W5Regular_11">strlen()</span> becomes the <span class="SANS_TheSansMonoCd_W5Regular_11">_strlen()</span> function. The <i>aoaa.inc</i> header file contains <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statements for many of these function names that add the underscore prefix in front of the unadorned names: <span class="SANS_TheSansMonoCd_W5Regular_11">#define strlen _strlen</span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_972" aria-label="972"/>&#13;
<h2 class="H1" id="sec1"><span id="h1-178"/><span class="SANS_Futura_Std_Bold_B_11">E.1 String Functions</span></h2>&#13;
<p class="TNI1">Various chapters in this book have introduced many of the C stdlib string functions (declared in the <i>strings.h</i> header file). This section describes most of the available functions, including those this book has not used:</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">char *strcat(char *dest, const char *src);</span></p>&#13;
<p class="ListPlain">Concatenates the zero-terminated string at which X1 (<span class="SANS_TheSansMonoCd_W5Regular_11">src</span>) points to the end of the string at which X0 (<span class="SANS_TheSansMonoCd_W5Regular_11">dest</span>) points. Returns a pointer to the <span class="SANS_TheSansMonoCd_W5Regular_11">dest</span> string in X0.</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">char *strchr(const char *str, int c);</span></p>&#13;
<p class="ListPlain">Searches for the first occurrence of the character specified by <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> (X1) in the string at which <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> (X0) points. Returns a pointer into the string (in X0) where the character was found, or a NULL (<span class="SANS_TheSansMonoCd_W5Regular_11">0</span>) pointer if <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> does not exist in <span class="SANS_TheSansMonoCd_W5Regular_11">str</span>.</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">char *strcpy(char *dest, const char *src);</span></p>&#13;
<p class="ListPlain">Copies the string pointed at by <span class="SANS_TheSansMonoCd_W5Regular_11">src</span> (X1) to <span class="SANS_TheSansMonoCd_W5Regular_11">dest</span> (X0), including the zero-terminating byte. Returns a pointer to <span class="SANS_TheSansMonoCd_W5Regular_11">dest</span> in X0.</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">char *strdup(char *str);</span></p>&#13;
<p class="ListPlain">Duplicates a string on the heap. On entry, X0 contains a pointer to the string to duplicate. On return, X0 contains a pointer to a copy of the string allocated on the heap. When the application is done using the string, the application should call the C stdlib <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span> function to return the storage to the heap. Though <span class="SANS_TheSansMonoCd_W5Regular_11">strdup()</span> is not defined in the C stdlib, most systems include it in their libraries.</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">char *strncat(char *dest, const char *src, size_t n);</span></p>&#13;
<p class="ListPlain">Concatenates at most <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> characters from the zero-terminated string at which X1 (<span class="SANS_TheSansMonoCd_W5Regular_11">src</span>) points to the end of the string at which X0 (<span class="SANS_TheSansMonoCd_W5Regular_11">dest</span>) points, plus a zero-terminating byte. Returns a pointer to the <span class="SANS_TheSansMonoCd_W5Regular_11">dest</span> string in X0. If the length of <span class="SANS_TheSansMonoCd_W5Regular_11">src</span> is less than <span class="SANS_TheSansMonoCd_W5Regular_11">n</span>, this string copies only the first <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> characters from <span class="SANS_TheSansMonoCd_W5Regular_11">src</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">dest</span> (plus a zero-terminating byte).</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">char *strpbrk(const char *str1, const char *str2);</span></p>&#13;
<p class="ListPlain">Finds the first character in the string <span class="SANS_TheSansMonoCd_W5Regular_11">str1</span> (passed in X0) that matches any character specified in <span class="SANS_TheSansMonoCd_W5Regular_11">str2</span> (passed in X1). Returns a pointer to the matching character in <span class="SANS_TheSansMonoCd_W5Regular_11">str1</span> in the X0 register (or <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> if no match).</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">char *strrchr(const char *str, int c);</span></p>&#13;
<p class="ListPlain">Searches for the last occurrence of the character <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> (a char passed in X1) in the string pointed to by the argument <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> (passed in X0). Returns a pointer into <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> where the character was found in X0. If the character was not found in <span class="SANS_TheSansMonoCd_W5Regular_11">str</span>, this function returns NULL (<span class="SANS_TheSansMonoCd_W5Regular_11">0</span>) in X0.</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">char *strstr(const char *inStr, const char *search4);</span></p>&#13;
<p class="ListPlain">Searches for the first occurrence of the string <span class="SANS_TheSansMonoCd_W5Regular_11">search4</span> (passed in X1) within <span class="SANS_TheSansMonoCd_W5Regular_11">inStr</span> (passed in X0). It returns a pointer to the matching <span role="doc-pagebreak" epub:type="pagebreak" id="pg_973" aria-label="973"/>position in the X0 register, returning NULL (<span class="SANS_TheSansMonoCd_W5Regular_11">0</span>) if the <span class="SANS_TheSansMonoCd_W5Regular_11">search4</span> string is not present within <span class="SANS_TheSansMonoCd_W5Regular_11">inStr</span>.</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">char *strtok(char *str, char *delim);</span></p>&#13;
<p class="ListPlain">Breaks string <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> (passed in X0) into a series of <i>tokens</i> (words) separated by characters found in the <span class="SANS_TheSansMonoCd_W5Regular_11">delim</span> (passed in X1) string. On a first call, the function expects a C string as an argument for <span class="SANS_TheSansMonoCd_W5Regular_11">str</span>, whose first character is used as the starting location to scan for tokens. In subsequent calls, the function expects a NULL (<span class="SANS_TheSansMonoCd_W5Regular_11">0</span>) pointer and uses the position right after the end of the last token as the new starting location for scanning (skipping any leading delimiter characters). Each call returns a pointer (in X0) to the next token within the string. This function returns NULL when it exhausts all the tokens in the string.</p>&#13;
<p class="ListPlain">This function modifies the contents of the string at which <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> (X0) points. If your program cannot tolerate this, make a copy of <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> before calling <span class="SANS_TheSansMonoCd_W5Regular_11">strtok()</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">strtok()</span> function maintains internal state in a static variable and therefore is not safe to use in multithreaded applications.</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">int memcmp(void *mem1, void *mem2, size_t n);</span></p>&#13;
<p class="ListPlain">Compares the first <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> bytes of <span class="SANS_TheSansMonoCd_W5Regular_11">mem1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">mem2</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">mem1</span> is passed in X0, <span class="SANS_TheSansMonoCd_W5Regular_11">mem2</span> is passed in X1, and <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> is passed in X2). Similar in operation to <span class="SANS_TheSansMonoCd_W5Regular_11">strcmp()</span>, except that this function doesn’t end the comparison upon encountering a 0 byte; <span class="SANS_TheSansMonoCd_W5Regular_11">strcmp()</span>, on the other hand, returns a negative value, 0, or a positive value to indicate the comparison status.</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">int strcasecmp(const char *str1, const char *str2);</span></p>&#13;
<p class="ListPlain">Compares the string at which <span class="SANS_TheSansMonoCd_W5Regular_11">str1</span> (X0) points against the string at which <span class="SANS_TheSansMonoCd_W5Regular_11">str2</span> (X1) points using a case-insensitive comparison. Returns (in X0) a negative number if <span class="SANS_TheSansMonoCd_W5Regular_11">str1</span> &lt; <span class="SANS_TheSansMonoCd_W5Regular_11">str2</span>, 0 if <span class="SANS_TheSansMonoCd_W5Regular_11">str1</span> == <span class="SANS_TheSansMonoCd_W5Regular_11">str2</span>, or a positive number if <span class="SANS_TheSansMonoCd_W5Regular_11">str1</span> &gt; <span class="SANS_TheSansMonoCd_W5Regular_11">str2</span>. Though <span class="SANS_TheSansMonoCd_W5Regular_11">strcasecmp()</span> is not defined in the C stdlib, many systems include it in their libraries; some use the function name <span class="SANS_TheSansMonoCd_W5Regular_11">strcmpi()</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">stricmp()</span> instead.</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">int strcmp(const char *str1, const char *str2);</span></p>&#13;
<p class="ListPlain">Compares the string at which <span class="SANS_TheSansMonoCd_W5Regular_11">str1</span> (X0) points against the string at which <span class="SANS_TheSansMonoCd_W5Regular_11">str2</span> (X1) points and returns (in X0) a negative number if <span class="SANS_TheSansMonoCd_W5Regular_11">str1</span> &lt; <span class="SANS_TheSansMonoCd_W5Regular_11">str2</span>, 0 if <span class="SANS_TheSansMonoCd_W5Regular_11">str1</span> == <span class="SANS_TheSansMonoCd_W5Regular_11">str2</span>, or a positive number if <span class="SANS_TheSansMonoCd_W5Regular_11">str1</span> &gt; <span class="SANS_TheSansMonoCd_W5Regular_11">str2</span>.</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">int strncmp(char *str1, char *str2, size_t n);</span></p>&#13;
<p class="ListPlain">Compares two strings up to the first <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> characters, or until encountering the first zero-terminating byte (in either string). Pointer to <span class="SANS_TheSansMonoCd_W5Regular_11">str1</span> is passed in X0, pointer to <span class="SANS_TheSansMonoCd_W5Regular_11">str2</span> is passed in X1, and <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> is passed in X2. Returns 0 if the strings were equal (through <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> characters, or less if both strings are equal and their length is less than <span class="SANS_TheSansMonoCd_W5Regular_11">n</span>). Returns a negative value if <span class="SANS_TheSansMonoCd_W5Regular_11">str1</span> is less than <span class="SANS_TheSansMonoCd_W5Regular_11">str2</span>. Returns a positive value if <span class="SANS_TheSansMonoCd_W5Regular_11">str1</span> is greater than <span class="SANS_TheSansMonoCd_W5Regular_11">str2</span>. You can use this function to see if <span class="SANS_TheSansMonoCd_W5Regular_11">str1</span> is a prefix of <span class="SANS_TheSansMonoCd_W5Regular_11">str2</span> by setting <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> equal to the length of <span class="SANS_TheSansMonoCd_W5Regular_11">str1</span>.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_974" aria-label="974"/><span class="SANS_TheSansMonoCd_W7Bold_11">size_t strcspn(const char *str1, const char *str2);</span></p>&#13;
<p class="ListPlain">Calculates the length of the initial segment of <span class="SANS_TheSansMonoCd_W5Regular_11">str1</span> (passed in X0), which consists entirely of characters not in <span class="SANS_TheSansMonoCd_W5Regular_11">str2</span> (passed in X1). Returns this count in X0.</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">size_t strlen(char *str);</span></p>&#13;
<p class="ListPlain">Computes the length of a zero-terminated string. X0 contains a pointer to the string upon entry, and this function returns the string length in X0 (not including the zero-terminating byte).</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">size_t strspn(const char *str1, const char *str2);</span></p>&#13;
<p class="ListPlain">Calculates the length of the initial segment of <span class="SANS_TheSansMonoCd_W5Regular_11">str1</span> (passed in X0), which consists entirely of characters in <span class="SANS_TheSansMonoCd_W5Regular_11">str2</span> (passed in X1). Returns the count in X0.</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">strlwr(str);</span></p>&#13;
<p class="ListPlain">Converts all the characters in a string to lowercase. On entry, X0 contains a pointer to the string to convert; on return, X0 points at this same string with the uppercase characters converted to lowercase. Though <span class="SANS_TheSansMonoCd_W5Regular_11">strlwr()</span> is not defined in the C stdlib, many systems include it in their libraries.</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">strncpy(char *dest, const char *src, size_t n);</span></p>&#13;
<p class="ListPlain">Copies, at most, <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> (passed in X2) characters from <span class="SANS_TheSansMonoCd_W5Regular_11">src</span> (passed in X1) to <span class="SANS_TheSansMonoCd_W5Regular_11">dest</span> (passed in X0). If <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> is less than or equal to the length of <span class="SANS_TheSansMonoCd_W5Regular_11">src</span>, this function will not copy the zero-terminating byte, and the caller is responsible for adding this extra byte. This function has two primary uses. First, it prevents overwriting data beyond the end of <span class="SANS_TheSansMonoCd_W5Regular_11">dest</span> (when <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> contains the size of the <span class="SANS_TheSansMonoCd_W5Regular_11">dest</span> buffer, plus 1, at which X0 points). Second, it serves as a substring function, allowing you to extract <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> characters from a particular position within a string.</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">strupr(str);</span></p>&#13;
<p class="ListPlain">Converts all lowercase characters in a string to uppercase. On entry, X0 contains a pointer to the string to convert; on return, X0 points at this same string with the lowercase characters converted to uppercase. Though <span class="SANS_TheSansMonoCd_W5Regular_11">strupr()</span> is not defined in the C stdlib, many systems include it in their libraries.</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">void *memchr(void *mem, int c, size_t n);</span></p>&#13;
<p class="ListPlain">Searches for the first occurrence of the character <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> (an unsigned char passed in X1) in the first <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> (passed in X2) bytes of the memory block at which the argument <span class="SANS_TheSansMonoCd_W5Regular_11">mem</span> (passed in X0) points. Very similar to <span class="SANS_TheSansMonoCd_W5Regular_11">strchr()</span>, except this function will not stop scanning when it finds a 0 byte in <span class="SANS_TheSansMonoCd_W5Regular_11">str</span>. Returns, in X0, a pointer into <span class="SANS_TheSansMonoCd_W5Regular_11">mem</span> where it found the character, or NULL (<span class="SANS_TheSansMonoCd_W5Regular_11">0</span>) if character <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> does not exist in <span class="SANS_TheSansMonoCd_W5Regular_11">mem</span>.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_975" aria-label="975"/><span class="SANS_TheSansMonoCd_W7Bold_11">void *memcpy(void *dest, const void *src, size_t n);</span></p>&#13;
<p class="ListPlain">Copies <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> bytes from <span class="SANS_TheSansMonoCd_W5Regular_11">src</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">dest</span> (passed in X2, X1, and X0, respectively). Returns a pointer to <span class="SANS_TheSansMonoCd_W5Regular_11">dest</span> in X0. If the memory block defined by <span class="SANS_TheSansMonoCd_W5Regular_11">dest</span> overlaps the memory block defined by <span class="SANS_TheSansMonoCd_W5Regular_11">src</span>, the results are undefined.</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">void *memmove(void *dest, const void *src, size_t n);</span></p>&#13;
<p class="ListPlain">Copies <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> bytes from <span class="SANS_TheSansMonoCd_W5Regular_11">src</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">dest</span> (passed in X2, X1, and X0, respectively). Returns a pointer to <span class="SANS_TheSansMonoCd_W5Regular_11">dest</span> in X0.</p>&#13;
<p class="ListPlain">The <span class="SANS_TheSansMonoCd_W5Regular_11">memmove()</span> function correctly handles situations in which the source and destination blocks overlap. However, this function may run a little bit slower than <span class="SANS_TheSansMonoCd_W5Regular_11">memcpy()</span>, so you should use it only when you cannot guarantee that the blocks do not overlap.</p>&#13;
<p class="ListHead"><span class="SANS_TheSansMonoCd_W7Bold_11">void *memset(void *mem, int c, size_t n);</span></p>&#13;
<p class="ListPlain">Copies the LO byte of <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> (passed in X1) to the first <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> (passed in X2) bytes of the memory block at which the argument <span class="SANS_TheSansMonoCd_W5Regular_11">mem</span> (passed in X0) points. Returns a pointer to the memory block in X0.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h2 class="H1" id="sec2"><span id="h1-179"/><span class="SANS_Futura_Std_Bold_B_11">E.2 Other C Stdlib and Unix Functions</span></h2>&#13;
<p class="TNI1">The string functions covered in this appendix are but a small sampling of the many functions available in the C stdlib. Other useful functions include the POSIX file I/O functions (declared in the <i>fcntl.h</i> and <i>unistd.h</i> header files), the math libraries (found in <i>math.h</i>), and many others. For more information on these header files, see the following:</p>&#13;
<p class="ListHead"><b><i>fcntl.h</i></b></p>&#13;
<p class="ListPlainFirst"><i><a href="https://pubs.opengroup.org/onlinepubs/000095399/basedefs/fcntl.h.html">https://<wbr/>pubs<wbr/>.opengroup<wbr/>.org<wbr/>/onlinepubs<wbr/>/000095399<wbr/>/basedefs<wbr/>/fcntl<wbr/>.h<wbr/>.html</a></i></p>&#13;
<p class="ListHead"><b><i>math.h</i></b></p>&#13;
<p class="ListPlainFirst"><i><a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/math.h.html">https://<wbr/>pubs<wbr/>.opengroup<wbr/>.org<wbr/>/onlinepubs<wbr/>/9699919799<wbr/>/basedefs<wbr/>/math<wbr/>.h<wbr/>.html</a></i></p>&#13;
<p class="ListHead"><b><i>unistd.h</i></b></p>&#13;
<p class="ListPlainFirst"><i><a href="https://pubs.opengroup.org/onlinepubs/007908775/xsh/unistd.h.html">https://<wbr/>pubs<wbr/>.opengroup<wbr/>.org<wbr/>/onlinepubs<wbr/>/007908775<wbr/>/xsh<wbr/>/unistd<wbr/>.h<wbr/>.html</a></i></p>&#13;
<p class="TX">You can easily call each of these functions by specifying its name (don’t forget to prepend an underscore when calling functions in macOS). You always pass parameters and retrieve function results by using the ARM ABI for Linux and the macOS ABI under macOS (remember that macOS differs when passing variable argument lists to a function, such as <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span>).</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>