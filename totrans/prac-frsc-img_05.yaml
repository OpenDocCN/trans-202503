- en: '**4**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PLANNING AND PREPARATION**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter describes the preparatory steps performed prior to imaging a disk
    or storage medium. These include setting up an audit trail of investigator activity,
    saving output for reports, and deciding on naming conventions. In addition, I
    describe various logistical challenges involved in the forensic acquisition of
    storage media and how to establish a protected write-blocking environment.
  prefs: []
  type: TYPE_NORMAL
- en: The subject of forensic readiness overlaps somewhat with the sections in this
    chapter. However, forensic readiness is a broader topic that includes general
    planning, budgeting, lab infrastructure, staff training, hardware and software
    purchasing, and so on. If you consider the preceding requirements needed as “macro”
    forensic readiness, you can consider the information in this chapter as “micro”
    forensic readiness. The focus is narrower and includes setting up a forensic examiner’s
    workstation environment and the tools and individual tasks needed to analyze a
    disk or storage media.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that forensic readiness in a private sector organization
    (in a corporate forensic lab, for example) is different from forensic readiness
    in some public sector organizations, such as law enforcement agencies. Private
    sector organizations, especially large corporate IT environments, can dictate
    how their IT infrastructure is built and operated. Forensic readiness in this
    controlled environment can be built into the IT infrastructure, providing advantages
    for a forensic examiner in the event of an investigation or incident. This chapter
    focuses on preparatory forensic tasks, which the private sector and public sector
    have in common.
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintain an Audit Trail**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An audit trail or log maintains a historical record of actions, events, and
    tasks. It can have various levels of detail and can be either manual or automated.
    This section covers several command line methods for manually tracking tasks as
    well as automated logging of command line activity.
  prefs: []
  type: TYPE_NORMAL
- en: '***Task Management***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: During a forensic examination, it’s beneficial to keep a high-level log of pending
    and completed activity. Pending tasks turn into completed tasks, and completed
    tasks make up the examination’s historical record. Often while working, you’ll
    think of a task that you need to address sometime in the future or a task you’ve
    completed and should note. Making quick notes and more comprehensive task lists
    becomes increasingly valuable as the length of the examination grows (possibly
    to many hours, days, or longer) or when more than one examiner is involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maintaining a list of pending and completed tasks during an examination is
    important for a number of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: • Helps ensure nothing was forgotten
  prefs: []
  type: TYPE_NORMAL
- en: • Avoids duplicating work already done
  prefs: []
  type: TYPE_NORMAL
- en: • Improves collaboration and coordination when working in teams
  prefs: []
  type: TYPE_NORMAL
- en: • Shows compliance with policies and procedures
  prefs: []
  type: TYPE_NORMAL
- en: • Facilitates accounting, including billing
  prefs: []
  type: TYPE_NORMAL
- en: • Helps produce documentation and reports (formal incident reports or forensic
    reports)
  prefs: []
  type: TYPE_NORMAL
- en: • Allows for post-incident review to identify lessons learned and support process
    optimization
  prefs: []
  type: TYPE_NORMAL
- en: • Helps to maintain a longer-term historical record of completed activity
  prefs: []
  type: TYPE_NORMAL
- en: • Supports learning and education for new team members
  prefs: []
  type: TYPE_NORMAL
- en: • Serves as a guide to remember complex procedures
  prefs: []
  type: TYPE_NORMAL
- en: • Provides information for troubleshooting problems and getting support
  prefs: []
  type: TYPE_NORMAL
- en: • Maintains a record of work done by external and third-party examiners
  prefs: []
  type: TYPE_NORMAL
- en: Many commercial task managers and investigation management tools are available,
    but the focus in this section is on simple task management that you can do from
    the command line. Using the command line permits you to quickly track tasks and
    activity without leaving the terminal to access some other graphical or web-based
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Many open source command line task managers are available and can be used to
    manage a forensic examiner’s activity. The most important criteria include reliable
    task recording and a detailed timestamp (not just dates).
  prefs: []
  type: TYPE_NORMAL
- en: '**Taskwarrior**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Taskwarrior is a popular task manager with many features for managing large
    task lists in a quick and efficient manner. You’ll find more information about
    Taskwarrior at *[http://taskwarrior.org/](http://taskwarrior.org/)*. The following
    examples show Taskwarrior commands in practical use in a forensic lab context.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add several pending tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To list the current task list (`task info` will show times and more detailed
    information):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete a task on the task list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To log a completed task without placing it on the task list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Taskwarrior is useful for managing large numbers of tasks. It provides reports,
    searching, sorting, and various levels of customizable detail. Taskwarrior maintains
    timestamps and unique identifiers (UUID) for each task, manages prioritization
    of pending tasks, and keeps a history of completed tasks. The ability to create
    user-defined attributes makes it customizable for specific settings, such as a
    forensics lab or examination process.
  prefs: []
  type: TYPE_NORMAL
- en: '**Todo.txt**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can also maintain a list of completed tasks and pending work by editing
    a simple text file. An example is the *todo.txt* file format by Gina Trapani (see
    *[http://todotxt.com/](http://todotxt.com/)* for more information). The *todo.txt*
    system defines a file format for task creation and completion dates, priorities,
    projects, and contexts. It also provides a shell script to manage the *todo.txt*
    file. Although the `todo.sh` script performs all the necessary operations on the
    *todo.txt* task list, the file format can be managed using a regular text editor.
    The notation indicates priority with parentheses (`(A)`, `(B)`, and so on), context
    keywords with `@`, and project keywords with `+`. Completed tasks are prefixed
    with an `x`. Here is an example *todo.txt* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The *todo.txt* apps don’t use timestamps, only dates. If you use this system,
    you must manually include the time with the completed task.
  prefs: []
  type: TYPE_NORMAL
- en: '**Shell Alias**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can also maintain an examiner activity log of completed tasks without the
    use of task management software. For example, here is a simple shell alias that
    redirects a short description into a file with a timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can customize the log filename and date format as desired. Making a quick
    note of activity or viewing past activity takes a simple one-line command, which
    you can enter anytime during the examination process. When something significant
    or notable occurs, enter `log` followed by the short description of the action
    taken. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Simple systems for managing tasks are useful for staff who spend much of their
    time working on the command line. They are also advantageous for remotely working
    on systems with secure shell (ssh).
  prefs: []
  type: TYPE_NORMAL
- en: '***Shell History***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section discusses how to set up automated logging of shell commands entered
    by the examiner on the command line. Ideally, this command logging should not
    increase complexity or interfere with the forensic work in progress. Using various
    tools, you can log the examiner’s command line activity with automated background
    processes. This approach is completely transparent to the examiner during the
    course of a forensic investigation.
  prefs: []
  type: TYPE_NORMAL
- en: The Unix/Linux shell was not originally designed with logging or audit trails
    in mind. In the past, patches have been created to augment the history mechanism,
    hacks have attempted to capture commands as the shell is used, and commercial
    products have performed various enterprise logging. Developing a robust auditing
    and compliance system to log all commands with timestamps, including shell builtins
    as well as executed programs and pipelines, is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Bash shell history can be configured to satisfy the following basic requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: • Record the command entered by the examiner
  prefs: []
  type: TYPE_NORMAL
- en: • Record a timestamp for each command entered
  prefs: []
  type: TYPE_NORMAL
- en: • Record all commands, including duplicates, comments, and space-prefixed commands
  prefs: []
  type: TYPE_NORMAL
- en: • Avoid truncating or overwriting history files
  prefs: []
  type: TYPE_NORMAL
- en: • Avoid conflicts when using multiple terminal windows on the same system
  prefs: []
  type: TYPE_NORMAL
- en: • Include root and non-root command history
  prefs: []
  type: TYPE_NORMAL
- en: 'Using basic Bash shell history as an audit trail is rudimentary. Important
    information, such as the command completion time, the working directory where
    the command was executed, and the return code, are not logged. The Bash history
    is also not a tamper-resistant system: the examiner can easily modify or delete
    the history. Creating a secure and tamper-resistant audit environment with restricted
    access is beyond the scope of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Some shells, such as zsh, have additional history features that allow for the
    logging of elapsed time. Other proposed solutions to improve shell logging include
    the use of `PS1`, `PROMPT_COMMAND`, `trap` and `DEBUG`, and `key` bindings to
    modify a command before executing. Using `sudo` logging; `auditd` logging; or
    special scripts, such as `preexec.sh`, can also increase command line logging.
    A useful tutorial at *[http://www.pointsoftware.ch/en/howto-bash-audit-command-logger/](http://www.pointsoftware.ch/en/howto-bash-audit-command-logger/)*
    discusses this problem at length and proposes a solution. The command line audit
    trail should be tailored to particular lab policies or expectations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For basic shell command logging, the built-in shell history functionality can
    be configured to record command line activity. Bash provides some useful functionality,
    including the ability to enable the time stamping of the commands entered. You
    can add the following commands to the Linux startup scripts (`.bashrc` and so
    on) to enable the basic requirements outlined in the previous list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: These commands ensure that history is enabled and in append mode (as opposed
    to overwriting with each new login). The two variables `HISTCONTROL` and `HISTIGNORE`
    control which commands are saved to the history file. A common default setting
    is to ignore duplicates and commands beginning with a space. To ensure complete
    logging of all commands, the `HISTCONTROL` and `HISTIGNORE` variables are explicitly
    set to null. The `HISTFILE` variable is explicitly set to ensure command history
    held in memory is saved when a shell exits. `HISTFILESIZE` and `HISTSIZE` are
    set to `-1` to ensure history is not truncated or overwritten. The `HISTTIMEFORMAT`
    variable enables timestamps to be written to the history file and allows you to
    set a time format. The format can include regional settings and should include
    a timestamp, not just the date.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the examination, the history can be saved to a text file and
    included in the examination’s supporting data files. The history can then be reset
    and made ready for the next examination by using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Synchronizing the history across multiple shell instances can be tricky because
    each shell keeps its history in memory and writes it to the history file only
    on exit. Setting the variable `PROMPT_COMMAND='history -a; history -r'` will write
    (append) and read new commands from the Bash history file every time the command
    prompt is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A command logger that is actively developed is Snoopy: it provides a number
    of features, including logging the commands to syslog. Snoopy is a preloaded library
    that functions as a wrapper around the `execv()` and `execve()` system calls.
    It is transparent to users, and you can enable and configure it by adding the
    Snoopy library to */etc/ld.so.preload* and editing the */etc/snoopy.ini* file.
    For example, suppose the following series of commands are entered on the Bash
    command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands are individually logged to syslog with various details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You’ll find more information and the latest release of Snoopy at *[https://github.com/a2o/snoopy/](https://github.com/a2o/snoopy/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Terminal Recorders***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some cases, it might be useful to show the work done in the terminal, complete
    with command output (`stdout`), error messages (`stderr`), and other messages
    or activity visible in a terminal session. Several tools exist to capture session
    activity and even provide playback of the session.
  prefs: []
  type: TYPE_NORMAL
- en: The most well-known tool is script. In this example, script is started and the
    output appended to a file together with timing data for replay. After running
    `script`, you can execute any normal shell commands, and they’ll be saved for
    later viewing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When the recorded session is finished, enter `exit` or press CTRL-D. You can
    view the recording using the `scriptreplay` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Common issues that make this method challenging are the handling of control
    characters and events such as terminal resizing. Other TTY recorders and sniffers,
    such as ttyrec and termrec, are available with similar functionality and features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Terminal multiplexers, such as tmux and GNU screen, also provide some level
    of logging that can be useful in certain situations. With screen, you can set
    up logging for a detached session from within a session (CTRL-A followed by H).
    The tmux terminal multiplexer now supports logging by using the `pipe-pane` option,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '***Linux Auditing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Professional labs might want to implement more robust logging or an audit trail
    to satisfy stricter organizational policies or regulatory requirements. One possibility
    to achieve this is through auditd, a Linux audit package. Typically, this involves
    running the `auditd` daemon with *pam_tty_audit.so* configured as a pam module.
    You can review audit trail activity using the `aureport` command.
  prefs: []
  type: TYPE_NORMAL
- en: Using auditd provides several security advantages, especially when used with
    granular access control, such as `sudo`. Audit trails, in particular those logging
    to a central log host, can be made relatively tamper resistant, ensuring an increased
    level of integrity when recording examination work.
  prefs: []
  type: TYPE_NORMAL
- en: Comprehensive audit trails can record all TTY activity (including keystrokes),
    as well as monitor file access and many other events on a system. Setting up auditing
    and audit reporting can be a complex process, one beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find discussions of other solutions and hacks in various places, including
    *[http://www.pointsoftware.ch/en/howto-bash-audit-command-logger/](http://www.pointsoftware.ch/en/howto-bash-audit-command-logger/)*
    and *[http://whmcr.com/2011/10/14/auditd-logging-all-commands/](http://whmcr.com/2011/10/14/auditd-logging-all-commands/)*.
  prefs: []
  type: TYPE_NORMAL
- en: As of Bash version 4.1, a new feature allowing command history logging to syslog
    has been added (it may require recompilation to enable).
  prefs: []
  type: TYPE_NORMAL
- en: '**Organize Collected Evidence and Command Output**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When conducting a forensic examination on the command line, it’s common to save
    command output from various tools and utilities to files for future reference
    and reporting. You can do this by redirecting the output of commands to text files.
    Those files can be saved with the rest of the examination data collected. During
    the process of collecting and saving large amounts of evidence data, it is important
    to keep your file and directory structure organized and understandable. This section
    talks about various strategies to achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: '***Naming Conventions for Files and Directories***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To reduce confusion among all the files, directories, mount points, images,
    and other saved data collected during an examination, it’s best to follow a naming
    convention. Make it descriptive enough to be intuitive, but avoid redundancy in
    the wording and file extensions. Most important, make naming conventions consistent
    throughout an investigation or incident and across multiple incidents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Certain unique identifiers are associated with systems, storage media devices,
    and removable media. Such identifiers can be useful when deciding on a naming
    convention:'
  prefs: []
  type: TYPE_NORMAL
- en: • Company asset tag or inventory number for PCs
  prefs: []
  type: TYPE_NORMAL
- en: • Manufacturer serial number for disk drives
  prefs: []
  type: TYPE_NORMAL
- en: • 64-bit World Wide Name (WWN) for disk drives
  prefs: []
  type: TYPE_NORMAL
- en: • Block device UUID for filesystems and RAIDs
  prefs: []
  type: TYPE_NORMAL
- en: • Forensic hash value for disk drive images
  prefs: []
  type: TYPE_NORMAL
- en: • 48-bit MAC address for network interface cards (NICs)
  prefs: []
  type: TYPE_NORMAL
- en: • Forensic lab evidence number (possibly a sticker or tag on the drive)
  prefs: []
  type: TYPE_NORMAL
- en: • Forensic lab evidence bag number (evidence bag containing the disc)
  prefs: []
  type: TYPE_NORMAL
- en: Wherever sensible, start all numbering with 1, not 0\. Programmers and engineers
    have a tendency to start at 0, but people who read and review the examination
    reports may not have a technical background (lawyers, judges, managers, and so
    on) and expect numbering to start with 1.
  prefs: []
  type: TYPE_NORMAL
- en: Raw image files use the extension **.raw* throughout this book. The commonly
    used **.dd* extension implies that a dd tool was used, which might not be the
    case. The **.raw* extension describes the file accurately without associating
    it with the particular tool used to acquire the image.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, a raw image’s filename should link a forensic image to a unique attribute
    of the physical object. If a forensic format is used, this unique information
    can be embedded as metadata in the forensic image file. This allows you to associate
    a lone physical disk with an image and associate a lone image with a physical
    disk. The disk and the image then remain linked without any dependencies on surrounding
    context (directory names, evidence shelves, and so on). This establishes a chain
    of custody link between the physical and digital worlds.
  prefs: []
  type: TYPE_NORMAL
- en: If large numbers of disks are under analysis, possibly include a serial number
    in the image filename. You can include varying levels of detail in a filename.
    Although the filename *server12-slot3-seagate-3.5in-disk-500gb -SN12345ACBDEE.raw*
    is very descriptive, it might be too detailed and cumbersome to work with. A practical
    naming convention for many basic incidents could simply be the storage media type
    with a number, for example, *disk1*, *tape1*, *ssd1*, *stick1*, *card1*, *cdrom1*,
    *dvd1*, *bluray1*, *floppy1*, and so on. In some cases, using a short description
    of the disk and the serial number might be the most suitable approach, for example,
    *crucial-ssd -15030E69A241.raw*. Often, it’s helpful to create image names that
    exam-iners can easily discuss in conversation, such as, “We found the file on
    disk1.” Terms used in conversations, raw examination output, and final reports
    should have a consistent nomenclature.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re extracting files from disk images, archive files, or other compound
    images, add an underscore to the filename to indicate it has been extracted. This
    will prevent you and others from accidentally opening malware, HTML pages with
    tracking bugs, macros in Office documents, or other executables and scripts that
    might execute on opening. Some examples are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If an extracted file already ends with an underscore, add another one. An appended
    underscore make it obvious that a file has been extracted as evidence from a suspect
    drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re analyzing an extracted file, saving tool output, or making manual
    notes, create a text file with the original name and append *_.txt* to it. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The *_.txt* extension signifies that the text file contains notes, tool output,
    and results of forensic analysis work about the extracted file. The filename is
    associated with the file originally extracted from the image. The text file may
    contain bookmarks and examiner annotations that can be searched. Unless it’s otherwise
    clear where an extracted file came from (which disk, partition, and so on), it’s
    good practice to have such corresponding text files; they can also indicate why
    it was chosen for extraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'A file extension should always indicate the format of the content. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: • **.txt* can be opened and read using a text editor.
  prefs: []
  type: TYPE_NORMAL
- en: • **.raw* is a raw data dump (disk, memory, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: • **.pcap* is captured network traffic.
  prefs: []
  type: TYPE_NORMAL
- en: • **.db* is a database (possibly a Sleuth Kit file list).
  prefs: []
  type: TYPE_NORMAL
- en: • **.sfs* is a SquashFS evidence container.
  prefs: []
  type: TYPE_NORMAL
- en: • **.e01* and **.aff* are forensic formats.
  prefs: []
  type: TYPE_NORMAL
- en: Each case, incident, or investigation will have an associated physical storage
    media. Storage media will have a corresponding forensic image and associated output
    from various programs (hdparm, smartctl, and so on). Each forensic image will
    have associated output from various programs (mmls, fls, and so on), and each
    extracted file may have associated output from various programs (exif, objdump,
    and so on). A naming convention will help keep everything organized and allow
    the organizing system to scale as the investigation data grows.
  prefs: []
  type: TYPE_NORMAL
- en: How much information should be embedded into filenames and directory names?
    When is it more sensible to have a corresponding description text file with additional
    information? How should the corresponding file be associated with an image? Consider
    the following examples of two representations of the same incident.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of information embedded into filenames looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of that same information embedded into a directory structure looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For manually written notes, further descriptions, caveats, issues, and other
    random comments within a certain context, storing the information in simple *notes.txt*
    or *readme.txt* files within working directories can be useful. They can provide
    reminders, hints, or warnings for you or other examiners to read at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re noting web URLs that might pose a risk if opened, replace *http*
    with *hxxp* to prevent others from accidentally clicking them. Such links might
    take the user to malware, personal sites monitored by a suspect, sites with tracking
    bugs, or other content that should not be accessed without understanding the consequences.
  prefs: []
  type: TYPE_NORMAL
- en: '***Scalable Examination Directory Structure***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each incident, case, or investigation should have a single unique directory
    (for example, *case42*). All collected evidence, images, and analysis work should
    be contained within a hierarchy under that one root directory. As investigations
    scale, a well-planned directory structure can scale with it. Having a single directory
    is also practical when multiple forensic examiners are working on the same incident
    and sharing the directory structure. Be prepared to reorganize the directory structure
    if an incident grows in complexity. If a large number of files are being extracted
    for individual analysis, consider having an *export* directory (similar to EnCase).
  prefs: []
  type: TYPE_NORMAL
- en: Examinations often scale unexpectedly, and a forensic examination that starts
    with a single disk under suspicion might expand into a larger examination involving
    multiple PCs with many disks. For example, suppose someone reports strange or
    suspicious behavior of a PC or employee. A single disk is seized for examination.
    Preliminary examination results find a USB stick is also involved. It is found
    and examined, and a second PC is linked to the incident. That PC has two internal
    hard disks and DVD burner. Further search reveals a box of DVDs full of data hidden
    in a closet. Then it turns out that an external USB hard disk and a spare notebook
    in another building are also involved in the incident. The collected evidence
    has grown from a single hard disk to 16 storage media items. This hypothetical
    incident is not uncommon in large organizations. When preparing for an examination,
    expanded coverage should be anticipated. The naming convention should be designed
    to scale as the size of an investigation grows.
  prefs: []
  type: TYPE_NORMAL
- en: Some PCs are used by multiple people, and some people use multiple PCs. Notebooks
    are not necessarily bound to a physical location. Removable media can be shared
    and attached to multiple PCs and notebooks. Over long periods of time, PC hardware
    will change, offices may change, departments will experience staff turnover, and
    organizational restructuring may occur. Be sure to design file and directory names
    to accommodate these changes.
  prefs: []
  type: TYPE_NORMAL
- en: As an examination progresses, the number of output files will grow as more collected
    data is analyzed and output is produced. A good practice is to create a directory
    structure to separate the files and organize the output of the examination. As
    with filenames, the directory name should indicate the contents without revealing
    confidential information. Creating a separate directory for each disk or image
    analyzed segregates files and allows an investigation to scale up.
  prefs: []
  type: TYPE_NORMAL
- en: 'The smallest examination usually consists of a single disk. A slightly larger
    examination might consist of a PC containing multiple disks; consider the following
    example directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0080-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As another example, consider the examination of an entire workplace that consists
    of a desktop PC (possibly with multiple disks), a notebook, several USB drives,
    multiple CD-ROMs and DVDs, and an external disk pack. A convenient directory structure
    would organize each piece of storage media where the command output files are
    stored, allowing an examination to easily scale further. Consider a larger investigation
    consisting of multiple workplaces, across multiple office buildings, spread out
    across multiple countries. In large global organizations, such investigations
    can occur; therefore, having a well-thought-out naming convention will maintain
    the organization of the examination process.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s advantageous to rely on a directory structure to separate command output
    from different disks, PCs, users, and locations. As a result, you won’t need to
    embed this information into the output filenames. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0081-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, two office locations are US123 and UK567, in the United States
    and the United Kingdom, respectively. The US office is divided by user workplaces,
    and a directory is used for each piece of storage media under examination. The
    UK office PC is not associated with any particular user (possibly located in a
    meeting room), and this is reflected in the directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using an employee identifier for the storage media, an organization’s
    IT inventory number can be used for the storage media in the directory structure.
    This unique identifier will likely have additional information associated with
    it (date of purchase, department, office location, user details, software installed,
    history of use, and so on). Confidentiality reasons might require you to omit
    information from the filenames and directory structure. For example, names of
    suspected or targeted individuals should not be embedded into filenames. Rather,
    you should use an identifier, initials, or an employee number. Code names for
    investigations might also be used. They provide a minimal level of protection
    if the information is lost, stolen, or otherwise accessed at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: '***Save Command Output with Redirection***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After creating the directory structure to store the analysis results from various
    items under examination, typical shell command output is redirected into files
    from stdout as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To include regular output and error messages, you need to redirect stdout and
    stderr file descriptors to the file. Newer versions of Bash provide an easy-to-remember
    method by adding an ampersand to the redirection (this also applies when piping
    to another program):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Other shells and earlier Bash versions might require `2>&1` notation for combining
    stderr and stdin. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When a text file already exists and you need to add additional information
    to it, you can use the `>>` notation to specify an append operation. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, all instances of a known filename are added to the end of the *notes.txt*
    file.^([1](footnote.xhtml#fn17)) If *notes.txt* doesn’t exist, it will be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many forensic tasks performed on the command line are time-consuming and may
    take many hours to complete (disk imaging, performing operations on very large
    files, and so on). Having a timestamp indicating the duration of the command can
    be useful. The `time` command provides this functionality. There are two common
    implementations of the `time` command: one is a shell builtin with rudimentary
    features, and the other is a GNU utility with additional features. The primary
    advantage of the shell builtin `time` version is that it will time an entire pipeline
    of commands, whereas GNU `time` will only time the first command in a pipeline.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using the `time` command to run a disk-imaging program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The zsh shell can log the elapsed time of a command as part of the history file.
    This functionality is currently not available in Bash.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful command for some situations is the timestamp output command `ts`.
    Any output piped into `ts` will have a timestamp appended to each line of output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this example, three commands were executed (grouped together with parentheses)
    and the command outputs were sent to `ts`, creating a timeline.
  prefs: []
  type: TYPE_NORMAL
- en: '**Assess Acquisition Infrastructure Logistics**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Various logistical issues are important when performing forensic acquisition
    of storage media. Managing large acquired forensic images is not a trivial task
    and so requires planning and forethought. Factors such as disk capacity, time
    duration, performance, and environmental issues need to be considered.
  prefs: []
  type: TYPE_NORMAL
- en: '***Image Sizes and Disk Space Requirements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Forensic images of storage media are orders of magnitude larger than the small
    file sizes a PC typically handles. Managing disk image files of this size takes
    additional thought and planning. You also need to consider certain logistical
    factors when you’re preparing an examination system. Careful preparation and planning
    for an examination will save you time and effort, as well as help you avoid problems
    that might disrupt the process.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a forensic image of a disk (hundreds of gigabytes or tera-bytes),
    it is not files that are copied, but the individual disk sectors. If a 1TB disk
    has only a single 20K Microsoft Word document on it, an uncompressed forensic
    image will still be 1TB. As of this writing, 10TB disks are now on the market,
    increasing the challenge for performing forensic acquisition.
  prefs: []
  type: TYPE_NORMAL
- en: 'When managing disk images, the examiner’s time and the examiner host’s disk
    capacity are the main logistical factors that need to be considered. Before beginning
    a forensic acquisition of a subject disk or storage media, you need to ask a number
    of questions:'
  prefs: []
  type: TYPE_NORMAL
- en: • Can the attached storage be analyzed *in place* without taking a forensic
    image?
  prefs: []
  type: TYPE_NORMAL
- en: • What is the size of the subject disk?
  prefs: []
  type: TYPE_NORMAL
- en: • What is the available space on the examiner’s machine?
  prefs: []
  type: TYPE_NORMAL
- en: • What is the potential for image compression?
  prefs: []
  type: TYPE_NORMAL
- en: • How much space do forensic tools need for processing and temporary files?
  prefs: []
  type: TYPE_NORMAL
- en: • What is the estimated number of files to be extracted for further analysis?
  prefs: []
  type: TYPE_NORMAL
- en: • How much memory and swap space is available on the examiner’s machine?
  prefs: []
  type: TYPE_NORMAL
- en: • Is there a possibility of more subject disks being added to the same case
    or incident?
  prefs: []
  type: TYPE_NORMAL
- en: • Is there an expectation to separately extract all slack or unallocated disk
    space?
  prefs: []
  type: TYPE_NORMAL
- en: • Are there plans to extract individual partitions (possibly including swap)?
  prefs: []
  type: TYPE_NORMAL
- en: • Is there a potential need to convert from one forensic format to another?
  prefs: []
  type: TYPE_NORMAL
- en: • Do disk images need to be prepared for transport to another location?
  prefs: []
  type: TYPE_NORMAL
- en: • Do subject disks contain virtual machine images to separately extract and
    analyze?
  prefs: []
  type: TYPE_NORMAL
- en: • Do subject disks contain large numbers of compressed and archive files?
  prefs: []
  type: TYPE_NORMAL
- en: • Are subject disks using full-disk encryption?
  prefs: []
  type: TYPE_NORMAL
- en: • Is there a need to burn images to another disk or DVDs for storage or transport?
  prefs: []
  type: TYPE_NORMAL
- en: • Is there a need to carve files from a damaged or partially overwritten filesystem?
  prefs: []
  type: TYPE_NORMAL
- en: • How are backups of the examiner host performed?
  prefs: []
  type: TYPE_NORMAL
- en: In some situations, it may not be necessary to image a disk. When certain triage
    or cursory searching is conducted, it may be enough to attach the disk to an examiner
    host and operate on the live subject disk. Depending on the triage or search findings,
    you can decide whether or not to take a forensic image. In a corporate environment,
    this approach could translate into downtime for an employee, because they must
    wait for a seized disk to be reviewed or analyzed. Corporate environments typically
    have a standard end-user PC build, which is designed without local user data (all
    data is saved to servers or clouds). It could be more economical simply to swap
    the original disk with a new disk. End-user PC disks are cheap, and replacing
    a subject disk with a new one could be a cost-saving alternative when factoring
    in the cost of employee downtime and the time needed to image a disk in the field.
  prefs: []
  type: TYPE_NORMAL
- en: '***File Compression***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using compression solves a number of the capacity challenges faced by a forensic
    examiner. You can use a compressed forensic format to store the resulting acquired
    image, but the effectiveness depends on a number of factors.
  prefs: []
  type: TYPE_NORMAL
- en: The compression algorithms you choose will have some effect on the size and
    time needed to compress a subject disk. A better compression ratio will take more
    time to compress (and subsequently uncompress).
  prefs: []
  type: TYPE_NORMAL
- en: A relatively new PC disk that contains a large number of untouched disk sectors
    (original manufacturer’s zeroed contents) will compress better than an older disk
    containing significant amounts of residual data in the unallocated sectors.
  prefs: []
  type: TYPE_NORMAL
- en: Disks that contain large amounts of compressed files (**.mp3*, **.avi*, and
    so on) will not compress much further, and as a result, forensic imaging tools
    will benefit less from added compression.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypted subject disks or disks with large numbers of encrypted files will
    not compress as well as unencrypted content due to the data’s higher entropy level.
  prefs: []
  type: TYPE_NORMAL
- en: '***Sparse Files***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sparse files are worth mentioning because they have some advantages; however,
    they can also be problematic when calculating disk capacity. Some filesystems
    use metadata to represent a sequence of zeros in a file instead of actually writing
    all the zeros to the disk. Sparse files contain “holes” where a sequence of zeros
    is known to exist. To illustrate, a new drive containing mostly zeroed sectors
    is acquired with GNU dd,^([2](footnote.xhtml#fn18)) first as a regular raw file
    and then as a sparse file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The GNU `dd` command provides a `conv=sparse` flag that creates a sparse destination
    file. In these dd examples, you can see the number of blocks transferred is the
    same for both the normal and sparse files. In the following output, the file size
    and the MD5 hash are also identical. However, notice how the block size used on
    the filesystem is very different (7733252 blocks versus 2600 blocks):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Although the sparse file requires much less space, the full byte size is still
    reported as the file size. This can cause confusion when calculating the real
    available disk capacity. Sparse files are often used by VM images and can become
    an issue when extracted for analysis.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use sparse files as a method of compacting image files, but using
    compressed forensic formats or SquashFS containers is preferred and recommended.
    Not all programs and utilities can handle sparse files correctly, and the files
    can become problematic when moved between filesystems and platforms. Some programs
    may even expand sparse files when reading them.
  prefs: []
  type: TYPE_NORMAL
- en: '***Reported File and Image Sizes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Reporting data sizes is an important concept to grasp. When you’re working with
    forensic tools, size can refer to bytes, disk sectors, filesystem blocks, or other
    units of measurement. The notation for bytes can be prefixed with a multiplier
    (such as kilobytes, megabytes, gigabytes, terabytes, and so on), and the multiplier
    can refer to multiples of either 1000 or 1024\. Disk sectors could represent sector
    sizes of either 512 bytes or 4096 bytes. The filesystem block size depends on
    the type of filesystem and the parameters used during creation. When you’re documenting
    sizes in a forensic context, it’s important to always include descriptive units.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many Linux tools support the `-h` flag to report file sizes in a human readable
    form. For example, you can use `ls -lh`, `df -h`, and `du -h` to more easily view
    the size of files and partitions. An example `ls` output with several file sizes
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The sizes in the second command’s output are much easier to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: '***Moving and Copying Forensic Images***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Moving and copying forensic disk images from one place to another requires planning
    and foresight. Don’t think of image files in the same way as typical end-user
    files (even though technically they’re the same).
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring, copying, and moving large disk images may take many hours or even
    days depending on the size and speed of the source disk and other performance
    factors. Consider the following list of typical file and disk image sizes and
    the average amount of time needed to copy the file from one disk to another disk:^([3](footnote.xhtml#fn19))
  prefs: []
  type: TYPE_NORMAL
- en: '• 5KB simple ASCII text email: less than 1 second'
  prefs: []
  type: TYPE_NORMAL
- en: '• 5MB typical MP3 music file: less than 1 second'
  prefs: []
  type: TYPE_NORMAL
- en: '• 650MB CD ISO image: about 5 seconds'
  prefs: []
  type: TYPE_NORMAL
- en: '• 5–6GB typical DVD or iTunes movie download: about 1 minute'
  prefs: []
  type: TYPE_NORMAL
- en: '• 64GB common mobile phone image: about 10 minutes'
  prefs: []
  type: TYPE_NORMAL
- en: '• 250GB common notebook disk image: 30-40 minutes'
  prefs: []
  type: TYPE_NORMAL
- en: '• 1TB typical desktop PC image: more than 2 hours'
  prefs: []
  type: TYPE_NORMAL
- en: '• 2TB typical external USB disk image: more than 4 hours'
  prefs: []
  type: TYPE_NORMAL
- en: '• 8TB internal disk image: more than 16 hours'
  prefs: []
  type: TYPE_NORMAL
- en: Once a copy or move process has been started, disrupting it could leave the
    data in an incomplete state or require additional time to revert to the original
    state. A copy or move operation could create temporary files or result in two
    copies of the images existing temporarily.
  prefs: []
  type: TYPE_NORMAL
- en: In general, think carefully beforehand about the copying and moving of large
    data sets, and don’t interrupt the process once it has started.
  prefs: []
  type: TYPE_NORMAL
- en: '***Estimate Task Completion Times***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The forensic acquisition process takes time to complete. During this time, people
    and other processes may be waiting. Therefore, it’s important to calculate and
    estimate the completion time needed for various processes. Also, determine whether
    you need to report estimated completion times to other parties, such as management,
    legal teams, law enforcement, or other investigators. It is important to manage
    expectations with regard to the time needed for completion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some important questions to consider include:'
  prefs: []
  type: TYPE_NORMAL
- en: • Can the acquisition be safely left running overnight while nobody is around?
  prefs: []
  type: TYPE_NORMAL
- en: • Is the examiner machine unusable during the acquisition process (for performance
    reasons or other reasons)?
  prefs: []
  type: TYPE_NORMAL
- en: • Can other examination work be done while the forensic image is being acquired?
  prefs: []
  type: TYPE_NORMAL
- en: • When can several tasks be completed in parallel?
  prefs: []
  type: TYPE_NORMAL
- en: • Are there certain tasks or processes that can only be done sequentially?
  prefs: []
  type: TYPE_NORMAL
- en: • Are there tasks that will block other tasks until they’re completed?
  prefs: []
  type: TYPE_NORMAL
- en: • Can the workload be shared, delegated, or distributed across multiple examiners?
  prefs: []
  type: TYPE_NORMAL
- en: You can calculate an estimated completion time for an acquisition. From previous
    work and processes, you should know the approximate initial setup time. This includes
    factors such as completing paperwork, creating necessary directory structure,
    documenting the hardware, attaching suspect drives to the examiner host, deciding
    on the approach for acquisition, and so on. This will give you a time estimate
    for the preacquisition phase.
  prefs: []
  type: TYPE_NORMAL
- en: You can calculate the expected storage media acquisition time based on the amount
    of data (known) passing through the slowest component in the system (the bottleneck).
  prefs: []
  type: TYPE_NORMAL
- en: '***Performance and Bottlenecks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To improve the efficiency of a forensic acquisition, you can optimally tune
    the examiner host and assess the bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: A performance bottleneck always occurs; this is simply the slowest component
    in the system, which all other components must wait for. In a forensic setting,
    the bottleneck should ideally be the subject disk. This is the evidence source
    and is the only performance variable that you can’t (or shouldn’t) modify.
  prefs: []
  type: TYPE_NORMAL
- en: You can assess the performance of various system components by reading the vendor
    specifications, querying the system with various tools, or running various benchmarking
    and measurement tests.
  prefs: []
  type: TYPE_NORMAL
- en: Useful tools to check the speed of various components include dmidecode, lshw,
    hdparm, and lsusb. Several command line examples are shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the CPU family and model, current and maximum speed, number of cores
    and threads, and other flags and characteristics, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a command to view the CPU’s cache (L1, L2, and L3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the memory, including slots used, size, data width, speed, and other
    details, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a command to view the number of PCI slots, usage, designation, and
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'A command to view the storage interfaces, type (SATA, NVME, SCSI, and so on),
    and speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the speed, interface, cache, rotation, and other information about
    the attached disks (using device */dev/sda* in this example), use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the speed of the external USB interfaces (and possibly an attached
    write blocker), use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*There are many different methods and commands to get this information. The
    commands shown here each present one example of getting the desired performance
    information. Providing an exhaustive list of all possible tools and techniques
    is beyond the scope of this book.*'
  prefs: []
  type: TYPE_NORMAL
- en: Reading the vendor documentation and querying a system will identify the speeds
    of various components. To get an accurate measurement, it’s best to use tools
    for hardware benchmarking and software profiling. Some tools for benchmarking
    include mbw for memory and bonnie++ for disk I/O.
  prefs: []
  type: TYPE_NORMAL
- en: The health and tuning of the OS is also a performance factor. Monitoring the
    logs (syslog, dmesg) of the examiner hardware can reveal error messages, misconfiguration,
    and other inefficiency indicators. Tools to monitor the performance and load of
    the live state of an examiner machine include htop, iostat, vmstat, free, or nmon.
  prefs: []
  type: TYPE_NORMAL
- en: You can also optimize the OS by ensuring minimal processes are running in the
    background (including scheduled processes via cron), tuning the kernel (`sysctl
    -a`), tuning the examiner host’s filesystems (`tunefs`), and managing disk swap
    and caching. In addition, ensure that the examiner OS is running on native hardware,
    not as a virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re looking for bottlenecks or optimizing, it’s helpful to imagine
    the flow of data from the subject disk to the examiner host’s disk. During an
    acquisition, the data flows through the following hardware interfaces and components:'
  prefs: []
  type: TYPE_NORMAL
- en: • Subject disk platters/media (rotation speed? latency?)
  prefs: []
  type: TYPE_NORMAL
- en: • Subject disk interface (SATA-X?)
  prefs: []
  type: TYPE_NORMAL
- en: • Write blocker logic (added latency?)
  prefs: []
  type: TYPE_NORMAL
- en: • Write blocker examiner host interface (USB3 with UASP?)
  prefs: []
  type: TYPE_NORMAL
- en: • Examiner host interface (USB3 sharing a bus with other devices? bridged?)
  prefs: []
  type: TYPE_NORMAL
- en: • PCI bus (PCI Express? speed?)
  prefs: []
  type: TYPE_NORMAL
- en: • CPU/memory and OS kernel (speed? DMA? data width?)
  prefs: []
  type: TYPE_NORMAL
- en: These components will be traversed twice, once between the subject disk and
    the examiner host, and again between the host and the examiner disk where the
    acquired image is being saved.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the data flow between the subject disk and the CPU/memory is not
    using the same path as for the data flow between the CPU/memory and the destination
    disk on the examiner host. For example, if a field imaging system has a write
    blocker and an external disk for the acquired image, and both are connected to
    local USB ports, it is possible they’re sharing a single bus. As a result, the
    available bandwidth will be split between the two disks, causing suboptimal performance.
  prefs: []
  type: TYPE_NORMAL
- en: For network performance tuning, the speed of the underlying network becomes
    a primary factor, and performance enhancements include the use of jumbo Ethernet
    frames and TCP checksum offloading with a high-performance network interface card.
    It is also beneficial to assess when various programs are accessing the network
    and for what reason (automatic updates, network backups, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, have an overall plan or strategy for the acquisition actions you
    intend to take. Have well-tested processes and infrastructure in place. Ensure
    that the right capacity planning and optimizing has been done. Be able to monitor
    the activity while it’s in progress.
  prefs: []
  type: TYPE_NORMAL
- en: The most common bus speeds relevant for a forensic examination host (in bytes/second)
    are listed in [Table 4-1](ch04.xhtml#ch4table1) for comparison. You’ll find a
    good reference of the bit rates for various interfaces and buses at *[https://en.wikipedia.org/wiki/List_of_device_bit_rates](https://en.wikipedia.org/wiki/List_of_device_bit_rates)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-1:** Common Bus/Interface Speeds'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bus/interface** | **Speed** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Internal buses |  |'
  prefs: []
  type: TYPE_TB
- en: '| PCI Express 3.0 x16 | 15750 MB/s |'
  prefs: []
  type: TYPE_TB
- en: '| PCI Express 3.0 x8 | 7880 MB/s |'
  prefs: []
  type: TYPE_TB
- en: '| PCI Express 3.0 x4 | 3934 MB/s |'
  prefs: []
  type: TYPE_TB
- en: '| PCI 64-bit/133MHz | 1067 MB/s |'
  prefs: []
  type: TYPE_TB
- en: '| Storage drives |  |'
  prefs: []
  type: TYPE_TB
- en: '| SAS4 | 2400 MB/s |'
  prefs: []
  type: TYPE_TB
- en: '| SAS3 | 1200 MB/s |'
  prefs: []
  type: TYPE_TB
- en: '| SATA3 | 600 MB/s |'
  prefs: []
  type: TYPE_TB
- en: '| SATA2 | 300 MB/s |'
  prefs: []
  type: TYPE_TB
- en: '| SATA1 | 150 MB/s |'
  prefs: []
  type: TYPE_TB
- en: '| External interfaces |  |'
  prefs: []
  type: TYPE_TB
- en: '| Thunderbolt3 | 5000 MB/s |'
  prefs: []
  type: TYPE_TB
- en: '| Thunderbolt2 | 2500 MB/s |'
  prefs: []
  type: TYPE_TB
- en: '| USB3.1 | 1250 MB/s |'
  prefs: []
  type: TYPE_TB
- en: '| USB3.0 | 625 MB/s |'
  prefs: []
  type: TYPE_TB
- en: '| GB Ethernet | 125 MB/s |'
  prefs: []
  type: TYPE_TB
- en: '| FW800 | 98 MB/s |'
  prefs: []
  type: TYPE_TB
- en: '| USB2 | 60 MB/s |'
  prefs: []
  type: TYPE_TB
- en: '***Heat and Environmental Factors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: During a forensic disk acquisition, every accessible sector on the disk is being
    read, and the reading of the disk is sustained and uninterrupted, often for many
    hours. As a result, disk operating temperatures can increase and cause issues.
    When disks become too hot, the risk of failure increases, especially with older
    disks. Researchers at Google have produced an informative paper on hard disk failure
    at *[http://research.google.com/archive/disk_failures.pdf](http://research.google.com/archive/disk_failures.pdf)*.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the risk of read errors, bad blocks, or total disk failure, it’s worthwhile
    to monitor the disk temperature while a disk is being acquired. Most disk vendors
    publish the normal operating temperatures for their drives, including the maximum
    acceptable operating temperature.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use several tools to manually query the temperature of a drive.
    A simple tool that queries the SMART interface for a drive’s temperature is hddtemp,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The hddtemp tool can be run as a daemon and periodically log to syslog, where
    you can monitor it for certain thresholds.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more detailed output on a disk’s temperature, and in some cases a temperature
    history, use the smartctl tool. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If a disk begins to overheat during a disk acquisition, take action to reduce
    the temperature. As an immediate step, temporarily suspend the acquisition process
    and continue it when the disk has cooled. Depending on the acquisition method
    you use, this could be a simple matter of sending a signal to the Linux process
    by pressing CTRL-Z or entering `kill -SIGTSTP` followed by a process id. When
    the temperature decreases to an acceptable level, the acquisition process can
    be resumed from the same place it was suspended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suspending and resuming a process in this way should not affect the forensic
    soundness of the acquisition. The process is suspended with its operational state
    intact (current sector, destination file, environment variables, and so on). An
    example of suspending and resuming an imaging process on the shell by pressing
    CTRL-Z looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here an executing `dcfldd` command is suspended by pressing CTRL-Z on the keyboard.
    Resume the process by using the `fg` command (foreground). The process can also
    be resumed with a `kill -SIGCONT` command. See the Bash documentation and the
    SIGNAL(7) manual page for more about job control and signals.
  prefs: []
  type: TYPE_NORMAL
- en: Using tools such as Nagios, Icinga, or other infrastructure-monitoring systems,
    you can automate temperature monitoring and alerting. Such systems monitor various
    environmental variables and provide alerts when critical thresholds are approached
    or exceeded.
  prefs: []
  type: TYPE_NORMAL
- en: Many forensic labs use heat sinks or disk coolers when imaging to reduce the
    problem of overheating subject disks. This is recommended during long acquisition
    sessions, especially when you’re working with older drives.
  prefs: []
  type: TYPE_NORMAL
- en: If you attempt to use certain power management techniques to reduce heat, they
    will be of little use. These methods work by spinning down the drive after a period
    of idle time; however, during a sustained imaging operation, there is little or
    no idle time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Establish Forensic Write-Blocking Protection**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A fundamental component of digital evidence collection is performing a forensically
    sound acquisition of storage media. You can achieve part of this goal^([4](footnote.xhtml#fn20))
    by ensuring that a write-blocking mechanism is in place before you attach the
    disk to the forensic acquisition host.
  prefs: []
  type: TYPE_NORMAL
- en: When you attach a disk to a PC running a modern OS, automated processes significantly
    increase the risk of data modification (and therefore evidence destruction). Attempts
    to automatically mount partitions, generate thumbnail images for display in graphical
    file managers, index for local search databases, scan with antivirus software,
    and more all put an attached drive at risk of modification. Timestamps might be
    updated, destroying potential evidence. Deleted files in unallocated parts of
    the disk might be overwritten, also destroying evidence. Discovered malware or
    viruses (the very evidence an investigator might be looking for) could be purged.
    Journaling filesystems could have queued changes in the journal log written to
    disk. There may be attempts to repair a broken filesystem or assemble/synchronize
    RAID components.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to automated potential destruction of evidence, human error poses
    another significant risk. People might accidentally copy or delete files; browse
    around the filesystem (and update last-accessed time-stamps); or mistakenly choose
    the wrong device, resulting in a destructive action.
  prefs: []
  type: TYPE_NORMAL
- en: Write blockers were designed to protect against unwanted data modification on
    storage media. Requiring the use of write blockers in a forensic lab’s standard
    processes and procedures demonstrates due diligence. It satisfies industry best
    practice for handling storage media as evidence in a digital forensic setting.
    Write blockers guarantee a read-only method of attaching storage media to an examiner’s
    workstation.
  prefs: []
  type: TYPE_NORMAL
- en: 'NIST Computer Forensic Tool Testing (CFTT) provides formal requirements for
    write blockers. The Hardware Write Block (HWB) Device Specification, Version 2.0
    is available at *[http://www.cftt.nist.gov/hardware_write_block.htm](http://www.cftt.nist.gov/hardware_write_block.htm)*.
    This specification identifies the following top-level tool requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: • An HWB device shall not transmit a command to a protected storage device that
    modifies the data on the storage device.
  prefs: []
  type: TYPE_NORMAL
- en: • An HWB device shall return the data requested by a read operation.
  prefs: []
  type: TYPE_NORMAL
- en: • An HWB device shall return without modification any access-significant information
    requested from the drive.
  prefs: []
  type: TYPE_NORMAL
- en: • Any error condition reported by the storage device to the HWB device shall
    be reported to the host.
  prefs: []
  type: TYPE_NORMAL
- en: Both hardware and software write blockers are available, as stand-alone hardware,
    installable software packages, or bootable forensic CDs. In some cases, media
    might have built-in read-only functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hardware Write Blockers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The preferred method of write blocking uses hardware devices situated between
    a subject disk and an examiner’s workstation. A hardware write blocker intercepts
    drive commands sent to the disk that might modify the data. A photograph of a
    portable write-blocking device protecting a SATA drive (Tableau by Guidance Software)
    is shown in [Figure 4-1](ch04.xhtml#ch4fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f04-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Portable SATA write blocker*'
  prefs: []
  type: TYPE_NORMAL
- en: Hardware write blockers usually have a switch or LED to indicate whether write
    blocking functionality is in operation. A photograph of a multifunctional write-blocking
    device designed to be built directly into the examiner workstation (Tableau by
    Guidance Software) is shown in [Figure 4-2](ch04.xhtml#ch4fig2). It can protect
    SATA, SAS, IDE, FireWire, and USB drives.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f04-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Multifunction drive bay write blocker*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write blockers can provide status information to the acquisition host system.
    An example is the tableau-parm tool (*[https://github.com/ecbftw/tableau-parm/](https://github.com/ecbftw/tableau-parm/)*),
    which can query the Tableau hardware write blocker for information. You can use
    this open source tool to verify the write-blocking status of a disk attached with
    a Tableau write blocker. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: According to Tableau’s documentation, the `drive_vendor` field may not contain
    any information for some drives.^([5](footnote.xhtml#fn21))
  prefs: []
  type: TYPE_NORMAL
- en: 'During the final stages of editing this book, the first PCI Express write blockers
    appeared on the market. An example is shown here from Tableau. Attaching an NVME
    drive using a PCI Express write blocker produces the following dmesg output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The write blocker operates as a USB3 bridge and makes the NVME drive available
    as a SCSI device. This particular write blocker supports PCI Express drives using
    both AHCI and NVME standards. The hardware interfaces supported are regular PCI
    Express slots ([Figure 4-3](ch04.xhtml#ch4fig3)) and M.2 ([Figure 4-4](ch04.xhtml#ch4fig4)).
    Standard adapters from mini-SAS to PCI Express or M.2 can be used to attach U.2
    (SFF-8639) NVME drives. PCI write blockers with NVME support are also available
    from Wiebetech.
  prefs: []
  type: TYPE_NORMAL
- en: The primary advantage of hardware-based write blockers is their OS independence.
    They operate transparently and separately from the acquisition host, eliminating
    the need to maintain drivers or OS compatibility. This makes them ideal for use
    in a Linux acquisition environment.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f04-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Write blocker dock for PCI Express slot drives*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f04-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: Multifunction write blocker and dock for PCI Express M.2 drives*'
  prefs: []
  type: TYPE_NORMAL
- en: Special thanks to Arina AG in Switzerland for providing the write blocker equipment
    used for test purposes in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '***Software Write Blockers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Software write blockers have a somewhat controversial history. They’ve become
    increasingly difficult to develop and maintain with modern OSes. System updates
    by the OS vendor, configuration tweaks by the examiner, and additionally installed
    software all create a risk of disabling, overwriting, bypassing, or causing the
    failure of write-blocking functionality implemented in software.
  prefs: []
  type: TYPE_NORMAL
- en: Software write blockers are difficult to implement. Simply mounting a disk as
    read-only (`mount -o ro`) will *not* guarantee that the disk won’t be modified.
    The *read-only* property in this context refers to the filesystem, not the disk
    device. The kernel may still write to the disk for various reasons. Software write
    blocking must be implemented in the kernel, below the virtual filesystem layer
    and even below the other device drivers that implement a particular drive interface
    (AHCI for example). Several low-level software write-blocking methods have been
    used under Linux but with limited success.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tools such as hdparm and blockdev can set a disk to read-only by setting a
    kernel flag. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The same flag can be set with blockdev, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The method of setting kernel flags is dependent on properly configuring udev
    to make newly attached drives read-only before any other process has a chance
    to modify them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A kernel patch has also been written to specifically implement forensic write-blocking
    functionality. You’ll find more information about it at *[https://github.com/msuhanov/Linux-write-blocker/](https://github.com/msuhanov/Linux-write-blocker/)*.
    Several forensic boot CDs use Maxim Suhanov’s write-blocking kernel patch. The
    following helper script manages software write blocking on the DEFT Linux forensic
    boot CD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The patch is implemented in the kernel and is turned on (and off) using helper
    scripts. The helper scripts simply use the `blockdev` command to mark the device
    as read-only.
  prefs: []
  type: TYPE_NORMAL
- en: NIST CFTT has performed software write blocker tool tests, which you’ll find
    at *[http://www.cftt.nist.gov/software_write_block.htm](http://www.cftt.nist.gov/software_write_block.htm)*.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware write blockers are still the safest and recommended method of protecting
    storage media during forensic acquisition.
  prefs: []
  type: TYPE_NORMAL
- en: '***Linux Forensic Boot CDs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The need to perform incident response and triage in the field has led to the
    development of bootable Linux CDs that contain the required software to perform
    such tasks. These CDs can boot a subject PC and access the locally attached storage
    using various forensic tools. Forensic boot CDs are designed to write protect
    discovered storage in the event it needs to be forensically imaged. You can make
    an attached disk writable by using a command (like `wrtblk` shown in the previous
    example), which is useful in acquiring an image when you attach an external destination
    disk. Forensic boot CDs also have network functionality and enable remote analysis
    and acquisition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Forensic boot CDs are useful when:'
  prefs: []
  type: TYPE_NORMAL
- en: • A PC is examined without opening it to remove a disk.
  prefs: []
  type: TYPE_NORMAL
- en: • A write blocker is not available.
  prefs: []
  type: TYPE_NORMAL
- en: • PCs need to be quickly checked during triage for a certain piece of evidence
    before deciding to image.
  prefs: []
  type: TYPE_NORMAL
- en: • Linux-based tools (Sleuth Kit, Foremost, and so on) are needed but not otherwise
    available.
  prefs: []
  type: TYPE_NORMAL
- en: • A forensic technician needs to remotely perform work via ssh.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several popular forensic boot CDs that are currently maintained include:'
  prefs: []
  type: TYPE_NORMAL
- en: '• Kali Linux (formerly BackTrack), which is based on Debian: *[https://www.kali.org/](https://www.kali.org/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '• Digital Evidence & Forensics Toolkit (DEFT), which is based on Ubuntu Linux:
    *[http://www.deftlinux.net/](http://www.deftlinux.net/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '• Pentoo, a forensic CD based on Gentoo Linux: *[http://pentoo.ch/](http://pentoo.ch/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '• C.A.I.N.E, Computer Forensics Linux Live Distro, which is based on Ubuntu
    Linux: *[http://www.caine-live.net/](http://www.caine-live.net/)*'
  prefs: []
  type: TYPE_NORMAL
- en: Forensic boot CDs require a lot of work to maintain and test. Many other forensic
    boot CDs have been available in the past. Because of the changing landscape of
    forensic boot CDs, be sure to research and use the latest functional and maintained
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Media with Physical Read-Only Modes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some storage media have a write-protect mechanism that can be useful in a forensic
    context. For example, most tapes have a sliding switch or tab that instructs the
    tape drive to treat them as read-only, as shown on the left of [Figure 4-5](ch04.xhtml#ch4fig5).
    On the LTO-5 tape (bottom left), a closed tab indicates it is write protected;
    on the DAT160 tape (top left), an open tab indicates it is write protected.
  prefs: []
  type: TYPE_NORMAL
- en: SD memory cards have a *lock* switch that write protects the memory card, as
    shown on the right of [Figure 4-5](ch04.xhtml#ch4fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f04-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: Write-protect tabs on tapes and SD cards*'
  prefs: []
  type: TYPE_NORMAL
- en: Older USB thumb drives may have a write-protect switch. Some very old IDE hard
    disks have a jumper that you can set to make the drive electronics treat the drive
    as read-only.
  prefs: []
  type: TYPE_NORMAL
- en: CD-ROMs, DVDs, and Blu-ray discs do not need a write blocker, because they are
    read-only by default. The simple act of accessing a rewritable disc will not make
    modifications to timestamps or other data on the disc; changes to these optical
    media must be explicitly burned to the disc.
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to set up basic auditing, activity logging,
    and task management. I covered topics such as naming conventions and scalable
    directory structures, as well as various challenges with image sizes, drive capacity
    planning, and performance and environmental issues. Finally, this chapter discussed
    the crucial component of forensic write blocking. You are now ready to attach
    a subject drive to the acquisition host in preparation for executing the forensic
    acquisition process.
  prefs: []
  type: TYPE_NORMAL
