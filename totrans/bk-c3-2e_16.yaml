- en: '**16**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**VALUES AND SIZING**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Much of CSS3, from its many new selectors to layout and font properties, is
    designed to give you more granular control over presentation than was available
    in CSS2.1\. That control will be even more evident in this chapter, as I introduce
    new value functions and units, as well as methods to calculate dimensions automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '**Relative Length Units**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In CSS a *relative length unit* is one whose value is relative to another property.
    The two relative units in CSS2.1 are `em`, which is calculated from the `font-size`
    property of an element, and `ex`, which is calculated from the x-height of the
    element’s font (see “[`font-size-adjust`](ch05.html#ch05leve1sec62)” on [page
    56](ch05.html#page_56)).
  prefs: []
  type: TYPE_NORMAL
- en: CSS3 expands the range of relative units, which are no longer relative solely
    to an element’s font size. The new units are defined in the Values and Units Module
    (*[http://www.w3.org/TR/css-values/](http://www.w3.org/TR/css-values/)*).
  prefs: []
  type: TYPE_NORMAL
- en: '***Root-Relative Units***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first new unit introduced in CSS3 is the `rem`, or *root em*. It behaves
    like the `em` unit from CSS2.1, but instead of being relative to the `font-size`
    value of the current element, it’s relative to the `font-size` value of the document
    root (the `html` element).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although `em` is quite useful, it’s not without its drawbacks, which become
    most apparent when nesting elements. To illustrate the problem, I’ll use this
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'and this simple style rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you presume that the root `font-size` of the document is the common browser
    default of 16px, the first `li` element will have a calculated `font-size` of
    32px (16 multiplied by 2). But the `font-size` of the `li` elements nested inside
    the first would be calculated relative to the inherited value, making them 64px
    (32 multiplied by 2).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the `rem` unit becomes essential. Here’s the same code as the
    previous example, only now using the `rem` in place of the `em` unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Again, presuming a root `font-size` of 16px, the first `li` has a calculated
    `font-size` of 32px. This time, however, the `font-size` of the nested `li` elements
    is also relative to the root value, the same as their parent. And no matter how
    many nested layers down you go, that value is always relative to the root.
  prefs: []
  type: TYPE_NORMAL
- en: '***Viewport-Relative Units***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When building responsively, developers tend to use percentage values for layout
    elements, as they scale fluidly across the range of different screen sizes that
    websites need to cater to. Percentages are useful at a top level, but—as you just
    saw with `em` units—you can run into difficulties when using percentages with
    nested elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code illustrates the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, imagine that `.parent` is 75 percent of the viewport width, and you want
    `.child` to be 65 percent of the viewport width—not the width of its parent. To
    do this, you have to divide 65 by 75, giving you a result of 86.666 (percent).
    This calculation is simple enough, but the deeper the nesting goes, the more complex
    the calculations become.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better solution is to use CSS3’s viewport-relative units—`vh` and `vw`—which
    represent viewport height and width, respectively. Each unit of value represents
    1 percent of the appropriate viewport dimension: 1vh is 1 percent of the viewport
    height, and 1vw is 1 percent of the viewport width. For example, the following
    code makes an element 75 percent of the viewport width and 50 percent of its height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The advantage of using these units is that when elements are nested, the units
    remain relative to the viewport. So, in the case of my previous example, to make
    `.child` 65 percent of the total viewport width, you simply do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: No calculation required!
  prefs: []
  type: TYPE_NORMAL
- en: 'Another pair of supplemental units is available, too: `vmax` is equivalent
    to whichever is the greater value of `vh` and `vw`, and `vmin` is equivalent to
    the lesser value. For instance, if the viewport were 480×640, the height would
    be greater, so `vmax` would be equivalent to `vh`, and `vmin` would be equal to
    `vw`. Swap the viewport dimensions (640×480), and `vmax` and `vmin` reverse their
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So if you presume a viewport of 480×640, in the following code snippet, element
    `*E*` is 640px wide, and element `*F*` is 480px wide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The utility of `vmax` and `vmin` is in ensuring an element remains proportional
    to the viewport regardless of orientation—useful when that orientation can easily
    change, such as on a mobile or tablet device.
  prefs: []
  type: TYPE_NORMAL
- en: Internet Explorer 9 implemented `vmin` as the `vm` unit, but neither it nor
    IE10 supports `vmax` (support was added in IE11). Many older smartphone browsers
    don’t support these properties, although newer versions (such as iOS 6.0 and Android
    4.4 and above) do (though often without support for `vmax`, most notably in iOS
    as of this writing).
  prefs: []
  type: TYPE_NORMAL
- en: '**Calculated Values**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the biggest changes in CSS3 lies in the way that lengths can be declared.
    In CSS2.1, lengths are always a single value plus a unit, and if calculations
    are required (say, subtracting the width of a border from a total width), the
    developer has to do the calculation. But in CSS3, the browser performs the calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS calculations are performed with the `calc()` function. You can use this
    function anywhere you use the common value units—length, angle, number, and so
    on. It takes as an argument any mathematical expression using those common value
    units and four basic operands: `+` (addition), `-` (subtraction), `*` (multiplication),
    and `/` (division).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `calc()` function is especially useful when mixing units. For example,
    you could create an expression to calculate the width of an element (as a percentage)
    minus its border (as an `em`) like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Addition and subtraction can be performed with any units, but when using multiplication,
    at least one argument on either side of the operand must be a unitless number.
    In the case of division, the argument *after* the operand must be a unitless number.
    Here are examples of how to perform both multiplication and division:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use parentheses in expressions to show computational order. For example,
    the following code shows an expression that performs three calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression first multiplies 10 percent by 5, and then adds it to the result
    of 15 percent multiplied by 2\. This setup works fine, but it’s is not immediately
    apparent when you look at it, and given a quite complex calculation could be difficult
    indeed to immediately understand. The expression becomes easier when written with
    parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can also use nested `calc()` functions to achieve the same result.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using multiplication or division in an expression, you must insert a single
    whitespace character around the operand—failing to do this means the expression
    is invalid and the property will be ignored. The following code shows an expression
    written twice: the first one is invalid because it has no space around the operand;
    the second is correctly formatted and, therefore, valid.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Sizing Elements**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The size of an element is generally set using the `width` or `height` properties
    or their `max*-*` and `min*-*` variants, together with either an absolute (`px`),
    relative (`em`), or percentage value. Although these options are good enough for
    most day-to-day use, I often find times when I wish the box model were a little
    more flexible or aware of the elements around it. CSS3 introduces new properties
    and values aimed at providing this extra flexibility through a box-model toggle
    and new content-aware sizing methods.
  prefs: []
  type: TYPE_NORMAL
- en: '***Box Sizing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For many years, Internet Explorer implemented its box model in contravention
    of the W3C spec. The W3C model dictated that the `width` value was the width of
    the content box and that any padding and borders were extra. In IE’s model, on
    the other hand, the `width` value was equal to the total width of the element
    including any padding and borders. Consider these style rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the IE model, the content box would be 70px wide, whereas in the W3C model,
    it would be the full 100px.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the standard model is more logical, at times the IE model is more
    convenient to use. In CSS3, you can opt to use the IE model with the `box-sizing`
    property, which is described in the CSS3 Basic User Interface Module (*[http://www.w3.org/TR/css3-ui/](http://www.w3.org/TR/css3-ui/)*).
    The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The default keyword is `content-box`, which means apply the specified `width`
    or `height` to the content box only, as in the W3C model. In contrast, the alternative
    value `border-box` means any specified length should also include any padding
    and border boxes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-1](ch16.html#ch16fig1) shows the difference. The top example uses
    the W3C box model, whereas the bottom one has the `border-box` value applied.
    As you can see, the total width of the lower example is equal to the content box
    of the upper.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f16-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: Comparing values for* `*box-sizing*`*: the default* `*content-box*`
    *(top) and* `*border-box*` *(bottom)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some people prefer to set a global style rule to apply* `*border-box*` *to
    all elements. I prefer to apply the rule only as required.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Intrinsic and Extrinsic Sizing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One challenge in web layout is that elements are ignorant of their content and
    the context in which they’re used—in other words, without JavaScript, an element
    is not aware of the dimensions of its child or parent elements. CSS3 introduces
    a new concept that changes that equation a bit with the addition of *intrinsic*
    and *extrinsic* sizing. Intrinsic sizing is based on an element’s children, and
    extrinsic sizing is based on the size of the parent element. These sizing models
    are defined in the CSS3 Intrinsic & Extrinsic Sizing Module (*[http://dev.w3.org/csswg/css-sizing/](http://dev.w3.org/csswg/css-sizing/)*).
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the intrinsic and extrinsic sizing models are applied using a keyword
    value on the `width` or `height` properties (and their `min-` and `max-` variants).
    For example, this listing shows how a new sizing model would be applied to `width`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**max-content and min-content**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first new keyword values, `max-content` and `min-content`, are intrinsic
    values that make an element as wide or as high as the largest (`max-content`)
    or smallest (`min-content`) item of content (in text, the width of the longest
    word) it contains. Consider this markup of an `img` and `p` element inside a containing
    `div`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Say the `img` element has a width of 200px and the width of the `p` is 300px.
    If the `div` element had a `width` value of `max-content`, it would be just wide
    enough to contain the `p`, and if it had a value of `min-content`, it would be
    just wide enough to fit the `img` and the text in the `p` would wrap.
  prefs: []
  type: TYPE_NORMAL
- en: Compare the results shown in [Figure 16-2](ch16.html#ch16fig2). The container
    element on the left has the `max-content` value applied, which makes it as wide
    as the widest child (the `p`), whereas the one on the right has `min-content`
    applied, which makes it as wide as the narrowest child (the `img`).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f16-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-2: The* `*max-content*` *value (left) makes the element as wide
    as its widest child, whereas* `*min-content*` *(right) makes the element as wide
    as its narrowest child.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As of this writing, the current desktop and mobile versions of Chrome, Firefox,
    and Safari support these keywords, although each requires vendor prefixes (namely*`*-moz-min-content*`
    *and* `*-webkit-min-content*`*). Support is not currently present in Internet
    Explorer or older smartphones.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**fit-content**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The next intrinsic keyword value is potentially the most useful. Called `fit-content`,
    it sizes an element just as floated elements or table cells do: An element will
    expand to be just wide enough to contain its content, unless the maximum width
    of the element is reached, in which case, the content will wrap.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-3](ch16.html#ch16fig3) compares the effect of `fit-content` to `max-content`
    and `min-content`. The box at the top left has `fit-content` applied, and the
    content wraps when it reaches the limit of the parent container. In contrast,
    the box at the top right has `max-content` applied, so it should expand to fit
    its content—however, the box now exceeds the width of its parent container, which
    has an `overflow` value of `hidden`, meaning the box is clipped.'
  prefs: []
  type: TYPE_NORMAL
- en: The box at bottom left also has `fit-content` applied, so the container resizes
    to fit the width of the content; the box at the bottom right has `min-content`
    applied, so the container is only as wide as the `img` element and the text content
    wraps.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f16-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-3: The* `*fit-content*` *value, compared to* `*max-content*` *and*
    `*min-content*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**fill**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The final keyword in the spec is named `fill`. (But in Firefox it’s `available`
    and in Chrome it’s `fill-available`!) This extrinsic value makes an element fill
    all available space along the height or width of its parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you want to make an inline-block `p` element, with border and padding,
    expand to be as wide as its parent. Generally, you would apply these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you know, however, an element’s “real” width also includes padding and border,
    so, in this case, the `p` element would overflow its parent. One solution is to
    use the `box-sizing` property (see “[Box Sizing](ch16.html#ch16leve1sec213)” on
    [page 203](ch16.html#page_203)), but you may have good reasons for keeping the
    standard box model, so a better alternative is to use intrinsic sizing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The result is shown in [Figure 16-4](ch16.html#ch16fig4); the inline-block element,
    with border and padding, is resized to fill the available space in its parent.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f16-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-4: Using the* `*fill*` *value for* `*width*` *makes the inline-block
    caption shown here fill the available width of its parent.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I’ve discussed value units that are relative to a root font
    size and the viewport, dynamic calculations of values, and CSS3 ways to size elements
    based on their content and context. I’ve also discussed the CSS3 switch to a different
    box model.
  prefs: []
  type: TYPE_NORMAL
- en: Although units and sizing methods may seem like an unglamorous aspect of CSS,
    they offer you fine-grained control over your layouts, which is always welcome.
    Because websites are viewed on such a variety of different devices, for an element
    to be aware of its viewport, content, and context, so it presents content in the
    most appropriate way, is extremely valuable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Values and Sizing: Browser Support**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '|  | **Chrome** | **Firefox** | **Safari** | **IE** |'
  prefs: []
  type: TYPE_TB
- en: '| Root-relative units | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Viewport-relative units | Yes | Yes | Yes^([*](ch16.html#footnote35a)) |
    IE9^([†](ch16.html#footnote36a)), IE10^([‡](ch16.html#footnote37a)) |'
  prefs: []
  type: TYPE_TB
- en: '| Calculated values | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Box sizing | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Intrinsic/extrinsic sizing | Yes^([§](ch16.html#footnote38a)) | Yes^([§](ch16.html#footnote38a))
    | Yes^([§](ch16.html#footnote38a)) | No |'
  prefs: []
  type: TYPE_TB
- en: '[*](ch16.html#footnote_35a) Buggy support for `vh` in iOS'
  prefs: []
  type: TYPE_NORMAL
- en: '[†](ch16.html#footnote_36a) Supports `vm` instead of `vmin`, no support for
    `vmax`'
  prefs: []
  type: TYPE_NORMAL
- en: '[‡](ch16.html#footnote_37a) No support for `vmax`'
  prefs: []
  type: TYPE_NORMAL
- en: '[§](ch16.html#footnote_38a) With vendor prefix'
  prefs: []
  type: TYPE_NORMAL
