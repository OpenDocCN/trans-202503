<html><head></head><body>
<h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_13"/><span class="big">2</span><br/>A BRIEF INTRODUCTION TO THE GNU AUTOTOOLS</h2>&#13;
<p class="quote"><em>We shall not cease from exploration And the end of all our exploring Will be to arrive where we started And know the place for the first time.<br/>—T.S. Eliot, “Quartet No. 4: Little Gidding”</em></p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">As stated in the preface to this book, the purpose of the GNU Autotools is to make life simpler for the end user, not the maintainer. Nevertheless, using the Autotools will make your job as a project maintainer easier in the long run, although maybe not for the reasons you suspect. The Autotools framework is as simple as it can be, given the functionality it provides. The real purpose of the Autotools is twofold: it serves the needs of your users, and it makes your project incredibly portable—even to systems on which you’ve never tested, installed, or built your code.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_14"/>Throughout this book, I will often use the term <em>Autotools</em>, although you won’t find a package in the GNU archives with this label. I use this term to signify the following three GNU projects, which are considered by the community to be part of the GNU build system:</p>&#13;
<ul>&#13;
<li class="noindent">Autoconf, which is used to generate a configuration script for a project</li>&#13;
<li class="noindent">Automake, which is used to simplify the process of creating consistent and functional makefiles</li>&#13;
<li class="noindent">Libtool, which provides an abstraction for the portable creation of shared libraries</li>&#13;
</ul>&#13;
<p class="indent">Other build tools, such as the open source projects CMake and SCons, attempt to provide the same functionality as the Autotools but in a more user-friendly manner. However, because these tools attempt to hide much of their complexity behind GUI interfaces and script builders, they actually end up being less functional, and more difficult to manage, because the build system is not as transparent. In the final analysis, this transparency is what makes the Autotools both simpler to use and simpler to understand. Initial frustration with the Autotools, therefore, comes not from their complexity—for they are truly very simple—but from their extensive use of less well understood tools and subsystems, such as the Linux command shell (Bash), the <code>make</code> utility, and the M4 macro processor and accompanying macro libraries. Indeed, the meta-language provided by Automake is so simple it can be entirely digested and comprehended within a few hours of perusing the manual (though the ramifications of this meta-language may take a bit longer to thoroughly internalize).</p>&#13;
<h3 class="h3" id="ch02sec1">Who Should Use the Autotools?</h3>&#13;
<p class="noindent">If you’re writing open source software that targets Unix or Linux systems, you should absolutely be using the GNU Autotools, and even if you’re writing proprietary software for Unix or Linux systems, you’ll still benefit significantly from using them. The Autotools provide you with a build environment that allows your project to build successfully on future versions or distributions with virtually no changes to the build scripts. This is useful even if you only intend to target a single Linux distribution, because—let’s be honest—you really <em>can’t</em> know in advance whether or not your company will want your software to run on other platforms in the future.</p>&#13;
<h3 class="h3" id="ch02sec2">When Should You Not Use the Autotools?</h3>&#13;
<p class="noindent">About the only time it makes sense not to use the Autotools is when you’re writing software that will <em>only</em> run on non-Unix platforms, such as Microsoft Windows.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_15"/>Autotools support for Windows requires an Msys<sup><a id="ch02fn_1" href="footnote.xhtml#ch02fn1">1</a></sup> environment in order to work correctly, because Autoconf-generated configuration scripts are Bourne-shell scripts, and Windows doesn’t provide a native Bourne shell.<sup><a id="ch02fn_2" href="footnote.xhtml#ch02fn2">2</a></sup> Unix and Microsoft tools are just different enough in command line options and runtime characteristics that it’s often simpler to use Windows ports of GNU tools, such as Cygwin, Msys2, or MinGW, to build Windows programs with an Autotools build system.</p>&#13;
<p class="indent">For these reasons, I’ll focus mostly on using the Autotools on POSIX-compliant platforms. Nevertheless, if you’re interested in trying out the Autotools on Windows, check out <a href="ch17.xhtml">Chapter 17</a> for an in-depth overview.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>I’m not a typical Unix bigot. While I love Unix (and especially Linux), I also appreciate Windows for the areas in which it excels.<sup><a id="ch02fn_3" href="footnote.xhtml#ch02fn3">3</a></sup> For Windows development, I highly recommend using Microsoft tools. The original reasons for using GNU tools to develop Windows programs are more or less academic nowadays because Microsoft has made the better part of its tools available for download at no cost. For download information, see Visual Studio Community at</em> <a href="https://visualstudio.microsoft.com/vs/express/">https://visualstudio.microsoft.com/vs/express/</a>.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch02sec3">Apple Platforms and Mac OS X</h3>&#13;
<p class="noindent">The Macintosh operating system has been POSIX compliant since 2007 when the “Leopard” release of macOS version 10 (OS X) was published. OS X is derived from NeXTSTEP/OpenStep, which is based on the Mach kernel, with parts taken from FreeBSD and NetBSD. As a POSIX-compliant operating system, OS X provides all the infrastructure required by the Autotools. The problems you’ll encounter with OS X will most likely involve Apple’s graphical user interface and package management systems, both of which are specific to the Mac.</p>&#13;
<p class="indent">The user interface presents the same issues you encounter when dealing with the X Window system on other Unix platforms, and then some. The primary difference is that the X Window system is used exclusively on most Unix systems, but macOS has its own graphical user interface called <em>Cocoa</em>. While the X Window system can be used on the Mac (Apple provides <span epub:type="pagebreak" id="page_16"/>a window manager that makes X applications look a lot like native Cocoa apps), Mac programmers will sometimes wish to take full advantage of the native user interface features provided by the operating system.</p>&#13;
<p class="indent">The Autotools skirt the issue of package management differences between Unix platforms by simply ignoring them. Instead, they create packages that are little more than compressed source archives using the <code>tar</code> and <code>gzip</code> utilities, and they install and uninstall products from the <code>make</code> command line. The macOS package management system is an integral part of installing an application on an Apple system, and projects like Fink (<em><a href="http://www.finkproject.org/">http://www.finkproject.org/</a></em>) and MacPorts (<em><a href="http://www.macports.org/">http://www.macports.org/</a></em>) help make existing open source packages available on the Mac by providing simplified mechanisms for converting Autotools packages into installable Mac packages.</p>&#13;
<p class="indent">The bottom line is that the Autotools can be used quite effectively on Apple Macintosh systems running OS X or later, as long as you keep these caveats in mind.</p>&#13;
<h3 class="h3" id="ch02sec4">The Choice of Language</h3>&#13;
<p class="noindent">Your choice of programming language is another important factor to consider when deciding whether to use the Autotools. Remember that the Autotools were designed by GNU people to manage GNU projects. In the GNU community, two factors determine the importance of a computer programming language:</p>&#13;
<ul>&#13;
<li class="noindent">Are there any GNU packages written in the language?</li>&#13;
<li class="noindent">Does the GNU compiler tool set support the language?</li>&#13;
</ul>&#13;
<p class="indent">Autoconf provides native support for the following languages based on these two criteria (by <em>native support</em>, I mean that Autoconf will compile, link, and run source-level feature checks in these languages):</p>&#13;
<ul>&#13;
<li class="noindent">C</li>&#13;
<li class="noindent">C++</li>&#13;
<li class="noindent">Objective C</li>&#13;
<li class="noindent">Objective C++</li>&#13;
<li class="noindent">Fortran</li>&#13;
<li class="noindent">Fortran 77</li>&#13;
<li class="noindent">Erlang</li>&#13;
<li class="noindent">Go</li>&#13;
</ul>&#13;
<p class="indentt">Therefore, if you want to build a Java package, you can configure Automake to do so (as you’ll see in <a href="ch14.xhtml">Chapters 14</a> and <a href="ch15.xhtml">15</a>), but you can’t ask <span epub:type="pagebreak" id="page_17"/>Autoconf to compile, link, or run Java-based checks,<sup><a id="ch02fn_4" href="footnote.xhtml#ch02fn4">4</a></sup> because Autoconf simply doesn’t natively support Java. However, you can find Autoconf macros (which I will cover in more detail in later chapters) that enhance Autoconf’s ability to manage the configuration process for projects written in Java.</p>&#13;
<p class="indent">The general feeling is that Java has plenty of its own build environments and tools that work very well (maven, for instance); therefore, adding full support for Java seems like a wasted effort. This is especially true since Java and its build tools are themselves highly portable—even to non-Unix/Linux platforms such as Windows.</p>&#13;
<p class="indent">Rudimentary support does exist in Automake for Java compilers and JVMs. I’ve used these features myself on projects, and they work well, as long as you don’t try to push them too far.</p>&#13;
<p class="indent">If you’re into Smalltalk, ADA, Modula, Lisp, Forth, or some other non-mainstream language, you’re probably not too interested in porting your code to dozens of platforms and CPUs. However, if you <em>are</em> using a non-mainstream language and you’re concerned about the portability of your build systems, consider adding support for your language to the Autotools yourself. This is not as daunting a task as you may think, and I guarantee that you’ll be an Autotools expert when you’re finished.<sup><a id="ch02fn_5" href="footnote.xhtml#ch02fn5">5</a></sup></p>&#13;
<h3 class="h3" id="ch02sec5">Generating Your Package Build System</h3>&#13;
<p class="noindent">The GNU Autotools framework includes three main packages: Autoconf, Automake, and Libtool. The tools in these packages can depend on utilities and functionality from the gettext, M4, sed, make, and Perl packages, among others; however, the build systems generated by these packages rely only on a Bourne shell and the <code>make</code> utility.</p>&#13;
<p class="indent">With respect to the Autotools, it’s important to distinguish between a <em>maintainer’s</em> system and an <em>end user’s</em> system. The design goals of the Autotools specify that an Autotools-generated build system should rely only on tools that are readily available and preinstalled on the end user’s machine (assuming the end user’s system has rudimentary support for building programs from source code). For example, the machine a maintainer uses to create distributions requires a Perl interpreter, but a machine on which an end user builds products from release distribution source archives should not require Perl (unless, of course, the project sources are written in Perl).</p>&#13;
<p class="indent">A corollary is that an end user’s machine doesn’t need to have the Autotools installed—an end user’s system only requires a reasonably <span epub:type="pagebreak" id="page_18"/>POSIX-compliant version of <code>make</code> and some variant of the Bourne shell that can execute the generated configuration script. And, of course, any package will also require compilers, linkers, and other tools needed to convert source files into executable binary programs, help files, and other runtime resources.</p>&#13;
<h3 class="h3" id="ch02sec6">Configuration</h3>&#13;
<p class="noindent">Most developers understand the purpose of the <code>make</code> utility, but what’s the point of <code>configure</code>? While Unix systems have followed the de facto standard Unix kernel interface for decades, most software has to stretch beyond these boundaries.</p>&#13;
<p class="indent">Originally, configuration scripts were hand-coded shell scripts designed to set environment variables based on platform-specific characteristics. They also allowed users to configure package options before running <code>make</code>. This approach worked well for decades, but as the number of Linux distributions and Unix-like systems grew, the variety of features and installation and configuration options exploded, so it became very difficult to write a decent portable configuration script. In fact, it was much more difficult to write a portable configuration script than it was to write makefiles for a new project. Therefore, most people just created configuration scripts for their projects by copying and modifying the script for a similar project.</p>&#13;
<p class="indent">In the early 1990s, it was apparent to many open source software developers that project configuration would become painful if something wasn’t done to ease the burden of writing massive complex shell scripts to manage configuration options. The number of GNU project packages had grown to hundreds, and maintaining consistency across their separate build systems had become more time-consuming than simply maintaining the code for these projects. These problems had to be solved.</p>&#13;
<h3 class="h3" id="ch02sec7">Autoconf</h3>&#13;
<p class="noindent">Autoconf <sup><a id="ch02fn_6" href="footnote.xhtml#ch02fn6">6</a></sup> changed this paradigm almost overnight. David MacKenzie started the Autoconf project in 1991, but a look at the <em>AUTHORS</em> file in the Savannah Autoconf project<sup><a id="ch02fn_7" href="footnote.xhtml#ch02fn7">7</a></sup> repository will give you an idea of the number of people who had a hand in making the tool. Although configuration scripts were long and complex, users needed to specify only a few variables when executing them. Most of these variables were simply choices about components, features, and options, such as <em>Where can the build system find libraries and header files? Where do I want to install my finished products? Which optional components do I want to build into my products?</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_19"/>Instead of modifying and debugging hundreds of lines of supposedly portable shell script, developers can now write a short metascript file using a concise, macro-based language, and Autoconf will generate a perfect configuration script that is more portable, more accurate, and more maintainable than a hand-coded one. In addition, Autoconf often catches semantic or logic errors that could otherwise take days to debug. Another benefit of Autoconf is that the shell code it generates is portable between most variations of the Bourne shell. Mistakes made in portability between shells are very common and, unfortunately, are the most difficult kinds of mistakes to find, because no one developer has access to all Bourne-like shells.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>While portable scripting languages like Perl and Python are now more pervasive than the Bourne shell, this was not the case when the idea for Autoconf was first conceived.</em></p>&#13;
</div>&#13;
<p class="indent">Autoconf-generated configuration scripts provide a common set of options that are important to all portable software projects running on POSIX systems. These include options to modify standard locations (a concept I’ll cover in more detail in <a href="ch03.xhtml">Chapter 3</a>), as well as project-specific options defined in the <em>configure.ac</em> file (which I’ll discuss in <a href="ch05.xhtml">Chapter 5</a>).</p>&#13;
<p class="indent">The autoconf package provides several programs, including the following:</p>&#13;
<ul>&#13;
<li class="noindent"><code>autoconf</code></li>&#13;
<li class="noindent"><code>autoreconf</code></li>&#13;
<li class="noindent"><code>autoheader</code></li>&#13;
<li class="noindent"><code>autoscan</code></li>&#13;
<li class="noindent"><code>autoupdate</code></li>&#13;
<li class="noindent"><code>ifnames</code></li>&#13;
<li class="noindent"><code>autom4te</code></li>&#13;
</ul>&#13;
<p class="indent">The <code>autoconf</code> program is a simple Bourne shell script. Its main task is to ensure that the current shell contains the functionality necessary to execute the <code>m4</code> macro processor. (I’ll discuss Autoconf’s use of M4 in detail in <a href="ch04.xhtml">Chapter 4</a>.) The remainder of the script parses command line parameters and executes <code>autom4te</code>.</p>&#13;
<h4 class="h4" id="ch02sec7-1"><em>autoreconf</em></h4>&#13;
<p class="noindent">The <code>autoreconf</code> utility executes the configuration tools in the autoconf, automake, and libtool packages as required by the project. This utility minimizes the amount of regeneration required to address changes in timestamps, features, and project state. It was written as an attempt to consolidate existing maintainer-written, script-based utilities that ran all the required Autotools in the right order. You can think of <code>autoreconf</code> as a sort of smart Autotools bootstrap utility. If all you have is a <em>configure.ac</em> file, you can run <code>autoreconf</code> to execute all the tools you need, in the correct order, so that <code>configure</code> will be properly generated. <a href="ch02.xhtml#ch02fig01">Figure 2-1</a> shows how <code>autoreconf</code> interacts with other utilities in the Autotools suite.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_20"/><img src="../images/02fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch02fig01"><em>Figure 2-1: A dataflow diagram for the <code>autoreconf</code> utility</em></p>&#13;
<p class="indent">Nevertheless, there are times when a project requires more than simply bootstrapping the Autotools to get a developer up and running on a newly checked-out repository work area. In these cases, a small shell script that runs <code>autoreconf</code>, along with any non-Autotools-related processes, is appropriate. Many projects name such a script <code>autogen.sh</code>, but this is often confusing to developers because there is a GNU Autogen project. A better name would be something like <code>bootstrap.sh</code>.</p>&#13;
<p class="indent">Additionally, when used with the <code>-i</code> option, <code>autoreconf</code> will bootstrap a project into a distributable state by adding missing files that are recommended or required by GNU for proper open source projects. These include a proper <em>ChangeLog</em> and template <em>INSTALL</em>, <em>README</em>, and <em>AUTHORS</em> files and so on.</p>&#13;
<h4 class="h4" id="ch02sec7-2"><em>autoheader</em></h4>&#13;
<p class="noindent">The <code>autoheader</code> utility generates a C/C++ compatible header file template from various constructs in <em>configure.ac</em>. This file is usually called <em>config.h.in</em>. When the end user executes <code>configure</code>, the configuration script generates <em>config.h</em> from <em>config.h.in</em>. As maintainer, you’ll use <code>autoheader</code> to generate the template file you will include in your distribution package. (We’ll examine <code>autoheader</code> in greater detail in <a href="ch04.xhtml">Chapter 4</a>.)</p>&#13;
<h4 class="h4" id="ch02sec7-3"><em>autoscan</em></h4>&#13;
<p class="noindent">The <code>autoscan</code> program generates a default <em>configure.ac</em> file for a new project; it can also examine an existing Autotools project for flaws and opportunities for enhancement. (We’ll discuss <code>autoscan</code> in more detail in <a href="ch04.xhtml">Chapters 4</a> and <a href="ch14.xhtml">14</a>.) <code>autoscan</code> is very useful as a starting point for a project that uses a non-Autotools-based build system, but it may also be useful for suggesting features that might enhance an existing Autotools-based project.</p>&#13;
<h4 class="h4" id="ch02sec7-4"><em>autoupdate</em></h4>&#13;
<p class="noindent">The <code>autoupdate</code> utility is used to update <em>configure.ac</em> or the template (<em>.in</em>) files to match the syntax supported by current versions of the Autotools.</p>&#13;
<h4 class="h4" id="ch02sec7-5"><em><span epub:type="pagebreak" id="page_21"/>ifnames</em></h4>&#13;
<p class="noindent">The <code>ifnames</code> program is a small and generally underused utility that accepts a list of source file names on the command line and displays a list of C-preprocessor definitions. This utility was designed to help maintainers determine what to put into the <em>configure.ac</em> and <em>Makefile.am</em> files to make them portable. If your project was written with some level of portability in mind, <code>ifnames</code> can help you determine where those attempts at portability are located in your source tree and give you the names of potential portability definitions.</p>&#13;
<h4 class="h4" id="ch02sec7-6"><em>autom4te</em></h4>&#13;
<p class="noindent">The <code>autom4te</code> utility is a Perl-based intelligent caching wrapper for <code>m4</code> that is used by most of the other Autotools. The <code>autom4te</code> cache decreases the time successive tools spend accessing <em>configure.ac</em> constructs by as much as 30 percent.</p>&#13;
<p class="indent">I won’t spend a lot of time on <code>autom4te</code> (pronounced <em>automate</em>) because it’s primarily used internally by the Autotools. The only sign that it’s working is the <em>autom4te.cache</em> directory that appears in your top-level project directory after you run <code>autoconf</code> or <code>autoreconf</code>.</p>&#13;
<h4 class="h4" id="ch02sec7-7"><em>Working Together</em></h4>&#13;
<p class="noindent">Of the previously listed tools, <code>autoconf</code> and <code>autoheader</code> are the only ones project maintainers use when generating a <code>configure</code> script, and <code>autoreconf</code> is the only one that the developer needs to directly execute. <a href="ch02.xhtml#ch02fig02">Figure 2-2</a> shows the interaction between input files and <code>autoconf</code> and <code>autoheader</code> that generates the corresponding product files.</p>&#13;
<div class="image"><img src="../images/02fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch02fig02"><em>Figure 2-2: A data flow diagram for <code>autoconf</code> and <code>autoheader</code></em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>I use the data flow diagram format shown in <a href="ch02.xhtml#ch02fig02">Figure 2-2</a> throughout this book. Dark boxes represent objects provided either by the user or by an Autotools package. Light boxes represent generated objects. Boxes with square corners are scripts and programs, and boxes with rounded corners are data files. The meaning of most of <span epub:type="pagebreak" id="page_22"/>the labels here should be obvious, but at least one deserves an explanation: the term ac-vars refers to Autoconf-specific replacement text. I’ll explain the gradient shading of the aclocal.m4 box shortly.</em></p>&#13;
</div>&#13;
<p class="indent">The primary task of this suite of tools is to generate a configuration script that can be used to configure a project build directory for a target platform (not necessarily the local host). This script does not rely on the Autotools themselves; in fact, <code>autoconf</code> is designed to generate configuration scripts that will run on all Unix-like platforms and in most variations of the Bourne shell. This means that you can generate a configuration script using <code>autoconf</code> and then successfully execute that script on a machine that does not have the Autotools installed.</p>&#13;
<p class="indent">The <code>autoconf</code> and <code>autoheader</code> programs are executed either directly by you or indirectly by <code>autoreconf</code>. They take their input from your project’s <em>configur</em><em>e</em><em>.ac</em> file and various Autoconf-flavored M4 macro definition files (which, by convention, have a <em>.m4</em> extension), using <code>autom4te</code> to maintain cache information. The <code>autoconf</code> program generates a configuration script called <code>configure</code>, a very portable Bourne shell script that enables your project to offer many useful configuration capabilities. The program <code>autoheader</code> generates the <em>config.h.in</em> template based on certain macro definitions in <em>configure.ac</em>.</p>&#13;
<h3 class="h3" id="ch02sec8">Automake</h3>&#13;
<p class="noindent">Once you’ve done it a few times, writing a basic makefile for a new project is fairly simple. But problems may occur when you try to do more than just the basics. And let’s face it—what project maintainer has ever been satisfied with just a basic makefile?</p>&#13;
<p class="indent">Attention to detail is what makes an open source project successful. Users lose interest in a project fairly easily—especially when functionality they expect is missing or improperly written. For example, power users have come to expect makefiles to support certain standard targets or goals, specified on the <code>make</code> command line, like this:</p>&#13;
<pre>$ <span class="codestrong1">make install</span></pre>&#13;
<p class="indent">Common <code>make</code> targets include <code>all</code>, <code>clean</code>, and <code>install</code>. In this example, <code>install</code> is the target. But you should realize that none of these are <em>real</em> targets: a <em>real target</em> is a filesystem object that is produced by the build system—usually a file (but sometimes a directory or a link). When building an executable called <code>doofabble</code>, for instance, you’d expect to be able to enter:</p>&#13;
<pre>$ <span class="codestrong1">make doofabble</span></pre>&#13;
<p class="indent">For this project, <code>doofabble</code> is a real target, and this command works for the doofabble project. However, requiring the user to enter real targets on the <code>make</code> command line is asking a lot of them, because each project must be built differently—<code>make doofabble</code>, <code>make foodabble</code>, <code>make abfooble</code>, and so on. Standardized targets for <code>make</code> allow all projects to be built in the <span epub:type="pagebreak" id="page_23"/>same way using commonly known commands like <code>make all</code> and <code>make clean</code>. But <em>commonly known</em> doesn’t mean <em>automatic</em>, and writing and maintaining makefiles that support these targets is tedious and error prone.</p>&#13;
<p class="indent">Automake’s job is to convert a simplified specification of your project’s build process into boilerplate makefile syntax that always works correctly the first time <em>and provides all the standard functionality expected</em>. Automake creates projects that support the guidelines defined in the <em>GNU Coding Standards</em> (discussed in <a href="ch03.xhtml">Chapter 3</a>).</p>&#13;
<p class="indent">Just like <code>autoconf</code> produces a <code>configure</code> script that is portable to many flavors of the Bourne shell, <code>automake</code> produces <code>make</code> script that is portable to many flavors of <code>make</code>.</p>&#13;
<p class="indent">The automake package provides the following tools in the form of Perl scripts:</p>&#13;
<ul>&#13;
<li class="noindent"><code>automake</code></li>&#13;
<li class="noindent"><code>aclocal</code></li>&#13;
</ul>&#13;
<h4 class="h4" id="ch02sec8-1"><em>automake</em></h4>&#13;
<p class="noindent">The <code>automake</code> program generates standard makefile templates (named <em>Makefile.in</em>) from high-level build specification files (named <em>Makefile.am</em>). These <em>Makefile.am</em> input files are essentially just regular makefiles. If you were to put only the few required Automake definitions in a <em>Makefile.am</em> file, you’d get a <em>Makefile.in</em> file containing several hundred lines of parameterized <code>make</code> script.</p>&#13;
<p class="indent">If you add additional <code>make</code> syntax to a <em>Makefile.am</em> file, Automake will move this code to the most functionally correct location in the resulting <em>Makefile.in</em> file. In fact, you can write your <em>Makefile.am</em> files so all they contain is ordinary <code>make</code> script, and the resulting makefiles will work just fine. This pass-through feature gives you the ability to extend Automake’s functionality to suit your project’s specific requirements.<sup><a id="ch02fn_8" href="footnote.xhtml#ch02fn8">8</a></sup></p>&#13;
<h4 class="h4" id="ch02sec8-2"><em>aclocal</em></h4>&#13;
<p class="noindent">In the <em>GNU Automake Manual</em>, the <code>aclocal</code> utility is documented as a temporary workaround for a certain lack of flexibility in Autoconf. Automake enhances Autoconf by adding an extensive set of macros, but Autoconf was not really designed with this level of enhancement in mind.</p>&#13;
<p class="indent">The original documented method for adding user-defined macros to an Autoconf project was to create a file called <em>aclocal.m4</em>, place the user-defined macros in this file, and place the file in the same directory as <em>configure.ac</em>. Autoconf then automatically includes this set of macros while processing <em>configure.ac</em>. The designers of Automake found this extension mechanism too useful to pass up; however, users would have been required to add an <code>m4_include</code> statement to a possibly unnecessary <em>aclocal.m4</em> file in order to <span epub:type="pagebreak" id="page_24"/>include the Automake macros. Since both user-defined macros and the use of M4 itself are considered advanced concepts, this was deemed too harsh a requirement.</p>&#13;
<p class="indent">The <code>aclocal</code> script was designed to solve this problem. This utility generates an <em>aclocal.m4</em> file for a project that contains both user-defined macros and all required Automake macros.<sup><a id="ch02fn_9" href="footnote.xhtml#ch02fn9">9</a></sup> Instead of adding user-defined macros directly to <em>aclocal.m4</em>, project maintainers should now add them to a new file called <em>acinclude.m4</em>.</p>&#13;
<p class="indent">To make it clear to readers that Autoconf doesn’t depend on Automake (and perhaps due to a bit of stubbornness), the <em>GNU Autoconf Manual</em> doesn’t make much mention of the <code>aclocal</code> utility. The <em>GNU Automake Manual</em> originally suggested that you rename <em>aclocal.m4</em> to <em>acinclude.m4</em> when adding Automake to an existing Autoconf project, and this approach is still commonly used. The flow of data for <code>aclocal</code> is depicted in <a href="ch02.xhtml#ch02fig03">Figure 2-3</a>.</p>&#13;
<div class="image"><img src="../images/02fig03.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch02fig03"><em>Figure 2-3: A data flow diagram for <code>aclocal</code></em></p>&#13;
<p class="indent">However, the latest documentation for both Autoconf and Automake suggests that the entire paradigm is now obsolete. Developers should now specify a directory that contains a set of M4 macro files. The current recommendation is to create a directory in the project root directory called <em>m4</em> and add macros as individual <em>.m4</em> files to it. All files in this directory will be gathered into <em>aclocal.m4</em> before Autoconf processes <em>configure.ac</em>.<sup><a id="ch02fn_10" href="footnote.xhtml#ch02fn10">10</a></sup></p>&#13;
<p class="indent">It may now be more apparent why the <em>aclocal.m4</em> box in <a href="ch02.xhtml#ch02fig02">Figure 2-2</a> couldn’t decide which color it should be. When you’re using it without Automake and Libtool, you write <em>aclocal.m4</em> by hand. However, when you’re using it with Automake, the file is generated by the <code>aclocal</code> utility, and you provide project-specific macros either in <em>acinclude.m4</em> or in an <em>m4</em> directory.</p>&#13;
<h3 class="h3" id="ch02sec9">Libtool</h3>&#13;
<p class="noindent">How do you build shared libraries on different Unix platforms without adding a lot of very platform-specific conditional code to your build system and source code? This is the question that the Libtool project tries to address.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_25"/>There’s a significant amount of common functionality among Unix-like platforms. However, one very significant difference has to do with how shared libraries are built, named, and managed. Some platforms name their libraries <em>lib</em>name<em>.so</em>, others use <em>lib</em>name<em>.a</em> or even <em>lib</em>name<em>.sl</em>. The Cygwin system for Windows names Cygwin-generated shared libraries <em>cyg</em>name<em>.dll</em>. Still others don’t even provide native shared libraries. Some platforms provide <em>libdl.so</em> to allow software to dynamically load and access library functionality at runtime, while others provide different mechanisms, and some platforms don’t provide this functionality at all.</p>&#13;
<p class="indent">The developers of Libtool have carefully considered all of these differences. Libtool supports dozens of platforms, not only providing a set of Autoconf macros that hide library-naming differences in makefiles but also offering an optional library of dynamic loader functionality that can be added to programs. This functionality allows maintainers to make their runtime, dynamic shared-object management code more portable and easier to maintain.</p>&#13;
<p class="indent">The libtool package provides the following programs, libraries, and header file:</p>&#13;
<ul>&#13;
<li class="noindent"><code>libtool</code> (program)</li>&#13;
<li class="noindent"><code>libtoolize</code> (program)</li>&#13;
<li class="noindent"><em>ltdl</em> (static and shared libraries)</li>&#13;
<li class="noindent"><em>ltdl.h</em> (header file)</li>&#13;
</ul>&#13;
<h4 class="h4" id="ch02sec9-1"><em>libtool</em></h4>&#13;
<p class="noindent">The <code>libtool</code> shell script that ships with the libtool package is a generic version of the custom script that <code>libtoolize</code> generates for a project.</p>&#13;
<h4 class="h4" id="ch02sec9-2"><em>libtoolize</em></h4>&#13;
<p class="noindent">The <code>libtoolize</code> shell script prepares your project to use Libtool. It generates a custom version of the generic <code>libtool</code> script and adds it to your project directory. This custom script is shipped with the project along with the Automake-generated makefiles, which execute the script on the user’s system at the appropriate time.</p>&#13;
<h4 class="h4" id="ch02sec9-3"><em>ltdl, the Libtool C API</em></h4>&#13;
<p class="noindent">The libtool package also provides the <em>ltdl</em> library and associated header files, which provide a consistent runtime shared-object manager across platforms. The <em>ltdl</em> library may be linked statically or dynamically into your programs, giving them a consistent runtime shared-library access interface between platforms.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch02fig04">Figure 2-4</a> illustrates the interaction between the <code>automake</code> and <code>libtool</code> scripts, and the input files used to create products that configure and build your projects.</p>&#13;
<p class="indent">Automake and Libtool are both standard pluggable options that can be added to <em>configure.ac</em> with just a few simple macro calls.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_26"/><img src="../images/02fig04.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch02fig04"><em>Figure 2-4: A data flow diagram for <code>automake</code> and <code>libtool</code></em></p>&#13;
<h3 class="h3" id="ch02sec10">Building Your Package</h3>&#13;
<p class="noindent">As maintainer, you probably build your software packages fairly often, and you’re also probably intimately familiar with your project’s components, architecture, and build system. However, you should make sure that your users’ build experiences are much simpler than your own. One way to do this is to give users a simple, easy-to-understand pattern to follow when building your software packages. In the following sections, I’ll show you the build pattern supported by the Autotools.</p>&#13;
<h4 class="h4" id="ch02sec10-1"><em>Running configure</em></h4>&#13;
<p class="noindent">After running the Autotools, you’re left with a shell script called <code>configure</code> and one or more <em>Makefile.in</em> files. These files are intended to be shipped with your project release distribution packages.<sup><a id="ch02fn_11" href="footnote.xhtml#ch02fn11">11</a></sup> Your users will download these packages, unpack them, and enter <code>./configure &amp;&amp; make</code> from the top-level project directory. The <code>configure</code> script will generate makefiles (called <em>Makefile</em>) from the <em>Makefile.in</em> templates created by <code>automake</code> and a <em>config.h</em> header file from the <em>config.h.in</em> template generated by <code>autoheader</code>.</p>&#13;
<p class="indent">Automake generates <em>Makefile.in</em> templates rather than makefiles because without makefiles, your users can’t run <code>make</code>; you don’t want them to run <code>make</code> until after they’ve run <code>configure</code>, and this functionality guards against them doing so. <em>Makefile.in</em> templates are nearly identical to makefiles you might <span epub:type="pagebreak" id="page_27"/>write by hand, except that you didn’t have to. They also do a lot more than most people are willing to hand-code. Another reason for not shipping ready-to-run makefiles is that it gives <code>configure</code> the chance to insert platform characteristics and user-specified optional features directly into the makefiles. This makes them a better fit for their target platforms and the end user’s build preferences. Finally, the makefiles can also be generated outside the source tree, which means you can create custom build systems in different directories for the same source directory tree. I’ll discuss this topic in greater detail in “Building Outside the Source Directory” on <a href="ch02.xhtml#page_28">page 28</a>.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch02fig05">Figure 2-5</a> illustrates the interaction between <code>configure</code> and the scripts it executes during the configuration process in order to create the makefiles and the <em>config.h</em> header file.</p>&#13;
<div class="image"><img src="../images/02fig05.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch02fig05"><em>Figure 2-5:  A data flow diagram for <code>configure</code></em></p>&#13;
<p class="indent">The <code>configure</code> script has a bidirectional relationship with another script called <code>config.status</code>. You may have thought that your <code>configure</code> script generated your makefiles. But actually, the only file (besides a log file) that <code>configure</code> generates is <code>config.status</code>.</p>&#13;
<p class="indent">The <code>configure</code> script is designed to determine platform characteristics and features available on the user’s system, as specified in the maintainer-written <em>configure.ac</em>. Once it has this information, it generates <code>config.status</code>, which contains all of the check results, and then it executes this script. The <code>config.status</code> script, in turn, uses the check information embedded within it to generate platform-specific <em>config.h</em> and makefiles, as well as any other template-based output files specified in <em>configure.ac</em>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>As the double-ended fat arrow in <a href="ch02.xhtml#ch02fig05">Figure 2-5</a> shows, <em><code>config.status</code></em> can also call <em><code>configure</code></em>. When used with the <em><code>--recheck</code></em> option, <em><code>config.status</code></em> will call <em><code>configure</code></em> using the same command line options used to originally generate <em><code>config.status</code></em>.</em></p>&#13;
</div>&#13;
<p class="indent">The <code>configure</code> script also generates a log file called <em>config.log</em>, which will contain very useful information in the event that an execution of <code>configure</code> fails on the user’s system. As the maintainer, you can use this information <span epub:type="pagebreak" id="page_28"/>for debugging. The <em>config.log</em> file also logs how <code>configure</code> was executed. (You can run <code>config.status --version</code> to discover the command line options used to generate <code>config.status</code>.) This feature can be particularly handy when, for example, a user returns from vacation and can’t remember which options they used to originally generate the project build directory.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>To regenerate makefiles and the</em> config.h <em>header files, just enter</em> <em><code>./config.status</code></em> <em>from within the project build directory. The output files will be generated using the same options originally used to generate</em> <em><code>config.status</code></em>.</p>&#13;
</div>&#13;
<p class="indent">The <em>config.site</em> file can be used to customize the way <code>configure</code> works based on the <code>--prefix</code> option passed to it. The <em>config.site</em> file is a script, but it’s not meant to be executed directly. Rather, <code>configure</code> looks for <em>$(prefix)/share/config</em><em>.</em><em>site</em> and “sources” it (incorporates it as part of its own script) before executing any of its own code. This can be a handy way of specifying the same set of options for many packages, all destined to be built and installed the same way. Since <code>configure</code> is just a shell script, <em>config.site</em> should just contain shell code.</p>&#13;
<p class="indent">The <em>config.cache</em> file is generated by <code>configure</code> when the <code>-C</code> or <code>--config-cache</code> options are used. The results of configuration tests are cached in this file and are reusable by subdirectory <code>configure</code> scripts or by future runs of <code>configure</code>. By default, <em>config.cache</em> is disabled because it can be a potential source of configuration errors. If you’re confident with your configuration process, <em>config.cache</em> can really speed up the configuration process between executions of <code>configure</code>.</p>&#13;
<h5 class="h5">Building Outside the Source Directory</h5>&#13;
<p class="noindent">A little-known feature of Autotools build environments is that they don’t need to be generated within a project source tree. That is, if a user executes <code>configure</code> from a directory other than the project source directory, they can generate a full build environment within an isolated build directory.</p>&#13;
<p class="indent">In the following example, the user downloads <em>doofabble-3.0.tar.gz</em>, unpacks it, and creates two sibling directories called <em>doofabble-3.0.debug</em> and <em>doofabble-3.0.release</em>. They change into the <em>doofabble-3.0.debug</em> directory; execute doofabble’s <code>configure</code> script, using a relative path, with a doofabble-specific <code>debug</code> option; and then run <code>make</code> from within this same directory. Then they switch over to the <em>doofabble-3.0.release</em> directory and do the same thing, this time running <code>configure</code> without the <code>debug</code> option:</p>&#13;
<pre>$ <span class="codestrong1">gzip -dc doofabble-3.0.tar.gz | tar xf -</span>&#13;
$ <span class="codestrong1">mkdir doofabble-3.0.debug</span>&#13;
$ <span class="codestrong1">mkdir doofabble-3.0.release</span>&#13;
$ <span class="codestrong1">cd doofabble-3.0.debug</span>&#13;
$ <span class="codestrong1">../doofabble-3.0/configure --enable-debug</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">make</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">cd ../doofabble-3.0.release</span>&#13;
$ <span class="codestrong1">../doofabble-3.0/configure</span>&#13;
<span epub:type="pagebreak" id="page_29"/><span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">make</span>&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="indent">Users generally don’t care about remote build functionality, because all they usually want to do is configure, build, and install your code on their platforms. Maintainers, on the other hand, find remote build functionality very useful, as it allows them to not only maintain a reasonably pristine source tree but also to maintain multiple build environments for their project, each with complex configuration options. Rather than reconfigure a single build environment, a maintainer can simply switch to another build directory that has been configured with different options.</p>&#13;
<p class="indent">There is one case, however, where a user might wish to use remote-build. Consider the case where one obtains the full unpacked source code of a project on CD or has access to it via a read-only NFS mount. The ability to build outside the source tree can grant the ability to build the project without having to copy it to writable media.</p>&#13;
<h4 class="h4" id="ch02sec10-2"><em>Running make</em></h4>&#13;
<p class="noindent">Finally, you run plain old <code>make</code>. The designers of the Autotools went to a <em>lot</em> of trouble to ensure that you didn’t need any special version or brand of <code>make</code>. <a href="ch02.xhtml#ch02fig06">Figure 2-6</a> depicts the interaction between <code>make</code> and the makefiles that are generated during the build process.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>There has been some discussion on the Autotools mailing lists during the last few years about supporting only GNU <em><code>make</code></em>, as modern GNU <em><code>make</code></em> is so much more functional than other <em><code>make</code></em> utilities. Almost all Unix-y platforms (and even Microsoft Windows) have a version of GNU <em><code>make</code></em> today, so the rationale for continuing to support other brands of <em><code>make</code></em> is no longer as important as it once was.</em></p>&#13;
</div>&#13;
<p class="indent">As you can see, <code>make</code> runs several generated scripts, but these are all really ancillary to the <code>make</code> process. The generated makefiles contain commands that execute these scripts under the appropriate conditions. These scripts are part of the Autotools, and they are either shipped with your package or generated by your configuration script.</p>&#13;
<div class="image"><img src="../images/02fig06.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch02fig06"><em>Figure 2-6:  A data flow diagram for <code>make</code></em></p>&#13;
<h3 class="h3" id="ch02sec11"><span epub:type="pagebreak" id="page_30"/>Installing the Most Up-to-Date Autotools</h3>&#13;
<p class="noindent">If you’re running a variant of Linux and you’ve chosen to install the compilers and tools used for developing C-language software, you probably already have some version of the Autotools installed on your system. To determine which versions of Autoconf, Automake, and Libtool you’re using, simply open a terminal window and type the following commands (if you don’t have the <code>which</code> utility on your system, try <span class="codestrong1">type -p</span> instead):</p>&#13;
<pre>$ <span class="codestrong1">which autoconf</span>&#13;
/usr/local/bin/autoconf&#13;
$&#13;
$ <span class="codestrong1">autoconf --version</span>&#13;
autoconf (GNU Autoconf) 2.69&#13;
Copyright (C) 2012 Free Software Foundation, Inc.&#13;
License GPLv3+/Autoconf: GNU GPL version 3 or later&#13;
&lt;http://gnu.org/licenses/gpl.html&gt;, &lt;http://gnu.org/licenses/exceptions.html&gt;&#13;
This is free software: you are free to change and redistribute it.&#13;
There is NO WARRANTY, to the extent permitted by law.&#13;
&#13;
Written by David J. MacKenzie and Akim Demaille.&#13;
$&#13;
$ <span class="codestrong1">which automake</span>&#13;
/usr/local/bin/automake&#13;
$&#13;
$ <span class="codestrong1">automake --version</span>&#13;
automake (GNU automake) 1.15&#13;
Copyright (C) 2014 Free Software Foundation, Inc.&#13;
License GPLv2+: GNU GPL version 2 or later &lt;http://gnu.org/licenses/gpl-2.0.html&gt;&#13;
This is free software: you are free to change and redistribute it.&#13;
There is NO WARRANTY, to the extent permitted by law.&#13;
&#13;
Written by Tom Tromey &lt;tromey@redhat.com&gt;&#13;
       and Alexandre Duret-Lutz &lt;adl@gnu.org&gt;.&#13;
$&#13;
$ <span class="codestrong1">which libtool</span>&#13;
/usr/local/bin/libtool&#13;
$&#13;
$ <span class="codestrong1">libtool --version</span>&#13;
&#13;
libtool (GNU libtool) 2.4.6&#13;
Written by Gordon Matzigkeit, 1996&#13;
&#13;
Copyright (C) 2014 Free Software Foundation, Inc.&#13;
This is free software; see the source for copying conditions.  There is NO&#13;
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&#13;
$</pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you have the Linux-distribution varieties of these Autotools packages installed on your system, the executables will probably be found in</em> /usr/bin <em>rather than</em> /usr/local/bin, <em>as you can see from the output of the <em><code>which</code></em> command here.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_31"/>If you choose to download, build, and install the latest released version of any one of these packages from the GNU website, you must do the same for all of them, because the Automake and Libtool packages install macros into the Autoconf macro directory. If you don’t already have the Autotools installed, you can install them using your system package manager (for example, <code>yum</code> or <code>apt</code>), or from source, using their GNU distribution source archives. The latter can be done with the following commands (be sure to change the version numbers as necessary):</p>&#13;
<pre>$ <span class="codestrong1">mkdir autotools &amp;&amp; cd autotools</span>&#13;
$ <span class="codestrong1">wget -q https://ftp.gnu.org/gnu/autoconf/autoconf-2.69.tar.gz</span>&#13;
$ <span class="codestrong1">wget -q https://ftp.gnu.org/gnu/autoconf/autoconf-2.69.tar.gz.sig</span>&#13;
$ <span class="codestrong1">gpg autoconf-2.69.tar.gz.sig</span>&#13;
gpg: assuming signed data in `autoconf-2.69.tar.gz'&#13;
gpg: Signature made Tue 24 Apr 2012 09:17:04 PM MDT using RSA key ID 2527436A&#13;
gpg: Can't check signature: public key not found&#13;
$&#13;
$ <span class="codestrong1">gpg --keyserver keys.gnupg.net --recv-key 2527436A</span>&#13;
gpg: requesting key 2527436A from hkp server keys.gnupg.net&#13;
gpg: key 2527436A: public key "Eric Blake &lt;eblake@redhat.com&gt;" imported&#13;
gpg: key 2527436A: public key "Eric Blake &lt;eblake@redhat.com&gt;" imported&#13;
gpg: no ultimately trusted keys found&#13;
gpg: Total number processed: 2&#13;
gpg:               imported: 2    (RSA: 2)$ gpg autoconf-2.69.tar.gz.sig&#13;
gpg: assuming signed data in `autoconf-2.69.tar.gz'&#13;
gpg: Signature made Tue 24 Apr 2012 09:17:04 PM MDT using RSA key ID 2527436A&#13;
gpg: Good signature from "Eric Blake &lt;eblake@redhat.com&gt;"&#13;
gpg:                 aka "Eric Blake (Free Software Programmer) &lt;ebb9@byu.net&gt;"&#13;
gpg:                 aka "[jpeg image of size 6874]"&#13;
gpg: WARNING: This key is not certified with a trusted signature!&#13;
gpg:          There is no indication that the signature belongs to the owner.&#13;
Primary key fingerprint: 71C2 CC22 B1C4 6029 27D2    F3AA A7A1 6B4A 2527 436A&#13;
$&#13;
$ <span class="codestrong1">gzip -cd autoconf* | tar xf -</span>&#13;
$ <span class="codestrong1">cd autoconf*/</span>&#13;
$ <span class="codestrong1">./configure &amp;&amp; make all check</span>&#13;
        # note – a few tests (501 and 503, for example) may fail&#13;
        # – this is fine for this release)&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">sudo make install</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">cd ..</span>&#13;
$ <span class="codestrong1">wget -q https://ftp.gnu.org/gnu/automake/automake-1.16.1.tar.gz</span>&#13;
$ <span class="codestrong1">wget -q https://ftp.gnu.org/gnu/automake/automake-1.16.1.tar.gz.sig</span>&#13;
$ <span class="codestrong1">gpg automake-1.16.1.tar.gz.sig</span>&#13;
gpg: assuming signed data in `automake-1.16.1.tar.gz'&#13;
gpg: Signature made Sun 11 Mar 2018 04:12:47 PM MDT using RSA key ID 94604D37&#13;
gpg: Can't check signature: public key not found&#13;
$&#13;
$ <span class="codestrong1">gpg --keyserver keys.gnupg.net --recv-key 94604D37</span>&#13;
gpg: requesting key 94604D37 from hkp server keys.gnupg.net&#13;
gpg: key 94604D37: public key "Mathieu Lirzin &lt;mthl@gnu.org&gt;" imported&#13;
gpg: no ultimately trusted keys found&#13;
gpg: Total number processed: 1&#13;
<span epub:type="pagebreak" id="page_32"/>gpg:               imported: 1    (RSA: 1)&#13;
$&#13;
$ <span class="codestrong1">gpg automake-1.16.1.tar.gz.sig</span>&#13;
gpg: assuming signed data in `automake-1.16.1.tar.gz'&#13;
gpg: Signature made Sun 11 Mar 2018 04:12:47 PM MDT using RSA key ID 94604D37&#13;
gpg: Good signature from "Mathieu Lirzin &lt;mthl@gnu.org&gt;"&#13;
gpg:                 aka "Mathieu Lirzin &lt;mthl@openmailbox.org&gt;"&#13;
gpg:                 aka "Mathieu Lirzin &lt;mathieu.lirzin@openmailbox.org&gt;"&#13;
gpg: WARNING: This key is not certified with a trusted signature!&#13;
gpg:          There is no indication that the signature belongs to the owner.&#13;
Primary key fingerprint: F2A3 8D7E EB2B 6640 5761    070D 0ADE E100 9460 4D37&#13;
$&#13;
$ <span class="codestrong1">gzip -cd automake* | tar xf -</span>&#13;
$ <span class="codestrong1">cd automake*/</span>&#13;
$ <span class="codestrong1">./configure &amp;&amp; make all check</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">sudo make install</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">cd ..</span>&#13;
$ <span class="codestrong1">wget -q https://ftp.gnu.org/gnu/libtool/libtool-2.4.6.tar.gz</span>&#13;
$ <span class="codestrong1">wget -q https://ftp.gnu.org/gnu/libtool/libtool-2.4.6.tar.gz.sig</span>&#13;
$ <span class="codestrong1">gpg libtool-2.4.6.tar.gz.sig</span>&#13;
gpg: assuming signed data in `libtool-2.4.6.tar.gz'&#13;
gpg: Signature made Sun 15 Feb 2015 01:31:09 PM MST using DSA key ID 2983D606&#13;
gpg: Can't check signature: public key not found&#13;
$&#13;
$ <span class="codestrong1">gpg --keyserver keys.gnupg.net --recv-key 2983D606</span>&#13;
gpg: requesting key 2983D606 from hkp server keys.gnupg.net&#13;
gpg: key 2983D606: public key "Gary Vaughan (Free Software Developer) &lt;gary@vaughan.pe&gt;" imported&#13;
gpg: key 2983D606: public key "Gary Vaughan (Free Software Developer) &lt;gary@vaughan.pe&gt;" imported&#13;
gpg: no ultimately trusted keys found&#13;
gpg: Total number processed: 2&#13;
gpg:               imported: 2    (RSA: 1)&#13;
$&#13;
$ <span class="codestrong1">gpg libtool-2.4.6.tar.gz.sig</span>&#13;
gpg: assuming signed data in `libtool-2.4.6.tar.gz'&#13;
gpg: Signature made Sun 15 Feb 2015 01:31:09 PM MST using DSA key ID 2983D606&#13;
gpg: Good signature from "Gary Vaughan (Free Software Developer) &lt;gary@vaughan.pe&gt;"&#13;
gpg:                 aka "Gary V. Vaughan &lt;gary@gnu.org&gt;"&#13;
gpg:                 aka "[jpeg image of size 9845]"&#13;
gpg: WARNING: This key is not certified with a trusted signature!&#13;
gpg:          There is no indication that the signature belongs to the owner.&#13;
Primary key fingerprint: CFE2 BE70 7B53 8E8B 2675    7D84 1513 0809 2983 D606&#13;
$&#13;
$ <span class="codestrong1">gzip -cd libtool* | tar xf -</span>&#13;
$ <span class="codestrong1">cd libtool*/</span>&#13;
$ <span class="codestrong1">./configure &amp;&amp; make all check</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">sudo make install</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">cd ..</span>&#13;
$</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_33"/>The preceding example shows how to use the associated <em>.sig</em> files to validate the signature on GNU packages. The example assumes you have not configured a gpg key server on your system and that you have not installed the public key for any of these packages. If you have already configured a preferred key server, you can skip the <code>gpg</code> command line <code>--keyserver</code> options. Once you’ve imported the public keys for these packages, you need not do it again.</p>&#13;
<p class="indent">You may also wish to install in a manner that does not require root access via <code>sudo</code>. To do this, execute <code>configure</code> with a <code>--prefix</code> option such as <code>--prefix=$HOME/autotools</code> and then add <em>~/autotools/bin</em> to your <code>PATH</code> environment variable.</p>&#13;
<p class="indent">You should now be able to successfully execute the version-check commands from the previous example. If you still see older versions, ensure your <code>PATH</code> environment variable properly contains <em>/usr/local/bin</em> (or wherever you installed to) before <em>/usr/bin</em>.</p>&#13;
<h3 class="h3" id="ch02sec12">Summary</h3>&#13;
<p class="noindent">In this chapter, I presented a high-level overview of the Autotools to give you a feel for how everything ties together. I also showed you the pattern to follow when building software from distribution tarballs created by Autotools build systems. Finally, I showed you how to install the Autotools and how to tell which versions you have installed.</p>&#13;
<p class="indent">In <a href="ch03.xhtml">Chapter 3</a>, we’ll step away from the Autotools briefly and begin creating a hand-coded build system for a toy project called <em>Jupiter</em>. You’ll learn the requirements of a reasonable build system, and you’ll become familiar with the rationale behind the original design of the Autotools. With this background knowledge, you’ll begin to understand why the Autotools do things the way they do. I can’t really emphasize this enough: <em><a href="ch03.xhtml">Chapter 3</a> is one of the most important chapters in this book, because it will get you past any emotional stigma you may have associated with the Autotools due to misconceptions</em>.<span epub:type="pagebreak" id="page_34"/></p>&#13;
</body></html>