<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="introduction" role="doc-introduction" aria-labelledby="int">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxv" aria-label="xxv"/>&#13;
<hgroup>&#13;
&#13;
<h1 class="FMH" id="int"><span class="SANS_Dogma_OT_Bold_B_11">INTRODUCTION</span></h1>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="378" height="378"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Welcome to <i>The Art of ARM Assembly</i>. This book will teach you how to program 64-bit ARM CPUs, such as those found in modern Apple macOS machines, ARM-based Linux systems (including the Raspberry Pi with a 64-bit version of Raspberry Pi OS, previously known as Raspbian, which I’ll just call Pi OS), and even mobile devices such as iPhones, iPads, and some Android devices. With the arrival of the ARM-based Apple macOS systems, the need to learn and understand 64-bit ARM assembly language increased dramatically, leading me to write this book. However, I’ve made the source code and other information in this book as portable as possible so that it applies to all 64-bit ARM machines.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxvi" aria-label="xxvi"/>This book is a sister volume to <i>The Art of 64-Bit Assembly</i>, which was, itself, a rewrite of <i>The Art of Assembly Language Programming</i> (<i>AoA</i>). <i>AoA</i> was a project I began way back in 1989 as a tool for teaching 80x86 (x86) assembly-language programming to students at California State Polytechnic University, Pomona, and the University of California, Riverside. For over 25 years, <i>AoA</i> served as a guide for learning x86 assembly language programming. During that time, other processors came and went, but x86 remained king of the hill in personal computers and high-end workstations, and x86 assembly language remained the de facto assembly language to learn. However, ARM-based PCs became mainstream with the introduction of the Apple M1-based systems (and later Apple machines), so the need to learn ARM assembly language programming is increasing.</p>&#13;
<p class="TX">This book was written using <i>The Art of 64-Bit Assembly</i> as a model for the material to cover. Anyone who has read my earlier books will find this book to be very familiar at a high level. Of course, the ARM instructions and assemblers—either the GNU assembler (Gas) or Apple’s Clang assembler (largely compatible with Gas)—are quite different from the x86 instructions and the Microsoft Macro Assembler (MASM). The low-level presentation and programming techniques are therefore also somewhat different.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h2 class="H1" id="sec1"><span id="h1-1"/><span class="SANS_Futura_Std_Bold_B_11">0.1 A Brief History of the ARM CPU</span></h2>&#13;
<p class="TNI1">The ARM CPU has a long and storied history. It was first developed by Acorn Computers Ltd. in late 1983 as a replacement for the venerable 8-bit 6502 CPU used in its BBC Micro system. <i>ARM</i> originally stood for <i>Acorn RISC Machine</i>, though this was later changed to <i>Advanced RISC Machine</i> (<i>RISC</i> stands for <i>reduced instruction set computer</i>). That original design was largely a mind meld between the design described in the early University of California, Berkeley, RISC design and the 6502 CPU. For this reason, many would argue that the ARM initially wasn’t a pure RISC design. We might think of the ARM as the spiritual successor to the 6502, inheriting many of the 6502’s features.</p>&#13;
<p class="TX">In many respects, the ARM CPU is modeled on the 6502 CPU’s notion of a reduced instruction set computer. In the original RISC design, each instruction was designed to do as little work as possible so it would require less hardware support and could run faster. Pure RISC architectures, for example, generally don’t use condition code bits (as setting condition codes after the execution of an instruction would require the CPU do extra work), and use fixed-size machine instruction encodings (typically 32 bits). The 6502, on the other hand, attempted to reduce the total <i>number</i> of machine instructions as much as possible.</p>&#13;
<p class="TX">Additionally, the original ARM supported both 16-bit and 32-bit instruction encodings. While pure RISC CPUs try to maximize the number of general-purpose registers (generally 32), the original ARM design supported only 16. Furthermore, the ARM used one of the general-purpose registers as the program counter, which allows for all kinds of <span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxvii" aria-label="xxvii"/>programming tricks but creates problems for pure RISC designs (such as handling exceptions). Finally, the ARM partially supported a hardware stack, something you don’t see on pure RISC machines. Nevertheless, “pure” or not, the ARM design outlasted all the other RISC CPUs of that era.</p>&#13;
<p class="TX">Over the years, the ARM CPU variants have largely been used in mobile and embedded applications, with the vast majority of ARM CPUs winding up in mobile phones and tablets. However, one notable use is in the Raspberry Pi computer system (with over 61 million units sold as of this writing). In addition to the Pi, millions of ARM-based Arduino-compatible and other single-board computers (such as the Teensy series) have been sold. At the time of writing, the Raspberry Pi Foundation released the Raspberry Pi Pico, an ARM-based microcontroller board for $4 (US), selling more than 4 million of these devices by January 2024.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h2 class="H1" id="sec2"><span id="h1-2"/><span class="SANS_Futura_Std_Bold_B_11">0.2 Why Learn ARM Assembly?</span></h2>&#13;
<p class="TNI1">RISC CPUs were designed to be programmed using high-level languages (especially C/C++). Very few programs of note have been written in RISC assembly language (though the original ARM Basic is a good counterexample). The main reason assembly language is taught in colleges and universities is to teach <i>machine organization</i> (an introduction to the machine’s architecture). In addition, some applications (or, at the very least, portions of some applications) can benefit from an assembly language implementation. Speed and space are the two main reasons for using assembly language, though it is also true that certain algorithms are more easily written in assembly language (particularly bit-handling operations).</p>&#13;
<p class="TX">Finally, learning assembly language can help you write much better high-level language code. After all, a compiler for a language like C/C++ translates that high-level source code into assembly language. Understanding the underlying machine language will help you write better high-level language (HLL) code because you can avoid inefficient HLL constructs. This understanding can also be helpful when debugging or optimizing HLL code. Sometimes you must look at the code that the compiler generated to understand a bug or inefficiency.</p>&#13;
<p class="TX">So why a book on ARM assembly language in particular? Until the Apple Silicon M1 CPU came along, the only common personal computer using an ARM CPU was the Raspberry Pi. While the Pi was popular, it generally wasn’t being used in schools to teach machine organization and assembly language programming. A few hobbyists were probably interested in picking up ARM assembly language on their own, but most Pi programmers were using Scratch or Python, with the hard-core types programming in C/C++. While mobile devices such as iPhones, iPads, and Android phones and tablets are also popular, developers rarely consider switching from Objective-C, Swift, or Java into assembly language for applications on those devices.</p>&#13;
<p class="TX">However, once Apple released M1-based Mac minis, MacBooks, and iMacs, the situation changed. Interest in low-level programming on ARMs <span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxviii" aria-label="xxviii"/>spiked, because now ARM assembly could be taught in colleges and universities on “normal” machines. Apple has sold more A-series (iPad and iPhone) and M-series (iPad and Mac) systems than Raspberry Pi since they were introduced. It is conceivable that Apple will have sold around a billion ARM-based personal computers and mobile devices by the time you’re reading this.</p>&#13;
<p class="TX">Given these developments, a lot more people are going to be interested in assembly language programming on ARM CPUs. If you want to be able to write high-performance, efficient, and small code on this new crop of devices, learning ARM assembly language is the place to start.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h2 class="H1" id="sec3"><span id="h1-3"/><span class="SANS_Futura_Std_Bold_B_11">0.3 Why Learn 64-Bit ARM?</span></h2>&#13;
<p class="TNI1">Although the original ARM was a 32-bit CPU, Arm Holdings—the outfit that licenses the ARM design—introduced a 64-bit version in 2011. Apple introduced its 32-bit iPhone 5 a few years after that. Since then, most mobile and personal computer devices (including the Raspberry Pi 3, 4, and 400) have used 64-bit CPUs, while embedded devices have largely stuck with the 32-bit CPU variants. Code written for 32-bit CPUs is generally more memory efficient than that for 64-bit CPUs; unless an application requires more than 4GB, using a 32-bit instruction set is usually better.</p>&#13;
<p class="TX">Nevertheless, for high-performance computing, 64 bits is definitely the future. Why is this the case? Can’t 64-bit ARM CPUs run the older 32-bit code? The answer is a qualified yes. For example, the Raspberry Pi provides a 32-bit OS that runs only 32-bit code, even when running on a 64-bit CPU such as on the Pi 3, 4, or 400. However, the 64-bit ARM CPUs (ARMv8 or AARCH64, informally abbreviated to ARM64) operate in one of two modes: 32-bit or 64-bit. When in 32-bit mode, they execute the 32-bit instruction set; when in 64-bit mode, they execute the 64-bit instruction set. Though these instruction sets have some similarities, they are not the same. Thus, when operating in one of these modes, you cannot execute the instructions from the other mode.</p>&#13;
<p class="TX">Given the incompatibility of the two instruction sets, this book focuses on 64-bit ARM assembly language. Since you can’t program the Apple M1 (and later) in 32-bit ARM assembly language, teaching 32-bit alone would be a nonstarter. Why not teach both? While knowing 32-bit assembly language would help readers who want to write code for the 32-bit Pi OS and other embedded single-board microcontrollers, this book aims to teach fundamentals. Teaching two different instruction sets complicates the educational experience; better to do one thing well (64-bit assembly) rather than two things poorly. Teaching both 32-bit and 64-bit assembly is almost like trying to teach x86-64 and ARM in the same book; it’s just too much to take in all at once. Moreover, the 32-bit operating modes will likely fade away entirely over time. As I write this, ARM has already introduced a variant that supports only 64-bit code; I expect all future desktop-class processors will head in this direction.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxix" aria-label="xxix"/>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Although concentrating on 64-bit ARM assembly language for desktop-class and mobile machines (such as iPhones) makes sense, some will want to learn 32-bit ARM assembly language to work with embedded devices. Arduino-based single-board computers (SBCs), Raspberry Pi Pico SBCs, and many other classes of ARM-based embedded systems use 32-bit ARM variants. Furthermore, if you’re operating a Raspberry Pi using a 32-bit version of Pi OS, you’ll need to use 32-bit ARM assembly language. For that reason,</i> <span class="note_Italic">The Art of ARM Assembly, Volume 2</span><i>, will cover 32-bit ARM assembly language on those systems.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h2 class="H1" id="sec4"><span id="h1-4"/><span class="SANS_Futura_Std_Bold_B_11">0.4 Expectations and Prerequisites</span></h2>&#13;
<p class="TNI1">This book assumes that you are already comfortable programming in an HLL such as C/C++ (preferred), Python, Swift, Java, Pascal, Ruby, BASIC, or another object-oriented or imperative (procedural) programming language. Although many programmers have successfully learned assembly language as their very first programming language, I recommend that you learn to <i>program</i> first, then learn assembly language programming. This book makes use of several HLL examples (typically in C/C++ or Pascal). The examples are generally simple, so you should be able to understand them if you know a different HLL.</p>&#13;
<p class="TX">This book also assumes you’re comfortable with the edit/compile/test/debug cycle during program development. You should be familiar with source code editors and using standard software development tools, as I won’t explain how to edit source files.</p>&#13;
<p class="TX">A wide variety of 64-bit ARM systems are out there, and I aimed to make this book applicable to as many of them as possible. To that end, every example program in this book has been tested on each of the following systems:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Apple M1-based Mac systems such as the Mac mini M1 and Mac mini M2. The book’s example code was tested on the mini M1 but should work on any of the ARM-based MacBooks or iMacs, as well as future M<i>x</i> systems.</li>&#13;
<li class="BL">Raspberry Pi 3, 4, 400, and 5 systems (and future 64-bit-capable Pi systems) running the 64-bit version of Pi OS.</li>&#13;
<li class="BL">PINE64 system including the Pinebook, Pinebook Pro, and ROCKPro 64.</li>&#13;
<li class="BL">Almost any 64-bit ARM-based Linux system.</li>&#13;
<li class="BL">NVIDIA Jetson Nano systems.</li>&#13;
</ul>&#13;
<p class="TX">In theory, it should be possible to apply the information in this book to ARM-based Windows machines (such as the Surface Laptop Copilot+). Unfortunately, Microsoft’s software development tools, particularly its assembler, are based on the original ARM assembly syntax defined by Arm (the company), not Gas. While Microsoft’s <i>armasm64</i> is a better tool in many respects (as it uses standard ARM assembly language syntax), everyone else uses Gas syntax. The machine instructions are more or less the same <span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxx" aria-label="xxx"/>between the two sets of assemblers, but the other statements (known as <i>assembler directives</i> or <i>pseudo-opcodes</i>) are completely different. Therefore, example programs written in Gas will not assemble under <i>armasm64</i>, and vice versa. Since trying to present both syntax forms in example programs would be just as confusing as trying to teach 32- and 64-bit programming simultaneously, I stick to Gas syntax in my examples.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h2 class="H1" id="sec5"><span id="h1-5"/><span class="SANS_Futura_Std_Bold_B_11">0.5 Source Code</span></h2>&#13;
<p class="TNI1">This book contains considerable ARM assembly language (and some C/C++) source code that typically comes in one of three forms: code snippets, single assembly language procedures or functions (modules), or full-blown programs.</p>&#13;
<p class="TX"><i>Code snippets</i> are fragments of a program; they are not stand-alone, and you cannot compile them by using an ARM assembler (or a C++ compiler, in the case of C/C++ source code). They exist to make a point or provide a small example of a particular programming technique. Here is a typical example:</p>&#13;
<pre id="pre-1"><code>     .data&#13;
i64  .quad   0&#13;
      .&#13;
      .&#13;
      .&#13;
     ldr     x1, i64</code></pre>&#13;
<p class="TX">The vertical ellipses denote arbitrary code that could appear in their place.</p>&#13;
<p class="TX"><i>Modules</i> are small blocks of code that can be compiled but won’t run on their own. Modules typically contain a function that will be called by another program. Here is a typical example:</p>&#13;
<pre id="pre-2"><code>someFunc:&#13;
        add x0, x1, x2&#13;
        sub x0, x0, x3&#13;
        ret</code></pre>&#13;
<p class="TX">Full-blown programs are called <i>listings</i> in this book, and I refer to them by listing number or filename. A typical filename usually takes the form <i>Listing</i>C<i>-</i>N<i>.S</i>, where C is the chapter number and N is a listing number within that chapter. For example, the following <i>Listing1-1.S</i> is the first listing that appears in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>:</p>&#13;
<pre id="pre-3"><code>// Listing1-1.S&#13;
//&#13;
// Comments consist of all text from a //&#13;
// sequence to the end of the line.&#13;
// The .text directive tells MASM that the&#13;
// statements following this directive go in&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxxi" aria-label="xxxi"/>// the section of memory reserved for machine&#13;
// instructions (code).&#13;
&#13;
        .text&#13;
&#13;
// Here is the main function.&#13;
// (This example assumes that the&#13;
// assembly language program is a&#13;
// stand-alone program with its own&#13;
// main function.)&#13;
//&#13;
// Under macOS, the main program&#13;
// must have the name _main&#13;
// beginning with an underscore.&#13;
// Linux systems generally don't&#13;
// require the underscore.&#13;
//&#13;
// The .global _main statement&#13;
// makes the _main procedure's name&#13;
// visible outside this source file&#13;
// (needed by the linker to produce&#13;
// an executable).&#13;
&#13;
        .global _main&#13;
&#13;
// The .align 2 statement tells the&#13;
// assembler to align the following code&#13;
// on a 4-byte boundary (required by the&#13;
// ARM CPU). The 2 operand specifies&#13;
// 2 raised to this power (2), which&#13;
// is 4.&#13;
&#13;
        .align 2&#13;
&#13;
// Here's the actual main program. It&#13;
// consists of a single ret (return)&#13;
// instruction that simply returns&#13;
// control to the operating system.&#13;
&#13;
_main:&#13;
        ret</code></pre>&#13;
<p class="TX">Although most listings take the form <i>Listing</i>C<i>-</i>N<i>.S</i>, some (especially those from external sources) simply consist of a descriptive filename, such as the <i>aoaa.inc</i> header file used by most of the sample programs in this book.</p>&#13;
<p class="TX">All listings are available in electronic form at <i><a href="https://artofarm.randallhyde.com">https://<wbr/>artofarm<wbr/>.randallhyde<wbr/>.com</a></i>, either individually or as a ZIP file containing all the listings found in this book. That page also contains support information for this book, including errata and PowerPoint slides for instructors.</p>&#13;
<p class="TX">Most of the programs in this book run from a command line. These examples typically use the bash shell interpreter. Therefore, every <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output will typically have the text prefix <span class="SANS_TheSansMonoCd_W5Regular_11">$</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">%</span> before any command you would type from the keyboard on the command line. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxxii" aria-label="xxxii"/>Under macOS, the default shell (command line) program is zsh. It prints a percent sign (<span class="SANS_TheSansMonoCd_W5Regular_11">%</span>) rather than <span class="SANS_TheSansMonoCd_W5Regular_11">$</span> as the prompt character. If you are completely unfamiliar with the Linux or macOS command line, please see <span class="Xref"><a href="appendix-D.xhtml">Appendix D</a></span> for a quick introduction to the command line interpreter.</p>&#13;
<p class="TX">Unless otherwise noted, all source code appearing in this book is covered under the Creative Commons 4.0 license. You may freely use that code in your own projects as per the Creative Commons license. See <i><a href="https://creativecommons.org/licenses/by/4.0/">https://<wbr/>creativecommons<wbr/>.org<wbr/>/licenses<wbr/>/by<wbr/>/4<wbr/>.0<wbr/>/</a></i> for more details.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h2 class="H1" id="sec6"><span id="h1-6"/><span class="SANS_Futura_Std_Bold_B_11">0.6 Typography and Pedantry</span></h2>&#13;
<p class="TNI1">Computer books have a habit of abusing the English language. This book is no exception. Whenever source code snippets appear in the middle of an English sentence, a conflict often arises between the grammar rules of the programming language and English. This section describes my choices for differentiating syntactical rules in English versus programming languages, in addition to a few other conventions.</p>&#13;
<p class="TX">First, this book uses a monospaced font to denote any text that appears as part of a program source file. This includes variable and procedure functions, program output, and user input to a program. Therefore, when you see something like <span class="SANS_TheSansMonoCd_W5Regular_11">get</span>, you know that the book is describing an identifier in a program, not commanding you to get something.</p>&#13;
<p class="TX">A few logic operations have names that also have common English meanings: AND, OR, and NOT. When using these terms as logic functions, this book uses all caps to help differentiate otherwise-confusing English statements. When using these terms as English, this book uses the standard typeset font. The fourth logic operator, exclusive or (XOR), doesn’t normally appear in English statements, but this book still capitalizes it.</p>&#13;
<p class="TX">In general, I always try to define any acronym or abbreviation the first time I use it. If I haven’t used the term in a while, I will often redefine it on that usage. The glossary in <span class="Xref"><a href="appendix-B.xhtml">Appendix B</a></span> also includes most of the acronyms appearing in this book.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h2 class="H1" id="sec7"><span id="h1-7"/><span class="SANS_Futura_Std_Bold_B_11">0.7 Organization</span></h2>&#13;
<p class="TNI1">This book is organized into 4 parts comprising 16 chapters and <a href="chapter6.xhtml">6</a> appendixes.</p>&#13;
<p class="TX"><a href="part1.xhtml">Part I</a>, Machine Organization, covers data types and machine architecture for the ARM processor:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><b><a href="chapter1.xhtml">Chapter 1</a>: Hello, World of Assembly Language</b>    Teaches you a small handful of instructions so you can experiment with the software development tools and write simple little programs.</p>&#13;
<p class="RunInPara"><b><a href="chapter2.xhtml">Chapter 2</a>: Data Representation and Operations</b>    Discusses the internal representation of simple data types such as integers, characters, and Boolean values. It also discusses the various arithmetic and logical operations possible on these data types. This chapter also introduces some basic ARM assembly language operand formats.</p>&#13;
<p class="RunInPara"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxxiii" aria-label="xxxiii"/><b><a href="chapter3.xhtml">Chapter 3</a>: Memory Access and Organization</b>    Discusses how the ARM organizes main memory. It explains the layout of memory and how to declare and access memory variables. It also introduces the ARM’s methods for accessing memory and the stack (a place to store temporary values).</p>&#13;
<p class="RunInPara"><b><a href="chapter4.xhtml">Chapter 4</a>: Constants, Variables, and Data Types</b>    Describes how to declare named constants in assembly language, how to declare and use pointers, and the use of composite data structures such as strings, arrays, structs (records), and unions.</p>&#13;
</div>&#13;
<p class="TX"><a href="part2.xhtml">Part II</a>, Basic Assembly Language, provides the basic tools and instructions you need to write assembly language programs.</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><b><a href="chapter5.xhtml">Chapter 5</a>: Procedures</b>    Covers the instructions and syntax you need to write your own assembly language functions (procedures). This chapter describes how to pass arguments (parameters) to functions and return function results. It also describes how to declare (and use) local or automatic variables that you allocate on the stack.</p>&#13;
<p class="RunInPara"><b><a href="chapter6.xhtml">Chapter 6</a>: Arithmetic</b>    Explains the basic integer arithmetic and logical operations in ARM assembly language. It also describes how to convert arithmetic expressions from an HLL into ARM assembly language. Finally, this chapter covers floating-point arithmetic using the hardware-based floating-point instructions.</p>&#13;
<p class="RunInPara"><b><a href="chapter7.xhtml">Chapter 7</a>: Low-Level Control Structures</b>    Describes how to implement HLL-like control structures such as <span class="SANS_TheSansMonoCd_W5Regular_11">if</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">elseif</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">else</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">while</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">do...while</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">repeat...until</span>), <span class="SANS_TheSansMonoCd_W5Regular_11">for</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> in ARM assembly language. This chapter also touches on optimizing loops and other code in assembly language.</p>&#13;
</div>&#13;
<p class="TX"><a href="part3.xhtml">Part III</a>, Advanced Assembly Language, covers more advanced assembly language operations.</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><b><a href="chapter8.xhtml">Chapter 8</a>: Advanced Arithmetic</b>    Explores extended-precision arithmetic, mixed-mode arithmetic, and other advanced arithmetic operations.</p>&#13;
<p class="RunInPara"><b><a href="chapter9.xhtml">Chapter 9</a>: Numeric Conversion</b>    Provides a very useful set of library functions you can use to convert numeric values to string format and convert string values to numeric format.</p>&#13;
<p class="RunInPara"><b><a href="chapter10.xhtml">Chapter 10</a>: Table Lookups</b>    Describes how to use memory-based lookup tables (arrays) to accelerate certain computations.</p>&#13;
<p class="RunInPara"><b><a href="chapter11.xhtml">Chapter 11</a>: Neon and SIMD Programming</b>    Discusses the ARM Advanced SIMD instruction set that allows you to speed up certain applications by operating on multiple pieces of data at once.</p>&#13;
<p class="RunInPara"><b><a href="chapter12.xhtml">Chapter 12</a>: Bit Manipulation</b>    Describes various operations and functions that allow you to manipulate data at the bit level in ARM assembly language.</p>&#13;
<p class="RunInPara"><b><a href="chapter13.xhtml">Chapter 13</a>: Macros and the Gas Compile-Time Language</b>    Covers the Gas macro facilities. Macros are powerful constructs enabling you to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxxiv" aria-label="xxxiv"/>design your own assembly language statements that expand to a large number of individual ARM assembly language instructions.</p>&#13;
<p class="RunInPara"><b><a href="chapter14.xhtml">Chapter 14</a>: String Operations</b>    Explains the use and creation of various character string library functions in ARM assembly language.</p>&#13;
<p class="RunInPara"><b><a href="chapter15.xhtml">Chapter 15</a>: Managing Complex Projects</b>    Describes how to create libraries of assembly language code, and build those libraries by using makefiles (along with a discussion of the <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> language).</p>&#13;
<p class="RunInPara"><b><a href="chapter16.xhtml">Chapter 16</a>: Stand-Alone Assembly Language Programs</b>    Shows how to write assembly language applications that don’t use the C/C++ standard library for I/O and other operations. This chapter includes system call examples for both Linux (Pi OS) and macOS.</p>&#13;
</div>&#13;
<p class="TX"><a href="part4.xhtml">Part IV</a>, Reference Materials, provides reference information, including a table listing the full ASCII character set, a glossary, instructions for installing and using Gas on your system, an introduction to the bash shell interpreter, useful C/C++ functions you can call from your assembly language programs, and answers to the questions at the end of each chapter.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>