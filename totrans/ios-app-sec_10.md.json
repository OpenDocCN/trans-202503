["```\n- (void)connection:(NSURLConnection *)connection\n     willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)\n     challenge {\n    NSURLProtectionSpace *space = [challenge protectionSpace];\n    if([[space authenticationMethod] isEqualToString:NS\n     URLAuthenticationMethodServerTrust]) {\n        NSURLCredential *cred = [NSURLCredential credentialForTrust:\n     [space serverTrust]];\n        [[challenge sender] useCredential:cred forAuthenticationChallenge:\n     challenge];\n    }\n}\n```", "```\n- (void)connection:(NSURLConnection *)connection\n     willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)\n     challenge {\n    NSString *user = @\"user\";\n    NSString *pass = @\"pass\";\n\n    if ([[challenge protectionSpace] receivesCredentialSecurely] == YES &&\n        [[[challenge protectionSpace] host] isEqualToString:@\"myhost.com\"]) {\n\n    NSURLCredential *credential = [NSURLCredential credentialWithUser:user password\n     :pass persistence:NSURLCredentialPersistenceForSession];\n\n    [[challenge sender] useCredential:credential\n           forAuthenticationChallenge:challenge];\n    }\n}\n```", "```\n➊ NSURLProtectionSpace *protectionSpace = [[NSURLProtectionSpace alloc] initWithHost:\n        @\"myhost.com\" port:443 protocol:@\"https\" realm:nil authenticationMethod:nil];\n\n➋ NSURLCredential *credential = [NSURLCredential credentialWithUser:user password:\n        pass persistence:NSURLCredentialPersistencePermanent];\n\n➌ [[NSURLCredentialStorage sharedCredentialStorage] setDefaultCredential:credential\n        forProtectionSpace:protectionSpace];\n```", "```\ncredentialStorage = [[NSURLCredentialStorage sharedCredentialStorage]\n     defaultCredentialForProtectionSpace:protectionSpace];\n```", "```\n   - (void)connection:(NSURLConnection *) willSendRequestForAuthenticationChallenge:(\n        NSURLAuthenticationChallenge *)challenge {\n       if ([[[challenge protectionSpace] authenticationMethod] isEqualToString:NS\n        URLAuthenticationMethodClientCertificate]) {\n\n           SecIdentityRef identity;\n           SecTrustRef trust;\n➊         extractIdentityAndTrust(somep12Data, &identity, &trust);\n           SecCertificateRef certificate;\n➋         SecIdentityCopyCertificate(identity, &certificate);\n➌         const void *certificates[] = { certificate };\n➍         CFArrayRef arrayOfCerts = CFArrayCreate(kCFAllocatorDefault, certificates,\n        1, NULL);\n\n➎         NSURLCredential *cred = [NSURLCredential credentialWithIdentity:identity\n        certificates:(__bridge NSArray*)arrayOfCerts\n         persistence:NSURLCredentialPersistenceNone];\n➏         [[challenge sender] useCredential:cred\n                 forAuthenticationChallenge:challenge];\n       }\n   }\n```", "```\nNSData *myP12Certificate = [NSData dataWithContentsOfFile:path];\nCFDataRef somep12Data = (__bridge CFDataRef)myP12Certificate;\n```", "```\n   - (NSURLRequest *)connection:(NSURLConnection *)connection\n                willSendRequest:(NSURLRequest *)request\n               redirectResponse:(NSURLResponse *)redirectResponse\n   {\n       NSURLRequest *newRequest = request;\n➊     if (![[[redirectResponse URL] host] isEqual:@\"myhost.com\"]) {\n           return newRequest;\n       }\n\n       else {\n➋         newRequest = nil;\n           return newRequest;\n       }\n   }\n```", "```\n➊ - (NSData*)loadCertificateFromFile:(NSString*)fileName {\n       NSString *certPath = [[NSString alloc] initWithFormat:@\"%@/%@\", [[NSBundle\n        mainBundle] bundlePath], fileName];\n       NSData *certData = [[NSData alloc] initWithContentsOfFile:certPath];\n       return certData;\n   }\n\n   - (void)pinThings {\n   NSMutableDictionary *domainsToPin = [[NSMutableDictionary alloc] init];\n\n➋ NSData *myCertData = [self loadCertificateFromFile:@\"myCerts.der\"];\n   if (myCertData == nil) {\n       NSLog(@\"Failed to load the certificates\");\n       return;\n       }\n\n➌ [domainsToPin setObject:myCertData forKey:@\"myhost.com\"];\n\n➍ if ([SSLCertificatePinning loadSSLPinsFromDERCertificates:domainsToPin] != YES) {\n       NSLog(@\"Failed to pin the certificates\");\n       return;\n       }\n   }\n```", "```\n- (void)connection:(NSURLConnection *)connection\n     willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)\n     challenge {\n\n    if([challenge.protectionSpace.authenticationMethod isEqualToString:NS\n     URLAuthenticationMethodServerTrust]) {\n\n        SecTrustRef serverTrust = [[challenge protectionSpace] serverTrust];\n        NSString *domain = [[challenge protectionSpace] host];\n        SecTrustResultType trustResult;\n\n        SecTrustEvaluate(serverTrust, &trustResult);\n        if (trustResult == kSecTrustResultUnspecified) {\n\n            // Look for a pinned public key in the server's certificate chain\n            if ([SSLCertificatePinning verifyPinnedCertificateForTrust:serverTrust\n     andDomain:domain]) {\n\n                // Found the certificate; continue connecting\n                [challenge.sender useCredential:[NSURLCredential credentialForTrust\n     :challenge.protectionSpace.serverTrust] forAuthenticationChallenge:challenge];\n            }\n            else {\n                // Certificate not found; cancel the connection\n                [[challenge sender] cancelAuthenticationChallenge: challenge];\n            }\n        }\n        else {\n            // Certificate chain validation failed; cancel the connection\n            [[challenge sender] cancelAuthenticationChallenge: challenge];\n        }\n    }\n}\n```", "```\n➊ NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration\n        ephemeralSessionConfiguration];\n\n➋ [configuration setTLSMinimumSupportedProtocol = kTLSProtocol12];\n\n➌ NSURL *url = [NSURL URLWithString:@\"https://www.mycorp.com\"];\n\n   NSURLRequest *request = [NSURLRequest requestWithURL:url];\n\n➍ NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration\n                                                         delegate:self\n                                                    delegateQueue:nil];\n\n➎ NSURLSessionDataTask *task = [session dataTaskWithRequest:request\n                                           completionHandler:\n        ^(NSData *data, NSURLResponse *response, NSError *error) {\n➏         // Your completion handler block\n        }];\n\n➐ [task resume];\n```", "```\n   - (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NS\n        URLAuthenticationChallenge *)challenge completionHandler:(void (^)(NS\n        URLSessionAuthChallengeDisposition disposition, NSURLCredential * credential))\n        completionHandler {\n\n➊      completionHandler(NSURLSessionAuthChallengeUseCredential,\n          [challenge proposedCredential]);\n   }\n```", "```\n➊ - (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NS\n        URLAuthenticationChallenge *)challenge completionHandler:(void (^)(NS\n        URLSessionAuthChallengeDisposition, NSURLCredential *))completionHandler {\n       NSString *user = @\"user\";\n       NSString *pass = @\"pass\";\n\n       NSURLProtectionSpace *space = [challenge protectionSpace];\n        if ([space receivesCredentialSecurely] == YES &&\n            [[space host] isEqualToString:@\"myhost.com\"] &&\n            [[space authenticationMethod] isEqualToString:NS\n        URLAuthenticationMethodHTTPBasic]) {\n\n➋    NSURLCredential *credential =\n        [NSURLCredential credentialWithUser:user\n                                   password:pass\n                                persistence:NSURLCredentialPersistenceForSession];\n\n➌    completionHandler(NSURLSessionAuthChallengeUseCredential, credential);\n       }\n   }\n```", "```\n- (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NS\n     URLAuthenticationChallenge *)challenge completionHandler:(void (^)(NS\n     URLSessionAuthChallengeDisposition, NSURLCredential *))completionHandler {\n\n    NSURLCredential *credential =\n      [NSURLCredential credentialWithUser:user\n                                 password:pass\n                              persistence:NSURLCredentialPersistenceForSession];\n\n    completionHandler(NSURLSessionAuthChallengeUseCredential, credential);\n}\n```", "```\nNSURLSessionConfiguration *config = [NSURLSessionConfiguration\n     defaultSessionConfiguration];\n[config setURLCredentialStorage:\n    [NSURLCredentialStorage sharedCredentialStorage]];\n\nNSURLSession *session = [NSURLSession sessionWithConfiguration:config\n                                                      delegate:nil\n                                                 delegateQueue:nil];\n```", "```\nNSURLProtectionSpace *space = [[NSURLProtectionSpace alloc]\n     initWithHost:@\"myhost.com\"\n             port:443\n         protocol:@\"https\"\n            realm:nil authenticationMethod:nil];\n\nNSURLCredential *credential = [credentialStorage\n     defaultCredentialForProtectionSpace:space];\n\n[[NSURLCredentialStorage sharedCredentialStorage] removeCredential:credential\n                                                forProtectionSpace:space];\n```", "```\nNSDictionary *options = [NSDictionary dictionaryWithObjects forKeys:NS\n     URLCredentialStorageRemoveSynchronizableCredentials, YES];\n\n[[NSURLCredentialStorage sharedCredentialStorage] removeCredential:credential\n                                                forProtectionSpace:space\n                                                           options:options];\n```", "```\nNSURL *baseURL = [NSURL URLWithString:@\"https://myhost.com\"];\nAFHTTPClient* client = [AFHTTPClient clientWithBaseURL:baseURL];\n[client setAllowsInvalidSSLCertificate:YES];\n```", "```\nAFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];\n[manager [securityPolicy setAllowInvalidCertificates:YES]];\n```", "```\nif ([[url scheme] isEqualToString:@\"https\"] &&\n    [[url host] isEqualToString:@\"yourpinneddomain.com\"]) {\n        [self setDefaultSSLPinningMode:AFSSLPinningModePublicKey];\n    }\n\n    else {\n        [self setDefaultSSLPinningMode:AFSSLPinningModeNone];\n    }\n\n    return self;\n}\n```", "```\n// If defined, will use the specified function for debug logging\n// Otherwise use NSLog\n#ifndef ASI_DEBUG_LOG\n    #define ASI_DEBUG_LOG NSLog\n#endif\n\n// When set to 1, ASIHTTPRequests will print information about what a request is\n      doing\n#ifndef DEBUG_REQUEST_STATUS\n    #define DEBUG_REQUEST_STATUS 0\n#endif\n\n// When set to 1, ASIFormDataRequests will print information about the request body\n      to the console\n#ifndef DEBUG_FORM_DATA_REQUEST\n    #define DEBUG_FORM_DATA_REQUEST 0\n#endif\n\n// When set to 1, ASIHTTPRequests will print information about bandwidth throttling\n      to the console\n#ifndef DEBUG_THROTTLING\n    #define DEBUG_THROTTLING 0\n#endif\n\n// When set to 1, ASIHTTPRequests will print information about persistent\n      connections to the console\n#ifndef DEBUG_PERSISTENT_CONNECTIONS\n    #define DEBUG_PERSISTENT_CONNECTIONS 0\n#endif\n\n// When set to 1, ASIHTTPRequests will print information about HTTP authentication\n      (Basic, Digest or NTLM) to the console\n#ifndef DEBUG_HTTP_AUTHENTICATION\n    #define DEBUG_HTTP_AUTHENTICATION 0\n#endif\n```", "```\n#ifndef DEBUG_HTTP_AUTHENTICATION\n    #ifdef DEBUG\n        #define DEBUG_HTTP_AUTHENTICATION 1\n    #else\n        #define DEBUG_HTTP_AUTHENTICATION 0\n    #endif\n#endif\n```", "```\nMCPeerID *peerID = [[MCPeerID alloc] initWithDisplayName:@\"my device\"];\n\nMCSession *session = [[MCSession alloc] initWithPeer:peerID\n                                    securityIdentity:nil\n                                encryptionPreference:MCEncryptionRequired];\n```", "```\n- (void) session:(MCSession *)session didReceiveCertificate:(NSArray *)certificate\n     fromPeer:(MCPeerID *)peerID\n     certificateHandler:(void (^)(BOOL accept))certificateHandler\n{\n    certificateHandler(YES);\n}\n```", "```\nNSInputStream *inStream;\nNSOutputStream *outStream;\n\nCFReadStreamRef readStream;\nCFWriteStreamRef writeStream;\nCFStreamCreatePairWithSocketToHost(NULL, (CFStringRef)@\"myhost.com\", 80, &\n     readStream, &writeStream);\ninStream = (__bridge NSInputStream *)readStream;\noutStream = (__bridge NSOutputStream *)writeStream;\n```", "```\n   NSHost *myhost = [NSHost hostWithName:[@\"www.conglomco.com\"]];\n\n   [NSStream getStreamsToHostNamed:myhost\n                              port:443\n                       inputStream:&MyInputStream\n                      outputStream:&MyOutputStream];\n\n➊ [MyInputStream setProperty:NSStreamSocketSecurityLevelTLSv1\n                      forKey:NSStreamSocketSecurityLevelKey];\n```"]