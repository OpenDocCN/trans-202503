["```\n.include \"`filename`\"\n```", "```\n.include  \"print.inc\"\n.include  \"getTitle.inc\"\n```", "```\n#ifdef  myinclude_inc   // Filename: myinclude.inc\n#define myinclude_inc 1\n\n `Put all the source code lines for the include file here.`\n\n// The following statement should be the last nonblank line\n// in the source file:\n\n#endif  // myinclude_inc\n```", "```\n// Listing1-3.S\n//\n// A simple Gas module that contains\n// an empty function to be called by\n// the C++ code in Listing 1-2.\n\n .text\n\n// Here is the asmMain function:\n\n        .global asmMain\n        .align  2    // Guarantee 4-byte alignment.\nasmMain:\n\n// Empty function just returns to C++ code:\n\n        ret          // Returns to caller\n```", "```\n// extern \"C\" namespace prevents\n// \"name mangling\" by the C++\n// compiler.\n\nextern \"C\"\n{\n    // Here's the external function,\n    // written in assembly language,\n    // that this program will call:\n\n    void asmMain(void);\n    int readLine(char *dest, int maxLen);\n};\n```", "```\n// strings.inc\n//\n// String function header file for the assembly\n// language string format\n\n#ifndef  strings_inc\n#define strings_inc 1\n\n// Assembly language string data structure:\n\n            struct  string, -16\n            dword   string.allocPtr // At offset -16\n            word    string.maxlen   // At offset -8\n            word    string.len      // At offset -4\n            byte    string.chars    // At offset 0\n\n            // Note: characters in string occupy offsets\n            // 0 ... in this structure.\n\n            ends    string\n\n// str.buf\n//\n// Allocate storage for an empty string\n// with the specified maximum size:\n\n            .macro  str.buf strName, maxSize\n            .align  4   // Align on 16-byte boundary.\n            .dword  0   // NULL ptr for allocation ptr\n            .word   \\maxSize\n            .word   0\n\\strName:   .space  ((\\maxSize+16) & 0xFFFFFFF0), 0\n            .endm\n\n// str.literal\n//\n// Allocate storage for a string buffer and initialize\n// it with a string literal:\n\n            .macro  str.literal strName, strChars\n            .align  4   // Align on 16-byte boundary.\n            .dword  0   // NULL ptr for allocation ptr\n            .word   len_\\strName    // string.maxlen\n            .word   len_\\strName    // string.len\n\n            // Emit the string data and compute the\n            // string's length:\n\n\\strName:   .ascii  \"\\strChars\"\nlen_\\strName=       .-\\strName\n            .byte   0   // Zero-terminating byte\n\n // Ensure object is multiple of 16 bytes:\n\n            .align  4\n            .endm\n\n// str.len\n//\n//          Return the length of the string pointed at by X0.\n//          Returns length in X0\n\n            .macro  str.len\n            ldr     w0, [x0, #string.len]\n            .endm\n\n// External declarations:\n\n            .extern str.cpy\n            .extern str.cmp\n            .extern str.substr\n            .extern str.bufInit\n            .extern str.alloc\n            .extern str.free\n\n// This would be a good place to include external\n// declarations for any string functions you write.\n\n#endif\n```", "```\n// str.cpy.S\n//\n// A str.cpy string copy function\n\n            #include    \"aoaa.inc\"\n          ❶ #include    \"strings.inc\"\n\n            .code\n\n///////////////////////////////////////////////////////////\n//\n// str.cpy\n//\n// Copies the data from one string variable to another\n//\n// On entry:\n//\n// X0- Pointer to source string (string struct variable)\n// X1- Pointer to destination string\n//\n// On exit:\n//\n// Carry flag clear if no errors, carry is set if\n// the source string will not fit in the destination.\n\n ❷ proc    str.cpy, public\n\n            locals  str_cpy\n            qword   str_cpy.saveV0\n            qword   str_cpy.saveX2X3\n            dword   str_cpy.saveX4\n            byte    str_cpy.stkSpace,64\n            endl    str_cpy\n\n            enter   str_cpy.size\n\n            // Preserve X2 ... X4 and V0:\n\n            str     q0,     [fp, #str_cpy.saveV0]\n            stp     x2, x3, [fp, #str_cpy.saveX2X3]\n            str     x4,     [fp, #str_cpy.saveX4]\n\n            // Ensure the source will fit in the destination\n            // string object:\n\n            ldr     w4, [x0, #string.len]\n            ldr     w3, [x1, #string.maxlen]\n            cmp     w4, w3\n            bhi     str.cpy.done    // Note: carry is set.\n\n            // Set the length of the destination string\n            // to the length of the source string.\n\n            str     w4, [x1, #string.len]\n\n            // X4 contains the number of characters to copy;\n            // while this is greater than 16, copy 16 bytes\n            // at a time from source to dest:\n\n            mov     x2, x0  // Preserve X0 and X1.\n            mov     x3, x1\n\ncpy16:      ldr     q0, [x2], #16\n            str     q0, [x3], #16\n            subs    w4, w4, #16\n            bhi     cpy16\n\n// At this point, you have fewer than 16 bytes to copy. If\n// W4 is not 0, just copy 16 remaining bytes (you know,\n// because of the string data structure, that if you have at\n// least 1 byte left to copy, you can safely copy\n// 16 bytes):\n\n            beq     setZByte    // Skip if 0 bytes.\n\n            ldr     q0, [x2]\n            str     q0, [x3]\n\n// Need to add a zero-terminating byte to the end of\n// the string. Note that maxlen does not include the\n// 0 byte, so it's always safe to append the 0\n// byte to the end of the string.\n\nsetZByte:   ldr     w4,  [x0, #string.len]\n            strb    wzr, [x1, w4, uxtw]\n\n            adds    wzr, wzr, wzr   // Clears the carry\n\nstr.cpy.done:\n            ldr     q0,     [fp, #str_cpy.saveV0]\n            ldp     x2, x3, [fp, #str_cpy.saveX2X3]\n            ldr     x4,     [fp, #str_cpy.saveX4]\n            leave\n            endp    str.cpy\n```", "```\n./build -c str.cpy\n./build -c str.cmp\n./build -c str.substr\n./build -c str.bufInit\n./build -c str.alloc\n./build -c str.free\n```", "```\n// Listing15-1.S\n//\n// A program that calls various string functions\n\n            #include    \"aoaa.inc\"\n #include    \"strings.inc\"\n\n///////////////////////////////////////////////////////////\n\n            .data\n\n            str.buf     destination, 256\n            str.literal src,    \"String to copy\"\n            str.literal left,   \"some string\"\n            str.literal right1, \"some string\"\n            str.literal right2, \"some string.\"\n            str.literal right3, \"some string\"\n\n            str.buf     smallDest, 32\n            str.literal dest,   \"Initial destination string\"\n\n//                             1111111111222222222233333\n//                   01234567890123456789012345678901234\nstr.literal source, \"Hello there, world! How's it going?\"\n\nfmtStr:     .asciz      \"source='%s', destination='%s'\\n\"\nltFmtStr:   .asciz      \"Left ('%s') is less than right ('%s')\\n\"\ngtFmtStr:   .asciz      \"Left ('%s') is greater than right ('%s')\\n\"\neqFmtStr:   .asciz      \"Left ('%s') is equal to right ('%s')\\n\"\n\nsuccessStr: .asciz      \"substr('%s', %2d, %3d)= '%s'\\n\"\nfailureStr: .asciz      \"substr('%s', %2d, %3d) failed\\n\"\n\n///////////////////////////////////////////////////////////\n\n            .code\nttlStr:     wastr  \"Listing15-1\"\n\n// Standard getTitle function\n// Returns pointer to program name in X0\n\n            proc    getTitle, public\n            lea     x0, ttlStr\n            ret\n            endp    getTitle\n\n///////////////////////////////////////////////////////////\n//\n// prtResult\n//\n// Utility function to print the result of a string\n// comparison:\n\n            proc    prtResult\n\n            mov     x2, x1\n            mov     x1, x0\n            mstr    x1, [sp]\n            mstr    x2, [sp, #8]\n beq     strsEQ\n            bhi     strGT\n\n            // Must be LT at this point.\n\n            lea     x0, ltFmtStr\n            b       printf\n\nstrsEQ:     lea     x0, eqFmtStr\n            b       printf\n\nstrGT:      lea     x0, gtFmtStr\n            b       printf\n\n            endp    prtResult\n\n///////////////////////////////////////////////////////////\n//\n// testSubstr\n//\n// Utility function to test call to str.substr\n//\n// On entry:\n// X0, X1, X2, X3 -- str.substr parameters\n\n            proc    testSubstr\n\n            locals  testSS\n            byte    testSS.stkspace, 64\n            endl    testSS\n\n            enter   testSS.size\n\n            lea     x5, successStr\n            bl      str.substr\n            bcc     success\n            lea     x5, failureStr\n\nsuccess:\n            mov     x4, x3\n            mov     x3, x2\n            mov     x2, x1\n            mov     x1, x0\n            mov     x0, x5\n            mstr    x1, [sp]\n            mstr    x2, [sp, #8]\n            mstr    x3, [sp, #16]\n            mstr    x4, [sp, #24]\n            bl      printf\n            leave\n            endp    testSubstr\n\n///////////////////////////////////////////////////////////\n//\n// Main program to test the code:\n\n            proc    asmMain, public\n\n            locals  lcl\n            byte    stkSpace, 64\n            endl    lcl\n\n            enter   lcl.size      // Reserve space for locals.\n\n            lea     x0, src\n            lea     x1, destination\n            bl      str.cpy\n\n            mov     x2, x1\n            mov     x1, x0\n            lea     x0, fmtStr\n            mstr    x1, [sp]\n            mstr    x2, [sp, #8]\n            bl      printf\n\n            lea     x0, left\n            lea     x1, right1\n            bl      str.cmp\n            bl      prtResult\n\n            lea     x0, left\n            lea     x1, right2\n            bl      str.cmp\n            bl      prtResult\n\n            lea     x0, left\n            lea     x1, right3\n            bl      str.cmp\n            bl      prtResult\n\n            lea     x0, source\n            mov     x1, #0\n            mov     x2, #11\n            lea     x3, dest\n            bl      testSubstr\n\n            lea     x0, source\n            mov     x1, #20\n            mov     x2, #15\n            lea     x3, dest\n            bl      testSubstr\n\n            lea     x0, source\n            mov     x1, #20\n            mov     x2, #20\n lea     x3, dest\n            bl      testSubstr\n\n            lea     x0, source\n            mov     x1, #40\n            mov     x2, #20\n            lea     x3, dest\n            bl      testSubstr\n\n            lea     x0, source\n            mov     x1, #0\n            mov     x2, #100\n            lea     x3, smallDest\n            bl      testSubstr\n\nAllDone:    leave\n            endp    asmMain\n```", "```\n./build Listing15-1\n```", "```\ng++ -DisMacOS c.cpp Listing15-1.S str.cpy.o str.cmp.o str.substr.o -o Listing15-1\n```", "```\n% g++ -c -DisMacOS str.cpy.S\n% g++ -c -DisMacOS str.cmp.S\n% g++ -c -DisMacOS str.substr.S\n% g++ -DisMacOS c.cpp Listing15-1.S str.cpy.o str.cmp.o str.substr.o -o Listing15-1\n% ./Listing15-1\nCalling Listing15-1:\nsource='String to copy', destination='String to copy'\nLeft ('some string') is equal to right ('some string')\nLeft ('some string') is less than right ('some string.')\nLeft ('some string') is greater than right ('some string')\nsubstr('Hello there, world! How's it going?',  0,  11)= 'Hello there'\nsubstr('Hello there, world! How's it going?', 20,  15)= 'How's it going?'\nsubstr('Hello there, world! How's it going?', 20,  20)= 'How's it going?'\nsubstr('Hello there, world! How's it going?', 40,  20)= ''\nsubstr('Hello there, world! How's it going?',  0, 100) failed\nlisting15-1 terminated\n```", "```\nmake `optionalArguments`\n```", "```\nmake -f mymake.mak\n```", "```\n`target`: `dependencies`\n    `commands`\n```", "```\nall:\n    g++ -c -DisMacOS str.cpy.S\n    g++ -c -DisMacOS str.cmp.S\n    g++ -c -DisMacOS str.substr.S\n    g++ -DisMacOS c.cpp Listing15-1.S str.cpy.o str.cmp.o \\\n         str.substr.o -o Listing15-1\n```", "```\nexecutable:\n  g++ -c -DisMacOS Listing15-1.S\n  g++ -DisMacOS c.cpp Listing15-1.o str.cpy.o str.cmp.o str.substr.o -o Listing15-1\n\nlibrary:\n  g++ -c -DisMacOS str.cpy.S\n  g++ -c -DisMacOS str.cmp.S\n  g++ -c -DisMacOS str.substr.S\n```", "```\nmake library\n```", "```\ntarget: `dependency1` `dependency2` `dependency3` ...\n```", "```\nexecutable:\n  g++-c -DisMacOS Listing15-1.S\n  g++-DisMacOS c.cpp Listing15-1.o str.cpy.o str.cmp.o str.substr.o -o Listing15-1\n\nlibrary:\n  g++ -c -DisMacOS str.cpy.S\n  g++-c -DisMacOS str.cmp.S\n  g++-c -DisMacOS str.substr.S\n\nall: library executable\n```", "```\nexecutable:\n  g++ -c -DisMacOS Listing15-1.1\n  g++ -DisMacOS c.cpp Listing15-1.o str.cpy.o str.cmp.o str.substr.o -o Listing15-1\n\nlibrary: str.cpy.o str.cmp.o str.substr.o\n\nstr.cpy.o:\n  g++ -c -DisMacOS str.cpy.S\n\nstr.cmp.o:\n  g++ -c -DisMacOS str.cmp.S\n\nstr.substr.o:\n  g++ -c -DisMacOS str.substr.S\n\nall: library executable\n```", "```\nListing15-1:Listing15-1.o str.cpy.o str.cmp.o str.substr.o\n  gcc -DisMacOS c.cpp Listing15-1.o str.cpy.o str.cmp.o str.substr.o -o Listing15-1\n\nListing15-1.o:\n  g++ -c -DisMacOS Listing15-1.S\n\nstr.cpy.o:\n  g++ -c -DisMacOS str.cpy.S\n\nstr.cmp.o:\n  g++ -c -DisMacOS str.cmp.S\n\nstr.substr.o:\n  g++ -c -DisMacOS str.substr.S\n```", "```\n# Listing15-2.mak\n#\n# makefile for Listing15-1\n\nListing15-1:Listing15-1.o str.cpy.o str.cmp.o str.substr.o\n  gcc -DisMacOS c.cpp Listing15-1.o str.cpy.o str.cmp.o str.substr.o -o Listing15-1\n\nListing15-1.o:aoaa.inc Listing15-1.S\n  gcc -c -DisMacOS Listing15-1.S\n\nstr.cpy.o:aoaa.inc str.cpy.S\n  gcc -c -DisMacOS str.cpy.S\n\nstr.cmp.o:aoaa.inc str.cmp.S\n  gcc -c -DisMacOS str.cmp.S\n\nstr.substr.o:aoaa.inc str.substr.S\n  gcc -c -DisMacOS str.substr.S\n```", "```\n% make -f Listing15-2.mak\ngcc -c -DisMacOS Listing15-1.S\ngcc -c -DisMacOS str.cpy.S\ngcc -c -DisMacOS str.cmp.S\ngcc -c -DisMacOS str.substr.S\ngcc -DisMacOS c.cpp Listing15-1.o str.cpy.o str.cmp.o str.substr.o -o Listing15-1\n```", "```\n# Listing15-3.mak\n#\n# makefile for Listing15-1 with dependencies that will\n# automatically set up the define for the OS\n\n❶ unamestr=`uname`\n\nListing15-1:Listing15-1.o str.cpy.o str.cmp.o str.substr.o\n    gcc -D$(unamestr) c.cpp Listing15-1.o str.cpy.o str.cmp.o \\\n        str.substr.o -o Listing15-1\n\nListing15-1.o:aoaa.inc Listing15-1.S\n  ❷ gcc -c -D$(unamestr) Listing15-1.S\n\nstr.cpy.o:aoaa.inc str.cpy.S\n    gcc -c -D$(unamestr) str.cpy.S\n\nstr.cmp.o:aoaa.inc str.cmp.S\n    gcc -c -D$(unamestr) str.cmp.S\n\nstr.substr.o:aoaa.inc str.substr.S\n    gcc -c -D$(unamestr) str.substr.S\n```", "```\n// Makefiles define the symbols Darwin (for macOS)\n// and Linux (for Linux) rather than isMacOS and\n// isLinux. Deal with that here:\n\n#ifdef Darwin\n    #define isMacOS (1)\n    #undef isLinux\n    #undef Darwin\n#endif\n#ifdef Linux\n    #define isLinux (1)\n    #undef isMacOS\n    #undef Linux\n#endif\n```", "```\n% make -f Listing15-3.mak\ng++ -c -D`uname` Listing15-1.S\ng++ -c -D`uname` str.cpy.S\ng++ -c -D`uname` str.cmp.S\ng++ -c -D`uname` str.substr.S\ng++ -D`uname` c.cpp Listing15-1.o str.cpy.o str.cmp.o \\\n    str.substr.o -o Listing15-1\n```", "```\n# Listing15-4.mak\n#\n# makefile for listing15-1 with dependencies that will\n# automatically set up the define for the OS\n#\n# Demonstrates the clean target\n\nunamestr=`uname`\n\nListing15-1:Listing15-1.o str.cpy.o str.cmp.o str.substr.o\n    gcc -D$(unamestr) c.cpp listing15-1.o str.cpy.o str.cmp.o \\\n        str.substr.o -o Listing15-1\n\nListing15-1.o:aoaa.inc Listing15-1.S\n    gcc -c -D$(unamestr) Listing15-1.S\nstr.cpy.o:aoaa.inc str.cpy.S\n    gcc -c -D$(unamestr) str.cpy.S\n\nstr.cmp.o:aoaa.inc str.cmp.S\n    gcc -c -D$(unamestr) str.cmp.S\n\nstr.substr.o:aoaa.inc str.substr.S\n    gcc -c -D$(unamestr) str.substr.S\nclean:\n    rm str.cpy.o\n    rm str.cmp.o\n    rm str.substr.o\n    rm Listing15-1.o\n    rm c.o\n    rm Listing15-1\n```", "```\n% make -f Listing15-4.mak clean\n```", "```\ntouch Listing15-1.S\n```", "```\nar rcs `libname.a` `list-of-.o-files`\n```", "```\nar rcs aoaalib.a getTitle.o print.o\n```", "```\ng++ -DisMacOS c.cpp Listing15-1.S strings.a -o Listing15-1\n```", "```\n# Listing15-5.mak\n#\n# makefile to build the string.a library file\n\nunamestr=`uname`\n\nstrings.a:str.cpy.o str.cmp.o str.substr.o str.bufInit.o \\\n            str.alloc.o str.free.o\n    ar rcs strings.a str.cpy.o str.cmp.o str.substr.o \\\n        str.bufInit.o str.alloc.o str.free.o\n\nstr.cpy.o:aoaa.inc str.cpy.S\n    g++ -c -D$(unamestr) str.cpy.S\n\nstr.cmp.o:aoaa.inc str.cmp.S\n    g++ -c -D$(unamestr) str.cmp.S\n\nstr.substr.o:aoaa.inc str.substr.S\n    g++ -c -D$(unamestr) str.substr.S\n\nstr.bufInit.o:aoaa.inc str.bufInit.S\n    g++ -c -D$(unamestr) str.bufInit.S\n\nstr.free.o:aoaa.inc str.free.S\n    g++ -c -D$(unamestr) str.free.S\n\nstr.alloc.o:aoaa.inc str.alloc.S\n    g++ -c -D$(unamestr) str.alloc.S\n\n clean:\n    rm -f strings.a\n    rm -f str.cpy.o\n    rm -f str.cmp.o\n    rm -f str.substr.o\n    rm -f str.bufInit.o\n    rm -f str.alloc.o\n    rm -f str.free.o\n```", "```\n# Listing15-6.mak\n#\n# makefile that uses the string.a library file\n\nunamestr=`uname`\n\nListing15-1:Listing15-1.o strings.a\n    g++ -D$(unamestr) c.cpp Listing15-1.o strings.a -o Listing15-1\n\nListing15-1.o:aoaa.inc Listing15-1.S\n    g++ -c -D$(unamestr) Listing15-1.S\n\nlib:\n    rm -f strings.a\n    rm -f str.*.o\n    make -f Listing15-5.mak\n\nclean:\n    rm -f Listing15-1\n    rm -f c.o\n    rm -f Listing15-1.o\n```", "```\nmake -f Listing15-6.mak lib\n```", "```\nnm strings.a\n```"]