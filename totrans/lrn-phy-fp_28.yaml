- en: '25'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ELECTRIC FIELD
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the 1800s, Faraday and Maxwell discovered a new way to think about electric
    (and magnetic) phenomena that forms the basis for today’s electromagnetic theory.
    In this 19th century view, one particle does not directly apply a force to another
    particle, as Coulomb’s law would imply. Instead, one particle creates an *electric
    field* that applies a force to the second particle.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start this chapter with a short discussion of exactly what an electric
    field is. Then, we’ll show how to calculate the electric field produced by each
    of the charge distributions we studied in the previous chapter. We’ll begin with
    the electric field produced by a point charge, which is really the fundamental
    piece that governs all of the other distributions. After a single point charge,
    we’ll look at the electric field produced by multiple point charges. As an example,
    we’ll compare the electric fields produced by a simple electric dipole composed
    of two point charges with an ideal electric dipole.
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the electric field, we’ll need to introduce a few new mathematical
    tools. Finding the electric field produced by a line charge requires a vector
    line integral; finding the electric field produced by a surface charge requires
    a vector surface integral; and finding the electric field produced by a volume
    charge requires a vector volume integral. We’ll introduce these as needed, and
    we’ll close out the chapter with the details of sampling or discretizing curves,
    surfaces, and volumes, which will allow us to do numerical line, surface, and
    volume integrals.
  prefs: []
  type: TYPE_NORMAL
- en: What Is an Electric Field?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An electric field is a *vector field* of the kind we talked about in [Chapter
    22](ch22.xhtml). The electric field associates a vector **E**(**r**) with each
    point **r** in space; that vector helps determine the force on a particle if there
    is a particle at point **r** in space.
  prefs: []
  type: TYPE_NORMAL
- en: Is the electric field a physical thing, or is it an abstraction we use to think
    about electricity? I would argue it is both. The electric field is an abstract
    mathematical construct, as are so many of the ideas of modern theoretical physics.
    We describe it using mathematical language and posit axioms about it as though
    it had no more physical reality than a 7×7 matrix of irrational numbers.
  prefs: []
  type: TYPE_NORMAL
- en: In static situations, where charges are not moving or accelerating, we can remain
    ambivalent about the reality of the electric field, or even deny it. These static
    situations are the ones where Coulomb’s law makes good predictions, and the new
    electromagnetic theory that speaks of an electric field makes the same predictions.
    In static situations, then, the electric field can be viewed as merely an abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: In dynamic situations, on the other hand, where electric charge is moving and/or
    accelerating, it becomes much harder to maintain the view that the electric field
    is only a calculational tool. The reason is that modern electromagnetic theory
    is, in addition to being a theory of electricity and magnetism, a theory of light
    and radiation. Maxwell’s insight was that electric and magnetic fields could serve
    to describe visible light and an entire spectrum of nonvisible light-like waves,
    including radio waves and microwaves. These waves are now viewed as waves in the
    electric and magnetic fields. Light is, according to the Faraday-Maxwell theory,
    an electromagnetic wave. To the extent that light and radiation are physical and
    real, it seems the electric field is also physical and real.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the electric field breaks the analysis of electrical situations
    into two parts. The first part is the creation of the electric field by charge,
    which we’ll discuss in this chapter. The second part is the force that the electric
    field applies to (a second) charge, which we’ll discuss in [Chapter 28](ch28.xhtml).
    [Figure 25-1](ch25.xhtml#ch25fig1) shows the electric field’s role in a situation
    with two charges.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/474equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-1: Conceptual diagram of the role of the electric field when two
    charged particles are present. Particle 1 creates the electric field. The electric
    field exerts a force on particle 2.*'
  prefs: []
  type: TYPE_NORMAL
- en: We say that the electric field *mediates* the interaction between the two particles.
    In this chapter, we focus on the electric field created by static, or stationary,
    charges and charge distributions. The real benefit of the electric field idea
    appears when charges are moving rapidly or accelerating because Coulomb’s law
    fails to make good predictions in these cases. In general, the Maxwell equations,
    which we discuss in [Chapter 29](ch29.xhtml), describe the creation and evolution
    of the electric field. The Maxwell equations describe the electric field created
    by charge in any sort of motion, and they make different predictions from Coulomb’s
    theory when charge is moving or accelerating. Our introduction of the electric
    field in simpler static situations will put us in a better position to discuss
    the Maxwell equations later.
  prefs: []
  type: TYPE_NORMAL
- en: Introductory Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Listing 25-1](ch25.xhtml#ch25list1) shows the first lines of code in the `ElectricField`
    module we’ll write in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 25-1: Opening lines of code for the ElectricField module*'
  prefs: []
  type: TYPE_NORMAL
- en: We use types and functions from the `SimpleVec` module of [Chapter 10](ch10.xhtml),
    the `CoordinateSystems` module of [Chapter 22](ch22.xhtml), the `Geometry` module
    of [Chapter 23](ch23.xhtml), and the `Charge` module of [Chapter 24](ch24.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Charge Creates an Electric Field
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first part of the modern two-part view of electricity is that electric charge
    creates the electric field. We want to calculate the electric field created by
    charges of various sorts. We’ll start with a point charge, the simplest charge
    distribution, and then move to more complex charge distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Electric Field Created by a Point Charge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A particle with charge *q*[1] located at position **r**[1] will create an electric
    field **E** given by the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/476equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The electric field **E** is a function from position to vectors (in other words,
    a vector field).
  prefs: []
  type: TYPE_NORMAL
- en: A positive point charge produces an electric field that points away from the
    positive charge. A negative point charge produces an electric field that points
    toward the negative charge.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced the constant *ϵ*[0], called the *permittivity of free space*,
    in [Chapter 21](ch21.xhtml); it is defined as
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/476equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *c* is the speed of light in vacuum and *μ*[0] is a constant called the
    *permeability of free space*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The speed of light in vacuum is exactly *c* = 299792458 m/s (the meter is defined
    to be the length that light travels in a vacuum in 1/299792458 s).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Prior to the 2019 SI revision, the constant *μ*[0] was defined to be exactly
    *μ*[0] = 4*π* × 10^(–7) N/A². The 2019 revision chooses other constants to be
    exact, leaving *μ*[0] to be determined by experiment. Nevertheless, it remains
    very close to this value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have *ϵ*[0] and *μ*[0] because the units in which we measure electric and
    magnetic fields (or voltage and current) are rooted in experiments measuring the
    forces between currents and charges. These experiments predate the modern electromagnetic
    theory based on Maxwell’s equations. Keeping the conventional units in the presence
    of Maxwell’s equations requires *ϵ*[0] and *μ*[0] to make the units work out.
    If you’re willing to give up the conventional units of current and voltage (amperes
    and volts), you can write Maxwell’s equations without *ϵ*[0] and *μ*[0].
  prefs: []
  type: TYPE_NORMAL
- en: The function `eFieldFromPointCharge` encodes Equation 25.1, taking the point
    particle’s charge and position as input and producing the electric field as output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The local name `d` stands for the displacement vector **r** – **r**[1] from
    the charge’s position **r**[1] to the *field point* **r**. The field point is
    a position where we are looking for or talking about the electric field. No particle
    or matter need be present at the field point.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 24](ch24.xhtml), we wrote a type for charge distribution. Over the
    course of the present chapter, we will write functions to calculate the electric
    field produced by each sort of charge distribution. This allows us to encapsulate
    the idea that charge creates an electric field in the following function, which
    produces an electric field given any charge distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The function `eField` uses pattern matching on the input to treat each sort
    of charge distribution separately. For a point charge, it uses the function `eFieldFromPointCharge`
    we wrote earlier. For line, surface, and volume charges, it uses functions we’ll
    write later in this chapter. For a combination distribution with the constructor
    `MultipleCharges`, it uses the *principle of superposition*, which says that the
    electric field produced by multiple charges is the vector sum of the electric
    fields produced by each individual charge. In this case, we use the function `addVectorFields`
    from [Chapter 22](ch22.xhtml) to combine the electric fields of the component
    distributions.
  prefs: []
  type: TYPE_NORMAL
- en: The function `eField` is an explicitly recursive function. We see this in the
    last line of the definition, where `eField` is defined in terms of `eField`. I
    have tried to avoid writing explicitly recursive functions because they are harder
    to understand. In this case, the explicit recursion appears only in the `MultipleCharges`
    clause. It means that when multiple charges are encountered, the appropriate thing
    to do is, first, find the electric field of each component charge (using the same
    `eField` function, but probably one of the other clauses), and, second, add these
    component electric fields together.
  prefs: []
  type: TYPE_NORMAL
- en: The electric field produced by a proton at the origin is given by the vector
    field `eField protonOrigin`, where `protonOrigin` is the charge distribution we
    wrote in [Chapter 24](ch24.xhtml) for a proton at the origin. [Figure 25-2](ch25.xhtml#ch25fig2)
    shows three ways of visualizing the electric field produced by a proton.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/478fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-2: Three ways of visualizing the electric field eField protonOrigin
    produced by a proton. The upper-left image is produced by eFieldPicProton2D, the
    upper-right image is produced by eFieldPicProtonGrad, and the lower picture is
    a screenshot of the 3D interactive image produced by eFieldPicProton3D.*'
  prefs: []
  type: TYPE_NORMAL
- en: The following code produced the upper-left picture in [Figure 25-2](ch25.xhtml#ch25fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Sample points lie in the xy-plane, but any plane through the point charge would
    give the same image. Each arrow represents the electric field at the location
    of the arrow’s tail. In this picture, electric field strength is proportional
    to the length of arrows displayed. Since the electric field produced by a point
    charge is inversely proportional to the square of the distance from the point
    charge, the length of these arrows would get arbitrarily long as we get closer
    to the point charge. Thus, we chose our sample points and scale factor so that
    no outrageously long arrows appear on our diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'The electric field produced by a proton at a point 1 m away is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/479equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The scale factor of `3e-9` means that an electric field of 3 × 10^(–9) N/C is
    displayed with an arrow of length 1 m in the scale of the picture. The arrows
    closest to the proton are 1 m away. Their lengths should be about (1.4 × 10^(–9)
    N/C)/(3 × 10^(–9) N/C), or about half, of the distance from the proton to the
    tail of the vector, which is true in this picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider the following code, which produced the upper-right picture in
    [Figure 25-2](ch25.xhtml#ch25fig2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Again, sample points lie in the xy-plane. Each arrow represents the electric
    field at the location of the arrow’s center. In this picture, the electric field
    is stronger at the darker arrows and weaker at the lighter arrows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we have the following code, which produced the lower picture in [Figure
    25-2](ch25.xhtml#ch25fig2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you run the program `eFieldPicProton3D`, perhaps by making a stand-alone
    program and calling it `main`, a 3D vector field will pop up. You can move it
    around and rotate it with your mouse or pointing device.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion of the electric field produced by a single point
    charge. Next we’ll look at multiple charges.
  prefs: []
  type: TYPE_NORMAL
- en: Electric Field Created by Multiple Charges
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Equation 25.1 is the fundamental equation for the electric field produced by
    a point charge. The principle of superposition says that the electric field produced
    by multiple charges is the vector sum of the electric fields produced by each
    charge alone. For a collection of point charges, with *i* labeling the particles,
    *q[i]* the charge of particle *i*, and **r**[*i*] the location of particle *i*,
    the electric field produced at field point **r** by the collection is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/479equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This principle of superposition is already encoded in our `eField` function.
    Whenever we have multiple charges in a charge distribution, they are tagged with
    a `MultipleCharges` data constructor, which tells the `eField` function to apply
    the superposition principle. We used this `MultipleCharges` data constructor in
    the last chapter when we wrote the `simpleDipole` charge distribution. So, although
    Equation 25.2 is a useful and important equation, telling us how to find the electric
    field from multiple point charges, we do not need to write any additional code;
    the superposition principle is already being applied automatically by the `eField`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first example of multiple charges, we’ll look at a simple electric dipole
    composed of two particles: one positively charged and the other with an equal
    but opposite negative charge.'
  prefs: []
  type: TYPE_NORMAL
- en: Electric Field of a Simple Electric Dipole
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the previous chapter, we introduced `simpleDipole`, a charge distribution
    composed of two oppositely charged point particles separated by some distance.
    The electric dipole moment of sodium chloride is 2.99 × 10^(–29) C m. The interatomic
    distance between the sodium and chlorine atoms is 2.36 × 10^(–10) m. If we think
    of NaCl as composed of two point particles, the sodium has an effective charge
    about 0.8 of the proton charge and the chlorine has an effective charge about
    – 0.8 of the proton charge. The effective charge is not an integer multiple of
    the elementary charge because the electrons are shared between the ions. Here
    is a charge distribution for NaCl, viewed as a simple electric dipole:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To find the electric field of this charge distribution, we simply use the `eField`
    function. Since a `simpleDipole` is a charge distribution constructed with `MultipleCharges`
    of two `PointCharge`s, the `eField` function comes across the `MultipleCharges`
    constructor first and uses that clause in the definition. The `MultipleCharges`
    clause says to first find the electric field of each point charge, which it does
    by using `eField` itself, but this time with the `PointCharge` constructor. So
    `eField` actually gets used three times. We use it once, but then it uses itself
    two more times to find the electric fields of each point charge, and then adds
    them together and sends the result back to us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The left picture in [Figure 25-3](ch25.xhtml#ch25fig3) shows the electric field
    produced by NaCl. The electric field points away from the positively charged sodium
    atom at the top of the picture and toward the negatively charged chlorine atom
    at the bottom of the picture. The right picture shows the electric field produced
    by an ideal dipole, described in the next section. We show them side by side in
    one figure to see what’s common and what’s different. The central parts of the
    pictures are different because charge is located in different places. The outer
    parts of the pictures are similar; any electric dipole produces this same electric
    field pattern at places a little bit away from the source.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/481fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-3: Electric field produced by a simple dipole (left) and an ideal
    dipole (right). The simple dipole consists of one positive point charge and one
    negative point charge. The left image shows the electric field eFieldSodiumChloride
    and is produced by eFieldPicSimpleDipole; the right image shows the electric field
    eFieldIdealDipole kHat and is produced by eFieldPicIdealDipole.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code that produced the picture on the left in [Figure 25-3](ch25.xhtml#ch25fig3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The picture shows a square in the yz-plane, in which *y* runs from –3 × 10^(–10)
    m to 3 × 10^(–10) m, and *z* runs across the same range. This is achieved by the
    mapping in the second input to `vfGrad`, which scales the parameters `y` and `z`
    by `3e-10`. Recall that the second input of the `vfGrad` function we wrote in
    [Chapter 22](ch22.xhtml) specifies the region of interest by mapping a square
    from (–1,–1) to (1,1) into the region we wish to visualize.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal Electric Dipole
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Equally but oppositely charged particles are an example of an electric dipole.
    An *ideal electric dipole* is a source of an electric field formed by letting
    the distance between these two particles approach zero while the charges increase
    in magnitude so that the electric dipole moment stays constant. Let’s look at
    the electric field produced by an ideal electric dipole.
  prefs: []
  type: TYPE_NORMAL
- en: The electric field produced by an ideal electric dipole at the origin is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/481equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'where **p** is the electric dipole moment. Here it is in Haskell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The right side of [Figure 25-3](ch25.xhtml#ch25fig3) shows the electric field
    produced by an ideal electric dipole. The magnitude of the electric dipole moment
    **p** is not so important in this picture because the darkest arrows are those
    where the electric field is largest in magnitude, regardless of what that magnitude
    is. Equation 25.3 shows that the electric field increases linearly with the dipole
    moment, so the picture would be the same for any dipole moment in the z-direction.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the two pictures in [Figure 25-3](ch25.xhtml#ch25fig3), we see that
    the electric field differs in the centers of the pictures, close to the sources
    of the field. The fields around the edges of the pictures, farther from the sources,
    are very similar in the two pictures. It is the similarity of the fields a bit
    farther from the sources that entitles both sources to be called electric dipoles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code to produce the picture on the right in [Figure 25-3](ch25.xhtml#ch25fig3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The only differences in this program compared to `eFieldPicSimpleDipole` for
    NaCl are the filenames and the electric fields. The electric field here is `eFieldIdealDipole
    kHat`, where we use the unit vector `kHat` for the electric dipole moment because
    its magnitude doesn’t change the picture.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen an example of the electric field produced by multiple point charges
    and compared it to that of an ideal electric dipole. Continuous charge distributions
    can be though of as a case of multiple charges, where there are many charges spread
    over some region. Before we turn to the question of finding the electric field
    produced by specific continuous charge distributions, there are a few general
    remarks we can make.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Distributions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When we move from discrete point charges to a charge that is continuously distributed,
    we replace the sum in Equation 25.2 with an integral. A general way to write this
    integral is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/482equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In Equation 25.4, we’ve replaced discrete quantities with continuous ones, as
    indicated in [Table 25-1](ch25.xhtml#ch25tab1), which shows the correspondence
    between discrete and continuous quantities.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 25-1:** Correspondence Between Discrete and Continuous Quantities in
    the Electric Field Produced by Charge'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Discrete** | **Continuous** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Aggregation method | ∑[*i*] | ∫ |'
  prefs: []
  type: TYPE_TB
- en: '| Quantity of charge | *q[i]* | *dq*′ |'
  prefs: []
  type: TYPE_TB
- en: '| Location of charge | **r***[i]* | **r**′ |'
  prefs: []
  type: TYPE_TB
- en: The form of the integral in Equation 25.4 is so general that we have not even
    specified whether the charge is distributed along a 1D curve, across a 2D surface,
    or throughout a 3D volume. In any case, the integral is defined by a limiting
    process in which the quantities of charge *dq*′ become arbitrarily small and the
    number of charges becomes arbitrarily large.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we can evaluate such an integral exactly; however, more often, we
    need to compute an approximation to the integral. We do this computationally by
    turning the continuous integral back into a discrete sum, basically by turning
    Equation 25.4 back into Equation 25.2\. The details depend on whether we are integrating
    over a 1D curve, a 2D surface, or a 3D volume. We take up each of these cases
    in turn in the sections that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Electric Field Created by a Line Charge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we discussed in the previous chapter, a line charge is specified by a curve
    *C* and a scalar field *λ* representing the linear charge density at any point
    on the curve. When charge is spread along a one-dimensional curve, a little bit
    of charge *dq*′ at position **r**′ is given by the product of the linear charge
    density *λ*(**r**) and the length *dl*′ of a small section of the curve near **r**′.
  prefs: []
  type: TYPE_NORMAL
- en: '*dq*′ = *λ*(**r**′) *dl*′'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then write the integral of Equation 25.4 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/483equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Such an integral of a vector field over a curve is called a *vector line integral*.
    Let’s explain the vector line integral in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Vector Line Integral
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The vector line integral takes a vector field and a curve as input and returns
    a vector as output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The vector line integral of a vector field **F** over a curve *C* is written
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/484equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What does this integral mean? The integral is defined by dividing the curve
    *C* into many small segments. The vector field **F** is evaluated at each point
    **r**[*i*] on or near the segment Δ**l**[*i*] and scaled (multiplied) by the length
    Δ*l[i]* of the segment. We then add up these vectors to form the sum
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/484equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The integral is the limit of this vector sum as the lengths of the segments
    approach 0 and the number of segments becomes arbitrarily large. The definition
    of the integral involves careful specification of the limiting process, which
    we’ll leave to textbooks on vector calculus.
  prefs: []
  type: TYPE_NORMAL
- en: The integral is not only defined by, but also approximated by, a finite sum.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/484equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our approximate calculation of the integral will use a finite number of segments.
    We will need a method to approximate a curve by a finite list of segments. We’ll
    represent a segment Δ**l**[*i*] as a short displacement vector lying along the
    curve. In addition to the displacement vector Δ**l**[*i*], which describes the
    length and orientation of the segment, we also need a position **r**[*i*] indicating
    where the segment is located on the curve. An approximation to a curve consists
    of a list of pairs of positions and displacement vectors. Notice that the lengths
    of the segments need not be the same. A curve approximation method is a function
    that returns such a list when given a curve.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A pair looks like (**r**[*i*], Δ**l**[*i*]). We could use many curve approximation
    methods; we’ll delay discussion of a curve approximation method to the final section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the Haskell definition of a vector line integral:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The curve `c` is approximated by the function `approx`, which is provided as
    an input. The function `approx` will specify the number of segments into which
    the curve is to be divided, as well as the method for the division and determination
    of the associated positions of the segments. For each segment `dl'` at position
    `r'`, the vector field `vF` is evaluated at position `r'` and scaled by the magnitude
    of `dl'`. We then sum these vectors to give the approximation to the integral.
    [Table 25-2](ch25.xhtml#ch25tab2) shows a correspondence between mathematical
    notation and Haskell notation in the definition of the vector line integral.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 25-2:** Correspondence Among Continuous Mathematical Notation, Discrete
    Mathematical Notation, and Haskell Notation for the Vector Line Integral'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Continuous math** | **Discrete math** | **Haskell** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ∫ | ∑[*i*] | `sumV` ➊ |'
  prefs: []
  type: TYPE_TB
- en: '| **r**′ | **r**[*i*] | `r''` ➋ |'
  prefs: []
  type: TYPE_TB
- en: '| **F** | **F** | `vF` |'
  prefs: []
  type: TYPE_TB
- en: '| **F**(**r**′) | **F**(**r**[*i*]) | `vF r''` |'
  prefs: []
  type: TYPE_TB
- en: '| *C* |  | `c` ➌ |'
  prefs: []
  type: TYPE_TB
- en: '| *dl*′ | Δ**l**[*i*] | `dl''` ➍ |'
  prefs: []
  type: TYPE_TB
- en: '| *dl*′ | Δ*l[i]* | `magnitude dl''` |'
  prefs: []
  type: TYPE_TB
- en: '| **F**(**r**′)*dl*′ | **F**(**r**[*i*])Δ*l[i]* | `vF r'' ^* magnitude dl''`
    |'
  prefs: []
  type: TYPE_TB
- en: Surprisingly, Haskell notation is closer to discrete notation only in the summation
    ➊. The Haskell names we chose for segment location ➋, curve ➌, and segment displacement
    ➍ are closer to the continuous notation. This is because Haskell does not require
    the index *i* used in the discrete notation, so there is no reason to introduce
    it. Haskell computes the integral in a discrete way, but Haskell’s list syntax
    avoids the need to talk about the index *i* that would number the list elements.
  prefs: []
  type: TYPE_NORMAL
- en: Back to Electric Field
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: From Equation 25.5, we see that the vector field **F** we want to integrate
    to find the electric field produced by a line charge is the function that maps
    the position **r**′ of a piece of charge to the vector
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/485equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: in which **r** is the field point, the fixed position where we want to know
    the electric field. In the function `eFieldFromLineCharge` below, this function
    is given the local name `integrand`. The local name `d` stands for the displacement
    **r** – **r**′ from the source point **r**′ to the field point **r**. Because
    the source point `r'` is introduced as a name local to the `integrand` function,
    we must define `d` with a `where` clause, rather than alongside the definitions
    of `k` and `integrand`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to give only two items to find the electric field produced by a line
    charge: the linear charge density, expressed as a scalar field, and the curve
    that describes the geometry of the line charge. The type signature of the function
    `eFieldFromLineCharge` makes it clear that the electric field depends only on
    these two items. We use the `vectorLineIntegral` we defined earlier. The curve
    approximation method `curveSample 1000` divides the curve into 1,000 segments
    and is defined later in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve shown how to find the electric field for a line charge, let’s
    look at the electric field produced by the line dipole `lineDipole` we discussed
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Example of a Line Dipole
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the previous chapter, we introduced `lineDipole`, a line charge with a linearly
    varying charge density. Suppose we had reason to believe that the charge distribution
    of NaCl looked more like that of a line dipole than a simple dipole. I have no
    such evidence, and the charge distribution of NaCl is probably complicated, but
    it’s certainly reasonable to imagine that the charge density varies smoothly,
    if not linearly, from sodium to chlorine. To model NaCl as a line dipole, we can
    use the same electric dipole moment and interatomic separation we used earlier
    for the simple dipole. Here is a charge distribution for NaCl, viewed as a line
    dipole:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can find the electric field of this charge distribution with the `eField`
    function, which in this case will use the `eFieldFromLineCharge` function we wrote
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 25.11 asks you to make a vector field picture for this electric field,
    similar to the ones we made earlier for the simple dipole and the ideal dipole.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve discussed how to find the electric field from our first continuous
    charge distribution, that of a line charge, and shown an example, let’s turn to
    our second continuous charge distribution, that of a surface charge.
  prefs: []
  type: TYPE_NORMAL
- en: Electric Field Created by a Surface Charge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we discussed in the previous chapter, a surface charge is specified by a
    surface *S* and a scalar field *σ* representing the surface charge density at
    any point on the surface. When charge is spread along a 2D surface, a little bit
    of charge *dq*′ at position **r**′ is given by the product of the surface charge
    density *σ*(**r**′) and the area *da*′ of a small patch of the surface near **r**′.
  prefs: []
  type: TYPE_NORMAL
- en: '*dq*′ = σ(**r**′) *da*′'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then write the integral of Equation 25.4 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/487equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Such an integral of a vector field over a surface is called a *vector surface
    integral*. Let’s explain the vector surface integral in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Vector Surface Integral
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The vector surface integral takes a vector field and a surface as input and
    returns a vector as output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The vector surface integral of a vector field **F** over a surface *S* is written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/487equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We define the integral by dividing the surface *S* into many small patches.
    You can think of a patch as a quadrilateral, but what’s really important is the
    location, area, and orientation of the patch rather than its shape. Each patch
    Δ**a**[*i*] is a vector area whose magnitude gives the area of the patch and whose
    direction points perpendicular to the patch. We assume each patch is small enough
    to be considered flat. Because our surfaces are oriented, as we discussed in [Chapter
    23](ch23.xhtml), the direction for the patch is unambiguous. The vector field
    **F** is evaluated at a point **r**[*i*] on or near the patch Δ**a**[*i*] and
    scaled by the area *Δa[i]* of the patch. We then add up these vectors to form
    the sum
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/487equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The integral is the limit of this vector sum as the areas of the patches approach
    0 and the number of patches becomes arbitrarily large.
  prefs: []
  type: TYPE_NORMAL
- en: The integral is not only defined by, but also approximated by, a finite sum.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/487equ04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our approximate calculation of the integral will use a finite number of patches.
    We will need a method to divide a surface into a list of patches. We’ll represent
    an oriented patch Δ**a**[*i*] as a vector perpendicular to the surface. In addition
    to the vector Δ**a**[*i*], which describes the area and orientation of the patch,
    we also need a position **r**[*i*] indicating where the patch is located on the
    surface. An approximation to a surface consists of a list of pairs of positions
    and area vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: A pair looks like (**r**[*i*], Δ**a**[*i*]). There are many ways the surface
    approximation could be done, and we’ll delay discussion of this point to the last
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the Haskell definition of a vector surface integral:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The surface `s` is approximated by the function `approx`, which is provided
    as an input. The function `approx` will specify the number of patches into which
    the surface is to be divided, as well as the method for the division and determination
    of the associated positions of the patches. For each patch `da'` at position `r'`,
    the vector field `vF` is evaluated at position `r'` and scaled by the magnitude
    of `da'`. We then sum these vectors to give the approximation to the integral.
    [Table 25-3](ch25.xhtml#ch25tab3) shows a correspondence between mathematical
    notation and Haskell notation in the definition of the vector surface integral.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 25-3:** Correspondence Among Continuous Mathematical Notation, Discrete
    Mathematical Notation, and Haskell Notation for the Vector Surface Integral'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Continuous math** | **Discrete math** | **Haskell** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ∫ | ∑[*i*] | `sumV` |'
  prefs: []
  type: TYPE_TB
- en: '| **r**′ | **r**[*i*] | `r''` |'
  prefs: []
  type: TYPE_TB
- en: '| **F** | **F** | `vF` |'
  prefs: []
  type: TYPE_TB
- en: '| **F**(**r**′) | **F**(**r**[*i*]) | `vF r''` |'
  prefs: []
  type: TYPE_TB
- en: '| *S* |  | `s` |'
  prefs: []
  type: TYPE_TB
- en: '| *d***a**′ | Δ**a**[*i*] | `da''` |'
  prefs: []
  type: TYPE_TB
- en: '| *da*′ | Δ*a[i]* | `magnitude da''` |'
  prefs: []
  type: TYPE_TB
- en: '| **F**(**r**′)*da*′ | **F**(**r**[*i*])Δ*a[i]* | `vF r'' ^* magnitude da''`
    |'
  prefs: []
  type: TYPE_TB
- en: The first four rows of [Table 25-3](ch25.xhtml#ch25tab3) are identical to those
    of [Table 25-2](ch25.xhtml#ch25tab2) for the vector line integral because they
    refer to the vector field and the integration. The last four rows of this table
    are analogous to those of the previous table, with surface patches substituting
    for line segments.
  prefs: []
  type: TYPE_NORMAL
- en: Back to Electric Field
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: From Equation 25.7, we see that the vector field **F** we want to integrate
    to find the electric field produced by a line charge is the function that maps
    the position **r**′ of a piece of charge to the vector
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/488equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we consider **r** the fixed position where we want to know the electric
    field. In the function `eFieldFromSurfaceCharge` next, which is a Haskell translation
    of Equation 25.7, we give this function the local name `integrand`. The local
    name `d` stands for the displacement **r** – **r**′ from the charge to the field
    point. Because we introduce the source point `r'` as a name local to the `integrand`
    function, we must define `d` with a `where` clause rather than alongside the definitions
    of `k` and `integrand`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to give only two items to find the electric field produced by a surface
    charge: the surface charge density *σ*, expressed as a scalar field, and the surface
    that describes the geometry of the surface charge. The type signature of `eFieldFromSurfaceCharge`
    makes it clear that the electric field depends only on these two items. We use
    the `vectorSurfaceIntegral` we defined earlier. The function `surfaceSample 200`
    divides the curve into 2(200)² = 80,000 patches and is defined later in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve shown how to find the electric field for a surface charge, let’s
    look at the electric field produced by the capacitor `diskCap` we discussed in
    the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Example of a Capacitor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s find the electric field produced by a parallel-plate capacitor whose plates
    are uniformly charged. The assumption of uniform charge is good when the plates
    are close together and worsens as the plates are moved farther apart. Suppose
    we have a capacitor with a plate separation of 4 cm in which the plates are disks
    with radius 5 cm. The positive plate has a surface charge density of 20 nC/m²,
    and the negative plate has a surface charge density of – 20 nC/m². The expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: represents this charge distribution.
  prefs: []
  type: TYPE_NORMAL
- en: We can find the electric field with the `eField` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `eField` uses the function `eFieldFromSurfaceCharge` we defined
    earlier. To start, let’s look at the electric field at the center of the capacitor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The electric field is in the negative z-direction, pointing from the positive
    plate above toward the negative plate below.
  prefs: []
  type: TYPE_NORMAL
- en: For comparison, a parallel-plate capacitor with infinitely wide plates and surface
    charge density *σ* has electric field *σ*/*ϵ*[0]. Physicists like the ideal parallel-plate
    capacitor with infinitely wide plates because there is a simple expression for
    the electric field it produces. The electric field outside the ideal capacitor
    is 0\. The electric field inside the ideal capacitor (between the two plates)
    has a uniform value of *σ*/*ϵ*[0] and points from the positive plate toward the
    negative plate. The electric field produced is independent of the plate separation.
    For a surface charge density of *σ* = 20 nC/m², the electric field magnitude would
    be
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/490equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The value we found earlier is less than this ideal value (in magnitude) because
    the radii of our plates are rather modest.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 25-4](ch25.xhtml#ch25fig4) shows the electric field produced by our
    disk capacitor.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/490fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 25-4: Electric field eFieldDiskCap produced by a parallel-plate capacitor.
    The plates have uniform surface charge density. (Image produced by eFieldPicDiskCap.)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 25-4](ch25.xhtml#ch25fig4) shows the region from –10 cm to 10 cm in
    the x-direction, and from –10 cm to 10 cm in the z-direction. The radii of the
    disks are 5 cm, so they extend horizontally over half the width of the figure.
    The electric field is largest in magnitude where the arrows are darkest, between
    the plates. The field is smaller outside the plates, but it’s not 0\. The electric
    field appears to be fairly uniform between the plates. We see from the shading
    how the electric field transitions from its maximum between the plates, to moderate
    values near the edges of the disks, to minimal values farther from the plates.
    Around the outside of the picture, the electric field looks like that of an electric
    dipole, which is not surprising since the capacitor is an electric dipole consisting
    of a positive plate and a negative plate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code that produced [Figure 25-4](ch25.xhtml#ch25fig4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The program might take several minutes to run. The surface and volume charge
    integrals involve many computations and can be slow. The methods used here are
    ones that are conceptually simple rather than numerically efficient. The slowness
    is mostly a consequence of the simple approach and is not inherent in the use
    of the Haskell language. There are data structures, such as unboxed vectors, that
    would speed up many of the operations here, at the expense of making the code
    less concise.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve talked about line charges and surface charges. Let’s turn to the third
    and last of our continuous charge distributions: the volume charge.'
  prefs: []
  type: TYPE_NORMAL
- en: Electric Field Created by a Volume Charge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we discussed in the previous chapter, a volume charge is specified by a volume
    *V* and a scalar field *ρ* representing the volume charge density at any point
    in the volume. When charge is spread throughout a 3D volume, a little bit of charge
    *dq*′ at position **r**′ is given by the product of the volume charge density
    *ρ*(**r**′) and the volume *dv*′ of a small portion of the volume near **r**′.
  prefs: []
  type: TYPE_NORMAL
- en: '*dq*′ = *ρ*(**r**′) *dv*′'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then write the integral of Equation 25.4 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/491equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Such an integral of a vector field over a volume is called a *vector volume
    integral*. Let’s explore the vector volume integral in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Vector Volume Integral
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The vector volume integral takes a vector field and a volume as input and returns
    a vector as output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The vector volume integral of a vector field **F** over a volume *V* is written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/492equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The integral is defined by dividing the volume *V* into many small portions.
    The vector field **F** is evaluated at each point **r**[*i*] on or near the portion
    and scaled by the volume Δ*v[i]* of the portion. We then add up these vectors
    to form the sum
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/492equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The integral is the limit of this vector sum as the volumes of the portions
    approach 0 and the number of portions becomes arbitrarily large.
  prefs: []
  type: TYPE_NORMAL
- en: 'The integral is both defined by and approximated by a finite sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/492equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our approximate calculation of the integral will use a finite number of portions.
    We’ll represent a portion by its location **r**[*i*] and its volume Δ*v[i]*. An
    approximation to a volume consists of a list of pairs of positions and portion
    volumes. A volume approximation method is a function that returns such a list
    when given a volume.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: A pair looks like (**r**[*i*], Δ*v[i]*). Many volume approximation methods could
    be used, and, as before, we’ll delay discussion of this point until later in the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the Haskell definition of a vector volume integral:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The volume `vol` is approximated by the function `approx`, giving a list of
    portion locations and volumes. For each portion `(r',dv')`, the vector field `vF`
    is evaluated at position `r'` and scaled by `dv'`. We then sum these vectors to
    give the approximation to the integral.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 25-4](ch25.xhtml#ch25tab4) shows a correspondence between mathematical
    notation and Haskell notation in the definition of the vector volume integral.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 25-4:** Correspondence Among Continuous Mathematical Notation, Discrete
    Mathematical Notation, and Haskell Notation for the Vector Volume Integral'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Continuous math** | **Discrete math** | **Haskell** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *V* |  | `vol` |'
  prefs: []
  type: TYPE_TB
- en: '| *dv*′ | Δ*v[i]* | `dv''` |'
  prefs: []
  type: TYPE_TB
- en: '| **F**(**r**′)*dv*′ | **F**(**r**[*i*])Δ*v[i]* | `vF r'' ^* dv''` |'
  prefs: []
  type: TYPE_TB
- en: This table is analogous to the last few rows of [Table 25-3](ch25.xhtml#ch25tab3).
    One important difference between the two is that each patch for a surface integral
    is a vector, while each bit of volume for a volume integral is a scalar.
  prefs: []
  type: TYPE_NORMAL
- en: Back to Electric Field
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We need to give only two items to find the electric field produced by a volume
    charge: the volume charge density *ρ*, expressed as a scalar field, and the volume
    that describes the geometry of the charge. The type signature of the following
    function, which is a Haskell translation of Equation 25.8, makes it clear that
    the electric field depends only on these two items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have functions to calculate the electric field produced by a line
    charge, a surface charge, and a volume charge, we have completed the definition
    of `eField` we began earlier in the chapter. We now have a method to find the
    electric field produced by any charge distribution. In writing functions to calculate
    the electric field, we spent some time discussing three types of vector integrals:
    the vector line integral for line charges, the vector surface integral for surface
    charges, and the vector volume integral for volume charges. With these integrals
    fresh in our minds, now is a good time to extend our integral methods to scalar
    integrals, which we used in the last chapter to calculate total charge.'
  prefs: []
  type: TYPE_NORMAL
- en: Scalar Integrals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the process of calculating the electric field produced by a line charge,
    a surface charge, or a volume charge, we introduced the vector line integral,
    the vector surface integral, and the vector volume integral. We used these integrals
    to add up the vector contributions to the electric field from each piece of charge.
    There are situations in which we need to add up scalar contributions to some quantity
    that come from sources on a curve, a surface, or a volume. This is the purpose
    of the scalar line integral, scalar surface integral, and scalar volume integral.
    Now that we have gone through the details for the vector integrals, it will be
    relatively easy to understand the scalar integrals.
  prefs: []
  type: TYPE_NORMAL
- en: Scalar Line Integral
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The scalar line integral takes a scalar field *f* and a curve *C* as input and
    returns a scalar as output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The integral is defined, and also approximated, by dividing the curve *C* into
    many small segments, exactly as we did for the vector line integral. The scalar
    field *f* is evaluated at each point **r**[*i*] at the segment Δ**l**[*i*], multiplied
    by the length Δ*l[i]* of the segment, and then added.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/494equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the Haskell definition of a scalar line integral:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The curve `c` is approximated by the function `approx`, which is provided as
    an input. For each segment `dl'` at position `r'`, the scalar field `f` is evaluated
    at position `r'` and multiplied by the magnitude of `dl'`. We then sum these numbers
    to give the approximation to the integral.
  prefs: []
  type: TYPE_NORMAL
- en: Scalar Surface Integral
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The scalar surface integral takes a scalar field *f* and a surface *S* as input
    and returns a scalar as output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The integral is defined, and also approximated, by dividing the surface *S*
    into many small patches, exactly as we did for the vector surface integral. The
    scalar field *f* is evaluated at each point **r**[*i*] at the patch Δ**a**[*i*],
    multiplied by the magnitude *Δa[i]* of the patch, and then added.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/495equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the Haskell definition of a scalar surface integral:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The surface `s` is approximated by the function `approx`. For each patch `da'`
    at position `r'`, the scalar field `f` is evaluated at position `r'` and multiplied
    by the magnitude of `da'`. We then sum these numbers to give the approximation
    to the integral.
  prefs: []
  type: TYPE_NORMAL
- en: Scalar Volume Integral
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The scalar volume integral takes a scalar field *f* and a volume *V* as input
    and returns a scalar as output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The integral is defined, and also approximated, by dividing the volume *V* into
    many small portions, exactly as we did for the vector volume integral. The scalar
    field *f* is evaluated at each portion, multiplied by the volume Δ[v*i*] of the
    portion, and then added.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/495equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the Haskell definition of a scalar volume integral:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The volume `vol` is approximated by the function `approx`. For each portion
    `dv'` at position `r'`, the scalar field `f` is evaluated at position `r'` and
    multiplied by `dv'`. We then sum numbers to give the approximation to the integral.
  prefs: []
  type: TYPE_NORMAL
- en: Before we leave this chapter, there is one detail left to discuss, and that’s
    the method we’ll use to approximate curves, surfaces, and volumes when we do integrals
    over these shapes. Let’s turn to that detail now.
  prefs: []
  type: TYPE_NORMAL
- en: Approximating Curves, Surfaces, and Volumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve seen multiple situations in which we want to add things up over a curve,
    surface, or volume by doing a line integral, surface integral, or volume integral.
    When the things we want to add up are vectors, we use a vector line integral,
    vector surface integral, or vector volume integral. Similarly, when the things
    we want to add up are scalars, we use a scalar line integral, scalar surface integral,
    or scalar volume integral. Whether we are adding scalars or vectors, our methods
    require us to approximate curves, surfaces, and volumes as finite lists of data.
    This approximation is the subject of this section; although there are many ways
    this approximation can be done, we’ll give only one method for approximating each
    geometrical object. The subject of numerical analysis is concerned with exploring
    different ways to make these approximations, examining the trade-offs involved,
    and doing it cleverly and efficiently. In our case, we’re concerned with doing
    it simply and understandably.
  prefs: []
  type: TYPE_NORMAL
- en: Approximating a Curve
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recall that a curve approximation is a way of turning a curve into a list of
    locations and displacement vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Our function `curveSample` approximates a curve as a number of segments, returning
    a list of segment positions and displacement vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The function takes an integer `n` that controls the number of segments generated,
    each segment being a pair of starting position and ending position.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Most of the work is done by the function `segments`, defined next, which returns
    a list of segments when given the integer `n` and the curve `c`. The local function
    `segCent` finds the center of each segment. The `rVF` vector field, introduced
    in [Chapter 22](ch22.xhtml), converts positions to displacement vectors, which
    the `shiftPosition` function then averages and converts back to positions.
  prefs: []
  type: TYPE_NORMAL
- en: The local function `segDisp` then computes the displacement vector of each segment.
    The displacement vector points from the beginning position of a segment to the
    ending position of the segment. The function `segDisp` is the uncurried version
    of `displacement` from [Chapter 22](ch22.xhtml), taking the two positions as a
    pair rather than a curried function.
  prefs: []
  type: TYPE_NORMAL
- en: We defined `segCent` and `segDisp` locally because they’re not used in any other
    functions. Note that we can still give them type signatures if we wish, although
    this is not required. Special-purpose functions like these are nice to define
    locally because it keeps fewer items in the global namespace and helps the reader
    of the code understand the relationship between the local function `segCent` and
    its parent function `curveSample`. The fact that `segCent` is local informs the
    reader that this function is not used elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: The function `segments` returns a list of segments when given a curve.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note the first argument to `segments` is an integer `n` that controls how many
    segments will be produced. We pass in the curve `Curve g a b` using pattern matching
    on the input because this function needs to refer to the curve’s parameter limits
    `a` and `b`, as well as to the parameterizing function `g`. The function begins
    by breaking the curve’s parameter interval from `a` to `b` into `n` equal subintervals
    using the function `linSpaced` defined below. At each of the `n+1` endpoints of
    these subintervals, we apply the function `g` to form a list `ps` of `n+1` positions
    along the curve. We then zip the list `ps` with its tail to produce the desired
    list of `n` segments. Zipping a list with its tail pairs the first and second
    items, the second and third items, the third and fourth items, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The function `linSpaced` returns a list of numbers that are linearly spaced.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The input `n` is the number of intervals, so the function returns a list of
    `n+1` numbers, starting at `x0` and going up to and including `x1`. Since n has
    type `Int` and x1 - x0 has type `R`, we need the fromIntegral function to convert
    n to type `R` before we do the division. We use the `take` function to treat the
    case in which the initial value `x0` and the final value `x1` are the same, in
    which case `dx` is 0 and the arithmetic sequence is an infinite list of the same
    number. The `take` function returns only the first `n+1` items of the infinite
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two examples of the use of `linSpaced`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve explored one way to approximate a curve, let’s do the same for
    a surface.
  prefs: []
  type: TYPE_NORMAL
- en: Approximating a Surface
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recall that a surface approximation is a way of turning a surface into a list
    of locations and vector areas.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Our function `surfaceSample` approximates a surface as a number of triangles,
    returning a list of triangle positions and vector areas.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The function takes an integer `n` that controls the number of triangles generated.
    Most of the work is done by the function `triangles`, which returns a list of
    triangles when given the integer `n` and the surface `s`. The function `triCenter`
    finds the center of each triangle, and the function `triArea` computes the vector
    area of each triangle. These two functions are defined below.
  prefs: []
  type: TYPE_NORMAL
- en: A triangle is described by specifying the positions of its three vertices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The triangles have an orientation, so the order in which we specify the vertices
    is important. If we are looking at a triangle from a place where the positions
    `p1`, `p2`, and `p3` of the vertices occur in a counterclockwise order, the orientation
    points from the triangle toward our viewing location, perpendicular to the triangle
    surface. The triangles `Tri p1 p2 p3`, `Tri p2 p3 p1`, and `Tri p3 p1 p2` all
    represent the same triangle with the same orientation, but the triangles `Tri
    p1 p3 p2`, `Tri p2 p1 p3`, and `Tri p3 p2 p1` represent triangles with the same
    vertices but an opposite orientation.
  prefs: []
  type: TYPE_NORMAL
- en: We find the center of a triangle by averaging the displacement vectors for the
    three vertices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We convert positions to displacement vectors with the `rVF` vector field, introduced
    in [Chapter 22](ch22.xhtml). We then average them and convert them back to a position
    with the `shiftPosition` function.
  prefs: []
  type: TYPE_NORMAL
- en: The vector area of a triangle is half the cross product of two of its vector
    edges. Since we care about the orientation of these triangles, we need to be careful
    about which way we do the cross product.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The function `triangles` returns a list of triangles when given a surface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note the first argument to `triangles` is an integer `n` that controls how many
    triangles will be produced. We pass in the surface `Surface g sl su tl tu` using
    pattern matching on the input because this function needs to refer to the surface’s
    parameter limits `sl` and `su`, as well as all of the other attributes of the
    surface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function begins by breaking the surface’s parameter interval from `sl`
    to `su` into `n` equal subintervals. At each of the `n+1` endpoints of these sub-intervals,
    we break the parameter interval from `tl s` to `tu s` into `n` equal subintervals,
    where `s` is the *s* parameter value at each subinterval endpoint. The local variable
    `sts :: [[(R,R)]]` is a list of lists, which can be thought of as an `n+1`-by-`n+1`
    matrix of parameter pairs corresponding to points on the surface. The local variable
    `stSquares :: [((R,R),(R,R),(R,R),(R,R))]` is a list of `n^2` “squares” of parameter
    pairs. Each of these squares is turned into two triangles by the local function
    `twoTriangles`. The function `triangles` returns a list of `2*n^2` triangles approximating
    the surface.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve shown one way to approximate a surface, let’s turn to the question
    of approximating a volume.
  prefs: []
  type: TYPE_NORMAL
- en: Approximating a Volume
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A volume approximation is a way of turning a volume into a list of locations
    and numerical volumes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Our function `volumeSample` approximates a volume by a number of tetrahedrons.
    A tetrahedron is a four-sided solid where each side is a triangle. The function
    returns a list of tetrahedron positions and numerical volumes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The function takes an integer `n` that controls the number of tetrahedrons used.
    Most of the work is done by the function `tetrahedrons`, defined below, which
    returns a list of tetrahedrons when given the integer `n` and the volume `v`.
    The function `tetCenter` finds the center of each tetrahedron, and the function
    `tetVolume` computes the numerical volume of each tetrahedron. These two functions
    are also defined below.
  prefs: []
  type: TYPE_NORMAL
- en: We can describe a tetrahedron by specifying the positions of its four vertices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We can find the center of a tetrahedron by averaging displacement vectors for
    the four vertices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This function is the natural extension of the `triCenter` function for triangles
    to tetrahedrons.
  prefs: []
  type: TYPE_NORMAL
- en: The volume of a tetrahedron is 1/6 of the *scalar triple product*, defined as
    **a** ⋅ (**b** × **c**), of three vector edges originating at one vertex or terminating
    at one vertex. The scalar triple product is also the determinant of the matrix
    whose columns are the three vector edges.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We use the `abs` function to guarantee a positive numerical volume.
  prefs: []
  type: TYPE_NORMAL
- en: Just as we used “parameter squares” to cover the parameter space of a surface,
    now we use “parameter cubes” to cover the parameter space of a volume. Let’s define
    a data type for parameter cube.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The function `tetrahedrons` returns a list of tetrahedrons when given a volume.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note the first argument to `tetrahedrons` is an integer `n` that controls how
    many tetrahedrons will be produced. We use pattern matching on the input to pass
    in the volume `Volume g sl su tl tu ul uu` because this function needs to refer
    to the volume’s parameter limits `sl` and `su` as well as all of the other attributes
    of the volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function begins by breaking the volume’s parameter interval from `sl` to
    `su` into `n` equal subintervals. At each of the `n+1` endpoints of these sub-intervals,
    we break the parameter interval from `tl s` to `tu s` into `n` equal subintervals,
    where `s` is the *s* parameter value at each subinterval endpoint. Finally, for
    the third dimension, we break each parameter interval from `ul s t` to `uu s t`
    into `n` equal subintervals, where `t` is the *t* parameter value at each sub-interval
    endpoint. The local variable `stus :: [[[(R,R,R)]]]` is a list of lists of lists,
    which can be thought of as an `n+1`-by-`n+1`-by-`n+1` array of parameter triples
    corresponding to points in the volume. The local variable `stCubes ::` `[ParamCube]`
    is a list of `n^3` parameter cubes. The local function `tets` turns each of these
    cubes into five tetrahedrons. The function `tetrahedrons` returns a list of `5*n^3`
    tetrahedrons approximating the volume.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter showed how to calculate the electric field produced by a charge
    distribution. We wrote functions to find the electric field produced by a point
    charge, a line charge, a surface charge, and a volume charge. On the way to that
    goal, we introduced the vector line integral, the vector surface integral, and
    the vector volume integral. We wrote a function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: that calculates the electric field of any charge distribution by combining the
    functions we wrote for each charge distribution.
  prefs: []
  type: TYPE_NORMAL
- en: After introducing the three sorts of vector integrals (line, surface, and volume),
    we took the opportunity to define three sorts of scalar integrals, in which we
    were adding up numbers rather than vectors. The chapter ended with a section on
    approximation of curves, surfaces, and volumes. Performing numerical integrals
    over these geometric objects requires that we have some way to carve the object
    up into a finite number of pieces. We showed one way to do this for each object.
    The next chapter on current distributions parallels the previous chapter on charge
    distributions. Just as charge is the source of electric fields, current is the
    source of magnetic fields.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 25.1.** Consider a line segment of charge, with uniform linear charge
    density *λ*[0]. Let us place this line segment on the x-axis from *x* = *–L*/2
    to *x* = *L*/2\. We want to find the electric field produced by this line segment
    at some point in the xy-plane. Write code to make a picture of the electric field
    produced by this line segment of charge. You may restrict your attention to the
    xy-plane. The electric field produced by a line segment of charge is an exactly
    solvable problem. Find or calculate the exact solution. Produce a picture of the
    exact electric field for comparison.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.2.** Make a picture of the electric field produced by a uniformly
    charged disk. Put the disk in the xy-plane and show the electric field in the
    xz-plane.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.3.** Make a graph of the magnitude of the electric field produced
    by a uniformly charged ball versus the distance from the ball’s center. Compare
    our numeric method to the exact solution.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.4.** Consider a ring of charge in the xy-plane with radius *R*
    and linear charge density *λ*(**r**) = *λ*[0] cos *ϕ*, where *ϕ* is the cylindrical
    coordinate and *R* and *λ*[0] are constants you can choose. Create a 3D visualization
    of the electric field produced by this charge distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.5.** An exercise in the previous chapter asked you to write a
    charge distribution for the hydrogen atom in its ground state. Find the electric
    field produced by the hydrogen atom at an arbitrary point in space. Make a graph
    of the magnitude of the electric field as a function of the distance from the
    proton.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.6.** Produce an image of the electric field created by four equal
    positive point charges located at the corners of a square.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.7.** Produce an image of the electric field in the xz-plane created
    by a square plate with uniform positive surface charge density in the xy-plane.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.8.** Produce images of the electric field in the xy-plane and
    the yz-plane created by a uniformly charged circular ring in the xy-plane centered
    on the origin.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.9.** If the functions `scalarLineIntegral` and `vectorLineIntegral`
    seem like they are basically doing the same thing, and that we ought to be able
    to exploit some sort of commonality to combine them into one function that can
    do both, you are right.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we define a general field that could be a scalar field, a vector field,
    or something else.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The type `ScalarField` is the same as `Field R` and the type `VectorField` is
    the same as `Field Vec`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we make a type class for abstract vectors, which are types that have a
    zero vector, can be added, and can be scaled by a real number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We write a function `sumG` to add a list of abstract vectors. This function
    is modeled after the `sumV` function from [Chapter 10](ch10.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: With these tools, we can write a general line integral function that performs
    the role of both the scalar line integral and the vector line integral.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Write instance declarations that will make the types `R` and `Vec` instances
    of type class `AbstractVector`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.10.** *Gauss’s law* asserts that the *electric flux* through
    a closed surface is proportional to the charge enclosed by the surface. The *flux*
    of a vector field describes the total flow through a surface if we imagine that
    the vectors are the velocity of some fluid. The electric flux Φ*[E]* through a
    surface *S* is defined to be the dotted surface integral of the electric field.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/504equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The definition for the dotted surface integral is a lot like that for the vector
    surface integral we defined in this chapter. The integral is defined by dividing
    the surface *S* into many small patches. Each patch Δ**a**[*i*] is a vector whose
    magnitude gives the area of the patch and whose direction points perpendicular
    to the patch. The electric field **E** is evaluated at a point **r**[*i*] on or
    near the patch Δ**a**[*i*] and dotted with the vector area Δ**a**[*i*] of the
    patch. We then add up these numbers to form the sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/504equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The integral is the limit of this vector sum as the areas of the patches approach
    0 and the number of patches becomes arbitrarily large.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is Haskell code for the dotted surface integral, also known as a *flux
    integral*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: (a) Write a function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: that accepts an electric field and a surface as input and returns electric flux
    as output.
  prefs: []
  type: TYPE_NORMAL
- en: (b) Write a function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: that returns the electric flux through a given surface produced by the electric
    field of a given charge distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.11.** Compare the electric field `eFieldLineDipole` produced
    by NaCl, viewed as a line dipole, to the electric fields of the simple dipole
    and the ideal dipole. Make a vector field picture similar to those we made for
    the simple dipole and the ideal dipole.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.12.** The point charge is the fundamental source of electric
    field. Given a surface approximation, we can find the electric field of a surface
    charge by viewing it as a collection of point charges. The surface approximation
    tells us where to place the point charges and what values they should have. In
    this way, we skip over the vector surface integral that was our primary method
    for calculating the field.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Write similar functions to calculate the electric field from a line charge and
    a volume charge.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.13.** Write a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: that uses `scalarSurfaceIntegral` to calculate the surface area of a surface.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.14.** The electric potential is a scalar field that can be defined
    in terms of the electric field as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/505equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The integral is a dotted line integral over any curve *C* that begins at the
    origin and ends at the field point **r**. The conservative nature of the electrostatic
    field **E** guarantees the result is independent of the chosen curve *C*.
  prefs: []
  type: TYPE_NORMAL
- en: The dotted line integral is defined and approximated by dividing the curve *C*
    into many small segments, exactly as we did for the vector line integral.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/505equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The vector field **F** is evaluated at each point **r**[*i*] of the approximation,
    dotted with the displacement Δ**l**[*i*] of the segment, and then added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the Haskell definition of the dotted line integral:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Write a function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: that takes the electric field as input and returns the electric potential as
    output. To write this function, you will need to construct a curve that begins
    at the origin and ends at the field point where we wish to find the electric potential.
    This curve can then be passed to `dottedLineIntegral`.
  prefs: []
  type: TYPE_NORMAL
