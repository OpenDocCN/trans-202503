- en: '25'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '25'
- en: ELECTRIC FIELD
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 电场
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: In the 1800s, Faraday and Maxwell discovered a new way to think about electric
    (and magnetic) phenomena that forms the basis for today’s electromagnetic theory.
    In this 19th century view, one particle does not directly apply a force to another
    particle, as Coulomb’s law would imply. Instead, one particle creates an *electric
    field* that applies a force to the second particle.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在19世纪，法拉第和麦克斯韦发现了一种新的思考电现象（以及磁现象）的方法，这为今天的电磁理论奠定了基础。在这种19世纪的观点中，一个粒子并不会像库仑定律所暗示的那样直接施加力于另一个粒子。相反，一个粒子会创建一个*电场*，这个电场施加力于第二个粒子。
- en: We’ll start this chapter with a short discussion of exactly what an electric
    field is. Then, we’ll show how to calculate the electric field produced by each
    of the charge distributions we studied in the previous chapter. We’ll begin with
    the electric field produced by a point charge, which is really the fundamental
    piece that governs all of the other distributions. After a single point charge,
    we’ll look at the electric field produced by multiple point charges. As an example,
    we’ll compare the electric fields produced by a simple electric dipole composed
    of two point charges with an ideal electric dipole.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简短的讨论电场究竟是什么开始本章内容。接着，我们将展示如何计算前一章中研究的每一种电荷分布所产生的电场。我们将从点电荷产生的电场开始，因为这实际上是控制所有其他电荷分布的基本因素。介绍了单个点电荷后，我们将探讨由多个点电荷产生的电场。作为一个例子，我们将比较由由两个点电荷组成的简单电偶极子与理想电偶极子产生的电场。
- en: To calculate the electric field, we’ll need to introduce a few new mathematical
    tools. Finding the electric field produced by a line charge requires a vector
    line integral; finding the electric field produced by a surface charge requires
    a vector surface integral; and finding the electric field produced by a volume
    charge requires a vector volume integral. We’ll introduce these as needed, and
    we’ll close out the chapter with the details of sampling or discretizing curves,
    surfaces, and volumes, which will allow us to do numerical line, surface, and
    volume integrals.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算电场，我们需要引入一些新的数学工具。计算由线电荷产生的电场需要矢量线积分；计算由面电荷产生的电场需要矢量面积分；计算由体电荷产生的电场需要矢量体积分。我们会根据需要引入这些工具，并在本章结束时介绍如何对曲线、面和体进行采样或离散化，这将使我们能够进行数值线积分、面积分和体积分。
- en: What Is an Electric Field?
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是电场？
- en: An electric field is a *vector field* of the kind we talked about in [Chapter
    22](ch22.xhtml). The electric field associates a vector **E**(**r**) with each
    point **r** in space; that vector helps determine the force on a particle if there
    is a particle at point **r** in space.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 电场是我们在[第22章](ch22.xhtml)讨论过的*矢量场*。电场将一个矢量**E**(**r**)与空间中每个点**r**关联；如果在空间的点**r**处有一个粒子，这个矢量帮助决定粒子所受的力。
- en: Is the electric field a physical thing, or is it an abstraction we use to think
    about electricity? I would argue it is both. The electric field is an abstract
    mathematical construct, as are so many of the ideas of modern theoretical physics.
    We describe it using mathematical language and posit axioms about it as though
    it had no more physical reality than a 7×7 matrix of irrational numbers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 电场是一个物理实体，还是我们用来思考电现象的抽象概念？我认为它两者兼具。电场是一个抽象的数学构造，就像现代理论物理学中许多概念一样。我们用数学语言来描述它，并假设一些公理，好像它的物理实在性不比一个由无理数构成的7×7矩阵更真实。
- en: In static situations, where charges are not moving or accelerating, we can remain
    ambivalent about the reality of the electric field, or even deny it. These static
    situations are the ones where Coulomb’s law makes good predictions, and the new
    electromagnetic theory that speaks of an electric field makes the same predictions.
    In static situations, then, the electric field can be viewed as merely an abstraction.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态情况下，电荷没有运动或加速时，我们可以对电场的真实性保持模棱两可的态度，甚至可以否定它。在这些静态情况下，库仑定律做出了良好的预测，而描述电场的新的电磁理论则做出了相同的预测。因此，在静态情况下，电场可以被看作仅仅是一个抽象。
- en: In dynamic situations, on the other hand, where electric charge is moving and/or
    accelerating, it becomes much harder to maintain the view that the electric field
    is only a calculational tool. The reason is that modern electromagnetic theory
    is, in addition to being a theory of electricity and magnetism, a theory of light
    and radiation. Maxwell’s insight was that electric and magnetic fields could serve
    to describe visible light and an entire spectrum of nonvisible light-like waves,
    including radio waves and microwaves. These waves are now viewed as waves in the
    electric and magnetic fields. Light is, according to the Faraday-Maxwell theory,
    an electromagnetic wave. To the extent that light and radiation are physical and
    real, it seems the electric field is also physical and real.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在动态情况下，当电荷在运动和/或加速时，我们就很难再坚持电场仅仅是一个计算工具的观点。原因在于，现代电磁理论除了是电和磁的理论外，还是光和辐射的理论。麦克斯韦的洞察力在于，电场和磁场可以用来描述可见光以及整个非可见光谱的光波，包括无线电波和微波。这些波现在被视为电场和磁场中的波动。根据法拉第-麦克斯韦理论，光是一种电磁波。由于光和辐射是物理的、真实的，因此电场也似乎是物理的、真实的。
- en: Introducing the electric field breaks the analysis of electrical situations
    into two parts. The first part is the creation of the electric field by charge,
    which we’ll discuss in this chapter. The second part is the force that the electric
    field applies to (a second) charge, which we’ll discuss in [Chapter 28](ch28.xhtml).
    [Figure 25-1](ch25.xhtml#ch25fig1) shows the electric field’s role in a situation
    with two charges.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 引入电场将电气情况的分析分为两部分。第一部分是电荷产生电场，这是我们将在本章中讨论的内容。第二部分是电场对（第二个）电荷施加的力，这是我们将在[第28章](ch28.xhtml)中讨论的内容。[图25-1](ch25.xhtml#ch25fig1)展示了电场在两个电荷情境中的作用。
- en: '![Image](Images/474equ01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/474equ01.jpg)'
- en: '*Figure 25-1: Conceptual diagram of the role of the electric field when two
    charged particles are present. Particle 1 creates the electric field. The electric
    field exerts a force on particle 2.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图25-1：当两个带电粒子存在时，电场的作用概念图。粒子1产生电场，电场对粒子2施加力。*'
- en: We say that the electric field *mediates* the interaction between the two particles.
    In this chapter, we focus on the electric field created by static, or stationary,
    charges and charge distributions. The real benefit of the electric field idea
    appears when charges are moving rapidly or accelerating because Coulomb’s law
    fails to make good predictions in these cases. In general, the Maxwell equations,
    which we discuss in [Chapter 29](ch29.xhtml), describe the creation and evolution
    of the electric field. The Maxwell equations describe the electric field created
    by charge in any sort of motion, and they make different predictions from Coulomb’s
    theory when charge is moving or accelerating. Our introduction of the electric
    field in simpler static situations will put us in a better position to discuss
    the Maxwell equations later.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说电场*介导*了两个粒子之间的相互作用。在本章中，我们主要关注由静止电荷或电荷分布产生的电场。当电荷快速移动或加速时，电场概念的实际好处就显现出来，因为库仑定律在这些情况下无法作出准确预测。一般来说，我们将在[第29章](ch29.xhtml)讨论的麦克斯韦方程描述了电场的产生和演化。麦克斯韦方程描述了电荷在任何形式运动中产生的电场，并且当电荷运动或加速时，它们会做出不同于库仑理论的预测。我们在更简单的静态情形下引入电场的概念，将有助于我们在后续讨论麦克斯韦方程时更加得心应手。
- en: Introductory Code
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引言代码
- en: '[Listing 25-1](ch25.xhtml#ch25list1) shows the first lines of code in the `ElectricField`
    module we’ll write in this chapter.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单25-1](ch25.xhtml#ch25list1)展示了我们将在本章中编写的`ElectricField`模块的第一行代码。'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 25-1: Opening lines of code for the ElectricField module*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单25-1：电场模块的开头代码行*'
- en: We use types and functions from the `SimpleVec` module of [Chapter 10](ch10.xhtml),
    the `CoordinateSystems` module of [Chapter 22](ch22.xhtml), the `Geometry` module
    of [Chapter 23](ch23.xhtml), and the `Charge` module of [Chapter 24](ch24.xhtml).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了来自[第10章](ch10.xhtml)的`SimpleVec`模块、[第22章](ch22.xhtml)的`CoordinateSystems`模块、[第23章](ch23.xhtml)的`Geometry`模块和[第24章](ch24.xhtml)的`Charge`模块中的类型和函数。
- en: Charge Creates an Electric Field
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电荷产生电场
- en: The first part of the modern two-part view of electricity is that electric charge
    creates the electric field. We want to calculate the electric field created by
    charges of various sorts. We’ll start with a point charge, the simplest charge
    distribution, and then move to more complex charge distributions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现代电学的两部分观点的第一部分是电荷产生电场。我们想要计算由各种电荷产生的电场。我们将从最简单的电荷分布——点电荷开始，然后转向更复杂的电荷分布。
- en: Electric Field Created by a Point Charge
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 点电荷产生的电场
- en: 'A particle with charge *q*[1] located at position **r**[1] will create an electric
    field **E** given by the following equation:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带电量为*q*[1]的粒子位于位置**r**[1]，将根据以下方程产生电场**E**：
- en: '![Image](Images/476equ01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/476equ01.jpg)'
- en: The electric field **E** is a function from position to vectors (in other words,
    a vector field).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 电场**E**是从位置到向量的函数（换句话说，是一个向量场）。
- en: A positive point charge produces an electric field that points away from the
    positive charge. A negative point charge produces an electric field that points
    toward the negative charge.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正点电荷产生的电场指向远离正电荷的方向。一个负点电荷产生的电场指向指向负电荷的方向。
- en: We introduced the constant *ϵ*[0], called the *permittivity of free space*,
    in [Chapter 21](ch21.xhtml); it is defined as
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第21章](ch21.xhtml)中介绍了常数*ϵ*[0]，称为*真空的介电常数*；它的定义为
- en: '![Image](Images/476equ02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/476equ02.jpg)'
- en: where *c* is the speed of light in vacuum and *μ*[0] is a constant called the
    *permeability of free space*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*c*是真空中的光速，*μ*[0]是一个常数，称为*真空的磁导率*。
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The speed of light in vacuum is exactly *c* = 299792458 m/s (the meter is defined
    to be the length that light travels in a vacuum in 1/299792458 s).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 真空中的光速是* c * = 299792458 m/s（米的定义是光在真空中在1/299792458秒内传播的距离）。
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Prior to the 2019 SI revision, the constant *μ*[0] was defined to be exactly
    *μ*[0] = 4*π* × 10^(–7) N/A². The 2019 revision chooses other constants to be
    exact, leaving *μ*[0] to be determined by experiment. Nevertheless, it remains
    very close to this value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在2019年国际单位制（SI）修订之前，常数*μ*[0]被定义为精确值*μ*[0] = 4*π* × 10^(–7) N/A²。2019年修订选择了其他常数为精确值，留下*μ*[0]由实验确定。然而，它仍然非常接近这个值。
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have *ϵ*[0] and *μ*[0] because the units in which we measure electric and
    magnetic fields (or voltage and current) are rooted in experiments measuring the
    forces between currents and charges. These experiments predate the modern electromagnetic
    theory based on Maxwell’s equations. Keeping the conventional units in the presence
    of Maxwell’s equations requires *ϵ*[0] and *μ*[0] to make the units work out.
    If you’re willing to give up the conventional units of current and voltage (amperes
    and volts), you can write Maxwell’s equations without *ϵ*[0] and *μ*[0].
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有*ϵ*[0]和*μ*[0]是因为我们测量电场和磁场（或电压和电流）所使用的单位来源于实验，实验测量了电流和电荷之间的力。这些实验早于基于麦克斯韦方程的现代电磁理论。在麦克斯韦方程的框架下保持常规单位需要*ϵ*[0]和*μ*[0]来使单位得以统一。如果你愿意放弃电流和电压的常规单位（安培和伏特），你可以不使用*ϵ*[0]和*μ*[0]写出麦克斯韦方程。
- en: The function `eFieldFromPointCharge` encodes Equation 25.1, taking the point
    particle’s charge and position as input and producing the electric field as output.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`eFieldFromPointCharge`编码了方程25.1，输入点粒子的电荷和位置，并输出电场。
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The local name `d` stands for the displacement vector **r** – **r**[1] from
    the charge’s position **r**[1] to the *field point* **r**. The field point is
    a position where we are looking for or talking about the electric field. No particle
    or matter need be present at the field point.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 局部名称`d`表示从电荷位置**r**[1]到*场点* **r**的位移向量**r** – **r**[1]。场点是我们寻找或讨论电场的位置。场点处不需要存在任何粒子或物质。
- en: In [Chapter 24](ch24.xhtml), we wrote a type for charge distribution. Over the
    course of the present chapter, we will write functions to calculate the electric
    field produced by each sort of charge distribution. This allows us to encapsulate
    the idea that charge creates an electric field in the following function, which
    produces an electric field given any charge distribution.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第24章](ch24.xhtml)中，我们为电荷分布写了一个类型。在本章中，我们将编写函数来计算由各种电荷分布产生的电场。这使我们能够将电荷产生电场的概念封装在以下函数中，该函数根据任意电荷分布产生电场。
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The function `eField` uses pattern matching on the input to treat each sort
    of charge distribution separately. For a point charge, it uses the function `eFieldFromPointCharge`
    we wrote earlier. For line, surface, and volume charges, it uses functions we’ll
    write later in this chapter. For a combination distribution with the constructor
    `MultipleCharges`, it uses the *principle of superposition*, which says that the
    electric field produced by multiple charges is the vector sum of the electric
    fields produced by each individual charge. In this case, we use the function `addVectorFields`
    from [Chapter 22](ch22.xhtml) to combine the electric fields of the component
    distributions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`eField`使用模式匹配对输入进行处理，以分别处理每种电荷分布类型。对于点电荷，它使用我们之前编写的函数`eFieldFromPointCharge`。对于线电荷、面电荷和体电荷，它使用我们将在本章后面编写的函数。对于具有构造函数`MultipleCharges`的组合分布，它使用*叠加原理*，即多个电荷产生的电场是由每个单独电荷产生的电场的矢量和。在这种情况下，我们使用来自[第22章](ch22.xhtml)的函数`addVectorFields`来组合各组成分布的电场。
- en: The function `eField` is an explicitly recursive function. We see this in the
    last line of the definition, where `eField` is defined in terms of `eField`. I
    have tried to avoid writing explicitly recursive functions because they are harder
    to understand. In this case, the explicit recursion appears only in the `MultipleCharges`
    clause. It means that when multiple charges are encountered, the appropriate thing
    to do is, first, find the electric field of each component charge (using the same
    `eField` function, but probably one of the other clauses), and, second, add these
    component electric fields together.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`eField`是一个显式递归函数。在定义的最后一行，我们可以看到`eField`是通过`eField`来定义的。我尽量避免编写显式递归函数，因为它们通常更难理解。在这种情况下，显式递归仅出现在`MultipleCharges`条款中。这意味着，当遇到多个电荷时，正确的做法是，首先找到每个组成电荷的电场（使用相同的`eField`函数，但可能是其他条款中的一个），其次将这些组成电场加在一起。
- en: The electric field produced by a proton at the origin is given by the vector
    field `eField protonOrigin`, where `protonOrigin` is the charge distribution we
    wrote in [Chapter 24](ch24.xhtml) for a proton at the origin. [Figure 25-2](ch25.xhtml#ch25fig2)
    shows three ways of visualizing the electric field produced by a proton.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由质子在原点产生的电场由矢量场`eField protonOrigin`给出，其中`protonOrigin`是我们在[第24章](ch24.xhtml)中为原点处的质子编写的电荷分布。[图25-2](ch25.xhtml#ch25fig2)展示了三种可视化质子产生的电场的方法。
- en: '![Image](Images/478fig01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/478fig01.jpg)'
- en: '*Figure 25-2: Three ways of visualizing the electric field eField protonOrigin
    produced by a proton. The upper-left image is produced by eFieldPicProton2D, the
    upper-right image is produced by eFieldPicProtonGrad, and the lower picture is
    a screenshot of the 3D interactive image produced by eFieldPicProton3D.*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*图25-2：三种可视化质子产生的电场eField protonOrigin的方法。左上图由eFieldPicProton2D生成，右上图由eFieldPicProtonGrad生成，下方图是由eFieldPicProton3D生成的3D交互式图像的截图。*'
- en: The following code produced the upper-left picture in [Figure 25-2](ch25.xhtml#ch25fig2).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码生成了[图25-2](ch25.xhtml#ch25fig2)左上方的图像。
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Sample points lie in the xy-plane, but any plane through the point charge would
    give the same image. Each arrow represents the electric field at the location
    of the arrow’s tail. In this picture, electric field strength is proportional
    to the length of arrows displayed. Since the electric field produced by a point
    charge is inversely proportional to the square of the distance from the point
    charge, the length of these arrows would get arbitrarily long as we get closer
    to the point charge. Thus, we chose our sample points and scale factor so that
    no outrageously long arrows appear on our diagram.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 样本点位于xy平面中，但通过点电荷的任何平面都会给出相同的图像。每个箭头代表箭头尾部位置的电场。在这张图中，电场强度与显示箭头的长度成正比。由于点电荷产生的电场与距离点电荷的平方成反比，因此当我们接近点电荷时，这些箭头的长度会变得非常长。因此，我们选择了合适的样本点和比例因子，以避免在图中出现过长的箭头。
- en: 'The electric field produced by a proton at a point 1 m away is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由一个质子在距离1米的地方产生的电场如下所示：
- en: '![Image](Images/479equ01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/479equ01.jpg)'
- en: The scale factor of `3e-9` means that an electric field of 3 × 10^(–9) N/C is
    displayed with an arrow of length 1 m in the scale of the picture. The arrows
    closest to the proton are 1 m away. Their lengths should be about (1.4 × 10^(–9)
    N/C)/(3 × 10^(–9) N/C), or about half, of the distance from the proton to the
    tail of the vector, which is true in this picture.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`3e-9`的尺度因子意味着在图像的尺度中，3 × 10^(-9) N/C的电场显示为1米长的箭头。离质子的箭头距离为1米。它们的长度应该大约是(1.4
    × 10^(-9) N/C)/(3 × 10^(-9) N/C)，或者大约是从质子到矢量尾部的距离的一半，这在这张图中是成立的。'
- en: 'Now consider the following code, which produced the upper-right picture in
    [Figure 25-2](ch25.xhtml#ch25fig2):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑以下代码，它生成了[图25-2](ch25.xhtml#ch25fig2)右上方的图片：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Again, sample points lie in the xy-plane. Each arrow represents the electric
    field at the location of the arrow’s center. In this picture, the electric field
    is stronger at the darker arrows and weaker at the lighter arrows.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 再次地，样本点位于xy平面中。每个箭头表示箭头中心位置的电场。在这张图中，电场在较暗的箭头处较强，在较亮的箭头处较弱。
- en: 'Lastly, we have the following code, which produced the lower picture in [Figure
    25-2](ch25.xhtml#ch25fig2):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有以下代码，它生成了[图25-2](ch25.xhtml#ch25fig2)下方的图片：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you run the program `eFieldPicProton3D`, perhaps by making a stand-alone
    program and calling it `main`, a 3D vector field will pop up. You can move it
    around and rotate it with your mouse or pointing device.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行程序`eFieldPicProton3D`，也许通过创建一个独立程序并命名为`main`，将会弹出一个3D矢量场。你可以用鼠标或指点设备移动并旋转它。
- en: This concludes our discussion of the electric field produced by a single point
    charge. Next we’ll look at multiple charges.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对单一点电荷产生的电场的讨论。接下来，我们将研究多个电荷的情况。
- en: Electric Field Created by Multiple Charges
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 由多个电荷产生的电场
- en: Equation 25.1 is the fundamental equation for the electric field produced by
    a point charge. The principle of superposition says that the electric field produced
    by multiple charges is the vector sum of the electric fields produced by each
    charge alone. For a collection of point charges, with *i* labeling the particles,
    *q[i]* the charge of particle *i*, and **r**[*i*] the location of particle *i*,
    the electric field produced at field point **r** by the collection is
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 方程25.1是由点电荷产生的电场的基本方程。叠加原理表明，多个电荷产生的电场是每个电荷单独产生的电场的矢量和。对于一组点电荷，*i*标记粒子，*q[i]*是粒子*i*的电荷，**r**[*i*]是粒子*i*的位置，那么由这组电荷在场点**r**产生的电场为：
- en: '![Image](Images/479equ02.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/479equ02.jpg)'
- en: This principle of superposition is already encoded in our `eField` function.
    Whenever we have multiple charges in a charge distribution, they are tagged with
    a `MultipleCharges` data constructor, which tells the `eField` function to apply
    the superposition principle. We used this `MultipleCharges` data constructor in
    the last chapter when we wrote the `simpleDipole` charge distribution. So, although
    Equation 25.2 is a useful and important equation, telling us how to find the electric
    field from multiple point charges, we do not need to write any additional code;
    the superposition principle is already being applied automatically by the `eField`
    function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 叠加原理已经在我们的`eField`函数中编码。当我们在一个电荷分布中有多个电荷时，它们会被标记为`MultipleCharges`数据构造器，这告诉`eField`函数应用叠加原理。在上一章中，我们在编写`simpleDipole`电荷分布时使用了这个`MultipleCharges`数据构造器。因此，尽管方程25.2是一个有用且重要的方程，告诉我们如何从多个点电荷中找到电场，但我们不需要编写额外的代码；叠加原理已经被`eField`函数自动应用。
- en: 'As a first example of multiple charges, we’ll look at a simple electric dipole
    composed of two particles: one positively charged and the other with an equal
    but opposite negative charge.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为多个电荷的第一个例子，我们将研究一个简单的电偶极子，由两个粒子组成：一个带正电，另一个带有大小相等但相反的负电荷。
- en: Electric Field of a Simple Electric Dipole
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 简单电偶极子的电场
- en: 'In the previous chapter, we introduced `simpleDipole`, a charge distribution
    composed of two oppositely charged point particles separated by some distance.
    The electric dipole moment of sodium chloride is 2.99 × 10^(–29) C m. The interatomic
    distance between the sodium and chlorine atoms is 2.36 × 10^(–10) m. If we think
    of NaCl as composed of two point particles, the sodium has an effective charge
    about 0.8 of the proton charge and the chlorine has an effective charge about
    – 0.8 of the proton charge. The effective charge is not an integer multiple of
    the elementary charge because the electrons are shared between the ions. Here
    is a charge distribution for NaCl, viewed as a simple electric dipole:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了`simpleDipole`，它是由两个带相反电荷的点粒子组成的电荷分布，粒子之间有一定的距离。氯化钠的电偶极矩为2.99 × 10^(–29)
    C·m。钠原子和氯原子之间的原子间距离为2.36 × 10^(–10) m。如果我们将NaCl视为由两个点粒子组成，钠原子的有效电荷大约是质子电荷的0.8倍，氯原子的有效电荷大约是质子电荷的–0.8倍。由于电子在离子之间共享，有效电荷不是基本电荷的整数倍。以下是NaCl的电荷分布，视为简单电偶极子：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To find the electric field of this charge distribution, we simply use the `eField`
    function. Since a `simpleDipole` is a charge distribution constructed with `MultipleCharges`
    of two `PointCharge`s, the `eField` function comes across the `MultipleCharges`
    constructor first and uses that clause in the definition. The `MultipleCharges`
    clause says to first find the electric field of each point charge, which it does
    by using `eField` itself, but this time with the `PointCharge` constructor. So
    `eField` actually gets used three times. We use it once, but then it uses itself
    two more times to find the electric fields of each point charge, and then adds
    them together and sends the result back to us.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算此电荷分布的电场，我们只需使用`eField`函数。由于`simpleDipole`是由`MultipleCharges`构造的两`PointCharge`点电荷组成的电荷分布，`eField`函数首先遇到`MultipleCharges`构造器，并使用该条款进行定义。`MultipleCharges`条款指示首先计算每个点电荷的电场，它通过使用`eField`自身来完成这一步骤，但这次是通过`PointCharge`构造器。因此，`eField`实际上被使用了三次。我们使用它一次，但它自己再调用两次来计算每个点电荷的电场，然后将结果加起来并返回给我们。
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The left picture in [Figure 25-3](ch25.xhtml#ch25fig3) shows the electric field
    produced by NaCl. The electric field points away from the positively charged sodium
    atom at the top of the picture and toward the negatively charged chlorine atom
    at the bottom of the picture. The right picture shows the electric field produced
    by an ideal dipole, described in the next section. We show them side by side in
    one figure to see what’s common and what’s different. The central parts of the
    pictures are different because charge is located in different places. The outer
    parts of the pictures are similar; any electric dipole produces this same electric
    field pattern at places a little bit away from the source.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 25-3](ch25.xhtml#ch25fig3)左侧的图片显示了NaCl产生的电场。电场从图片顶部的带正电钠原子指向图片底部带负电氯原子。右侧图片显示了由理想偶极子产生的电场，理想偶极子的描述将在下一节中给出。我们将它们并排展示在一张图中，以便观察它们的相同点和不同点。图片的中央部分不同，因为电荷位于不同的位置；而图片的外部部分相似，任何电偶极子在距离源稍远的地方都会产生相同的电场模式。'
- en: '![Image](Images/481fig01.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/481fig01.jpg)'
- en: '*Figure 25-3: Electric field produced by a simple dipole (left) and an ideal
    dipole (right). The simple dipole consists of one positive point charge and one
    negative point charge. The left image shows the electric field eFieldSodiumChloride
    and is produced by eFieldPicSimpleDipole; the right image shows the electric field
    eFieldIdealDipole kHat and is produced by eFieldPicIdealDipole.*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 25-3：由简单偶极子（左）和理想偶极子（右）产生的电场。简单偶极子由一个正点电荷和一个负点电荷组成。左侧图像显示了由eFieldSodiumChloride产生的电场，电场由eFieldPicSimpleDipole产生；右侧图像显示了由eFieldIdealDipole
    kHat产生的电场，电场由eFieldPicIdealDipole产生。*'
- en: 'Here is the code that produced the picture on the left in [Figure 25-3](ch25.xhtml#ch25fig3):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是产生[图 25-3](ch25.xhtml#ch25fig3)左侧图片的代码：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The picture shows a square in the yz-plane, in which *y* runs from –3 × 10^(–10)
    m to 3 × 10^(–10) m, and *z* runs across the same range. This is achieved by the
    mapping in the second input to `vfGrad`, which scales the parameters `y` and `z`
    by `3e-10`. Recall that the second input of the `vfGrad` function we wrote in
    [Chapter 22](ch22.xhtml) specifies the region of interest by mapping a square
    from (–1,–1) to (1,1) into the region we wish to visualize.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了yz平面中的一个正方形，其中*y*的范围从–3 × 10^(–10) m到3 × 10^(–10) m，而*z*的范围也是相同的。这是通过将`vfGrad`的第二个输入进行映射实现的，该映射将`y`和`z`的参数缩放为`3e-10`。请记住，我们在[第22章](ch22.xhtml)中编写的`vfGrad`函数的第二个输入，通过将从(–1,–1)到(1,1)的正方形映射到我们希望可视化的区域，来指定感兴趣的区域。
- en: Ideal Electric Dipole
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 理想电偶极子
- en: Equally but oppositely charged particles are an example of an electric dipole.
    An *ideal electric dipole* is a source of an electric field formed by letting
    the distance between these two particles approach zero while the charges increase
    in magnitude so that the electric dipole moment stays constant. Let’s look at
    the electric field produced by an ideal electric dipole.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 等量但相反电荷的粒子是电偶极子的一个例子。*理想电偶极子*是由两个粒子之间的距离趋近于零，而电荷的大小增大，使得电偶极矩保持不变，从而形成电场源。让我们来看一下理想电偶极子产生的电场。
- en: The electric field produced by an ideal electric dipole at the origin is
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由理想电偶极子在原点产生的电场是
- en: '![Image](Images/481equ01.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/481equ01.jpg)'
- en: 'where **p** is the electric dipole moment. Here it is in Haskell:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 其中**p**是电偶极矩。这里是用Haskell表示的：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The right side of [Figure 25-3](ch25.xhtml#ch25fig3) shows the electric field
    produced by an ideal electric dipole. The magnitude of the electric dipole moment
    **p** is not so important in this picture because the darkest arrows are those
    where the electric field is largest in magnitude, regardless of what that magnitude
    is. Equation 25.3 shows that the electric field increases linearly with the dipole
    moment, so the picture would be the same for any dipole moment in the z-direction.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[图25-3](ch25.xhtml#ch25fig3)的右侧显示了由理想电偶极子产生的电场。电偶极矩**p**的大小在这个图像中并不重要，因为最暗的箭头表示电场最强的地方，尽管电场的大小可能不同。方程25.3表明，电场随偶极矩线性增加，因此对于z方向上的任何电偶极矩，图像都是相同的。'
- en: Comparing the two pictures in [Figure 25-3](ch25.xhtml#ch25fig3), we see that
    the electric field differs in the centers of the pictures, close to the sources
    of the field. The fields around the edges of the pictures, farther from the sources,
    are very similar in the two pictures. It is the similarity of the fields a bit
    farther from the sources that entitles both sources to be called electric dipoles.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 比较[图25-3](ch25.xhtml#ch25fig3)中的两个图像，我们看到电场在图像中心处有所不同，接近电场源的位置。在图像边缘，远离电场源的区域，两个图像中的电场非常相似。电场在离源稍远的地方的相似性使得这两种源都可以被称为电偶极子。
- en: 'Here is the code to produce the picture on the right in [Figure 25-3](ch25.xhtml#ch25fig3):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是生成[图25-3](ch25.xhtml#ch25fig3)右侧图片的代码：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The only differences in this program compared to `eFieldPicSimpleDipole` for
    NaCl are the filenames and the electric fields. The electric field here is `eFieldIdealDipole
    kHat`, where we use the unit vector `kHat` for the electric dipole moment because
    its magnitude doesn’t change the picture.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与`eFieldPicSimpleDipole`相比，该程序在NaCl中的唯一区别是文件名和电场。这里的电场是`eFieldIdealDipole kHat`，我们使用单位向量`kHat`表示电偶极矩，因为它的大小不会改变图像。
- en: We’ve seen an example of the electric field produced by multiple point charges
    and compared it to that of an ideal electric dipole. Continuous charge distributions
    can be though of as a case of multiple charges, where there are many charges spread
    over some region. Before we turn to the question of finding the electric field
    produced by specific continuous charge distributions, there are a few general
    remarks we can make.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了由多个点电荷产生的电场示例，并将其与理想电偶极子的电场进行了比较。连续电荷分布可以看作是多个电荷的一个特例，其中有许多电荷分布在某个区域上。在我们转向如何计算特定连续电荷分布产生的电场之前，有一些一般性的说明可以做。
- en: Continuous Distributions
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 连续分布
- en: 'When we move from discrete point charges to a charge that is continuously distributed,
    we replace the sum in Equation 25.2 with an integral. A general way to write this
    integral is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从离散的点电荷转向连续分布的电荷时，我们将方程25.2中的和替换为积分。写这个积分的一般方法如下：
- en: '![Image](Images/482equ01.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/482equ01.jpg)'
- en: In Equation 25.4, we’ve replaced discrete quantities with continuous ones, as
    indicated in [Table 25-1](ch25.xhtml#ch25tab1), which shows the correspondence
    between discrete and continuous quantities.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在方程式25.4中，我们已经将离散量替换为连续量，正如[表25-1](ch25.xhtml#ch25tab1)所示，表中显示了离散量和连续量之间的对应关系。
- en: '**Table 25-1:** Correspondence Between Discrete and Continuous Quantities in
    the Electric Field Produced by Charge'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**表25-1：** 电场中离散和连续量的对应关系'
- en: '|  | **Discrete** | **Continuous** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|  | **离散** | **连续** |'
- en: '| --- | --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Aggregation method | ∑[*i*] | ∫ |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 聚合方法 | ∑[*i*] | ∫ |'
- en: '| Quantity of charge | *q[i]* | *dq*′ |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 电荷量 | *q[i]* | *dq*′ |'
- en: '| Location of charge | **r***[i]* | **r**′ |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 电荷位置 | **r**[*i*] | **r**′ |'
- en: The form of the integral in Equation 25.4 is so general that we have not even
    specified whether the charge is distributed along a 1D curve, across a 2D surface,
    or throughout a 3D volume. In any case, the integral is defined by a limiting
    process in which the quantities of charge *dq*′ become arbitrarily small and the
    number of charges becomes arbitrarily large.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式25.4中积分的形式是如此一般，以至于我们甚至没有明确规定电荷是分布在一维曲线、二维表面，还是三维体积中。无论如何，积分是通过一个极限过程来定义的，其中电荷量*dq*′变得无限小，电荷数目变得无限大。
- en: Sometimes we can evaluate such an integral exactly; however, more often, we
    need to compute an approximation to the integral. We do this computationally by
    turning the continuous integral back into a discrete sum, basically by turning
    Equation 25.4 back into Equation 25.2\. The details depend on whether we are integrating
    over a 1D curve, a 2D surface, or a 3D volume. We take up each of these cases
    in turn in the sections that follow.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可以精确计算这样的积分；然而，更多时候，我们需要计算积分的近似值。我们通过将连续积分转化为离散和来进行计算，基本上是通过将方程式25.4转回方程式25.2。具体细节取决于我们是在对1D曲线、2D表面还是3D体积进行积分。我们将在接下来的各节中依次讨论这些情况。
- en: Electric Field Created by a Line Charge
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 由线电荷产生的电场
- en: As we discussed in the previous chapter, a line charge is specified by a curve
    *C* and a scalar field *λ* representing the linear charge density at any point
    on the curve. When charge is spread along a one-dimensional curve, a little bit
    of charge *dq*′ at position **r**′ is given by the product of the linear charge
    density *λ*(**r**) and the length *dl*′ of a small section of the curve near **r**′.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章讨论的，线电荷由曲线*C*和标量场*λ*指定，*λ*表示曲线上任何点的线电荷密度。当电荷沿一维曲线分布时，在位置**r**′的小电荷*dq*′由线电荷密度*λ*(**r**)与曲线段的小长度*dl*′的乘积给出。
- en: '*dq*′ = *λ*(**r**′) *dl*′'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*dq*′ = *λ*(**r**′) *dl*′'
- en: 'We then write the integral of Equation 25.4 as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将方程式25.4的积分写作如下：
- en: '![Image](Images/483equ01.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/483equ01.jpg)'
- en: Such an integral of a vector field over a curve is called a *vector line integral*.
    Let’s explain the vector line integral in more detail.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对向量场在曲线上的积分称为*向量线积分*。让我们更详细地解释一下向量线积分。
- en: Vector Line Integral
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向量线积分
- en: The vector line integral takes a vector field and a curve as input and returns
    a vector as output.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 向量线积分将向量场和曲线作为输入，并返回一个向量作为输出。
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The vector line integral of a vector field **F** over a curve *C* is written
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 向量场**F**在曲线*C*上的向量线积分表示为
- en: '![Image](Images/484equ01.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/484equ01.jpg)'
- en: What does this integral mean? The integral is defined by dividing the curve
    *C* into many small segments. The vector field **F** is evaluated at each point
    **r**[*i*] on or near the segment Δ**l**[*i*] and scaled (multiplied) by the length
    Δ*l[i]* of the segment. We then add up these vectors to form the sum
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个积分是什么意思？积分的定义是通过将曲线*C*分成许多小段来实现的。向量场**F**在每个点**r**[*i*]（位于或接近段Δ**l**[*i*]）处进行评估，并且按段长度Δ*l[i]*进行缩放（乘以）。然后我们将这些向量相加形成和
- en: '![Image](Images/484equ02.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/484equ02.jpg)'
- en: The integral is the limit of this vector sum as the lengths of the segments
    approach 0 and the number of segments becomes arbitrarily large. The definition
    of the integral involves careful specification of the limiting process, which
    we’ll leave to textbooks on vector calculus.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个积分是当段长度趋近于0并且段数变得无限大的时候，这个向量和的极限。积分的定义涉及对极限过程的精确定义，这部分内容我们将留给向量微积分的教材。
- en: The integral is not only defined by, but also approximated by, a finite sum.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个积分不仅通过有限和定义，还通过有限和进行逼近。
- en: '![Image](Images/484equ03.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/484equ03.jpg)'
- en: Our approximate calculation of the integral will use a finite number of segments.
    We will need a method to approximate a curve by a finite list of segments. We’ll
    represent a segment Δ**l**[*i*] as a short displacement vector lying along the
    curve. In addition to the displacement vector Δ**l**[*i*], which describes the
    length and orientation of the segment, we also need a position **r**[*i*] indicating
    where the segment is located on the curve. An approximation to a curve consists
    of a list of pairs of positions and displacement vectors. Notice that the lengths
    of the segments need not be the same. A curve approximation method is a function
    that returns such a list when given a curve.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对积分的近似计算将使用有限数量的段。我们需要一种方法，通过有限的段列表来近似曲线。我们将把段Δ**l**[*i*]表示为沿曲线的短位移矢量。除了描述段长度和方向的位移矢量Δ**l**[*i*]，我们还需要一个位置**r**[*i*]来表示该段在曲线上的位置。曲线的近似是由位置和位移矢量的对组成的列表。注意，段的长度不必相同。曲线近似方法是一个函数，当给定一条曲线时，会返回这样的列表。
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A pair looks like (**r**[*i*], Δ**l**[*i*]). We could use many curve approximation
    methods; we’ll delay discussion of a curve approximation method to the final section
    of this chapter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一对看起来像是(**r**[*i*], Δ**l**[*i*])。我们可以使用许多曲线近似方法；我们将在本章最后一节讨论曲线近似方法。
- en: 'Here’s the Haskell definition of a vector line integral:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是矢量线积分的Haskell定义：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The curve `c` is approximated by the function `approx`, which is provided as
    an input. The function `approx` will specify the number of segments into which
    the curve is to be divided, as well as the method for the division and determination
    of the associated positions of the segments. For each segment `dl'` at position
    `r'`, the vector field `vF` is evaluated at position `r'` and scaled by the magnitude
    of `dl'`. We then sum these vectors to give the approximation to the integral.
    [Table 25-2](ch25.xhtml#ch25tab2) shows a correspondence between mathematical
    notation and Haskell notation in the definition of the vector line integral.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线`c`由输入函数`approx`进行近似，该函数会指定曲线划分的段数、划分方法以及各个段的相关位置。对于每个在位置`r'`的段`dl'`，矢量场`vF`将在位置`r'`进行评估，并按`dl'`的大小进行缩放。然后，我们将这些向量相加，从而得到积分的近似值。[表25-2](ch25.xhtml#ch25tab2)显示了数学符号、离散数学符号和Haskell符号在定义矢量线积分时的对应关系。
- en: '**Table 25-2:** Correspondence Among Continuous Mathematical Notation, Discrete
    Mathematical Notation, and Haskell Notation for the Vector Line Integral'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**表25-2：** 连续数学符号、离散数学符号和Haskell符号在矢量线积分中的对应关系'
- en: '| **Continuous math** | **Discrete math** | **Haskell** |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| **连续数学** | **离散数学** | **Haskell** |'
- en: '| --- | --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| ∫ | ∑[*i*] | `sumV` ➊ |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| ∫ | ∑[*i*] | `sumV` ➊ |'
- en: '| **r**′ | **r**[*i*] | `r''` ➋ |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **r**′ | **r**[*i*] | `r''` ➋ |'
- en: '| **F** | **F** | `vF` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **F** | **F** | `vF` |'
- en: '| **F**(**r**′) | **F**(**r**[*i*]) | `vF r''` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **F**(**r**′) | **F**(**r**[*i*]) | `vF r''` |'
- en: '| *C* |  | `c` ➌ |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| *C* |  | `c` ➌ |'
- en: '| *dl*′ | Δ**l**[*i*] | `dl''` ➍ |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| *dl*′ | Δ**l**[*i*] | `dl''` ➍ |'
- en: '| *dl*′ | Δ*l[i]* | `magnitude dl''` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| *dl*′ | Δ*l[i]* | `magnitude dl''` |'
- en: '| **F**(**r**′)*dl*′ | **F**(**r**[*i*])Δ*l[i]* | `vF r'' ^* magnitude dl''`
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **F**(**r**′)*dl*′ | **F**(**r**[*i*])Δ*l[i]* | `vF r'' ^* magnitude dl''`
    |'
- en: Surprisingly, Haskell notation is closer to discrete notation only in the summation
    ➊. The Haskell names we chose for segment location ➋, curve ➌, and segment displacement
    ➍ are closer to the continuous notation. This is because Haskell does not require
    the index *i* used in the discrete notation, so there is no reason to introduce
    it. Haskell computes the integral in a discrete way, but Haskell’s list syntax
    avoids the need to talk about the index *i* that would number the list elements.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 出人意料的是，Haskell符号在求和符号部分➊上与离散符号更为接近。我们为段位置➋、曲线➌和段位移➍选择的Haskell名称更接近于连续符号。这是因为Haskell不需要离散符号中使用的索引*i*，所以没有必要引入它。虽然Haskell以离散的方式计算积分，但Haskell的列表语法避免了谈论需要编号列表元素的索引*i*。
- en: Back to Electric Field
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 回到电场
- en: From Equation 25.5, we see that the vector field **F** we want to integrate
    to find the electric field produced by a line charge is the function that maps
    the position **r**′ of a piece of charge to the vector
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从方程25.5中，我们看到，想要积分以找到由线电荷产生的电场的矢量场**F**，是将电荷某部分的位置**r**′映射到矢量的函数。
- en: '![Image](Images/485equ01.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/485equ01.jpg)'
- en: in which **r** is the field point, the fixed position where we want to know
    the electric field. In the function `eFieldFromLineCharge` below, this function
    is given the local name `integrand`. The local name `d` stands for the displacement
    **r** – **r**′ from the source point **r**′ to the field point **r**. Because
    the source point `r'` is introduced as a name local to the `integrand` function,
    we must define `d` with a `where` clause, rather than alongside the definitions
    of `k` and `integrand`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，**r**是场点，即我们希望知道电场的固定位置。在下面的`eFieldFromLineCharge`函数中，这个函数被赋予了局部名称`integrand`。局部名称`d`表示从源点**r**′到场点**r**的位移**r**
    – **r**′。由于源点`r'`作为`integrand`函数的局部名称引入，因此我们必须通过`where`子句来定义`d`，而不是与`k`和`integrand`的定义一起给出。
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We need to give only two items to find the electric field produced by a line
    charge: the linear charge density, expressed as a scalar field, and the curve
    that describes the geometry of the line charge. The type signature of the function
    `eFieldFromLineCharge` makes it clear that the electric field depends only on
    these two items. We use the `vectorLineIntegral` we defined earlier. The curve
    approximation method `curveSample 1000` divides the curve into 1,000 segments
    and is defined later in the chapter.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到线电荷产生的电场，我们只需要提供两个信息：线电荷密度（作为标量场表示）和描述线电荷几何形状的曲线。函数`eFieldFromLineCharge`的类型签名明确表明，电场只依赖于这两个参数。我们使用之前定义的`vectorLineIntegral`。曲线近似方法`curveSample
    1000`将曲线分成1000段，并将在本章稍后定义。
- en: Now that we’ve shown how to find the electric field for a line charge, let’s
    look at the electric field produced by the line dipole `lineDipole` we discussed
    in the previous chapter.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经展示了如何找到线电荷的电场，接下来让我们看看前一章讨论的线偶极子`lineDipole`所产生的电场。
- en: Example of a Line Dipole
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 线偶极子的示例
- en: 'In the previous chapter, we introduced `lineDipole`, a line charge with a linearly
    varying charge density. Suppose we had reason to believe that the charge distribution
    of NaCl looked more like that of a line dipole than a simple dipole. I have no
    such evidence, and the charge distribution of NaCl is probably complicated, but
    it’s certainly reasonable to imagine that the charge density varies smoothly,
    if not linearly, from sodium to chlorine. To model NaCl as a line dipole, we can
    use the same electric dipole moment and interatomic separation we used earlier
    for the simple dipole. Here is a charge distribution for NaCl, viewed as a line
    dipole:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了`lineDipole`，它是一个具有线性变化电荷密度的线电荷。假设我们有理由相信，NaCl的电荷分布看起来更像是线偶极子而非简单的偶极子。我没有这样的证据，而且NaCl的电荷分布可能很复杂，但假设电荷密度从钠到氯是平滑变化的（即使不是线性变化），这一点是完全合理的。为了将NaCl建模为一个线偶极子，我们可以使用之前为简单偶极子计算的电偶极矩和原子间距。这里是NaCl作为线偶极子时的电荷分布：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can find the electric field of this charge distribution with the `eField`
    function, which in this case will use the `eFieldFromLineCharge` function we wrote
    earlier.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`eField`函数来找到这个电荷分布的电场，在这种情况下，它将使用我们之前写的`eFieldFromLineCharge`函数。
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Exercise 25.11 asks you to make a vector field picture for this electric field,
    similar to the ones we made earlier for the simple dipole and the ideal dipole.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 练习25.11要求你绘制出这个电场的矢量场图，就像我们之前为简单偶极子和理想偶极子所做的那样。
- en: Now that we’ve discussed how to find the electric field from our first continuous
    charge distribution, that of a line charge, and shown an example, let’s turn to
    our second continuous charge distribution, that of a surface charge.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了如何从第一个连续电荷分布（即线电荷）中找到电场，并展示了一个示例，那么我们接下来将讨论第二个连续电荷分布——表面电荷。
- en: Electric Field Created by a Surface Charge
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 表面电荷产生的电场
- en: As we discussed in the previous chapter, a surface charge is specified by a
    surface *S* and a scalar field *σ* representing the surface charge density at
    any point on the surface. When charge is spread along a 2D surface, a little bit
    of charge *dq*′ at position **r**′ is given by the product of the surface charge
    density *σ*(**r**′) and the area *da*′ of a small patch of the surface near **r**′.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章讨论的，表面电荷是由一个表面*S*和一个标量场*σ*指定的，后者表示表面上任何点的表面电荷密度。当电荷分布在二维表面上时，位置**r**′处的小电荷*dq*′由表面电荷密度*σ*(**r**′)和靠近**r**′的表面小区域*da*′的面积的乘积给出。
- en: '*dq*′ = σ(**r**′) *da*′'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*dq*′ = σ(**r**′) *da*′'
- en: 'We then write the integral of Equation 25.4 as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将方程25.4的积分写为如下：
- en: '![Image](Images/487equ01.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/487equ01.jpg)'
- en: Such an integral of a vector field over a surface is called a *vector surface
    integral*. Let’s explain the vector surface integral in more detail.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对曲面上向量场的积分称为*向量曲面积分*。让我们更详细地解释向量曲面积分。
- en: Vector Surface Integral
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向量曲面积分
- en: The vector surface integral takes a vector field and a surface as input and
    returns a vector as output.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 向量曲面积分接受一个向量场和一个曲面作为输入，返回一个向量作为输出。
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The vector surface integral of a vector field **F** over a surface *S* is written
    as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 向量场**F**在曲面*S*上的向量曲面积分写作：
- en: '![Image](Images/487equ02.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/487equ02.jpg)'
- en: We define the integral by dividing the surface *S* into many small patches.
    You can think of a patch as a quadrilateral, but what’s really important is the
    location, area, and orientation of the patch rather than its shape. Each patch
    Δ**a**[*i*] is a vector area whose magnitude gives the area of the patch and whose
    direction points perpendicular to the patch. We assume each patch is small enough
    to be considered flat. Because our surfaces are oriented, as we discussed in [Chapter
    23](ch23.xhtml), the direction for the patch is unambiguous. The vector field
    **F** is evaluated at a point **r**[*i*] on or near the patch Δ**a**[*i*] and
    scaled by the area *Δa[i]* of the patch. We then add up these vectors to form
    the sum
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将曲面*S*划分为许多小贴片来定义积分。你可以将贴片看作一个四边形，但真正重要的是贴片的位置、面积和方向，而不是其形状。每个贴片Δ**a**[*i*]都是一个向量面积，其大小给出贴片的面积，方向垂直于贴片。我们假设每个贴片足够小，可以视为平坦的。由于我们的曲面是有方向的，正如我们在[第23章](ch23.xhtml)中讨论的那样，贴片的方向是明确的。向量场**F**在贴片Δ**a**[*i*]附近的点**r**[*i*]上进行评估，并按贴片面积*Δa[i]*进行缩放。然后我们将这些向量相加，得到和
- en: '![Image](Images/487equ03.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/487equ03.jpg)'
- en: The integral is the limit of this vector sum as the areas of the patches approach
    0 and the number of patches becomes arbitrarily large.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 积分是这个向量和的极限，当贴片的面积趋近于 0 且贴片数量变得无限大时。
- en: The integral is not only defined by, but also approximated by, a finite sum.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 积分不仅通过有限和进行近似定义，还通过有限和来近似计算。
- en: '![Image](Images/487equ04.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/487equ04.jpg)'
- en: Our approximate calculation of the integral will use a finite number of patches.
    We will need a method to divide a surface into a list of patches. We’ll represent
    an oriented patch Δ**a**[*i*] as a vector perpendicular to the surface. In addition
    to the vector Δ**a**[*i*], which describes the area and orientation of the patch,
    we also need a position **r**[*i*] indicating where the patch is located on the
    surface. An approximation to a surface consists of a list of pairs of positions
    and area vectors.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对积分的近似计算将使用有限数量的贴片。我们需要一种方法将一个曲面划分成一系列贴片。我们将用一个垂直于曲面的向量来表示一个有向贴片Δ**a**[*i*]。除了描述贴片面积和方向的向量Δ**a**[*i*]，我们还需要一个位置**r**[*i*]，表示贴片在曲面上的位置。曲面的近似由一系列位置和面积向量的配对组成。
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A pair looks like (**r**[*i*], Δ**a**[*i*]). There are many ways the surface
    approximation could be done, and we’ll delay discussion of this point to the last
    section of this chapter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个配对看起来像是(**r**[*i*], Δ**a**[*i*])。曲面近似的方式有很多，我们将在本章最后一节讨论这一点。
- en: 'Here’s the Haskell definition of a vector surface integral:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是向量曲面积分的 Haskell 定义：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The surface `s` is approximated by the function `approx`, which is provided
    as an input. The function `approx` will specify the number of patches into which
    the surface is to be divided, as well as the method for the division and determination
    of the associated positions of the patches. For each patch `da'` at position `r'`,
    the vector field `vF` is evaluated at position `r'` and scaled by the magnitude
    of `da'`. We then sum these vectors to give the approximation to the integral.
    [Table 25-3](ch25.xhtml#ch25tab3) shows a correspondence between mathematical
    notation and Haskell notation in the definition of the vector surface integral.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 曲面`s`通过函数`approx`进行近似，`approx`作为输入提供。该函数将指定曲面被划分为多少个贴片，并且确定这些贴片的划分方法以及与之相关的位置。对于每个位置为`r'`的贴片`da'`，我们在位置`r'`评估向量场`vF`，并按`da'`的大小进行缩放。然后我们将这些向量相加，从而得到积分的近似值。[表
    25-3](ch25.xhtml#ch25tab3)展示了向量曲面积分的数学符号与 Haskell 符号之间的对应关系。
- en: '**Table 25-3:** Correspondence Among Continuous Mathematical Notation, Discrete
    Mathematical Notation, and Haskell Notation for the Vector Surface Integral'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 25-3：** 连续数学符号、离散数学符号和 Haskell 符号之间的对应关系，适用于向量曲面积分'
- en: '| **Continuous math** | **Discrete math** | **Haskell** |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| **连续数学** | **离散数学** | **Haskell** |'
- en: '| --- | --- | --- |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| ∫ | ∑[*i*] | `sumV` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| ∫ | ∑[*i*] | `sumV` |'
- en: '| **r**′ | **r**[*i*] | `r''` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| **r**′ | **r**[*i*] | `r''` |'
- en: '| **F** | **F** | `vF` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **F** | **F** | `vF` |'
- en: '| **F**(**r**′) | **F**(**r**[*i*]) | `vF r''` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| **F**(**r**′) | **F**(**r**[*i*]) | `vF r''` |'
- en: '| *S* |  | `s` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| *S* |  | `s` |'
- en: '| *d***a**′ | Δ**a**[*i*] | `da''` |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| *d***a**′ | Δ**a**[*i*] | `da''` |'
- en: '| *da*′ | Δ*a[i]* | `magnitude da''` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| *da*′ | Δ*a[i]* | `magnitude da''` |'
- en: '| **F**(**r**′)*da*′ | **F**(**r**[*i*])Δ*a[i]* | `vF r'' ^* magnitude da''`
    |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| **F**(**r**′)*da*′ | **F**(**r**[*i*])Δ*a[i]* | `vF r'' ^* magnitude da''`
    |'
- en: The first four rows of [Table 25-3](ch25.xhtml#ch25tab3) are identical to those
    of [Table 25-2](ch25.xhtml#ch25tab2) for the vector line integral because they
    refer to the vector field and the integration. The last four rows of this table
    are analogous to those of the previous table, with surface patches substituting
    for line segments.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格25-3](ch25.xhtml#ch25tab3)的前四行与[表格25-2](ch25.xhtml#ch25tab2)的前四行相同，因为它们都涉及向量场和积分。该表的最后四行与前一个表类似，只不过是用表面小块代替了线段。'
- en: Back to Electric Field
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 回到电场
- en: From Equation 25.7, we see that the vector field **F** we want to integrate
    to find the electric field produced by a line charge is the function that maps
    the position **r**′ of a piece of charge to the vector
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从方程25.7中，我们看到我们想要积分以找到由线电荷产生的电场的向量场**F**是一个将电荷片段的位置**r**′映射到向量的函数。
- en: '![Image](Images/488equ01.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/488equ01.jpg)'
- en: Here we consider **r** the fixed position where we want to know the electric
    field. In the function `eFieldFromSurfaceCharge` next, which is a Haskell translation
    of Equation 25.7, we give this function the local name `integrand`. The local
    name `d` stands for the displacement **r** – **r**′ from the charge to the field
    point. Because we introduce the source point `r'` as a name local to the `integrand`
    function, we must define `d` with a `where` clause rather than alongside the definitions
    of `k` and `integrand`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们考虑**r**是我们想要知道电场的固定位置。在接下来的`eFieldFromSurfaceCharge`函数中，这是方程25.7的Haskell翻译，我们给这个函数取了本地名称`integrand`。本地名称`d`表示从电荷到场点的位移**r**
    – **r**′。由于我们将源点`r'`作为`integrand`函数的局部名称引入，因此必须使用`where`子句来定义`d`，而不是与`k`和`integrand`的定义一起定义。
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We need to give only two items to find the electric field produced by a surface
    charge: the surface charge density *σ*, expressed as a scalar field, and the surface
    that describes the geometry of the surface charge. The type signature of `eFieldFromSurfaceCharge`
    makes it clear that the electric field depends only on these two items. We use
    the `vectorSurfaceIntegral` we defined earlier. The function `surfaceSample 200`
    divides the curve into 2(200)² = 80,000 patches and is defined later in the chapter.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到表面电荷产生的电场，我们只需要给出两个项目：表面电荷密度*σ*，它作为标量场表示，和描述表面电荷几何形状的表面。`eFieldFromSurfaceCharge`的类型签名清楚地表明，电场仅依赖于这两个项目。我们使用之前定义的`vectorSurfaceIntegral`。函数`surfaceSample
    200`将曲线分成2(200)² = 80,000个小块，并在本章后面定义。
- en: Now that we’ve shown how to find the electric field for a surface charge, let’s
    look at the electric field produced by the capacitor `diskCap` we discussed in
    the previous chapter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经展示了如何找到表面电荷产生的电场，让我们来看一下上一章讨论过的电容器`diskCap`产生的电场。
- en: Example of a Capacitor
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 电容器示例
- en: Let’s find the electric field produced by a parallel-plate capacitor whose plates
    are uniformly charged. The assumption of uniform charge is good when the plates
    are close together and worsens as the plates are moved farther apart. Suppose
    we have a capacitor with a plate separation of 4 cm in which the plates are disks
    with radius 5 cm. The positive plate has a surface charge density of 20 nC/m²,
    and the negative plate has a surface charge density of – 20 nC/m². The expression
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出由平行板电容器产生的电场，其中电容器的板均匀带电。当板距离较近时，均匀电荷的假设是合理的，但随着板间距离增大，这个假设会变得不太准确。假设我们有一个板间距为4厘米的电容器，其中的板是半径为5厘米的圆盘。正板的表面电荷密度为20
    nC/m²，负板的表面电荷密度为–20 nC/m²。表达式
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: represents this charge distribution.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 表示该电荷分布。
- en: We can find the electric field with the `eField` function.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`eField`函数来找到电场。
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this case, `eField` uses the function `eFieldFromSurfaceCharge` we defined
    earlier. To start, let’s look at the electric field at the center of the capacitor.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`eField`使用我们之前定义的`eFieldFromSurfaceCharge`函数。首先，让我们来看一下电容器中心的电场。
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The electric field is in the negative z-direction, pointing from the positive
    plate above toward the negative plate below.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 电场朝负z方向，指向上面的正极板，朝向下面的负极板。
- en: For comparison, a parallel-plate capacitor with infinitely wide plates and surface
    charge density *σ* has electric field *σ*/*ϵ*[0]. Physicists like the ideal parallel-plate
    capacitor with infinitely wide plates because there is a simple expression for
    the electric field it produces. The electric field outside the ideal capacitor
    is 0\. The electric field inside the ideal capacitor (between the two plates)
    has a uniform value of *σ*/*ϵ*[0] and points from the positive plate toward the
    negative plate. The electric field produced is independent of the plate separation.
    For a surface charge density of *σ* = 20 nC/m², the electric field magnitude would
    be
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较，一个具有无限宽板和平行板电容器，其表面电荷密度为*σ*，其电场为*σ*/*ϵ*[0]。物理学家喜欢理想的平行板电容器，因为它能简单地表达其产生的电场。理想电容器外部的电场为0。理想电容器内部（两个板之间）的电场值均匀，为*σ*/*ϵ*[0]，并且方向从正极板指向负极板。所产生的电场与板间距无关。对于表面电荷密度*σ*
    = 20 nC/m²，电场的大小将是
- en: '![Image](Images/490equ01.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/490equ01.jpg)'
- en: The value we found earlier is less than this ideal value (in magnitude) because
    the radii of our plates are rather modest.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前找到的值小于这个理想值（在量值上），因为我们的电容板半径相对较小。
- en: '[Figure 25-4](ch25.xhtml#ch25fig4) shows the electric field produced by our
    disk capacitor.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 25-4](ch25.xhtml#ch25fig4)显示了我们盘形电容器产生的电场。'
- en: '![Image](Images/490fig01.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/490fig01.jpg)'
- en: '*Figure 25-4: Electric field eFieldDiskCap produced by a parallel-plate capacitor.
    The plates have uniform surface charge density. (Image produced by eFieldPicDiskCap.)*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 25-4：由平行板电容器产生的电场 eFieldDiskCap。电容板具有均匀的表面电荷密度。（图像由 eFieldPicDiskCap 生成。）*'
- en: '[Figure 25-4](ch25.xhtml#ch25fig4) shows the region from –10 cm to 10 cm in
    the x-direction, and from –10 cm to 10 cm in the z-direction. The radii of the
    disks are 5 cm, so they extend horizontally over half the width of the figure.
    The electric field is largest in magnitude where the arrows are darkest, between
    the plates. The field is smaller outside the plates, but it’s not 0\. The electric
    field appears to be fairly uniform between the plates. We see from the shading
    how the electric field transitions from its maximum between the plates, to moderate
    values near the edges of the disks, to minimal values farther from the plates.
    Around the outside of the picture, the electric field looks like that of an electric
    dipole, which is not surprising since the capacitor is an electric dipole consisting
    of a positive plate and a negative plate.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 25-4](ch25.xhtml#ch25fig4)显示了x方向上从–10 cm到10 cm的区域，以及z方向上从–10 cm到10 cm的区域。盘形电容器的半径为5
    cm，因此它们水平延伸，覆盖了图中一半的宽度。电场的强度在箭头最黑的地方最大，即板之间。电场在板外部较小，但并非为0。电场在板之间看起来相当均匀。我们从阴影中可以看到电场如何从板间的最大值过渡到接近盘边缘的中等值，再到离板更远处的最小值。在图的外围，电场看起来像是电偶极子的电场，这并不奇怪，因为该电容器本身就是由正负两块电板组成的电偶极子。'
- en: 'Here’s the code that produced [Figure 25-4](ch25.xhtml#ch25fig4):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成[图 25-4](ch25.xhtml#ch25fig4)的代码：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The program might take several minutes to run. The surface and volume charge
    integrals involve many computations and can be slow. The methods used here are
    ones that are conceptually simple rather than numerically efficient. The slowness
    is mostly a consequence of the simple approach and is not inherent in the use
    of the Haskell language. There are data structures, such as unboxed vectors, that
    would speed up many of the operations here, at the expense of making the code
    less concise.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序可能需要几分钟才能运行。表面和体积电荷的积分涉及大量计算，可能会比较慢。这里使用的方法在概念上简单，但数值效率较低。慢速主要是由于简单方法的使用，而非Haskell语言本身的局限性。实际上，存在一些数据结构，如无包装向量，可以加速许多操作，但这会使代码变得不那么简洁。
- en: 'We’ve talked about line charges and surface charges. Let’s turn to the third
    and last of our continuous charge distributions: the volume charge.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过线电荷和表面电荷。现在让我们讨论第三种也是最后一种连续电荷分布：体积电荷。
- en: Electric Field Created by a Volume Charge
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 由体积电荷产生的电场
- en: As we discussed in the previous chapter, a volume charge is specified by a volume
    *V* and a scalar field *ρ* representing the volume charge density at any point
    in the volume. When charge is spread throughout a 3D volume, a little bit of charge
    *dq*′ at position **r**′ is given by the product of the volume charge density
    *ρ*(**r**′) and the volume *dv*′ of a small portion of the volume near **r**′.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中讨论的那样，体积电荷由一个体积 *V* 和一个标量场 *ρ* 指定，该标量场表示体积中任意一点的体积电荷密度。当电荷分布在三维体积中时，位置
    **r**′ 处的一个小电荷 *dq*′ 由体积电荷密度 *ρ*(**r**′) 与靠近 **r**′ 的小部分体积 *dv*′ 的乘积给出。
- en: '*dq*′ = *ρ*(**r**′) *dv*′'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*dq*′ = *ρ*(**r**′) *dv*′'
- en: 'We then write the integral of Equation 25.4 as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将方程 25.4 的积分写成如下形式：
- en: '![Image](Images/491equ01.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/491equ01.jpg)'
- en: Such an integral of a vector field over a volume is called a *vector volume
    integral*. Let’s explore the vector volume integral in more detail.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的向量场在体积上的积分被称为 *向量体积积分*。让我们更详细地探讨向量体积积分。
- en: Vector Volume Integral
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向量体积积分
- en: The vector volume integral takes a vector field and a volume as input and returns
    a vector as output.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 向量体积积分以向量场和体积为输入，并返回一个向量作为输出。
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The vector volume integral of a vector field **F** over a volume *V* is written
    as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 向量场 **F** 在体积 *V* 上的向量体积积分表示如下：
- en: '![Image](Images/492equ01.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/492equ01.jpg)'
- en: The integral is defined by dividing the volume *V* into many small portions.
    The vector field **F** is evaluated at each point **r**[*i*] on or near the portion
    and scaled by the volume Δ*v[i]* of the portion. We then add up these vectors
    to form the sum
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 积分是通过将体积 *V* 分割成许多小部分来定义的。向量场 **F** 在每个点 **r**[*i*]（在该部分上或附近）被评估，并按该部分的体积 Δ*v[i]*
    进行缩放。然后我们将这些向量加起来，得到总和
- en: '![Image](Images/492equ02.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/492equ02.jpg)'
- en: The integral is the limit of this vector sum as the volumes of the portions
    approach 0 and the number of portions becomes arbitrarily large.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个积分是当体积部分趋近于 0 且部分数目变得无限大时，这个向量和的极限。
- en: 'The integral is both defined by and approximated by a finite sum:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 积分既通过有限和来定义，也通过有限和来近似：
- en: '![Image](Images/492equ03.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/492equ03.jpg)'
- en: Our approximate calculation of the integral will use a finite number of portions.
    We’ll represent a portion by its location **r**[*i*] and its volume Δ*v[i]*. An
    approximation to a volume consists of a list of pairs of positions and portion
    volumes. A volume approximation method is a function that returns such a list
    when given a volume.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的积分近似计算将使用有限数量的部分。我们将通过其位置 **r**[*i*] 和体积 Δ*v[i]* 来表示一个部分。体积的近似由一组位置和部分体积的对构成。体积近似方法是一个函数，当给定体积时，它返回这样的列表。
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A pair looks like (**r**[*i*], Δ*v[i]*). Many volume approximation methods could
    be used, and, as before, we’ll delay discussion of this point until later in the
    chapter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一对看起来像 (**r**[*i*], Δ*v[i]*)。可以使用许多体积近似方法，正如之前所说的，我们将把这个问题的讨论推迟到本章稍后。
- en: 'Here’s the Haskell definition of a vector volume integral:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个向量体积积分的 Haskell 定义：
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The volume `vol` is approximated by the function `approx`, giving a list of
    portion locations and volumes. For each portion `(r',dv')`, the vector field `vF`
    is evaluated at position `r'` and scaled by `dv'`. We then sum these vectors to
    give the approximation to the integral.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 体积 `vol` 通过函数 `approx` 近似，给出一组部分位置和体积的列表。对于每个部分 `(r', dv')`，向量场 `vF` 在位置 `r'`
    处进行评估，并按 `dv'` 进行缩放。然后我们将这些向量加起来，得到积分的近似值。
- en: '[Table 25-4](ch25.xhtml#ch25tab4) shows a correspondence between mathematical
    notation and Haskell notation in the definition of the vector volume integral.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 25-4](ch25.xhtml#ch25tab4) 显示了向量体积积分中数学符号和 Haskell 符号之间的对应关系。'
- en: '**Table 25-4:** Correspondence Among Continuous Mathematical Notation, Discrete
    Mathematical Notation, and Haskell Notation for the Vector Volume Integral'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 25-4：** 连续数学符号、离散数学符号和 Haskell 符号在向量体积积分中的对应关系'
- en: '| **Continuous math** | **Discrete math** | **Haskell** |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| **连续数学** | **离散数学** | **Haskell** |'
- en: '| --- | --- | --- |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *V* |  | `vol` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| *V* |  | `vol` |'
- en: '| *dv*′ | Δ*v[i]* | `dv''` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| *dv*′ | Δ*v[i]* | `dv''` |'
- en: '| **F**(**r**′)*dv*′ | **F**(**r**[*i*])Δ*v[i]* | `vF r'' ^* dv''` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| **F**(**r**′)*dv*′ | **F**(**r**[*i*])Δ*v[i]* | `vF r'' ^* dv''` |'
- en: This table is analogous to the last few rows of [Table 25-3](ch25.xhtml#ch25tab3).
    One important difference between the two is that each patch for a surface integral
    is a vector, while each bit of volume for a volume integral is a scalar.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格类似于[表25-3](ch25.xhtml#ch25tab3)的最后几行。两者之间的一个重要区别是，表面积分的每个小块是一个向量，而体积积分的每一小部分则是标量。
- en: Back to Electric Field
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 回到电场
- en: 'We need to give only two items to find the electric field produced by a volume
    charge: the volume charge density *ρ*, expressed as a scalar field, and the volume
    that describes the geometry of the charge. The type signature of the following
    function, which is a Haskell translation of Equation 25.8, makes it clear that
    the electric field depends only on these two items:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要给出两个参数来求解由体积电荷产生的电场：体积电荷密度*ρ*，它表示为标量场，以及描述电荷几何形状的体积。以下函数的类型签名，这是方程式25.8的Haskell翻译，清楚地表明电场仅依赖于这两个参数：
- en: '[PRE31]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that we have functions to calculate the electric field produced by a line
    charge, a surface charge, and a volume charge, we have completed the definition
    of `eField` we began earlier in the chapter. We now have a method to find the
    electric field produced by any charge distribution. In writing functions to calculate
    the electric field, we spent some time discussing three types of vector integrals:
    the vector line integral for line charges, the vector surface integral for surface
    charges, and the vector volume integral for volume charges. With these integrals
    fresh in our minds, now is a good time to extend our integral methods to scalar
    integrals, which we used in the last chapter to calculate total charge.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了计算由线电荷、面电荷和体电荷产生的电场的函数，我们已经完成了本章开始时定义的`eField`。我们现在有了一种方法来求解由任何电荷分布产生的电场。在编写计算电场的函数时，我们花了一些时间讨论了三种类型的矢量积分：线电荷的矢量线积分、面电荷的矢量曲面积分和体电荷的矢量体积积分。通过将这些积分牢记在心，现在是时候将我们的积分方法扩展到标量积分了，这些积分在上一章中用于计算总电荷。
- en: Scalar Integrals
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标量积分
- en: In the process of calculating the electric field produced by a line charge,
    a surface charge, or a volume charge, we introduced the vector line integral,
    the vector surface integral, and the vector volume integral. We used these integrals
    to add up the vector contributions to the electric field from each piece of charge.
    There are situations in which we need to add up scalar contributions to some quantity
    that come from sources on a curve, a surface, or a volume. This is the purpose
    of the scalar line integral, scalar surface integral, and scalar volume integral.
    Now that we have gone through the details for the vector integrals, it will be
    relatively easy to understand the scalar integrals.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算由线电荷、面电荷或体电荷产生的电场的过程中，我们引入了矢量线积分、矢量曲面积分和矢量体积积分。我们使用这些积分来将每一部分电荷对电场的矢量贡献加起来。有些情况下，我们需要将来自曲线、表面或体积的源的标量贡献加起来。这就是标量线积分、标量曲面积分和标量体积积分的目的。既然我们已经完成了矢量积分的细节，现在理解标量积分就相对容易了。
- en: Scalar Line Integral
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标量线积分
- en: The scalar line integral takes a scalar field *f* and a curve *C* as input and
    returns a scalar as output.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 标量线积分接受一个标量场*f*和一条曲线*C*作为输入，并返回一个标量作为输出。
- en: '[PRE32]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The integral is defined, and also approximated, by dividing the curve *C* into
    many small segments, exactly as we did for the vector line integral. The scalar
    field *f* is evaluated at each point **r**[*i*] at the segment Δ**l**[*i*], multiplied
    by the length Δ*l[i]* of the segment, and then added.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 积分的定义以及近似方法是通过将曲线*C*划分为许多小段，正如我们在计算矢量线积分时所做的那样。标量场*f*在每个点**r**[*i*]处被计算，并在段Δ**l**[*i*]的长度Δ*l[i]*上乘以，之后将其相加。
- en: '![Image](Images/494equ01.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/494equ01.jpg)'
- en: 'Here is the Haskell definition of a scalar line integral:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这是标量线积分的Haskell定义：
- en: '[PRE33]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The curve `c` is approximated by the function `approx`, which is provided as
    an input. For each segment `dl'` at position `r'`, the scalar field `f` is evaluated
    at position `r'` and multiplied by the magnitude of `dl'`. We then sum these numbers
    to give the approximation to the integral.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线`c`通过输入的函数`approx`进行近似。对于每个在位置`r'`的段`dl'`，在位置`r'`处计算标量场`f`，并与`dl'`的大小相乘。然后，我们将这些数值相加，以得到积分的近似值。
- en: Scalar Surface Integral
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标量曲面积分
- en: The scalar surface integral takes a scalar field *f* and a surface *S* as input
    and returns a scalar as output.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 标量曲面积分接受一个标量场*f*和一个曲面*S*作为输入，并返回一个标量作为输出。
- en: '[PRE34]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The integral is defined, and also approximated, by dividing the surface *S*
    into many small patches, exactly as we did for the vector surface integral. The
    scalar field *f* is evaluated at each point **r**[*i*] at the patch Δ**a**[*i*],
    multiplied by the magnitude *Δa[i]* of the patch, and then added.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 积分是通过将曲面*S*分成许多小块来定义并进行近似的，正如我们在进行矢量曲面积分时所做的那样。在每个小块Δ**a**[*i*]的点**r**[*i*]处，评估标量场*f*，然后与小块的大小*Δa[i]*相乘，再将结果相加。
- en: '![Image](Images/495equ01.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/495equ01.jpg)'
- en: 'Here is the Haskell definition of a scalar surface integral:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是标量曲面积分的Haskell定义：
- en: '[PRE35]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The surface `s` is approximated by the function `approx`. For each patch `da'`
    at position `r'`, the scalar field `f` is evaluated at position `r'` and multiplied
    by the magnitude of `da'`. We then sum these numbers to give the approximation
    to the integral.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 曲面`s`通过函数`approx`进行近似。对于位置`r'`处的每个小块`da'`，在位置`r'`评估标量场`f`并与`da'`的大小相乘。然后我们将这些数值相加，从而得到积分的近似值。
- en: Scalar Volume Integral
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标量体积积分
- en: The scalar volume integral takes a scalar field *f* and a volume *V* as input
    and returns a scalar as output.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 标量体积积分接受一个标量场*f*和一个体积*V*作为输入，并返回一个标量作为输出。
- en: '[PRE36]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The integral is defined, and also approximated, by dividing the volume *V* into
    many small portions, exactly as we did for the vector volume integral. The scalar
    field *f* is evaluated at each portion, multiplied by the volume Δ[v*i*] of the
    portion, and then added.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 积分是通过将体积*V*分成许多小部分来定义并进行近似的，正如我们在进行矢量体积积分时所做的那样。在每个部分中，标量场*f*在该部分处进行评估，并与该部分的体积Δ[v*i*]相乘，再将结果相加。
- en: '![Image](Images/495equ02.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/495equ02.jpg)'
- en: 'Here is the Haskell definition of a scalar volume integral:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是标量体积积分的Haskell定义：
- en: '[PRE37]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The volume `vol` is approximated by the function `approx`. For each portion
    `dv'` at position `r'`, the scalar field `f` is evaluated at position `r'` and
    multiplied by `dv'`. We then sum numbers to give the approximation to the integral.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 体积`vol`通过函数`approx`进行近似。对于位置`r'`处的每一部分`dv'`，在位置`r'`评估标量场`f`并与`dv'`相乘。然后我们将这些数值相加，从而得到积分的近似值。
- en: Before we leave this chapter, there is one detail left to discuss, and that’s
    the method we’ll use to approximate curves, surfaces, and volumes when we do integrals
    over these shapes. Let’s turn to that detail now.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开本章之前，还有一个细节需要讨论，那就是当我们对这些形状进行积分时，用来近似曲线、曲面和体积的方法。现在让我们讨论这个细节。
- en: Approximating Curves, Surfaces, and Volumes
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 近似曲线、曲面和体积
- en: We’ve seen multiple situations in which we want to add things up over a curve,
    surface, or volume by doing a line integral, surface integral, or volume integral.
    When the things we want to add up are vectors, we use a vector line integral,
    vector surface integral, or vector volume integral. Similarly, when the things
    we want to add up are scalars, we use a scalar line integral, scalar surface integral,
    or scalar volume integral. Whether we are adding scalars or vectors, our methods
    require us to approximate curves, surfaces, and volumes as finite lists of data.
    This approximation is the subject of this section; although there are many ways
    this approximation can be done, we’ll give only one method for approximating each
    geometrical object. The subject of numerical analysis is concerned with exploring
    different ways to make these approximations, examining the trade-offs involved,
    and doing it cleverly and efficiently. In our case, we’re concerned with doing
    it simply and understandably.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经见过多种情况，我们希望通过线积分、曲面积分或体积积分对曲线、曲面或体积上的内容进行求和。当我们要求和的是矢量时，我们使用矢量线积分、矢量曲面积分或矢量体积积分。类似地，当我们要求和的是标量时，我们使用标量线积分、标量曲面积分或标量体积积分。无论是加标量还是加矢量，我们的方法都要求我们将曲线、曲面和体积近似为有限的数据列表。这个近似是本节的主题；尽管有多种方法可以进行近似，但我们将为每个几何对象提供一种近似方法。数值分析的研究内容是探索不同的近似方法，研究其中的权衡，并以巧妙和高效的方式进行处理。在我们的情况中，我们关注的是简单且易于理解的做法。
- en: Approximating a Curve
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 近似曲线
- en: Recall that a curve approximation is a way of turning a curve into a list of
    locations and displacement vectors.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，曲线近似是将曲线转化为位置和位移向量列表的一种方式。
- en: '[PRE38]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Our function `curveSample` approximates a curve as a number of segments, returning
    a list of segment positions and displacement vectors.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数`curveSample`通过多个段来逼近一条曲线，返回一个段的位置和位移向量的列表。
- en: '[PRE39]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The function takes an integer `n` that controls the number of segments generated,
    each segment being a pair of starting position and ending position.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个整数`n`，用于控制生成的段数，每个段由起始位置和结束位置组成。
- en: '[PRE40]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Most of the work is done by the function `segments`, defined next, which returns
    a list of segments when given the integer `n` and the curve `c`. The local function
    `segCent` finds the center of each segment. The `rVF` vector field, introduced
    in [Chapter 22](ch22.xhtml), converts positions to displacement vectors, which
    the `shiftPosition` function then averages and converts back to positions.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分工作由接下来的`segments`函数完成，当给定整数`n`和曲线`c`时，它返回一个段的列表。局部函数`segCent`找到每个段的中心。`rVF`向量场，在[第22章](ch22.xhtml)中介绍，将位置转换为位移向量，接着`shiftPosition`函数对位移向量进行平均并转换回位置。
- en: The local function `segDisp` then computes the displacement vector of each segment.
    The displacement vector points from the beginning position of a segment to the
    ending position of the segment. The function `segDisp` is the uncurried version
    of `displacement` from [Chapter 22](ch22.xhtml), taking the two positions as a
    pair rather than a curried function.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 局部函数`segDisp`计算每个段的位移向量。位移向量从段的起始位置指向段的结束位置。函数`segDisp`是[第22章](ch22.xhtml)中`displacement`的非柯里化版本，接受一对位置而非柯里化函数。
- en: We defined `segCent` and `segDisp` locally because they’re not used in any other
    functions. Note that we can still give them type signatures if we wish, although
    this is not required. Special-purpose functions like these are nice to define
    locally because it keeps fewer items in the global namespace and helps the reader
    of the code understand the relationship between the local function `segCent` and
    its parent function `curveSample`. The fact that `segCent` is local informs the
    reader that this function is not used elsewhere.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在局部定义了`segCent`和`segDisp`，因为它们在其他函数中并没有被使用。需要注意的是，我们仍然可以为它们提供类型签名，尽管这不是必须的。像这样的特定用途函数最好局部定义，因为这样可以减少全局命名空间中的内容，并帮助代码阅读者理解局部函数`segCent`与其父函数`curveSample`之间的关系。`segCent`是局部的这一事实提醒读者该函数不会在其他地方使用。
- en: The function `segments` returns a list of segments when given a curve.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`segments`在给定曲线时返回一个段的列表。
- en: '[PRE41]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note the first argument to `segments` is an integer `n` that controls how many
    segments will be produced. We pass in the curve `Curve g a b` using pattern matching
    on the input because this function needs to refer to the curve’s parameter limits
    `a` and `b`, as well as to the parameterizing function `g`. The function begins
    by breaking the curve’s parameter interval from `a` to `b` into `n` equal subintervals
    using the function `linSpaced` defined below. At each of the `n+1` endpoints of
    these subintervals, we apply the function `g` to form a list `ps` of `n+1` positions
    along the curve. We then zip the list `ps` with its tail to produce the desired
    list of `n` segments. Zipping a list with its tail pairs the first and second
    items, the second and third items, the third and fourth items, and so on.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`segments`的第一个参数是整数`n`，控制生成多少个段。我们使用模式匹配将曲线`Curve g a b`作为输入传入，因为这个函数需要引用曲线的参数限制`a`和`b`，以及参数化函数`g`。该函数首先使用下面定义的`linSpaced`函数将曲线的参数区间`a`到`b`分成`n`个相等的小区间。在这些小区间的`n+1`个端点上，我们应用函数`g`，形成一个包含`n+1`个位置的列表`ps`。然后，我们将列表`ps`与其尾部配对，生成所需的`n`个段。将列表与其尾部配对会将第一个和第二个项、第二个和第三个项、第三个和第四个项，依此类推，配对起来。
- en: The function `linSpaced` returns a list of numbers that are linearly spaced.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`linSpaced`返回一个线性间隔的数字列表。
- en: '[PRE42]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The input `n` is the number of intervals, so the function returns a list of
    `n+1` numbers, starting at `x0` and going up to and including `x1`. Since n has
    type `Int` and x1 - x0 has type `R`, we need the fromIntegral function to convert
    n to type `R` before we do the division. We use the `take` function to treat the
    case in which the initial value `x0` and the final value `x1` are the same, in
    which case `dx` is 0 and the arithmetic sequence is an infinite list of the same
    number. The `take` function returns only the first `n+1` items of the infinite
    list.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的`n`是间隔的数量，因此该函数返回一个包含`n+1`个数字的列表，起始值为`x0`，直到包括`x1`。由于`n`的类型是`Int`，而`x1 -
    x0`的类型是`R`，我们需要使用`fromIntegral`函数将`n`转换为`R`类型，然后才能进行除法操作。我们使用`take`函数处理初始值`x0`和最终值`x1`相同的情况，在这种情况下，`dx`为0，算术序列是一个包含相同数字的无限列表。`take`函数只返回该无限列表的前`n+1`个元素。
- en: 'Here are two examples of the use of `linSpaced`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个`linSpaced`的使用示例：
- en: '[PRE43]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now that we’ve explored one way to approximate a curve, let’s do the same for
    a surface.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了近似曲线的一种方式，接下来让我们做同样的事情来近似表面。
- en: Approximating a Surface
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 近似一个表面
- en: Recall that a surface approximation is a way of turning a surface into a list
    of locations and vector areas.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，表面近似是将一个表面转换为位置和向量面积的列表。
- en: '[PRE44]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Our function `surfaceSample` approximates a surface as a number of triangles,
    returning a list of triangle positions and vector areas.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数`surfaceSample`将一个表面近似为多个三角形，返回一个包含三角形位置和向量面积的列表。
- en: '[PRE45]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The function takes an integer `n` that controls the number of triangles generated.
    Most of the work is done by the function `triangles`, which returns a list of
    triangles when given the integer `n` and the surface `s`. The function `triCenter`
    finds the center of each triangle, and the function `triArea` computes the vector
    area of each triangle. These two functions are defined below.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个整数`n`，控制生成的三角形数量。大部分工作由函数`triangles`完成，当给定整数`n`和表面`s`时，它返回一个三角形列表。函数`triCenter`找到每个三角形的中心，函数`triArea`计算每个三角形的向量面积。以下是这两个函数的定义。
- en: A triangle is described by specifying the positions of its three vertices.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形通过指定其三个顶点的位置来描述。
- en: '[PRE46]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The triangles have an orientation, so the order in which we specify the vertices
    is important. If we are looking at a triangle from a place where the positions
    `p1`, `p2`, and `p3` of the vertices occur in a counterclockwise order, the orientation
    points from the triangle toward our viewing location, perpendicular to the triangle
    surface. The triangles `Tri p1 p2 p3`, `Tri p2 p3 p1`, and `Tri p3 p1 p2` all
    represent the same triangle with the same orientation, but the triangles `Tri
    p1 p3 p2`, `Tri p2 p1 p3`, and `Tri p3 p2 p1` represent triangles with the same
    vertices but an opposite orientation.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形有一个方向，因此我们指定顶点的顺序非常重要。如果我们从一个地方观察三角形，其中顶点`p1`、`p2`和`p3`按逆时针顺序排列，则方向从三角形指向我们的观察位置，垂直于三角形表面。`Tri
    p1 p2 p3`、`Tri p2 p3 p1`和`Tri p3 p1 p2`都表示具有相同方向的同一个三角形，但`Tri p1 p3 p2`、`Tri p2
    p1 p3`和`Tri p3 p2 p1`表示具有相同顶点但方向相反的三角形。
- en: We find the center of a triangle by averaging the displacement vectors for the
    three vertices.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过对三个顶点的位移向量进行平均来找到三角形的中心。
- en: '[PRE47]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We convert positions to displacement vectors with the `rVF` vector field, introduced
    in [Chapter 22](ch22.xhtml). We then average them and convert them back to a position
    with the `shiftPosition` function.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`rVF`向量场将位置转换为位移向量，这在[第22章](ch22.xhtml)中介绍。然后我们对它们求平均，并使用`shiftPosition`函数将其转换回位置。
- en: The vector area of a triangle is half the cross product of two of its vector
    edges. Since we care about the orientation of these triangles, we need to be careful
    about which way we do the cross product.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形的向量面积是两个向量边的叉积的一半。由于我们关心这些三角形的方向，因此我们需要小心进行叉积的操作顺序。
- en: '[PRE48]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The function `triangles` returns a list of triangles when given a surface.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`triangles`在给定一个表面时返回一个三角形列表。
- en: '[PRE49]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note the first argument to `triangles` is an integer `n` that controls how many
    triangles will be produced. We pass in the surface `Surface g sl su tl tu` using
    pattern matching on the input because this function needs to refer to the surface’s
    parameter limits `sl` and `su`, as well as all of the other attributes of the
    surface.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`triangles`的第一个参数是整数`n`，它控制将生成多少个三角形。我们通过对输入进行模式匹配，传递表面`Surface g sl su tl
    tu`，因为该函数需要引用表面的参数限制`sl`和`su`，以及表面的所有其他属性。
- en: 'The function begins by breaking the surface’s parameter interval from `sl`
    to `su` into `n` equal subintervals. At each of the `n+1` endpoints of these sub-intervals,
    we break the parameter interval from `tl s` to `tu s` into `n` equal subintervals,
    where `s` is the *s* parameter value at each subinterval endpoint. The local variable
    `sts :: [[(R,R)]]` is a list of lists, which can be thought of as an `n+1`-by-`n+1`
    matrix of parameter pairs corresponding to points on the surface. The local variable
    `stSquares :: [((R,R),(R,R),(R,R),(R,R))]` is a list of `n^2` “squares” of parameter
    pairs. Each of these squares is turned into two triangles by the local function
    `twoTriangles`. The function `triangles` returns a list of `2*n^2` triangles approximating
    the surface.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '该函数首先将曲面的参数区间从`sl`到`su`划分为`n`个相等的子区间。在这些`n+1`个子区间的每个端点，我们将参数区间从`tl s`到`tu s`划分为`n`个相等的子区间，其中`s`是每个子区间端点的*参数值*。局部变量`sts
    :: [[(R,R)]]`是一个列表的列表，可以看作是一个`n+1`×`n+1`的矩阵，包含与曲面上的点对应的参数对。局部变量`stSquares :: [((R,R),(R,R),(R,R),(R,R))]`是一个包含`n^2`个“平方”的列表，每个平方由参数对组成。这些平方通过局部函数`twoTriangles`转化为两个三角形。函数`triangles`返回一个包含`2*n^2`个三角形的列表，用于近似曲面。'
- en: Now that we’ve shown one way to approximate a surface, let’s turn to the question
    of approximating a volume.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们展示了一种近似曲面的方式，让我们转向近似体积的问题。
- en: Approximating a Volume
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 近似体积
- en: A volume approximation is a way of turning a volume into a list of locations
    and numerical volumes.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 体积近似是一种将体积转化为位置列表和数值体积的方法。
- en: '[PRE50]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Our function `volumeSample` approximates a volume by a number of tetrahedrons.
    A tetrahedron is a four-sided solid where each side is a triangle. The function
    returns a list of tetrahedron positions and numerical volumes.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数`volumeSample`通过多个四面体来近似一个体积。四面体是一个四面体固体，其中每一面都是一个三角形。该函数返回一个四面体位置和数值体积的列表。
- en: '[PRE51]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The function takes an integer `n` that controls the number of tetrahedrons used.
    Most of the work is done by the function `tetrahedrons`, defined below, which
    returns a list of tetrahedrons when given the integer `n` and the volume `v`.
    The function `tetCenter` finds the center of each tetrahedron, and the function
    `tetVolume` computes the numerical volume of each tetrahedron. These two functions
    are also defined below.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个整数`n`，它控制所使用的四面体数量。大部分工作由下面定义的函数`tetrahedrons`完成，该函数在给定整数`n`和体积`v`时返回四面体列表。函数`tetCenter`找到每个四面体的中心，函数`tetVolume`计算每个四面体的数值体积。这两个函数也在下面定义。
- en: We can describe a tetrahedron by specifying the positions of its four vertices.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定四个顶点的位置来描述一个四面体。
- en: '[PRE52]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We can find the center of a tetrahedron by averaging displacement vectors for
    the four vertices.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过对四个顶点的位移向量求平均来找到一个四面体的中心。
- en: '[PRE53]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This function is the natural extension of the `triCenter` function for triangles
    to tetrahedrons.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数是`triCenter`函数从三角形到四面体的自然扩展。
- en: The volume of a tetrahedron is 1/6 of the *scalar triple product*, defined as
    **a** ⋅ (**b** × **c**), of three vector edges originating at one vertex or terminating
    at one vertex. The scalar triple product is also the determinant of the matrix
    whose columns are the three vector edges.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 四面体的体积是*标量三重积*的1/6，定义为**a** ⋅ (**b** × **c**)，其中三个向量边从一个顶点出发或终止于一个顶点。标量三重积也是一个矩阵的行列式，该矩阵的列是这三个向量边。
- en: '[PRE54]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We use the `abs` function to guarantee a positive numerical volume.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`abs`函数来保证数值体积为正。
- en: Just as we used “parameter squares” to cover the parameter space of a surface,
    now we use “parameter cubes” to cover the parameter space of a volume. Let’s define
    a data type for parameter cube.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们使用“参数平方”来覆盖曲面的参数空间一样，现在我们使用“参数立方体”来覆盖体积的参数空间。让我们为参数立方体定义一个数据类型。
- en: '[PRE55]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The function `tetrahedrons` returns a list of tetrahedrons when given a volume.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`tetrahedrons`在给定体积时返回一个四面体列表。
- en: '[PRE56]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note the first argument to `tetrahedrons` is an integer `n` that controls how
    many tetrahedrons will be produced. We use pattern matching on the input to pass
    in the volume `Volume g sl su tl tu ul uu` because this function needs to refer
    to the volume’s parameter limits `sl` and `su` as well as all of the other attributes
    of the volume.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`tetrahedrons`的第一个参数是一个整数`n`，它控制将产生多少个四面体。我们使用模式匹配对输入进行处理，传递体积`Volume g
    sl su tl tu ul uu`，因为此函数需要引用体积的参数限制`sl`和`su`，以及体积的其他所有属性。
- en: 'The function begins by breaking the volume’s parameter interval from `sl` to
    `su` into `n` equal subintervals. At each of the `n+1` endpoints of these sub-intervals,
    we break the parameter interval from `tl s` to `tu s` into `n` equal subintervals,
    where `s` is the *s* parameter value at each subinterval endpoint. Finally, for
    the third dimension, we break each parameter interval from `ul s t` to `uu s t`
    into `n` equal subintervals, where `t` is the *t* parameter value at each sub-interval
    endpoint. The local variable `stus :: [[[(R,R,R)]]]` is a list of lists of lists,
    which can be thought of as an `n+1`-by-`n+1`-by-`n+1` array of parameter triples
    corresponding to points in the volume. The local variable `stCubes ::` `[ParamCube]`
    is a list of `n^3` parameter cubes. The local function `tets` turns each of these
    cubes into five tetrahedrons. The function `tetrahedrons` returns a list of `5*n^3`
    tetrahedrons approximating the volume.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '该函数通过将体积的参数区间从 `sl` 到 `su` 分成 `n` 个相等的小区间开始。在这些小区间的 `n+1` 个端点处，我们将参数区间从 `tl
    s` 到 `tu s` 分成 `n` 个相等的小区间，其中 `s` 是每个子区间端点的 *s* 参数值。最后，对于第三维度，我们将每个参数区间从 `ul s
    t` 到 `uu s t` 分成 `n` 个相等的小区间，其中 `t` 是每个子区间端点的 *t* 参数值。局部变量 `stus :: [[[(R,R,R)]]]`
    是一个列表的列表的列表，可以看作是一个 `n+1` x `n+1` x `n+1` 的参数三元组数组，对应于体积中的点。局部变量 `stCubes ::`
    `[ParamCube]` 是一个包含 `n^3` 个参数立方体的列表。局部函数 `tets` 将每个立方体转换为五个四面体。函数 `tetrahedrons`
    返回一个包含 `5*n^3` 个四面体的列表，用于近似该体积。'
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter showed how to calculate the electric field produced by a charge
    distribution. We wrote functions to find the electric field produced by a point
    charge, a line charge, a surface charge, and a volume charge. On the way to that
    goal, we introduced the vector line integral, the vector surface integral, and
    the vector volume integral. We wrote a function
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何计算由电荷分布产生的电场。我们编写了函数来计算点电荷、线电荷、面电荷和体电荷产生的电场。在实现这一目标的过程中，我们引入了矢量线积分、矢量面积分和矢量体积分。我们编写了一个函数
- en: '[PRE57]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: that calculates the electric field of any charge distribution by combining the
    functions we wrote for each charge distribution.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通过结合我们为每种电荷分布编写的函数，计算任何电荷分布的电场。
- en: After introducing the three sorts of vector integrals (line, surface, and volume),
    we took the opportunity to define three sorts of scalar integrals, in which we
    were adding up numbers rather than vectors. The chapter ended with a section on
    approximation of curves, surfaces, and volumes. Performing numerical integrals
    over these geometric objects requires that we have some way to carve the object
    up into a finite number of pieces. We showed one way to do this for each object.
    The next chapter on current distributions parallels the previous chapter on charge
    distributions. Just as charge is the source of electric fields, current is the
    source of magnetic fields.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入三种矢量积分（线积分、面积分和体积分）后，我们借此机会定义了三种标量积分，其中我们加总的是数值而不是矢量。本章以曲线、曲面和体积的逼近方法为结尾。对这些几何体进行数值积分需要我们有方法将物体划分为有限数量的部分。我们展示了每种物体的一个划分方法。下一章将讨论电流分布，它与本章的电荷分布类似。就像电荷是电场的源头一样，电流是磁场的源头。
- en: Exercises
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 习题
- en: '**Exercise 25.1.** Consider a line segment of charge, with uniform linear charge
    density *λ*[0]. Let us place this line segment on the x-axis from *x* = *–L*/2
    to *x* = *L*/2\. We want to find the electric field produced by this line segment
    at some point in the xy-plane. Write code to make a picture of the electric field
    produced by this line segment of charge. You may restrict your attention to the
    xy-plane. The electric field produced by a line segment of charge is an exactly
    solvable problem. Find or calculate the exact solution. Produce a picture of the
    exact electric field for comparison.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 25.1.** 考虑一段均匀线性电荷密度为 *λ*[0] 的线电荷段。我们将这段线电荷置于 x 轴上，从 *x* = *–L*/2 到 *x*
    = *L*/2。我们想要找出该线电荷段在 xy 平面某点产生的电场。编写代码绘制该线电荷段产生的电场图像。你可以将注意力集中在 xy 平面内。由一段线电荷产生的电场是一个完全可解的问题。找出或计算出精确解，并绘制精确电场图像以作比较。'
- en: '**Exercise 25.2.** Make a picture of the electric field produced by a uniformly
    charged disk. Put the disk in the xy-plane and show the electric field in the
    xz-plane.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 25.2.** 画出由均匀带电盘产生的电场图像。将盘放置在 xy 平面，并在 xz 平面中展示电场。'
- en: '**Exercise 25.3.** Make a graph of the magnitude of the electric field produced
    by a uniformly charged ball versus the distance from the ball’s center. Compare
    our numeric method to the exact solution.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 25.3.** 绘制由均匀带电球体产生的电场强度与距离球体中心的关系图。将我们的数值方法与精确解进行比较。'
- en: '**Exercise 25.4.** Consider a ring of charge in the xy-plane with radius *R*
    and linear charge density *λ*(**r**) = *λ*[0] cos *ϕ*, where *ϕ* is the cylindrical
    coordinate and *R* and *λ*[0] are constants you can choose. Create a 3D visualization
    of the electric field produced by this charge distribution.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 25.4.** 考虑一个位于xy平面的带电环，半径为*R*，线电荷密度*λ*(**r**) = *λ*[0] cos *ϕ*，其中*ϕ*是圆柱坐标，*R*和*λ*[0]是可以选择的常数。创建一个3D可视化图像，展示由该电荷分布产生的电场。'
- en: '**Exercise 25.5.** An exercise in the previous chapter asked you to write a
    charge distribution for the hydrogen atom in its ground state. Find the electric
    field produced by the hydrogen atom at an arbitrary point in space. Make a graph
    of the magnitude of the electric field as a function of the distance from the
    proton.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 25.5.** 在上一章中，有一道练习要求你为氢原子的基态写出电荷分布。找到氢原子在空间中任意一点产生的电场。绘制电场强度随质子距离变化的图像。'
- en: '**Exercise 25.6.** Produce an image of the electric field created by four equal
    positive point charges located at the corners of a square.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 25.6.** 画出由位于正方形四个角的四个相等的正点电荷产生的电场图像。'
- en: '**Exercise 25.7.** Produce an image of the electric field in the xz-plane created
    by a square plate with uniform positive surface charge density in the xy-plane.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 25.7.** 绘制由位于xy平面的均匀正表面电荷密度的方形板产生的电场在xz平面上的图像。'
- en: '**Exercise 25.8.** Produce images of the electric field in the xy-plane and
    the yz-plane created by a uniformly charged circular ring in the xy-plane centered
    on the origin.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 25.8.** 绘制由位于原点的xy平面内均匀带电圆环产生的xy平面和yz平面上的电场图像。'
- en: '**Exercise 25.9.** If the functions `scalarLineIntegral` and `vectorLineIntegral`
    seem like they are basically doing the same thing, and that we ought to be able
    to exploit some sort of commonality to combine them into one function that can
    do both, you are right.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 25.9.** 如果`scalarLineIntegral`和`vectorLineIntegral`这两个函数看起来基本上在做相同的事情，且我们应该能够利用某种共性将它们合并成一个既能做标量线积分又能做向量线积分的函数，那么你是对的。'
- en: First, we define a general field that could be a scalar field, a vector field,
    or something else.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个通用场，它可以是标量场、向量场或其他类型。
- en: '[PRE58]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The type `ScalarField` is the same as `Field R` and the type `VectorField` is
    the same as `Field Vec`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`ScalarField`与`Field R`相同，类型`VectorField`与`Field Vec`相同。
- en: Next, we make a type class for abstract vectors, which are types that have a
    zero vector, can be added, and can be scaled by a real number.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为抽象向量创建一个类型类，这些类型具有零向量，能够进行加法运算，并且可以由实数进行缩放。
- en: '[PRE59]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We write a function `sumG` to add a list of abstract vectors. This function
    is modeled after the `sumV` function from [Chapter 10](ch10.xhtml).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写一个函数`sumG`，用于求和一个抽象向量列表。该函数是借鉴自[第10章](ch10.xhtml)中的`sumV`函数。
- en: '[PRE60]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: With these tools, we can write a general line integral function that performs
    the role of both the scalar line integral and the vector line integral.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些工具，我们可以写出一个通用的线积分函数，它既可以作为标量线积分，也可以作为向量线积分。
- en: '[PRE61]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Write instance declarations that will make the types `R` and `Vec` instances
    of type class `AbstractVector`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 编写实例声明，使得类型`R`和`Vec`成为类型类`AbstractVector`的实例。
- en: '**Exercise 25.10.** *Gauss’s law* asserts that the *electric flux* through
    a closed surface is proportional to the charge enclosed by the surface. The *flux*
    of a vector field describes the total flow through a surface if we imagine that
    the vectors are the velocity of some fluid. The electric flux Φ*[E]* through a
    surface *S* is defined to be the dotted surface integral of the electric field.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 25.10.** *高斯定律*断言，*电通量*通过一个封闭表面的值与该表面所包围的电荷成正比。一个向量场的*通量*描述了如果我们将向量视为某种流体的速度，那么通过一个表面的总流量。电通量Φ*[E]*通过一个表面*S*的定义是电场的表面点积积分。'
- en: '![Image](Images/504equ01.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/504equ01.jpg)'
- en: 'The definition for the dotted surface integral is a lot like that for the vector
    surface integral we defined in this chapter. The integral is defined by dividing
    the surface *S* into many small patches. Each patch Δ**a**[*i*] is a vector whose
    magnitude gives the area of the patch and whose direction points perpendicular
    to the patch. The electric field **E** is evaluated at a point **r**[*i*] on or
    near the patch Δ**a**[*i*] and dotted with the vector area Δ**a**[*i*] of the
    patch. We then add up these numbers to form the sum:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 点表面积积分的定义与我们在本章定义的向量表面积积分非常相似。该积分通过将表面 *S* 划分为许多小块来定义。每个小块 Δ**a**[*i*] 是一个向量，其大小表示该小块的面积，方向指向垂直于小块的方向。电场
    **E** 在点 **r**[*i*] 上被评估，位于或接近小块 Δ**a**[*i*]，并与小块的向量面积 Δ**a**[*i*] 点积。然后，我们将这些数值加起来，形成总和：
- en: '![Image](Images/504equ02.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/504equ02.jpg)'
- en: The integral is the limit of this vector sum as the areas of the patches approach
    0 and the number of patches becomes arbitrarily large.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 积分是通过将小块的面积趋近于 0，且小块的数量变得无限大的过程，得到的该向量和的极限。
- en: 'Here is Haskell code for the dotted surface integral, also known as a *flux
    integral*:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这是点表面积积分的 Haskell 代码，也称为 *通量积分*：
- en: '[PRE62]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: (a) Write a function
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 编写一个函数
- en: '[PRE63]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: that accepts an electric field and a surface as input and returns electric flux
    as output.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 接受电场和表面作为输入，并返回电通量作为输出的函数。
- en: (b) Write a function
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 编写一个函数
- en: '[PRE64]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: that returns the electric flux through a given surface produced by the electric
    field of a given charge distribution.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 返回由给定电荷分布的电场产生的通过给定表面的电通量的函数。
- en: '**Exercise 25.11.** Compare the electric field `eFieldLineDipole` produced
    by NaCl, viewed as a line dipole, to the electric fields of the simple dipole
    and the ideal dipole. Make a vector field picture similar to those we made for
    the simple dipole and the ideal dipole.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 25.11.** 比较 NaCl 产生的电场 `eFieldLineDipole`，将其视为线偶极子，与简单偶极子和理想偶极子的电场。制作一个类似于我们为简单偶极子和理想偶极子所做的矢量场图。'
- en: '**Exercise 25.12.** The point charge is the fundamental source of electric
    field. Given a surface approximation, we can find the electric field of a surface
    charge by viewing it as a collection of point charges. The surface approximation
    tells us where to place the point charges and what values they should have. In
    this way, we skip over the vector surface integral that was our primary method
    for calculating the field.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 25.12.** 点电荷是电场的基本源。给定一个表面近似，我们可以通过将其视为一组点电荷来找到表面电荷的电场。表面近似告诉我们在哪里放置点电荷，以及它们应该具有的值。通过这种方式，我们跳过了本来是我们计算电场的主要方法——向量表面积积分。'
- en: '[PRE65]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Write similar functions to calculate the electric field from a line charge and
    a volume charge.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 编写类似的函数来计算由线电荷和体电荷产生的电场。
- en: '**Exercise 25.13.** Write a function'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 25.13.** 编写一个函数'
- en: '[PRE66]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: that uses `scalarSurfaceIntegral` to calculate the surface area of a surface.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `scalarSurfaceIntegral` 计算表面的表面积的函数。
- en: '**Exercise 25.14.** The electric potential is a scalar field that can be defined
    in terms of the electric field as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 25.14.** 电势是一个标量场，可以通过以下方式根据电场定义：'
- en: '![Image](Images/505equ01.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/505equ01.jpg)'
- en: The integral is a dotted line integral over any curve *C* that begins at the
    origin and ends at the field point **r**. The conservative nature of the electrostatic
    field **E** guarantees the result is independent of the chosen curve *C*.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 积分是对任意曲线 *C* 进行的点线积分，该曲线从原点开始，终点为场点 **r**。电静场 **E** 的保守性保证了结果与所选曲线 *C* 无关。
- en: The dotted line integral is defined and approximated by dividing the curve *C*
    into many small segments, exactly as we did for the vector line integral.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 点线积分通过将曲线 *C* 分割为许多小段来定义和逼近，正如我们为向量线积分所做的那样。
- en: '![Image](Images/505equ02.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/505equ02.jpg)'
- en: The vector field **F** is evaluated at each point **r**[*i*] of the approximation,
    dotted with the displacement Δ**l**[*i*] of the segment, and then added.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在逼近的每个点 **r**[*i*] 处评估矢量场 **F**，与段的位移 Δ**l**[*i*] 点积，然后加总。
- en: 'Here is the Haskell definition of the dotted line integral:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这是点线积分的 Haskell 定义：
- en: '[PRE67]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Write a function
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数
- en: '[PRE68]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: that takes the electric field as input and returns the electric potential as
    output. To write this function, you will need to construct a curve that begins
    at the origin and ends at the field point where we wish to find the electric potential.
    This curve can then be passed to `dottedLineIntegral`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 它将电场作为输入，并返回电势作为输出。为了编写这个函数，你需要构造一条从原点开始并以我们希望找到电势的场点结束的曲线。然后，可以将这条曲线传递给`dottedLineIntegral`。
