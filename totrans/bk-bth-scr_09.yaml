- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 8 EXECUTING COMPILED PROGRAMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter is ostensibly about a bat file executing or calling a program written
    and compiled in another language. In truth, the syntax to do that is pretty straightforward.
    The most interesting facet of this chapter is that sometimes the program being
    executed doesn’t have a defined path in the bat file. How does the bat file find
    the executable?
  prefs: []
  type: TYPE_NORMAL
- en: The main focus of this chapter will be on two highly important mechanisms for
    finding such a program, the *current directory* and the path variable. This topic
    goes well past the executing of programs. You’ll use it when calling other bat
    files, and it impacts many other instances when a resource isn’t defined with
    a path. For instance, in [Chapter 7](chapter7.xhtml), I discussed many commands
    for copying, moving, deleting, and renaming files. All of those commands will
    work perfectly well in your bat files when the file or files in each command aren’t
    defined with a path in the bat file, but only if you understand these concepts.
    And of course, you’ll also learn different ways to invoke programs and pass them
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Calling an Executable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often a bat file is little more than a vehicle or a wrapper for calling a compiled
    program, also known as an *executable*. The bat file will simply set some variables
    needed by the program, call the executable, and perform some error handling on
    the backend. More sophisticated bat files might call dozens of different programs,
    maybe even employing conditional logic on some calls. Simple or complex, a feature
    of Batch is the ability to call executables written in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The call command accepts the executable as its first, and possibly only, argument.
    The following command calls or executes the program *MyProg .exe* located in the
    *C:\Executables\* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The call command calls a program; that should surprise no one, but it’s about
    to get weird. This is the only command in Batch, and possibly all other languages,
    that works perfectly well when the command name itself is omitted. The following
    command, while not technically a call command, performs the same function as the
    call command in the prior example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Think about this for a moment. The command set x=1 sets a variable, but the
    statement x=1 will do nothing more than confuse the interpreter. If the text robocopy
    is left off the beginning of a robocopy command, no one in their right mind would
    expect the remaining text to copy a file. (If this isn’t weird enough, the presence
    or lack of the call command gets a little weirder when calling other bat files
    in [Chapter 10](chapter10.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: It almost seems like magic, but consider it from the interpreter’s perspective.
    When it interprets a new line, it usually expects the first item to be a command.
    When it finds set, it then anticipates a variable, an equal sign, and a value;
    when it finds robocopy, it next looks for a different set of arguments. When it
    finds something completely unexpected, the interpreter doesn’t balk; it gives
    you, the coder, the benefit of the doubt, assumes that whatever it is can be executed,
    and executes it—just as the call command would.
  prefs: []
  type: TYPE_NORMAL
- en: Some Batch coders use the call command for executables; some do not. I’m in
    the latter camp, preferring the clean look of the executable alone or just a resolved
    variable on a single line of code, but I’ve no qualms with those who explicitly
    spell out the command. More important, consistency is key; stick with your convention
    of choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'I also prefer to keep the program name in a variable with a fully qualified
    path, setting it only when it isn’t already defined. This ensures that the desired
    program is stored in the variable by default, while also allowing others to set
    it to an alternate program for the sake of flexibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then when it comes time to execute the program, this simple command, if I can
    call it a command, will *call* the desired program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This variable contains the path of the executable, but let’s return to the concept
    of a line of code consisting of nothing more than a hardcoded path and filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can shorten it by removing the path, leaving just the name of the program
    and maybe the extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This looks even simpler, but when you stop to ponder where on the machine or
    even on a network the interpreter is to find the program, the complexity grows.
    Before delving into those details, I’ll need a digression about two commands/variables.
  prefs: []
  type: TYPE_NORMAL
- en: The cd Command and Variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The cd command is also a variable, a special variable that’s one of a few Batch
    pseudo-environment variables. In [Chapter 21](chapter21.xhtml), I’ll have much
    more to say about these variables. For now, just consider them to be variables
    originally set by the interpreter that have some unique features.
  prefs: []
  type: TYPE_NORMAL
- en: The variable stands for *current directory*. The command is a bit more ambiguous,
    as it can also mean *change directory* because it’s used to ... well, change the
    current directory.
  prefs: []
  type: TYPE_NORMAL
- en: When you double-click or open a bat file, the current directory is the directory
    or folder where the bat file resides. If the same bat file is called from a different
    process, the current directory is inherited from that process. Simply calling
    a bat file or executable in a different directory doesn’t change the current directory,
    but the cd command does.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first and last lines shown next use the cd variable to display the current
    directory. The meat of this sandwich is the cd command that adeptly changes the
    current directory to its argument, assuming the directory exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If a bat file with these three lines resides in *C:\Batch\*, executing it displays
    both the original current directory and the newly assigned current directory to
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also set the current directory relative to the existing current directory.
    A single dot represents its existing value, so this assigns the cd variable to
    a subdirectory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Two dots represent the existing current directory’s parent, so the following
    moves the current directory up one level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: (The ..\.. argument finds the grandparent directory.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even reassign the cd variable to a sibling directory by first going
    up one level with the two dots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: I’m hesitant to even mention this, but chdir is a Batch synonym for the cd command.
    That is, the command in the prior example is functionally equivalent to chdir
    ..\Sibling\. However, the cd variable has no synonym, so you can use either chdir
    or cd to change the current directory, but you need to use cd when resolving the
    current directory. I find it easiest to always use cd for both purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Before I get into the purpose of the current directory, I need to introduce
    another command that’s also a variable.
  prefs: []
  type: TYPE_NORMAL
- en: The path Command and Variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Much like cd, path also is both a command and a pseudo-environment variable.
    The variable is predefined on Windows machines with a semicolon-delimited list
    of directories needed by the computer, such as paths for Java and Windows executables.
    (To see the path variable currently set on any Windows machine, open a command
    prompt, and using what we learned in [Chapter 2](chapter2.xhtml) enter the command
    set path.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as the cd command sets the current directory, the path command sets the
    path variable. In the following line of code, the existing value is being prepended
    and appended with two other directories; notice the semicolons inserted at the
    end of each additional directory as a delimiter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can completely reassign the path variable—or even wipe it out entirely if
    the argument is solely a semicolon. The various directories in this variable exist
    for a purpose, probably allowing for some necessary processes to run. Be extremely
    cautious about changing the variable persistently on your machine, such as with
    the setx command, but the path command shown previously changes only the path
    for the execution of the bat file. At worst you might break your bat file, but
    you won’t break anything else on your computer. In the next section, I’ll explain
    why you might want to change the path variable.
  prefs: []
  type: TYPE_NORMAL
- en: WARNING
  prefs: []
  type: TYPE_NORMAL
- en: '*The set command offers an alternative means of resetting both the cd and path
    variables, but out of consistency, I resist this method because some other pseudo-
    environment variables can’t or shouldn’t be reset with this command—and it requires
    a few more keystrokes.*'
  prefs: []
  type: TYPE_NORMAL
- en: Finding an Executable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s get back to executing a program simply by invoking nothing but its name
    and extension like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Where does the interpreter find the executable? The first place it looks is
    in the current directory. If found there, that’s the file executed. Otherwise,
    the interpreter will look for it sequentially in each directory defined in the
    path variable and execute the first one it finds. If it can’t find an executable
    with this name in any of those directories, the interpreter does nothing more
    than set errorlevel to the value of 9009. (Oddly, the bad return code is 1 if
    the call command precedes the name of the executable.)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s execute the same line of code, assuming that *myProg.exe* lives in *C:\Executables\*.
    If this directory is the current directory, the program will be found and executed.
    Otherwise, if this directory is in the path variable, the program will likely
    be found and executed. This assumes that the program isn’t superseded with a different
    program of the same name and extension residing in the current directory or higher
    in the path variable hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'If none of this is true, the program won’t be found, but there are different
    methods to make sure that the interpreter finds the executable. First, we can
    use the cd command to change the current directory prior to executing the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can alter the path variable to contain the directory in one
    of two ways. Here I’m prepending the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And here I’m appending the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If the directory is appended and if another file named *myProg.exe* exists in
    a directory defined earlier in the path variable, that other program will be the
    one executed. Prepending the directory ensures that my executable is picked up
    before any other, but this isn’t without its own dangers. It might be introducing
    something into the path variable that’ll override a resource used by some other
    process.
  prefs: []
  type: TYPE_NORMAL
- en: This is in no way a bad technique; in fact, it’s quite useful when managed wisely.
    One great use of finding an executable using the current directory or path variable
    is to make the code portable. You can keep a bat file in a single folder or a
    more complex folder structure with other bat files, as well as any number of executables,
    configuration files, and other resources. You then can copy that folder to other
    machines and networks with different root directory structures. Since the current
    directory essentially follows the high-level bat file around, it’ll work in those
    various locations if the current directory is used to find its other components.
  prefs: []
  type: TYPE_NORMAL
- en: You can house a default executable in the same folder as your bat file. If run
    on its own, it’ll use this executable. If called from another bat file with a
    different current directory, it may find a different program, allowing others
    to use your bat file to invoke their own executable. In short, you can create
    a hierarchy of same-named programs with different ones executed in different instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take this one step further, I hinted earlier that the extension isn’t even
    required to invoke a program. That is, if *myProg.exe* resides in the current
    directory, it’ll *probably* be invoked with this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The interpreter finds an executable given no extension with the aid of another
    pseudo-environment variable, pathext, which contains a hierarchy of semicolon-delimited
    extensions in much the same way that the path variable contains a hierarchy of
    directories. The interpreter still looks for the executable in the current directory,
    followed by the directories in the path variable, but in each folder, it now looks
    for the first executable it can find with the *myProg* filename and an extension
    listed in the given hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: If the pathext variable hasn’t been altered by someone or something else, it
    will likely contain about a dozen file extensions, starting with.*com*, *.exe*,
    *.bat*, and *.cmd*—in that order. Thus, the only entity that would prevent the
    previous command from executing *myProg.exe* from the current directory would
    be *myProg.com* in the current directory. (If you ever have to reset this variable,
    use the set command. The pathext variable is only a variable, not a command.)
  prefs: []
  type: TYPE_NORMAL
- en: Pushing and Popping the Current Directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The cd command does quite a nice job of changing the current directory, but
    the prior current directory is lost into the ether, never to be known again. Often
    that’s perfectly fine, but in other instances, you may want to change the current
    directory temporarily before reverting it to its prior state. Perhaps a utility
    bat file is written to be callable from many other bat files. In short order,
    I’ll discuss exactly how to call one bat file from another, but for now, we only
    need to understand the perspective of the called bat file.
  prefs: []
  type: TYPE_NORMAL
- en: The called bat file may create or use resources in a certain folder, so changing
    the current directory at the bat file’s onset makes sense. However, when the called
    bat file completes and turns control back to the calling bat file, the prior current
    directory should be restored. It’s simple courtesy because the calling bat file
    may be working in a different directory and changing its current directory might
    very well cause it problems. A more self-serving motivation is that the called
    bat file wants to keep its directory to itself. If the called bat file doesn’t
    restore the current directory, the calling bat file might drop unwanted files
    in what’s now the current directory. The called bat file can hide its directory
    from the unwashed masses while also presenting itself as being courteous.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this issue, you could store the prior current directory in a variable
    just before the cd command is executed, and then you could execute another cd
    command at the end of the bat file to set it back. But Batch provides two commands
    that together will do this far more elegantly, namely, the pushd and popd commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pushd command changes the current directory just like the cd command, but
    it also *pushes* the prior current directory onto a stack to be used later. It’s
    sometimes referred to as the *push directory* command, although for the sake of
    brevity it’s usually pronounced as it’s written, that is, the “push-d” command.
    Near the beginning of the bat file this command will succinctly perform both tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'At or near the close of the bat file, the following short command will remove
    *C:\NewDir\* as the current directory and retrieve or *pop* the prior current
    directory off the stack, using it to restore the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is sometimes called the *pop directory* command, but more commonly, the
    “pop-d” command.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there’s no argument; popd is the rare command that accepts no arguments
    at all, ever. As multiple pushd commands execute, each one pushes another prior
    current directory onto the stack, and each subsequent popd command will restore
    the one most recently added.
  prefs: []
  type: TYPE_NORMAL
- en: Also of note, if the argument passed to the pushd command is a network path,
    the highest unused drive letter is assigned to that path, and the popd command
    will unassign it. Lastly, the pushd command with no argument displays the full
    list of directories on the stack starting with the most recently added.
  prefs: []
  type: TYPE_NORMAL
- en: WARNING
  prefs: []
  type: TYPE_NORMAL
- en: '*It’s very important that pushd and popd commands be balanced. If a pushd assigns
    a network path, a corresponding popd should always execute, even if an error is
    handled. If not, any mapped drive letters will remain mapped, even after the bat
    file finishes up. If that happens often enough, the computer will run out of usable
    drive letters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Finding Other Resources with the Current Directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The current directory is used for far more than finding programs to execute.
    For any resource, such as a file, if the path isn’t defined, the current directory
    is assumed to be its path. For instance, in [Chapter 7](chapter7.xhtml), this
    command deleted an explicit file and everything ending in a particular extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command performs the same task with far fewer keystrokes *if*—the
    *if* being a critical qualifier—the current directory is *C:\Source\*, which is
    the path twice removed from the prior command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The same is true for the source argument of an xcopy command and any other command
    that accepts a path and filename as an argument. I usually prefer to use explicit
    paths to avoid any ambiguity, but this technique grants the same type of flexibility
    described throughout this chapter for a great number of commands. Flip through
    [Chapter 7](chapter7.xhtml) again, imagining all of the commands for copying,
    moving, and renaming files without explicit paths. They’d all be good commands
    if the interpreter finds the particular file or files in whatever happened to
    be the current directory at that time.
  prefs: []
  type: TYPE_NORMAL
- en: Passing Arguments to an Executable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the beginning of this chapter, I demonstrated how to call a compiled program.
    Before moving on, I have one last observation to share about this syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executables often accept one to many parameters at execution time. Those parameters
    are passed to the program as arguments by simply listing them after the program.
    For readability, I’ve put the three arguments into variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The input file is the first argument passed to the program; in many languages,
    that would be considered args[0] inside the program. Likewise, the output file
    is the second argument, args[1], and the log is the third, args[2]. You can also
    use hardcoded values, and the arguments can be anything you like; they don’t have
    to be files.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Executing a compiled program appears pretty basic at first. After all, you don’t
    even need a command. But you can’t truly understand how it works without knowing
    the details about the current directory and the path variable that I’ve detailed
    here. You’ve learned how the interpreter uses them to find executables, files,
    and any other resources, along with multiple means of managing the content of
    these important variables.
  prefs: []
  type: TYPE_NORMAL
- en: Executing another bat file is similar to but not the same as executing a compiled
    program, and you’ll learn about those differences in [Chapter 10](chapter10.xhtml).
    But before I delve into that, you’ll learn about labels and their many important
    uses in the very next chapter, primarily their impact on when commands are executed
    and how often.
  prefs: []
  type: TYPE_NORMAL
