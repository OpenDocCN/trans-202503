- en: '**4**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4**'
- en: '**ADVANCED APPLICATION TRAFFIC CAPTURE**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级应用流量捕获**'
- en: Usually, the network traffic-capturing techniques you learned in [Chapter 2](../Text/ch02.xhtml#ch02)
    should suffice, but occasionally you’ll encounter tricky situations that require
    more advanced ways to capture network traffic. Sometimes, the challenge is an
    embedded platform that can only be configured with the Dynamic Host Configuration
    Protocol (DHCP); other times, there may be a network that offers you little control
    unless you’re directly connected to it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你在[第 2 章](../Text/ch02.xhtml#ch02)中学到的网络流量捕获技术应该足够用了，但有时你会遇到需要更高级方法来捕获网络流量的复杂情况。有时，挑战来自于只能通过动态主机配置协议（DHCP）配置的嵌入式平台；有时，可能是一个网络，除非你直接连接到它，否则你几乎无法控制它。
- en: Most of the advanced traffic-capturing techniques discussed in this chapter
    use existing network infrastructure and protocols to redirect traffic. None of
    the techniques require specialty hardware; all you’ll need are software packages
    commonly found on various operating systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的大多数高级流量捕获技术都使用现有的网络基础设施和协议来重定向流量。这些技术不需要专用硬件；你只需要一些常见的操作系统软件包。
- en: '**Rerouting Traffic**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**重定向流量**'
- en: IP is a *routed* protocol; that is, none of the nodes on the network need to
    know the exact location of any other nodes. Instead, when one node wants to send
    traffic to another node that it isn’t directly connected to, it sends the traffic
    to a *gateway* node, which forwards the traffic to the destination. A gateway
    is also commonly called a *router*, a device that routes traffic from one location
    to another.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: IP 是一种*路由*协议；也就是说，网络上的节点不需要知道其他任何节点的确切位置。相反，当一个节点想要将流量发送到它没有直接连接的另一个节点时，它会将流量发送到一个*网关*节点，网关节点将流量转发到目的地。网关通常也被称为*路由器*，它是一种将流量从一个位置路由到另一个位置的设备。
- en: For example, in [Figure 4-1](../Text/ch04.xhtml#ch4fig1), the client 192.168.56.10
    is trying to send traffic to the server 10.1.1.10, but the client doesn’t have
    a direct connection to the server. It first sends traffic destined for the server
    to Router A. In turn, Router A sends the traffic to Router B, which has a direct
    connection to the target server; Router B passes the traffic on to its final destination.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[图 4-1](../Text/ch04.xhtml#ch4fig1)中，客户端 192.168.56.10 正试图将流量发送到服务器 10.1.1.10，但客户端与服务器没有直接连接。它首先将目标流量发送到路由器
    A。接着，路由器 A 将流量发送到路由器 B，后者与目标服务器有直接连接；路由器 B 将流量转发到最终目的地。
- en: As with all nodes, the gateway node doesn’t know the traffic’s exact destination,
    so it looks up the appropriate next gateway to send to. In this case, Routers
    A and B only know about the two networks they are directly connected to. To get
    from the client to the server, the traffic must be routed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有节点一样，网关节点并不知道流量的确切目的地，因此它会查找合适的下一个网关进行转发。在这种情况下，路由器 A 和 B 只知道它们直接连接的两个网络。为了让客户端与服务器之间的流量能够到达，必须进行路由。
- en: '![image](../Images/f04-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f04-01.jpg)'
- en: '*Figure 4-1: An example of routed traffic*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：路由流量示例*'
- en: '***Using Traceroute***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 Traceroute***'
- en: When tracing a route, you attempt to map the route that the IP traffic will
    take to a particular destination. Most operating systems have built-in tools to
    perform a trace, such as `traceroute` on most Unix-like platforms and `tracert`
    on Windows.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 路由追踪时，你试图映射出 IP 流量到达特定目的地的路径。大多数操作系统都有内置工具来执行追踪，例如大多数类 Unix 平台上的 `traceroute`
    和 Windows 上的 `tracert`。
- en: '[Listing 4-1](../Text/ch04.xhtml#ch4list1) shows the result of tracing the
    route to *[www.google.com](http://www.google.com)* from a home internet connection.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-1](../Text/ch04.xhtml#ch4list1) 显示了从家庭互联网连接追踪到 *[www.google.com](http://www.google.com)*
    的结果。'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 4-1: Traceroute to* [www.google.com](http://www.google.com) *using
    the `tracert` tool*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-1：使用 `tracert` 工具追踪到* [www.google.com](http://www.google.com) *的路径*'
- en: Each numbered line of output (1, 2, and so on) represents a unique gateway routing
    traffic to the ultimate destination. The output refers to a maximum number of
    *hops*. A single hop represents the network between each gateway in the entire
    route. For example, there’s a hop between your machine and the first router, another
    between that router and the next, and hops all the way to the final destination.
    If the maximum hop count is exceeded, the traceroute process will stop probing
    for more routers. The maximum hop can be specified to the trace route tool command
    line; specify `-h NUM` on Windows and `-m NUM` on Unix-style systems.(The output
    also shows the round-trip time from the machine performing the traceroute and
    the discovered node.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行输出（1、2 等）代表一个唯一的网关，将流量路由到最终目的地。输出中提到的最大跳数(*hops*)表示从一个网关到下一个网关的网络跳数。例如，在你的机器和第一个路由器之间有一个跳数，在那个路由器和下一个路由器之间又有一个跳数，一直到达最终目的地。如果跳数超过最大值，跟踪路由过程将停止探测更多的路由器。最大跳数可以在
    trace route 工具的命令行中指定；在 Windows 上指定`-h NUM`，在类 Unix 系统上指定`-m NUM`。（输出还显示了执行 traceroute
    的机器与发现节点之间的往返时间。）
- en: '***Routing Tables***'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***路由表***'
- en: The OS uses *routing tables* to figure out which gateways to send traffic to.
    A routing table contains a list of destination networks and the gateway to route
    traffic to. If a network is directly connected to the node sending the network
    traffic, no gateway is required, and the network traffic can be transmitted directly
    on the local network.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统使用*路由表*来决定将流量发送到哪些网关。路由表包含目标网络和将流量路由到的网关列表。如果某个网络直接连接到发送网络流量的节点，则无需网关，网络流量可以直接通过本地网络传输。
- en: You can view your computer’s routing table by entering the command `netstat
    -r` on most Unix-like systems or `route print` on Windows. [Listing 4-2](../Text/ch04.xhtml#ch4list2)
    shows the output from Windows when you execute this command.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在大多数类 Unix 系统中输入命令`netstat -r`，或在 Windows 中输入`route print`来查看计算机的路由表。[列表
    4-2](../Text/ch04.xhtml#ch4list2)显示了在 Windows 中执行此命令时的输出。
- en: '**route print**'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**route print**'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 4-2: Example routing table output*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-2：示例路由表输出*'
- en: As mentioned earlier, one reason routing is used is so that nodes don’t need
    to know the location of all other nodes on the network. But what happens to traffic
    when the gateway responsible for communicating with the destination network isn’t
    known? In that case, it’s common for the routing table to forward all unknown
    traffic to a *default gateway*. You can see the default gateway at ➊, where the
    network destination is 0.0.0.0\. This destination is a placeholder for the default
    gateway, which simplifies the management of the routing table. By using a placeholder,
    the table doesn’t need to be changed if the network configuration changes, such
    as through a DHCP configuration. Traffic sent to any destination that has no known
    matching route will be sent to the gateway registered for the 0.0.0.0 placeholder
    address.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用路由的一大原因是使节点无需知道网络中所有其他节点的位置。但当与目标网络通信的网关未知时，流量会发生什么？在这种情况下，路由表通常会将所有未知流量转发到一个*默认网关*。你可以在
    ➊ 看到默认网关，其中网络目标是 0.0.0.0。这一目标是默认网关的占位符，简化了路由表的管理。通过使用占位符，如果网络配置发生变化（例如通过 DHCP
    配置），就不需要更改路由表。发送到没有已知匹配路由的任何目标的流量将被发送到注册在 0.0.0.0 占位符地址的网关。
- en: How can you use routing to your advantage? Let’s consider an embedded system
    in which the operating system and hardware come as one single device. You might
    not be able to influence the network configuration in an embedded system as you
    might not even have access to the underlying operating system, but if you can
    present your capturing device as a gateway between the system generating the traffic
    and its ultimate destination, you can capture the traffic on that system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如何利用路由来为自己谋取优势？我们可以考虑一个嵌入式系统，其中操作系统和硬件作为一个整体设备存在。在嵌入式系统中，你可能无法影响网络配置，因为你可能甚至无法访问底层操作系统，但如果你能将捕获设备呈现为系统与最终目标之间的网关，你就可以捕获该系统上的流量。
- en: The following sections discuss ways to configure an OS to act as a gateway to
    facilitate traffic capture.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将讨论如何配置操作系统以充当网关来促进流量捕获。
- en: '**Configuring a Router**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**配置路由器**'
- en: 'By default, most operating systems do not route traffic directly between network
    interfaces. This is mainly to prevent someone on one side of the route from communicating
    directly with the network addresses on the other side. If routing is not enabled
    in the OS configuration, any traffic sent to one of the machine’s network interfaces
    that needs to be routed is instead dropped or an error message is sent to the
    sender. The default configuration is very important for security: imagine the
    implications if the router controlling your connection to the internet routed
    traffic from the internet directly to your private network.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，大多数操作系统不会直接在网络接口之间路由流量。 这主要是为了防止路由器的一侧与另一侧的网络地址直接通信。 如果在操作系统配置中未启用路由，则发送到计算机的任何需要路由的流量将被丢弃或向发送者发送错误消息。
    默认配置对安全性非常重要：想象一下，如果控制您与互联网连接的路由器将互联网流量直接路由到您的私有网络，会有什么影响。
- en: 'Therefore, to enable an OS to perform routing, you need to make some configuration
    changes as an administrator. Although each OS has different ways of enabling routing,
    one aspect remains constant: you’ll need at least two separate network interfaces
    installed in your computer to act as a router. In addition, you’ll need routes
    on both sides of the gateway for routing to function correctly. If the destination
    doesn’t have a corresponding route back to the source device, communication might
    not work as expected. Once routing is enabled, you can configure the network devices
    to forward traffic via your new router. By running a tool such as Wireshark on
    the router, you can capture traffic as it’s forwarded between the two network
    interfaces you configured.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要使操作系统能够执行路由功能，您需要以管理员身份进行一些配置更改。 尽管每个操作系统启用路由的方式都不同，但一个方面保持不变：您需要至少安装两个单独的网络接口来充当路由器。
    此外，您需要在网关两侧配置路由以确保路由正常运行。 如果目的地没有返回源设备的对应路由，通信可能无法正常工作。 启用路由后，您可以配置网络设备通过新的路由器转发流量。
    通过在路由器上运行诸如Wireshark之类的工具，您可以捕获在您配置的两个网络接口之间转发的流量。
- en: '***Enabling Routing on Windows***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在Windows上启用路由***'
- en: 'By default, Windows does not enable routing between network interfaces. To
    enable routing on Windows, you need to modify the system registry. You can do
    this by using a GUI registry editor, but the easiest way is to run the following
    command as an administrator from the command prompt:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Windows不会在网络接口之间启用路由。 要在Windows上启用路由功能，您需要修改系统注册表。 您可以使用GUI注册表编辑器来执行此操作，但最简单的方法是以管理员身份从命令提示符运行以下命令：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To turn off routing after you’ve finished capturing traffic, enter the following
    command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 完成流量捕获后，要关闭路由，请输入以下命令：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You’ll also need to reboot between command changes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改命令之间，还需要重新启动。
- en: '**WARNING**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Be very careful when you’re modifying the Windows registry. Incorrect changes
    could completely break Windows and prevent it from booting! Be sure to make a
    system backup using a utility like the built-in Windows backup tool before performing
    any dangerous changes.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*在修改Windows注册表时一定要非常小心。 错误的更改可能会完全破坏Windows并阻止其启动！ 在执行任何危险更改之前，请务必使用内置的Windows备份工具等实用程序进行系统备份。*'
- en: '***Enabling Routing on *nix***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在*nix上启用路由***'
- en: To enable routing on Unix-like operating systems, you simply change the IP routing
    system setting using the `sysctl` command. (Note that the instructions for doing
    so aren’t necessarily consistent between systems, but you should be able to easily
    find specific instructions.)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要在类Unix操作系统上启用路由功能，只需使用`sysctl`命令更改IP路由系统设置。 （请注意，这样做的说明可能在各个系统之间并不一致，但你应该可以很容易地找到具体的说明。）
- en: 'To enable routing on Linux for IPv4, enter the following command as root (no
    need to reboot; the change is immediate):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Linux上为IPv4启用路由，请以root身份输入以下命令（无需重新启动；更改立即生效）：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To enable IPv6 routing on Linux, enter this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Linux上启用IPv6路由，请输入以下命令：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can revert the routing configuration by changing `1` to `0` in the previous
    commands.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在上述命令中将`1`更改为`0`来恢复路由配置。
- en: 'To enable routing on macOS, enter the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要在macOS上启用路由，请输入以下命令：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Network Address Translation**'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络地址转换**'
- en: When trying to capture traffic, you may find that you can capture outbound traffic
    but not returning traffic. The reason is that an upstream router doesn’t know
    the route to the original source network; therefore, it either drops the traffic
    entirely or forwards it to an unrelated network. You can mitigate this situation
    by using *Network Address Translation (NAT)*, a technique that modifies the source
    and destination address information of IP and higher-layer protocols, such as
    TCP. NAT is used extensively to extend the limited IPv4 address space by hiding
    multiple devices behind a single public IP address.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试捕获流量时，你可能会发现能够捕获出站流量，但无法捕获返回流量。原因是上游路由器不知道到原始源网络的路由；因此，它要么完全丢弃流量，要么将流量转发到一个不相关的网络。你可以通过使用*网络地址转换（NAT）*来缓解这种情况，这种技术修改了IP和更高层协议（如TCP）的源和目的地址信息。NAT被广泛用于通过隐藏多个设备在一个公共IP地址后面，来扩展有限的IPv4地址空间。
- en: NAT can make network configuration and security easier, too. When NAT is turned
    on, you can run as many devices behind a single NAT IP address as you like and
    manage only that public IP address.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: NAT也可以使网络配置和安全性变得更简单。当启用NAT时，你可以在单个NAT IP地址后运行任意数量的设备，并只管理这个公共IP地址。
- en: 'Two types of NAT are common today: *Source NAT (SNAT)* and *Destination NAT
    (DNAT)*. The differences between the two relate to which address is modified during
    the NAT processing of the network traffic. SNAT (also called *masquerading*) changes
    the IP source address information; DNAT changes the destination address.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 今天常见的两种NAT类型是*源NAT（SNAT）*和*目的NAT（DNAT）*。这两者的区别在于，在NAT处理网络流量时，修改的是哪个地址。SNAT（也叫*伪装*）修改的是源IP地址信息；DNAT修改的是目的地址。
- en: '***Enabling SNAT***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启用SNAT***'
- en: When you want a router to hide multiple machines behind a single IP address,
    you use SNAT. When SNAT is turned on, as traffic is routed across the external
    network interface, the source IP address in the packets is rewritten to match
    the single IP address made available by SNAT.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想让路由器将多个机器隐藏在一个IP地址后面时，你需要使用SNAT。启用SNAT时，当流量通过外部网络接口路由时，数据包中的源IP地址会被重写，匹配由SNAT提供的单一IP地址。
- en: It can be useful to implement SNAT when you want to route traffic to a network
    that you don’t control because, as you’ll recall, both nodes on the network must
    have appropriate routing information for network traffic to be sent between the
    nodes. In the worst case, if the routing information is incorrect, traffic will
    flow in only one direction. Even in the best case, it’s likely that you would
    be able to capture traffic only in one direction; the other direction would be
    routed through an alternative path.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想将流量路由到一个你不控制的网络时，实施SNAT可能会很有用，因为正如你所记得的，网络中的两个节点必须拥有适当的路由信息才能在节点之间发送网络流量。在最坏的情况下，如果路由信息不正确，流量只能单向流动。即使在最好的情况下，你也很可能只能捕获一个方向的流量；另一个方向将会通过其他路径路由。
- en: SNAT addresses this potential problem by changing the source address of the
    traffic to an IP address that the destination node can route to—typically, the
    one assigned to the external interface of the router. Thus, the destination node
    can send traffic back in the direction of the router. [Figure 4-2](../Text/ch04.xhtml#ch4fig2)
    shows a simple example of SNAT.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: SNAT通过将流量的源地址修改为目的节点可以路由到的IP地址来解决这个潜在问题——通常是分配给路由器外部接口的地址。这样，目的节点就可以将流量返回到路由器的方向。[图4-2](../Text/ch04.xhtml#ch4fig2)展示了一个简单的SNAT示例。
- en: '![image](../Images/f04-02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f04-02.jpg)'
- en: '*Figure 4-2: An example of SNAT from a client to a server*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-2：从客户端到服务器的SNAT示例*'
- en: 'When the client wants to send a packet to a server on a different network,
    it sends it to the router that has been configured with SNAT. When the router
    receives the packet from the client, the source address is the client’s (10.0.0.1)
    and the destination is the server (the resolved address of *[domain.com](http://domain.com)*).
    It’s at this point that SNAT is used: the router modifies the source address of
    the packet to its own (1.1.1.1) and then forwards the packet to the server.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端想要向不同网络中的服务器发送数据包时，它会将数据包发送到已配置SNAT的路由器。当路由器接收到来自客户端的数据包时，源地址是客户端的（10.0.0.1），目的地是服务器（*[domain.com](http://domain.com)*的解析地址）。就在这个时候，使用了SNAT：路由器将数据包的源地址修改为它自己的（1.1.1.1），然后将数据包转发给服务器。
- en: When the server receives this packet, it assumes the packet came from the router;
    so, when it wants to send a packet back, it sends the packet to 1.1.1.1\. The
    router receives the packet, determines it came from an existing NAT connection
    (based on destination address and port numbers), and reverts the address change,
    converting 1.1.1.1 back to the original client address of 10.0.0.1\. Finally,
    the packet can be forwarded back to the original client without the server needing
    to know about the client or how to route to its network.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器接收到此数据包时，它会假设数据包来自路由器；因此，当它想要发送数据包时，它会将数据包发送到 1.1.1.1。路由器接收到数据包后，会根据目标地址和端口号判断它来自现有的
    NAT 连接，并还原地址更改，将 1.1.1.1 转换回原始客户端地址 10.0.0.1。最后，数据包可以被转发回原始客户端，而不需要服务器知道客户端的具体信息或如何路由到其网络。
- en: '***Configuring SNAT on Linux***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在 Linux 上配置 SNAT***'
- en: Although you can configure SNAT on Windows and macOS using Internet Connection
    Sharing, I’ll only provide details on how to configure SNAT on Linux because it’s
    the easiest platform to describe and the most flexible when it comes to network
    configuration.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在 Windows 和 macOS 上使用 Internet 连接共享配置 SNAT，但我只会提供如何在 Linux 上配置 SNAT 的详细信息，因为它是最容易描述的平台，也是最灵活的网络配置平台。
- en: 'Before configuring SNAT, you need to do the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置 SNAT 之前，你需要执行以下操作：
- en: • Enable IP routing as described earlier in this chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: • 如本章前面所述，启用 IP 路由。
- en: • Find the name of the outbound network interface on which you want to configure
    SNAT. You can do so by using the `ifconfig` command. The outbound interface might
    be named something like `eth0`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: • 查找你想要配置 SNAT 的出站网络接口名称。你可以使用 `ifconfig` 命令来查找。出站接口可能会被命名为 `eth0` 之类的名称。
- en: • Note the IP address associated with the outbound interface when you use `ifconfig`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: • 在使用 `ifconfig` 时，记下与出站接口关联的 IP 地址。
- en: 'Now you can configure the NAT rules using the `iptables`. (The `iptables` command
    is most likely already installed on your Linux distribution.) But first, flush
    any existing NAT rules in `iptables` by entering the following command as the
    root user:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用 `iptables` 配置 NAT 规则。（`iptables` 命令很可能已经安装在你的 Linux 发行版中。）但首先，请以 root
    用户身份输入以下命令，清除 `iptables` 中的任何现有 NAT 规则：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the outbound network interface has a fixed address, run the following commands
    as root to enable SNAT. Replace `INTNAME` with the name of your outbound interface
    and `INTIP` with the IP address assigned to that interface.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出站网络接口具有固定地址，请以 root 用户身份运行以下命令以启用 SNAT。将 `INTNAME` 替换为你的出站接口名称，将 `INTIP`
    替换为分配给该接口的 IP 地址。
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, if the IP address is configured dynamically (perhaps using DHCP or
    a dial-up connection), use the following command to automatically determine the
    outbound IP address:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果 IP 地址是动态配置的（可能是通过 DHCP 或拨号连接），可以使用以下命令自动确定出站 IP 地址：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***Enabling DNAT***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启用 DNAT***'
- en: DNAT is useful if you want to redirect traffic to a proxy or other service to
    terminate it, or before forwarding the traffic to its original destination. DNAT
    rewrites the destination IP address, and optionally, the destination port. You
    can use DNAT to redirect specific traffic to a different destination, as shown
    in [Figure 4-3](../Text/ch04.xhtml#ch4fig3), which illustrates traffic being redirected
    from both the router and the server to a proxy at 192.168.0.10 to perform a man-in-the-middle
    analysis.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将流量重定向到代理或其他服务以终止它，或在将流量转发到其原始目的地之前，DNAT 非常有用。DNAT 会重写目标 IP 地址，并可选地重写目标端口。你可以使用
    DNAT 将特定流量重定向到不同的目的地，如[图 4-3](../Text/ch04.xhtml#ch4fig3)所示，其中流量被从路由器和服务器都重定向到位于
    192.168.0.10 的代理，以进行中间人分析。
- en: '![image](../Images/f04-03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f04-03.jpg)'
- en: '*Figure 4-3: An example of DNAT to a proxy*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3：DNAT 重定向到代理的示例*'
- en: '[Figure 4-3](../Text/ch04.xhtml#ch4fig3) shows a client application sending
    traffic through a router that is destined for *[domain.com](http://domain.com)*
    on port 1234\. When a packet is received at the router, that router would normally
    just forward the packet to the original destination. But because DNAT is used
    to change the packet’s destination address and port to 192.168.0.10:8888, the
    router will apply its forwarding rules and send the packet to a proxy machine
    that can capture the traffic. The proxy then establishes a new connection to the
    server and forwards any packets sent from the client to the server. All traffic
    between the original client and the server can be captured and manipulated.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-3](../Text/ch04.xhtml#ch4fig3)展示了一个客户端应用程序通过路由器发送流量，目标是端口1234上的*[domain.com](http://domain.com)*。当数据包到达路由器时，路由器通常会将数据包转发到原始目标。但由于使用了DNAT来改变数据包的目标地址和端口为192.168.0.10:8888，路由器将应用其转发规则并将数据包发送到能够捕获流量的代理机器。代理然后与服务器建立新连接，并将客户端发送的任何数据包转发给服务器。原始客户端与服务器之间的所有流量都可以被捕获和篡改。'
- en: 'Configuring DNAT depends on the OS the router is running. (If your router is
    running Windows, you’re probably out of luck because the functionality required
    to support it isn’t exposed to the user.) Setup varies considerably between different
    versions of Unix-like operating systems and macOS, so I’ll only show you how to
    configure DNAT on Linux. First, flush any existing NAT rules by entering the following
    command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 配置DNAT取决于路由器运行的操作系统。（如果你的路由器运行Windows，可能不行，因为支持该功能的功能并没有暴露给用户。）不同版本的类Unix操作系统和macOS的设置差异很大，所以我只会展示如何在Linux上配置DNAT。首先，输入以下命令清除任何现有的NAT规则：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, run the following command as the root user, replacing `ORIGIP` (originating
    IP) with the IP address to match traffic to and `NEWIP` with the new destination
    IP address you want that traffic to go to.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，以root用户身份运行以下命令，替换`ORIGIP`（源IP）为要匹配流量的IP地址，并将`NEWIP`替换为你希望流量转发到的新目标IP地址。
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The new NAT rule will redirect any packet routed to `ORIGIP` to `NEWIP`. (Because
    the DNAT occurs prior to the normal routing rules on Linux, it’s safe to choose
    a local network address; the DNAT rule will not affect traffic sent directly from
    Linux.) To apply the rule only to a specific TCP or UDP, change the command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 新的NAT规则将把任何路由到`ORIGIP`的数据包重定向到`NEWIP`。（因为DNAT发生在Linux的常规路由规则之前，选择一个本地网络地址是安全的；DNAT规则不会影响直接从Linux发送的流量。）要将规则仅应用于特定的TCP或UDP，可以更改命令：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The placeholder `PROTO` (for protocol) should be either `tcp` or `udp` depending
    on the IP protocol being redirected using the DNAT rule. The values for `ORIGIP`
    (original IP) and `NEWIP` are the same as earlier.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符`PROTO`（协议）应该是`tcp`或`udp`，取决于通过DNAT规则重定向的IP协议。`ORIGIP`（原始IP）和`NEWIP`的值与之前相同。
- en: You can also configure `ORIGPORT` (the original port) and `NEWPORT` if you want
    to change the destination port. If `NEWPORT` is not specified, only the IP address
    will be changed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以配置`ORIGPORT`（原始端口）和`NEWPORT`，如果你希望改变目标端口。如果没有指定`NEWPORT`，则只会改变IP地址。
- en: '**Forwarding Traffic to a Gateway**'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**将流量转发到网关**'
- en: 'You’ve set up your gateway device to capture and modify traffic. Everything
    appears to be working properly, but there’s a problem: you can’t easily change
    the network configuration of the device you want to capture. Also, you have limited
    ability to change the network configuration the device is connected to. You need
    some way to reconfigure or trick the sending device into forwarding traffic through
    your gateway. You could accomplish this by exploiting the local network by spoofing
    packets for either DHCP or *Address Resolution Protocol (ARP)*.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经设置好网关设备来捕获和修改流量。一切似乎都在正常工作，但有一个问题：你无法轻易更改你想要捕获的设备的网络配置。此外，你也有限制改变该设备连接的网络配置的能力。你需要一种方法来重新配置或欺骗发送设备，将流量转发到你的网关。你可以通过利用局域网，利用欺骗数据包的方式来实现这一点，方法包括欺骗DHCP或*地址解析协议（ARP）*。
- en: '***DHCP Spoofing***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***DHCP欺骗***'
- en: DHCP is designed to run on IP networks to distribute network configuration information
    to nodes automatically. Therefore, if we can spoof DHCP traffic, we can change
    a node’s network configuration remotely. When DHCP is used, the network configuration
    pushed to a node can include an IP address as well as the default gateway, routing
    tables, the default DNS servers, and even additional custom parameters. If the
    device you want to test uses DHCP to configure its network interface, this flexibility
    makes it very easy to supply a custom configuration that will allow easy network
    traffic capture.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: DHCP 旨在在 IP 网络上运行，以自动向节点分发网络配置。因此，如果我们能够伪造 DHCP 流量，我们就可以远程更改节点的网络配置。使用 DHCP
    时，推送到节点的网络配置可以包括 IP 地址、默认网关、路由表、默认 DNS 服务器，甚至额外的自定义参数。如果你要测试的设备使用 DHCP 配置其网络接口，这种灵活性使得提供一个自定义配置变得非常容易，从而便于捕获网络流量。
- en: 'DHCP uses the UDP protocol to send requests to and from a DHCP service on the
    local network. Four types of DHCP packets are sent when negotiating the network
    configuration:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: DHCP 使用 UDP 协议向本地网络中的 DHCP 服务发送请求。协商网络配置时，会发送四种类型的 DHCP 数据包：
- en: '**Discover** Sent to all nodes on the IP network to discover a DHCP server'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**发现** 发送到 IP 网络上的所有节点，以发现 DHCP 服务器'
- en: '**Offer** Sent by the DHCP server to the node that sent the discovery packet
    to offer a network configuration'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**提供** 由 DHCP 服务器发送给发送发现数据包的节点，以提供网络配置'
- en: '**Request** Sent by the originating node to confirm its acceptance of the offer'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求** 由发起节点发送，确认其接受该配置'
- en: '**Acknowledgment** Sent by the server to confirm completion of the configuration'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**确认** 由服务器发送，确认配置完成'
- en: The interesting aspect of DHCP is that it uses an unauthenticated, connectionless
    protocol to perform configuration. Even if an existing DHCP server is on a network,
    you may be able to spoof the configuration process and change the node’s network
    configuration, including the default gateway address, to one you control. This
    is called *DHCP spoofing*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: DHCP 的有趣之处在于，它使用未经身份验证的无连接协议来执行配置。即使网络中已有 DHCP 服务器，你也可能能够欺骗配置过程并更改节点的网络配置，包括默认网关地址，改为你控制的地址。这被称为
    *DHCP 欺骗*。
- en: To perform DHCP spoofing, we’ll use *Ettercap*, a free tool that’s available
    on most operating systems (although Windows isn’t officially supported).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 DHCP 欺骗，我们将使用 *Ettercap*，这是一款免费工具，适用于大多数操作系统（尽管 Windows 并不被正式支持）。
- en: 'On Linux, start Ettercap in graphical mode as the root user:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Linux 上，以 root 用户身份启动 Ettercap 图形模式：
- en: '[PRE13]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You should see the Ettercap GUI, as shown in [Figure 4-4](../Text/ch04.xhtml#ch4fig4).
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该能看到如 [图 4-4](../Text/ch04.xhtml#ch4fig4) 所示的 Ettercap 图形界面。
- en: '![image](../Images/f04-04.jpg)'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../Images/f04-04.jpg)'
- en: '*Figure 4-4: The main Ettercap GUI*'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 4-4：Ettercap 主图形界面*'
- en: Configure Ettercap’s sniffing mode by selecting **Sniff** ▸ **Unified Sniffing**.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择 **嗅探** ▸ **统一嗅探** 配置 Ettercap 的嗅探模式。
- en: The dialog shown in [Figure 4-5](../Text/ch04.xhtml#ch4fig5) should prompt you
    to select the network interface you want to sniff on. Select the interface connected
    to the network you want to perform DHCP spoofing on. (Make sure the network interface’s
    network is configured correctly because Ettercap will automatically send the interface’s
    configured IP address as the DHCP default gateway.)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如 [图 4-5](../Text/ch04.xhtml#ch4fig5) 所示，应该会提示你选择要嗅探的网络接口。选择连接到你想进行 DHCP 欺骗的网络的接口。（确保该网络接口的网络配置正确，因为
    Ettercap 会自动将该接口配置的 IP 地址作为 DHCP 默认网关发送。）
- en: '![image](../Images/f04-05.jpg)'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../Images/f04-05.jpg)'
- en: '*Figure 4-5: Selecting the sniffing interface*'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 4-5：选择嗅探接口*'
- en: Enable DHCP spoofing by choosing **Mitm** ▸ **Dhcp spoofing**. The dialog shown
    in [Figure 4-6](../Text/ch04.xhtml#ch4fig6) should appear, allowing you to configure
    the DHCP spoofing options.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择 **Mitm** ▸ **DHCP 欺骗** 启用 DHCP 欺骗。此时，应该会显示 [图 4-6](../Text/ch04.xhtml#ch4fig6)
    中所示的对话框，允许你配置 DHCP 欺骗选项。
- en: '![image](../Images/f04-06.jpg)'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../Images/f04-06.jpg)'
- en: '*Figure 4-6: Configuring DHCP spoofing*'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 4-6：配置 DHCP 欺骗*'
- en: The IP Pool field sets the range of IP addresses to hand out for spoofing DHCP
    requests. Supply a range of IP addresses that you configured for the network interface
    that is capturing traffic. For example, in [Figure 4-6](../Text/ch04.xhtml#ch4fig6),
    the IP Pool value is set to 10.0.0.10-50 (the dash indicates all addresses inclusive
    of each value), so we’ll hand out IPs from 10.0.0.10 to 10.0.0.50 inclusive. Configure
    the Netmask to match your network interface’s netmask to prevent conflicts. Specify
    a DNS server IP of your choice.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IP池字段设置要欺骗DHCP请求的IP地址范围。提供一个IP地址范围，该范围是您为捕获流量配置的网络接口的IP地址。例如，在 [图 4-6](../Text/ch04.xhtml#ch4fig6)
    中，IP池值设置为10.0.0.10-50（短划线表示包括每个值的所有地址），因此我们将分配从10.0.0.10到10.0.0.50的IP地址。配置Netmask以匹配您的网络接口的子网掩码，以防止冲突。指定您选择的DNS服务器IP。
- en: Start sniffing by choosing **Start** ▸ **Start sniffing**. If DHCP spoofing
    is successful on the device, the Ettercap log window should look like [Figure
    4-7](../Text/ch04.xhtml#ch4fig7). The crucial line is `fake ACK` sent by Ettercap
    in response to the DHCP request.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择 **开始** ▸ **开始嗅探** 来开始嗅探。如果设备上的DHCP欺骗成功，Ettercap日志窗口应如 [图 4-7](../Text/ch04.xhtml#ch4fig7)
    所示。关键行是Ettercap响应DHCP请求发送的 `fake ACK`。
- en: '![image](../Images/f04-07.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f04-07.jpg)'
- en: '*Figure 4-7: Successful DHCP spoofing*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-7: 成功的DHCP欺骗*'
- en: That’s all there is to DHCP spoofing with Ettercap. It can be very powerful
    if you don’t have any other option and a DHCP server is already on the network
    you’re trying to attack.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用Ettercap进行DHCP欺骗的全部内容。如果您没有其他选择并且网络上已经存在DHCP服务器，则它可能非常强大。
- en: '***ARP Poisoning***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***ARP毒化***'
- en: 'ARP is critical to the operation of IP networks running on Ethernet because
    ARP finds the Ethernet address for a given IP address. Without ARP, it would be
    very difficult to communicate IP traffic efficiently over Ethernet. Here’s how
    ARP works: when one node wants to communicate with another on the same Ethernet
    network, it must be able to map the IP address to an Ethernet MAC address (which
    is how Ethernet knows the destination node to send traffic to). The node generates
    an ARP request packet (see [Figure 4-8](../Text/ch04.xhtml#ch4fig8)) containing
    the node’s 6-byte Ethernet MAC address, its current IP address, and the target
    node’s IP address. The packet is transmitted on the Ethernet network with a destination
    MAC address of ff:ff:ff:ff:ff:ff, which is the defined broadcast address. Normally,
    an Ethernet device only processes packets with a destination address that matches
    its address, but if it receives a packet with the destination MAC address set
    to the broadcast address, it will process it, too.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ARP对以太网运行的IP网络的操作至关重要，因为ARP查找给定IP地址的以太网地址。没有ARP，要在以太网上高效地通信IP流量将非常困难。ARP的工作原理如下：当一个节点想要与同一以太网网络上的另一个节点通信时，它必须能够将IP地址映射到以太网MAC地址（这是以太网知道发送流量到目标节点的方式）。该节点生成一个ARP请求数据包（见
    [图 4-8](../Text/ch04.xhtml#ch4fig8)），其中包含节点的6字节以太网MAC地址，当前IP地址以及目标节点的IP地址。该数据包通过以太网网络传输，目的MAC地址为
    ff:ff:ff:ff:ff:ff，这是定义的广播地址。通常，以太网设备只处理目的地址与其地址匹配的数据包，但如果收到目的MAC地址设置为广播地址的数据包，它也会处理。
- en: If one of the recipients of this broadcasted message has been assigned the target
    IP address, it can now return an ARP response, as shown in [Figure 4-9](../Text/ch04.xhtml#ch4fig9).
    This response is almost exactly the same as the request except the sender and
    target fields are reversed. Because the sender’s IP address should correspond
    to the original requested target IP address, the original requestor can now extract
    the sender’s MAC address and remember it for future network communication without
    having to resend the ARP request.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果广播消息的接收者之一被分配了目标IP地址，则现在可以返回一个ARP响应，如 [图 4-9](../Text/ch04.xhtml#ch4fig9)
    所示。该响应几乎与请求完全相同，只是发送者和目标字段被颠倒。因为发送者的IP地址应该对应于最初请求的目标IP地址，原始请求者现在可以提取发送者的MAC地址，并将其记住以备将来的网络通信，而无需重新发送ARP请求。
- en: '![image](../Images/f04-08.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f04-08.jpg)'
- en: '*Figure 4-8: An example ARP request packet*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-8: ARP请求数据包示例*'
- en: '![image](../Images/f04-09.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f04-09.jpg)'
- en: '*Figure 4-9: An example ARP response*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-9: ARP响应示例*'
- en: How can you use ARP poisoning to your advantage? As with DHCP, there’s no authentication
    on ARP packets, which are intentionally sent to all nodes on the Ethernet network.
    Therefore, you can inform the target node you own an IP address and ensure the
    node forwards traffic to your rogue gateway by sending spoofed ARP packets to
    poison the target node’s ARP cache. You can use Ettercap to spoof the packets,
    as shown in [Figure 4-10](../Text/ch04.xhtml#ch4fig10).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如何利用ARP中毒为自己谋取利益？与DHCP类似，ARP包没有认证，它们会被故意发送到以太网网络上的所有节点。因此，你可以通过向目标节点发送伪造的ARP包，欺骗它认为你拥有一个IP地址，并确保该节点将流量转发到你的恶意网关，进而中毒目标节点的ARP缓存。你可以使用Ettercap来伪造这些包，具体操作见[图4-10](../Text/ch04.xhtml#ch4fig10)。
- en: '![image](../Images/f04-10.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f04-10.jpg)'
- en: '*Figure 4-10: ARP poisoning*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-10：ARP中毒*'
- en: In [Figure 4-10](../Text/ch04.xhtml#ch4fig10), Ettercap sends spoofed ARP packets
    to the client and the router on the local network. If spoofing succeeds, these
    ARP packets will change the cached ARP entries for both devices to point to your
    proxy.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图4-10](../Text/ch04.xhtml#ch4fig10)中，Ettercap向本地网络上的客户端和路由器发送伪造的ARP包。如果伪造成功，这些ARP包将会改变这两个设备的缓存ARP条目，使它们指向你的代理。
- en: '**WARNING**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Be sure to spoof ARP packets to both the client and the router to ensure that
    you get both sides of the communication. Of course, if all you want is one side
    of the communication, you only need to poison one or the other node.*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*确保同时对客户端和路由器进行ARP包伪造，以确保你能够捕获到通信的两端。当然，如果你只需要捕获通信的一端，你只需对其中一个节点进行ARP中毒即可。*'
- en: 'To start ARP poisoning, follow these steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始ARP中毒，请按照以下步骤操作：
- en: Start Ettercap, and enter **Unified Sniffing** mode as you did with DHCP spoofing.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Ettercap，并进入**Unified Sniffing**模式，就像你在DHCP伪造时所做的那样。
- en: Select the network interface to poison (the one connected to the network with
    the nodes you want to poison).
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择要中毒的网络接口（即连接到你要中毒的节点的网络接口）。
- en: Configure a list of hosts to ARP poison. The easiest way to get a list of hosts
    is to let Ettercap scan for you by choosing **Hosts** ▸ **Scan For Hosts**. Depending
    on the size of the network, scanning can take from a few seconds to hours. When
    the scan is complete, choose **Hosts** ▸ **Host List**; a dialog like the one
    in [Figure 4-11](../Text/ch04.xhtml#ch4fig11) should appear.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置一个ARP中毒的主机列表。获取主机列表的最简单方法是通过选择**Hosts** ▸ **Scan For Hosts**让Ettercap扫描网络。根据网络的大小，扫描可能需要几秒钟到几小时的时间。扫描完成后，选择**Hosts**
    ▸ **Host List**，应该会弹出一个对话框，类似于[图4-11](../Text/ch04.xhtml#ch4fig11)。
- en: '![image](../Images/f04-11.jpg)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../Images/f04-11.jpg)'
- en: '*Figure 4-11: A list of discovered hosts*'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图4-11：已发现的主机列表*'
- en: As you can see in [Figure 4-11](../Text/ch04.xhtml#ch4fig11), we’ve found two
    hosts. In this case, one is the client node that you want to capture, which is
    on IP address 192.168.100.1 with a MAC address of 08:00:27:33:81:6d. The other
    node is the gateway to the internet on IP address 192.168.100.10 with a MAC address
    of 08:00:27:68:95:c3\. Most likely, you’ll already know the IP addresses configured
    for each network device, so you can determine which is the local machine and which
    is the remote machine.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如[图4-11](../Text/ch04.xhtml#ch4fig11)所示，我们已经找到两个主机。在这个例子中，一个是你想要捕获的客户端节点，IP地址为192.168.100.1，MAC地址为08:00:27:33:81:6d。另一个节点是通往互联网的网关，IP地址为192.168.100.10，MAC地址为08:00:27:68:95:c3。你很可能已经知道每个网络设备的IP地址配置，因此可以判断哪个是本地机器，哪个是远程机器。
- en: Choose your targets. Select one of the hosts from the list and click **Add to
    Target 1**; select the other host you want to poison and click **Add to Target
    2**. (Target 1 and Target 2 differentiate between the client and the gateway.)
    This should enable one-way ARP poisoning in which only data sent from Target 1
    to Target 2 is rerouted.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的目标。选中列表中的一个主机并点击**Add to Target 1**；选择另一个你想要中毒的主机并点击**Add to Target 2**。（Target
    1和Target 2用于区分客户端和网关。）这将启用单向ARP中毒，其中只有从Target 1到Target 2的数据会被重定向。
- en: Start ARP poisoning by choosing **Mitm** ▸ **ARP poisoning.** A dialog should
    appear. Accept the defaults and click **OK**. Ettercap should attempt to poison
    the ARP cache of your chosen targets. ARP poisoning may not work immediately because
    the ARP cache has to refresh. If poisoning is successful, the client node should
    look similar to [Figure 4-12](../Text/ch04.xhtml#ch4fig12).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**Mitm** ▸ **ARP poisoning**开始ARP中毒。一个对话框应该会弹出。接受默认设置并点击**OK**。Ettercap应该会尝试中毒你选择的目标的ARP缓存。由于ARP缓存需要刷新，ARP中毒可能不会立即生效。如果中毒成功，客户端节点的显示应类似于[图4-12](../Text/ch04.xhtml#ch4fig12)。
- en: '![image](../Images/f04-12.jpg)'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../Images/f04-12.jpg)'
- en: '*Figure 4-12: Successful ARP poisoning*'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 4-12：成功的 ARP 中毒*'
- en: '[Figure 4-12](../Text/ch04.xhtml#ch4fig12) shows the router was poisoned at
    IP 192.168.100.10, which has had its MAC Hardware address modified to the proxy’s
    MAC address of 08:00:27:08:dc:e6\. (For comparison, see the corresponding entry
    in [Figure 4-11](../Text/ch04.xhtml#ch4fig11).) Now any traffic that is sent from
    the client to the router will instead be sent to the proxy (shown by the MAC address
    of 192.168.100.5). The proxy can forward the traffic to the correct destination
    after capturing or modifying it.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-12](../Text/ch04.xhtml#ch4fig12) 显示路由器在 IP 192.168.100.10 处遭到中毒，且其 MAC
    硬件地址已被修改为代理的 MAC 地址 08:00:27:08:dc:e6（对比，请参见 [图 4-11](../Text/ch04.xhtml#ch4fig11)
    中的相应条目）。现在，任何从客户端发送到路由器的流量将被发送到代理（由 192.168.100.5 的 MAC 地址表示）。代理可以在捕获或修改流量后将其转发到正确的目标。'
- en: One advantage that ARP poisoning has over DHCP spoofing is that you can redirect
    nodes on the local network to communicate with your gateway even if the destination
    is on the local network. ARP poisoning doesn’t have to poison the connection between
    the node and the external gateway if you don’t want it to.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ARP 中毒相比 DHCP 欺骗的一个优势是，即使目标在本地网络上，你也可以将本地网络中的节点重定向到与你的网关通信。如果你不希望，它不需要破坏节点与外部网关之间的连接。
- en: '**Final Words**'
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结束语**'
- en: In this chapter, you’ve learned a few additional ways to capture and modify
    traffic between a client and server. I began by describing how to configure your
    OS as an IP gateway, because if you can forward traffic through your own gateway,
    you have a number of techniques available to you.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了几种额外的方法来捕获并修改客户端与服务器之间的流量。我首先描述了如何将你的操作系统配置为 IP 网关，因为如果你能通过自己的网关转发流量，你将拥有多种可用的技术。
- en: Of course, just getting a device to send traffic to your network capture device
    isn’t always easy, so employing techniques such as DHCP spoofing or ARP poisoning
    is important to ensure that traffic is sent to your device rather than directly
    to the internet. Fortunately, as you’ve seen, you don’t need custom tools to do
    so; all the tools you need are either already included in your operating system
    (especially if you’re running Linux) or easily downloadable.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅让设备将流量发送到你的网络捕获设备并不总是容易的，因此使用诸如 DHCP 欺骗或 ARP 中毒等技术很重要，以确保流量发送到你的设备而不是直接发送到互联网。幸运的是，正如你所看到的，你不需要自定义工具来完成这项任务；你所需的所有工具要么已经包含在操作系统中（特别是如果你使用的是
    Linux），要么可以轻松下载。
