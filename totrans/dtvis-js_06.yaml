- en: Chapter 6. Visualizing Geographic Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Humans crave context when evaluating data, so it’s important to provide that
    context when it’s available. In the previous chapter, we saw how timelines can
    provide one frame of reference; now we’ll examine another equally important context:
    place. If a data set includes geographic coordinates or has values that correspond
    to different geographic regions, you can provide geographic context using a map-based
    visualization. The examples in this chapter consider two types of map-based visualizations.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first two examples, we want to show how data varies by region. The resulting
    visualizations, known as choropleth maps, use color to highlight different characteristics
    of the different regions. For the next two examples, the visualization data doesn’t
    itself vary by region directly, but the data does have a geographic component.
    By showing the data on a map, we can help our users understand it.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, we’ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use special map fonts to create maps with minimal JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manipulate Scalable Vector Graphic (SVG) image maps with JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use a simple mapping library to add maps to web pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to integrate a full-featured map library into a visualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Map Fonts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One technique for adding maps to web pages is surprisingly simple but often
    overlooked—map fonts. Two examples of these fonts are Stately (*[http://intridea.github.io/stately/](http://intridea.github.io/stately/)*)
    for the United States and Continental (*[http://contfont.net/](http://contfont.net/)*)
    for Europe. Map fonts are special-purpose web fonts whose character sets contain
    map symbols instead of letters and numbers. In just a few easy steps, we’ll create
    a visualization of Europe using the symbols from Continental.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Include the Fonts in the Page'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main websites for both Stately and Continental include more detailed instructions
    for installing the fonts, but all that’s really necessary is including a single
    CSS style sheet. In the case of Continental, that style sheet is called, naturally,
    *continental.css*. No JavaScript libraries are required.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**For a production website, you might want to combine** *continental.css* **with
    your site’s other style sheets to minimize the number of network requests the
    browser has to make.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Display One Country'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To show a single country, all we have to do is include an HTML `<span>` element
    with the appropriate attributes. We can do this right in the markup, adding a
    class attribute set to `map-` followed by a two-letter country abbreviation. (*fr*
    is the international two-letter abbreviation for France.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For this example, we’ll use JavaScript to generate the markup.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here we’ve created a new `<span>` element, giving it a class name of `"map-fr"`,
    and appending it to the map `<div>`.
  prefs: []
  type: TYPE_NORMAL
- en: One last bit of housekeeping is setting the size of the font. By default, any
    map font character will be the same size as a regular text character. For maps
    we want something much larger, so we can use standard CSS rules to increase the
    size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That’s all it takes to add France to a web page, as you can see in [Figure 6-1](ch06.html#map_fonts_make_it_very_easy_to_add_a_map
    "Figure 6-1. Map fonts make it very easy to add a map to a web page.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Map fonts make it very easy to add a map to a web page.](figs/web/06fig01.png.jpg)Figure 6-1. Map
    fonts make it very easy to add a map to a web page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Combine Multiple Countries into a Single Map'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this example we want to show more than a single country. We’d like to visualize
    the median age for all of Europe’s countries, based on United Nations population
    data (*[http://www.un.org/en/development/desa/population/](http://www.un.org/en/development/desa/population/)*)
    from 2010\. To do that, we’ll create a map that includes all European countries,
    and we’ll style each country according to the data.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in this visualization is putting all of the countries into a
    single map. Since each country is a separate character in the Continental font,
    we want to overlay those characters on top of one another rather than spread them
    across the page. That requires setting a couple of CSS rules.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: First we set the position of the outer container to `relative` ➊. This rule
    doesn’t change the styling of the outer container at all, but it does establish
    a *positioning context* for anything within the container. Those elements will
    be our individual country symbols, and we set their position to be `absolute`
    ➋. We then place each one at the top and left ➌, respectively, of the map so they’ll
    overlay one another. Because we’ve positioned the container `relative`, the country
    symbols will be positioned relative to that container rather than to the page
    as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we’ve used a couple of CSS tricks to apply this positioning to all
    of the individual symbols within this element. We start by selecting the element
    with an `id` of `map`. Nothing fancy there. The direct descendent selector (`>`),
    however, says that what follows should match only elements that are immediate
    children of that element, not arbitrary descendants. Finally, the attribute selector
    `[class*="map-"]` specifies only children that have a class containing the characters
    `map-`. Since all the country symbols will be `<span>` elements with a class of
    `map-`*`xx`* (where *`xx`* is the two-letter country abbreviation), this will
    match all of our countries.
  prefs: []
  type: TYPE_NORMAL
- en: In our JavaScript, we can start with an array listing all of the countries and
    iterate through it. For each country, we create a `<span>` element with the appropriate
    class and insert it in the map `<div>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With these style rules defined, inserting multiple `<span>` elements within
    our map `<div>` creates the complete, if somewhat uninteresting, map of Europe
    shown in [Figure 6-2](ch06.html#overlaying_map_characters_on_top_of_one "Figure 6-2. Overlaying
    map characters on top of one another creates a complete map.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Overlaying map characters on top of one another creates a complete map.](figs/web/06fig02.png.jpg)Figure 6-2. Overlaying
    map characters on top of one another creates a complete map.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Vary the Countries Based on the Data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’re ready to create the actual data visualization. Naturally, we’ll start
    with the data, in this case from the United Nations. Here’s how we could format
    that data in a JavaScript array. (The full data set can be found with the book’s
    source code at *[http://jsDataV.is/source/](http://jsDataV.is/source/)*.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There are several ways we could use this data to modify the map. We could use
    JavaScript code to set the visualization properties directly by, for example,
    changing the `color` style for each country symbol. That would work, but it forgoes
    one of the big advantages of map fonts. With map fonts, our visualization is standard
    HTML, so we can use standard CSS to style it. If, in the future, we want to change
    the styles on the page, they’ll all be contained within the style sheets, and
    we won’t have to hunt through our JavaScript code to adjust colors.
  prefs: []
  type: TYPE_NORMAL
- en: To indicate which styles are appropriate for an individual country symbol, we
    can attach a `data-` attribute to each.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we set the `data-age` attribute to the mean age, rounded to the
    nearest whole number ➋. To find the age for a given country, we need that country’s
    index in the `ages` array. The `findCountryIndex()` function ➊ does that in a
    straightforward way.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can assign CSS style rules based on that `data-age` attribute. Here’s
    the start of a simple blue gradient for the different ages, where greater median
    ages are colored darker blue-green.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Although they’re beyond the scope of this book, CSS preprocessors such as
    LESS (***[http://lesscss.org/](http://lesscss.org/)***) and SASS (***[http://sass-lang.com/](http://sass-lang.com/)***)
    make it easy to create these kinds of rules.**'
  prefs: []
  type: TYPE_NORMAL
- en: Now we have the nice visualization of the age trends shown in [Figure 6-3](ch06.html#with_css_rulescomma_we_can_change_the_st
    "Figure 6-3. With CSS rules, we can change the styles of individual map symbols.").
  prefs: []
  type: TYPE_NORMAL
- en: '![With CSS rules, we can change the styles of individual map symbols.](figs/web/06fig03.png.jpg)Figure 6-3. With
    CSS rules, we can change the styles of individual map symbols.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Add a Legend'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To finish off the visualization, we can add a legend to the map. Because the
    map itself is nothing more than standard HTML elements with CSS styling, it’s
    easy to create a matching legend. This example covers a fairly broad range (ages
    28 to 44), so a linear gradient works well as a key. Your own implementation will
    depend on the specific browser versions that you wish to support, but a generic
    style rule would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The resulting visualization in [Figure 6-4](ch06.html#standard_html_can_also_provide_a_legend
    "Figure 6-4. Standard HTML can also provide a legend for the visualization.")
    summarizes the median age for European countries in a clear and concise format.
  prefs: []
  type: TYPE_NORMAL
- en: '![Standard HTML can also provide a legend for the visualization.](figs/web/06fig04.png.jpg)Figure 6-4. Standard
    HTML can also provide a legend for the visualization.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Scalable Vector Graphics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Map fonts like those in the previous example are easy to use and visually effective,
    but only a few map fonts exist, and they definitely don’t cover all the conceivable
    geographic regions. For visualizations of other regions, we’ll have to find a
    different technique. Maps, of course, are ultimately images, and web browsers
    can display many different image formats. One format in particular, called *Scalable
    Vector Graphics (SVG)*, is especially well suited for interactive visualizations.
    That’s because, as we’ll see in this example, JavaScript code (as well as CSS
    styles) can easily and naturally interact with SVG images.
  prefs: []
  type: TYPE_NORMAL
- en: Although our example for this section deals with a map, the techniques here
    are by no means limited to maps. Whenever you have a diagram or illustration in
    SVG format, you can manipulate it directly on a web page.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**There is one important consideration for using SVG: only modern web browsers
    support it. more specifically, IE8 (and earlier) cannot display SVG images. If
    a significant number of your users are using older browsers, you might want to
    consider alternatives.**'
  prefs: []
  type: TYPE_NORMAL
- en: For web developers, SVG is especially convenient because its syntax uses the
    same structure as HTML. You can use many of the same tools and techniques for
    working with HTML on SVG as well. Consider, for example, a skeletal HTML document.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare that to the next example: the universal symbol for first aid represented
    in an SVG document.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**If you have worked with htmL before htmL5, the similarities might be especially
    striking, as the SVG header text follows the same format as htmL4.**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even style the SVG elements using CSS. Here’s how we could color the
    preceding image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 6-5](ch06.html#svg_images_may_be_embedded_directly_with "Figure 6-5. SVG
    images may be embedded directly within web pages.") shows how that SVG renders.'
  prefs: []
  type: TYPE_NORMAL
- en: '![SVG images may be embedded directly within web pages.](figs/web/06fig05.png.jpg)Figure 6-5. SVG
    images may be embedded directly within web pages.'
  prefs: []
  type: TYPE_NORMAL
- en: The affinity between HTML and SVG is, in fact, far stronger than the similar
    syntax. With modern browsers, you can mix SVG and HTML in the same web page. To
    see how that works, let’s visualize health data for the 159 counties in the US
    state of Georgia. The data comes from County Health Rankings (*[http://www.countyhealthrankings.org/](http://www.countyhealthrankings.org/)*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Create the SVG Map'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our visualization starts with a map, so we’ll need an illustration of Georgia’s
    counties in SVG format. Although that might seem like a challenge, there are actually
    many sources for SVG maps that are free to use, as well as special-purpose applications
    that can generate SVG maps for almost any region. The Wikimedia Commons (*[http://commons.wikimedia.org/wiki/Main_Page](http://commons.wikimedia.org/wiki/Main_Page)*),
    for example, contains a large number of open source maps, including many of Georgia.
    We’ll use one showing data from the National Register of Historic Places (*[http://commons.wikimedia.org/wiki/File:NRHP_Georgia_Map.svg#file](http://commons.wikimedia.org/wiki/File:NRHP_Georgia_Map.svg#file)*).
  prefs: []
  type: TYPE_NORMAL
- en: After downloading the map file, we can adjust it to better fit our needs, removing
    the legend, colors, and other elements that we don’t need. Although you can do
    this in a text editor (just as you can edit HTML), you may find it easier to use
    a graphics program such as Adobe Illustrator or a more web-focused app like Sketch
    (*[http://www.bohemiancoding.com/sketch/](http://www.bohemiancoding.com/sketch/)*).
    You might also want to take advantage of an SVG optimization website (*[http://petercollingridge.appspot.com/svg-optimiser/](http://petercollingridge.appspot.com/svg-optimiser/)*)
    or application (*[https://github.com/svg/](https://github.com/svg/)*), which can
    compress an SVG by removing extraneous tags and reducing the sometimes-excessive
    precision of graphics programs.
  prefs: []
  type: TYPE_NORMAL
- en: Our result will be a series of `<path>` elements, one for each county. We’ll
    also want to assign a `class` or `id` to each path to indicate the county. The
    resulting SVG file might begin like the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To summarize, here are the steps to create the SVG map.
  prefs: []
  type: TYPE_NORMAL
- en: Locate a suitably licensed SVG-format map file or create one using a special-purpose
    map application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the SVG file in a graphics application to remove extraneous components
    and simplify the illustration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optimize the SVG file using an optimization site or application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make final adjustments (such as adding `id` attributes) in your regular HTML
    editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Step 2: Embed the Map in the Page'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest way to include an SVG map in a web page is to embed the SVG markup
    directly within the HTML markup. To include the first-aid symbol, for example,
    just include the SVG tags within the page itself, as shown at ➊ through ➋. You
    don’t have to include the header tags that are normally present in a standalone
    SVG file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If your map is relatively simple, direct embedding is the easiest way to include
    it in the page. Our map of Georgia, however, is about 1 MB even after optimization.
    That’s not unusual for maps with reasonable resolution, as describing complex
    borders such as coastlines or rivers can make for large `<path>` elements. Especially
    if the map isn’t the sole focus of the page, you can provide a better user experience
    by loading the rest of the page first. That will give your users something to
    read while the map loads in the background. You can even add a simple animated
    progress loader if that’s appropriate for your site.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using jQuery, loading the map is a single instruction. You do want
    to make sure, though, that your code doesn’t start manipulating the map until
    the load is complete. Here’s how that would look in the source code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 3: Collect the Data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The data for our visualization is available as an Excel spreadsheet directly
    from County Health Rankings (*[http://www.countyhealthrankings.org/](http://www.countyhealthrankings.org/)*).
    We’ll convert that to a JavaScript object in advance, and we’ll add a two-letter
    code corresponding to each county. Here’s how that array might begin.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For this visualization we’d like to show the variation in health outcomes among
    counties. The data set provides two variables for that value, a ranking and a
    z-score (a measure of how far a sample is from the mean in terms of standard deviation).
    The County Health Rankings site provides z-scores slightly modified from the traditional
    statistical definition. Normal z-scores are always positive; in this data set,
    however, measurements that are subjectively better than average are multiplied
    by –1 so that they are negative. A county whose health outcome is two standard
    deviations “better” than the mean, for example, is given a z-score of –2 instead
    of 2\. This adjustment makes it easier to use these z-scores in our visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Our first step in working with these z-scores is to find the maximum and minimum
    values. We can do that by extracting the outcomes as a separate array and then
    using JavaScript’s built-in `Math.max()` and `Math.min()` functions. Note that
    the following code uses the `map()` method to extract the array, and that method
    is available only in modern browsers. Since we’ve chosen to use SVG images, however,
    we’ve already restricted our users to modern browsers, so we might as well take
    advantage of that when we can.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we’ve used the `.apply()` method here. Normally the `Math.max()`
    and `Math.min()` functions accept a comma-separated list of arguments. We, of
    course, have an array instead. The `apply()` method, which works with any JavaScript
    function, turns an array into a comma-separated list. The first parameter is the
    context to use, which in our case doesn’t matter, so we set it to `null`.
  prefs: []
  type: TYPE_NORMAL
- en: To complete the data preparation, let’s make sure the minimum and maximum ranges
    are symmetric about the mean.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If, for example, the z-scores ranged from `-2` to `1.5`, this code would extend
    the range to `[-2, 2]`. This adjustment will make the color scales symmetric as
    well, thus making our visualization easier for users to interpret.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Define the Color Scheme'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Defining an effective color scheme for a map can be quite tricky, but fortunately
    there are some excellent resources available. For this visualization we’ll rely
    on the Chroma.js library (*[http://driven-by-data.net/about/chromajs/](http://driven-by-data.net/about/chromajs/)*).
    That library includes many tools for working with and manipulating colors and
    color scales, and it can satisfy the most advanced color theorist. For our example,
    however, we can take advantage of the predefined color scales, specifically those
    defined originally by Cynthia Brewer (*[http://colorbrewer2.org/](http://colorbrewer2.org/)*).
  prefs: []
  type: TYPE_NORMAL
- en: The Chroma.js library is available on popular content distribution networks,
    so we can rely on a network such as CloudFlare’s cdnjs (*[http://cdnjs.com/](http://cdnjs.com/)*)
    to host it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To use a predefined scale, we pass the scale’s name (`"BrBG"` for Brewer’s brown-to-blue-green
    scale) to the `chroma.scale()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: At the same time, we indicate the domain for our scale (`minZ` to `maxZ`, although
    we’re reversing the order because of the data set’s z-score adjustment) and our
    desired output. The `"hex"` output is the common `"#012345"` format compatible
    with CSS and HTML markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Color the Map'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With our color scheme established, we can now apply the appropriate colors to
    each county on the map. That’s probably the easiest step in the whole visualization.
    We iterate through all the counties, finding their `<path>` elements based on
    their `id` values, and applying the color by setting the `fill` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The resulting map, shown in [Figure 6-6](ch06.html#css_rules_can_set_the_styles_for_individ
    "Figure 6-6. CSS rules can set the styles for individual SVG elements within an
    SVG illustration."), illustrates which counties are above average and which are
    below average for health outcomes in 2014.
  prefs: []
  type: TYPE_NORMAL
- en: '![CSS rules can set the styles for individual SVG elements within an SVG illustration.](figs/web/06fig06.png.jpg)Figure 6-6. CSS
    rules can set the styles for individual SVG elements within an SVG illustration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 6: Add a Legend'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To help users interpret the map, we can add a legend to the visualization. We
    can take advantage of the Chroma.js scale to easily create a table that explains
    the variation. For the table, we’ll use four increments for the colors on each
    side of the mean value. That gives us a total of nine colors for the legend.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Some straightforward CSS will style the table appropriately. Because we have
    nine colors, we set the width of each table cell to `11.1111%` (1/9 is 0.111111).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we use the Chroma scale created earlier to set the background color
    for the legend’s table cells. Because the legend is a `<table>` element, we can
    directly access the rows and the cells within the rows. Although these elements
    look like arrays in the following code, they’re not true JavaScript arrays, so
    they don’t support array methods such as `forEach()`. For now, we’ll iterate through
    them with a `for` loop, but if you’d rather use the array methods, stay tuned
    for a simple trick. Note that once again we’re working backward because of the
    data set’s z-score adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ we calculate the fraction of the current index from the total number of
    legend colors `((idx + 0.5) / cells.length)`, multiply that by the total range
    of the scale `(maxZ - minZ)`, and subtract the result from the maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: The result is the legend for the map in [Figure 6-7](ch06.html#html_less_thantablegreater_than_can_serv
    "Figure 6-7. An HTML <table> can serve as a legend.").
  prefs: []
  type: TYPE_NORMAL
- en: '![An HTML <table> can serve as a legend.](figs/web/06fig07.png.jpg)Figure 6-7. An
    HTML `<table>` can serve as a legend.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 7: Add Interactions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To complete the visualization, let’s enable users to hover their mouse over
    a county on the map to see more details. Of course, mouse interactions are not
    available for tablet or smartphone users. To support those users, you could add
    a similar interaction for tap or click events. That code would be almost identical
    to the next example.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by defining a table to show county details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Initially, we don’t want that table to be visible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To show the table, we use event handler functions that track when the mouse
    enters or leaves an SVG path for a county. To find these `<path>` elements, we
    can use the `querySelectorAll()` function that modern browsers support. Unfortunately,
    that function doesn’t return a true array of elements, so we can’t use array methods
    such as `forEach()` to iterate through those elements. There’s a trick, however,
    that will let us convert the returned list into a true array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This code calls the `[].slice.call()` function with the “not quite array” object
    as its parameter. The result is a true array with all of its useful methods.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to making the details table visible, we’ll also want to update it
    with the appropriate information. To help with this display, we can write a function
    that converts a z-score into a more user-friendly explanation. The specific values
    in the following example are arbitrary since we’re not trying for statistical
    precision in this visualization.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of noteworthy items in this function. First, the statement
    `z = +z` converts the z-score from a string to a numeric value for the tests that
    follow. Second, remember that because of the z-score adjustments, the negative
    z-scores are actually better than average, while the positive values are below
    average.
  prefs: []
  type: TYPE_NORMAL
- en: We can use this function to provide the data for our details table. The first
    step is finding the full data set for the associated `<path>` element. To do that,
    we search through the `counties` array looking for a `code` property that matches
    the `id` attribute of the path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Because `indexOf()` doesn’t allow us to find objects by key, we’ve used the
    `some()` method instead. That method terminates as soon as it finds a match, so
    we avoid iterating through the entire array.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve found the county data, it’s a straightforward process to update the
    table. The following code directly updates the relevant table cell’s text content.
    For a more robust implementation, you could provide class names for the cells
    and update based on those class names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we just need a few more refinements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here we add a stroke color at ➊ for counties that are highlighted. We remove
    the stroke at ➋ when the mouse leaves the path.
  prefs: []
  type: TYPE_NORMAL
- en: At this point our visualization example is complete. [Figure 6-8](ch06.html#browsers_left_parenthesisand_a_bit_of_co
    "Figure 6-8. Browsers (and a bit of code) can turn SVG illustrations into interactive
    visualizations.") shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Browsers (and a bit of code) can turn SVG illustrations into interactive
    visualizations.](figs/web/06fig08.png.jpg)Figure 6-8. Browsers (and a bit of code)
    can turn SVG illustrations into interactive visualizations.'
  prefs: []
  type: TYPE_NORMAL
- en: Including Maps for Context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far in this chapter, we’ve looked at map visualizations where the main subjects
    are geographic regions—countries in Europe or counties in Georgia. In those cases,
    choropleth maps were effective in showing the differences between regions. Not
    all map visualizations have the same focus, however. In some cases, we want to
    include a map more as context or background for the visualization data.
  prefs: []
  type: TYPE_NORMAL
- en: When we want to include a map as a visualization background, we’re likely to
    find that traditional mapping libraries will serve us better than custom choropleth
    maps. The most well-known mapping library is probably Google Maps (*[http://maps.google.com/](http://maps.google.com/)*),
    and you’ve almost certainly seen many examples of embedded Google maps on web
    pages. There are, however, several free and open source alternatives to Google
    Maps. For this example, we’ll use the Modest Maps library (*[https://github.com/modestmaps/modestmaps-js/](https://github.com/modestmaps/modestmaps-js/)*)
    from Stamen Design. To show off this library, we’ll visualize the major UFO sightings
    in the United States (*[http://en.wikipedia.org/wiki/UFO_sightings_in_the_United_States](http://en.wikipedia.org/wiki/UFO_sightings_in_the_United_States)*),
    or at least those important enough to merit a Wikipedia entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Set Up the Web Page'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For our visualization, we’ll rely on a couple of components from the Modest
    Maps library: the core library itself and the spotlight extension that can be
    found in the library’s examples folder. In production you would likely combine
    these and minify the result to optimize performance, but for our example, we’ll
    include them separately.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We’ve also set aside a `<div>` at ➊ to hold the map. Not surprisingly, it has
    the `id` of `"map"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Prepare the Data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Wikipedia data can be formatted as an array of JavaScript objects. We can
    include whatever information we wish in the objects, but we’ll definitely need
    the latitude and longitude of the sighting in order to place it on the map. Here’s
    how you might structure the data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `location` property holds the latitude and longitude (where negative values
    indicate west) as a two-element array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Choose a Map Style'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with most mapping libraries, Modest Maps builds its maps using layers. The
    layering process works much like it does in a graphics application such as Photoshop
    or Sketch. Subsequent layers add further visual information to the map. In most
    cases, the base layer for a map consists of image tiles. Additional layers such
    as markers or routes can be included on top of the image tiles.
  prefs: []
  type: TYPE_NORMAL
- en: When we tell Modest Maps to create a map, it calculates which tiles (both size
    and location) are needed and then it requests those tiles asynchronously over
    the Internet. The tiles define the visual style of the map. Stamen Design has
    published several tile sets itself; you can see them on *[http://maps.stamen.com/](http://maps.stamen.com/)*.
  prefs: []
  type: TYPE_NORMAL
- en: To use the Stamen tiles, we’ll add one more, small JavaScript library to our
    page. That library is available directly from Stamen Design (*[http://maps.stamen.com/js/tile.stamen.js](http://maps.stamen.com/js/tile.stamen.js)*).
    It should be included *after* the Modest Maps library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: For our example, the “toner” style is a good match, so we’ll use those tiles.
    To use those tiles, we create a *tile layer* for the map.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When you consider a source for image tiles, be aware of any copyright restrictions.
    Some image tiles must be licensed, and even those that are freely available often
    require that any user identify the provider as the source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Draw the Map'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we’re ready to draw the map itself. That takes two JavaScript statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: First we create a new `MM.Map` object, giving it the `id` of the element containing
    the map and the tiles we just initialized. Then we provide the latitude and longitude
    for the map’s center as well as an initial zoom level. For your own maps, you
    may need to experiment a bit to get the right values, but for this example, we’ll
    center and zoom the map so that it comfortably shows the continental United States.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting map, shown in [Figure 6-9](ch06.html#map_libraries_can_show_maps_based_on_geo
    "Figure 6-9. Map libraries can show maps based on geographic coordinates."), forms
    a base for showing the sightings.
  prefs: []
  type: TYPE_NORMAL
- en: '![Map libraries can show maps based on geographic coordinates.](figs/web/06fig09.png.jpg)Figure 6-9. Map
    libraries can show maps based on geographic coordinates.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that both Stamen Design and OpenStreetMap are credited. That attribution
    is required by the terms of the Stamen Design license.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Add the Sightings'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With our map in place, it’s time to add the individual UFO sightings. We’re
    using the spotlight extension to highlight these locations, so we first create
    a spotlight layer for the map. We’ll also want to set the radius of the spotlight
    effect. As with the center and zoom parameters, a bit of trial and error helps
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now we can iterate through the array of sightings that make up our data. For
    each sighting, we extract the latitude and longitude of the location and add that
    location to the spotlight layer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: At this point our visualization is complete. [Figure 6-10](ch06.html#adding_layers_in_a_map_library_can_empha
    "Figure 6-10. Adding layers in a map library can emphasize regions of a map.")
    shows where UFOs have allegedly appeared over the United States in a suitably
    mysterious context.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding layers in a map library can emphasize regions of a map.](figs/web/06fig10.png.jpg)Figure 6-10. Adding
    layers in a map library can emphasize regions of a map.'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating a Full-Featured Mapping Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Modest Maps library of the previous example is a fine library for simple
    map visualizations, but it doesn’t have all of the features and support of a full-featured
    service such as Google Maps. There is, however, an open source library that does
    provide those features: Leaflet (*[http://leafletjs.com/](http://leafletjs.com/)*).
    In this example, we’ll build a more complex visualization that features a Leaflet-based
    map.'
  prefs: []
  type: TYPE_NORMAL
- en: In the 1940s, two private railroads were in competition for passenger traffic
    in the southeastern United States. Two routes that competed most directly were
    the Silver Comet (run by Seaboard Air Lines) and the Southerner (operated by Southern
    Railways). Both served passengers traveling between New York and Birmingham, Alabama.
    One factor cited in the Southerner’s ultimate success was the shorter distance
    of its route. Trips on the Southerner were quicker, giving Southern Railways a
    competitive advantage. Let’s create a visualization to demonstrate that advantage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Prepare the Data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The data for our visualization is readily available as timetables for the two
    routes. A more precise comparison might consider timetables from the same year,
    but for this example, we’ll use the Southerner’s timetable from 1941 (*[http://www.streamlinerschedules.com/concourse/track1/southerner194112.html](http://www.streamlinerschedules.com/concourse/track1/southerner194112.html)*)
    and the Silver Comet’s timetable from 1947 (*[http://www.streamlinerschedules.com/concourse/track1/silvercomet194706.html](http://www.streamlinerschedules.com/concourse/track1/silvercomet194706.html)*),
    as they are readily available on the Internet. The timetables only include station
    names, so we will have to look up latitude and longitude values (using, for example,
    Google Maps) for all of the stations in order to place them on a map. We can also
    calculate the time difference between stops, in minutes. Those calculations result
    in two arrays, one for each train.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 2: Set Up the Web Page and Libraries'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To add Leaflet maps to our web page, we’ll need to include the library and its
    companion style sheet. Both are available from a content distribution network,
    so there’s no need to host them on our own servers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When we create our page, we also define a `<div>` container for the map at ➊.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Draw the Base Map'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Silver Comet and the Southerner traveled between New York and Birmingham
    (and, in the case of the Southerner, all the way to New Orleans). But the region
    that’s relevant for our visualization lies between Washington, DC, and Atlanta,
    Georgia, because that’s the only region where the train routes differed; for the
    rest of their journeys, the routes were essentially the same. Our map, therefore,
    will extend from Atlanta in the southwest to Washington, DC, in the northeast.
    Using a bit of trial and error, we can determine the best center point and zoom
    level for the map. The center point defines the latitude and longitude for the
    map’s center, and the zoom level determines the area covered by the map on its
    initial display. When we create the map object, we give it the `id` of the containing
    element as well as those parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: For this particular visualization, there is little point in zooming or panning
    the map, so we can include additional options to disable those interactions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Setting both the minimum zoom level ➌ and the maximum zoom level ➍ to be equal
    to the initial zoom level disables zooming. We also disable the onscreen map controls
    for zooming at ➏. The other zoom controls are likewise disabled (➐ through ➑).
    For panning, we disable dragging the map at ➎ and keyboard arrow keys at ➒. We
    also specify the latitude/longitude bounds for the map (➊ and ➋).
  prefs: []
  type: TYPE_NORMAL
- en: Because we’ve disabled the user’s ability to pan or zoom the map, we should
    also make sure the mouse cursor doesn’t mislead the user when it’s hovering over
    the map. The *leaflet.css* style sheet expects zooming and panning to be enabled,
    so it sets the cursor to a “grabbing” hand icon. We can override that value with
    a style rule of our own. We have to define this rule *after* including the *leaflet.css*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As with the Modest Maps example, we base our map on a set of tiles. There are
    many tile providers that support Leaflet; some are open source, while others are
    commercial. Leaflet has a demo page (*[http://leaflet-extras.github.io/leaflet-providers/preview/](http://leaflet-extras.github.io/leaflet-providers/preview/)*)
    you can use to compare some of the open source tile providers. For our example,
    we want to avoid tiles with roads, as the highway network looked very different
    in the 1940s. Esri has a neutral WorldGrayCanvas set that works well for our visualization.
    It does include current county boundaries, and some counties may have changed
    their borders since the 1940s. For our example, we won’t worry about that detail,
    though you might consider it in any production visualization. Leaflet’s API lets
    us create the tile layer and add it to the map in a single statement. The Leaflet
    includes a built-in option to handle attribution so we can be sure to credit the
    tile source appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `maxZoom` option at ➊ indicates the maximum zoom layer available
    for that particular tile set. That value is independent of the zoom level we’re
    permitting for our map.
  prefs: []
  type: TYPE_NORMAL
- en: With a map and a base tile layer, we have a good starting point for our visualization
    in (see [Figure 6-11](ch06.html#base_layer_map_provides_the_canvas_for_a "Figure 6-11. A
    base layer map provides the canvas for a visualization.")).
  prefs: []
  type: TYPE_NORMAL
- en: '![A base layer map provides the canvas for a visualization.](figs/web/06fig11.png.jpg)Figure 6-11. A
    base layer map provides the canvas for a visualization.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Add the Routes to the Map'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the next step in our visualization, we want to show the two routes on our
    map. First, we’ll simply draw each route on the map. Then, we’ll add an animation
    that traces both routes at the same time to show which one is faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Leaflet library includes a function that does exactly what we need to draw
    each route: `polyline()` connects a series of lines defined by the latitude and
    longitude of their endpoints and prepares them for a map. Our data set includes
    the geographic coordinates of each route’s stops, so we can use the JavaScript
    `map()` method to format those values for Leaflet. For the Silver Comet example,
    the following statement extracts its stops.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This statement returns an array of latitude/longitude pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: That result is the perfect input to the `polyline()` function. We’ll use it
    for each of the routes. The options let us specify a color for the lines, which
    we’ll match with the associated railroad’s official color from the era. We also
    indicate that the lines have no function when clicked by setting the `clickable`
    option to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: With this addition, the visualization shown in [Figure 6-12](ch06.html#additional_map_layers_add_data_to_the_ca
    "Figure 6-12. Additional map layers add data to the canvas.") is starting to convey
    the relative distances of the two routes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Additional map layers add data to the canvas.](figs/web/06fig12.png.jpg)Figure 6-12. Additional
    map layers add data to the canvas.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Add an Animation Control'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll animate the two routes. Not only will this emphasize the competitive
    advantage of the shorter route, but it will also make the visualization more interesting
    and engaging. We’ll definitely want to let our users start and stop the animation,
    so our map will need a control button. The Leaflet library doesn’t have its own
    animation control, but the library does have a lot of support for customizations.
    Part of that support is a generic `Control` object. We can create an animation
    control by starting with that object and extending it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Next we define the options for our custom control. Those options include its
    position on the map, the text and tool tip (title) for its states, and functions
    to call when the animation starts or stops. We define these within an `options`
    object as follows, which lets Leaflet integrate them within its normal functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: For our example, we’re using UTF-8 characters for the play and pause control.
    In a production visualization, you might consider using icon fonts or images to
    have maximum control over the appearance.
  prefs: []
  type: TYPE_NORMAL
- en: Our animation control also needs an `onAdd()` method for Leaflet to call when
    it adds a control to a map. This method constructs the HTML markup for the control
    and returns that to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Our implementation of `onAdd()` constructs the markup in two stages. First,
    starting at ➊, it creates a `<div>` element and gives that element two classes:
    `leaflet-control-animate` and `leaflet-bar`. The first class is unique to our
    animation control, and we can use it to apply CSS rules uniquely to our control.
    The second class is a general Leaflet class for all toolbars. By adding it to
    the animation control, we’re making that control consistent with other Leaflet
    controls. Note that Leaflet includes the `L.DomUtil.create()` method at ➊ to handle
    the details of creating the element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `onAdd()` creates a button element within this `<div>` container.
    Most of the work takes place in the `_createButton()` function at ➋, which we’ll
    examine shortly. The parameters to the function include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The text for the button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tool tip (title) to display when the mouse hovers over the button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CSS class to apply to the button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The container in which to insert the button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function to call when the button is clicked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re wondering why the name of this function begins with an underscore
    (_), that’s the convention that Leaflet uses for private methods (and attributes).
    There’s no requirement to follow it, but doing so will make it easier for someone
    familiar with Leaflet to understand our code.
  prefs: []
  type: TYPE_NORMAL
- en: The `_createButton()` method itself relies on Leaflet utility functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: First it creates the button as an `<a>` element with the specified text, title,
    and class, and it creates that element within the appropriate container (➊ through
    ➋). It then binds several events to this `<a>` element. First it ignores initial
    `mousedown` and double-click events at ➌. It also prevents single-click events
    from propagating up the document tree and from implementing their default behavior
    at ➍. Finally, it executes the callback function on `click` events at ➎.
  prefs: []
  type: TYPE_NORMAL
- en: The callback function itself is our next task.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we get into the function, we add a single state variable (`_running`)
    to keep track of whether the animation is currently running. It starts out stopped
    at ➊. Then our callback function starts by checking this variable at ➋. If `_running`
    is `true`, that means the animation was running and has just been paused by the
    current click, so it changes the control to indicate that clicking will now resume
    the animation. If the animation isn’t running, the callback function does the
    opposite: it changes the control to indicate that a subsequent click will pause
    it. In both cases, the callback function executes the appropriate control function
    if one exists. Finally, it sets the state of `_running` to its complement.'
  prefs: []
  type: TYPE_NORMAL
- en: The last part of our custom control adds a `reset()` method to clear the animation.
    This function sets the control back to its initial state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: To completely integrate our custom control into the Leaflet architecture, we
    add a function to the `L.control` object. Following the Leaflet convention, this
    function’s name begins with a lowercase letter but is otherwise identical to the
    name of our control.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Defining this last function lets us create the control using a common Leaflet
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This is the same syntax we’ve seen before with layers and polylines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 6: Prepare the Animation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With a convenient user control in place, we can now begin work on the animation
    itself. Although this particular animation isn’t especially taxing, we can still
    follow best practices and compute as much as possible in advance. Since we’re
    animating two routes, we’ll define a function that will build an animation for
    any input route. A second parameter will specify polyline options. This function
    will return an array of polyline paths, indexed by minutes. You can see the basic
    structure of this function next.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The first element in the array will be the polyline for the first minute of
    the route. We’ll build the entire array in the `animation` variable.
  prefs: []
  type: TYPE_NORMAL
- en: To build the paths, we iterate through the stops on the route.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We want to keep track of all the stops we’ve already passed, so we define the
    `prevStops` array and initialize it as empty at ➊. Each iteration calculates the
    animation steps for the current stop up to the next stop. There’s no need to go
    beyond the final stop on the route, so we terminate the loop at the next-to-last
    stop (`stopIdx < route.length-1;`).
  prefs: []
  type: TYPE_NORMAL
- en: As we start to calculate the paths beginning at the current stop, we’ll store
    that stop and the next one in local variables, and we’ll add the current stop
    to the `prevStops` array that’s keeping track of previous stops.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: For each stop in our data sets, the `duration` property stores the number of
    minutes until the next stop. We’ll use an inner loop, shown next, to count from
    `1` up to that value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Within the loop, we use a simple linear interpolation to calculate the position
    at the corresponding time. That position, when appended to the `prevStops` array,
    is the polyline path for that time. This code creates a polyline based on the
    path and adds it to the animation array.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the array `concat()` method, we embed the position array within
    another array object. That keeps `concat()` from flattening the position array
    before appending it. You can see the difference in the following examples. It’s
    the latter outcome that we want.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 7: Animate the Routes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now it’s finally time to execute the animation. To initialize it, we create
    an array to hold the two routes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Next we calculate the maximum number of animation steps. That’s the minimum
    of the length of the two animation arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'That statement might seem overly complex for finding the minimum length, but
    it works with an arbitrary number of routes. If, in the future, we decided to
    animate a third route on our map, we wouldn’t have to change the code. The best
    way to understand the statement is to start in the middle and work outward. The
    following fragment converts the array of route animations into an array of lengths,
    specifically `[870,775]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: To find the minimum value in an array, we can use the `Math.min()` function,
    except that function expects its parameters as a comma-separated list of arguments
    rather than an array. The `apply()` method (which is available for any JavaScript
    function) converts an array into a comma-separated list. Its first parameter is
    a context for the function, which in our case is irrelevant, so we pass `null`
    for that parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The animation keeps track of its current state with the `step` variable, which
    we initialize to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `animateStep()` function processes each step in the animation. There are
    four parts to this function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: First we check to see whether this is the very first step in the animation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: If it isn’t, `step` will be greater than zero and we can remove the previous
    step’s polylines from the map at ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Next we check to see if we’re already at the end of the animation. If so, then
    we restart the animation back at step 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: For the third part, we add the current step’s polylines to the map.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we return `true` if we’ve reached the end of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We’ll execute this step function repeatedly in a JavaScript interval, shown
    next.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We use a variable to keep a reference to that interval and add functions to
    start and stop it. In the `animate()` function, we check the return value from
    `animateStep()` at ➊. When it returns `true`, the animation is complete, so we
    clear the interval and reset our control. (We’ll see where that control is defined
    shortly.) The `pause()` function at ➋ stops the interval.
  prefs: []
  type: TYPE_NORMAL
- en: Now all we need to do is define the animation control using the object we created
    in Step 5.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Once we add it to the map, the user will be able to activate the animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 8: Create Labels for the Stops'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we wrap up the animation, we’ll add some labels for each train stop.
    To emphasize the passage of time, we’ll reveal each label as the animation reaches
    the corresponding stop. To do that, we’ll create the labels using a special object;
    then we’ll create a method to add labels to the map; and, to finish the label
    object, we’ll add methods that get or set a label’s status.
  prefs: []
  type: TYPE_NORMAL
- en: Since Leaflet doesn’t have a predefined object for labels, we can once again
    create our own custom object. We start with the basic Leaflet `Class`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Our `Label` object accepts parameters for its position on the map, its label
    text, and any options. Next, we extend the `initialize()` method of the Leaflet
    `Class` to handle those parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: For position and text, we simply save their values for later use. For the options,
    we use a Leaflet utility at ➊ to easily support default values. The object includes
    one variable to keep track of its status. Initially all labels are hidden, so
    `this._status` is initialized appropriately at ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Next we define the default option values with the `options` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The only option we need for our label is an offset for the standard position.
    By default, that offset will be `0` in both the x- and y-coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: This `options` attribute, combined with the call to `L.Util.setOptions` in the
    `initialize` method, establishes a default value (`0,0`) for the offset that can
    be easily overridden when a `Label` object is created.
  prefs: []
  type: TYPE_NORMAL
- en: Next we write the method that adds a label to a map.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This method does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a new `<div>` element with the CSS class `leaflet-label` at ➊
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets the `line-height` of that element to `0` to work around a quirk in the
    way Leaflet calculates position at ➋
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets the `opacity` of the element to `0` to match its initial `hidden` status
    at ➌
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adds the new element to the `markerPane` layer in the map at ➍
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets the contents of the element to the label text at ➎
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculates a position for the label using its defined latitude/longitude at
    ➏ and then adjusts for any offset (➐ through ➑)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Positions the element on the map at ➒
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Step 2—setting the `line-height` to `0`—addresses a problem in the method
    Leaflet uses to position elements on the map. In particular, Leaflet does not
    account for other elements in the same parent container. By setting all elements
    to have no line height, we nullify this effect so that the calculated position
    is correct.**'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we add methods to get and set the label’s status. As the following
    code indicates, our labels can have three different status values, and those values
    determine the opacity of the label.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We included the option to adjust the label’s position because not all labels
    will look good positioned exactly on the latitude and longitude of the station.
    Most will benefit from slight shifts to avoid interference with the route polylines,
    text on the base map tiles, or other labels. For a custom visualization such as
    this example, there’s no substitute for trial-and-error adjustments. We’ll capture
    those adjustments for each label by adding another `offset` field to our data
    set. The augmented data set might begin like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 9: Build the Label Animation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create the label animation, we can once again iterate through the trains’
    routes. Because we have more than one route, a general-purpose function will let
    us avoid duplicating code. As you can see from the following code, we’re not using
    a fixed number of arguments to our function. Instead, we let the caller pass in
    as many individual routes as desired. All of those input parameters will be stored
    in the `arguments` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `arguments` object looks a lot like a JavaScript array. It has a `length`
    property, and we can access individual elements using, for example, `arguments[0]`.
    Unfortunately, the object isn’t a true array, so we can’t use the convenient array
    methods (such as `forEach`) on it. As a workaround, the very first statement in
    our `buildLabelAnimation()` function, shown next, relies on a simple trick to
    convert the `arguments` object into the true `args` array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: It’s a bit long winded, but the statement at ➊ effectively executes the `slice()`
    method on `arguments`. That operation clones `arguments` into a true array.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**This same trick works for nearly all of JavaScript’s “array-like” objects.
    You can often use it to convert them into true arrays.**'
  prefs: []
  type: TYPE_NORMAL
- en: With the routes converted into an array, we can use `forEach` to iterate through
    all of them, regardless of their number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: As we begin processing each route, we set the `minutes` value to `0`. Then we
    can use `forEach` again to iterate through all the stops on the route.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: For each stop in the route, we first check to see whether that stop is the first
    or last one. If so, we don’t want to animate a label for that stop. Otherwise,
    we create a new `Label` object at ➊ and add it to the map. Then we append that
    `Label` object to the `labels` array that’s accumulating the label animation data.
    Notice that we add each label to this array twice. The first time we add it (➋)
    is at the time the animation reaches the stop; in this case, we add it with a
    status of `shown`. We also add the label to the array 50 minutes later (➌), this
    time with a status of `dimmed`. When we execute the animation, it will show the
    label when the route first reaches the station and then dim it a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve iterated through all the routes, our `labels` array will indicate
    when each label should change status. At this point, though, the labels aren’t
    listed in the order of their animation state changes. To fix that, we sort the
    array in order of increasing time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: To use our new function, we call and pass in all the routes to animate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Because we’re not animating the start (Washington, DC) or end (Atlanta) of any
    routes, we can go ahead and display those on the map from the start. We can get
    the coordinates from any route; the following example uses the `seaboard` data
    set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 10: Incorporate Label Animation in the Animation Step'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that the label animation data is available, we can make some adjustments
    to our animation function to incorporate the labels as well as the polyline paths.
    The first change is deciding when to conclude the animation. Because we’re dimming
    the labels some time after the route passes their stops, we can’t simply stop
    when all the paths are drawn. That might leave some labels undimmed. We’ll need
    separate variables to store the number of steps for each animation, and the total
    number of animation steps will be whichever is greater.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: We also need a copy of the label animation data that we can destroy during the
    animation, while keeping the original data intact. We don’t want to destroy the
    original so that users can replay the animation if they wish. The easiest way
    to copy a JavaScript array is by calling its `slice(0)` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**We can’t simply copy the array using an assignment statement (`var labelAnimation
    = labels`). In JavaScript this statement would simply set `labelAnimation` to
    reference the same actual array as labels. Any changes made to the first would
    also affect the latter.**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The animation step function itself needs some additional code to handle labels.
    It will now have five major parts; we’ll walk through each of them in the code
    that follows. Our first adjustment is to make sure the code removes previous polyline
    paths only as long as we’re still adding paths to the map. That’s true only when
    `step` is less than `maxPathSteps`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The next block handles the case in which the user replays the animation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: When the animation replays, the `step` value will still be set to `maxSteps`
    from the prior animation. To reset the animation, we remove the last polyline
    paths for each route (➊ through ➋), make a new copy of the label animation data
    (➌), and hide all the labels (➍ through ➎). We also reset the `step` variable
    to `0` (➏).
  prefs: []
  type: TYPE_NORMAL
- en: The third block is a completely new block that animates the labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This block looks at the first element in the `labelAnimation` array, if one
    exists. If the time value for that element (its `minutes` property) is the same
    as the animation step, we check to see if we need to process it. We always process
    label animations when we’re still adding the paths. If the paths are complete,
    though, we process animations only for labels that are already shown. Once we’re
    finished with the first element in `labelAnimation`, we remove it from the array
    (using the `shift()` method) and check again. We must keep checking in case multiple
    label animation actions are scheduled at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code explains a couple of things about our label animation preparation.
    First, because we sorted the label animation, we only need to look at the first
    element in that array. That’s much more efficient than searching through the entire
    array. Secondly, because we’re working with a copy of the label animation array
    instead of the original, it’s safe to remove elements once we finish processing
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve handled all the label animations, we can return to the polyline
    paths. As long as there are still paths to animate, we add them to the map as
    before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The final code block in our animation step function is the same as before. We
    return an indication of whether the animation is complete.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: There’s one more improvement we can make to the animation, in this case with
    a judicious bit of CSS. Because we use the `opacity` property to change the status
    of the labels, we can define a CSS transition for that property that will make
    any changes less abrupt.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: To accommodate all popular browsers, we use appropriate vendor prefixes, but
    the effect of the rule is consistent. Whenever the browser changes the opacity
    of elements within a `leaflet-label` class, it will ease the transition in and
    out over a 500-millisecond period. This transition prevents the label animations
    from distracting users too much from the path animation that is the visualization’s
    main effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 11: Add a Title'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To complete the visualization, all we need is a title and a bit of explanation.
    We can build the title as a Leaflet control, much as we did for the animation
    control. The code to do this is quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: We provide a default position in the top left of the map (➊) and accept a title
    string as an initialization parameter (➋). At ➌, we make it so that title string
    becomes the `innerHTML` of the control when we add it to the map.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can use the following code to create a title object with our desired
    content and immediately add it to the map. Here’s a simple implementation; [Figure 6-13](ch06.html#maps_built_in_the_browser_with_a_map_lib
    "Figure 6-13. Maps built in the browser with a map library can use interactivity
    to build interest.") includes some extra information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: To set the title’s appearance, we can define CSS rules for children of the `leaflet-control-title`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have the interactive visualization of the two train routes
    in [Figure 6-13](ch06.html#maps_built_in_the_browser_with_a_map_lib "Figure 6-13. Maps
    built in the browser with a map library can use interactivity to build interest.").
    Users can clearly see that the Southerner has a quicker route from Washington
    to Atlanta.
  prefs: []
  type: TYPE_NORMAL
- en: '![Maps built in the browser with a map library can use interactivity to build
    interest.](figs/web/06fig13.png.jpg)Figure 6-13. Maps built in the browser with
    a map library can use interactivity to build interest.'
  prefs: []
  type: TYPE_NORMAL
- en: Summing Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’ve looked at several visualizations based on maps. In the
    first two examples, geographic regions were the main subjects of the visualization,
    and we built choropleth maps to compare and contrast those regions. Map fonts
    are quick and convenient, but only if they’re available for the regions the visualization
    needs. Although it usually takes more effort, we have far more control over the
    map regions if we use SVGs to create our own custom maps. Unlike other image formats,
    SVG can be easily manipulated in a web page with just CSS and JavaScript. This
    chapter also looked at examples based on traditional mapping libraries. Mapping
    libraries are especially convenient when your data sets include latitude and longitude
    values, as the libraries take care of the complicated mathematics required to
    position those points on a two-dimensional projection. As we saw, some libraries
    are relatively simple yet perfectly capable of mapping a data set. Full-featured
    libraries such as Leaflet offer much more power and customization, and we relied
    on that extensibility for a custom, animated map.
  prefs: []
  type: TYPE_NORMAL
