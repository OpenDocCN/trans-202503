- en: Chapter 6. Visualizing Geographic Data
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 6 章：地理数据可视化
- en: 'Humans crave context when evaluating data, so it’s important to provide that
    context when it’s available. In the previous chapter, we saw how timelines can
    provide one frame of reference; now we’ll examine another equally important context:
    place. If a data set includes geographic coordinates or has values that correspond
    to different geographic regions, you can provide geographic context using a map-based
    visualization. The examples in this chapter consider two types of map-based visualizations.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 人类在评估数据时渴望获得上下文，因此在上下文可用时提供它是非常重要的。在上一章中，我们看到时间轴可以提供一个参考框架；现在我们将研究另一个同样重要的上下文：地点。如果数据集包含地理坐标或具有与不同地理区域相对应的值，您可以使用基于地图的可视化提供地理上下文。本章中的示例考虑了两种类型的基于地图的可视化。
- en: In the first two examples, we want to show how data varies by region. The resulting
    visualizations, known as choropleth maps, use color to highlight different characteristics
    of the different regions. For the next two examples, the visualization data doesn’t
    itself vary by region directly, but the data does have a geographic component.
    By showing the data on a map, we can help our users understand it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个示例中，我们希望展示数据如何按区域变化。结果的可视化称为分级图（choropleth maps），通过颜色来突出显示不同区域的不同特征。对于接下来的两个示例，虽然可视化数据本身并不会直接按区域变化，但数据确实有地理成分。通过将数据展示在地图上，我们可以帮助用户理解它。
- en: 'More specifically, we’ll see the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地，我们将看到以下内容：
- en: How to use special map fonts to create maps with minimal JavaScript
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用特殊的地图字体通过最少的JavaScript创建地图
- en: How to manipulate Scalable Vector Graphic (SVG) image maps with JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用JavaScript操作可缩放矢量图（SVG）地图
- en: How to use a simple mapping library to add maps to web pages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用简单的映射库将地图添加到网页中
- en: How to integrate a full-featured map library into a visualization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将功能全面的地图库集成到可视化中
- en: Using Map Fonts
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用地图字体
- en: One technique for adding maps to web pages is surprisingly simple but often
    overlooked—map fonts. Two examples of these fonts are Stately (*[http://intridea.github.io/stately/](http://intridea.github.io/stately/)*)
    for the United States and Continental (*[http://contfont.net/](http://contfont.net/)*)
    for Europe. Map fonts are special-purpose web fonts whose character sets contain
    map symbols instead of letters and numbers. In just a few easy steps, we’ll create
    a visualization of Europe using the symbols from Continental.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将地图添加到网页中的一种技巧出乎意料地简单，但常常被忽视——地图字体。这些字体的两个示例是Stately（*[http://intridea.github.io/stately/](http://intridea.github.io/stately/)）*用于美国和Continental（*[http://contfont.net/](http://contfont.net/)*）用于欧洲。地图字体是特殊用途的网页字体，它们的字符集包含地图符号，而不是字母和数字。通过几个简单的步骤，我们将使用Continental中的符号创建欧洲的可视化。
- en: 'Step 1: Include the Fonts in the Page'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 1：在页面中包含字体
- en: The main websites for both Stately and Continental include more detailed instructions
    for installing the fonts, but all that’s really necessary is including a single
    CSS style sheet. In the case of Continental, that style sheet is called, naturally,
    *continental.css*. No JavaScript libraries are required.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Stately和Continental的官方网站提供了更详细的字体安装说明，但实际上，只需要包含一个CSS样式表。对于Continental，这个样式表自然叫做*continental.css*。不需要任何JavaScript库。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**For a production website, you might want to combine** *continental.css* **with
    your site’s other style sheets to minimize the number of network requests the
    browser has to make.**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于生产环境的网站，你可能希望将** *continental.css* **与网站的其他样式表结合使用，以减少浏览器需要发出的网络请求数量。**'
- en: 'Step 2: Display One Country'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 2：显示一个国家
- en: To show a single country, all we have to do is include an HTML `<span>` element
    with the appropriate attributes. We can do this right in the markup, adding a
    class attribute set to `map-` followed by a two-letter country abbreviation. (*fr*
    is the international two-letter abbreviation for France.)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示一个单一的国家，我们只需在HTML中包含一个`<span>`元素，并设置相应的属性即可。我们可以直接在标记中完成这项操作，添加一个类属性，值为`map-`，后跟两个字母的国家缩写。（*fr*
    是法国的国际两字母缩写。）
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For this example, we’ll use JavaScript to generate the markup.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将使用JavaScript生成标记。
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we’ve created a new `<span>` element, giving it a class name of `"map-fr"`,
    and appending it to the map `<div>`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新的`<span>`元素，给它赋予了类名`"map-fr"`，并将其添加到地图`<div>`中。
- en: One last bit of housekeeping is setting the size of the font. By default, any
    map font character will be the same size as a regular text character. For maps
    we want something much larger, so we can use standard CSS rules to increase the
    size.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个整理步骤是设置字体大小。默认情况下，任何地图字体字符的大小与普通文本字符相同。对于地图，我们希望字体更大一些，因此可以使用标准CSS规则来增大字体大小。
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That’s all it takes to add France to a web page, as you can see in [Figure 6-1](ch06.html#map_fonts_make_it_very_easy_to_add_a_map
    "Figure 6-1. Map fonts make it very easy to add a map to a web page.").
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，添加法国到网页上所需要的全部操作，正如在[图6-1](ch06.html#map_fonts_make_it_very_easy_to_add_a_map
    "图6-1. 地图字体使得将地图添加到网页变得非常容易。")中所示。
- en: '![Map fonts make it very easy to add a map to a web page.](figs/web/06fig01.png.jpg)Figure 6-1. Map
    fonts make it very easy to add a map to a web page.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![地图字体使得将地图添加到网页变得非常容易。](figs/web/06fig01.png.jpg)图6-1. 地图字体使得将地图添加到网页变得非常容易。'
- en: 'Step 3: Combine Multiple Countries into a Single Map'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步：将多个国家合并到一个地图中
- en: For this example we want to show more than a single country. We’d like to visualize
    the median age for all of Europe’s countries, based on United Nations population
    data (*[http://www.un.org/en/development/desa/population/](http://www.un.org/en/development/desa/population/)*)
    from 2010\. To do that, we’ll create a map that includes all European countries,
    and we’ll style each country according to the data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们希望展示不仅仅是一个国家。我们想要基于联合国人口数据（* [http://www.un.org/en/development/desa/population/](http://www.un.org/en/development/desa/population/)
    *）2010年的数据，展示所有欧洲国家的中位年龄。为此，我们将创建一个包含所有欧洲国家的地图，并根据数据对每个国家进行样式设置。
- en: The first step in this visualization is putting all of the countries into a
    single map. Since each country is a separate character in the Continental font,
    we want to overlay those characters on top of one another rather than spread them
    across the page. That requires setting a couple of CSS rules.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可视化的第一步是将所有国家放入一个单一的地图中。由于每个国家都是大陆字体中的一个独立字符，我们希望将这些字符叠加在一起，而不是将它们分布到整个页面。这需要设置一些CSS规则。
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First we set the position of the outer container to `relative` ➊. This rule
    doesn’t change the styling of the outer container at all, but it does establish
    a *positioning context* for anything within the container. Those elements will
    be our individual country symbols, and we set their position to be `absolute`
    ➋. We then place each one at the top and left ➌, respectively, of the map so they’ll
    overlay one another. Because we’ve positioned the container `relative`, the country
    symbols will be positioned relative to that container rather than to the page
    as a whole.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将外部容器的定位设置为`relative` ➊。此规则不会改变外部容器的样式，但它确立了一个*定位上下文*，供容器内的任何元素使用。这些元素将是我们的单个国家符号，我们将它们的定位设置为`absolute`
    ➋。接着，我们分别将每个国家符号定位到地图的顶部和左侧 ➌，使它们重叠在一起。由于我们已将容器定位为`relative`，因此这些国家符号将相对于该容器进行定位，而不是相对于整个页面。
- en: Note that we’ve used a couple of CSS tricks to apply this positioning to all
    of the individual symbols within this element. We start by selecting the element
    with an `id` of `map`. Nothing fancy there. The direct descendent selector (`>`),
    however, says that what follows should match only elements that are immediate
    children of that element, not arbitrary descendants. Finally, the attribute selector
    `[class*="map-"]` specifies only children that have a class containing the characters
    `map-`. Since all the country symbols will be `<span>` elements with a class of
    `map-`*`xx`* (where *`xx`* is the two-letter country abbreviation), this will
    match all of our countries.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了一些CSS技巧，将这些定位应用到该元素中的所有单个符号上。我们首先通过选择`id`为`map`的元素来开始。这里没有什么特别的。直接子代选择器（`>`）则表示后面的内容应该匹配该元素的直接子元素，而不是任意后代元素。最后，属性选择器`[class*="map-"]`仅指定具有包含`map-`字符的类的子元素。由于所有的国家符号将是具有类`map-`*`xx`*（其中*`xx`*是两位字母的国家缩写）的`<span>`元素，这将匹配我们所有的国家。
- en: In our JavaScript, we can start with an array listing all of the countries and
    iterate through it. For each country, we create a `<span>` element with the appropriate
    class and insert it in the map `<div>`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的JavaScript中，我们可以从一个列出所有国家的数组开始，并遍历它。对于每个国家，我们创建一个带有相应类的`<span>`元素，并将其插入到地图的`<div>`中。
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With these style rules defined, inserting multiple `<span>` elements within
    our map `<div>` creates the complete, if somewhat uninteresting, map of Europe
    shown in [Figure 6-2](ch06.html#overlaying_map_characters_on_top_of_one "Figure 6-2. Overlaying
    map characters on top of one another creates a complete map.").
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义这些样式规则，我们可以在地图的`<div>`中插入多个`<span>`元素，创建出[图6-2](ch06.html#overlaying_map_characters_on_top_of_one
    "图6-2. 将地图字符叠加在一起可以创建一个完整的地图")所示的欧洲地图，虽然它有些平淡，但已经是一个完整的地图。
- en: '![Overlaying map characters on top of one another creates a complete map.](figs/web/06fig02.png.jpg)Figure 6-2. Overlaying
    map characters on top of one another creates a complete map.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![将地图字符叠加在一起可以创建一个完整的地图。](figs/web/06fig02.png.jpg)图6-2. 将地图字符叠加在一起可以创建一个完整的地图。'
- en: 'Step 4: Vary the Countries Based on the Data'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步：根据数据变化国家符号
- en: Now we’re ready to create the actual data visualization. Naturally, we’ll start
    with the data, in this case from the United Nations. Here’s how we could format
    that data in a JavaScript array. (The full data set can be found with the book’s
    source code at *[http://jsDataV.is/source/](http://jsDataV.is/source/)*.)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建实际的数据可视化了。自然，我们将从数据开始，在这种情况下是来自联合国的数据。以下是我们如何将这些数据格式化为一个JavaScript数组。（完整的数据集可以在本书的源代码中找到，地址是
    *[http://jsDataV.is/source/](http://jsDataV.is/source/)*。）
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are several ways we could use this data to modify the map. We could use
    JavaScript code to set the visualization properties directly by, for example,
    changing the `color` style for each country symbol. That would work, but it forgoes
    one of the big advantages of map fonts. With map fonts, our visualization is standard
    HTML, so we can use standard CSS to style it. If, in the future, we want to change
    the styles on the page, they’ll all be contained within the style sheets, and
    we won’t have to hunt through our JavaScript code to adjust colors.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式使用这些数据来修改地图。例如，我们可以通过JavaScript代码直接设置可视化属性，例如更改每个国家符号的`color`样式。这样是可行的，但它忽略了地图字体的一大优势。使用地图字体时，我们的可视化是标准的HTML，因此我们可以使用标准的CSS来进行样式设置。如果将来我们想要更改页面上的样式，它们将全部包含在样式表中，而我们无需在JavaScript代码中查找并调整颜色。
- en: To indicate which styles are appropriate for an individual country symbol, we
    can attach a `data-` attribute to each.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指示哪些样式适用于某个国家的符号，我们可以为每个符号附加一个`data-`属性。
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this code, we set the `data-age` attribute to the mean age, rounded to the
    nearest whole number ➋. To find the age for a given country, we need that country’s
    index in the `ages` array. The `findCountryIndex()` function ➊ does that in a
    straightforward way.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们将`data-age`属性设置为平均年龄，四舍五入到最接近的整数➋。为了找出某个国家的年龄，我们需要该国在`ages`数组中的索引。`findCountryIndex()`函数➊可以以直接的方式完成这一操作。
- en: Now we can assign CSS style rules based on that `data-age` attribute. Here’s
    the start of a simple blue gradient for the different ages, where greater median
    ages are colored darker blue-green.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以根据`data-age`属性来分配CSS样式规则。这是为不同年龄段创建简单蓝色渐变的开始，其中较大中位数年龄的颜色为较深的蓝绿色。
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Although they’re beyond the scope of this book, CSS preprocessors such as
    LESS (***[http://lesscss.org/](http://lesscss.org/)***) and SASS (***[http://sass-lang.com/](http://sass-lang.com/)***)
    make it easy to create these kinds of rules.**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**尽管这些内容超出了本书的范围，但CSS预处理器如LESS（***[http://lesscss.org/](http://lesscss.org/)***）和SASS（***[http://sass-lang.com/](http://sass-lang.com/)***）使得创建这些规则变得更加简单。**'
- en: Now we have the nice visualization of the age trends shown in [Figure 6-3](ch06.html#with_css_rulescomma_we_can_change_the_st
    "Figure 6-3. With CSS rules, we can change the styles of individual map symbols.").
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到[图6-3](ch06.html#with_css_rulescomma_we_can_change_the_st "图6-3. 通过CSS规则，我们可以更改单个地图符号的样式")中展示的年龄趋势的良好可视化效果。
- en: '![With CSS rules, we can change the styles of individual map symbols.](figs/web/06fig03.png.jpg)Figure 6-3. With
    CSS rules, we can change the styles of individual map symbols.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![通过CSS规则，我们可以更改单个地图符号的样式。](figs/web/06fig03.png.jpg)图6-3. 通过CSS规则，我们可以更改单个地图符号的样式。'
- en: 'Step 5: Add a Legend'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步：添加图例
- en: 'To finish off the visualization, we can add a legend to the map. Because the
    map itself is nothing more than standard HTML elements with CSS styling, it’s
    easy to create a matching legend. This example covers a fairly broad range (ages
    28 to 44), so a linear gradient works well as a key. Your own implementation will
    depend on the specific browser versions that you wish to support, but a generic
    style rule would be as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成可视化，我们可以在地图上添加图例。因为地图本身只是标准的HTML元素，并且使用了CSS样式，所以创建匹配的图例非常简单。这个示例涵盖了一个相对广泛的范围（28到44岁），因此线性渐变作为关键图例效果很好。你自己的实现将取决于你希望支持的具体浏览器版本，但通用的样式规则如下：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The resulting visualization in [Figure 6-4](ch06.html#standard_html_can_also_provide_a_legend
    "Figure 6-4. Standard HTML can also provide a legend for the visualization.")
    summarizes the median age for European countries in a clear and concise format.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 6-4](ch06.html#standard_html_can_also_provide_a_legend "图 6-4. 标准HTML也可以为可视化提供图例。")中，结果的可视化清晰简洁地总结了欧洲国家的中位年龄。
- en: '![Standard HTML can also provide a legend for the visualization.](figs/web/06fig04.png.jpg)Figure 6-4. Standard
    HTML can also provide a legend for the visualization.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![标准HTML也可以为可视化提供图例。](figs/web/06fig04.png.jpg)图 6-4. 标准HTML也可以为可视化提供图例。'
- en: Working with Scalable Vector Graphics
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可缩放矢量图形
- en: Map fonts like those in the previous example are easy to use and visually effective,
    but only a few map fonts exist, and they definitely don’t cover all the conceivable
    geographic regions. For visualizations of other regions, we’ll have to find a
    different technique. Maps, of course, are ultimately images, and web browsers
    can display many different image formats. One format in particular, called *Scalable
    Vector Graphics (SVG)*, is especially well suited for interactive visualizations.
    That’s because, as we’ll see in this example, JavaScript code (as well as CSS
    styles) can easily and naturally interact with SVG images.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 像前一个示例中的地图字体易于使用且视觉效果显著，但只有少数几种地图字体可用，且它们显然无法涵盖所有可想象的地理区域。对于其他区域的可视化，我们需要找到不同的技术。地图，当然，最终是图像，网页浏览器可以显示多种不同的图像格式。特别是，有一种格式叫做*可缩放矢量图形（SVG）*，特别适合交互式可视化。正如我们将在这个示例中看到的，JavaScript代码（以及CSS样式）可以轻松自然地与SVG图像进行交互。
- en: Although our example for this section deals with a map, the techniques here
    are by no means limited to maps. Whenever you have a diagram or illustration in
    SVG format, you can manipulate it directly on a web page.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本节的示例处理的是地图，但这里的技巧并不限于地图。每当你有一个SVG格式的图表或插图时，你都可以直接在网页上操作它。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**There is one important consideration for using SVG: only modern web browsers
    support it. more specifically, IE8 (and earlier) cannot display SVG images. If
    a significant number of your users are using older browsers, you might want to
    consider alternatives.**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用SVG时有一个重要的考虑因素：只有现代的网页浏览器支持它。更具体来说，IE8（及更早版本）无法显示SVG图像。如果你的网站用户中有大量使用旧版浏览器的用户，你可能需要考虑其他替代方案。**'
- en: For web developers, SVG is especially convenient because its syntax uses the
    same structure as HTML. You can use many of the same tools and techniques for
    working with HTML on SVG as well. Consider, for example, a skeletal HTML document.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网页开发者来说，SVG特别方便，因为它的语法使用与HTML相同的结构。你可以使用许多与HTML相同的工具和技巧来处理SVG。例如，考虑一个基本的HTML文档。
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Compare that to the next example: the universal symbol for first aid represented
    in an SVG document.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与下一个示例进行对比：在SVG文档中表示的急救通用符号。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**If you have worked with htmL before htmL5, the similarities might be especially
    striking, as the SVG header text follows the same format as htmL4.**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你曾经使用过HTML5之前的HTML，可能会特别注意到它们的相似性，因为SVG的头部文本与HTML4遵循相同的格式。**'
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can even style the SVG elements using CSS. Here’s how we could color the
    preceding image:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用CSS对SVG元素进行样式设置。下面是我们如何给前面的图像上色：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Figure 6-5](ch06.html#svg_images_may_be_embedded_directly_with "Figure 6-5. SVG
    images may be embedded directly within web pages.") shows how that SVG renders.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](ch06.html#svg_images_may_be_embedded_directly_with "图 6-5. SVG 图像可以直接嵌入到网页中。")展示了SVG如何渲染。'
- en: '![SVG images may be embedded directly within web pages.](figs/web/06fig05.png.jpg)Figure 6-5. SVG
    images may be embedded directly within web pages.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![SVG图像可以直接嵌入到网页中。](figs/web/06fig05.png.jpg)图 6-5. SVG图像可以直接嵌入到网页中。'
- en: The affinity between HTML and SVG is, in fact, far stronger than the similar
    syntax. With modern browsers, you can mix SVG and HTML in the same web page. To
    see how that works, let’s visualize health data for the 159 counties in the US
    state of Georgia. The data comes from County Health Rankings (*[http://www.countyhealthrankings.org/](http://www.countyhealthrankings.org/)*).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: HTML与SVG之间的关联实际上远比类似的语法要强。在现代浏览器中，你可以在同一网页中混合使用SVG和HTML。为了演示如何实现这一点，让我们为美国乔治亚州的159个县可视化健康数据。数据来自县健康排名（*[http://www.countyhealthrankings.org/](http://www.countyhealthrankings.org/)*）。
- en: 'Step 1: Create the SVG Map'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤1：创建SVG地图
- en: Our visualization starts with a map, so we’ll need an illustration of Georgia’s
    counties in SVG format. Although that might seem like a challenge, there are actually
    many sources for SVG maps that are free to use, as well as special-purpose applications
    that can generate SVG maps for almost any region. The Wikimedia Commons (*[http://commons.wikimedia.org/wiki/Main_Page](http://commons.wikimedia.org/wiki/Main_Page)*),
    for example, contains a large number of open source maps, including many of Georgia.
    We’ll use one showing data from the National Register of Historic Places (*[http://commons.wikimedia.org/wiki/File:NRHP_Georgia_Map.svg#file](http://commons.wikimedia.org/wiki/File:NRHP_Georgia_Map.svg#file)*).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的可视化从地图开始，因此我们需要一张乔治亚州县的SVG格式插图。尽管这看起来可能是一个挑战，但实际上有许多免费的SVG地图来源，以及可以为几乎任何区域生成SVG地图的专用应用程序。例如，维基共享资源（*[http://commons.wikimedia.org/wiki/Main_Page](http://commons.wikimedia.org/wiki/Main_Page)）包含了大量的开源地图，其中包括许多乔治亚州的地图。我们将使用一张显示历史遗址名录数据的地图（*[http://commons.wikimedia.org/wiki/File:NRHP_Georgia_Map.svg#file](http://commons.wikimedia.org/wiki/File:NRHP_Georgia_Map.svg#file)）。
- en: After downloading the map file, we can adjust it to better fit our needs, removing
    the legend, colors, and other elements that we don’t need. Although you can do
    this in a text editor (just as you can edit HTML), you may find it easier to use
    a graphics program such as Adobe Illustrator or a more web-focused app like Sketch
    (*[http://www.bohemiancoding.com/sketch/](http://www.bohemiancoding.com/sketch/)*).
    You might also want to take advantage of an SVG optimization website (*[http://petercollingridge.appspot.com/svg-optimiser/](http://petercollingridge.appspot.com/svg-optimiser/)*)
    or application (*[https://github.com/svg/](https://github.com/svg/)*), which can
    compress an SVG by removing extraneous tags and reducing the sometimes-excessive
    precision of graphics programs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下载地图文件后，我们可以根据需要进行调整，移除图例、颜色和其他不需要的元素。虽然你可以在文本编辑器中完成这项工作（就像编辑HTML一样），但你可能会发现使用像Adobe
    Illustrator这样的图形程序，或者像Sketch（*[http://www.bohemiancoding.com/sketch/](http://www.bohemiancoding.com/sketch/)*）这样的更专注于网页的应用程序会更方便。你还可能想利用SVG优化网站（*[http://petercollingridge.appspot.com/svg-optimiser/](http://petercollingridge.appspot.com/svg-optimiser/)*）或应用程序（*[https://github.com/svg/](https://github.com/svg/)*），这些工具可以通过移除多余的标签并减少图形程序有时过度的精度来压缩SVG文件。
- en: Our result will be a series of `<path>` elements, one for each county. We’ll
    also want to assign a `class` or `id` to each path to indicate the county. The
    resulting SVG file might begin like the following.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果将是一系列的`<path>`元素，每个县一个。我们还需要为每个路径分配一个`class`或`id`，以表示县名。最终生成的SVG文件可能如下所示。
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To summarize, here are the steps to create the SVG map.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，创建SVG地图的步骤如下。
- en: Locate a suitably licensed SVG-format map file or create one using a special-purpose
    map application.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个合适许可的SVG格式地图文件，或使用专用地图应用程序创建一个。
- en: Edit the SVG file in a graphics application to remove extraneous components
    and simplify the illustration.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图形应用程序中编辑SVG文件，以移除多余的组件并简化插图。
- en: Optimize the SVG file using an optimization site or application.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用优化网站或应用程序优化SVG文件。
- en: Make final adjustments (such as adding `id` attributes) in your regular HTML
    editor.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的常规HTML编辑器中进行最后调整（例如添加`id`属性）。
- en: 'Step 2: Embed the Map in the Page'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤2：将地图嵌入页面
- en: The simplest way to include an SVG map in a web page is to embed the SVG markup
    directly within the HTML markup. To include the first-aid symbol, for example,
    just include the SVG tags within the page itself, as shown at ➊ through ➋. You
    don’t have to include the header tags that are normally present in a standalone
    SVG file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将SVG地图嵌入网页的最简单方法是直接将SVG标记嵌入HTML标记中。例如，要包含急救符号，只需在页面本身内包含SVG标签，如➊至➋所示。你不需要包含通常存在于独立SVG文件中的头标签。
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If your map is relatively simple, direct embedding is the easiest way to include
    it in the page. Our map of Georgia, however, is about 1 MB even after optimization.
    That’s not unusual for maps with reasonable resolution, as describing complex
    borders such as coastlines or rivers can make for large `<path>` elements. Especially
    if the map isn’t the sole focus of the page, you can provide a better user experience
    by loading the rest of the page first. That will give your users something to
    read while the map loads in the background. You can even add a simple animated
    progress loader if that’s appropriate for your site.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的地图相对简单，直接嵌入是将其包含在页面中最简单的方法。然而，我们的乔治亚州地图即使经过优化后也有大约1 MB的大小。对于分辨率合理的地图，这并不罕见，因为描述复杂的边界，如海岸线或河流，可能会导致大型的`<path>`元素。特别是当地图不是页面的唯一重点时，你可以通过先加载页面的其余部分来提供更好的用户体验。这样，当地图在后台加载时，用户可以阅读其他内容。如果适合你的站点，你甚至可以添加一个简单的动画进度加载器。
- en: If you’re using jQuery, loading the map is a single instruction. You do want
    to make sure, though, that your code doesn’t start manipulating the map until
    the load is complete. Here’s how that would look in the source code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是jQuery，加载地图只需要一条指令。但你需要确保，在加载完成之前，代码不会开始操作地图。以下是源代码中的示例：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Step 3: Collect the Data'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步：收集数据
- en: The data for our visualization is available as an Excel spreadsheet directly
    from County Health Rankings (*[http://www.countyhealthrankings.org/](http://www.countyhealthrankings.org/)*).
    We’ll convert that to a JavaScript object in advance, and we’ll add a two-letter
    code corresponding to each county. Here’s how that array might begin.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的可视化数据可以直接从County Health Rankings（*[http://www.countyhealthrankings.org/](http://www.countyhealthrankings.org/)*）以Excel电子表格的形式获得。我们将在前期将其转换为JavaScript对象，并为每个县添加一个对应的两字母代码。以下是该数组的起始部分。
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For this visualization we’d like to show the variation in health outcomes among
    counties. The data set provides two variables for that value, a ranking and a
    z-score (a measure of how far a sample is from the mean in terms of standard deviation).
    The County Health Rankings site provides z-scores slightly modified from the traditional
    statistical definition. Normal z-scores are always positive; in this data set,
    however, measurements that are subjectively better than average are multiplied
    by –1 so that they are negative. A county whose health outcome is two standard
    deviations “better” than the mean, for example, is given a z-score of –2 instead
    of 2\. This adjustment makes it easier to use these z-scores in our visualization.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这次可视化，我们希望展示各县之间健康结果的差异。数据集提供了两种变量来表示该值，一个是排名，另一个是z-score（标准分数，衡量样本与均值之间的偏差程度）。County
    Health Rankings网站提供了稍微修改过的z-score，偏离传统统计定义。正常的z-score总是正值；然而，在这个数据集中，主观上优于平均水平的测量值会乘以-1，使其变为负值。例如，某个县的健康结果比均值好两个标准差时，其z-score为-2，而不是2。这种调整使得在我们的可视化中使用这些z-score变得更加容易。
- en: Our first step in working with these z-scores is to find the maximum and minimum
    values. We can do that by extracting the outcomes as a separate array and then
    using JavaScript’s built-in `Math.max()` and `Math.min()` functions. Note that
    the following code uses the `map()` method to extract the array, and that method
    is available only in modern browsers. Since we’ve chosen to use SVG images, however,
    we’ve already restricted our users to modern browsers, so we might as well take
    advantage of that when we can.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在使用这些z-score的第一步是找到最大值和最小值。我们可以通过提取结果作为一个单独的数组，然后使用JavaScript的内置`Math.max()`和`Math.min()`函数来完成这项工作。请注意，以下代码使用了`map()`方法来提取数组，而该方法仅在现代浏览器中可用。然而，既然我们已经选择使用SVG图像，我们的用户已经被限制为使用现代浏览器，因此当有可能时，我们也可以利用这一点。
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice how we’ve used the `.apply()` method here. Normally the `Math.max()`
    and `Math.min()` functions accept a comma-separated list of arguments. We, of
    course, have an array instead. The `apply()` method, which works with any JavaScript
    function, turns an array into a comma-separated list. The first parameter is the
    context to use, which in our case doesn’t matter, so we set it to `null`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里使用了`.apply()`方法。通常，`Math.max()`和`Math.min()`函数接受以逗号分隔的参数列表。而我们当然有一个数组。`apply()`方法可以与任何JavaScript函数一起使用，将数组转化为逗号分隔的列表。第一个参数是要使用的上下文，在我们的例子中并不重要，因此我们将其设置为`null`。
- en: To complete the data preparation, let’s make sure the minimum and maximum ranges
    are symmetric about the mean.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成数据准备，让我们确保最小值和最大值范围对称于均值。
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If, for example, the z-scores ranged from `-2` to `1.5`, this code would extend
    the range to `[-2, 2]`. This adjustment will make the color scales symmetric as
    well, thus making our visualization easier for users to interpret.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果z分数的范围从`-2`到`1.5`，那么这段代码将把范围扩展到`[-2, 2]`。这个调整还会使颜色比例变得对称，从而使我们的可视化更容易被用户解读。
- en: 'Step 4: Define the Color Scheme'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步：定义颜色方案
- en: Defining an effective color scheme for a map can be quite tricky, but fortunately
    there are some excellent resources available. For this visualization we’ll rely
    on the Chroma.js library (*[http://driven-by-data.net/about/chromajs/](http://driven-by-data.net/about/chromajs/)*).
    That library includes many tools for working with and manipulating colors and
    color scales, and it can satisfy the most advanced color theorist. For our example,
    however, we can take advantage of the predefined color scales, specifically those
    defined originally by Cynthia Brewer (*[http://colorbrewer2.org/](http://colorbrewer2.org/)*).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为地图定义一个有效的颜色方案可能相当棘手，但幸运的是，有一些非常好的资源可以参考。对于这次可视化，我们将依赖Chroma.js库（*[http://driven-by-data.net/about/chromajs/](http://driven-by-data.net/about/chromajs/)*）。这个库包含了许多处理和操作颜色以及颜色比例的工具，可以满足最为高阶的色彩理论学者。对于我们的例子来说，我们可以利用预定义的色阶，特别是由Cynthia
    Brewer最初定义的那些色阶（*[http://colorbrewer2.org/](http://colorbrewer2.org/)*）。
- en: The Chroma.js library is available on popular content distribution networks,
    so we can rely on a network such as CloudFlare’s cdnjs (*[http://cdnjs.com/](http://cdnjs.com/)*)
    to host it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Chroma.js库在流行的内容分发网络上有提供，因此我们可以依赖像CloudFlare的cdnjs这样的网络来托管它（*[http://cdnjs.com/](http://cdnjs.com/)*）。
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To use a predefined scale, we pass the scale’s name (`"BrBG"` for Brewer’s brown-to-blue-green
    scale) to the `chroma.scale()` function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 若要使用预定义的色阶，我们将色阶的名称（`"BrBG"`表示Brewer的棕色到蓝绿色色阶）传递给`chroma.scale()`函数。
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At the same time, we indicate the domain for our scale (`minZ` to `maxZ`, although
    we’re reversing the order because of the data set’s z-score adjustment) and our
    desired output. The `"hex"` output is the common `"#012345"` format compatible
    with CSS and HTML markup.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们还会指明我们色阶的范围（`minZ`到`maxZ`，虽然因为数据集的z分数调整，我们需要反转顺序）以及我们期望的输出格式。`"hex"`输出是常见的`"#012345"`格式，兼容CSS和HTML标记。
- en: 'Step 5: Color the Map'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步：为地图上色
- en: With our color scheme established, we can now apply the appropriate colors to
    each county on the map. That’s probably the easiest step in the whole visualization.
    We iterate through all the counties, finding their `<path>` elements based on
    their `id` values, and applying the color by setting the `fill` attribute.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色方案确定后，我们可以将适当的颜色应用到地图上的每个县。那大概是整个可视化过程中最简单的步骤。我们遍历所有县，通过它们的`id`值找到相应的`<path>`元素，并通过设置`fill`属性来应用颜色。
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The resulting map, shown in [Figure 6-6](ch06.html#css_rules_can_set_the_styles_for_individ
    "Figure 6-6. CSS rules can set the styles for individual SVG elements within an
    SVG illustration."), illustrates which counties are above average and which are
    below average for health outcomes in 2014.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 结果地图，展示在[图6-6](ch06.html#css_rules_can_set_the_styles_for_individ "图6-6. CSS规则可以为SVG插图中的每个SVG元素设置样式")中，显示了哪些县在2014年健康结果上高于平均水平，哪些则低于平均水平。
- en: '![CSS rules can set the styles for individual SVG elements within an SVG illustration.](figs/web/06fig06.png.jpg)Figure 6-6. CSS
    rules can set the styles for individual SVG elements within an SVG illustration.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![CSS规则可以为SVG插图中的每个SVG元素设置样式。](figs/web/06fig06.png.jpg)图6-6. CSS规则可以为SVG插图中的每个SVG元素设置样式。'
- en: 'Step 6: Add a Legend'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第6步：添加图例
- en: To help users interpret the map, we can add a legend to the visualization. We
    can take advantage of the Chroma.js scale to easily create a table that explains
    the variation. For the table, we’ll use four increments for the colors on each
    side of the mean value. That gives us a total of nine colors for the legend.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助用户解读地图，我们可以向可视化中添加图例。我们可以利用Chroma.js的色阶轻松创建一个表格，来解释变化。对于这个表格，我们将使用四个增量来表示均值两侧的颜色。这样我们总共有九种颜色用于图例。
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Some straightforward CSS will style the table appropriately. Because we have
    nine colors, we set the width of each table cell to `11.1111%` (1/9 is 0.111111).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一些简单的CSS样式将使表格呈现得恰当。由于我们有九种颜色，我们将每个表格单元格的宽度设置为`11.1111%`（1/9约等于0.111111）。
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, we use the Chroma scale created earlier to set the background color
    for the legend’s table cells. Because the legend is a `<table>` element, we can
    directly access the rows and the cells within the rows. Although these elements
    look like arrays in the following code, they’re not true JavaScript arrays, so
    they don’t support array methods such as `forEach()`. For now, we’ll iterate through
    them with a `for` loop, but if you’d rather use the array methods, stay tuned
    for a simple trick. Note that once again we’re working backward because of the
    data set’s z-score adjustments.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用之前创建的 Chroma 色标来设置图例表格单元格的背景颜色。因为图例是一个`<table>`元素，所以我们可以直接访问行和行中的单元格。尽管在以下代码中，这些元素看起来像数组，但它们并不是真正的
    JavaScript 数组，因此不支持像`forEach()`这样的数组方法。目前，我们将使用`for`循环来迭代它们，但如果你更喜欢使用数组方法，敬请期待一个简单的技巧。请注意，由于数据集的
    z-score 调整，我们再次是在逆向操作。
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: At ➊ we calculate the fraction of the current index from the total number of
    legend colors `((idx + 0.5) / cells.length)`, multiply that by the total range
    of the scale `(maxZ - minZ)`, and subtract the result from the maximum value.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们计算当前索引占图例颜色总数的比例`((idx + 0.5) / cells.length)`，将其乘以色标的总范围`(maxZ - minZ)`，并从最大值中减去结果。
- en: The result is the legend for the map in [Figure 6-7](ch06.html#html_less_thantablegreater_than_can_serv
    "Figure 6-7. An HTML <table> can serve as a legend.").
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是地图的图例，如[图 6-7](ch06.html#html_less_thantablegreater_than_can_serv "图 6-7.
    一个 HTML <table> 可以作为图例。")所示。
- en: '![An HTML <table> can serve as a legend.](figs/web/06fig07.png.jpg)Figure 6-7. An
    HTML `<table>` can serve as a legend.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个 HTML <table> 可以作为图例。](figs/web/06fig07.png.jpg)图 6-7. 一个 HTML `<table>`
    可以作为图例。'
- en: 'Step 7: Add Interactions'
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 7 步：添加交互
- en: To complete the visualization, let’s enable users to hover their mouse over
    a county on the map to see more details. Of course, mouse interactions are not
    available for tablet or smartphone users. To support those users, you could add
    a similar interaction for tap or click events. That code would be almost identical
    to the next example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成可视化，我们让用户可以在地图上将鼠标悬停在一个县上，以查看更多详细信息。当然，平板或智能手机用户无法进行鼠标交互。为了支持这些用户，你可以为触摸或点击事件添加类似的交互。那段代码几乎与下一个示例相同。
- en: We’ll start by defining a table to show county details.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从定义一个表格开始，以显示县的详细信息。
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Initially, we don’t want that table to be visible.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们不希望这个表格可见。
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To show the table, we use event handler functions that track when the mouse
    enters or leaves an SVG path for a county. To find these `<path>` elements, we
    can use the `querySelectorAll()` function that modern browsers support. Unfortunately,
    that function doesn’t return a true array of elements, so we can’t use array methods
    such as `forEach()` to iterate through those elements. There’s a trick, however,
    that will let us convert the returned list into a true array.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示表格，我们使用事件处理函数来跟踪鼠标何时进入或离开县的 SVG 路径。为了找到这些`<path>`元素，我们可以使用现代浏览器支持的`querySelectorAll()`函数。不幸的是，这个函数并不会返回一个真正的元素数组，因此我们不能使用`forEach()`等数组方法来迭代这些元素。然而，有一个技巧可以将返回的列表转换为一个真正的数组。
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code calls the `[].slice.call()` function with the “not quite array” object
    as its parameter. The result is a true array with all of its useful methods.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码调用了`[].slice.call()`函数，并将“几乎是数组”的对象作为参数传递。结果是一个真正的数组，包含了所有有用的方法。
- en: In addition to making the details table visible, we’ll also want to update it
    with the appropriate information. To help with this display, we can write a function
    that converts a z-score into a more user-friendly explanation. The specific values
    in the following example are arbitrary since we’re not trying for statistical
    precision in this visualization.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了让详细信息表格可见之外，我们还希望用适当的信息更新它。为了帮助显示这些信息，我们可以编写一个函数，将 z-score 转换为更易于理解的解释。以下示例中的具体值是任意的，因为我们在这次可视化中并不追求统计精度。
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are a couple of noteworthy items in this function. First, the statement
    `z = +z` converts the z-score from a string to a numeric value for the tests that
    follow. Second, remember that because of the z-score adjustments, the negative
    z-scores are actually better than average, while the positive values are below
    average.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数中有几个值得注意的地方。首先，语句`z = +z`将 z-score 从字符串转换为数值，以便进行后续的测试。其次，记住由于 z-score 调整，负的
    z-score 实际上好于平均值，而正的值则低于平均值。
- en: We can use this function to provide the data for our details table. The first
    step is finding the full data set for the associated `<path>` element. To do that,
    we search through the `counties` array looking for a `code` property that matches
    the `id` attribute of the path.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个函数为我们的详细信息表格提供数据。第一步是找到与 `<path>` 元素相关联的完整数据集。为此，我们会在 `counties` 数组中查找
    `code` 属性与路径的 `id` 属性匹配的项。
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Because `indexOf()` doesn’t allow us to find objects by key, we’ve used the
    `some()` method instead. That method terminates as soon as it finds a match, so
    we avoid iterating through the entire array.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `indexOf()` 不能让我们按键查找对象，因此我们使用了 `some()` 方法。该方法在找到匹配项后会立即终止，因此我们避免了遍历整个数组。
- en: Once we’ve found the county data, it’s a straightforward process to update the
    table. The following code directly updates the relevant table cell’s text content.
    For a more robust implementation, you could provide class names for the cells
    and update based on those class names.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了县的数据，更新表格就是一个简单的过程。以下代码直接更新相关表格单元格的文本内容。为了实现更健壮的功能，你可以为单元格提供类名，并基于这些类名进行更新。
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we just need a few more refinements:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要进行一些进一步的完善：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here we add a stroke color at ➊ for counties that are highlighted. We remove
    the stroke at ➋ when the mouse leaves the path.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为高亮显示的县添加了一个边框颜色，位于➊。当鼠标离开路径时，我们移除了位于➋的边框。
- en: At this point our visualization example is complete. [Figure 6-8](ch06.html#browsers_left_parenthesisand_a_bit_of_co
    "Figure 6-8. Browsers (and a bit of code) can turn SVG illustrations into interactive
    visualizations.") shows the result.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里为止，我们的可视化示例已经完成。[图 6-8](ch06.html#browsers_left_parenthesisand_a_bit_of_co
    "图 6-8. 浏览器（以及一些代码）可以将 SVG 插图转化为互动式可视化.") 展示了结果。
- en: '![Browsers (and a bit of code) can turn SVG illustrations into interactive
    visualizations.](figs/web/06fig08.png.jpg)Figure 6-8. Browsers (and a bit of code)
    can turn SVG illustrations into interactive visualizations.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![浏览器（以及一些代码）可以将 SVG 插图转化为互动式可视化。](figs/web/06fig08.png.jpg)图 6-8. 浏览器（以及一些代码）可以将
    SVG 插图转化为互动式可视化。'
- en: Including Maps for Context
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包括地图作为背景
- en: So far in this chapter, we’ve looked at map visualizations where the main subjects
    are geographic regions—countries in Europe or counties in Georgia. In those cases,
    choropleth maps were effective in showing the differences between regions. Not
    all map visualizations have the same focus, however. In some cases, we want to
    include a map more as context or background for the visualization data.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在本章中看过的地图可视化主要关注地理区域——比如欧洲的国家或乔治亚州的县。在这些情况下，分级色块地图在展示区域间差异时非常有效。然而，并非所有地图可视化都具有相同的焦点。在某些情况下，我们希望将地图更多地作为可视化数据的上下文或背景。
- en: When we want to include a map as a visualization background, we’re likely to
    find that traditional mapping libraries will serve us better than custom choropleth
    maps. The most well-known mapping library is probably Google Maps (*[http://maps.google.com/](http://maps.google.com/)*),
    and you’ve almost certainly seen many examples of embedded Google maps on web
    pages. There are, however, several free and open source alternatives to Google
    Maps. For this example, we’ll use the Modest Maps library (*[https://github.com/modestmaps/modestmaps-js/](https://github.com/modestmaps/modestmaps-js/)*)
    from Stamen Design. To show off this library, we’ll visualize the major UFO sightings
    in the United States (*[http://en.wikipedia.org/wiki/UFO_sightings_in_the_United_States](http://en.wikipedia.org/wiki/UFO_sightings_in_the_United_States)*),
    or at least those important enough to merit a Wikipedia entry.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将地图作为可视化背景时，我们可能会发现传统的地图绘制库比自定义的分级色块地图更适合我们的需求。最著名的地图库可能是 Google Maps (*[http://maps.google.com/](http://maps.google.com/)*)，你几乎肯定在网页上见过许多嵌入的
    Google 地图。然而，Google Maps 也有几个免费的开源替代品。对于这个示例，我们将使用 Stamen Design 提供的 Modest Maps
    库 (*[https://github.com/modestmaps/modestmaps-js/](https://github.com/modestmaps/modestmaps-js/)*)。为了展示这个库，我们将可视化美国的主要
    UFO 目击事件 (*[http://en.wikipedia.org/wiki/UFO_sightings_in_the_United_States](http://en.wikipedia.org/wiki/UFO_sightings_in_the_United_States)*)，至少是那些足够重要以至于值得在维基百科上出现的事件。
- en: 'Step 1: Set Up the Web Page'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一步：设置网页
- en: 'For our visualization, we’ll rely on a couple of components from the Modest
    Maps library: the core library itself and the spotlight extension that can be
    found in the library’s examples folder. In production you would likely combine
    these and minify the result to optimize performance, but for our example, we’ll
    include them separately.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的可视化，我们将依赖于 Modest Maps 库中的几个组件：核心库本身和可以在库的示例文件夹中找到的 spotlight 扩展。在生产环境中，您可能会将这些组件合并并压缩结果以优化性能，但在我们的示例中，我们将它们单独包含。
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We’ve also set aside a `<div>` at ➊ to hold the map. Not surprisingly, it has
    the `id` of `"map"`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在 ➊ 处设置了一个 `<div>` 来容纳地图。不出所料，它的 `id` 为 `"map"`。
- en: 'Step 2: Prepare the Data'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步：准备数据
- en: The Wikipedia data can be formatted as an array of JavaScript objects. We can
    include whatever information we wish in the objects, but we’ll definitely need
    the latitude and longitude of the sighting in order to place it on the map. Here’s
    how you might structure the data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科数据可以格式化为 JavaScript 对象数组。我们可以在对象中包含任何信息，但我们肯定需要观察数据的纬度和经度，以便将其定位到地图上。这是您可能如何构建数据的示例。
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `location` property holds the latitude and longitude (where negative values
    indicate west) as a two-element array.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`location` 属性保存纬度和经度（负值表示西方）作为一个包含两个元素的数组。'
- en: 'Step 3: Choose a Map Style'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步：选择地图样式
- en: As with most mapping libraries, Modest Maps builds its maps using layers. The
    layering process works much like it does in a graphics application such as Photoshop
    or Sketch. Subsequent layers add further visual information to the map. In most
    cases, the base layer for a map consists of image tiles. Additional layers such
    as markers or routes can be included on top of the image tiles.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数地图库一样，Modest Maps 使用图层构建地图。图层的构建过程与在 Photoshop 或 Sketch 等图形应用程序中的工作方式非常相似。后续的图层会向地图添加更多的视觉信息。在大多数情况下，地图的基础图层由图像瓷砖组成。像标记或路线等附加图层可以叠加在图像瓷砖之上。
- en: When we tell Modest Maps to create a map, it calculates which tiles (both size
    and location) are needed and then it requests those tiles asynchronously over
    the Internet. The tiles define the visual style of the map. Stamen Design has
    published several tile sets itself; you can see them on *[http://maps.stamen.com/](http://maps.stamen.com/)*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们告诉 Modest Maps 创建地图时，它会计算所需的瓷砖（包括大小和位置），然后异步地从互联网上请求这些瓷砖。瓷砖定义了地图的视觉样式。Stamen
    Design 本身发布了几套瓷砖，您可以在*[http://maps.stamen.com/](http://maps.stamen.com/)*上查看。
- en: To use the Stamen tiles, we’ll add one more, small JavaScript library to our
    page. That library is available directly from Stamen Design (*[http://maps.stamen.com/js/tile.stamen.js](http://maps.stamen.com/js/tile.stamen.js)*).
    It should be included *after* the Modest Maps library.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Stamen 瓷砖，我们将向页面中添加一个小的 JavaScript 库。该库可以直接从 Stamen Design 获取 (*[http://maps.stamen.com/js/tile.stamen.js](http://maps.stamen.com/js/tile.stamen.js)*)。它应在
    Modest Maps 库之后被包含。
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For our example, the “toner” style is a good match, so we’ll use those tiles.
    To use those tiles, we create a *tile layer* for the map.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，"toner" 样式非常合适，因此我们将使用这些瓷砖。要使用这些瓷砖，我们为地图创建一个 *瓷砖图层*。
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When you consider a source for image tiles, be aware of any copyright restrictions.
    Some image tiles must be licensed, and even those that are freely available often
    require that any user identify the provider as the source.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑图像瓷砖来源时，请注意任何版权限制。一些图像瓷砖必须获得授权，甚至那些自由提供的瓷砖，通常也要求用户标明提供者为来源。
- en: 'Step 4: Draw the Map'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 4 步：绘制地图
- en: 'Now we’re ready to draw the map itself. That takes two JavaScript statements:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好绘制地图了。这需要两条 JavaScript 语句：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First we create a new `MM.Map` object, giving it the `id` of the element containing
    the map and the tiles we just initialized. Then we provide the latitude and longitude
    for the map’s center as well as an initial zoom level. For your own maps, you
    may need to experiment a bit to get the right values, but for this example, we’ll
    center and zoom the map so that it comfortably shows the continental United States.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们创建一个新的 `MM.Map` 对象，给它传入包含地图的元素的 `id` 和我们刚刚初始化的瓷砖。然后，我们提供地图中心的纬度和经度以及初始缩放级别。对于您自己的地图，您可能需要做些实验来找到合适的值，但对于本示例，我们将地图居中并缩放，以便舒适地显示美国本土。
- en: The resulting map, shown in [Figure 6-9](ch06.html#map_libraries_can_show_maps_based_on_geo
    "Figure 6-9. Map libraries can show maps based on geographic coordinates."), forms
    a base for showing the sightings.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 结果地图，如[图 6-9](ch06.html#map_libraries_can_show_maps_based_on_geo "图 6-9. 地图库可以根据地理坐标显示地图")所示，为显示观察数据提供了基础。
- en: '![Map libraries can show maps based on geographic coordinates.](figs/web/06fig09.png.jpg)Figure 6-9. Map
    libraries can show maps based on geographic coordinates.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![地图库可以根据地理坐标显示地图。](figs/web/06fig09.png.jpg)图6-9。地图库可以根据地理坐标显示地图。'
- en: Notice that both Stamen Design and OpenStreetMap are credited. That attribution
    is required by the terms of the Stamen Design license.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Stamen Design和OpenStreetMap都有注明出处。这是Stamen Design许可协议要求的归属。
- en: 'Step 5: Add the Sightings'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步：添加目击事件
- en: With our map in place, it’s time to add the individual UFO sightings. We’re
    using the spotlight extension to highlight these locations, so we first create
    a spotlight layer for the map. We’ll also want to set the radius of the spotlight
    effect. As with the center and zoom parameters, a bit of trial and error helps
    here.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的地图搭建完成后，是时候添加单独的UFO目击事件了。我们使用聚光灯扩展来突出显示这些地点，因此我们首先为地图创建一个聚光灯图层。我们还需要设置聚光灯效果的半径。与中心和缩放参数一样，这里也需要通过一定的反复试验来调整。
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now we can iterate through the array of sightings that make up our data. For
    each sighting, we extract the latitude and longitude of the location and add that
    location to the spotlight layer.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以遍历构成我们数据的所有目击事件。对于每一个目击事件，我们提取该地点的纬度和经度，并将该地点添加到聚光灯图层中。
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: At this point our visualization is complete. [Figure 6-10](ch06.html#adding_layers_in_a_map_library_can_empha
    "Figure 6-10. Adding layers in a map library can emphasize regions of a map.")
    shows where UFOs have allegedly appeared over the United States in a suitably
    mysterious context.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们的可视化已经完成。[图6-10](ch06.html#adding_layers_in_a_map_library_can_empha "图6-10。在地图库中添加图层可以突出显示地图区域。")展示了在美国上空据称出现UFO的地点，并在合适的神秘背景下呈现。
- en: '![Adding layers in a map library can emphasize regions of a map.](figs/web/06fig10.png.jpg)Figure 6-10. Adding
    layers in a map library can emphasize regions of a map.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![在地图库中添加图层可以突出显示地图区域。](figs/web/06fig10.png.jpg)图6-10。在地图库中添加图层可以突出显示地图区域。'
- en: Integrating a Full-Featured Mapping Library
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成一个功能齐全的地图库
- en: 'The Modest Maps library of the previous example is a fine library for simple
    map visualizations, but it doesn’t have all of the features and support of a full-featured
    service such as Google Maps. There is, however, an open source library that does
    provide those features: Leaflet (*[http://leafletjs.com/](http://leafletjs.com/)*).
    In this example, we’ll build a more complex visualization that features a Leaflet-based
    map.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个例子中的Modest Maps库是一个很好的简单地图可视化库，但它没有Google Maps这样全面功能的支持。不过，有一个开源库提供了这些功能：Leaflet
    (*[http://leafletjs.com/](http://leafletjs.com/)*)。在这个例子中，我们将构建一个更复杂的可视化，使用基于Leaflet的地图。
- en: In the 1940s, two private railroads were in competition for passenger traffic
    in the southeastern United States. Two routes that competed most directly were
    the Silver Comet (run by Seaboard Air Lines) and the Southerner (operated by Southern
    Railways). Both served passengers traveling between New York and Birmingham, Alabama.
    One factor cited in the Southerner’s ultimate success was the shorter distance
    of its route. Trips on the Southerner were quicker, giving Southern Railways a
    competitive advantage. Let’s create a visualization to demonstrate that advantage.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪40年代，两个私人铁路公司在美国东南部的客运市场展开竞争。两个竞争最直接的路线是“银彗星号”（由海滨航空公司运营）和“南方号”（由南方铁路公司运营）。这两条线路都服务于从纽约到阿拉巴马州伯明翰的乘客。有人认为“南方号”最终成功的原因之一是其路线较短，旅程较快，使得南方铁路公司在竞争中占据了优势。让我们通过可视化来展示这一优势。
- en: 'Step 1: Prepare the Data'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步：准备数据
- en: The data for our visualization is readily available as timetables for the two
    routes. A more precise comparison might consider timetables from the same year,
    but for this example, we’ll use the Southerner’s timetable from 1941 (*[http://www.streamlinerschedules.com/concourse/track1/southerner194112.html](http://www.streamlinerschedules.com/concourse/track1/southerner194112.html)*)
    and the Silver Comet’s timetable from 1947 (*[http://www.streamlinerschedules.com/concourse/track1/silvercomet194706.html](http://www.streamlinerschedules.com/concourse/track1/silvercomet194706.html)*),
    as they are readily available on the Internet. The timetables only include station
    names, so we will have to look up latitude and longitude values (using, for example,
    Google Maps) for all of the stations in order to place them on a map. We can also
    calculate the time difference between stops, in minutes. Those calculations result
    in two arrays, one for each train.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可视化的数据作为两条路线的时刻表随时可用。更精确的比较可能会考虑同一年份的时刻表，但在这个示例中，我们将使用1941年《南方人号》的时刻表（* [http://www.streamlinerschedules.com/concourse/track1/southerner194112.html](http://www.streamlinerschedules.com/concourse/track1/southerner194112.html)
    *）和1947年《银彗星号》的时刻表（* [http://www.streamlinerschedules.com/concourse/track1/silvercomet194706.html](http://www.streamlinerschedules.com/concourse/track1/silvercomet194706.html)
    *），因为它们可以在互联网上轻松获取。时刻表只包含车站名称，因此我们需要查找所有车站的纬度和经度值（例如使用Google地图），以便将它们标记在地图上。我们还可以计算站点之间的时间差（以分钟为单位）。这些计算会得到两个数组，每个数组对应一列车。
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Step 2: Set Up the Web Page and Libraries'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步：设置网页和库
- en: To add Leaflet maps to our web page, we’ll need to include the library and its
    companion style sheet. Both are available from a content distribution network,
    so there’s no need to host them on our own servers.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Leaflet地图添加到我们的网页中，我们需要包含该库及其附带的样式表。两者都可以通过内容分发网络获取，因此无需将其托管在我们自己的服务器上。
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When we create our page, we also define a `<div>` container for the map at ➊.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建页面时，我们还会在➊处定义一个用于地图的`<div>`容器。
- en: 'Step 3: Draw the Base Map'
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步：绘制基础地图
- en: The Silver Comet and the Southerner traveled between New York and Birmingham
    (and, in the case of the Southerner, all the way to New Orleans). But the region
    that’s relevant for our visualization lies between Washington, DC, and Atlanta,
    Georgia, because that’s the only region where the train routes differed; for the
    rest of their journeys, the routes were essentially the same. Our map, therefore,
    will extend from Atlanta in the southwest to Washington, DC, in the northeast.
    Using a bit of trial and error, we can determine the best center point and zoom
    level for the map. The center point defines the latitude and longitude for the
    map’s center, and the zoom level determines the area covered by the map on its
    initial display. When we create the map object, we give it the `id` of the containing
    element as well as those parameters.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 《银彗星号》和《南方人号》列车在纽约和伯明翰之间往返（对于《南方人号》，甚至一路行驶到新奥尔良）。但是对于我们的可视化，相关的区域位于华盛顿特区和乔治亚州亚特兰大之间，因为只有在这个区域，列车路线有所不同；在其余行程中，路线基本相同。因此，我们的地图将从西南部的亚特兰大延伸到东北部的华盛顿特区。通过一些试验和错误，我们可以确定地图的最佳中心点和缩放级别。中心点定义了地图中心的纬度和经度，而缩放级别决定了地图初次显示时所覆盖的区域。当我们创建地图对象时，我们会将包含元素的`id`以及这些参数传递给它。
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For this particular visualization, there is little point in zooming or panning
    the map, so we can include additional options to disable those interactions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的可视化，缩放或平移地图没有太大意义，因此我们可以加入额外的选项来禁用这些交互功能。
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Setting both the minimum zoom level ➌ and the maximum zoom level ➍ to be equal
    to the initial zoom level disables zooming. We also disable the onscreen map controls
    for zooming at ➏. The other zoom controls are likewise disabled (➐ through ➑).
    For panning, we disable dragging the map at ➎ and keyboard arrow keys at ➒. We
    also specify the latitude/longitude bounds for the map (➊ and ➋).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 设置最小缩放级别➌和最大缩放级别➍为与初始缩放级别相同将禁用缩放功能。我们还在➏禁用了屏幕上的地图缩放控件。其他缩放控件也同样被禁用（➐到➑）。对于平移，我们在➎禁用了拖动地图，在➒禁用了键盘方向键。我们还指定了地图的纬度/经度范围（➊和➋）。
- en: Because we’ve disabled the user’s ability to pan or zoom the map, we should
    also make sure the mouse cursor doesn’t mislead the user when it’s hovering over
    the map. The *leaflet.css* style sheet expects zooming and panning to be enabled,
    so it sets the cursor to a “grabbing” hand icon. We can override that value with
    a style rule of our own. We have to define this rule *after* including the *leaflet.css*
    file.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经禁用了用户平移和缩放地图的功能，我们还应该确保鼠标指针在地图上悬停时不会误导用户。*leaflet.css* 样式表期望启用缩放和拖动，因此它将鼠标指针设置为“抓取”手形图标。我们可以用我们自己的样式规则覆盖这个设置。我们必须在引入
    *leaflet.css* 文件后定义这个规则。
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As with the Modest Maps example, we base our map on a set of tiles. There are
    many tile providers that support Leaflet; some are open source, while others are
    commercial. Leaflet has a demo page (*[http://leaflet-extras.github.io/leaflet-providers/preview/](http://leaflet-extras.github.io/leaflet-providers/preview/)*)
    you can use to compare some of the open source tile providers. For our example,
    we want to avoid tiles with roads, as the highway network looked very different
    in the 1940s. Esri has a neutral WorldGrayCanvas set that works well for our visualization.
    It does include current county boundaries, and some counties may have changed
    their borders since the 1940s. For our example, we won’t worry about that detail,
    though you might consider it in any production visualization. Leaflet’s API lets
    us create the tile layer and add it to the map in a single statement. The Leaflet
    includes a built-in option to handle attribution so we can be sure to credit the
    tile source appropriately.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Modest Maps 示例一样，我们将地图基于一组瓦片。支持 Leaflet 的瓦片提供商有很多；其中一些是开源的，而其他则是商业的。Leaflet
    提供了一个演示页面 (*[http://leaflet-extras.github.io/leaflet-providers/preview/](http://leaflet-extras.github.io/leaflet-providers/preview/)*)，你可以用它来比较一些开源的瓦片提供商。在我们的示例中，我们希望避免包含道路的瓦片，因为在
    1940 年代，高速公路网络与现在有很大不同。Esri 提供了一个中性化的 WorldGrayCanvas 瓦片集，这对于我们的可视化非常合适。它包含了当前的县界，而一些县的边界可能自
    1940 年代以来发生了变化。不过，在我们的示例中，我们不需要担心这个细节，但在任何生产环境的可视化中，你可能需要考虑这一点。Leaflet 的 API 允许我们在一个语句中创建瓦片图层并将其添加到地图上。Leaflet
    内置了一个选项来处理版权归属，这样我们可以确保正确地标注瓦片来源。
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that the `maxZoom` option at ➊ indicates the maximum zoom layer available
    for that particular tile set. That value is independent of the zoom level we’re
    permitting for our map.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，➊ 处的 `maxZoom` 选项表示该特定瓦片集可用的最大缩放层级。这个值独立于我们允许地图缩放的层级。
- en: With a map and a base tile layer, we have a good starting point for our visualization
    in (see [Figure 6-11](ch06.html#base_layer_map_provides_the_canvas_for_a "Figure 6-11. A
    base layer map provides the canvas for a visualization.")).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有了地图和基础瓦片图层，我们就有了一个很好的可视化起点（见 [图 6-11](ch06.html#base_layer_map_provides_the_canvas_for_a
    "图 6-11。基础图层地图为可视化提供了画布.")）。
- en: '![A base layer map provides the canvas for a visualization.](figs/web/06fig11.png.jpg)Figure 6-11. A
    base layer map provides the canvas for a visualization.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![基础图层地图为可视化提供了画布。](figs/web/06fig11.png.jpg)图 6-11。基础图层地图为可视化提供了画布。'
- en: 'Step 4: Add the Routes to the Map'
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 4 步：将路线添加到地图
- en: For the next step in our visualization, we want to show the two routes on our
    map. First, we’ll simply draw each route on the map. Then, we’ll add an animation
    that traces both routes at the same time to show which one is faster.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在可视化的下一步中，我们想要在地图上显示两条路线。首先，我们将简单地在地图上绘制每条路线。然后，我们会添加一个动画，实时显示两条路线，同时展示哪一条更快。
- en: 'The Leaflet library includes a function that does exactly what we need to draw
    each route: `polyline()` connects a series of lines defined by the latitude and
    longitude of their endpoints and prepares them for a map. Our data set includes
    the geographic coordinates of each route’s stops, so we can use the JavaScript
    `map()` method to format those values for Leaflet. For the Silver Comet example,
    the following statement extracts its stops.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Leaflet 库中有一个函数，正是我们需要的来绘制每条路线：`polyline()` 连接一系列由其端点的纬度和经度定义的线条，并为地图做准备。我们的数据集包括每条路线停靠站的地理坐标，因此我们可以使用
    JavaScript 的 `map()` 方法来格式化这些值以供 Leaflet 使用。对于 Silver Comet 示例，以下语句提取了它的停靠站。
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This statement returns an array of latitude/longitude pairs:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这条语句返回一组纬度/经度对：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: That result is the perfect input to the `polyline()` function. We’ll use it
    for each of the routes. The options let us specify a color for the lines, which
    we’ll match with the associated railroad’s official color from the era. We also
    indicate that the lines have no function when clicked by setting the `clickable`
    option to `false`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 该结果是`polyline()`函数的完美输入。我们将为每条路线使用它。选项允许我们为线路指定颜色，我们将其与该时代相关铁路的官方颜色相匹配。我们还通过将`clickable`选项设置为`false`来表明，点击时这些线路没有任何功能。
- en: '[PRE47]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: With this addition, the visualization shown in [Figure 6-12](ch06.html#additional_map_layers_add_data_to_the_ca
    "Figure 6-12. Additional map layers add data to the canvas.") is starting to convey
    the relative distances of the two routes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这个功能后，图6-12中显示的可视化开始传达两条路线的相对距离。
- en: '![Additional map layers add data to the canvas.](figs/web/06fig12.png.jpg)Figure 6-12. Additional
    map layers add data to the canvas.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![附加地图图层将数据添加到画布中。](figs/web/06fig12.png.jpg) 图6-12. 附加地图图层将数据添加到画布中。'
- en: 'Step 5: Add an Animation Control'
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步：添加动画控制
- en: Next, we’ll animate the two routes. Not only will this emphasize the competitive
    advantage of the shorter route, but it will also make the visualization more interesting
    and engaging. We’ll definitely want to let our users start and stop the animation,
    so our map will need a control button. The Leaflet library doesn’t have its own
    animation control, but the library does have a lot of support for customizations.
    Part of that support is a generic `Control` object. We can create an animation
    control by starting with that object and extending it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对两条路线进行动画处理。这不仅会强调较短路线的竞争优势，还会让可视化更加有趣和吸引人。我们肯定希望让用户能够启动和停止动画，因此我们的地图将需要一个控制按钮。Leaflet库本身没有动画控制器，但它提供了大量的自定义支持。这部分支持就是一个通用的`Control`对象。我们可以通过从该对象开始并扩展它来创建一个动画控制器。
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Next we define the options for our custom control. Those options include its
    position on the map, the text and tool tip (title) for its states, and functions
    to call when the animation starts or stops. We define these within an `options`
    object as follows, which lets Leaflet integrate them within its normal functionality.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义自定义控制器的选项。这些选项包括它在地图上的位置、其状态的文本和工具提示（标题），以及在动画开始或停止时调用的函数。我们将这些定义在一个`options`对象中，如下所示，这样Leaflet就可以将其集成到其正常功能中。
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: For our example, we’re using UTF-8 characters for the play and pause control.
    In a production visualization, you might consider using icon fonts or images to
    have maximum control over the appearance.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们使用UTF-8字符作为播放和暂停控制。在生产环境的可视化中，你可能会考虑使用图标字体或图像，以便最大程度地控制外观。
- en: Our animation control also needs an `onAdd()` method for Leaflet to call when
    it adds a control to a map. This method constructs the HTML markup for the control
    and returns that to the caller.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的动画控制还需要一个`onAdd()`方法，供Leaflet在将控制添加到地图时调用。该方法构建控制的HTML标记，并将其返回给调用者。
- en: '[PRE50]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Our implementation of `onAdd()` constructs the markup in two stages. First,
    starting at ➊, it creates a `<div>` element and gives that element two classes:
    `leaflet-control-animate` and `leaflet-bar`. The first class is unique to our
    animation control, and we can use it to apply CSS rules uniquely to our control.
    The second class is a general Leaflet class for all toolbars. By adding it to
    the animation control, we’re making that control consistent with other Leaflet
    controls. Note that Leaflet includes the `L.DomUtil.create()` method at ➊ to handle
    the details of creating the element.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`onAdd()`的实现分两步构建标记。首先，从➊开始，创建一个`<div>`元素，并为该元素赋予两个类：`leaflet-control-animate`和`leaflet-bar`。第一个类是我们动画控制器特有的，我们可以使用它为我们的控制器应用唯一的CSS规则。第二个类是Leaflet为所有工具栏定义的通用类。通过将它添加到动画控制器中，我们使该控制器与其他Leaflet控制器保持一致。请注意，Leaflet在➊处包含了`L.DomUtil.create()`方法，用来处理创建元素的细节。
- en: 'The second part of `onAdd()` creates a button element within this `<div>` container.
    Most of the work takes place in the `_createButton()` function at ➋, which we’ll
    examine shortly. The parameters to the function include the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`onAdd()`的第二部分在这个`<div>`容器内创建一个按钮元素。大部分工作是在➋处的`_createButton()`函数中进行的，我们稍后会详细查看。传递给该函数的参数包括：'
- en: The text for the button
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮的文本
- en: The tool tip (title) to display when the mouse hovers over the button
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当鼠标悬停在按钮上时显示的工具提示（标题）
- en: The CSS class to apply to the button
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用到按钮的CSS类
- en: The container in which to insert the button
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入按钮的容器
- en: A function to call when the button is clicked
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮点击时调用的函数
- en: If you’re wondering why the name of this function begins with an underscore
    (_), that’s the convention that Leaflet uses for private methods (and attributes).
    There’s no requirement to follow it, but doing so will make it easier for someone
    familiar with Leaflet to understand our code.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想为什么这个函数的名字以下划线（_）开头，那是因为 Leaflet 使用这种命名约定来表示私有方法（和属性）。虽然没有强制要求遵循，但这样做会使熟悉
    Leaflet 的人更容易理解我们的代码。
- en: The `_createButton()` method itself relies on Leaflet utility functions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`_createButton()` 方法本身依赖于 Leaflet 的工具函数。'
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First it creates the button as an `<a>` element with the specified text, title,
    and class, and it creates that element within the appropriate container (➊ through
    ➋). It then binds several events to this `<a>` element. First it ignores initial
    `mousedown` and double-click events at ➌. It also prevents single-click events
    from propagating up the document tree and from implementing their default behavior
    at ➍. Finally, it executes the callback function on `click` events at ➎.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它将按钮创建为一个 `<a>` 元素，设置指定的文本、标题和类，并将该元素放入合适的容器中（➊ 到 ➋）。然后，它将几个事件绑定到这个 `<a>`
    元素上。首先，它忽略初始的 `mousedown` 和双击事件（➌）。它还会防止单击事件在文档树中传播并实现默认行为（➍）。最后，它在 `click` 事件时执行回调函数（➎）。
- en: The callback function itself is our next task.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数本身是我们接下来的任务。
- en: '[PRE52]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Before we get into the function, we add a single state variable (`_running`)
    to keep track of whether the animation is currently running. It starts out stopped
    at ➊. Then our callback function starts by checking this variable at ➋. If `_running`
    is `true`, that means the animation was running and has just been paused by the
    current click, so it changes the control to indicate that clicking will now resume
    the animation. If the animation isn’t running, the callback function does the
    opposite: it changes the control to indicate that a subsequent click will pause
    it. In both cases, the callback function executes the appropriate control function
    if one exists. Finally, it sets the state of `_running` to its complement.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入函数之前，我们添加了一个状态变量（`_running`）来跟踪动画当前是否正在运行。它初始时停止，状态为 ➊。然后我们的回调函数会在 ➋ 处检查这个变量。如果
    `_running` 为 `true`，意味着动画正在运行并刚被当前点击暂停，因此它会改变控件，指示点击将恢复动画。如果动画没有运行，回调函数会做相反的操作：改变控件，指示后续的点击将暂停它。在这两种情况下，如果有可用的控件函数，回调函数会执行相应的控制函数。最后，它会将
    `_running` 的状态设置为其补集。
- en: The last part of our custom control adds a `reset()` method to clear the animation.
    This function sets the control back to its initial state.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自定义控件的最后部分添加了一个 `reset()` 方法，用来清除动画。这个函数将控件恢复到初始状态。
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: To completely integrate our custom control into the Leaflet architecture, we
    add a function to the `L.control` object. Following the Leaflet convention, this
    function’s name begins with a lowercase letter but is otherwise identical to the
    name of our control.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的自定义控件完全集成到 Leaflet 架构中，我们在 `L.control` 对象中添加了一个函数。按照 Leaflet 的约定，这个函数的名字以小写字母开头，但除此之外，它的名字与我们的控件名称完全相同。
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Defining this last function lets us create the control using a common Leaflet
    syntax.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 定义这个最后的函数让我们能够使用通用的 Leaflet 语法创建控件。
- en: '[PRE55]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is the same syntax we’ve seen before with layers and polylines.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前在图层和折线中看到的相同语法。
- en: 'Step 6: Prepare the Animation'
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第六步：准备动画
- en: With a convenient user control in place, we can now begin work on the animation
    itself. Although this particular animation isn’t especially taxing, we can still
    follow best practices and compute as much as possible in advance. Since we’re
    animating two routes, we’ll define a function that will build an animation for
    any input route. A second parameter will specify polyline options. This function
    will return an array of polyline paths, indexed by minutes. You can see the basic
    structure of this function next.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好方便的用户控件后，我们现在可以开始处理动画本身。尽管这个特定的动画并不特别复杂，但我们仍然可以遵循最佳实践，尽可能提前计算。由于我们要为两条路线制作动画，我们将定义一个函数，用来为任何输入的路线构建动画。第二个参数将指定折线的选项。这个函数会返回一个按分钟索引的折线路径数组。你可以看到这个函数的基本结构如下。
- en: '[PRE56]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first element in the array will be the polyline for the first minute of
    the route. We’ll build the entire array in the `animation` variable.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的第一个元素将是路线的第一分钟的折线。我们将在 `animation` 变量中构建整个数组。
- en: To build the paths, we iterate through the stops on the route.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建路径，我们遍历路线上的所有站点。
- en: '[PRE57]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We want to keep track of all the stops we’ve already passed, so we define the
    `prevStops` array and initialize it as empty at ➊. Each iteration calculates the
    animation steps for the current stop up to the next stop. There’s no need to go
    beyond the final stop on the route, so we terminate the loop at the next-to-last
    stop (`stopIdx < route.length-1;`).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望跟踪我们已经经过的所有站点，因此我们在➊处定义了 `prevStops` 数组并将其初始化为空。每次迭代都会计算当前站点到下一个站点的动画步骤。由于不需要超出路线的最后一个站点，所以我们在倒数第二个站点处终止循环（`stopIdx
    < route.length-1;`）。
- en: As we start to calculate the paths beginning at the current stop, we’ll store
    that stop and the next one in local variables, and we’ll add the current stop
    to the `prevStops` array that’s keeping track of previous stops.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始计算从当前站点开始的路径时，我们会将该站点及下一个站点存储在局部变量中，并将当前站点添加到跟踪前一个站点的 `prevStops` 数组中。
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: For each stop in our data sets, the `duration` property stores the number of
    minutes until the next stop. We’ll use an inner loop, shown next, to count from
    `1` up to that value.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据集中的每一个站点，`duration` 属性存储到下一个站点的分钟数。我们将使用下面的内部循环，从 `1` 计数到该值。
- en: '[PRE59]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Within the loop, we use a simple linear interpolation to calculate the position
    at the corresponding time. That position, when appended to the `prevStops` array,
    is the polyline path for that time. This code creates a polyline based on the
    path and adds it to the animation array.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内，我们使用简单的线性插值来计算相应时间的当前位置。这个位置在添加到 `prevStops` 数组时，形成了该时间的折线路径。这段代码基于路径创建折线，并将其添加到动画数组中。
- en: When we use the array `concat()` method, we embed the position array within
    another array object. That keeps `concat()` from flattening the position array
    before appending it. You can see the difference in the following examples. It’s
    the latter outcome that we want.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用数组 `concat()` 方法时，我们将位置数组嵌套在另一个数组对象中。这样可以避免 `concat()` 在附加之前将位置数组展平。你可以在以下示例中看到这种区别。我们想要的是后者的结果。
- en: '[PRE60]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Step 7: Animate the Routes'
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第7步：动画路线
- en: Now it’s finally time to execute the animation. To initialize it, we create
    an array to hold the two routes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在终于到了执行动画的时刻。为了初始化它，我们创建一个数组来保存两个路线。
- en: '[PRE61]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Next we calculate the maximum number of animation steps. That’s the minimum
    of the length of the two animation arrays.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们计算最大的动画步骤数。这是两个动画数组长度的最小值。
- en: '[PRE62]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'That statement might seem overly complex for finding the minimum length, but
    it works with an arbitrary number of routes. If, in the future, we decided to
    animate a third route on our map, we wouldn’t have to change the code. The best
    way to understand the statement is to start in the middle and work outward. The
    following fragment converts the array of route animations into an array of lengths,
    specifically `[870,775]`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这条语句看起来可能有些复杂，用来找到最小长度，但它适用于任意数量的路线。如果未来我们决定在地图上增加第三条路线，我们就不需要修改代码。理解这条语句的最好方法是从中间开始，向外推理。以下代码片段将路线动画数组转换为长度数组，具体为
    `[870,775]`：
- en: '[PRE63]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: To find the minimum value in an array, we can use the `Math.min()` function,
    except that function expects its parameters as a comma-separated list of arguments
    rather than an array. The `apply()` method (which is available for any JavaScript
    function) converts an array into a comma-separated list. Its first parameter is
    a context for the function, which in our case is irrelevant, so we pass `null`
    for that parameter.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要在数组中找到最小值，我们可以使用 `Math.min()` 函数，除了这个函数期望的参数是一个逗号分隔的参数列表，而不是数组。`apply()` 方法（任何
    JavaScript 函数都可以使用）将数组转换为逗号分隔的参数列表。它的第一个参数是函数的上下文，在我们这里无关紧要，所以我们传递 `null` 作为该参数。
- en: The animation keeps track of its current state with the `step` variable, which
    we initialize to `0`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 动画使用 `step` 变量来跟踪当前状态，我们将其初始化为 `0`。
- en: '[PRE64]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `animateStep()` function processes each step in the animation. There are
    four parts to this function.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`animateStep()` 函数处理动画中的每一个步骤。这个函数有四个部分。'
- en: '[PRE65]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: First we check to see whether this is the very first step in the animation.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们检查这是否是动画中的第一步。
- en: '[PRE66]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If it isn’t, `step` will be greater than zero and we can remove the previous
    step’s polylines from the map at ➊.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是，`step` 将大于零，我们可以在➊处从地图上移除上一个步骤的折线。
- en: Next we check to see if we’re already at the end of the animation. If so, then
    we restart the animation back at step 0.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们检查是否已经到达动画的末尾。如果是，则我们从步骤0重新启动动画。
- en: '[PRE67]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: For the third part, we add the current step’s polylines to the map.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三部分，我们将当前步骤的折线添加到地图上。
- en: '[PRE68]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Finally, we return `true` if we’ve reached the end of the animation.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们已经到达动画的末尾，则返回`true`。
- en: '[PRE69]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We’ll execute this step function repeatedly in a JavaScript interval, shown
    next.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在JavaScript间隔中反复执行这个步骤函数，如下所示。
- en: '[PRE70]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We use a variable to keep a reference to that interval and add functions to
    start and stop it. In the `animate()` function, we check the return value from
    `animateStep()` at ➊. When it returns `true`, the animation is complete, so we
    clear the interval and reset our control. (We’ll see where that control is defined
    shortly.) The `pause()` function at ➋ stops the interval.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个变量来保持对该间隔的引用，并添加函数以开始和停止它。在`animate()`函数中，我们在➊处检查`animateStep()`的返回值。当它返回`true`时，动画完成，因此我们清除该间隔并重置控制。（我们稍后会看到该控制的定义位置。）在➋处的`pause()`函数停止该间隔。
- en: Now all we need to do is define the animation control using the object we created
    in Step 5.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要使用第5步中创建的对象来定义动画控制。
- en: '[PRE71]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Once we add it to the map, the user will be able to activate the animation.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将其添加到地图中，用户将能够激活动画。
- en: 'Step 8: Create Labels for the Stops'
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第8步：为车站创建标签
- en: Before we wrap up the animation, we’ll add some labels for each train stop.
    To emphasize the passage of time, we’ll reveal each label as the animation reaches
    the corresponding stop. To do that, we’ll create the labels using a special object;
    then we’ll create a method to add labels to the map; and, to finish the label
    object, we’ll add methods that get or set a label’s status.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成动画之前，我们将为每个火车站添加一些标签。为了强调时间的流逝，我们将在动画到达相应站点时显示每个标签。为此，我们将使用一个特殊的对象来创建标签；然后我们会创建一个方法来将标签添加到地图上；最后，为了完成标签对象，我们将添加方法来获取或设置标签的状态。
- en: Since Leaflet doesn’t have a predefined object for labels, we can once again
    create our own custom object. We start with the basic Leaflet `Class`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Leaflet没有预定义的标签对象，我们可以再次创建我们自己的自定义对象。我们从基本的Leaflet `Class`开始。
- en: '[PRE72]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Our `Label` object accepts parameters for its position on the map, its label
    text, and any options. Next, we extend the `initialize()` method of the Leaflet
    `Class` to handle those parameters.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Label`对象接受其在地图上的位置、标签文本和任何选项作为参数。接下来，我们扩展Leaflet `Class`的`initialize()`方法以处理这些参数。
- en: '[PRE73]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: For position and text, we simply save their values for later use. For the options,
    we use a Leaflet utility at ➊ to easily support default values. The object includes
    one variable to keep track of its status. Initially all labels are hidden, so
    `this._status` is initialized appropriately at ➋.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于位置和文本，我们只是保存它们的值以供稍后使用。对于选项，我们使用Leaflet工具在➊处轻松支持默认值。该对象包括一个变量，用于跟踪其状态。最初所有标签都是隐藏的，因此`this._status`在➋处被适当初始化。
- en: Next we define the default option values with the `options` attribute.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`options`属性定义默认的选项值。
- en: '[PRE74]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The only option we need for our label is an offset for the standard position.
    By default, that offset will be `0` in both the x- and y-coordinates.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为标签所需的唯一选项是标准位置的偏移量。默认情况下，该偏移量在x和y坐标中都为`0`。
- en: This `options` attribute, combined with the call to `L.Util.setOptions` in the
    `initialize` method, establishes a default value (`0,0`) for the offset that can
    be easily overridden when a `Label` object is created.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 该`options`属性与`initialize`方法中对`L.Util.setOptions`的调用结合，建立了一个默认值（`0,0`）作为偏移量，当创建`Label`对象时，可以轻松覆盖该默认值。
- en: Next we write the method that adds a label to a map.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写将标签添加到地图上的方法。
- en: '[PRE75]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This method does the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法执行以下操作：
- en: Creates a new `<div>` element with the CSS class `leaflet-label` at ➊
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在➊处创建一个新的`<div>`元素，并应用CSS类`leaflet-label`
- en: Sets the `line-height` of that element to `0` to work around a quirk in the
    way Leaflet calculates position at ➋
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该元素的`line-height`设置为`0`，以解决Leaflet计算位置时的一个奇异现象，在➋处
- en: Sets the `opacity` of the element to `0` to match its initial `hidden` status
    at ➌
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将元素的`opacity`设置为`0`，以匹配其初始`hidden`状态，在➌处
- en: Adds the new element to the `markerPane` layer in the map at ➍
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新元素添加到地图的`markerPane`图层中，在➍处
- en: Sets the contents of the element to the label text at ➎
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该元素的内容设置为标签文本，在➎处
- en: Calculates a position for the label using its defined latitude/longitude at
    ➏ and then adjusts for any offset (➐ through ➑)
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用其定义的纬度/经度在➏处计算标签的位置，然后调整任何偏移量（➐至➑）
- en: Positions the element on the map at ➒
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将元素定位到地图上，在➒处
- en: Note
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: '**Step 2—setting the `line-height` to `0`—addresses a problem in the method
    Leaflet uses to position elements on the map. In particular, Leaflet does not
    account for other elements in the same parent container. By setting all elements
    to have no line height, we nullify this effect so that the calculated position
    is correct.**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2——将 `line-height` 设置为 `0`——解决了 Leaflet 在地图上定位元素时所使用方法中的一个问题。特别是，Leaflet
    并未考虑到同一父容器中的其他元素。通过将所有元素的行高设置为 0，我们可以消除这种影响，从而使计算出的定位是正确的。**'
- en: Finally, we add methods to get and set the label’s status. As the following
    code indicates, our labels can have three different status values, and those values
    determine the opacity of the label.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加方法来获取和设置标签的状态。如以下代码所示，我们的标签可以具有三种不同的状态值，这些值决定了标签的透明度。
- en: '[PRE76]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We included the option to adjust the label’s position because not all labels
    will look good positioned exactly on the latitude and longitude of the station.
    Most will benefit from slight shifts to avoid interference with the route polylines,
    text on the base map tiles, or other labels. For a custom visualization such as
    this example, there’s no substitute for trial-and-error adjustments. We’ll capture
    those adjustments for each label by adding another `offset` field to our data
    set. The augmented data set might begin like this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了调整标签位置的选项，因为并非所有标签都能恰好位于车站的经纬度位置。大多数标签需要稍微移动，以避免与路线折线、底图上的文字或其他标签相互干扰。对于像这个示例这样的自定义可视化，没有什么能替代反复试验的调整。我们通过在数据集中添加另一个
    `offset` 字段来捕捉每个标签的这些调整。增强后的数据集可能如下所示：
- en: '[PRE77]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Step 9: Build the Label Animation'
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 9：构建标签动画
- en: To create the label animation, we can once again iterate through the trains’
    routes. Because we have more than one route, a general-purpose function will let
    us avoid duplicating code. As you can see from the following code, we’re not using
    a fixed number of arguments to our function. Instead, we let the caller pass in
    as many individual routes as desired. All of those input parameters will be stored
    in the `arguments` object.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建标签动画，我们可以再次遍历火车的路线。由于我们有不止一条路线，通用的函数可以帮助我们避免代码重复。如以下代码所示，我们没有使用固定数量的参数传递给函数。相反，我们让调用者传入任意数量的单独路线。这些输入参数将存储在
    `arguments` 对象中。
- en: The `arguments` object looks a lot like a JavaScript array. It has a `length`
    property, and we can access individual elements using, for example, `arguments[0]`.
    Unfortunately, the object isn’t a true array, so we can’t use the convenient array
    methods (such as `forEach`) on it. As a workaround, the very first statement in
    our `buildLabelAnimation()` function, shown next, relies on a simple trick to
    convert the `arguments` object into the true `args` array.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments` 对象看起来很像 JavaScript 数组。它有一个 `length` 属性，我们可以使用例如 `arguments[0]`
    来访问单个元素。不幸的是，该对象并不是真正的数组，因此我们无法在其上使用便利的数组方法（如 `forEach`）。作为解决方法，我们在 `buildLabelAnimation()`
    函数中的第一行代码，使用一个简单的技巧将 `arguments` 对象转换为真正的 `args` 数组。'
- en: '[PRE78]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: It’s a bit long winded, but the statement at ➊ effectively executes the `slice()`
    method on `arguments`. That operation clones `arguments` into a true array.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码稍显冗长，但位于 ➊ 的语句有效地在 `arguments` 上执行了 `slice()` 方法。该操作将 `arguments` 克隆成一个真正的数组。
- en: Note
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**This same trick works for nearly all of JavaScript’s “array-like” objects.
    You can often use it to convert them into true arrays.**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**这个相同的技巧几乎适用于所有 JavaScript 的“类数组”对象。你通常可以使用它将这些对象转换为真正的数组。**'
- en: With the routes converted into an array, we can use `forEach` to iterate through
    all of them, regardless of their number.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 由于路线已转换为数组，我们可以使用 `forEach` 遍历它们，无论它们有多少条。
- en: '[PRE79]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: As we begin processing each route, we set the `minutes` value to `0`. Then we
    can use `forEach` again to iterate through all the stops on the route.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始处理每条路线时，我们将 `minutes` 的值设置为 `0`。然后，我们可以再次使用 `forEach` 遍历该路线上的所有站点。
- en: '[PRE80]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: For each stop in the route, we first check to see whether that stop is the first
    or last one. If so, we don’t want to animate a label for that stop. Otherwise,
    we create a new `Label` object at ➊ and add it to the map. Then we append that
    `Label` object to the `labels` array that’s accumulating the label animation data.
    Notice that we add each label to this array twice. The first time we add it (➋)
    is at the time the animation reaches the stop; in this case, we add it with a
    status of `shown`. We also add the label to the array 50 minutes later (➌), this
    time with a status of `dimmed`. When we execute the animation, it will show the
    label when the route first reaches the station and then dim it a bit later.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于路线中的每个站点，我们首先检查该站点是否是第一个或最后一个。如果是，我们就不想为该站点制作标签动画。否则，我们在➊位置创建一个新的`Label`对象，并将其添加到地图上。然后，我们将这个`Label`对象添加到正在积累标签动画数据的`labels`数组中。注意，我们将每个标签添加到这个数组两次。第一次添加（➋）是在动画到达该站点时；在这种情况下，我们添加它时状态为`shown`。我们还将在50分钟后再次将标签添加到数组（➌），这时它的状态为`dimmed`。当我们执行动画时，标签会在路线第一次到达车站时显示，然后在稍后变得稍微暗淡。
- en: Once we’ve iterated through all the routes, our `labels` array will indicate
    when each label should change status. At this point, though, the labels aren’t
    listed in the order of their animation state changes. To fix that, we sort the
    array in order of increasing time.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们遍历完所有路线，我们的`labels`数组将指示每个标签何时应该改变状态。然而，此时标签的顺序并不是按照它们动画状态变化的顺序排列的。为了解决这个问题，我们按时间递增的顺序对数组进行排序。
- en: '[PRE81]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: To use our new function, we call and pass in all the routes to animate.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的新函数，我们调用并传入所有需要动画化的路线。
- en: '[PRE82]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Because we’re not animating the start (Washington, DC) or end (Atlanta) of any
    routes, we can go ahead and display those on the map from the start. We can get
    the coordinates from any route; the following example uses the `seaboard` data
    set.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有对任何路线的起点（华盛顿，DC）或终点（亚特兰大）进行动画处理，所以可以从一开始就在地图上显示它们。我们可以从任何路线中获取坐标；以下示例使用了`seaboard`数据集。
- en: '[PRE83]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Step 10: Incorporate Label Animation in the Animation Step'
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第10步：在动画步骤中加入标签动画
- en: Now that the label animation data is available, we can make some adjustments
    to our animation function to incorporate the labels as well as the polyline paths.
    The first change is deciding when to conclude the animation. Because we’re dimming
    the labels some time after the route passes their stops, we can’t simply stop
    when all the paths are drawn. That might leave some labels undimmed. We’ll need
    separate variables to store the number of steps for each animation, and the total
    number of animation steps will be whichever is greater.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在标签动画数据已经可用，我们可以对我们的动画函数进行一些调整，以便同时包括标签和折线路径。第一个变化是决定何时结束动画。因为我们是在路线经过站点后才逐渐淡化标签，所以不能在所有路径绘制完成后就简单地停止动画。这可能会导致某些标签没有被淡化。我们需要单独的变量来存储每个动画的步骤数，动画的总步骤数将是其中较大的那个。
- en: '[PRE84]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We also need a copy of the label animation data that we can destroy during the
    animation, while keeping the original data intact. We don’t want to destroy the
    original so that users can replay the animation if they wish. The easiest way
    to copy a JavaScript array is by calling its `slice(0)` method.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个标签动画数据的副本，以便在动画过程中销毁它，同时保持原始数据不变。我们不希望破坏原始数据，这样用户如果愿意的话，还可以重新播放动画。复制JavaScript数组的最简单方法是调用它的`slice(0)`方法。
- en: Note
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**We can’t simply copy the array using an assignment statement (`var labelAnimation
    = labels`). In JavaScript this statement would simply set `labelAnimation` to
    reference the same actual array as labels. Any changes made to the first would
    also affect the latter.**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们不能仅仅通过赋值语句（`var labelAnimation = labels`）来复制数组。在JavaScript中，这个语句会将`labelAnimation`设置为引用与`labels`相同的实际数组。对第一个数组的任何更改都会影响到后者。**'
- en: '[PRE85]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The animation step function itself needs some additional code to handle labels.
    It will now have five major parts; we’ll walk through each of them in the code
    that follows. Our first adjustment is to make sure the code removes previous polyline
    paths only as long as we’re still adding paths to the map. That’s true only when
    `step` is less than `maxPathSteps`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 动画步骤函数本身需要一些额外的代码来处理标签。它现在有五个主要部分；接下来我们将逐一讲解每个部分。我们的第一个调整是确保代码只在我们仍在往地图上添加路径时才移除先前的折线路径。这只有在`step`小于`maxPathSteps`时才成立。
- en: '[PRE86]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The next block handles the case in which the user replays the animation.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 下一块代码处理用户重新播放动画的情况。
- en: '[PRE87]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: When the animation replays, the `step` value will still be set to `maxSteps`
    from the prior animation. To reset the animation, we remove the last polyline
    paths for each route (➊ through ➋), make a new copy of the label animation data
    (➌), and hide all the labels (➍ through ➎). We also reset the `step` variable
    to `0` (➏).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画重新播放时，`step`值仍然会保持为上次动画中的`maxSteps`。为了重置动画，我们移除每条路线的最后一条折线路径（➊到➋），复制一份标签动画数据（➌），并隐藏所有标签（➍到➎）。我们还将`step`变量重置为`0`（➏）。
- en: The third block is a completely new block that animates the labels.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个代码块是一个全新的块，它负责动画化标签。
- en: '[PRE88]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This block looks at the first element in the `labelAnimation` array, if one
    exists. If the time value for that element (its `minutes` property) is the same
    as the animation step, we check to see if we need to process it. We always process
    label animations when we’re still adding the paths. If the paths are complete,
    though, we process animations only for labels that are already shown. Once we’re
    finished with the first element in `labelAnimation`, we remove it from the array
    (using the `shift()` method) and check again. We must keep checking in case multiple
    label animation actions are scheduled at the same time.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码块查看`labelAnimation`数组中的第一个元素（如果存在）。如果该元素的时间值（它的`minutes`属性）与当前动画步伐相同，我们检查是否需要处理它。我们总是在添加路径时处理标签动画。如果路径已经完成，我们只处理那些已经显示的标签的动画。一旦我们完成了`labelAnimation`数组中的第一个元素，就会将其从数组中移除（使用`shift()`方法）并再次检查。我们必须继续检查，以防多个标签动画操作同时安排。
- en: The preceding code explains a couple of things about our label animation preparation.
    First, because we sorted the label animation, we only need to look at the first
    element in that array. That’s much more efficient than searching through the entire
    array. Secondly, because we’re working with a copy of the label animation array
    instead of the original, it’s safe to remove elements once we finish processing
    them.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码解释了我们在标签动画准备过程中做的几件事。首先，由于我们已经对标签动画进行了排序，因此只需要查看该数组中的第一个元素。这比在整个数组中查找更高效。其次，由于我们处理的是标签动画数组的副本，而非原始数组，因此一旦完成处理，可以安全地移除元素。
- en: Now that we’ve handled all the label animations, we can return to the polyline
    paths. As long as there are still paths to animate, we add them to the map as
    before.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了所有标签动画，可以回到折线路径。如果仍然有路径需要动画，我们会像之前一样将其添加到地图上。
- en: '[PRE89]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The final code block in our animation step function is the same as before. We
    return an indication of whether the animation is complete.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画步骤函数中的最后一个代码块与之前相同。我们返回一个指示动画是否完成的标志。
- en: '[PRE90]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: There’s one more improvement we can make to the animation, in this case with
    a judicious bit of CSS. Because we use the `opacity` property to change the status
    of the labels, we can define a CSS transition for that property that will make
    any changes less abrupt.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对动画进行另一个改进，这次是通过巧妙地使用CSS。因为我们使用`opacity`属性来改变标签的状态，我们可以为该属性定义一个CSS过渡效果，使任何变化都不那么突兀。
- en: '[PRE91]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: To accommodate all popular browsers, we use appropriate vendor prefixes, but
    the effect of the rule is consistent. Whenever the browser changes the opacity
    of elements within a `leaflet-label` class, it will ease the transition in and
    out over a 500-millisecond period. This transition prevents the label animations
    from distracting users too much from the path animation that is the visualization’s
    main effect.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了兼容所有主流浏览器，我们使用了适当的厂商前缀，但规则的效果是一致的。每当浏览器改变`leaflet-label`类中元素的透明度时，它都会在500毫秒的时间内逐渐过渡。这种过渡效果可以防止标签动画过于分散用户的注意力，从而影响作为可视化主要效果的路径动画。
- en: 'Step 11: Add a Title'
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第11步：添加标题
- en: To complete the visualization, all we need is a title and a bit of explanation.
    We can build the title as a Leaflet control, much as we did for the animation
    control. The code to do this is quite straightforward.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成可视化，我们只需要一个标题和一点解释。我们可以像构建动画控制一样，构建一个标题作为Leaflet控制项。实现这个的代码非常简单。
- en: '[PRE92]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We provide a default position in the top left of the map (➊) and accept a title
    string as an initialization parameter (➋). At ➌, we make it so that title string
    becomes the `innerHTML` of the control when we add it to the map.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在地图的左上角提供了一个默认位置（➊），并接受一个标题字符串作为初始化参数（➋）。在➌时，我们将标题字符串设置为控制项的`innerHTML`，当我们将其添加到地图时。
- en: Now we can use the following code to create a title object with our desired
    content and immediately add it to the map. Here’s a simple implementation; [Figure 6-13](ch06.html#maps_built_in_the_browser_with_a_map_lib
    "Figure 6-13. Maps built in the browser with a map library can use interactivity
    to build interest.") includes some extra information.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下代码来创建一个带有所需内容的标题对象，并立即将其添加到地图中。这里是一个简单的实现；[图 6-13](ch06.html#maps_built_in_the_browser_with_a_map_lib
    "图 6-13. 通过地图库在浏览器中构建的地图可以利用交互性来增加兴趣。") 包含了一些额外的信息。
- en: '[PRE93]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: To set the title’s appearance, we can define CSS rules for children of the `leaflet-control-title`
    class.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置标题的外观，我们可以为 `leaflet-control-title` 类的子元素定义 CSS 规则。
- en: At this point, we have the interactive visualization of the two train routes
    in [Figure 6-13](ch06.html#maps_built_in_the_browser_with_a_map_lib "Figure 6-13. Maps
    built in the browser with a map library can use interactivity to build interest.").
    Users can clearly see that the Southerner has a quicker route from Washington
    to Atlanta.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经在[图 6-13](ch06.html#maps_built_in_the_browser_with_a_map_lib "图 6-13.
    通过地图库在浏览器中构建的地图可以利用交互性来增加兴趣。")中实现了两条火车路线的交互式可视化。用户可以清楚地看到，南方路线从华盛顿到亚特兰大的时间更短。
- en: '![Maps built in the browser with a map library can use interactivity to build
    interest.](figs/web/06fig13.png.jpg)Figure 6-13. Maps built in the browser with
    a map library can use interactivity to build interest.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '![通过地图库在浏览器中构建的地图可以利用交互性来增加兴趣。](figs/web/06fig13.png.jpg)图 6-13. 通过地图库在浏览器中构建的地图可以利用交互性来增加兴趣。'
- en: Summing Up
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小结
- en: In this chapter, we’ve looked at several visualizations based on maps. In the
    first two examples, geographic regions were the main subjects of the visualization,
    and we built choropleth maps to compare and contrast those regions. Map fonts
    are quick and convenient, but only if they’re available for the regions the visualization
    needs. Although it usually takes more effort, we have far more control over the
    map regions if we use SVGs to create our own custom maps. Unlike other image formats,
    SVG can be easily manipulated in a web page with just CSS and JavaScript. This
    chapter also looked at examples based on traditional mapping libraries. Mapping
    libraries are especially convenient when your data sets include latitude and longitude
    values, as the libraries take care of the complicated mathematics required to
    position those points on a two-dimensional projection. As we saw, some libraries
    are relatively simple yet perfectly capable of mapping a data set. Full-featured
    libraries such as Leaflet offer much more power and customization, and we relied
    on that extensibility for a custom, animated map.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了几种基于地图的可视化方法。在前两个例子中，地理区域是可视化的主要对象，我们构建了等值线地图来对比和对照这些区域。地图字体非常快捷和方便，但仅限于可视化所需的区域存在的情况下。虽然通常需要更多的努力，但如果使用
    SVG 来创建自定义地图，我们对地图区域有更大的控制权。与其他图像格式不同，SVG 可以通过简单的 CSS 和 JavaScript 在网页中轻松操作。本章还展示了基于传统地图绘制库的例子。当数据集包含经纬度值时，地图绘制库特别方便，因为它们处理了将这些点定位到二维投影所需的复杂数学计算。正如我们所看到的，一些库相对简单，但仍完全能够绘制数据集。像
    Leaflet 这样的功能全面的库提供了更多的功能和自定义选项，我们依赖这些扩展性来创建一个自定义的动态地图。
