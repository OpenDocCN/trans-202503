["```\n$ `ls | wc -l`\n```", "```\n#include <unistd.h>\n\nint `pipe`(int *filedes*[2]);\n```", "```\nint filedes[2];\n\n    if (pipe(filedes) == -1)                    /* Create the pipe */\n        errExit(\"pipe\");\n\n    switch (fork()) {                           /* Create a child process */\n    case -1:\n        errExit(\"fork\");\n\n    case 0:  /* Child */\n        if (close(filedes[1]) == -1)            /* Close unused write end */\n            errExit(\"close\");\n\n        /* Child now reads from pipe */\n        break;\n\n    default: /* Parent */\n        if (close(filedes[0]) == -1)            /* Close unused read end */\n            errExit(\"close\");\n\n        /* Parent now writes to pipe */\n        break;\n    }\n```", "```\n$ `./simple_pipe 'It was a bright cold day in April, '\\`\n`'and the clocks were striking thirteen.'`\nIt was a bright cold day in April, and the clocks were striking thirteen.\n```", "```\n`pipes/simple_pipe.c`\n    #include <sys/wait.h>\n    #include \"tlpi_hdr.h\"\n\n    #define BUF_SIZE 10\n\n    int\n    main(int argc, char *argv[])\n    {\n        int pfd[2];                             /* Pipe file descriptors */\n        char buf[BUF_SIZE];\n        ssize_t numRead;\n\n        if (argc != 2 || strcmp(argv[1], \"--help\") == 0)\n            usageErr(\"%s string\\n\", argv[0]);\n\n    if (pipe(pfd) == -1)                    /* Create the pipe */\n            errExit(\"pipe\");\n\n    switch (fork()) {xs\n        case -1:\n            errExit(\"fork\");\n\n        case 0:             /* Child  - reads from pipe */\n        if (close(pfd[1]) == -1)            /* Write end is unused */\n                errExit(\"close - child\");\n\n            for (;;) {              /* Read data from pipe, echo on stdout */\n            numRead = read(pfd[0], buf, BUF_SIZE);\n                if (numRead == -1)\n                    errExit(\"read\");\n            if (numRead == 0)\n                    break;                      /* End-of-file */\n            if (write(STDOUT_FILENO, buf, numRead) != numRead)\n                    fatal(\"child - partial/failed write\");\n            }\n\n        write(STDOUT_FILENO, \"\\n\", 1);\n            if (close(pfd[0]) == -1)\n                errExit(\"close\");\n            _exit(EXIT_SUCCESS);\n\n        default:            /* Parent - writes to pipe */\n        if (close(pfd[0]) == -1)            /* Read end is unused */\n                errExit(\"close - parent\");\n\nif (write(pfd[1], argv[1], strlen(argv[1])) != strlen(argv[1]))\n                fatal(\"parent - partial/failed write\");\n\n        if (close(pfd[1]) == -1)            /* Child will see EOF */\n                errExit(\"close\");\n        wait(NULL);                         /* Wait for child to finish */\n            exit(EXIT_SUCCESS);\n        }\n    }\n         `pipes/simple_pipe.c`\n```", "```\n$ `./pipe_sync 4 2 6`\n08:22:16  Parent started\n08:22:18  Child 2 (PID=2445) closing pipe\n08:22:20  Child 1 (PID=2444) closing pipe\n08:22:22  Child 3 (PID=2446) closing pipe\n08:22:22  Parent ready to go\n```", "```\n`pipes/pipe_sync.c`\n    #include \"curr_time.h\"                      /* Declaration of currTime() */\n    #include \"tlpi_hdr.h\"\n\n    int\n    main(int argc, char *argv[])\n    {\n        int pfd[2];                             /* Process synchronization pipe */\n        int j, dummy;\n\n            if (argc < 2 || strcmp(argv[1], \"--help\") == 0)\n            usageErr(\"%s sleep-time...\\n\", argv[0]);\n\n        setbuf(stdout, NULL);                   /* Make stdout unbuffered, since we\n                                                   terminate child with _exit() */\n        printf(\"%s  Parent started\\n\", currTime(\"%T\"));\n\n    if (pipe(pfd) == -1)\n            errExit(\"pipe\");\n\n        for (j = 1; j < argc; j++) {\n        switch (fork()) {\n            case -1:\n                errExit(\"fork %d\", j);\n\n            case 0: /* Child */\n                if (close(pfd[0]) == -1)        /* Read end is unused */\n                    errExit(\"close\");\n\n                /* Child does some work, and lets parent know it's done */\n\n                sleep(getInt(argv[j], GN_NONNEG, \"sleep-time\"));\n                                                /* Simulate processing */\n                printf(\"%s  Child %d (PID=%ld) closing pipe\\n\",\n                        currTime(\"%T\"), j, (long) getpid());\n            if (close(pfd[1]) == -1)\n                    errExit(\"close\");\n\n                /* Child now carries on to do other things... */\n\n                _exit(EXIT_SUCCESS);\n\n            default: /* Parent loops to create next child */\n                break;\n            }\n        }\n\n        /* Parent comes here; close write end of pipe so we can see EOF */\n\n    if (close(pfd[1]) == -1)                /* Write end is unused */\n            errExit(\"close\");\n\n        /* Parent may do other work, then synchronizes with children */\n\n    if (read(pfd[0], &dummy, 1) != 0)\n            fatal(\"parent didn't get EOF\");\n        printf(\"%s  Parent ready to go\\n\", currTime(\"%T\"));\n\n        /* Parent can now carry on to do other things... */\n\n        exit(EXIT_SUCCESS);\n    }\n          `pipes/pipe_sync.c`\n```", "```\nint pfd[2];\n\npipe(pfd);          /* Allocates (say) file descriptors 3 and 4 for pipe */\n\n/* Other steps here, e.g., fork() */\n\nclose(STDOUT_FILENO);           /* Free file descriptor 1 */\ndup(pfd[1]);                    /* Duplication uses lowest free file\n                                   descriptor, i.e., fd 1 */\n```", "```\ndup2(pfd[1], STDOUT_FILENO);    /* Close descriptor 1, and reopen bound\n                                   to write end of pipe */\n```", "```\nclose(pfd[1]);\n```", "```\ndup2(1, 1);         /* Does nothing */\nclose(1);           /* Closes sole descriptor for write end of pipe */\n```", "```\nif (pfd[1] != STDOUT_FILENO) {\n    dup2(pfd[1], STDOUT_FILENO);\n    close(pfd[1]);\n}\n```", "```\n`pipes/pipe_ls_wc.c`\n#include <sys/wait.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int pfd[2];                                     /* Pipe file descriptors */\n\n    if (pipe(pfd) == -1)                            /* Create pipe */\n        errExit(\"pipe\");\n\n    switch (fork()) {\n    case -1:\n        errExit(\"fork\");\n\n    case 0:             /* First child: exec 'ls' to write to pipe */\n        if (close(pfd[0]) == -1)                    /* Read end is unused */\n            errExit(\"close 1\");\n\n        /* Duplicate stdout on write end of pipe; close duplicated descriptor */\n\n        if (pfd[1] != STDOUT_FILENO) {              /* Defensive check */\n            if (dup2(pfd[1], STDOUT_FILENO) == -1)\n                errExit(\"dup2 1\");\n            if (close(pfd[1]) == -1)\n                errExit(\"close 2\");\n        }\n\n        execlp(\"ls\", \"ls\", (char *) NULL);          /* Writes to pipe */\n        errExit(\"execlp ls\");\n\n    default:            /* Parent falls through to create next child */\n        break;\n    }\n\n    switch (fork()) {\n    case -1:\n        errExit(\"fork\");\n\n    case 0:             /* Second child: exec 'wc' to read from pipe */\n        if (close(pfd[1]) == -1)                    /* Write end is unused */\n            errExit(\"close 3\");\n\n        /* Duplicate stdin on read end of pipe; close duplicated descriptor */\n\n        if (pfd[0] != STDIN_FILENO) {               /* Defensive check */\n            if (dup2(pfd[0], STDIN_FILENO) == -1)\n                errExit(\"dup2 2\");\n            if (close(pfd[0]) == -1)\n                errExit(\"close 4\");\n        }\n\n        execlp(\"wc\", \"wc\", \"-l\", (char *) NULL);    /* Reads from pipe */\n        errExit(\"execlp wc\");\n\n    default:            /* Parent falls through */\n        break;\n    }\n\n    /* Parent closes unused file descriptors for pipe, and waits for children */\n\n    if (close(pfd[0]) == -1)\n        errExit(\"close 5\");\n    if (close(pfd[1]) == -1)\n        errExit(\"close 6\");\n    if (wait(NULL) == -1)\n        errExit(\"wait 1\");\n    if (wait(NULL) == -1)\n        errExit(\"wait 2\");\n\n    exit(EXIT_SUCCESS);\n}\n     `pipes/pipe_ls_wc.c`\n```", "```\n$ `./pipe_ls_wc`\n     24\n$ `ls | wc -l`                    *Verify the results using shell commands*\n     24\n```", "```\n#include <stdio.h>\n\nFILE *`popen`(const char **command*, const char **mode*);\n```", "```\nint `pclose`(FILE **stream*);\n```", "```\n`pipes/popen_glob.c`\n    #include <ctype.h>\n    #include <limits.h>\n    #include \"print_wait_status.h\"          /* For printWaitStatus() */\n    #include \"tlpi_hdr.h\"\n\n#define POPEN_FMT \"/bin/ls -d %s 2> /dev/null\"\n    #define PAT_SIZE 50\n    #define PCMD_BUF_SIZE (sizeof(POPEN_FMT) + PAT_SIZE)\n\n    int\n    main(int argc, char *argv[])\n    {\n        char pat[PAT_SIZE];                 /* Pattern for globbing */\n        char popenCmd[PCMD_BUF_SIZE];\n        FILE *fp;                           /* File stream returned by popen() */\n        Boolean badPattern;                 /* Invalid characters in 'pat'? */\n        int len, status, fileCnt, j;\n        char pathname[PATH_MAX];\n\n        for (;;) {                  /* Read pattern, display results of globbing */\n            printf(\"pattern: \");\n            fflush(stdout);\n        if (fgets(pat, PAT_SIZE, stdin) == NULL)\n                break;                      /* EOF */\n            len = strlen(pat);\n            if (len <= 1)                   /* Empty line */\n                continue;\n\n            if (pat[len - 1] == '\\n')       /* Strip trailing newline */\n                pat[len - 1] = '\\0';\n\n            /* Ensure that the pattern contains only valid characters,\n               i.e., letters, digits, underscore, dot, and the shell\n               globbing characters. (Our definition of valid is more\n               restrictive than the shell, which permits other characters\n               to be included in a filename if they are quoted.) */\n\n        for (j = 0, badPattern = FALSE; j < len && !badPattern; j++)\n                if (!isalnum((unsigned char) pat[j]) &&\n                        strchr(\"_*?[^-].\", pat[j]) == NULL)\n                    badPattern = TRUE;\n\n            if (badPattern) {\n                printf(\"Bad pattern character: %c\\n\", pat[j - 1]);\n                continue;\n            }\n\n            /* Build and execute command to glob 'pat' */\n\n        snprintf(popenCmd, PCMD_BUF_SIZE, POPEN_FMT, pat);\n            popenCmd[PCMD_BUF_SIZE - 1] = '\\0';     /* Ensure string is\n                                                       null-terminated */\n            fp = popen(popenCmd, \"r\");\n            if (fp == NULL) {\n                printf(\"popen() failed\\n\");\n                continue;\n            }\n\n            /* Read resulting list of pathnames until EOF */\n\n            fileCnt = 0;\n            while (fgets(pathname, PATH_MAX, fp) != NULL) {\n                printf(\"%s\", pathname);\n                fileCnt++;\n            }\n\n            /* Close pipe, fetch and display termination status */\n\n            status = pclose(fp);\n            printf(\"    %d matching file%s\\n\", fileCnt, (fileCnt != 1) ? \"s\" : \"\");\n            printf(\"    pclose() status == %#x\\n\", (unsigned int) status);\n            if (status != -1)\n                printWaitStatus(\"\\t\", status);\n        }\n\n        exit(EXIT_SUCCESS);\n    }\n         `pipes/popen_glob.c`\n```", "```\n$ `./popen_glob`\npattern: `popen_glob*`                          *Matches two filenames*\npopen_glob\npopen_glob.c\n    2 matching files\n    pclose() status = 0\n        child exited, status=0\npattern: `x*`                                   *Matches no filename*\n    0 matching files\n    pclose() status = 0x100                   *ls(1)* *exits with status 1*\n        child exited, status=1\npattern: `^D`$                                  *Type Control-D to terminate*\n```", "```\npattern: `; rm *`\n```", "```\n/bin/ls -d ; rm * 2> /dev/null\n```", "```\n$ `mkfifo` [`-m` ``*`mode`*``] ``*`pathname`*``\n```", "```\n#include <sys/stat.h>\n\nint `mkfifo`(const char **pathname*, mode_t *mode*);\n```", "```\n$ `mkfifo myfifo`\n$ `wc -l < myfifo &`\n$ `ls -l | tee myfifo | sort -k5n`\n*(Resulting output not shown)*\n```", "```\n`pipes/fifo_seqnum.h`\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"tlpi_hdr.h\"\n\n#define SERVER_FIFO \"/tmp/seqnum_sv\"\n                                /* Well-known name for server's FIFO */\n#define CLIENT_FIFO_TEMPLATE \"/tmp/seqnum_cl.%ld\"\n                                /* Template for building client FIFO name */\n#define CLIENT_FIFO_NAME_LEN (sizeof(CLIENT_FIFO_TEMPLATE) + 20)\n                                /* Space required for client FIFO pathname\n                                   (+20 as a generous allowance for the PID) */\n\nstruct request {                /* Request (client --> server) */\n    pid_t pid;                  /* PID of client */\n    int seqLen;                 /* Length of desired sequence */\n};\n\nstruct response {               /* Response (server --> client) */\n    int seqNum;                 /* Start of sequence */\n};\n     `pipes/fifo_seqnum.h`\n```", "```\n`pipes/fifo_seqnum_server.c`\n    #include <signal.h>\n    #include \"fifo_seqnum.h\"\n\n    int\n    main(int argc, char *argv[])\n    {\n        int serverFd, dummyFd, clientFd;\n        char clientFifo[CLIENT_FIFO_NAME_LEN];\n        struct request req;\n        struct response resp;\n        int seqNum = 0;                     /* This is our \"service\" */\n\n            /* Create well-known FIFO, and open it for reading */\n\n        umask(0);                           /* So we get the permissions we want */\n    if (mkfifo(SERVER_FIFO, S_IRUSR | S_IWUSR | S_IWGRP) == -1\n                && errno != EEXIST)\n            errExit(\"mkfifo %s\", SERVER_FIFO);\n    serverFd = open(SERVER_FIFO, O_RDONLY);\n        if (serverFd == -1)\n            errExit(\"open %s\", SERVER_FIFO);\n\n        /* Open an extra write descriptor, so that we never see EOF */\n\n    dummyFd = open(SERVER_FIFO, O_WRONLY);\n        if (dummyFd == -1)\n            errExit(\"open %s\", SERVER_FIFO);\n\n    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)\n            errExit(\"signal\");\n\n    for (;;) {                          /* Read requests and send responses */\n            if (read(serverFd, &req, sizeof(struct request))\n                    != sizeof(struct request)) {\n                fprintf(stderr, \"Error reading request; discarding\\n\");\n                continue;                   /* Either partial read or error */\n            }\n\n            /* Open client FIFO (previously created by client) */\n\n        snprintf(clientFifo, CLIENT_FIFO_NAME_LEN, CLIENT_FIFO_TEMPLATE,\n                    (long) req.pid);\n        clientFd = open(clientFifo, O_WRONLY);\n            if (clientFd == -1) {           /* Open failed, give up on client */\n                errMsg(\"open %s\", clientFifo);\n            continue;\n            }\n\n            /* Send response and close FIFO */\n\n            resp.seqNum = seqNum;\n            if (write(clientFd, &resp, sizeof(struct response))\n                    != sizeof(struct response))\n                fprintf(stderr, \"Error writing to FIFO %s\\n\", clientFifo);\n            if (close(clientFd) == -1)\n                errMsg(\"close\");\n\n            seqNum += req.seqLen;           /* Update our sequence number */\n        }\n    }\n         `pipes/fifo_seqnum_server.c`\n```", "```\n$ `./fifo_seqnum_server &`\n[1] 5066\n$ `./fifo_seqnum_client 3`                *Request a sequence of three numbers*\n0                                       *Assigned sequence begins at 0*\n$ `./fifo_seqnum_client 2`                *Request a sequence of two numbers*\n3                                       *Assigned sequence begins at 3*\n$ `./fifo_seqnum_client`                  *Request a single number*\n5\n```", "```\n`pipes/fifo_seqnum_client.c`\n    #include \"fifo_seqnum.h\"\n\n    static char clientFifo[CLIENT_FIFO_NAME_LEN];\n\n    static void             /* Invoked on exit to delete client FIFO */\nremoveFifo(void)\n    {\n        unlink(clientFifo);\n    }\n\n    int\n    main(int argc, char *argv[])\n    {\n        int serverFd, clientFd;\n        struct request req;\n        struct response resp;\n\n            if (argc > 1 && strcmp(argv[1], \"--help\") == 0)\n            usageErr(\"%s [seq-len...]\\n\", argv[0]);\n\n        /* Create our FIFO (before sending request, to avoid a race) */\n\n        umask(0);                   /* So we get the permissions we want */\n    snprintf(clientFifo, CLIENT_FIFO_NAME_LEN, CLIENT_FIFO_TEMPLATE,\n                (long) getpid());\n        if (mkfifo(clientFifo, S_IRUSR | S_IWUSR | S_IWGRP) == -1\n                    && errno != EEXIST)\n            errExit(\"mkfifo %s\", clientFifo);\n\n    if (atexit(removeFifo) != 0)\n            errExit(\"atexit\");\n\n        /* Construct request message, open server FIFO, and send request */\n\n    req.pid = getpid();\n        req.seqLen = (argc > 1) ? getInt(argv[1], GN_GT_0, \"seq-len\") : 1;\n\n    serverFd = open(SERVER_FIFO, O_WRONLY);\n        if (serverFd == -1)\n            errExit(\"open %s\", SERVER_FIFO);\n\n    if (write(serverFd, &req, sizeof(struct request)) !=\n                sizeof(struct request))\n            fatal(\"Can't write to server\");\n\n        /* Open our FIFO, read and display response */\n\n    clientFd = open(clientFifo, O_RDONLY);\n        if (clientFd == -1)\n            errExit(\"open %s\", clientFifo);\n\n    if (read(clientFd, &resp, sizeof(struct response))\n                != sizeof(struct response))\n            fatal(\"Can't read response from server\");\n\n        printf(\"%d\\n\", resp.seqNum);\n        exit(EXIT_SUCCESS);\n    }\n         `pipes/fifo_seqnum_client.c`\n```", "```\nfd = open(\"fifopath\", O_RDONLY | O_NONBLOCK);\nif (fd == -1)\n    errExit(\"open\");\n```", "```\nint flags;\n\nflags = fcntl(fd, F_GETFL);       /* Fetch open files status flags */\nflags |= O_NONBLOCK;              /* Enable O_NONBLOCK bit */\nfcntl(fd, F_SETFL, flags);        /* Update open files status flags */\n```", "```\nflags = fcntl(fd, F_GETFL);\nflags &= ~O_NONBLOCK;             /* Disable O_NONBLOCK bit */\nfcntl(fd, F_SETFL, flags);\n```"]