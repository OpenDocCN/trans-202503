- en: '**14'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: INSIDE SUBFUNCTIONS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg297_Image_276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Good engineering practice generally includes breaking problems down into functionally
    distinct subproblems. In software, this approach leads to programs with many functions,
    each of which solves a subproblem.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of this *divide and conquer* approach is that it’s usually
    easier to solve a small subproblem than the overall problem. Another advantage
    is that previous solutions to subproblems are often reusable, as we have demonstrated
    by using functions from the C standard library. We can also save development time
    by having several people work on different parts of the overall problem simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: When breaking down a problem like this, it’s important to coordinate the many
    partial solutions so that they work together to provide a correct overall solution.
    In software, this translates to making sure the data interface between a calling
    function and a called function works correctly. To ensure correct operation of
    the interface, it must be explicitly specified. In this chapter, I’ll show you
    how to do that. I’ll first show you how to place data items in a global location
    so that all the functions in the program can have direct access to them. Then
    I’ll cover restricting the passage of data items as arguments to a function, which
    gives us better control over the data the function works with.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, you learned how to pass arguments to a function in
    registers. In this chapter, you’ll learn how to store these arguments in memory
    so the registers can be reused inside the called function. You’ll also learn how
    to pass more arguments to a function than can be done with the eight registers
    specified in [Table 11-3](ch11.xhtml#ch11tab3) in [Chapter 11](ch11.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I’ll discuss in more detail the creation of variables within a function.
    I’ll cover variables that exist only when program flow is in the function, as
    well as variables that stay in memory for the duration of the program but are
    accessible only within their defining function.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into the inner workings of functions, however, let’s take a look
    at some of the rules that govern the use of variable names in C.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scope of Variable Names in C**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Scope* refers to the places in our code where a variable’s name is *visible*,
    meaning we can use that name. This is not a book on C, so I won’t cover all the
    rules of where variable names can be used in a program, but I’ll explain enough
    to help you understand the basic concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: In C, a *declaration* of a variable introduces its name and data type into the
    current scope. A *definition* of a variable is a declaration that also allocates
    memory for the variable. A variable can be defined in only one place in a program,
    but as you’ll see in “Global Variables” on [page 271](ch14.xhtml#ch14lev1sec3),
    it might be declared in more than one scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables that are defined inside a function definition are called *local variables*,
    and names declared in a function’s parameter list are called *formal parameters*.
    Both local variables and formal parameters have *function scope*: their scope
    extends from the point of declaration to the end of the function.'
  prefs: []
  type: TYPE_NORMAL
- en: A *block* in C is a group of C statements enclosed in a matched pair of curly
    brackets, `{}`. The scope of variables defined inside a block extends from the
    point of definition to the end of that block, including any enclosed blocks. This
    is *block scope*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *function prototype* is only a declaration of the function, not its definition.
    It includes the name of the function, the data types of any parameters passed
    to the function, and the return data type. The parameters don’t need to be named
    in the prototype, but doing so provides some documentation within the prototype
    itself. The scope of a parameter name in a prototype declaration is limited to
    its own prototype. This limit allows us to use the same names in different function
    prototypes. For example, the C standard library includes functions for computing
    sine and cosine, whose prototypes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can use both function prototypes in the same function without having to use
    different names for the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Before looking at the final kind of scope, file scope, I’ll give you a brief
    overview of the reasons for passing arguments to a function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Overview of Passing Arguments**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Input and output are relative to our point of view. As you read through this
    section, be careful to distinguish between data input from and data output to
    a calling function and data input from and data output to a user of the program.
    In this chapter, we’re looking at inputs to a function that come from and outputs
    that go to other functions in the program. We’ll look at program inputs from and
    outputs to I/O devices in [Chapter 20](ch20.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the difference, consider this C program statement (from [Listing
    2-1](ch02.xhtml#ch2list1) in [Chapter 2](ch02.xhtml)), which is used to input
    an integer from the keyboard, an I/O device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `scanf` function has one data input from the `main` function: the address
    of the formatting text string, `"%x"`. The `scanf` function reads user data that
    is input from the keyboard and outputs data, an unsigned integer, to the `an_int`
    variable in the `main` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions can interact with the data in other parts of the program in four
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Direct** Data that is global to the program can be directly accessed from
    any function in the program.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input** The data comes from another part of the program and is used by the
    function, but the original copy is not modified.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Output** The function provides new data to another part of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Update** The function modifies a data item that is held by another part of
    the program. The new value is based on the value before the function was called.'
  prefs: []
  type: TYPE_NORMAL
- en: All four interactions can be performed if the called function also knows the
    location of the data item, but this exposes the original copy of the data and
    allows it to be changed even if it’s intended to be used only as input to the
    called function.
  prefs: []
  type: TYPE_NORMAL
- en: We can output data from a function by placing the output in a globally known
    location, such as a register or a globally known address. We can also pass the
    called function the address of the place to store the output. Updates require
    the called function to know the address of the data being updated.
  prefs: []
  type: TYPE_NORMAL
- en: To see how this works, we’ll start by looking at how global variables are created
    and how they are accessed in a subfunction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Global Variables**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Global variables* are defined outside any functions and have *file scope*,
    which means they can be accessed from the point of their definition to the end
    of the file. Global variables can also be accessed from another file by declaring
    them with the `extern` modifier. Using `extern` only introduces the name and data
    type of the variable into the scope of the declaration, without allocating memory
    for it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-1](ch14.xhtml#ch14list1) shows how to define global variables.'
  prefs: []
  type: TYPE_NORMAL
- en: '*sum_ints_global.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-1: A* main *function that uses three global variables*'
  prefs: []
  type: TYPE_NORMAL
- en: Placing the definitions of the variables `x`, `y`, and `z` outside the function
    body makes them global ❶. The first two variables are initialized, but not the
    third. I’ll show you how the compiler treats the difference.
  prefs: []
  type: TYPE_NORMAL
- en: This `main` function calls the `add_two` function, which will add `x` and `y`
    and store the sum in `z`. [Listing 14-2](ch14.xhtml#ch14list2) shows the assembly
    language produced by the compiler for this `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: '*sum_ints_global.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-2: The compiler-generated assembly language for the function in
    [Listing 14-1](ch14.xhtml#ch14list1)*'
  prefs: []
  type: TYPE_NORMAL
- en: I don’t know why the compiler added the first `.text` directive ❶, but it’s
    not needed. Its effect is immediately overridden by the `.data` assembler directive,
    which switches us to the data segment ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The `.word` directive allocates a word (4 bytes) of memory and initializes it
    to the value of the argument, which is the integer 123 here ❸. The `.bss` assembler
    directive then switches us to a *block starting symbol* section, which will be
    located in the data segment when the program is loaded into memory for execution
    ❹. Each label defined in a `.bss` section will name the start of an uninitialized
    block of memory. Only the size of each labeled block is stored in the program’s
    executable file, thus making the file smaller.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux operating system initializes all the bytes in memory in a `.bss` section
    to 0 when the program is loaded, but your algorithm should not depend on the variables
    there being 0 unless they are explicitly set to 0 in your source code.
  prefs: []
  type: TYPE_NORMAL
- en: The `.size` assembler directive associates a label with a number of bytes in
    its block ❺. The `z` label is for a 4-byte variable in this program. Although
    `z` is not initialized in our C code, and the `.bss` segment will be set to 0
    when the program is loaded, the compiler has used the `.zero` assembler directive,
    which specifies 4 bytes of memory, each set to 0 here ❻. The `.skip` directive
    would have the same effect as a `.zero` directive in a `.bss` section. Since we
    are in a `.bss` segment, the assembler does not store the 4 zero bytes in the
    object file.
  prefs: []
  type: TYPE_NORMAL
- en: The variables are defined in this file, so the compiler uses the `adrp`/`add`
    two-instruction sequence to load their addresses ❼.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at `add_two`. First, we need a header file for the function.
    This is shown in [Listing 14-3](ch14.xhtml#ch14list3).
  prefs: []
  type: TYPE_NORMAL
- en: '*add_two_global.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-3: The header file for the* add_two *function using global variables.*'
  prefs: []
  type: TYPE_NORMAL
- en: Header files are used to declare a function prototype, which can be declared
    only once in a C source code file ❸. A header file can include other header files,
    some of which could include the original header file, leading to a function prototype
    being declared more than once. To guard against this, we define an identifier
    that is a stylized version of the header file’s name ❷.
  prefs: []
  type: TYPE_NORMAL
- en: We start with an `#ifndef` assembler directive to check if this identifier has
    already been defined ❶. If not, the contents of the file up to the end of the
    `#endif` directive are included, defining the filename identifier and declaring
    the function prototype. The check for the filename identifier in any subsequent
    inclusions of this header file will then show that the identifier has been defined,
    so the preprocessor will skip down to the `#endif` and avoid declaring the function
    prototype again.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-4](ch14.xhtml#ch14list4) shows the definition of the `add_two`
    function using global variables.'
  prefs: []
  type: TYPE_NORMAL
- en: '*add_two_global.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-4: The* add_two *function using global variables*'
  prefs: []
  type: TYPE_NORMAL
- en: The header file for a function should be included in the file where the function
    is defined to make sure the function prototype in the header file matches the
    definition ❶. The global variables are defined in only one place, but they need
    to be declared in any other file that uses them ❷.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-5](ch14.xhtml#ch14list5) shows the assembly language generated
    by the compiler for the `add_two` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*add_two_global.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-5: The compiler-generated assembly language for the function in
    [Listing 14-4](ch14.xhtml#ch14list4)*'
  prefs: []
  type: TYPE_NORMAL
- en: The `add_two` function declares the `x`, `y`, and `z` variables with an `extern`
    storage class specifier so it can access them, but it needs to use a different
    technique to load the addresses because they are defined in another file. The
    loader stores the addresses of the global variables in the global offset table
    (GOT), introduced in “The Linker” on [page 239](ch12.xhtml#ch12lev2sec7), when
    the program is loaded into memory for execution. The `:got:` operand modifier
    tells the loader to use the GOT containing the address of the variable when filling
    in the page offset from the `adrp` instruction ❶.
  prefs: []
  type: TYPE_NORMAL
- en: The `ldr` instruction here is using the page address of the GOT, in `x0`, for
    its base address ❷. The `:got_lo12:` operand modifier tells the loader to use
    the low-order 12 bits of the offset to where the variable’s address is stored
    in the GOT, thus overwriting the page address of the GOT with the variable’s address
    in `x0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-5](ch14.xhtml#ch14list5) also contains a new instruction, the `nop`
    (pronounced “no-op”) ❸. It has no effect on the algorithm. The manual says it’s
    used for instruction alignment purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: nop**—No operation**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`nop` adds 4 to the program counter with no other effect.'
  prefs: []
  type: TYPE_NORMAL
- en: Although global variables are simple to work with in small programs, managing
    them is unwieldy in large programs. You need to keep track of exactly what each
    function in the program is doing with the global variables. Managing variables
    is much easier if you define them within a function and pass only what is needed
    to each subfunction. In the next section, I’ll show you how to maintain control
    over what gets passed to and from a subfunction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Explicitly Passing Arguments**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we restrict each function to using only those variables it needs, it’s
    much easier to isolate the inner workings of a function from other functions.
    This is a principle called *information hiding*. It means that you, the programmer,
    need to deal with only those variables and constants that a subfunction needs
    to do its specific job. Of course, most subfunctions will need to interact with
    some of the variables in their calling functions in one way or another. In this
    section, we’ll look at how a function uses the arguments explicitly passed to
    it to accept input, produce output, or update a variable.
  prefs: []
  type: TYPE_NORMAL
- en: When a value serves only as input to the called function, we can pass a copy
    of the value to the called function. This is called *passing by value*. Passing
    by value prevents the called function from changing the value in the calling function.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving output from the called function is a bit more complex. One way to
    accomplish this is to use a *return value*, which in our environment is placed
    in the `w0` register. Using the `w0` register assumes the return value is an `int`.
    This technique is used in most of the example programs in this book. The `main`
    function almost always returns a 0 to the function in the operating system that
    called it. There are other rules for returning larger values, which we won’t go
    into in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The other techniques for the calling function to receive an output from the
    called function require that the calling function pass the called function the
    address of the place to store the output. This can be implemented in higher-level
    languages as either *pass by pointer* or *pass by reference*. The difference is
    that with pass by pointer, the program can change the pointer to point to another
    object, while with pass by reference, the program cannot change the pointer. C
    and C++ both support pass by pointer, but only C++ supports pass by reference.
    These are the same at the assembly language level; the address of the place to
    store the output is passed to the called function. The difference is enforced
    by the high-level language.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll learn how C controls access to its local variables.
  prefs: []
  type: TYPE_NORMAL
- en: '***In C***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, I’ll write the same program as in [Listings 14-1](ch14.xhtml#ch14list1),
    [14-3](ch14.xhtml#ch14list3), and [14-4](ch14.xhtml#ch14list4), but this time
    I’ll define the variables as local variables in the `main` function and pass them
    as arguments to the subfunction. [Listing 14-6](ch14.xhtml#ch14list6) shows the
    new version of the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: '*sum_ints.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-6: A* main *function that uses three local variables*'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the variables inside the body of the function ❶ makes them visible
    only to this function. The `add_two` function will store its result at the address
    we pass in as the first argument. We use the C address operator, `&`, to get the
    address of the `z` variable, giving `&z` ❷. The values of the `x` and `y` variables
    are inputs to the `add_two` function, so we pass copies of these variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-7](ch14.xhtml#ch14list7) shows the header file for the `add_two`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*add_two.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-7: The header file for the* add_two *function using local variables*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-8](ch14.xhtml#ch14list8) shows the definition of the `add_two`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*add_two.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-8: The* add_two *function using local variables*'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter in the argument list, `a`, is a pointer to an `int`. This
    means that `a` holds the address where we need to store the value of `sum`. To
    dereference `a`, we use the C *dereference operator*, `*`, giving `*a` ❶. This
    stores the result of the computation at the address passed in `a`.
  prefs: []
  type: TYPE_NORMAL
- en: '***In Assembly Language***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-9](ch14.xhtml#ch14list9) shows the assembly language generated
    by the compiler for the `main` function in [Listing 14-6](ch14.xhtml#ch14list6).'
  prefs: []
  type: TYPE_NORMAL
- en: '*sum_ints.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-9: The compiler-generated assembly language for the function in
    [Listing 14-6](ch14.xhtml#ch14list6)*'
  prefs: []
  type: TYPE_NORMAL
- en: All three variables are automatic local variables, so the compiler allocates
    space for them in the stack frame ❶. Initialized automatic local variables are
    newly created each time the function is called, so they need to be actively initialized
    ❷.
  prefs: []
  type: TYPE_NORMAL
- en: We pass the address of our `z` variable to the `add_two` function so it can
    store its output there ❸, and we send copies of the values in the `x` and `y`
    variables as inputs to the function ❹.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-10](ch14.xhtml#ch14list10) shows the compiler-generated assembly
    language for the `add_two` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*add_two.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-10: The compiler-generated assembly language for the function in
    [Listing 14-8](ch14.xhtml#ch14list8)*'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you might notice about this function is that it does not save
    the contents of the link register, `lr`, and frame pointer, `fp` ❶. These two
    addresses make up the *frame record*. The address in `lr` provides the link back
    to the place where this function was called, while `fp` provides a link back to
    the frame record of the calling function. This chain of frame records can be useful
    in certain error situations, but I won’t get into the details in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The AArch64 procedure call standard states that a small function that doesn’t
    call a function does not need a frame record, which explains why the compiler
    has omitted it. A function that does not call any functions is often called a
    *leaf function*.
  prefs: []
  type: TYPE_NORMAL
- en: This function simply allocates a 32-byte stack frame, where it stores the three
    items that were passed to it ❷. You can probably tell this is not needed in this
    very simple function, but it might be in more complex functions. [Figure 14-1](ch14.xhtml#ch14fig1)
    gives a pictorial view of `add_two`’s stack frame.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg308_Image_277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: The stack frame for the* add_two *function in [Listing 14-10](ch14.xhtml#ch14list10)*'
  prefs: []
  type: TYPE_NORMAL
- en: The values at `c` and `b` are inputs to this function, and `a` is the address
    where the output from the function will be stored.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-11](ch14.xhtml#ch14list11) shows how I would probably write the
    `add_two` function in assembly language.'
  prefs: []
  type: TYPE_NORMAL
- en: '*add_two.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-11: The* add_two *function written in assembly language*'
  prefs: []
  type: TYPE_NORMAL
- en: A stack frame is not required for this small leaf function, but I have created
    one here to show how to save registers for the calling function so we can use
    them as local variables. We first need to specify a location in the stack frame
    ❶. This leads to the stack frame shown in [Figure 14-2](ch14.xhtml#ch14fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg309_Image_278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: The stack frame for the* add_two *function in [Listing 14-11](ch14.xhtml#ch14list11)*'
  prefs: []
  type: TYPE_NORMAL
- en: Although the algorithm uses only the low-order word of the `x19` register, we
    need to save the entire 64 bits because our algorithm might change the high-order
    32 bits ❷. In fact, the `add` instruction here will zero the high-order 32 bits
    of `x19` ❸. Don’t forget that we need to restore the saved registers before undoing
    our stack frame ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the stack frame for my assembly language version of the `add_two`
    function with the stack frame created by the compiler for the C version in [Figure
    14-1](ch14.xhtml#ch14fig1), notice that I’ve created a frame record at the top
    of my stack frame. I’ve then saved the `x19` and `x20` registers so I can use
    them for the computations in the function. If I later change my assembly language
    `add_two` function such that it calls another function, I don’t need to change
    its stack frame because it already has a frame record, and the standard says that
    the called function must preserve the values in the `x19` and `20` registers for
    the calling function.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you’ll see how the stack comes to our rescue when we want
    to pass more than the eight arguments we can pass in registers.
  prefs: []
  type: TYPE_NORMAL
- en: '***With More Than Eight Arguments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most functions take fewer than the eight arguments we can pass in registers,
    but sometimes a calling function needs to pass more than eight arguments to another
    function. In these cases, the arguments beyond the first eight are passed on the
    call stack. They are placed on the stack before the call to the function. I’ll
    use the program in [Listings 14-12](ch14.xhtml#ch14list12), [14-14](ch14.xhtml#ch14list14),
    and [14-15](ch14.xhtml#ch14list15) to show you how this works.
  prefs: []
  type: TYPE_NORMAL
- en: '*sum11ints.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-12: A program passing more than eight arguments to a subfunction*'
  prefs: []
  type: TYPE_NORMAL
- en: This `main` function creates 11 integer variables and initializes them to the
    values 1 through 11\. It then calls the `add_eleven` function to compute the sum
    of the 11 numbers and prints the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-13](ch14.xhtml#ch14list13) shows the assembly language generated
    by the compiler for the `main` function in [Listing 14-12](ch14.xhtml#ch14list12).'
  prefs: []
  type: TYPE_NORMAL
- en: '*sum11ints.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-13: The compiler-generated assembly language for the function in
    [Listing 14-12](ch14.xhtml#ch14list12)*'
  prefs: []
  type: TYPE_NORMAL
- en: When this function creates its stack frame, it allocates memory on the stack
    for the additional arguments it needs to pass on the stack ❶. Before calling the
    `add_eleven` function, it works from right to left in the argument list. Since
    it can pass only eight arguments in registers, it needs to store the three excess
    arguments on the stack ❷. These arguments are stored at the top of our stack frame,
    where the AArch64 procedure call standard specifies the called function should
    expect them. [Figure 14-3](ch14.xhtml#ch14fig3) shows the state of the stack at
    this point.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg312_Image_279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: The stack frame for the* main *function in [Listing 14-12](ch14.xhtml#ch14list12),
    just before calling* add_eleven'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-3](ch14.xhtml#ch14fig3) shows that the stack pointer is pointing
    to the arguments that are being passed to `add_eleven` on the stack. The names
    in the arguments area in this figure, `nine`, `ten`, and `eleven`, are the corresponding
    parameter names used by the `add_eleven` function. The procedure call standard
    allows both `main` and `add_eleven` to access stack memory in the arguments area,
    but argument passing can only take place from caller to callee—that is, from `main`
    to `add_eleven` in this example.'
  prefs: []
  type: TYPE_NORMAL
- en: Although we’re passing 4-byte `int`s, the AArch64 procedure call standard states
    that we must use 8 bytes for each stack argument, the same number of bytes as
    a register argument. Following this rule ensures you can use your assembly language
    functions with C functions. In [Figure 14-3](ch14.xhtml#ch14fig3), the compiler
    has stored the ninth, tenth, and eleventh arguments in the low-order 4 bytes of
    each argument slot on the stack. (Don’t forget that our memory order is little-endian.)
  prefs: []
  type: TYPE_NORMAL
- en: With our stack frame set up for calling the `add_eleven` function, we now store
    the remaining eight arguments in registers ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how the `add_eleven` function retrieves the arguments from the
    stack. I’ll start with the header file for the function, in [Listing 14-14](ch14.xhtml#ch14list14).
  prefs: []
  type: TYPE_NORMAL
- en: '*add_eleven.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-14: The header file for the* add_eleven *function*'
  prefs: []
  type: TYPE_NORMAL
- en: The `add_eleven` function is defined in [Listing 14-15](ch14.xhtml#ch14list15).
  prefs: []
  type: TYPE_NORMAL
- en: '*add_eleven.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-15: A function that receives more than eight arguments from a calling
    function*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-16](ch14.xhtml#ch14list16) shows the assembly language generated
    by the compiler for the `add_eleven` function in [Listing 14-15](ch14.xhtml#ch14list15).'
  prefs: []
  type: TYPE_NORMAL
- en: '*add_eleven.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-16: The compiler-generated assembly language for the function in
    [Listing 14-15](ch14.xhtml#ch14list15)*'
  prefs: []
  type: TYPE_NORMAL
- en: After creating a stack frame, the compiler saves the arguments that were passed
    in registers, because the call to another function might change their contents
    ❶. It does this near the beginning of the function so it doesn’t have to keep
    track of which ones have been saved when compiling the C statements in the function.
  prefs: []
  type: TYPE_NORMAL
- en: After loading each of these eight arguments from the stack and summing them,
    the function adds the remaining three arguments that are in the calling function’s
    stack frame ❷.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-4](ch14.xhtml#ch14fig4) shows the stack frames belonging to the
    `main` and `add_eleven` functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg315_Image_280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: The stack frames after the* add_eleven *function has been called
    and has created its stack frame*'
  prefs: []
  type: TYPE_NORMAL
- en: I mentioned on [page 279](ch14.xhtml#page_279) that the frame pointer points
    to the frame record, which points to the calling function’s frame record, and
    so forth. [Figure 14-4](ch14.xhtml#ch14fig4) shows this chain back to `main`’s
    frame record.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve shown only the offsets from `sp` that should be used by `add_eleven`. This
    function knows that `sp` was pointing to three 32-bit arguments before it subtracted
    64 from `sp`, so the first argument on the stack is now +64 from `sp`.
  prefs: []
  type: TYPE_NORMAL
- en: The procedure call standard allows the `add_eleven` function to store and load
    items to and from the area labeled “ `add_eleven` only” in [Figure 14-4](ch14.xhtml#ch14fig4).
    It allows the `add_eleven` function to use items in the stack area labeled “Both,”
    but it does not allow a called function to pass items back to the calling function
    in this area. The `add_eleven` function is not allowed to access the stack area
    labeled “`main` only.”
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function can store and load items to and from the area labeled “`main`
    only” in [Figure 14-4](ch14.xhtml#ch14fig4), but it is allowed only to store items
    to the stack area labeled “Both.”
  prefs: []
  type: TYPE_NORMAL
- en: '***Stack Frame Discipline***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s essential that you follow the register usage and argument passing disciplines
    precisely when writing in assembly language. Any deviation can cause errors that
    are difficult to debug.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-5](ch14.xhtml#ch14fig5) shows the overall pattern for a stack frame.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg316_Image_281.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: A stack frame*'
  prefs: []
  type: TYPE_NORMAL
- en: A stack frame doesn’t always include all the parts in [Figure 14-5](ch14.xhtml#ch14fig5).
    If the function never passes more than eight arguments to the functions it calls,
    the top box doesn’t exist. In this case, `sp` and `fp` both point to the frame
    record.
  prefs: []
  type: TYPE_NORMAL
- en: Some functions may not have any local variables or saved register contents.
    If it’s a leaf function, we don’t even need a frame record.
  prefs: []
  type: TYPE_NORMAL
- en: If no more than eight arguments are passed to the function, then the bottom
    box in this diagram does not exist. The bottom box is the only area of the stack
    frame that both the current function and its calling function have access to.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write the `sum11ints` program in assembly language. Unless it’s a very
    simple function, I start my designs by drawing a diagram of the stack frame for
    each function, similar to [Figures 14-3](ch14.xhtml#ch14fig3) and [14-4](ch14.xhtml#ch14fig4).
    Then I use `.equ` directives to give symbolic names to the locations on the stack
    that I need to access in my code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-17](ch14.xhtml#ch14list17) shows how we can do this for the `main`
    function in our `sum11ints` program.'
  prefs: []
  type: TYPE_NORMAL
- en: '*sum11ints.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-17: The* sum11ints main *function written in assembly language*'
  prefs: []
  type: TYPE_NORMAL
- en: The list of `.equ` directives gives a good view of what our stack frame looks
    like ❶. Using the symbolic names for our variables makes it easy to read the assembly
    language code, because we don’t have to remember the numerical offset of each
    item on the stack ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm for the function prologue needs to take into account that `main`
    will be passing arguments on the stack. We start by allocating space for our stack
    frame ❷. Then, we create the frame record after the area for passing arguments
    on the stack. This is easy once we have created our `.equ` view of the stack frame.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll write the `add_eleven` function in assembly language, using the
    diagram in [Figure 14-4](ch14.xhtml#ch14fig4) to set the values of the `.equ`
    directives. The assembly language is shown in [Listing 14-18](ch14.xhtml#ch14list18).
  prefs: []
  type: TYPE_NORMAL
- en: '*add_eleven.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-18: The* add_eleven *function written in assembly language*'
  prefs: []
  type: TYPE_NORMAL
- en: We need to be careful to distinguish between the part of our stack frame being
    used only by this function and the arguments that were passed in by the calling
    function. Naming this boundary with a `.equ` directive ❶ makes it easy to create
    our stack frame ❷. As with the `main` function in [Listing 14-17](ch14.xhtml#ch14list17),
    the `.equ` directive names also make it easier to read the assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: The values in automatic local variables will be lost when exiting a function.
    There are times when you want the information provided by a local variable to
    be hidden, but you also want the content of the variable to remain the same between
    subsequent calls to the function. We’ll look next at how this can be done.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 14.1     Show that the assembly language `add_eleven` function in [Listing 14-18](ch14.xhtml#ch14list18)
    works with the C `main` function in [Listing 14-12](ch14.xhtml#ch14list12).
  prefs: []
  type: TYPE_NORMAL
- en: 14.2     Show that initializing the `sum` variable in [Listing 14-15](ch14.xhtml#ch14list15)
    is the same as doing the addition separately, like in [Listing 14-8](ch14.xhtml#ch14list8).
  prefs: []
  type: TYPE_NORMAL
- en: 14.3     Write a program in assembly language that sums all the integers between
    two integers entered by the user.
  prefs: []
  type: TYPE_NORMAL
- en: '14.4     Write the three functions `write_char`, `write_str`, and `read_str`
    in assembly language. You’ll use these functions in exercises later in the book.
    Here are the specifications for each:'
  prefs: []
  type: TYPE_NORMAL
- en: (a)     `write_char` writes one character in the terminal window using the `write`
    system call. It takes one argument and returns 0.
  prefs: []
  type: TYPE_NORMAL
- en: (b)     `write_str` writes text in the terminal window using the `write` system
    call. It takes one argument and returns the number of characters written.
  prefs: []
  type: TYPE_NORMAL
- en: '(c)     `read_str` reads characters from the keyboard using the `read` system
    call and stores them in memory as a C-style text string, without the return character.
    It takes two arguments: a pointer to the memory location to store the text and
    the maximum number of characters to store. If the number of characters entered
    exceeds the maximum, it reads the remaining input but does not store it. It returns
    the number of characters entered, less the `NUL` terminating character.'
  prefs: []
  type: TYPE_NORMAL
- en: Test the functions with the following C `main` function. Don’t forget to write
    the C header files for your assembly language functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Hint: Use a small number for `MAX` when testing your `read_str` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static Local Variables**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed in [Chapter 11](ch11.xhtml), automatic local variables are created
    in a function’s prologue and get deleted in the function’s epilogue. This means
    the value stored in an automatic local variable will be lost in subsequent calls
    to the function. But in some cases, we might want to keep the value of a variable
    between function calls while still providing the information-hiding advantage
    of a local variable. For example, we might have a function that is called from
    several other functions and want to maintain a count of how many times it’s called.
    We could use a global variable, but a global variable doesn’t provide the information-hiding
    properties of a local variable.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can use a *static local variable*. Like an automatic local variable,
    a static local variable has local scope; however, like a global variable, it remains
    in memory throughout the lifetime of the entire program.
  prefs: []
  type: TYPE_NORMAL
- en: '***In C***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’ll explain where static local variables are created in memory using the program
    in [Listings 14-19](ch14.xhtml#ch14list19), [14-20](ch14.xhtml#ch14list20), and
    [14-21](ch14.xhtml#ch14list21). These listings illustrate the differences between
    the visibility and persistence of an automatic local variable, a static local
    variable, and a global variable.
  prefs: []
  type: TYPE_NORMAL
- en: '*var_life.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-19: A program to compare automatic local, static local, and global
    variables*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This `main` function defines three `int` variables: the global variable `z`
    and the automatic local variables `x` and `y`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-20](ch14.xhtml#ch14list20) shows the header file for the `add_const`
    function, which adds a constant value to an automatic local variable, a static
    local variable, and the global variable defined in `main`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*add_const.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-20: The header file for the* add_const *function*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-21](ch14.xhtml#ch14list21) is the definition of the `add_const`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*add_const.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-21: A function to add a constant value to three variables*'
  prefs: []
  type: TYPE_NORMAL
- en: The `add_const` function defines two local variables, `x` and `y`. The `y` variable
    is specified to be `static` ❶. This means it will be initialized to `INIT_Y` only
    the first time `add_const` is called. (If you don’t give an initial value to a
    static local variable, the compiler will initialize it to 0, but I recommend explicitly
    initializing it to 0 if that is your intention.) Any changes to `y` by `add_const`
    will persist through this call and all subsequent calls to the function. The `z`
    variable is declared with the `extern` modifier ❷ to show that it’s defined elsewhere
    in the program.
  prefs: []
  type: TYPE_NORMAL
- en: The `add_const` function adds a constant value to each of the three variables
    declared in the function. The `printf` statement shows the values of the `x` and
    `y` local variables defined in `add_const` and the `z` global variable defined
    in `main` each time `add_const` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing this program gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `x` in `main` is different from the `x` in `add_const`.
    Each time `main` calls `add_const`, the `x` in `add_const` is initialized to 78
    and the function adds 1,000 to it ❶. This shows that a new `x` is automatically
    created each time `add_const` is called.
  prefs: []
  type: TYPE_NORMAL
- en: You can also see that the `y` in `main` is different from the `y` in `add_const`,
    but the behavior of the `x` and `y` variables in `add_const` is not the same.
    The first time `add_const` is called, it initializes its `y` variable to 90 and
    adds 1,000 to it. However, the result of this first call to `add_const` persists.
    The second call to `add_const` does not cause its `y` to be initialized again;
    the function simply adds 1,000 to the existing value in the static `y` ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Although there are two `x`s and two `y`s in this program, there is only one
    `z`, which is defined in `main`. The output of the program shows that `main` gives
    `z` its initial value, 56, and `add_const` adds 1,000 to this each time the function
    is called ❸.
  prefs: []
  type: TYPE_NORMAL
- en: '***In Assembly Language***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 14-22](ch14.xhtml#ch14list22) shows the compiler-generated assembly
    language for the `main` function of the `var_life` program.'
  prefs: []
  type: TYPE_NORMAL
- en: '*var_life.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-22: The compiler-generated assembly language for the function in
    [Listing 14-19](ch14.xhtml#ch14list19)*'
  prefs: []
  type: TYPE_NORMAL
- en: Most of this code should look familiar to you. The one instance of `z` in this
    program is defined as a global in `main`, and the compiler uses our name to label
    the variable ❶. `main`’s `y` is created on the stack ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the assembly language the compiler generated for the `add_const`
    function, shown in [Listing 14-23](ch14.xhtml#ch14list23).
  prefs: []
  type: TYPE_NORMAL
- en: '*add_const.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-23: The compiler-generated assembly language for the* add_const
    *function in [Listing 14-21](ch14.xhtml#ch14list21)*'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler allocated the `x` variable in the stack frame, so it knows the
    amount of the offset from the stack pointer ❶. As you learned in “Global Variables”
    on [page 271](ch14.xhtml#ch14lev1sec3), `add_const` needs to retrieve the address
    of the global variable `z` from the GOT ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler treats the static local variable `y` a little differently than
    a global variable. It has changed our name to `y.0` ❷. This embellishment of our
    given name for the variable is called *name decoration* or *name mangling*. I
    prefer calling it decoration because it adds to our given name.
  prefs: []
  type: TYPE_NORMAL
- en: A static local variable cannot exist in the stack frame. Like the global variable
    `z` defined in the `main` function (see [Listing 14-22](ch14.xhtml#ch14list22)),
    the static local variable `y` is allocated in the `.data` section ❹. It’s labeled
    with its decorated name and initialized with a `.word` assembler directive ❺.
    We get the address of our `y` variable using its decorated name ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler needs to decorate names to satisfy the rules of C while also producing
    a valid assembly language file. As you might recall from the first section of
    this chapter ([page 270](ch14.xhtml#ch14lev1sec1)), the scope of a variable name
    in C extends only to the end of the block where it’s defined. That means we can
    use the same name to define another static variable in a different block that
    is not enclosed within the first one. But both variables result in labels in the
    assembly language, where they have file scope. The C compiler needs to distinguish
    between the two labels because the assembler requires that each label be unique
    within a file. It does this by decorating our static local variable names.
  prefs: []
  type: TYPE_NORMAL
- en: When writing in assembly language, we can use more meaningful names to distinguish
    variables, making the code easier to read. [Listings 14-24](ch14.xhtml#ch14list24)
    and [14-25](ch14.xhtml#ch14list25) show how I would write this program in assembly
    language.
  prefs: []
  type: TYPE_NORMAL
- en: '*var_life.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-24: An assembly language program to compare automatic local, static
    local, and global variables*'
  prefs: []
  type: TYPE_NORMAL
- en: My assembly language `main` function is very similar to what the compiler did
    in [Listing 14-22](ch14.xhtml#ch14list22), but I used more meaningful names. Programs
    that use only terminal I/O tend to be very small, so I assumed that `z` will be
    within *±*1MB of the instruction and used the `adr` instruction to load its address
    ❶. The linker should warn us if this is not true, in which case we would need
    to use the `adrp/add` instruction sequence to load the address of `z`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-25](ch14.xhtml#ch14list25) shows how I would write `add_const`
    in assembly language.'
  prefs: []
  type: TYPE_NORMAL
- en: '*add_const.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-25: An assembly language function to add a constant value to three
    variables*'
  prefs: []
  type: TYPE_NORMAL
- en: I have not decorated the name of the `y` variable ❶. As we saw earlier, the
    compiler decorates the names of static local variables to prevent a duplication
    of labels in the compiler-generated assembly language if we use the same static
    local name in another function in the same C source file. But writing in assembly
    language gives us more flexibility in choosing our label names. If we use `y`
    to label another memory location in the same file with the `add_const` function,
    the assembler will tell us about the error.
  prefs: []
  type: TYPE_NORMAL
- en: As with the `z` variable in the `main` function, I assume the `y` static variable
    will be close to the instructions that access it ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I’ll give a brief summary of program memory characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: '**Program Memory Characteristics**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You learned about the different memory segments when we started programming
    in assembly language in [Chapter 10](ch10.xhtml). [Table 14-1](ch14.xhtml#ch14tab1)
    summarizes the memory characteristics of some of the most common components of
    a program, as well as which segment they are placed in.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-1:** The Memory Characteristics of Common Program Components'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Component** | **Memory segment** | **Access** | **Lifetime** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Automatic local variable | Stack | Read and write | Function |'
  prefs: []
  type: TYPE_TB
- en: '| Constant | Text | Read only | Program |'
  prefs: []
  type: TYPE_TB
- en: '| Instruction | Text | Read only | Program |'
  prefs: []
  type: TYPE_TB
- en: '| Static local variable | Data | Read and write | Program |'
  prefs: []
  type: TYPE_TB
- en: '| Global variable | Data | Read and write | Program |'
  prefs: []
  type: TYPE_TB
- en: '[Table 14-2](ch14.xhtml#ch14tab2) summarizes some of the more common assembler
    directives used to control where program components go in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-2:** Some Common Assembler Memory Directives'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Directive** | Memory segment | Effect |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `.text` | Text | Instructions follow |'
  prefs: []
  type: TYPE_TB
- en: '| `.rodata` | Text | Constant data follows |'
  prefs: []
  type: TYPE_TB
- en: '| `.string "*string*", ...` | Text | Arrays of characters, each terminated
    by `NUL` |'
  prefs: []
  type: TYPE_TB
- en: '| `.ascii "*string*", ...` | Text | Arrays of characters |'
  prefs: []
  type: TYPE_TB
- en: '| `.asciz "*string*", ...` | Text | Arrays of characters, each terminated by
    `NUL` |'
  prefs: []
  type: TYPE_TB
- en: '| `.bss` | Data | Following data memory is initialized to zero |'
  prefs: []
  type: TYPE_TB
- en: '| `.data` | Data | Variable data follows |'
  prefs: []
  type: TYPE_TB
- en: '| `.byte *expression*, ...` | Data | Initialize memory, 1 byte for each *`expression`*
    |'
  prefs: []
  type: TYPE_TB
- en: '| `.hword *expression*, ...` | Data | Initialize memory, 2 bytes for each *`expression`*
    |'
  prefs: []
  type: TYPE_TB
- en: '| `.word *expression*, ...` | Data | Initialize memory, 4 bytes for each *`expression`*
    |'
  prefs: []
  type: TYPE_TB
- en: '| `.quad *expression*, ...` | Data | Initialize memory, 8 bytes for each *`expression`*
    |'
  prefs: []
  type: TYPE_TB
- en: The `.string`, `.ascii`, and `.asciz` directives can allocate more than one
    text string, each separated by a comma. The `.string` and `.asciz` directives
    add a `NUL` character to the end of the text string, while `.ascii` does not.
  prefs: []
  type: TYPE_NORMAL
- en: The `.byte`, `.hword`, `.word`, and `.quad` directives can apply to zero or
    more expressions, each of which must evaluate to an integral value. Multiple-byte
    values are stored in little-endian order. If there is no expression, no memory
    is allocated.
  prefs: []
  type: TYPE_NORMAL
- en: This is only a summary of these directives. For additional details, consult
    the `info` page for `as`.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 14.5     Modify the program in [Listings 14-24](ch14.xhtml#ch14list24) and [14-25](ch14.xhtml#ch14list25)
    so that the `add_const` function prints the number of times it has been called.
  prefs: []
  type: TYPE_NORMAL
- en: 14.6     Duplicate the `add_const` function in the file in [Listing 14-21](ch14.xhtml#ch14list21),
    naming the second copy `add_const2`. Modify the header file in [Listing 14-20](ch14.xhtml#ch14list20)
    accordingly. Modify the `main` function in [Listing 14-19](ch14.xhtml#ch14list19)
    so it calls both functions twice. How does this affect the name decorating in
    the `add_const` and `add_const2` functions ?
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Global variables** Persist throughout the entire life of the program (global
    scope).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automatic local variables** Created in their function when the function is
    called and deleted when the function is exited (function scope).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static local variables** Initialized in the first call to their function.
    Their value, including any changes, persists between subsequent calls to the function
    (function scope).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Passing arguments** The first eight arguments are passed in registers. Any
    additional arguments are passed on the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pass by value** A copy of the value is passed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pass by pointer** The address of the variable is passed. The address can
    be changed in the called function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pass by reference** The address of the variable is passed. The address cannot
    be changed in the called function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack frame** An area on the stack where a function’s frame record, local
    variables, saved register contents, and arguments to the function can be stored.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Frame pointer** A register containing the address of the frame record in
    the stack frame.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Frame record** Two addresses: the calling function’s frame pointer and the
    return address to the calling function.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve learned about the inner workings of functions, I’ll show you
    a couple of specialized uses of subfunctions in the next chapter.
  prefs: []
  type: TYPE_NORMAL
