- en: '**6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6'
- en: FUNCTIONS, METAPROGRAMMING, AND ERRORS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数、元编程与错误**'
- en: '*A small error at the beginning of something is a great one at the end.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*一开始的小错误，最终会变成一个大错误。*'
- en: —Thomas Aquinas
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: — 托马斯·阿奎那
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: In this chapter, we’ll explore three topics that afford greater power, control,
    and flexibility when writing programs. We’ll delve deeper into the central subject
    of functions, and further explore function arguments and higher-order functions.
    We’ll see how metaprogramming and macros let us create new syntax and bend Julia
    to our will in a way that’s not possible with most programming languages. Finally,
    we’ll see how to take control of the error system and use it to manipulate program
    execution.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨三大主题，这些主题在编写程序时能提供更大的能力、控制力和灵活性。我们将更深入地研究函数这一核心主题，并进一步探讨函数参数和高阶函数。我们将看到元编程和宏如何让我们创建新的语法，并以大多数编程语言无法做到的方式扭曲
    Julia 来满足我们的需求。最后，我们将看到如何控制错误系统，并利用它来操控程序的执行。
- en: '**Functions and Their Arguments**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数及其参数**'
- en: In [Chapter 4](ch04.xhtml), we learned about positional and keyword arguments
    to functions. In this section we’ll extend our knowledge of functions and learn
    additional ways to supply them with arguments.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.xhtml)，我们学习了函数的定位参数和关键字参数。本节将扩展我们对函数的知识，并学习提供额外参数的其他方式。
- en: '***Concise Syntax for Keyword Arguments***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***关键字参数的简洁语法***'
- en: Keyword arguments tend to have names that reflect their purposes, which means
    when calling a function using variables for some of the keyword arguments, the
    names of those variables often are the same as their names in the function definition.
    This is even more likely to happen if we’ve defined these variables with their
    eventual use in calling the function in mind.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数通常具有反映其用途的名称，这意味着在调用函数时，使用变量作为某些关键字参数时，这些变量的名称通常与函数定义中的名称相同。如果我们在定义这些变量时就考虑到了它们最终在调用函数中的用途，这种情况发生的可能性更大。
- en: 'Under such circumstances our function calls look something like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的函数调用看起来像这样：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Julia has a syntax option that reduces this visual noise and unnecessary typing.
    We can replace the previous call with:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 提供了一种语法选项，可以减少这种视觉噪音和不必要的输入。我们可以用以下方式替代之前的调用：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As the example shows, we can use either a variable with the same name as the
    keyword or a composite object that has a property name matching a keyword name.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，我们可以使用与关键字同名的变量，或者具有匹配关键字名称属性的复合对象。
- en: '***The Splat and Slurp Operators***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***展开与吸取操作符***'
- en: The `...` operator (three dots) is either a *splat* or a *slurp*, depending
    on context. When we’re supplying arguments to a function, we can *splat*, and
    when we’re defining a function, we can *slurp*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`...` 操作符（三个点）根据上下文可以是 *splat* 或 *slurp*。当我们向函数提供参数时，我们可以使用 *splat*，而在定义函数时，我们可以使用
    *slurp*。'
- en: '**Splatting**'
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**展开操作符**'
- en: 'Suppose we make a function that takes three arguments and adds them together:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们编写一个函数，接收三个参数并将它们加在一起：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we supply three arguments, as the function definition demands, the sum
    is returned. However, if the three values are part of a vector, we get an error
    ➊ if we call the function with the vector as an argument. That’s because its definition
    includes no method that accepts a single `Vector` argument; the only option is
    three separate values.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提供三个参数时，正如函数定义所要求的，结果会返回和它们的和。然而，如果这三个值是向量的一部分，当我们将向量作为参数传递给函数时，会发生错误➊。这是因为函数的定义没有包含接受单个
    `Vector` 参数的方法；唯一的选项是传递三个独立的值。
- en: 'We could handle this situation by extracting the values within `v3` into three
    separate variables and passing those to `addthree()`, but, since this situation
    arises frequently, Julia provides an easier way, through an operator spelled as
    three dots and called *splat*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 `v3` 中的值提取到三个独立的变量中，然后将这些变量传递给 `addthree()` 来处理这种情况，但由于这种情况经常发生，Julia
    提供了一种更简单的方法，通过一个由三个点组成的操作符，称为 *splat*：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here the splatting operator unpacks the values in a collection and supplies
    them as separate arguments to the called function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，展开操作符会解包集合中的值，并将它们作为独立参数传递给被调用的函数。
- en: '[Listing 6-1](ch06.xhtml#ch6lis1) shows how we can also splat keyword arguments
    stored in a named tuple.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-1](ch06.xhtml#ch6lis1) 展示了我们如何使用命名元组展开存储的关键字参数。'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 6-1: Splatting a named tuple*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-1：展开一个命名元组*'
- en: In this example, we create a new function, `addthreeWithCoefficients()`, that
    takes the three keyword arguments `f1`, `f2`, and `f3` and multiplies the positional
    arguments by them before returning the sum. We then create a named tuple, `coeffs`,
    that has two properties with names matching two of the keyword arguments. When
    we call the function with a splat applied to the named tuple ➊, `f1` and `f2`
    get values assigned from the corresponding properties of the tuple. The argument
    `f3` does not exist in the tuple, so it gets its default value of 1.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个新函数`addthreeWithCoefficients()`，它接受三个关键字参数`f1`、`f2`和`f3`，并在返回和之前先将位置参数乘以它们。然后我们创建一个命名元组`coeffs`，它有两个与两个关键字参数匹配的属性。当我们用命名元组➊应用splat时，`f1`和`f2`会从元组的相应属性中获得值。`f3`在元组中不存在，所以它会获得默认值1。
- en: Although structs also have properties, we can’t use them for splatting in this
    way. This limitation is related to the fact that we can’t iterate over a struct
    as we can over a named or ordinary tuple.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管结构体也有属性，但我们不能像在命名元组或普通元组中那样对结构体进行splat操作。这一限制与我们无法像遍历命名元组或普通元组那样遍历结构体有关。
- en: 'However, dictionaries will work, as long as the keyword names appear as symbols:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，字典只要关键字名称作为符号出现，依然有效：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here the dictionary keys `:f1` and `:f2` correspond to the arguments `f1` and
    `f2` in the function definition in [Listing 6-1](ch06.xhtml#ch6lis1).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里字典的键`:f1`和`:f2`对应于[清单6-1](ch06.xhtml#ch6lis1)中函数定义中的参数`f1`和`f2`。
- en: '**Slurping**'
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Slurping**'
- en: 'In a function definition, the three dots indicate the *slurp* operator. Slurping
    is a kind of inverse operation to splatting: instead of unpacking a collection
    into separate arguments, it packs any number of separate arguments into a single
    iterable object. If we want a function to accept an unknown, or variable, number
    of positional arguments, we can use slurping:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义中，三个点表示*slurp*操作符。Slurping是一种与splatting相反的操作：它不是将一个集合解包成单独的参数，而是将任意数量的单独参数打包成一个可迭代对象。如果我们希望一个函数接受未知数量或可变数量的位置参数，我们可以使用slurping：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `addonlythreeWithNote()` function returns the sum of the first three arguments
    we supply, just as the `addthree()` function did. This version, however, accepts
    any number of additional arguments, which it packs into a tuple called `more`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`addonlythreeWithNote()`函数返回我们提供的前三个参数的和，就像`addthree()`函数一样。然而，这个版本接受任意数量的额外参数，并将它们打包成一个名为`more`的元组。'
- en: 'We can also slurp keyword arguments. The function defined in the following
    example performs two optional tests on the string supplied as its positional argument.
    If it gets a keyword called `palindrome`, it tests for the thusly named property,
    and if it gets one called `onlyascii`, it uses the `isascii()` function to check
    for the presence of non-ASCII characters in the string:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对关键字参数进行slurp。下面这个例子中的函数对作为位置参数传入的字符串进行两个可选测试。如果它得到一个名为`palindrome`的关键字，它会测试该字符串是否为回文；如果它得到一个名为`onlyascii`的关键字，它会使用`isascii()`函数检查字符串中是否有非ASCII字符：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because we define `examine_string()` using slurping for keyword arguments, it
    doesn’t matter if it’s called with extra arguments ➊; they will be ignored. Since
    we supply default values for the keyword arguments in the function definition,
    it also doesn’t matter if some are missing. Finally, since the program checks
    only for the presence of the keyword arguments, the values assigned in the call
    are arbitrary.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在定义`examine_string()`函数时使用了slurping来处理关键字参数，所以即使传入额外的参数➊也无关紧要；它们会被忽略。由于我们在函数定义中为关键字参数提供了默认值，因此即使某些关键字参数缺失，也没有问题。最后，由于程序只检查关键字参数是否存在，传入调用中的值是任意的。
- en: 'We can also call the function with a splatted value as before. The difference
    now is that the object we splat into the call may contain superfluous keywords
    without creating an error condition. Here’s an example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以像之前一样调用函数并传入一个splat值。不同之处在于，我们传入的对象可能包含多余的关键字，但不会引发错误。下面是一个例子：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Defining functions with slurped keyword arguments can be convenient for users.
    For example, some of the functions in the `Plots` package work this way. We can
    call them with keywords that they don’t use; they’ll use the ones they can handle
    and ignore the others. This might happen in the REPL if we create a plot using
    one plotting function supplied with a list of keywords and then decide we want
    to use a different one. We can press the up arrow and change the function’s name
    without having to consult its documentation to see whether it understands all
    the keywords we used previously.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“slurped”关键字参数定义函数对于用户来说非常方便。例如，`Plots` 包中的一些函数就是以这种方式工作的。我们可以使用它们不需要的关键字来调用它们；它们会使用自己能处理的关键字，忽略其他的。这种情况可能出现在
    REPL 中，如果我们使用一个包含关键字列表的绘图函数创建了一个图表，然后决定使用另一个函数。我们可以按上箭头键，改变函数名，而不必查看文档来确认它是否理解我们之前使用的所有关键字。
- en: Julia allows one more way to supply keyword arguments to such functions. We
    can list them separately in the form `:kw=>value`, with keywords appearing as
    symbols, or we can splat a dictionary, but all of its keys must be symbols.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 还允许向此类函数提供关键字参数的另一种方式。我们可以以 `:kw=>value` 的形式单独列出它们，关键字以符号出现，或者我们可以展开一个字典，但字典的所有键必须是符号。
- en: '***Destructuring***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***解构***'
- en: '*Destructuring* refers to the unpacking of a tuple of values into named variables
    with a single assignment:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*解构* 是指将一个元组的值解包为具有单一赋值的命名变量：'
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This feature is especially convenient in unpacking tuple return values from
    functions. As mentioned previously, tuples need not be written with parentheses
    as long as omitting them doesn’t create an ambiguity, so we can write the assignment
    in the example just shown as `x, y = 3, 4`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能在解包来自函数的元组返回值时尤其方便。如前所述，只要省略括号不会引起歧义，元组就不需要写括号，所以我们可以像 `x, y = 3, 4` 这样编写示例中的赋值。
- en: '[Listing 6-2](ch06.xhtml#ch6lis2) shows another form of destructuring that
    unpacks keyword arguments from a struct, using the following syntax:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-2](ch06.xhtml#ch6lis2) 展示了另一种解构方式，它从结构体中解包关键字参数，使用以下语法：'
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 6-2: Destructuring a struct*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-2：解构一个结构体*'
- en: In this example, the definition of `google` from [Listing 5-2](ch05.xhtml#ch5lis2)
    is in force. In this type of destructuring, the variable names on the left-hand
    side of the assignment must match the field names of the composite type on the
    right-hand side.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，来自 [列表 5-2](ch05.xhtml#ch5lis2) 的 `google` 定义生效。在这种类型的解构中，赋值左侧的变量名必须与右侧复合类型的字段名匹配。
- en: '**NOTE**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Keyword destructuring from structs first appeared in Julia v1.7\. In earlier
    versions,* (; a, b) *is a syntax error.*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*从 Julia v1.7 开始，结构体的关键字解构被首次引入。在早期版本中，* (; a, b) *是语法错误。*'
- en: 'The utility of this form of destructuring may not be immediately obvious. After
    all, without this peculiar syntax, we can still do this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解构方式的实用性可能不会立即显现。毕竟，没有这种特殊语法，我们仍然可以做到这一点：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It’s not much more verbose than the form in [Listing 6-2](ch06.xhtml#ch6lis2)
    and has the same effect.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它与 [列表 6-2](ch06.xhtml#ch6lis2) 中的形式相比并没有更多的冗长，并且具有相同的效果。
- en: 'However, one advantage of this destructuring syntax is in providing a succinct
    way to define functions that take keyword arguments extracted from structs. In
    the following example, we first define a struct with three fields and create an
    object from the struct:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种解构语法的一个优势在于它为定义接受从结构体中提取的关键字参数的函数提供了一种简洁的方式。在以下示例中，我们首先定义一个具有三个字段的结构体，并从该结构体创建一个对象：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Then we make a different version of the `addthreeWithCoefficients()` function
    that we created in [Listing 6-1](ch06.xhtml#ch6lis1) ➊. Instead of a list of keyword
    arguments, this version takes a fourth positional argument that has the syntax
    of a struct destructuring. When we call the function, supplying the composite
    object as the fourth positional argument, the function makes the assignment`(;
    f1, f2,` `f3) = someco`. Referring to the syntax in [Listing 6-2](ch06.xhtml#ch6lis2),
    we can see that this will assign 100 to `f1`, 10 to `f2`, and 1 to `f3`. The struct
    used as an argument may contain fields that are not extracted by the function,
    as the destructing syntax doesn’t require all fields to be unpacked.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个与 [Listing 6-1](ch06.xhtml#ch6lis1) ➊ 中创建的 `addthreeWithCoefficients()`
    函数不同的版本。这个版本没有使用关键字参数的列表，而是使用了一个第四个位置参数，具有结构体解构的语法。当我们调用该函数并将复合对象作为第四个位置参数传入时，函数会执行赋值
    `(; f1, f2, f3) = someco`。参考 [Listing 6-2](ch06.xhtml#ch6lis2) 中的语法，我们可以看到这将把
    100 赋值给 `f1`，10 赋值给 `f2`，1 赋值给 `f3`。作为参数传递的结构体可能包含函数没有解构的字段，因为解构语法并不要求解构所有字段。
- en: '***Operators Are Functions Too***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运算符也是函数***'
- en: 'Binary operators in Julia, such as `*` and `+`, also called *infix operators*,
    are functions of two arguments. Each one has a more explicit functional form:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 中的二元运算符，如 `*` 和 `+`，也叫做 *中缀运算符*，是两个参数的函数。每个运算符都有一个更明确的函数形式：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the first example, the `+` function operates on the arguments 1, 2, and 3,
    adding them up to return 6\. The functional form of infix operators can be more
    concise when we have many arguments.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，`+` 函数对参数 1、2 和 3 进行操作，将它们相加并返回 6。中缀运算符的函数形式在我们有多个参数时可以更加简洁。
- en: Since binary operators are functions, we can pass them as arguments to higher-order
    functions (see [Listing 6-5](ch06.xhtml#ch6lis5) for an example).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于二元运算符是函数，我们可以将它们作为参数传递给高阶函数（有关示例，请参见 [Listing 6-5](ch06.xhtml#ch6lis5)）。
- en: In an expression involving infix operators, the order of operations, or *precedence
    rules* for operators, determines the result. For example, the expression `3 +
    2 * 5` evaluates to `13` because multiplication happens before addition.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及中缀运算符的表达式中，操作顺序或运算符的 *优先级规则* 决定了结果。例如，表达式 `3 + 2 * 5` 计算结果为 `13`，因为乘法先于加法执行。
- en: When using the functional forms of operators, there are no precedence rules,
    because the function application syntax makes the order of operations explicit.
    For example, the expression `3 + 2 * 5` is equivalent to `+(3, *(2, 5))`. The
    syntax shows that the multiplication occurs before the addition.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用运算符的函数形式时，没有优先级规则，因为函数应用的语法使得操作顺序变得明确。例如，表达式 `3 + 2 * 5` 相当于 `+(3, *(2, 5))`。语法显示乘法先于加法执行。
- en: Julia allows us to use certain characters to define our own binary operators.
    If we create a function and give it one of these characters for its name, we can
    use the function in an infix position.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 允许我们使用某些字符来定义自己的二元运算符。如果我们创建一个函数并将其中一个字符作为其名称，我们就可以在中缀位置使用该函数。
- en: We can’t create an infix operator from any character, however. The source code
    for Julia’s interpreter provides a complete list of available characters (see
    “Further Reading” on [page 187](ch06.xhtml#fur6)). The source also indicates the
    precedence of each character by grouping them in classes with equal precedence.
    When deciding on a symbol for an infix operator, it’s not enough to pick one that
    looks right. We must decide how the operator is to fit within the hierarchy of
    precedence and choose a symbol in the appropriate group.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能从任何字符创建中缀运算符。Julia 解释器的源代码提供了可用字符的完整列表（请参阅 [第 187 页](ch06.xhtml#fur6)
    的“进一步阅读”）。该源代码还通过将字符分组到具有相同优先级的类中，标明了每个字符的优先级。在决定中缀运算符的符号时，仅仅挑选一个看起来合适的符号是不够的。我们必须决定该运算符如何融入优先级层级，并选择合适组中的符号。
- en: The three major precedence groups are multiplication, addition, and comparison.
    [Figure 6-1](ch06.xhtml#ch6fig1) shows a small selection of characters from each
    group.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 三个主要的优先级组是乘法、加法和比较。 [Figure 6-1](ch06.xhtml#ch6fig1) 显示了每个组的几个字符示例。
- en: '![Image](../images/ch06fig01.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch06fig01.jpg)'
- en: '*Figure 6-1: A few operator characters*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 6-1: 一些运算符字符*'
- en: Comparison operators have the lowest precedence of these three types, so the
    expression `2 * 3 + 2 > 7` is equivalent to `((2 * 3) + 2) > 7` and returns `true`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符在这三种类型中优先级最低，因此表达式 `2 * 3 + 2 > 7` 相当于 `((2 * 3) + 2) > 7`，并返回 `true`。
- en: Let’s use one of these characters to create a new infix operator that extends
    the idea of subtraction to give us the Euclidean distance between two vectors.
    We want it to have the same precedence as addition and subtraction operators,
    so we’ll pick a symbol from that group that looks like it has something to do
    with subtraction (enter \boxminus followed by TAB to enter the function’s name
    in the REPL).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些字符中的一个来创建一个新的中缀操作符，将减法的概念扩展到计算两个向量之间的欧几里得距离。我们希望它与加法和减法操作符具有相同的优先级，因此我们会选择一个看起来与减法有关的符号（在
    REPL 中输入 `\boxminus` 后按 TAB 键以输入该函数的名称）。
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**NOTE**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To learn the shortcut for any other special character, paste it in after entering
    help mode.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*要学习任何其他特殊字符的快捷键，请在进入帮助模式后粘贴它。*'
- en: After this definition, we have a new function with a single-character name.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个定义之后，我们有了一个新的函数，名称是单个字符。
- en: 'Since the character is in the list of characters blessed for use as infix operators,
    it should work:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该字符在允许用作中缀操作符的字符列表中，它应该能够正常工作：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This result is correct.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果是正确的。
- en: 'Let’s use the new operator in an expression containing a higher-precedence
    operation to check that it follows the desired precedence rules:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个包含更高优先级运算的表达式中使用新操作符，检查它是否遵循所需的优先级规则：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The multiplications were taken before the vector subtraction, as expected (the
    result may remind you of the 3-4-5 right triangle from high school trigonometry).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法运算是在向量减法之前进行的，正如预期的那样（结果可能会让你想起高中三角学中的 3-4-5 直角三角形）。
- en: 'We can transform infix operators we create ourselves into broadcast versions
    using the dot prefix, just like built-in operators:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过点前缀将自己创建的中缀操作符转换为广播版本，就像内置操作符一样：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The broadcasting operation applies our function to all corresponding elements
    of the pair of vectors (of vectors). The result is a vector containing the Euclidean
    distance between each pair of corresponding vectors.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 广播操作将我们的函数应用于这对向量（向量的向量）中所有相应的元素。结果是一个包含每对相应向量之间欧几里得距离的向量。
- en: '***The Mapping, Filtering, and Reduction Operators***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***映射、过滤和归约操作符***'
- en: A *higher-order function* is a function that takes one or more functions as
    some of its arguments. Usually they either transform functions into other functions
    or apply them to data supplied as further arguments. The three operators `map()`,
    `filter()`, and `reduce()` are higher-order functions that apply a supplied function
    to a collection.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*高阶函数*是一个接受一个或多个函数作为其参数的函数。通常，它们要么将函数转换为其他函数，要么将它们应用于作为进一步参数提供的数据。三个操作符`map()`、`filter()`和`reduce()`是高阶函数，它们将提供的函数应用于集合。'
- en: '**The map() Operator**'
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**map() 操作符**'
- en: 'The `map()` operator applies a function to each element of a collection and
    returns another collection:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`操作符对集合的每个元素应用一个函数，并返回另一个集合：'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here `map()` applies `double()` to each element of the matrix individually,
    returning a result with the same shape as the matrix.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`map()`对矩阵的每个元素单独应用`double()`，返回一个与矩阵形状相同的结果。
- en: 'In the case of an infix operator, `map` applies it between corresponding elements
    of all the collections supplied:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于中缀操作符，`map`在所有提供的集合的相应元素之间应用它：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The result has the same shape as the collections that `map()` is operating on.
    The result’s first element comes from applying `+` to the first elements of all
    the collections; the second element, 15, is 3 + 5 + 7.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的形状与`map()`操作的集合相同。结果的第一个元素是将`+`运算应用于所有集合的第一个元素；第二个元素 15 是 3 + 5 + 7。
- en: 'The key to understanding `map()` is understanding `zip()` because the `map()`
    operator combines the elements of the arrays we give it using `zip()`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`map()`的关键是理解`zip()`，因为`map()`操作符通过`zip()`将我们提供的数组的元素结合在一起：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In these examples, `map()` applies the `+` operator between the elements of
    the vector and the 2×2 matrix in column-major order. In both cases, it stops when
    it runs out of elements in one of the collections.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，`map()`在列主序的情况下，对向量和 2×2 矩阵的元素应用了`+`操作符。在这两种情况下，它都会在其中一个集合的元素用完时停止。
- en: 'In some cases, `map()` returns the same result as an equivalent broadcast using
    the dot. The map of `double()` earlier could have been written this way:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，`map()`返回的结果与使用点操作符的等效广播相同。之前`double()`的映射本可以这样写：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, mapping and broadcasting are not the same. We can see this clearly
    in the case of an infix operator:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，映射（mapping）和广播（broadcasting）并不相同。在中缀操作符的情况下，我们可以清楚地看到这一点：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, the array on the left-hand side has a different shape from
    the one on the right-hand side. However, its shape fits the shape of the *rows*
    of the right-hand array. The broadcasting operator `.+` extends, or broadcasts,
    the array `[20 30]` over the rows of the other array.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，左侧的数组形状与右侧的数组不同。然而，它的形状与右侧数组的*行*形状相匹配。广播操作符`.+`将数组`[20 30]`扩展或广播到另一个数组的行上。
- en: 'If we make the left-hand array a single column instead of a single row, it’s
    broadcast over the columns of the other array:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将左侧数组改为单列而不是单行，它将会在另一个数组的列上进行广播：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Examining the examples in this section should make the difference between mapping
    and broadcasting clear. Unlike broadcasting, `map()` does not perform operations
    on entire arrays, but goes element by element, using `zip()` under the hood. Using
    `map()` in this last example yields a different result:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查本节中的例子，应该能清楚地区分映射和广播。与广播不同，`map()`并不是对整个数组进行操作，而是逐个元素地进行操作，并在背后使用`zip()`。在这个最后的例子中，使用`map()`会得到一个不同的结果：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `[3, 5]` column of the last argument is never used because `map()` runs
    out of elements before it gets there.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数的`[3, 5]`列从未被使用，因为`map()`在到达该位置之前就已经没有元素可用。
- en: '**The filter() Operator**'
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**filter() 操作符**'
- en: The `filter()` operator takes a function of one variable as its first argument;
    this function should return `true` or `false`. It applies this function to each
    element of its second argument, which should be a collection. It returns a new
    collection with the elements for which the function returned `false` *filtered*
    out, or removed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`操作符接受一个由一个变量组成的函数作为第一个参数；这个函数应该返回`true`或`false`。它将这个函数应用到第二个参数的每个元素上，第二个参数应该是一个集合。它返回一个新的集合，包含那些函数返回`false`的元素被*过滤*掉或删除。'
- en: As with `map()`, [Listing 6-3](ch06.xhtml#ch6lis3) shows how `filter()` is often
    used with anonymous functions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与`map()`一样，[清单 6-3](ch06.xhtml#ch6lis3)展示了`filter()`如何常与匿名函数一起使用。
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 6-3: Using filter() with an anonymous function*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-3：使用 filter() 和匿名函数*'
- en: Here we’ve created a list of the integers from 1 to 100 that are divisible by
    17.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们创建了一个包含从1到100之间能被17整除的整数的列表。
- en: Julia provides a collection of test functions that can be convenient to use
    with `filter()`, such as `isodd()`, `iseven()`, `isfinite()`, and `isfile()`,
    which answer the questions indicated by their names.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Julia提供了一些可以方便地与`filter()`一起使用的测试函数，比如`isodd()`、`iseven()`、`isfinite()`和`isfile()`，它们分别回答由函数名所指示的问题。
- en: 'The `isascii()` function tells you whether a character is part of the old ASCII
    character set; we can use it on a string to filter out non-ASCII characters:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`isascii()`函数告诉你一个字符是否属于旧的ASCII字符集；我们可以在字符串上使用它来过滤掉非ASCII字符：'
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We get the string back with “ç” filtered out. We can also invert the condition
    to filter out the ASCII characters with `filter(!isascii, "François")`, which
    returns `"ç"`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回了一个字符串，其中“ç”被过滤掉。我们还可以反转条件，通过`filter(!isascii, "François")`过滤掉ASCII字符，返回`"ç"`。
- en: '**The reduce() Operator**'
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**reduce() 操作符**'
- en: We’ve used the `sum()` function several times. It adds up all the numbers in
    an array, reducing it to a single number. The `reduce()` higher-order function
    generalizes this concept. It applies a function of two variables, supplied as
    its first argument, to a collection supplied as its second argument.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次使用了`sum()`函数。它将数组中的所有数字相加，最终返回一个单一的数字。`reduce()`高阶函数将这一概念进行了概括。它将一个由两个变量组成的函数（作为第一个参数）应用到一个集合（作为第二个参数）上。
- en: Let’s consider an example to visualize how it works. If there were no `sum()`
    function, we could use `reduce()` instead. We can calculate the sum `1 + 2 + 3`
    with `sum([1, 2, 3])`, but also with `reduce(+, [1, 2, 3])`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子，帮助理解它的工作原理。如果没有`sum()`函数，我们可以用`reduce()`来代替。我们可以通过`sum([1, 2, 3])`计算和`1
    + 2 + 3`，也可以用`reduce(+, [1, 2, 3])`来做同样的事情。
- en: We can use any binary operator, or any function of two variables, with `reduce()`.
    For example, [Listing 6-4](ch06.xhtml#ch6lis4) shows a function that divides its
    first argument by its second and uses it in `reduce()`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`reduce()`中使用任何二元操作符或任何由两个变量组成的函数。例如，[清单 6-4](ch06.xhtml#ch6lis4)展示了一个将第一个参数除以第二个参数的函数，并在`reduce()`中使用它。
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 6-4: The reduce() function*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-4：reduce() 函数*'
- en: The last line shows how `reduce()` inserts the function between elements, accumulating
    partial results as it goes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行展示了`reduce()`如何在元素之间插入函数，逐步累积结果。
- en: 'However, reducing with division introduces a complication. While the `+` and
    `*` operators are *associative*, division and subtraction are not. Associativity
    means that it doesn’t matter how we group: `(1 + 2) + 3` gives the same result
    as `1 + (2 + 3)`. Division is not associative: `1/(2/3)` is equal to 1.5.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用除法进行归约引入了一个复杂性。虽然`+`和`*`运算符是*结合的*，但除法和减法不是。结合性意味着我们如何分组并不重要：`(1 + 2) +
    3`和`1 + (2 + 3)`给出的结果是相同的。除法并不满足结合律：`1/(2/3)`等于1.5。
- en: '**NOTE**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In fact, addition and multiplication are associative when operating on real
    numbers (and other number systems in the realm of mathematics), but they are not
    truly associative when applied to floating-point numbers in a computer. Although
    the numerical effect of association, the difference between (*a *+* b*) +* c *and*
    a *+ (*b *+* c*), is usually small, it’s better to use the folding operators,
    which we’ll introduce next, when numerical accuracy or reproducibility are important.*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*事实上，加法和乘法在对实数（以及数学领域中的其他数系）进行运算时是结合的，但在应用于计算机中的浮点数时，它们并不真正满足结合律。尽管结合的数值效果，即(*a
    *+* b*) +* c* 和* a *+ (*b *+* c*) 之间的差异通常很小，但当数值精度或可重复性很重要时，最好使用接下来我们将介绍的折叠操作符。*'
- en: 'In cases where the function or operator is not associative, the result of using
    `reduce()` is undefined: we cannot assume that it works from left to right. In
    such cases, we should use `foldl()` or `foldr()`, which work just like `reduce()`,
    but associate from the left or the right:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数或运算符不满足结合律的情况下，使用`reduce()`的结果是未定义的：我们不能假设它是从左到右进行的。在这种情况下，我们应该使用`foldl()`或`foldr()`，它们的工作方式与`reduce()`相似，但分别从左或从右进行结合：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[Listing 6-5](ch06.xhtml#ch6lis5) shows how the `reduce()` operator, but not
    `foldl()` or `foldr()`, accepts the keyword argument `dims` to reduce along the
    specified dimension.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-5](ch06.xhtml#ch6lis5)展示了`reduce()`操作符如何接受关键字参数`dims`来沿指定维度进行归约，而`foldl()`或`foldr()`则不接受该参数。'
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 6-5: Reducing along a specified dimension*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6-5：沿指定维度进行归约*'
- en: Here `dims=1` causes a reduction along the rows, while `dims=2` reduces along
    the columns. If we omit the `dims` argument, the result is a reduction over all
    elements, giving the single number 33.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`dims=1`导致沿着行进行归约，而`dims=2`则沿着列进行归约。如果我们省略`dims`参数，结果是对所有元素进行归约，得到单一数字33。
- en: 'All three reducing functions accept another keyword argument that acts as a
    default in case they encounter an empty collection. This argument is called `init`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个归约函数都接受另一个关键字参数，用作在遇到空集合时的默认值。这个参数叫做`init`：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, when faced with the empty collection `[]`, `reduce()` returns
    the specified value 0.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当遇到空集合`[]`时，`reduce()`返回指定的值0。
- en: If a reducing function encounters an empty collection, no default neutral element
    exists, and no `init` argument has been supplied, it returns an error. Some reducing
    functions *may* use the value of `init` as a starting value for the reduction
    when the collection is not empty, but this behavior is formally unspecified and
    may change in future implementations of these functions. For that reason, to assure
    correct results, when `init` is present it should be the correct *neutral element*
    for the applied operation. For addition, this is 0, and for multiplication, the
    neutral element is 1.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果归约函数遇到空集合，并且没有默认的中立元素，并且也没有提供`init`参数，则会返回错误。一些归约函数*可能*会在集合不为空时使用`init`的值作为归约的起始值，但这种行为在正式上没有明确规定，未来这些函数的实现可能会有所变化。因此，为了确保结果正确，当`init`存在时，它应该是所应用操作的正确*中立元素*。对于加法来说，这个元素是0，对于乘法来说，中立元素是1。
- en: 'Some reducing operations arise so frequently in programs that Julia has purpose-built
    versions for them. We’ve already seem `sum()`; `prod()` is similar but multiplies
    rather than adds:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一些归约操作在程序中出现得非常频繁，以至于Julia为它们提供了专门的版本。我们已经见过`sum()`；`prod()`类似，但执行的是乘法而不是加法：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first expression in this example multiplies together all the integers from
    1 to 7 inclusive; as this is the definition of 7!, we get the same result returned
    from the second expression.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的第一个表达式将1到7之间的所有整数相乘；由于这是7!的定义，因此第二个表达式返回相同的结果。
- en: 'The `maximum()` and `minimum()` reducers find the largest or smallest element
    of a collection:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`maximum()`和`minimum()`归约函数找到集合中的最大或最小元素：'
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, we create the collections by broadcasting the `sin()` function
    over an interval.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过对一个区间应用`sin()`函数来创建集合。
- en: 'The `any()` and `all()` reducing tests apply a test over a collection:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`any()` 和 `all()` 减少测试会对集合应用一个测试：'
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'These two operations answer the questions: do *any* or *all* elements of the
    collection satisfy the test in the first argument?'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个操作回答了以下问题：集合中的 *任何* 或 *所有* 元素是否满足第一个参数中的测试？
- en: '**The mapreduce() Function**'
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**mapreduce() 函数**'
- en: 'The powerful `mapreduce()` function does what its name suggests: it combines
    a `map()` and a `reduce()`. For example, here are two ways to add up the first
    100 squares:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 强大的 `mapreduce()` 函数正如其名字所示：它结合了 `map()` 和 `reduce()`。例如，下面是两种加总前 100 个平方数的方式：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The second method shows exactly what a `mapreduce()` call does. However, it’s
    almost always better to use `mapreduce()` instead of combining a `map()` and a
    `reduce()` because the former uses far less memory and is much faster; the gain
    in efficiency grows dramatically as the collection gets larger. The main reason
    is that combining `map()` and `reduce()` creates an intermediate collection to
    reduce over, whereas `mapreduce()` performs the calculation in one go, without
    allocating a collection.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法准确地展示了 `mapreduce()` 调用的作用。然而，几乎总是最好使用 `mapreduce()` 而不是组合 `map()` 和 `reduce()`，因为前者使用的内存更少，速度更快；随着集合的增大，效率的提升显著。主要原因是，组合
    `map()` 和 `reduce()` 会创建一个中间集合来进行归约，而 `mapreduce()` 一次性完成计算，无需分配集合。
- en: '**do Blocks**'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**do 块**'
- en: Many functions in Julia take functions as their first arguments, and we often
    want to supply an anonymous function, as we have no need to reuse the function
    elsewhere. We’ve seen this with `plot()` and related plotting routines, and with
    the mapping and reducing functions described in this chapter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 中的许多函数将函数作为第一个参数，而我们通常希望提供一个匿名函数，因为我们不需要在其他地方重用该函数。我们已经在 `plot()` 和相关绘图函数中看到了这一点，以及本章中描述的映射和归约函数。
- en: Constructing an anonymous function can be cumbersome or impossible using the
    `x -> ...` syntax. For example, we might want it to contain loops or `if` blocks.
    In those situations, we can resort to first creating a named function and then
    passing it to the higher-level function, but Julia provides another way.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `x -> ...` 语法构造匿名函数可能繁琐或不可能。例如，我们可能希望它包含循环或 `if` 块。在这种情况下，我们可以先创建一个命名函数，再将其传递给高阶函数，但
    Julia 提供了另一种方法。
- en: The `do` block is a type of function definition block solely for the purpose
    of creating anonymous functions. The function is inserted as the first argument
    of the function call immediately preceding the `do` block.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`do` 块是一种仅用于创建匿名函数的函数定义块。该函数作为紧接着 `do` 块前的函数调用的第一个参数被插入。'
- en: Let’s revisit reducing using our `q()` function from [Listing 6-4](ch06.xhtml#ch6lis4).
    If any of the denominators taken from the collection is 0, the reduction will
    return `Inf`. But what if we want to simply skip those denominators?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下使用 `q()` 函数的归约，[请参见列表 6-4](ch06.xhtml#ch6lis4)。如果从集合中取出的任何分母为 0，则归约将返回
    `Inf`。但如果我们只想跳过这些分母呢？
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `do` block defines an anonymous function of two variables that returns the
    first divided by the second, handling 0 denominators as a special case. The call
    to `foldl()` looks wrong because it passes only a single argument, but the function
    defined by the `do` block is inserted as the missing first argument.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`do` 块定义了一个匿名函数，接受两个变量，返回第一个变量除以第二个变量，并处理 0 除数的特殊情况。调用 `foldl()` 看起来不对，因为它只传递了一个参数，但由
    `do` 块定义的函数作为缺失的第一个参数被插入。'
- en: '**Symbols and Metaprogramming**'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**符号与元编程**'
- en: We’ve used the `Symbol` type in several places—for example, when setting attributes
    in plotting functions—but we’ve deferred a thorough discussion of what symbols
    in Julia actually are until now.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在几个地方使用过 `Symbol` 类型，例如在绘图函数中设置属性时，但直到现在我们才对 Julia 中的符号是什么进行彻底讨论。
- en: To grasp the meaning of symbols, we must introduce the concept of *metaprogramming*
    in Julia. Metaprogramming refers to a general class of language facilities and
    associated techniques for writing code that examines itself, modifies itself,
    and can even modify or add to the syntax of the language. In this section, we’ll
    introduce the basic concepts and apply them to the code-transforming programs
    called *macros* described in the next section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解符号的含义，我们必须引入 Julia 中的 *元编程* 概念。元编程是指一种语言设施和相关技术的通用类别，用于编写能够检查自己、修改自己，甚至修改或添加语言语法的代码。在本节中，我们将介绍基本概念，并将其应用于下一节中描述的代码转换程序，称为
    *宏*。
- en: Scientific code does not typically use much metaprogramming. However, Julia,
    and many of its packages, provides some indispensable macros, such as the `@layout`
    macro that we used in “Creating Complex Layouts Using @layout” on [page 118](ch04.xhtml#ch04lev1sec28).
    Even if you never write a macro yourself, having a basic understanding of how
    they work is worthwhile. Programming in Julia routinely uses a handful of indispensable
    macros, so it’s important to be able to use them intelligently and debug them
    if something goes wrong.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 科学代码通常不使用太多的元编程。然而，Julia 及其许多包提供了一些不可或缺的宏，例如我们在 [第 118 页](ch04.xhtml#ch04lev1sec28)
    中使用的 `@layout` 宏。即使你从未自己编写过宏，了解它们如何工作仍然是值得的。在 Julia 编程中，经常使用少量的不可或缺的宏，因此，能够智能地使用它们并在出现问题时进行调试是非常重要的。
- en: '***Expression Objects***'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***表达式对象***'
- en: Julia has the ability to manipulate Julia code. That’s possible because Julia
    code itself is expressible as a data type that the language can operate on, just
    as it operates on numbers, strings, and arrays. This data type is called `Expr`.
    Objects with this data type are referred to as `Expr` objects or *expression objects*.
    Expression objects are different from *expressions*, which are language forms
    that return results, such as `3 * 5`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 具有操作 Julia 代码的能力。这是因为 Julia 代码本身可以作为一种数据类型来表示，语言可以对其进行操作，就像它对数字、字符串和数组进行操作一样。这个数据类型被称为
    `Expr`。具有这种数据类型的对象被称为 `Expr` 对象或 *表达式对象*。表达式对象不同于 *表达式*，后者是返回结果的语言形式，例如 `3 * 5`。
- en: 'Expression objects often involve Julia `Symbol`s. We can create a `Symbol`
    by prepending a colon to a name, as with the attributes, such as `:red`, that
    we used when making plots. We can convert a string to a symbol with the `Symbol()`
    function as well: `Symbol("red") == :red`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式对象通常涉及 Julia 的 `Symbol`。我们可以通过在名称前加上冒号来创建一个 `Symbol`，就像我们在绘图时使用的 `:red` 这样的属性一样。我们也可以通过
    `Symbol()` 函数将字符串转换为符号，例如：`Symbol("red") == :red`。
- en: 'We can also use colons to construct expression objects by following the colon
    with an expression in parentheses. To reiterate: `3 * 5` is an expression, while
    `:(3 * 5)` is an expression object. If we enter `3 * 5` in the REPL, Julia evaluates
    the expression and returns `15`. If we enter `:(3 * 5)`, or any other expression
    object, it simply returns what we entered.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在冒号后面加上括号中的表达式来构造表达式对象。再强调一下：`3 * 5` 是一个表达式，而 `:(3 * 5)` 是一个表达式对象。如果我们在
    REPL 中输入 `3 * 5`，Julia 会评估该表达式并返回 `15`。如果我们输入 `:(3 * 5)` 或任何其他表达式对象，它会直接返回我们输入的内容。
- en: In order to evaluate the expression that the `Expr` object represents, the part
    inside the parentheses, we use the `eval()` function. If we enter `eval(:(3 *
    5))` in the REPL, Julia returns `15`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估 `Expr` 对象所表示的表达式（即括号内的部分），我们使用 `eval()` 函数。如果我们在 REPL 中输入 `eval(:(3 * 5))`，Julia
    会返回 `15`。
- en: '**NOTE**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We can turn a string into an expression using* Meta.parse()*—for example,*
    Meta.parse("3 * 5") *returns* :(3 * 5)*.*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们可以使用* Meta.parse() *将字符串转换为表达式*——例如，*Meta.parse("3 * 5")* 返回* :(3 * 5)*。'
- en: 'Sometimes putting the entire expression object on one line is inconvenient.
    Julia has a block called `quote` for defining such objects:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将整个表达式对象放在一行上不太方便。Julia 有一个名为 `quote` 的块，用于定义此类对象：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The assignment beginning the example assigns the result of the `quote` block
    to `ex`. Since `quote` blocks create expression objects, that’s the type of `ex`,
    as we confirm in the following line. Evaluating the expression performs the operations
    within the block, as the next two lines confirm.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的赋值语句将 `quote` 块的结果赋值给 `ex`。由于 `quote` 块创建了表达式对象，因此 `ex` 的类型就是这种类型，正如我们在下一行中确认的那样。评估该表达式会执行块中的操作，接下来的两行验证了这一点。
- en: The block gets its name from the concept of *quoting*, which means turning an
    expression into an expression object, whether we accomplish that by surrounding
    an expression with `:(...)` or using the `quote` block.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块的名称来源于*引号*的概念，它意味着将一个表达式转换为表达式对象，无论是通过使用 `:(...)` 来包围一个表达式，还是使用 `quote` 块来完成。
- en: In English, sometimes we need to distinguish between *using* a word or expression
    and talking *about* the word or expression. We do this by surrounding the terms
    we are discussing with quotes. Quoting in Julia serves the same purpose. We quote
    an expression so that we can act on it as an expression; the expression object
    is simply the quoted expression.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，有时我们需要区分*使用*一个单词或表达式和*谈论*这个单词或表达式。我们通过将我们讨论的术语放在引号中来实现这一点。在 Julia 中，引号有相同的作用。我们将表达式加上引号，这样就可以把它作为表达式来处理；表达式对象就是被引号包围的表达式。
- en: Most languages have no way to talk about themselves. All those that do, such
    as Julia, all Lisps, and Elixir, have a way to quote expressions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言没有办法自我描述。所有能够做到这一点的语言，如 Julia、所有的 Lisp 语言和 Elixir，都有一种引用表达式的方式。
- en: '***Expression Object Interpolation***'
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***表达式对象插值***'
- en: 'We can interpolate values into an expression object similarly to how we can
    interpolate into a string. As a simple example, let’s define a variable and create
    two expression objects, one that uses the variable and one that uses the interpolated
    value of the variable:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像在字符串中插值一样，将值插入到表达式对象中。作为一个简单的例子，定义一个变量并创建两个表达式对象，一个使用该变量，另一个使用该变量的插值值：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the definition of `ey`, the value of `w` was interpolated into the expression
    object at the time of its creation. The expression object `ex` contains the *variable*
    `w` instead. Applying `eval()` to those expression objects, before and after changing
    the value of `w`, clarifies the consequences of this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ey` 的定义中，`w` 的值在表达式对象创建时就被插入到其中。表达式对象 `ex` 则包含了*变量* `w`。在更改 `w` 的值之前和之后对这些表达式对象应用
    `eval()`，可以明确看出它们的后果：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Changing the value assigned to `w` does not change the result of evaluating
    `ey` because that expression does not contain `w` as a variable. Instead, it uses
    the *value* of `w` in its definition.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 改变 `w` 所赋的值不会改变 `ey` 的计算结果，因为该表达式并不包含 `w` 作为变量。相反，它使用的是 `w` 的*值*进行定义。
- en: With just these few simple metaprogramming tools, we can already perform a whole
    category of programming tricks that are impossible without them. For example,
    suppose we want to create a function that, given a string and a value, creates
    a variable from the string and assigns the value to it. [Listing 6-6](ch06.xhtml#ch6lis6)
    shows a function that performs this task.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 仅凭这些简单的元编程工具，我们已经能够执行一整类没有它们就无法完成的编程技巧。例如，假设我们想要创建一个函数，给定一个字符串和一个值，创建一个由字符串命名的变量并将值赋给它。[列表
    6-6](ch06.xhtml#ch6lis6)展示了一个执行此任务的函数。
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 6-6: Putting expression objects to work*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-6：将表达式对象付诸实践*'
- en: The `mkvar()` function converts the `s` string into a `Symbol`. It then creates
    an expression object that assigns to the interpolated value of that symbol the
    value of `v`. Finally, it applies `eval()` to the expression object. The result
    of this `eval()` is a new variable with a name identical to the supplied string
    `s`, and with the value `v`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkvar()` 函数将 `s` 字符串转换为一个 `Symbol`。然后，它创建一个表达式对象，将该符号的插值值赋给 `v` 的值。最后，它对该表达式对象应用
    `eval()`。这个 `eval()` 的结果是一个新变量，它的名称与提供的字符串 `s` 相同，并且值为 `v`。'
- en: 'Here it is in action:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的实际应用：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This kind of functionality requires metaprogramming. In particular, we can’t
    do `"Arthur" = 42`, because we can’t assign to a string.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这种功能需要元编程。特别是，我们不能做 `"Arthur" = 42`，因为我们不能将值赋给一个字符串。
- en: 'The previous example makes clear exactly what symbols are: they are the way
    Julia represents variables within expression objects. In other words, symbols
    are how Julia represents variables to itself. They are also, as we’ve shown, often
    drafted for service as keyword arguments and for other purposes, but that usage
    is tangential to their fundamental identity. Symbols are popular for these purposes
    simply because they’re more efficient than strings.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子清楚地表明了符号到底是什么：它们是 Julia 在表达式对象中表示变量的方式。换句话说，符号是 Julia 自我表示变量的方式。正如我们所展示的，它们也经常被用作关键字参数和其他用途，但这种用法是与它们的基本身份无关的。符号之所以流行，正是因为它们比字符串更高效。
- en: The `mkvar()` function is more than just a magic trick. The strings it consumes
    may be taken, for example, from the headings of a table of data read from a file.
    In that case, `mkvar()`, or something like it, could create variables named after
    those headings and assign them to the columns of data underneath them. We’ll explore
    applications of these ideas in [Chapter 10](ch10.xhtml).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkvar()` 函数不仅仅是一个魔术技巧。它所处理的字符串可能来自，例如，从文件中读取的一个数据表的标题。在这种情况下，`mkvar()` 或类似的东西可以根据这些标题创建变量，并将它们赋值给下面的对应数据列。我们将在[第10章](ch10.xhtml)中探索这些思想的应用。'
- en: '**Macros**'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**宏**'
- en: A *macro* is a function that accepts expressions, symbols, and literals as arguments
    and returns an expression object. The expression object is automatically evaluated
    at runtime.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*宏* 是一个接受表达式、符号和字面量作为参数并返回表达式对象的函数。该表达式对象会在运行时自动求值。'
- en: There is a crucial difference between macros and the other functions that we’ve
    studied up to now, including functions that manipulate expression objects. Functions
    are evaluated at runtime, using the current values of any global variables.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 宏与我们到目前为止学习的其他函数之间有一个至关重要的区别，包括操作表达式对象的函数。函数在运行时评估，使用当前全局变量的值。
- en: The processing inside a macro, in contrast, happens during a separate compilation
    stage *before* the program runs. The expression object returned by the macro is
    inserted into the code at the location of the macro and `eval()`ed. This property
    allows us to use macros to alter or add to the syntax of the language.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与此不同，宏的处理发生在程序运行之前的一个单独的编译阶段。宏返回的表达式对象被插入到代码中的宏位置并通过`eval()`执行。这个特性使我们可以使用宏来改变或添加语言的语法。
- en: '***How to Create Macros***'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***如何创建宏***'
- en: 'The following is a macro version of the `mkvar()` function that we defined
    in [Listing 6-6](ch06.xhtml#ch6lis6):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在[列表6-6](ch06.xhtml#ch6lis6)中定义的`mkvar()`函数的宏版本：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Normally, to avoid collisions with names in the calling context, macros change
    the names of all the variables they contain into private versions. In cases where
    we want these variables to refer to variables of the same name when we use the
    macro, we use `esc()` ➊ to bypass the private naming process. This is one of those
    cases because the purpose of this macro is to create a variable from the string
    we supply and to assign it a value.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了避免与调用上下文中的名称发生冲突，宏会将其包含的所有变量的名称改为私有版本。如果我们希望这些变量在使用宏时仍然引用同名的全局变量，可以使用`esc()`
    ➊来绕过私有命名过程。这就是这种情况，因为这个宏的目的是从我们提供的字符串创建一个变量并为其赋值。
- en: 'We invoke a macro by prepending an `@` sign to its name ➋. The syntax for supplying
    arguments is more flexible than in the case of functions. We can list the arguments
    separately using spaces, as in this example, or place a comma-separated list inside
    parentheses, as we do with functions: `@mkvarmacro("color", 17)`. If the argument
    is a literal array, we can dispense with the space and the parentheses and call
    the macro as `@macroname[1 2 3]`.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在宏的名称前加上`@`符号来调用宏 ➋。提供参数的语法比函数更灵活。我们可以像这个例子一样，用空格将参数单独列出，或者将用逗号分隔的参数列表放在括号内，就像我们对待函数那样：`@mkvarmacro("color",
    17)`。如果参数是字面量数组，我们可以省略空格和括号，直接调用宏，例如：`@macroname[1 2 3]`。
- en: As soon as the macro is invoked, the `Expr` object `($ss = $v)`, with interpolation
    substituting a literal `color` for `ss` and `17` for `v`, is evaluated, so 17
    is assigned to the variable `color`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用宏，带有插值的`Expr`对象`($ss = $v)`被评估，字面量`color`替代`ss`，`17`替代`v`，因此17被赋值给变量`color`。
- en: As an example of how we can use macros to add new syntax to Julia, suppose we
    don’t like using the `end` keyword in `while` loops. In [Listing 6-7](ch06.xhtml#ch6lis7)
    we’ll create a simple macro that accepts a condition and a loop body, with no
    `end` required. We’re not allowed to reuse the `while` keyword, so we’ll call
    our macro `@during`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们如何使用宏为Julia添加新语法的示例，假设我们不喜欢在`while`循环中使用`end`关键字。在[列表6-7](ch06.xhtml#ch6lis7)中，我们将创建一个简单的宏，接受一个条件和一个循环体，不需要`end`。我们不能重复使用`while`关键字，所以我们将宏命名为`@during`。
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 6-7: Creating new syntax with a macro*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表6-7：使用宏创建新的语法*'
- en: We use the `esc()` function ➊ because we want the loop body to be able to use
    variables defined outside the macro.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`esc()`函数 ➊是因为我们希望循环体能够使用宏外部定义的变量。
- en: 'Here’s how to use this macro:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用这个宏：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The last two lines show that the macro indeed references the variable `i` in
    the global scope.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行显示宏确实引用了全局作用域中的变量`i`。
- en: 'With our new powers, we can invent a kind of loop that doesn’t exist in the
    language. Let’s create an “until” loop that repeats a block *until* a condition
    is met. This is the same thing as a `while` loop that continues while the condition
    is *not* met. With this insight, our new macro is a simple modification of the
    one in [Listing 6-7](ch06.xhtml#ch6lis7):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们新的能力，我们可以发明一种语言中不存在的循环。让我们创建一个“until”循环，直到满足某个条件才重复执行一个代码块。这和`while`循环的工作方式相同，只是条件*不*满足时继续执行，而在条件满足时停止。基于这个思路，我们的新宏只是对[列表6-7](ch06.xhtml#ch6lis7)中的宏进行简单的修改：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let’s test it in the REPL to see if it does what we expect:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在REPL中测试一下，看看它是否按预期工作：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Our `@until` loop works as intended, incrementing `i` until `i == 11`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`@until`循环按预期工作，将`i`递增直到`i == 11`。
- en: Writing macros is inherently more difficult than writing normal functions, partly
    due to the necessity to keep track of levels of quoting and self-reference. Fortunately,
    you’ll never need to write a single macro to perform scientific calculations or
    numerical work. However, if you find you’re repeating “boilerplate” code often,
    and this repeated code can’t be expressed using a normal function, you may have
    a situation where the code-writing powers of macros can save you some work.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 编写宏本质上比编写普通函数要困难一些，部分原因是需要跟踪引用级别和自我引用。幸运的是，你永远不需要编写一个宏来执行科学计算或数值工作。然而，如果你发现自己经常重复写“模板”代码，而且这些重复的代码不能通过普通函数表达出来，那么宏的代码编写能力就能帮你节省一些工作。
- en: '***Useful Macros***'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***有用的宏***'
- en: Although you may never write your own macros, you’ll use them often. Both the
    standard library and many packages provide useful functionality through various
    macros. This section surveys several convenient macros for general use.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能永远不会编写自己的宏，但你会经常使用它们。标准库和许多包通过各种宏提供有用的功能。本节概述了几种常用的宏供一般使用。
- en: '**The Broadcast Macro**'
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**广播宏**'
- en: 'We’ve described how Julia’s dot operator can extend functions and operators
    to act element-wise over entire arrays (see “Broadcasting” on [page 51](ch02.xhtml#ch02lev1sec13)).
    We often want to write long expressions in which all, or the great majority, of
    the functions need to be broadcast over their array arguments. The broadcast macro
    frees us from having to sprinkle dots everywhere in such an expression—for example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经描述了 Julia 的点运算符如何扩展函数和运算符，使其对整个数组进行逐元素操作（详见“广播”章节，第 [51 页](ch02.xhtml#ch02lev1sec13)）。我们经常需要编写长表达式，其中所有或大多数函数都需要对它们的数组参数进行广播。广播宏使我们无需在这样的表达式中到处加点符号——例如：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This example constructs a three-column matrix showing when the exponential function
    becomes larger than its argument to the fourth power (`exp(x)` is the Julia function
    for *e*^(*x*)). The second column is made from an expression using the broadcast
    macro, while the third is an expression with the identical meaning, but with explicit
    dots. The two columns are identical.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子构建了一个三列矩阵，展示了指数函数何时大于其参数的四次方（`exp(x)` 是 Julia 中的 *e*^(*x*) 函数）。第二列是通过广播宏构造的表达式，而第三列是具有相同意义的表达式，但使用了显式的点运算符。这两列是相同的。
- en: 'To exclude a function from the macro’s automatic broadcasting, precede it with
    a dollar sign (`$`). As an example, here is the sum of the first 10 squares:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要从宏的自动广播中排除某个函数，只需在其前面加上美元符号（`$`）。例如，这里是前10个平方的和：
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `sum()` function, which adds all the numbers in an array, does not have
    a dot because it acts on the array as a whole, rather than element by element.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum()` 函数，它对数组中的所有数字求和，通常没有点操作符，因为它是作用于整个数组，而不是逐个元素。'
- en: 'If we rewrite the expression using the broadcast macro, we should exempt `sum()`
    from the auto-dotting:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用广播宏重写该表达式，我们应该将 `sum()` 排除在自动点运算之外：
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Without the prepending dollar sign, `sum()` would be applied to each element
    individually; however, this is not what we want, as `sum(n)` is simply equal to
    `n` when `n` is a single number.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有前缀美元符号，`sum()` 将会对每个元素单独应用；然而，这并不是我们想要的，因为当 `n` 是一个单独的数字时，`sum(n)` 就等于 `n`。
- en: '**The @chain Macro**'
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**@chain 宏**'
- en: The `@chain` macro, which is not part of the standard library and must be imported
    from the `Chain` package, is a more convenient alternative to the pipe operator
    (`|>`) for transforming data through a series of expressions. The pipe operator
    has certain limitations. For example, it’s designed to work only with functions
    that have a single argument. The `@chain` macro is one of several approaches in
    the Julia ecosystem that creates a more flexible pipelining mechanism.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`@chain` 宏是一个更方便的替代管道操作符（`|>`），用于通过一系列表达式转换数据。管道操作符有一些局限性，例如，它仅与具有单一参数的函数配合使用。`@chain`
    宏是 Julia 生态系统中几种创建更灵活管道机制的方式之一。'
- en: 'First, let’s look at the syntax of the built-in pipe with a simple example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过一个简单的示例来看看内置管道的语法：
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We’ve passed the string `"hello"` through two functions to transform it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过两个函数将字符串 `"hello"` 进行了转换。
- en: Suppose we want to continue the pipeline, adding `occursin()` as a third function,
    to check for the occurrence in the result of the string `"OL"`. The `occursin()`
    function takes the string to search in as the *second* argument, so there’s no
    obvious way to extend the pipeline to use it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想继续管道，添加`occursin()`作为第三个函数，检查字符串“OL”是否出现在结果中。`occursin()`函数将要查找的字符串作为*第二*个参数，因此没有显而易见的方式将其扩展到管道中使用。
- en: 'Instead of the pipe operator, we can use the `@chain` macro to accomplish this
    task:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`@chain`宏代替管道操作符来完成这个任务：
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `@chain` macro creates a pipeline from a series of expressions without the
    use of any extra operators. It handles functions of any number of arguments. By
    default, the result of each expression is fed into the first argument of the following
    function. To insert the result into an argument in a position other than the first,
    indicate its slot with an underscore ➊.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`@chain`宏通过一系列表达式创建一个管道，而无需使用任何额外的运算符。它可以处理任意数量参数的函数。默认情况下，每个表达式的结果会传入下一个函数的第一个参数。如果要将结果插入到非第一个位置的参数中，可以用下划线➊标记该位置。'
- en: '**The @time Macro**'
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**@time 宏**'
- en: 'The `@time` macro tells how much machine time a computation consumes, plus
    some information about memory allocations:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`@time`宏会告诉我们计算消耗了多少机器时间，并提供一些关于内存分配的信息：'
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First the REPL prints a line with information about the resources used, and
    then the result of the computation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，REPL会打印一行关于所使用资源的信息，然后是计算结果。
- en: '**NOTE**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The* @time *macro is handy for getting a rough idea of timings, but for more
    systematic benchmarking or profiling, I recommend importing the* BenchmarkTools
    *package and using the* @btime *macro and other tools therein. The* BenchmarkTools
    *macros can run an expression multiple times and take an average, separate run
    time from compilation time, and more.*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*@time*宏对于大致了解时间消耗很有帮助，但对于更系统的基准测试或分析，我建议导入*BenchmarkTools*包，并使用*@btime*宏和其中的其他工具。*BenchmarkTools*宏可以多次运行一个表达式并取平均值，分离运行时间和编译时间等。'
- en: '**Macros for Performance**'
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**性能宏**'
- en: Julia comes with several macros we can use to alter the behavior of the compiler,
    sometimes leading to more efficient code. They need to be used with care, as their
    use is not without risk. The two macros discussed in this section can provide
    significant speedups in some circumstances; in others, they have little or no
    effect. One usually has to experiment to find out if they’ll provide any benefit.
    These two macros, and similar strategies, should be explored at the final stages
    of performance tuning. During the development of an algorithm or a program, such
    attempts at optimization would likely be a counterproductive distraction.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Julia提供了几个宏，可以用来改变编译器的行为，有时能导致代码更高效。这些宏需要小心使用，因为它们的使用并非没有风险。本节讨论的两个宏在某些情况下可以显著加速程序；在其他情况下，它们几乎没有效果。通常需要通过实验来确定它们是否能带来任何好处。这两个宏以及类似的策略应该在性能调优的最后阶段进行探索。在算法或程序开发过程中，尝试这种优化可能会成为一种适得其反的干扰。
- en: 'Normally the compiler checks our indexing expressions to make sure we’re not
    indexing array elements that don’t exist, returning a `BoundsError` if we index
    beyond the end of an array, or wind up using a nonpositive index. In some routines,
    this bounds checking can affect performance. If we’re sure that an area of code
    cannot contain an indexing error, we can instruct the compiler to skip the bounds
    checking for that location using the `@inbounds` macro:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编译器会检查我们的索引表达式，以确保我们不会索引不存在的数组元素。如果我们索引超出数组末尾，或者使用非正索引，则会返回`BoundsError`。在某些例程中，这种边界检查可能会影响性能。如果我们确定某段代码中不会出现索引错误，可以使用`@inbounds`宏指示编译器跳过该位置的边界检查：
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `@inbounds` instruction at the start of the `for` loop tells the compiler
    not to worry about `x[i]` being an illegal access during the loop. We’re responsible
    for ensuring that `i` stays within the bounds of `x`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环开始时的`@inbounds`指令告诉编译器在循环期间不必担心`x[i]`会成为非法访问。我们负责确保`i`保持在`x`的边界内。'
- en: The utility of `inbounds` is much reduced in recent versions of Julia; there’s
    no longer a good reason to use it for versions more recent than 1.8\. However,
    we’ll encounter it in much existing code, so it’s important to know what it’s
    supposed to do.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新版本的Julia中，`inbounds`的效用大大减少；在1.8版本之后使用它已经没有什么好的理由。然而，我们会在许多现有代码中遇到它，因此了解它的作用非常重要。
- en: '**NOTE**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A common error is to try to generate the indices for the array* A *with* 1:length(A)*.
    This does not create legal indices for every type of array, and, if used to access*
    A *within an* @inbounds *section, it can create silent bounds errors. Instead,
    we should use* eachindex(A)*, which always returns an iterator over legal indices
    of* A*.*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个常见的错误是尝试用`1:length(A)`生成数组A的索引*。这并不能为每种类型的数组创建合法的索引，如果在`@inbounds`部分中使用它来访问A，可能会导致静默的越界错误。我们应该使用*eachindex(A)*，它总是返回一个合法索引的迭代器来访问A*。'
- en: 'As mentioned earlier in this chapter, addition and multiplication on floats
    are not associative: the results can depend on the order in which we add or multiply
    numbers. For this reason, the Julia compiler will normally perform arithmetic
    exactly the way we spell it out, even if it would be faster to change the order
    of operands or rewrite expressions to “real number equivalents” that would be
    more efficient. This ensures that running a program on different versions of the
    compiler will produce the same numerical results, as all the arithmetic will occur
    in the same order.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面提到的，浮点数的加法和乘法不是可交换的：结果可能依赖于我们加法或乘法的顺序。因此，Julia编译器通常会按我们写出的顺序执行算术运算，即使改变操作数的顺序或重写表达式成“实数等价物”可能会更高效。这样做可以确保在不同版本的编译器上运行程序时，所有的算术运算都按照相同的顺序进行，从而得到相同的数值结果。
- en: 'In situations where the last few decimal places of a result are not important,
    we can sacrifice some of this reproducibility to gain speed by allowing the compiler
    to rearrange our expressions. The instruction is provided by the `@fastmath` macro:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果的最后几个小数位不重要的情况下，我们可以通过允许编译器重新排列我们的表达式来牺牲部分可重现性，从而获得更高的速度。这一指令由`@fastmath`宏提供：
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here we’ve performed the same sum
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们进行了相同的求和操作
- en: '![Image](../images/math177.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/math177.jpg)'
- en: twice, the second time using the `@fastmath` directive. Our expression needlessly
    performs an extra billion divisions. One obvious optimization available for `@fastmath`
    is to factor out the constant *d*. The macro gets us a speedup of about 26 percent.
    It also changes the result slightly in the two final digits. Neither result is
    more “correct." This is an example of how arithmetic on floats depends on the
    details of the calculation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 两次计算，第二次使用`@fastmath`指令。我们的表达式不必要地进行了额外的十亿次除法运算。对于`@fastmath`，一个显而易见的优化是将常量*d*提取出来。这个宏能让我们获得约26%的加速。同时，它也稍微改变了结果的最后两位数字。两个结果都不算更“正确”。这是一个例子，说明浮点数运算如何依赖于计算的细节。
- en: '**Macros for String Formatting**'
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串格式化宏**'
- en: 'The `Printf` package provides two macros that format strings using the C-style
    specifications that have become a de facto standard across multiple programming
    languages. The following example shows how a macro makes our code neater, allowing
    us to list the variables to be formatted without parentheses and commas:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`Printf`包提供了两个宏，用于使用C风格的格式说明符格式化字符串，这些格式说明符已经成为多个编程语言的事实标准。以下示例展示了宏如何使我们的代码更加简洁，让我们在不使用括号和逗号的情况下列出要格式化的变量：'
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The format specifiers are the fragments in the string beginning with `%`; the
    digit after the decimal point determines the number of digits after the point
    printed in the result. For a list of all the format specifiers and a guide to
    their syntax, see “Further Reading” on [page 187](ch06.xhtml#fur6).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 格式说明符是字符串中以`%`开头的片段，小数点后的数字决定了结果中小数点后打印的数字位数。关于所有格式说明符的列表和语法指南，请参见[第187页](ch06.xhtml#fur6)的“进一步阅读”。
- en: A companion to this macro is `sprintf`, which behaves the same way but returns
    the formatted string as a result rather than printing it. Use `sprintf` to store
    the generated string in a variable.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏的伴侣是`sprintf`，它的行为相同，但返回格式化后的字符串作为结果，而不是直接打印。使用`sprintf`可以将生成的字符串存储在变量中。
- en: '**Macros for Information**'
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**信息宏**'
- en: Several macros that provide information about the environment in which they
    are invoked are always available. The `@__MODULE__`, `@__DIR__`, `@__FILE__`,
    and `@__LINE__` macros return the module, directory, filepath, and line number,
    respectively, where they are called. These macros can be useful for debugging,
    writing build scripts, code formatting, testing, and other purposes. (Each of
    the macro names in this paragraph begins and ends with a double underscore.)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个宏始终可用，它们提供有关调用它们的环境的信息。`@__MODULE__`、`@__DIR__`、`@__FILE__` 和 `@__LINE__`
    宏分别返回它们被调用的模块、目录、文件路径和行号。这些宏在调试、编写构建脚本、代码格式化、测试和其他用途时非常有用。（这一段中的每个宏名称前后都带有双下划线。）
- en: One essential aid when debugging macros is a macro called `@macroexpand`. Simply
    prepend it to your macro call, and it will show you what the macro is using for
    each variable and reference.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 调试宏时的一个重要工具是名为 `@macroexpand` 的宏。只需将其加到宏调用前，它就会展示宏在每个变量和引用上使用的内容。
- en: '**Error Handling**'
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**错误处理**'
- en: 'Like most modern languages, Julia has methods for handling, manipulating, and
    creating errors (also called *exceptions*). We’ve seen plenty of examples of errors
    in this book so far: they occurred in REPL sessions or as a result of running
    programs when Julia encountered a situation that prevented it from continuing
    with the computation. These situations have included calling functions with arguments
    that they were not designed to accept, indexing arrays outside their bounds, using
    an undefined name, and others. Each one was introduced in order to illustrate
    a characteristic of the language, but in practice we encounter errors when something
    unexpected happens, or something happens that we need to guard against.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数现代编程语言一样，Julia 提供了处理、操作和创建错误（也称为 *异常*）的方法。到目前为止，我们在本书中已经看到许多错误的例子：它们出现在
    REPL 会话中或在运行程序时，当 Julia 遇到无法继续计算的情况时。这些情况包括调用函数时传入了不被接受的参数、数组越界、使用未定义的名称等。每一个错误都是为了展示语言的某个特性，但在实际使用中，我们遇到错误通常是因为出现了意外情况，或者发生了需要防范的事情。
- en: In this section we’ll explore how to handle errors and some methods for making
    them part of our programs’ flow control. Julia’s type system and its method of
    function dispatch, covered in [Chapter 8](ch08.xhtml), provide a cleaner way to
    accomplish some of what relies on exception handling in other languages. These
    more idiomatic Julia techniques should be preferred because they allow the compiler
    to perform more optimizations. Nevertheless, sometimes the methods described in
    this section are the most convenient way to accomplish a programming task.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何处理错误以及将其纳入程序流程控制的一些方法。Julia 的类型系统和函数调度方法（在[第 8 章](ch08.xhtml)中讨论）提供了一种更清晰的方式来完成其他语言中依赖于异常处理的部分内容。由于这些更符合
    Julia 风格的技术能够让编译器进行更多优化，因此应该优先使用。然而，某些情况下，本节中描述的方法仍然是完成编程任务的最便捷方式。
- en: '***Types of Errors***'
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***错误类型***'
- en: 'Julia uses about 25 distinct kinds of exceptions. Some occur rarely, while
    others we may only wish were rare. Here are the most common ones:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 使用大约 25 种不同类型的异常。有些异常很少发生，而有些则是我们希望它们能更少发生的。以下是最常见的异常：
- en: '[PRE55]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The identifier immediately following the word `ERROR:` is the name of the error.
    It’s usually followed by some explanation and even occasionally some advice.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 紧跟在 `ERROR:` 之后的标识符是错误的名称。它通常会跟随一些解释，有时甚至还会提供一些建议。
- en: Most of the error messages are self-explanatory. A `MethodError` means that
    someone tried to call a function with argument types that it doesn’t support.
    Operators such as + are functions written with an infix syntax. (See “Creating
    Multiple Methods” on [page 230](ch08.xhtml#ch08lev1sec6) for more information
    on methods and the precise meaning of the error message.)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数错误信息都能自解释。`MethodError` 表示某人尝试调用一个函数，但传入了该函数不支持的参数类型。像 `+` 这样的运算符是以中缀语法书写的函数。（有关方法和错误信息含义的更多信息，请参见[第
    230 页](ch08.xhtml#ch08lev1sec6)中的“创建多个方法”部分。）
- en: The `*` operator, when applied to arrays, performs matrix multiplication, which
    requires that the second dimension of the first argument match the first dimension
    of the second argument ➊.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `*` 运算符应用于数组时，它执行矩阵乘法，这要求第一个参数的第二维与第二个参数的第一维匹配 ➊。
- en: We’re allowed to divide by a floating-point 0, which results in `Inf` or `-Inf`,
    which means that we can do `1/0` because the `/` operator converts to floating
    point. However, dividing by 0 using the integer division operator (`÷`) results
    in a `DivideError` ➋.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用浮点数0进行除法，这会得到`Inf`或`-Inf`，意味着我们可以做`1/0`，因为`/`运算符会转换为浮点数。然而，使用整数除法运算符（`÷`）除以0会导致`DivideError`
    ➋。
- en: If we try a conversion between numerical types that would lose information,
    an `InexactError` is the result ➌.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试进行会丢失信息的数值类型转换，结果将是`InexactError` ➌。
- en: The usual types of integers aren’t large enough to hold the result of `factorial(55)`,
    but, as the advice following the error message ➍ suggests, we can turn to another
    type of number. We’ll cover `big` numbers in “‘Big’ and Irrational Types” on [page
    216](ch08.xhtml#ch08lev1sec1).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 普通整数类型的大小不足以存储`factorial(55)`的结果，但正如错误消息后面建议的那样 ➍，我们可以使用另一种类型的数字。我们将在《'大'数字与无理类型》一节中详细讨论`big`类型，参见[第
    216 页](ch08.xhtml#ch08lev1sec1)。
- en: '***The Call Stack***'
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调用栈***'
- en: Suppose we have a series of function calls, where a function calls a second
    function, which calls a third, and so on. When the final function in this chain
    finishes its job, the compiler needs to know what to do next. In order to know
    what the next instruction should be, the compiler keeps track of “how we got here.”
    That information, which includes the details of the chain of function calls, is
    called the *call stack*. It forms the sometimes lengthy part of error messages
    that I usually omit from the listings in this book to save space.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一系列函数调用，其中一个函数调用第二个函数，第二个函数调用第三个函数，以此类推。当这一链中的最后一个函数完成工作时，编译器需要知道接下来该做什么。为了知道下一个指令是什么，编译器需要跟踪“我们是如何到达这里的”。这些信息，包括函数调用链的详细情况，称为*调用栈*。它通常构成错误消息中较长的部分，我通常为了节省空间在本书的示例中省略它们。
- en: '**NOTE**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In practice, the compiler optimizes nested function calls through “inlining”
    when possible. This optimization replaces the nested calls with direct insertion
    of the called function’s code into the calling function. But there is still the
    logical notion of the call stack, and the error report prints this logical stack,
    noting any inlining.*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*实际上，编译器在可能的情况下会通过“内联”优化嵌套函数调用。这种优化会将嵌套调用替换为直接将被调用函数的代码插入调用函数中。但调用栈这一逻辑概念仍然存在，错误报告打印出这一逻辑栈，并标明任何内联的情况。*'
- en: To illustrate how the call stack works, [Listing 6-8](ch06.xhtml#ch6lis8) sets
    up a series of five functions, each one defined to call the next one by name,
    except the last, which calls the `log()` function.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示调用栈如何工作，[列表 6-8](ch06.xhtml#ch6lis8) 设置了一系列五个函数，每个函数都定义为按顺序调用下一个函数，最后一个调用`log()`函数。
- en: '[PRE56]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*Listing 6-8: A chain of functions*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-8：一系列函数调用*'
- en: Function `a()` calls `b()`, passing the supplied argument `n`. Function `b()`
    decrements that argument and calls `c()`, passing its new value, then `c()` calls
    `d()` similarly. Finally, `e()` calls `log(n)`, where now `n` is 3 less than the
    original `n`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`a()`调用`b()`，传递参数`n`。函数`b()`将该参数递减并调用`c()`，传递新的值，接着`c()`同样调用`d()`。最后，`e()`调用`log(n)`，此时`n`比原始`n`小了
    3。
- en: '[Listing 6-9](ch06.xhtml#ch6lis9) shows calling `a()` a couple of times.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-9](ch06.xhtml#ch6lis9) 显示了多次调用`a()`。'
- en: '[PRE57]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*Listing 6-9: A call stack when an error occurs*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-9：错误发生时的调用栈*'
- en: 'First we call `a(5)`, which ultimately leads to a call to `log(5-3)`, or `log(2)`,
    and returns the expected result. When we call `a(2)`, that results in `log(2-3)`,
    or `log(-1)`, and the attempt to take the logarithm of a negative number produces
    the expected `DomainError`. What follows is the stacktrace: information about
    the call stack at the moment that the error occurred. This data, which can become
    far lengthier than in this artificial example, is an aid to debugging, informing
    us about the state of the program that led to an error condition.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们调用`a(5)`，这最终会调用`log(5-3)`，即`log(2)`，并返回预期的结果。当我们调用`a(2)`时，结果是`log(2-3)`，即`log(-1)`，尝试对负数取对数会产生预期的`DomainError`。接下来是堆栈跟踪：它提供了出错时调用栈的相关信息。这些数据，可能比这个人工示例要长得多，是调试的有力助手，帮助我们了解导致错误的程序状态。
- en: The numbers in square brackets are part of the trace as printed in the REPL,
    showing the sequence of function calls, beginning with the most recent, where
    the error was raised, and proceeding up the chain. The first entry is the function
    that actually handles the error. This is followed by the log functions themselves,
    and then our functions `e()` up through `a()`. The final entry informs us that
    `a()` was called from the REPL. The stacktrace also tells us which functions were
    inlined by the compiler.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '***try...catch Blocks***'
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instead of allowing errors to simply stop our program, we can intercept them.
    We do this in Julia with the `try`...`catch` block, another form of flow control
    like the `if` block. Here’s an example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `friendly_log()` function wraps the built-in `log()` function in some error
    handling. The normal `log()` rejects negative arguments with a `DomainError`,
    but this version tries again with the argument’s absolute value, warning the user
    about what it’s doing. The `try` part of the block contains the code whose errors
    we want to intercept; the `catch` part intercepts them, optionally assigning the
    error itself to a variable, here `oops`. Inside the `catch` block we put an ordinary
    `if` block, using `isa` to test for the type of error (“Types in Practice” on
    [page 214](ch08.xhtml#ch08lev1) explains more about `isa` and types). If `oops`
    happens to be a `DomainError`, the `@warn` macro prints a warning to the terminal,
    after which we issue another message, using the `@info` macro, explaining how
    the program plans to change the faulty argument ➊. We then call `log()` with the
    argument made positive.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: If the error is not a `DomainError`, but instead is a `MethodError`, something
    else is wrong with the argument. In this case, we don’t know what to do and the
    program should halt. The `@error` macro ➋ prints an error message, *after which
    the program continues*. Since there’s nothing else for it to do, it exits. The
    `@error` macro, like the `@warn` macro, simply prints an appropriately formatted
    message; neither macro creates an error condition nor has any effect on flow.
    On a color device, warnings are signaled in yellow and errors in red, and both
    attempt to indicate where in the program the problem occurred. Messages generated
    by `@info` appear in blue in the REPL, and don’t include a program location. All
    three macros are part of Julia’s logging system. See the link to the documentation
    in “Further Reading” on [page 187](ch06.xhtml#fur6) for information about more
    of what you can do with this logging information.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we “handle” the errors in the `catch` block, they won’t stop the program
    or lead to a stacktrace:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If we had not intercepted the error in the `catch` block, it would have led
    to a stacktrace as in the previous section, with `call_fl()` as part of the call
    stack.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '***Using throw()***'
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The REPL’s help mode explains that `throw()` throws an object as an exception.
    Most Julia tutorials describe it as a way for the programmer to create errors.
    Both of these descriptions are true, but they tell only part of the story. Before
    delving into the full power of `throw()`, let’s look at a simple example of where
    we might want to create an error where there otherwise would not be one.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating Errors**'
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `log()` function allows us to call it with an argument of 0, returning
    `-Inf` as the result. Suppose we wanted to have a logarithm function that did
    *not* allow 0 as an argument because we wanted to exclude infinities from its
    results. The `finite_log()` function would be one way to accomplish this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'An `if` block checks for the 0 input and calls `throw()` if it finds one. The
    argument of `throw()` is the name of an error turned into a function; each of
    Julia’s errors has such an associated function for constructing the error. The
    `finite_log()` function raises a `DomainError` if it gets 0 as an argument. We
    can raise any error we want, but as the idea here is to exclude a value from the
    domain, a `DomainError` makes sense:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here `finite_log()` behaves like `log()` unless it gets a 0, when it halts with
    a `DomainError`. The message that we included in `throw()` is printed out with
    the error message.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the error constructors accept arguments for information for Julia to
    include in the error message. To see what arguments are permitted, ask the REPL:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The documentation informs us that there are two versions, one with just the
    offending value, and the version that we used, with an explanatory message as
    well.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '**Combining throw() with try...catch Blocks**'
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Combining `throw()` with `try`...`catch` blocks unleashes its full power. In
    combination, they create a new form of flow control that allows us to pass *any
    value* up the call stack until it is intercepted by a `catch`, at which point
    we can halt the program or do something else.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: As an example, [Listing 6-10](ch06.xhtml#ch6lis10) modifies the chain of functions
    from [Listing 6-8](ch06.xhtml#ch6lis8).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '*Listing 6-10: Throwing and catching*'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the `e()` function first, we’ve added an `if` block above what used
    to be its only line. Before trying to calculate the logarithm, it checks the argument
    `n`. If this argument is not positive, it calls `throw()` with a `Tuple` as an
    argument ➊. In both cases, the tuple’s first element is `n` and its second element
    is a string. The `throw()` function sends this tuple up the call stack and returns
    from `e()` without attempting to calculate the logarithm. If `n == 0`, we send
    a different message up the call stack.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: The message sent by `throw()` travels from function call to function call until
    it’s intercepted by the `try`...`catch` block in function `a()`. The `catch` statement
    assigns the message, in this case a `Tuple`, to the variable `oops`, where it’s
    examined in the `if` block, which prints the appropriate warning or error message.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Here it is in action:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This exhibits a dramatic difference from the error reporting shown in [Listing
    6-9](ch06.xhtml#ch6lis9). Here we see no call stack, but merely the messages constructed
    in our `try...catch` block. The `throw()...catch` mechanism lets us toss a message
    “over the heads” of any number of functions in a call stack, directly to the first
    one ready with the appropriate `catch` statement. [Listing 6-9](ch06.xhtml#ch6lis9)
    had no `catch` in place to intercept the error, so Julia halted the program and
    printed out the complete call stack for our diagnostic use.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '***The finally Clause***'
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `try...catch` block can optionally end with a `finally` clause, which is
    executed before the program exits. We typically use this for “cleanup,” such as
    releasing external resources or file handles that an error condition otherwise
    might leave in an uncertain state.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a `finally` clause to `a()` from [Listing 6-10](ch06.xhtml#ch6lis10):'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Calling it as before, we’ll see the following:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This example shows how the `finally` clause is always executed, whether there
    is a message to catch or not.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the more advanced language features discussed in this chapter, we’ve attained
    a higher level of Julia mastery. We’re now better prepared for the detailed applications
    in [Part II](part2.xhtml), where we’ll see how to apply our skills to address
    problems across a variety of fields.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: The source containing the lists of characters available for infix operators,
    with their precedences, is available at [*https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm*](https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm).
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on page tabulating C format specifiers, visit [*https://web.archive.org/web/20220127135451/https://www.journaldev.com/35137/format-specifiers-in-c*](https://web.archive.org/web/20220127135451/https://www.journaldev.com/35137/format-specifiers-in-c).
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read Stefan Karpinski’s masterful explanation of what symbols really
    are at [*https://stackoverflow.com/a/23482257*](https://stackoverflow.com/a/23482257).
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation about the logging system and further uses for the `@info`, `@warn`,
    and `@error` macros is available at [*https://docs.julialang.org/en/v1/stdlib/Logging/*](https://docs.julialang.org/en/v1/stdlib/Logging/).
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
