- en: '**6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FUNCTIONS, METAPROGRAMMING, AND ERRORS**
  prefs: []
  type: TYPE_NORMAL
- en: '*A small error at the beginning of something is a great one at the end.*'
  prefs: []
  type: TYPE_NORMAL
- en: —Thomas Aquinas
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll explore three topics that afford greater power, control,
    and flexibility when writing programs. We’ll delve deeper into the central subject
    of functions, and further explore function arguments and higher-order functions.
    We’ll see how metaprogramming and macros let us create new syntax and bend Julia
    to our will in a way that’s not possible with most programming languages. Finally,
    we’ll see how to take control of the error system and use it to manipulate program
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions and Their Arguments**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.xhtml), we learned about positional and keyword arguments
    to functions. In this section we’ll extend our knowledge of functions and learn
    additional ways to supply them with arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '***Concise Syntax for Keyword Arguments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Keyword arguments tend to have names that reflect their purposes, which means
    when calling a function using variables for some of the keyword arguments, the
    names of those variables often are the same as their names in the function definition.
    This is even more likely to happen if we’ve defined these variables with their
    eventual use in calling the function in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under such circumstances our function calls look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Julia has a syntax option that reduces this visual noise and unnecessary typing.
    We can replace the previous call with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As the example shows, we can use either a variable with the same name as the
    keyword or a composite object that has a property name matching a keyword name.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Splat and Slurp Operators***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `...` operator (three dots) is either a *splat* or a *slurp*, depending
    on context. When we’re supplying arguments to a function, we can *splat*, and
    when we’re defining a function, we can *slurp*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Splatting**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Suppose we make a function that takes three arguments and adds them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When we supply three arguments, as the function definition demands, the sum
    is returned. However, if the three values are part of a vector, we get an error
    ➊ if we call the function with the vector as an argument. That’s because its definition
    includes no method that accepts a single `Vector` argument; the only option is
    three separate values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could handle this situation by extracting the values within `v3` into three
    separate variables and passing those to `addthree()`, but, since this situation
    arises frequently, Julia provides an easier way, through an operator spelled as
    three dots and called *splat*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here the splatting operator unpacks the values in a collection and supplies
    them as separate arguments to the called function.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-1](ch06.xhtml#ch6lis1) shows how we can also splat keyword arguments
    stored in a named tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-1: Splatting a named tuple*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we create a new function, `addthreeWithCoefficients()`, that
    takes the three keyword arguments `f1`, `f2`, and `f3` and multiplies the positional
    arguments by them before returning the sum. We then create a named tuple, `coeffs`,
    that has two properties with names matching two of the keyword arguments. When
    we call the function with a splat applied to the named tuple ➊, `f1` and `f2`
    get values assigned from the corresponding properties of the tuple. The argument
    `f3` does not exist in the tuple, so it gets its default value of 1.
  prefs: []
  type: TYPE_NORMAL
- en: Although structs also have properties, we can’t use them for splatting in this
    way. This limitation is related to the fact that we can’t iterate over a struct
    as we can over a named or ordinary tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, dictionaries will work, as long as the keyword names appear as symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here the dictionary keys `:f1` and `:f2` correspond to the arguments `f1` and
    `f2` in the function definition in [Listing 6-1](ch06.xhtml#ch6lis1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Slurping**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In a function definition, the three dots indicate the *slurp* operator. Slurping
    is a kind of inverse operation to splatting: instead of unpacking a collection
    into separate arguments, it packs any number of separate arguments into a single
    iterable object. If we want a function to accept an unknown, or variable, number
    of positional arguments, we can use slurping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `addonlythreeWithNote()` function returns the sum of the first three arguments
    we supply, just as the `addthree()` function did. This version, however, accepts
    any number of additional arguments, which it packs into a tuple called `more`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also slurp keyword arguments. The function defined in the following
    example performs two optional tests on the string supplied as its positional argument.
    If it gets a keyword called `palindrome`, it tests for the thusly named property,
    and if it gets one called `onlyascii`, it uses the `isascii()` function to check
    for the presence of non-ASCII characters in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Because we define `examine_string()` using slurping for keyword arguments, it
    doesn’t matter if it’s called with extra arguments ➊; they will be ignored. Since
    we supply default values for the keyword arguments in the function definition,
    it also doesn’t matter if some are missing. Finally, since the program checks
    only for the presence of the keyword arguments, the values assigned in the call
    are arbitrary.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also call the function with a splatted value as before. The difference
    now is that the object we splat into the call may contain superfluous keywords
    without creating an error condition. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Defining functions with slurped keyword arguments can be convenient for users.
    For example, some of the functions in the `Plots` package work this way. We can
    call them with keywords that they don’t use; they’ll use the ones they can handle
    and ignore the others. This might happen in the REPL if we create a plot using
    one plotting function supplied with a list of keywords and then decide we want
    to use a different one. We can press the up arrow and change the function’s name
    without having to consult its documentation to see whether it understands all
    the keywords we used previously.
  prefs: []
  type: TYPE_NORMAL
- en: Julia allows one more way to supply keyword arguments to such functions. We
    can list them separately in the form `:kw=>value`, with keywords appearing as
    symbols, or we can splat a dictionary, but all of its keys must be symbols.
  prefs: []
  type: TYPE_NORMAL
- en: '***Destructuring***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Destructuring* refers to the unpacking of a tuple of values into named variables
    with a single assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This feature is especially convenient in unpacking tuple return values from
    functions. As mentioned previously, tuples need not be written with parentheses
    as long as omitting them doesn’t create an ambiguity, so we can write the assignment
    in the example just shown as `x, y = 3, 4`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-2](ch06.xhtml#ch6lis2) shows another form of destructuring that
    unpacks keyword arguments from a struct, using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-2: Destructuring a struct*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the definition of `google` from [Listing 5-2](ch05.xhtml#ch5lis2)
    is in force. In this type of destructuring, the variable names on the left-hand
    side of the assignment must match the field names of the composite type on the
    right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Keyword destructuring from structs first appeared in Julia v1.7\. In earlier
    versions,* (; a, b) *is a syntax error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The utility of this form of destructuring may not be immediately obvious. After
    all, without this peculiar syntax, we can still do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It’s not much more verbose than the form in [Listing 6-2](ch06.xhtml#ch6lis2)
    and has the same effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, one advantage of this destructuring syntax is in providing a succinct
    way to define functions that take keyword arguments extracted from structs. In
    the following example, we first define a struct with three fields and create an
    object from the struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Then we make a different version of the `addthreeWithCoefficients()` function
    that we created in [Listing 6-1](ch06.xhtml#ch6lis1) ➊. Instead of a list of keyword
    arguments, this version takes a fourth positional argument that has the syntax
    of a struct destructuring. When we call the function, supplying the composite
    object as the fourth positional argument, the function makes the assignment`(;
    f1, f2,` `f3) = someco`. Referring to the syntax in [Listing 6-2](ch06.xhtml#ch6lis2),
    we can see that this will assign 100 to `f1`, 10 to `f2`, and 1 to `f3`. The struct
    used as an argument may contain fields that are not extracted by the function,
    as the destructing syntax doesn’t require all fields to be unpacked.
  prefs: []
  type: TYPE_NORMAL
- en: '***Operators Are Functions Too***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Binary operators in Julia, such as `*` and `+`, also called *infix operators*,
    are functions of two arguments. Each one has a more explicit functional form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, the `+` function operates on the arguments 1, 2, and 3,
    adding them up to return 6\. The functional form of infix operators can be more
    concise when we have many arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Since binary operators are functions, we can pass them as arguments to higher-order
    functions (see [Listing 6-5](ch06.xhtml#ch6lis5) for an example).
  prefs: []
  type: TYPE_NORMAL
- en: In an expression involving infix operators, the order of operations, or *precedence
    rules* for operators, determines the result. For example, the expression `3 +
    2 * 5` evaluates to `13` because multiplication happens before addition.
  prefs: []
  type: TYPE_NORMAL
- en: When using the functional forms of operators, there are no precedence rules,
    because the function application syntax makes the order of operations explicit.
    For example, the expression `3 + 2 * 5` is equivalent to `+(3, *(2, 5))`. The
    syntax shows that the multiplication occurs before the addition.
  prefs: []
  type: TYPE_NORMAL
- en: Julia allows us to use certain characters to define our own binary operators.
    If we create a function and give it one of these characters for its name, we can
    use the function in an infix position.
  prefs: []
  type: TYPE_NORMAL
- en: We can’t create an infix operator from any character, however. The source code
    for Julia’s interpreter provides a complete list of available characters (see
    “Further Reading” on [page 187](ch06.xhtml#fur6)). The source also indicates the
    precedence of each character by grouping them in classes with equal precedence.
    When deciding on a symbol for an infix operator, it’s not enough to pick one that
    looks right. We must decide how the operator is to fit within the hierarchy of
    precedence and choose a symbol in the appropriate group.
  prefs: []
  type: TYPE_NORMAL
- en: The three major precedence groups are multiplication, addition, and comparison.
    [Figure 6-1](ch06.xhtml#ch6fig1) shows a small selection of characters from each
    group.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch06fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1: A few operator characters*'
  prefs: []
  type: TYPE_NORMAL
- en: Comparison operators have the lowest precedence of these three types, so the
    expression `2 * 3 + 2 > 7` is equivalent to `((2 * 3) + 2) > 7` and returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use one of these characters to create a new infix operator that extends
    the idea of subtraction to give us the Euclidean distance between two vectors.
    We want it to have the same precedence as addition and subtraction operators,
    so we’ll pick a symbol from that group that looks like it has something to do
    with subtraction (enter \boxminus followed by TAB to enter the function’s name
    in the REPL).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To learn the shortcut for any other special character, paste it in after entering
    help mode.*'
  prefs: []
  type: TYPE_NORMAL
- en: After this definition, we have a new function with a single-character name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the character is in the list of characters blessed for use as infix operators,
    it should work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This result is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the new operator in an expression containing a higher-precedence
    operation to check that it follows the desired precedence rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The multiplications were taken before the vector subtraction, as expected (the
    result may remind you of the 3-4-5 right triangle from high school trigonometry).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can transform infix operators we create ourselves into broadcast versions
    using the dot prefix, just like built-in operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The broadcasting operation applies our function to all corresponding elements
    of the pair of vectors (of vectors). The result is a vector containing the Euclidean
    distance between each pair of corresponding vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Mapping, Filtering, and Reduction Operators***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *higher-order function* is a function that takes one or more functions as
    some of its arguments. Usually they either transform functions into other functions
    or apply them to data supplied as further arguments. The three operators `map()`,
    `filter()`, and `reduce()` are higher-order functions that apply a supplied function
    to a collection.
  prefs: []
  type: TYPE_NORMAL
- en: '**The map() Operator**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `map()` operator applies a function to each element of a collection and
    returns another collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here `map()` applies `double()` to each element of the matrix individually,
    returning a result with the same shape as the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of an infix operator, `map` applies it between corresponding elements
    of all the collections supplied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The result has the same shape as the collections that `map()` is operating on.
    The result’s first element comes from applying `+` to the first elements of all
    the collections; the second element, 15, is 3 + 5 + 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to understanding `map()` is understanding `zip()` because the `map()`
    operator combines the elements of the arrays we give it using `zip()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, `map()` applies the `+` operator between the elements of
    the vector and the 2×2 matrix in column-major order. In both cases, it stops when
    it runs out of elements in one of the collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, `map()` returns the same result as an equivalent broadcast using
    the dot. The map of `double()` earlier could have been written this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'However, mapping and broadcasting are not the same. We can see this clearly
    in the case of an infix operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the array on the left-hand side has a different shape from
    the one on the right-hand side. However, its shape fits the shape of the *rows*
    of the right-hand array. The broadcasting operator `.+` extends, or broadcasts,
    the array `[20 30]` over the rows of the other array.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we make the left-hand array a single column instead of a single row, it’s
    broadcast over the columns of the other array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Examining the examples in this section should make the difference between mapping
    and broadcasting clear. Unlike broadcasting, `map()` does not perform operations
    on entire arrays, but goes element by element, using `zip()` under the hood. Using
    `map()` in this last example yields a different result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `[3, 5]` column of the last argument is never used because `map()` runs
    out of elements before it gets there.
  prefs: []
  type: TYPE_NORMAL
- en: '**The filter() Operator**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `filter()` operator takes a function of one variable as its first argument;
    this function should return `true` or `false`. It applies this function to each
    element of its second argument, which should be a collection. It returns a new
    collection with the elements for which the function returned `false` *filtered*
    out, or removed.
  prefs: []
  type: TYPE_NORMAL
- en: As with `map()`, [Listing 6-3](ch06.xhtml#ch6lis3) shows how `filter()` is often
    used with anonymous functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-3: Using filter() with an anonymous function*'
  prefs: []
  type: TYPE_NORMAL
- en: Here we’ve created a list of the integers from 1 to 100 that are divisible by
    17.
  prefs: []
  type: TYPE_NORMAL
- en: Julia provides a collection of test functions that can be convenient to use
    with `filter()`, such as `isodd()`, `iseven()`, `isfinite()`, and `isfile()`,
    which answer the questions indicated by their names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `isascii()` function tells you whether a character is part of the old ASCII
    character set; we can use it on a string to filter out non-ASCII characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We get the string back with “ç” filtered out. We can also invert the condition
    to filter out the ASCII characters with `filter(!isascii, "François")`, which
    returns `"ç"`.
  prefs: []
  type: TYPE_NORMAL
- en: '**The reduce() Operator**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ve used the `sum()` function several times. It adds up all the numbers in
    an array, reducing it to a single number. The `reduce()` higher-order function
    generalizes this concept. It applies a function of two variables, supplied as
    its first argument, to a collection supplied as its second argument.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider an example to visualize how it works. If there were no `sum()`
    function, we could use `reduce()` instead. We can calculate the sum `1 + 2 + 3`
    with `sum([1, 2, 3])`, but also with `reduce(+, [1, 2, 3])`.
  prefs: []
  type: TYPE_NORMAL
- en: We can use any binary operator, or any function of two variables, with `reduce()`.
    For example, [Listing 6-4](ch06.xhtml#ch6lis4) shows a function that divides its
    first argument by its second and uses it in `reduce()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-4: The reduce() function*'
  prefs: []
  type: TYPE_NORMAL
- en: The last line shows how `reduce()` inserts the function between elements, accumulating
    partial results as it goes.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, reducing with division introduces a complication. While the `+` and
    `*` operators are *associative*, division and subtraction are not. Associativity
    means that it doesn’t matter how we group: `(1 + 2) + 3` gives the same result
    as `1 + (2 + 3)`. Division is not associative: `1/(2/3)` is equal to 1.5.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In fact, addition and multiplication are associative when operating on real
    numbers (and other number systems in the realm of mathematics), but they are not
    truly associative when applied to floating-point numbers in a computer. Although
    the numerical effect of association, the difference between (*a *+* b*) +* c *and*
    a *+ (*b *+* c*), is usually small, it’s better to use the folding operators,
    which we’ll introduce next, when numerical accuracy or reproducibility are important.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases where the function or operator is not associative, the result of using
    `reduce()` is undefined: we cannot assume that it works from left to right. In
    such cases, we should use `foldl()` or `foldr()`, which work just like `reduce()`,
    but associate from the left or the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 6-5](ch06.xhtml#ch6lis5) shows how the `reduce()` operator, but not
    `foldl()` or `foldr()`, accepts the keyword argument `dims` to reduce along the
    specified dimension.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-5: Reducing along a specified dimension*'
  prefs: []
  type: TYPE_NORMAL
- en: Here `dims=1` causes a reduction along the rows, while `dims=2` reduces along
    the columns. If we omit the `dims` argument, the result is a reduction over all
    elements, giving the single number 33.
  prefs: []
  type: TYPE_NORMAL
- en: 'All three reducing functions accept another keyword argument that acts as a
    default in case they encounter an empty collection. This argument is called `init`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when faced with the empty collection `[]`, `reduce()` returns
    the specified value 0.
  prefs: []
  type: TYPE_NORMAL
- en: If a reducing function encounters an empty collection, no default neutral element
    exists, and no `init` argument has been supplied, it returns an error. Some reducing
    functions *may* use the value of `init` as a starting value for the reduction
    when the collection is not empty, but this behavior is formally unspecified and
    may change in future implementations of these functions. For that reason, to assure
    correct results, when `init` is present it should be the correct *neutral element*
    for the applied operation. For addition, this is 0, and for multiplication, the
    neutral element is 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some reducing operations arise so frequently in programs that Julia has purpose-built
    versions for them. We’ve already seem `sum()`; `prod()` is similar but multiplies
    rather than adds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first expression in this example multiplies together all the integers from
    1 to 7 inclusive; as this is the definition of 7!, we get the same result returned
    from the second expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `maximum()` and `minimum()` reducers find the largest or smallest element
    of a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create the collections by broadcasting the `sin()` function
    over an interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `any()` and `all()` reducing tests apply a test over a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'These two operations answer the questions: do *any* or *all* elements of the
    collection satisfy the test in the first argument?'
  prefs: []
  type: TYPE_NORMAL
- en: '**The mapreduce() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The powerful `mapreduce()` function does what its name suggests: it combines
    a `map()` and a `reduce()`. For example, here are two ways to add up the first
    100 squares:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The second method shows exactly what a `mapreduce()` call does. However, it’s
    almost always better to use `mapreduce()` instead of combining a `map()` and a
    `reduce()` because the former uses far less memory and is much faster; the gain
    in efficiency grows dramatically as the collection gets larger. The main reason
    is that combining `map()` and `reduce()` creates an intermediate collection to
    reduce over, whereas `mapreduce()` performs the calculation in one go, without
    allocating a collection.
  prefs: []
  type: TYPE_NORMAL
- en: '**do Blocks**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many functions in Julia take functions as their first arguments, and we often
    want to supply an anonymous function, as we have no need to reuse the function
    elsewhere. We’ve seen this with `plot()` and related plotting routines, and with
    the mapping and reducing functions described in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing an anonymous function can be cumbersome or impossible using the
    `x -> ...` syntax. For example, we might want it to contain loops or `if` blocks.
    In those situations, we can resort to first creating a named function and then
    passing it to the higher-level function, but Julia provides another way.
  prefs: []
  type: TYPE_NORMAL
- en: The `do` block is a type of function definition block solely for the purpose
    of creating anonymous functions. The function is inserted as the first argument
    of the function call immediately preceding the `do` block.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s revisit reducing using our `q()` function from [Listing 6-4](ch06.xhtml#ch6lis4).
    If any of the denominators taken from the collection is 0, the reduction will
    return `Inf`. But what if we want to simply skip those denominators?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `do` block defines an anonymous function of two variables that returns the
    first divided by the second, handling 0 denominators as a special case. The call
    to `foldl()` looks wrong because it passes only a single argument, but the function
    defined by the `do` block is inserted as the missing first argument.
  prefs: []
  type: TYPE_NORMAL
- en: '**Symbols and Metaprogramming**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve used the `Symbol` type in several places—for example, when setting attributes
    in plotting functions—but we’ve deferred a thorough discussion of what symbols
    in Julia actually are until now.
  prefs: []
  type: TYPE_NORMAL
- en: To grasp the meaning of symbols, we must introduce the concept of *metaprogramming*
    in Julia. Metaprogramming refers to a general class of language facilities and
    associated techniques for writing code that examines itself, modifies itself,
    and can even modify or add to the syntax of the language. In this section, we’ll
    introduce the basic concepts and apply them to the code-transforming programs
    called *macros* described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Scientific code does not typically use much metaprogramming. However, Julia,
    and many of its packages, provides some indispensable macros, such as the `@layout`
    macro that we used in “Creating Complex Layouts Using @layout” on [page 118](ch04.xhtml#ch04lev1sec28).
    Even if you never write a macro yourself, having a basic understanding of how
    they work is worthwhile. Programming in Julia routinely uses a handful of indispensable
    macros, so it’s important to be able to use them intelligently and debug them
    if something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: '***Expression Objects***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Julia has the ability to manipulate Julia code. That’s possible because Julia
    code itself is expressible as a data type that the language can operate on, just
    as it operates on numbers, strings, and arrays. This data type is called `Expr`.
    Objects with this data type are referred to as `Expr` objects or *expression objects*.
    Expression objects are different from *expressions*, which are language forms
    that return results, such as `3 * 5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expression objects often involve Julia `Symbol`s. We can create a `Symbol`
    by prepending a colon to a name, as with the attributes, such as `:red`, that
    we used when making plots. We can convert a string to a symbol with the `Symbol()`
    function as well: `Symbol("red") == :red`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use colons to construct expression objects by following the colon
    with an expression in parentheses. To reiterate: `3 * 5` is an expression, while
    `:(3 * 5)` is an expression object. If we enter `3 * 5` in the REPL, Julia evaluates
    the expression and returns `15`. If we enter `:(3 * 5)`, or any other expression
    object, it simply returns what we entered.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to evaluate the expression that the `Expr` object represents, the part
    inside the parentheses, we use the `eval()` function. If we enter `eval(:(3 *
    5))` in the REPL, Julia returns `15`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We can turn a string into an expression using* Meta.parse()*—for example,*
    Meta.parse("3 * 5") *returns* :(3 * 5)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes putting the entire expression object on one line is inconvenient.
    Julia has a block called `quote` for defining such objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The assignment beginning the example assigns the result of the `quote` block
    to `ex`. Since `quote` blocks create expression objects, that’s the type of `ex`,
    as we confirm in the following line. Evaluating the expression performs the operations
    within the block, as the next two lines confirm.
  prefs: []
  type: TYPE_NORMAL
- en: The block gets its name from the concept of *quoting*, which means turning an
    expression into an expression object, whether we accomplish that by surrounding
    an expression with `:(...)` or using the `quote` block.
  prefs: []
  type: TYPE_NORMAL
- en: In English, sometimes we need to distinguish between *using* a word or expression
    and talking *about* the word or expression. We do this by surrounding the terms
    we are discussing with quotes. Quoting in Julia serves the same purpose. We quote
    an expression so that we can act on it as an expression; the expression object
    is simply the quoted expression.
  prefs: []
  type: TYPE_NORMAL
- en: Most languages have no way to talk about themselves. All those that do, such
    as Julia, all Lisps, and Elixir, have a way to quote expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Expression Object Interpolation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can interpolate values into an expression object similarly to how we can
    interpolate into a string. As a simple example, let’s define a variable and create
    two expression objects, one that uses the variable and one that uses the interpolated
    value of the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the definition of `ey`, the value of `w` was interpolated into the expression
    object at the time of its creation. The expression object `ex` contains the *variable*
    `w` instead. Applying `eval()` to those expression objects, before and after changing
    the value of `w`, clarifies the consequences of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Changing the value assigned to `w` does not change the result of evaluating
    `ey` because that expression does not contain `w` as a variable. Instead, it uses
    the *value* of `w` in its definition.
  prefs: []
  type: TYPE_NORMAL
- en: With just these few simple metaprogramming tools, we can already perform a whole
    category of programming tricks that are impossible without them. For example,
    suppose we want to create a function that, given a string and a value, creates
    a variable from the string and assigns the value to it. [Listing 6-6](ch06.xhtml#ch6lis6)
    shows a function that performs this task.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-6: Putting expression objects to work*'
  prefs: []
  type: TYPE_NORMAL
- en: The `mkvar()` function converts the `s` string into a `Symbol`. It then creates
    an expression object that assigns to the interpolated value of that symbol the
    value of `v`. Finally, it applies `eval()` to the expression object. The result
    of this `eval()` is a new variable with a name identical to the supplied string
    `s`, and with the value `v`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here it is in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This kind of functionality requires metaprogramming. In particular, we can’t
    do `"Arthur" = 42`, because we can’t assign to a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example makes clear exactly what symbols are: they are the way
    Julia represents variables within expression objects. In other words, symbols
    are how Julia represents variables to itself. They are also, as we’ve shown, often
    drafted for service as keyword arguments and for other purposes, but that usage
    is tangential to their fundamental identity. Symbols are popular for these purposes
    simply because they’re more efficient than strings.'
  prefs: []
  type: TYPE_NORMAL
- en: The `mkvar()` function is more than just a magic trick. The strings it consumes
    may be taken, for example, from the headings of a table of data read from a file.
    In that case, `mkvar()`, or something like it, could create variables named after
    those headings and assign them to the columns of data underneath them. We’ll explore
    applications of these ideas in [Chapter 10](ch10.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '**Macros**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *macro* is a function that accepts expressions, symbols, and literals as arguments
    and returns an expression object. The expression object is automatically evaluated
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: There is a crucial difference between macros and the other functions that we’ve
    studied up to now, including functions that manipulate expression objects. Functions
    are evaluated at runtime, using the current values of any global variables.
  prefs: []
  type: TYPE_NORMAL
- en: The processing inside a macro, in contrast, happens during a separate compilation
    stage *before* the program runs. The expression object returned by the macro is
    inserted into the code at the location of the macro and `eval()`ed. This property
    allows us to use macros to alter or add to the syntax of the language.
  prefs: []
  type: TYPE_NORMAL
- en: '***How to Create Macros***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following is a macro version of the `mkvar()` function that we defined
    in [Listing 6-6](ch06.xhtml#ch6lis6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Normally, to avoid collisions with names in the calling context, macros change
    the names of all the variables they contain into private versions. In cases where
    we want these variables to refer to variables of the same name when we use the
    macro, we use `esc()` ➊ to bypass the private naming process. This is one of those
    cases because the purpose of this macro is to create a variable from the string
    we supply and to assign it a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We invoke a macro by prepending an `@` sign to its name ➋. The syntax for supplying
    arguments is more flexible than in the case of functions. We can list the arguments
    separately using spaces, as in this example, or place a comma-separated list inside
    parentheses, as we do with functions: `@mkvarmacro("color", 17)`. If the argument
    is a literal array, we can dispense with the space and the parentheses and call
    the macro as `@macroname[1 2 3]`.'
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the macro is invoked, the `Expr` object `($ss = $v)`, with interpolation
    substituting a literal `color` for `ss` and `17` for `v`, is evaluated, so 17
    is assigned to the variable `color`.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of how we can use macros to add new syntax to Julia, suppose we
    don’t like using the `end` keyword in `while` loops. In [Listing 6-7](ch06.xhtml#ch6lis7)
    we’ll create a simple macro that accepts a condition and a loop body, with no
    `end` required. We’re not allowed to reuse the `while` keyword, so we’ll call
    our macro `@during`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-7: Creating new syntax with a macro*'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `esc()` function ➊ because we want the loop body to be able to use
    variables defined outside the macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to use this macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The last two lines show that the macro indeed references the variable `i` in
    the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our new powers, we can invent a kind of loop that doesn’t exist in the
    language. Let’s create an “until” loop that repeats a block *until* a condition
    is met. This is the same thing as a `while` loop that continues while the condition
    is *not* met. With this insight, our new macro is a simple modification of the
    one in [Listing 6-7](ch06.xhtml#ch6lis7):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s test it in the REPL to see if it does what we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Our `@until` loop works as intended, incrementing `i` until `i == 11`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing macros is inherently more difficult than writing normal functions, partly
    due to the necessity to keep track of levels of quoting and self-reference. Fortunately,
    you’ll never need to write a single macro to perform scientific calculations or
    numerical work. However, if you find you’re repeating “boilerplate” code often,
    and this repeated code can’t be expressed using a normal function, you may have
    a situation where the code-writing powers of macros can save you some work.
  prefs: []
  type: TYPE_NORMAL
- en: '***Useful Macros***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although you may never write your own macros, you’ll use them often. Both the
    standard library and many packages provide useful functionality through various
    macros. This section surveys several convenient macros for general use.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Broadcast Macro**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We’ve described how Julia’s dot operator can extend functions and operators
    to act element-wise over entire arrays (see “Broadcasting” on [page 51](ch02.xhtml#ch02lev1sec13)).
    We often want to write long expressions in which all, or the great majority, of
    the functions need to be broadcast over their array arguments. The broadcast macro
    frees us from having to sprinkle dots everywhere in such an expression—for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This example constructs a three-column matrix showing when the exponential function
    becomes larger than its argument to the fourth power (`exp(x)` is the Julia function
    for *e*^(*x*)). The second column is made from an expression using the broadcast
    macro, while the third is an expression with the identical meaning, but with explicit
    dots. The two columns are identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'To exclude a function from the macro’s automatic broadcasting, precede it with
    a dollar sign (`$`). As an example, here is the sum of the first 10 squares:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `sum()` function, which adds all the numbers in an array, does not have
    a dot because it acts on the array as a whole, rather than element by element.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we rewrite the expression using the broadcast macro, we should exempt `sum()`
    from the auto-dotting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Without the prepending dollar sign, `sum()` would be applied to each element
    individually; however, this is not what we want, as `sum(n)` is simply equal to
    `n` when `n` is a single number.
  prefs: []
  type: TYPE_NORMAL
- en: '**The @chain Macro**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `@chain` macro, which is not part of the standard library and must be imported
    from the `Chain` package, is a more convenient alternative to the pipe operator
    (`|>`) for transforming data through a series of expressions. The pipe operator
    has certain limitations. For example, it’s designed to work only with functions
    that have a single argument. The `@chain` macro is one of several approaches in
    the Julia ecosystem that creates a more flexible pipelining mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at the syntax of the built-in pipe with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We’ve passed the string `"hello"` through two functions to transform it.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to continue the pipeline, adding `occursin()` as a third function,
    to check for the occurrence in the result of the string `"OL"`. The `occursin()`
    function takes the string to search in as the *second* argument, so there’s no
    obvious way to extend the pipeline to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of the pipe operator, we can use the `@chain` macro to accomplish this
    task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `@chain` macro creates a pipeline from a series of expressions without the
    use of any extra operators. It handles functions of any number of arguments. By
    default, the result of each expression is fed into the first argument of the following
    function. To insert the result into an argument in a position other than the first,
    indicate its slot with an underscore ➊.
  prefs: []
  type: TYPE_NORMAL
- en: '**The @time Macro**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `@time` macro tells how much machine time a computation consumes, plus
    some information about memory allocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: First the REPL prints a line with information about the resources used, and
    then the result of the computation.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The* @time *macro is handy for getting a rough idea of timings, but for more
    systematic benchmarking or profiling, I recommend importing the* BenchmarkTools
    *package and using the* @btime *macro and other tools therein. The* BenchmarkTools
    *macros can run an expression multiple times and take an average, separate run
    time from compilation time, and more.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Macros for Performance**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Julia comes with several macros we can use to alter the behavior of the compiler,
    sometimes leading to more efficient code. They need to be used with care, as their
    use is not without risk. The two macros discussed in this section can provide
    significant speedups in some circumstances; in others, they have little or no
    effect. One usually has to experiment to find out if they’ll provide any benefit.
    These two macros, and similar strategies, should be explored at the final stages
    of performance tuning. During the development of an algorithm or a program, such
    attempts at optimization would likely be a counterproductive distraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally the compiler checks our indexing expressions to make sure we’re not
    indexing array elements that don’t exist, returning a `BoundsError` if we index
    beyond the end of an array, or wind up using a nonpositive index. In some routines,
    this bounds checking can affect performance. If we’re sure that an area of code
    cannot contain an indexing error, we can instruct the compiler to skip the bounds
    checking for that location using the `@inbounds` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `@inbounds` instruction at the start of the `for` loop tells the compiler
    not to worry about `x[i]` being an illegal access during the loop. We’re responsible
    for ensuring that `i` stays within the bounds of `x`.
  prefs: []
  type: TYPE_NORMAL
- en: The utility of `inbounds` is much reduced in recent versions of Julia; there’s
    no longer a good reason to use it for versions more recent than 1.8\. However,
    we’ll encounter it in much existing code, so it’s important to know what it’s
    supposed to do.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A common error is to try to generate the indices for the array* A *with* 1:length(A)*.
    This does not create legal indices for every type of array, and, if used to access*
    A *within an* @inbounds *section, it can create silent bounds errors. Instead,
    we should use* eachindex(A)*, which always returns an iterator over legal indices
    of* A*.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier in this chapter, addition and multiplication on floats
    are not associative: the results can depend on the order in which we add or multiply
    numbers. For this reason, the Julia compiler will normally perform arithmetic
    exactly the way we spell it out, even if it would be faster to change the order
    of operands or rewrite expressions to “real number equivalents” that would be
    more efficient. This ensures that running a program on different versions of the
    compiler will produce the same numerical results, as all the arithmetic will occur
    in the same order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In situations where the last few decimal places of a result are not important,
    we can sacrifice some of this reproducibility to gain speed by allowing the compiler
    to rearrange our expressions. The instruction is provided by the `@fastmath` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here we’ve performed the same sum
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/math177.jpg)'
  prefs: []
  type: TYPE_IMG
- en: twice, the second time using the `@fastmath` directive. Our expression needlessly
    performs an extra billion divisions. One obvious optimization available for `@fastmath`
    is to factor out the constant *d*. The macro gets us a speedup of about 26 percent.
    It also changes the result slightly in the two final digits. Neither result is
    more “correct." This is an example of how arithmetic on floats depends on the
    details of the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Macros for String Formatting**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `Printf` package provides two macros that format strings using the C-style
    specifications that have become a de facto standard across multiple programming
    languages. The following example shows how a macro makes our code neater, allowing
    us to list the variables to be formatted without parentheses and commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The format specifiers are the fragments in the string beginning with `%`; the
    digit after the decimal point determines the number of digits after the point
    printed in the result. For a list of all the format specifiers and a guide to
    their syntax, see “Further Reading” on [page 187](ch06.xhtml#fur6).
  prefs: []
  type: TYPE_NORMAL
- en: A companion to this macro is `sprintf`, which behaves the same way but returns
    the formatted string as a result rather than printing it. Use `sprintf` to store
    the generated string in a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Macros for Information**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Several macros that provide information about the environment in which they
    are invoked are always available. The `@__MODULE__`, `@__DIR__`, `@__FILE__`,
    and `@__LINE__` macros return the module, directory, filepath, and line number,
    respectively, where they are called. These macros can be useful for debugging,
    writing build scripts, code formatting, testing, and other purposes. (Each of
    the macro names in this paragraph begins and ends with a double underscore.)
  prefs: []
  type: TYPE_NORMAL
- en: One essential aid when debugging macros is a macro called `@macroexpand`. Simply
    prepend it to your macro call, and it will show you what the macro is using for
    each variable and reference.
  prefs: []
  type: TYPE_NORMAL
- en: '**Error Handling**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like most modern languages, Julia has methods for handling, manipulating, and
    creating errors (also called *exceptions*). We’ve seen plenty of examples of errors
    in this book so far: they occurred in REPL sessions or as a result of running
    programs when Julia encountered a situation that prevented it from continuing
    with the computation. These situations have included calling functions with arguments
    that they were not designed to accept, indexing arrays outside their bounds, using
    an undefined name, and others. Each one was introduced in order to illustrate
    a characteristic of the language, but in practice we encounter errors when something
    unexpected happens, or something happens that we need to guard against.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section we’ll explore how to handle errors and some methods for making
    them part of our programs’ flow control. Julia’s type system and its method of
    function dispatch, covered in [Chapter 8](ch08.xhtml), provide a cleaner way to
    accomplish some of what relies on exception handling in other languages. These
    more idiomatic Julia techniques should be preferred because they allow the compiler
    to perform more optimizations. Nevertheless, sometimes the methods described in
    this section are the most convenient way to accomplish a programming task.
  prefs: []
  type: TYPE_NORMAL
- en: '***Types of Errors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Julia uses about 25 distinct kinds of exceptions. Some occur rarely, while
    others we may only wish were rare. Here are the most common ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The identifier immediately following the word `ERROR:` is the name of the error.
    It’s usually followed by some explanation and even occasionally some advice.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the error messages are self-explanatory. A `MethodError` means that
    someone tried to call a function with argument types that it doesn’t support.
    Operators such as + are functions written with an infix syntax. (See “Creating
    Multiple Methods” on [page 230](ch08.xhtml#ch08lev1sec6) for more information
    on methods and the precise meaning of the error message.)
  prefs: []
  type: TYPE_NORMAL
- en: The `*` operator, when applied to arrays, performs matrix multiplication, which
    requires that the second dimension of the first argument match the first dimension
    of the second argument ➊.
  prefs: []
  type: TYPE_NORMAL
- en: We’re allowed to divide by a floating-point 0, which results in `Inf` or `-Inf`,
    which means that we can do `1/0` because the `/` operator converts to floating
    point. However, dividing by 0 using the integer division operator (`÷`) results
    in a `DivideError` ➋.
  prefs: []
  type: TYPE_NORMAL
- en: If we try a conversion between numerical types that would lose information,
    an `InexactError` is the result ➌.
  prefs: []
  type: TYPE_NORMAL
- en: The usual types of integers aren’t large enough to hold the result of `factorial(55)`,
    but, as the advice following the error message ➍ suggests, we can turn to another
    type of number. We’ll cover `big` numbers in “‘Big’ and Irrational Types” on [page
    216](ch08.xhtml#ch08lev1sec1).
  prefs: []
  type: TYPE_NORMAL
- en: '***The Call Stack***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose we have a series of function calls, where a function calls a second
    function, which calls a third, and so on. When the final function in this chain
    finishes its job, the compiler needs to know what to do next. In order to know
    what the next instruction should be, the compiler keeps track of “how we got here.”
    That information, which includes the details of the chain of function calls, is
    called the *call stack*. It forms the sometimes lengthy part of error messages
    that I usually omit from the listings in this book to save space.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In practice, the compiler optimizes nested function calls through “inlining”
    when possible. This optimization replaces the nested calls with direct insertion
    of the called function’s code into the calling function. But there is still the
    logical notion of the call stack, and the error report prints this logical stack,
    noting any inlining.*'
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate how the call stack works, [Listing 6-8](ch06.xhtml#ch6lis8) sets
    up a series of five functions, each one defined to call the next one by name,
    except the last, which calls the `log()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-8: A chain of functions*'
  prefs: []
  type: TYPE_NORMAL
- en: Function `a()` calls `b()`, passing the supplied argument `n`. Function `b()`
    decrements that argument and calls `c()`, passing its new value, then `c()` calls
    `d()` similarly. Finally, `e()` calls `log(n)`, where now `n` is 3 less than the
    original `n`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-9](ch06.xhtml#ch6lis9) shows calling `a()` a couple of times.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-9: A call stack when an error occurs*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we call `a(5)`, which ultimately leads to a call to `log(5-3)`, or `log(2)`,
    and returns the expected result. When we call `a(2)`, that results in `log(2-3)`,
    or `log(-1)`, and the attempt to take the logarithm of a negative number produces
    the expected `DomainError`. What follows is the stacktrace: information about
    the call stack at the moment that the error occurred. This data, which can become
    far lengthier than in this artificial example, is an aid to debugging, informing
    us about the state of the program that led to an error condition.'
  prefs: []
  type: TYPE_NORMAL
- en: The numbers in square brackets are part of the trace as printed in the REPL,
    showing the sequence of function calls, beginning with the most recent, where
    the error was raised, and proceeding up the chain. The first entry is the function
    that actually handles the error. This is followed by the log functions themselves,
    and then our functions `e()` up through `a()`. The final entry informs us that
    `a()` was called from the REPL. The stacktrace also tells us which functions were
    inlined by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '***try...catch Blocks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instead of allowing errors to simply stop our program, we can intercept them.
    We do this in Julia with the `try`...`catch` block, another form of flow control
    like the `if` block. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `friendly_log()` function wraps the built-in `log()` function in some error
    handling. The normal `log()` rejects negative arguments with a `DomainError`,
    but this version tries again with the argument’s absolute value, warning the user
    about what it’s doing. The `try` part of the block contains the code whose errors
    we want to intercept; the `catch` part intercepts them, optionally assigning the
    error itself to a variable, here `oops`. Inside the `catch` block we put an ordinary
    `if` block, using `isa` to test for the type of error (“Types in Practice” on
    [page 214](ch08.xhtml#ch08lev1) explains more about `isa` and types). If `oops`
    happens to be a `DomainError`, the `@warn` macro prints a warning to the terminal,
    after which we issue another message, using the `@info` macro, explaining how
    the program plans to change the faulty argument ➊. We then call `log()` with the
    argument made positive.
  prefs: []
  type: TYPE_NORMAL
- en: If the error is not a `DomainError`, but instead is a `MethodError`, something
    else is wrong with the argument. In this case, we don’t know what to do and the
    program should halt. The `@error` macro ➋ prints an error message, *after which
    the program continues*. Since there’s nothing else for it to do, it exits. The
    `@error` macro, like the `@warn` macro, simply prints an appropriately formatted
    message; neither macro creates an error condition nor has any effect on flow.
    On a color device, warnings are signaled in yellow and errors in red, and both
    attempt to indicate where in the program the problem occurred. Messages generated
    by `@info` appear in blue in the REPL, and don’t include a program location. All
    three macros are part of Julia’s logging system. See the link to the documentation
    in “Further Reading” on [page 187](ch06.xhtml#fur6) for information about more
    of what you can do with this logging information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we “handle” the errors in the `catch` block, they won’t stop the program
    or lead to a stacktrace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: If we had not intercepted the error in the `catch` block, it would have led
    to a stacktrace as in the previous section, with `call_fl()` as part of the call
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using throw()***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The REPL’s help mode explains that `throw()` throws an object as an exception.
    Most Julia tutorials describe it as a way for the programmer to create errors.
    Both of these descriptions are true, but they tell only part of the story. Before
    delving into the full power of `throw()`, let’s look at a simple example of where
    we might want to create an error where there otherwise would not be one.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating Errors**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `log()` function allows us to call it with an argument of 0, returning
    `-Inf` as the result. Suppose we wanted to have a logarithm function that did
    *not* allow 0 as an argument because we wanted to exclude infinities from its
    results. The `finite_log()` function would be one way to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'An `if` block checks for the 0 input and calls `throw()` if it finds one. The
    argument of `throw()` is the name of an error turned into a function; each of
    Julia’s errors has such an associated function for constructing the error. The
    `finite_log()` function raises a `DomainError` if it gets 0 as an argument. We
    can raise any error we want, but as the idea here is to exclude a value from the
    domain, a `DomainError` makes sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Here `finite_log()` behaves like `log()` unless it gets a 0, when it halts with
    a `DomainError`. The message that we included in `throw()` is printed out with
    the error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the error constructors accept arguments for information for Julia to
    include in the error message. To see what arguments are permitted, ask the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The documentation informs us that there are two versions, one with just the
    offending value, and the version that we used, with an explanatory message as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: '**Combining throw() with try...catch Blocks**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Combining `throw()` with `try`...`catch` blocks unleashes its full power. In
    combination, they create a new form of flow control that allows us to pass *any
    value* up the call stack until it is intercepted by a `catch`, at which point
    we can halt the program or do something else.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, [Listing 6-10](ch06.xhtml#ch6lis10) modifies the chain of functions
    from [Listing 6-8](ch06.xhtml#ch6lis8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-10: Throwing and catching*'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the `e()` function first, we’ve added an `if` block above what used
    to be its only line. Before trying to calculate the logarithm, it checks the argument
    `n`. If this argument is not positive, it calls `throw()` with a `Tuple` as an
    argument ➊. In both cases, the tuple’s first element is `n` and its second element
    is a string. The `throw()` function sends this tuple up the call stack and returns
    from `e()` without attempting to calculate the logarithm. If `n == 0`, we send
    a different message up the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: The message sent by `throw()` travels from function call to function call until
    it’s intercepted by the `try`...`catch` block in function `a()`. The `catch` statement
    assigns the message, in this case a `Tuple`, to the variable `oops`, where it’s
    examined in the `if` block, which prints the appropriate warning or error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here it is in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This exhibits a dramatic difference from the error reporting shown in [Listing
    6-9](ch06.xhtml#ch6lis9). Here we see no call stack, but merely the messages constructed
    in our `try...catch` block. The `throw()...catch` mechanism lets us toss a message
    “over the heads” of any number of functions in a call stack, directly to the first
    one ready with the appropriate `catch` statement. [Listing 6-9](ch06.xhtml#ch6lis9)
    had no `catch` in place to intercept the error, so Julia halted the program and
    printed out the complete call stack for our diagnostic use.
  prefs: []
  type: TYPE_NORMAL
- en: '***The finally Clause***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `try...catch` block can optionally end with a `finally` clause, which is
    executed before the program exits. We typically use this for “cleanup,” such as
    releasing external resources or file handles that an error condition otherwise
    might leave in an uncertain state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a `finally` clause to `a()` from [Listing 6-10](ch06.xhtml#ch6lis10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling it as before, we’ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This example shows how the `finally` clause is always executed, whether there
    is a message to catch or not.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the more advanced language features discussed in this chapter, we’ve attained
    a higher level of Julia mastery. We’re now better prepared for the detailed applications
    in [Part II](part2.xhtml), where we’ll see how to apply our skills to address
    problems across a variety of fields.
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  prefs: []
  type: TYPE_NORMAL
- en: The source containing the lists of characters available for infix operators,
    with their precedences, is available at [*https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm*](https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on page tabulating C format specifiers, visit [*https://web.archive.org/web/20220127135451/https://www.journaldev.com/35137/format-specifiers-in-c*](https://web.archive.org/web/20220127135451/https://www.journaldev.com/35137/format-specifiers-in-c).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read Stefan Karpinski’s masterful explanation of what symbols really
    are at [*https://stackoverflow.com/a/23482257*](https://stackoverflow.com/a/23482257).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation about the logging system and further uses for the `@info`, `@warn`,
    and `@error` macros is available at [*https://docs.julialang.org/en/v1/stdlib/Logging/*](https://docs.julialang.org/en/v1/stdlib/Logging/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
