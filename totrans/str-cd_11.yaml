- en: '8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FRACTRAN
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'John Conway (1937–2020) was a British mathematician, most famous to the general
    public for his Game of Life (see *[https://playgameoflife.com/](https://playgameoflife.com/)*),
    but equally famous to his fellow mathematicians for his many contributions to
    a wide variety of mathematical disciplines. In this chapter, we’ll examine another
    of Conway’s contributions, one that isn’t as well known as his Game of Life, but
    is perfect for our purposes: FRACTRAN. We’ll start with the specification of FRACTRAN,
    build it, and, lastly, use it to implement basic programs for addition, subtraction,
    and multiplication, among other tasks. After that, we’ll end with a discussion,
    like always.'
  prefs: []
  type: TYPE_NORMAL
- en: Be warned that there’s math ahead, at the level of fractions, prime numbers,
    and big integers. FRACTRAN is the most mathematical esolang we’ll encounter. If
    you wish, skip this chapter and move on to the remaining esolangs. However, if
    you do, please don’t forget to come back. FRACTRAN is worth the struggle.
  prefs: []
  type: TYPE_NORMAL
- en: '**The FRACTRAN Specification**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'FRACTRAN’s specification is straightforward. In fact, it’s almost as straightforward
    as ABC’s. Here’s the full specification for FRACTRAN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: FRACTRAN programs are a sequence of integers and nothing more. An initial integer
    is tested against each fraction in the program, in order. If the product of the
    integer and the fraction is itself an integer, that product becomes the new integer
    and the program loops from the beginning. If the program ever reaches the state
    where no product results in a new integer, the program ends. That’s it.
  prefs: []
  type: TYPE_NORMAL
- en: As the specification is simple, so are the implementations. Let’s write two
    FRACTRAN interpreters because it’s fun and it will expose us to another programming
    language, one that is well suited to this particular task.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Tale of Two Implementations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The specification above includes the phrase *arbitrary precision*. A FRACTRAN
    implementation must use fractions where the numerator and denominator are integers
    of any size, even if that size has thousands of digits.
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages don’t natively support arbitrary-precision integers,
    let alone fractions (rationals). However, Scheme does. Scheme is a dialect of
    Lisp, which we first mentioned in [Chapter 1](ch01.xhtml#ch01). Not only does
    Scheme support arbitrary-precision integers, it also natively supports rationals.
    Therefore, Scheme is ideally suited to implementing FRACTRAN.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve used Python fairly often throughout the book. Python also supports arbitrary-precision
    integers natively and has a rational arithmetic library module. So we’ll implement
    FRACTRAN in Python as well. The juxtaposition between the two implementations
    will be illustrative, and allow us to test each against the other to ensure our
    implementations are correct.
  prefs: []
  type: TYPE_NORMAL
- en: '***A Scheme Implementation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The version of Scheme we’ll use is called Racket (*[https://racket-lang.org/](https://racket-lang.org/)*).
    It’s easy to install on Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'See the Racket website to install macOS and Windows versions. Once installed,
    run Racket by entering racket at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Your version should be at least 6.11 or greater. Like Python and Forth, Racket
    enters an interactive mode if no file is given to it. For now, just quit by entering
    (exit); note that the parentheses are required.
  prefs: []
  type: TYPE_NORMAL
- en: We certainly don’t have the space here to give even a short tutorial on Scheme
    (Racket). The genuinely motivated will find all they need on the Racket website.
    Instead, we’ll walk through our implementation. [Listing 8-1](ch08.xhtml#ch08list1)
    shows the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-1: FRACTRAN in Racket*'
  prefs: []
  type: TYPE_NORMAL
- en: The Racket implementation of FRACTRAN is compact. The first four lines do nothing
    more than parse the command line. In Racket, `define` assigns a value. We use
    `argv` to avoid duplicating the call to `current-command-line` `-arguments`. Racket
    returns the command line arguments as a vector, so `(vector` `-ref argv 0)` is
    equivalent to `argv[0]` in other languages. Racket is a prefix language, meaning
    that function names come first, followed by the arguments with parentheses around
    everything. We’ll see below how FRACTRAN code is stored. We chose a format friendly
    to Racket so we can add comments easily. The `file->list` function reads the code
    and returns a list of the fractions. The next argument is the starting integer,
    which Racket puts in `num`. The last argument, `trace`, is a 0 or 1 flag indicating
    whether to output only the final integer or all intermediate integers. We’ll learn
    what that means in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: All of FRACTRAN is a single function that takes no arguments ➊. It consists
    of a `do` loop, which is similar to a `for` loop in other languages, but is configured
    to run forever ➋. The loop counter is `i`, which we use to get the `i`th fraction
    from `prog`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of the `do` loop has two main parts: a `when` function ➌ and a `let`
    function ➍. A `when` function checks whether a given condition is true, and if
    so, executes all the code in the body. This `when` checks to see if the loop counter
    matches the length of the program, that is, the number of fractions. If so, the
    program ends, outputting the final value of `num` if `trace` is 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `let` function creates a local environment assigning `(* num (list-ref`
    `prog i))` to `n`. What is `(* num (list-ref prog i))`? It’s the current integer
    times the current fraction: `num*prog[i]`. The body of `let` is a single `when`
    ➎ function. The function `exact-integer?` is true when its argument, `n`, is an
    integer rather than a rational or a float. Recall that the fractions in `prog`
    are native Racket rational numbers. This is the condition we need to check. If
    true, we have a new integer, so the body of the `when` destructively sets `num`
    to the new value in `n` and modifies the loop counter by setting it to *–*1 so
    that the next iteration of the `do` begins again with 0\. Additionally, if `trace`
    is 1, the new integer is output. The program starts by calling `FRACTRAN` ➏.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s implement FRACTRAN in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '***A Python Implementation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Racket version of FRACTRAN was straightforward, at least after learning
    to interpret Racket’s prefix approach to everything. Our Python implementation
    is longer, but it’s likely more familiar. Racket gave us arbitrary-precision integers,
    and Python gives us those, too. Racket also gave us rational arithmetic, which
    is something Python does not have out of the box, but does support via the `fractions`
    library module.
  prefs: []
  type: TYPE_NORMAL
- en: Our Python implementation mimics the Racket code in [Listing 8-1](ch08.xhtml#ch08list1).
    The code we’ll use is shown in [Listing 8-2](ch08.xhtml#ch08list2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-2: FRACTRAN in Python*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-2](ch08.xhtml#ch08list2) shows the body of `main`. *FRACTRAN.py*
    uses the expected Python convention of running from `main` if not imported.'
  prefs: []
  type: TYPE_NORMAL
- en: 'FRACTRAN in Python expects the same arguments as the Racket version: the name
    of the FRACTRAN program, the initial integer value, and whether to output every
    integer change. Unlike the Racket version, the final argument is optional and
    defaults to 0 if not present.'
  prefs: []
  type: TYPE_NORMAL
- en: The code operates like the Racket version. The command line is parsed to set
    the initial integer as a rational ➊, followed by loading the FRACTRAN code via
    `LoadProgram` ➋. We won’t show `LoadProgram` here, but it loads the file and returns
    the fractions as a list of `Fraction` objects. Do read through it.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop runs until all fractions in `p` are exhausted ➌. The current
    integer (`n`) is multiplied by the current fraction (`p[k]`) ➍. If the result
    is an integer, meaning the denominator is 1, we have a new `n`. Thus, `n` is updated
    and printed if `m = 1`. Lastly, as in the Racket version, the loop counter is
    reset so the fractions are scanned from the beginning again (`k = -1`). When the
    loop ends, the final value of `n` is printed if it has not already been printed
    above.
  prefs: []
  type: TYPE_NORMAL
- en: We now have two implementations of FRACTRAN ready to go. Why two? To illustrate
    that different programming languages require different thought processes to arrive
    at the same endpoint. This is a book on programming languages, after all. Now,
    lets put them through their paces.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using FRACTRAN**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest FRACTRAN program is the single fraction, 3/2\. It’s in the file
    *add.frac*. Let’s run it. We won’t understand the output just yet, but it will
    make sense eventually. Try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the Racket version, create a shell script named *FRACTRAN* with the
    following line, which wraps the command line Racket expects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, make *FRACTRAN* executable by typing chmod a+x FRACTRAN. Let’s test
    the Racket version using *add.frac*. The output should match the Python version
    just shown.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The output matches the Python version, so our FRACTRAN implementations are working;
    however, we don’t yet understand what the output means. Let’s remedy that situation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding FRACTRAN**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'FRACTRAN is perhaps the most elegant of all esolangs. It’s subtle, brilliant,
    strangely beautiful, and difficult. In this section, we’ll finally dive into the
    operation of FRACTRAN. We’ll start with *add.frac*, the version included with
    the book’s code. That version contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It appears that *add.frac* adds two integers. Before learning how, we must make
    sense of the input and output comments. To do that, we must understand how FRACTRAN
    represents state.
  prefs: []
  type: TYPE_NORMAL
- en: FRACTRAN is a *register machine*, which is a hypothetical machine that manipulates
    an infinite set of registers. FRACTRAN uses Gödel numbering to represent its state,
    the value of the registers. So to understand FRACTRAN, we first must understand
    Gödel numbering.
  prefs: []
  type: TYPE_NORMAL
- en: Kurt Gödel was a German-Austrian-American mathematician most famous for his
    *incompleteness theorem*, by which he proved that in any system of axioms capable
    of describing mathematics with natural numbers, there are true statements that
    cannot be proved from the axioms. The incompleteness theorem sounded the death
    knell of early 20th-century attempts to put all of mathematics on rigorous footing.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of his incompleteness theorem, Gödel made use of *Gödel numbering*,
    which itself makes use of the fact that all integers can be expressed as the product
    of a unique set of prime numbers: *prime factorization*. For example, the prime
    factorization of 88 is 2³11¹, whereas the prime factorization of 68,600 is 2³5²7³.'
  prefs: []
  type: TYPE_NORMAL
- en: Gödel used his numbering scheme to represent the expressions and theorems of
    mathematics. FRACTRAN uses Gödel numbering to represent its state—the value of
    all registers—which must be positive or 0\. For example, if the state is 88 =
    2³11¹, the v2 register is 3, the v11 register is 1, and all other registers are
    0\. It’s customary to refer to the registers by their associated primes. Similarly,
    the state 68,600 = 2³5²7³ means v2 = 3, v5 = 2, and v7 = 3\. As there are an infinite
    number of primes, there are an infinite number of FRACTRAN registers with all
    possible states representable by a single integer. This single integer is the
    integer multiplied by each fraction.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review a bit before proceeding. We must follow the link between the integer
    FRACTRAN manipulates, prime factorization of a number, and state represented by
    registers holding specific values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with registers holding values. At some point in a program, we may
    want register v17 to hold the value 12, that is, v17 = 12\. Again, registers are
    identified by their prime, and 17 is a prime. In FRACTRAN, setting v17 to 12 means
    raising 17 to the 12th power: 17¹2\. Likewise, if we want v3 = 7, we use 3⁷. So
    to set a FRACTRAN register to a value, we raise the corresponding prime to that
    power.'
  prefs: []
  type: TYPE_NORMAL
- en: The state of a FRACTRAN program is the current value of all of its registers.
    This is because FRACTRAN can manipulate only register values. To continue the
    example above, if v3 and v17 are the only nonzero registers, then the entire state
    of the FRACTRAN program is the product of 3⁷ and 17¹2, which is 3⁷17¹2 = 1,274,194,832,821,487,307\.
    This number is the integer FRACTRAN implementations use to represent the state.
  prefs: []
  type: TYPE_NORMAL
- en: Conway’s insight was that all positive integers can be written as the product
    of a series of primes in only one way, that is, prime factorization. Therefore,
    the large integer in the previous paragraph represents the state where v3 = 7
    and v17 = 12 and all other registers are 0, and that is the *only* integer representing
    that state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fractions of a FRACTRAN program attempt to alter the state in two ways:
    by decrementing register values via canceling with the denominator and by incrementing
    register values via multiplying by the numerator. Only fractions where the denominator
    cancels completely “fire” are allowed to alter the program state.'
  prefs: []
  type: TYPE_NORMAL
- en: We’re now able to understand the input and output comments from *add.frac*.
    The expected input sets register v2 = *a* and v3 = *b*. When the program ends,
    register v3 = *a* + *b*. Therefore, if we want to add *a* + *b* = 3 + 2, the input
    given to FRACTRAN is
  prefs: []
  type: TYPE_NORMAL
- en: 2*^a*3*^b* = 2³3² = 8(9) = 72
  prefs: []
  type: TYPE_NORMAL
- en: which is the first test input above. If the input is 2³3², then the output is,
    according to the comments in *add.frac*, 3^(*a*+*b*) = 3^(3+2) = 3⁵ = 243, which
    is the first test output.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s work through *add.frac* for the input 2³3² = 72 to see each step leading
    to the output. First, let’s run the code with trace on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Trace tells us the program looped three times, changing the state from 72 →
    108 → 162 → 243\. Stepping through by hand gives
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0224-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Or, tracking the state: 2³3² → 2²3³ → 2¹3⁴ → 2⁰3⁵ = 3⁵.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following how the state changes, especially when writing the prime factorization
    of the state, shows us what FRACTRAN is doing. The add program is a single instruction:
    3/2\. Every time the state is multiplied by 3/2, the 2 in the denominator decrements
    v2, and the 3 in the numerator increments v3\. This is a general rule: the denominators
    are gatekeepers, so they decide whether the fraction “fires” or not. If the current
    integer contains factors of each prime factor of the denominator, to at least
    the power specified by the factor, then the denominator will be completely canceled
    and a new integer will be the result. This is what is meant by a fraction “firing.”
    When a fraction fires, it also decrements register values. Numerators, on the
    other hand, increment register values because they multiply the state integer.
    A FRACTRAN program is a sequence of operations applied to the state of the register
    machine.'
  prefs: []
  type: TYPE_NORMAL
- en: For addition, every multiplication of the state by 3/2 increments v3 and decrements
    v2 until v2 = 0, making the state no longer evenly divisible by 2\. According
    to the processing rule, the state should be multiplied by the next fraction in
    the list; however, there is no next fraction, so the program halts and outputs
    its state.
  prefs: []
  type: TYPE_NORMAL
- en: It’s clever enough to realize that repeated multiplications by 3/2 when an integer
    has the form 2^(*a*)3^(*b*) will result in 3^(*a*+*b*), thereby adding *a* and
    *b*, but realizing that this is a general form of computation is brilliant. We’ll
    explore other FRACTRAN programs, but before we do, notice that 3/2 isn’t the only
    add program in FRACTRAN—2/3 works as well. Instead of decrementing v2 and incrementing
    v3, 2/3 decrements v3 and increments v2, leaving the sum in v2\. Let’s see that
    this is so.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The file *add2.frac* contains `2/3`. The input is 2³3² = 72 as before. The state
    transitions are
  prefs: []
  type: TYPE_NORMAL
- en: 2³3² = 72 → 2⁴3¹ = 48 → 2⁵3⁰ = 32 → end → 2⁵ = 32
  prefs: []
  type: TYPE_NORMAL
- en: proving that the sum is in v2.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make sure we follow how FRACTRAN manipulates state. These examples are
    not full programs, but they show the way fractions operate on the state. For example,
    see Equations 8.1 through 8.5.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/08eqa01.jpg)![Image](Images/08eqa02.jpg)![Image](Images/08eqa03.jpg)![Image](Images/08eqa04.jpg)![Image](Images/08eqa05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Equation 8.1 fires because the denominator contains v5 and v17, which are also
    present in the state. Notice that several things happen when the fraction fires:
    v5 goes down by 4, v17 goes down by o1ne, v7 goes up by 2 (from 0), and v11 goes
    up by 1\. Thus, the new state is v2 = 3, v5 = 3, v7 = 2, v11 = 1, and v17 = 1.'
  prefs: []
  type: TYPE_NORMAL
- en: For Equation 8.2, there is no factor of 13 in the state (v13 = 0), so the result
    of multiplying the state by the fraction is not an integer. Therefore, the fraction
    does not fire, and FRACTRAN proceeds to the next fraction in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Equation 8.3 fires and sets v2 = 0 without changing v5 or v17.
  prefs: []
  type: TYPE_NORMAL
- en: Equation 8.4 does not fire, because even though v2 = 3, attempting to subtract
    five from its state would make v2 negative, which is not allowed. The rules of
    FRACTRAN account for this by requiring the product of the state and a fraction
    to be an integer. The denominator of the fraction must be canceled completely
    by the prime factors of the state.
  prefs: []
  type: TYPE_NORMAL
- en: The addition example manipulated v2 and v3\. These are often used because they
    are the smallest primes, but there is no reason they must be used. Any two primes
    will work. For example, 8,675,309 and 8,675,311 are both prime. To show they work
    just as well, create *add3.frac*, containing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add 3 and 2 as before using v8675309 and v8675311 to set the initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: 8675309³8675311² = 49138847138949979077348022181175509
  prefs: []
  type: TYPE_NORMAL
- en: Run it to get
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: which is 8675311⁵.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This proves once again that 3 + 2 = 5 and that any pair of FRACTRAN registers
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '**More FRACTRAN Examples**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s examine more FRACTRAN examples. Specifically, let’s work through subtraction,
    the maximum of two values, duplicating registers, and multiplication. We’ll conclude
    by exploring Conway’s prime number example, PRIMEGAME, and the Collatz conjecture.
  prefs: []
  type: TYPE_NORMAL
- en: '***Subtraction***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Addition in FRACTRAN is a single fraction, and it turns out that subtraction
    is as well (see *sub.frac*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s run a test to work out 17 *–* 4 = 13\. The input is 2^(17)3⁴ = 10,616,832,
    with intermediate values corresponding to states:'
  prefs: []
  type: TYPE_NORMAL
- en: 2^(16)3³ → 2^(15)3² → 2^(14)3¹ → 2^(13)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The fraction 1/6 = 1/(2¹3¹), so every multiplication decrements both v2 and
    v3 by 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0227-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It decrements both v2 and v3 by 1 until v3 = 0 and multiplication by 1/6 no
    longer produces an integer, causing the program to stop. By assumption, the input
    is of the form 2*^a*3*^b*, *a* > *b*, so continually decrementing v2 and v3 together
    until v3 is 0 will necessarily leave the difference in v2\. If *b* > *a*, *sub.frac*
    still works, but the difference is in v3, not v2.
  prefs: []
  type: TYPE_NORMAL
- en: '***Maximum of Two Integers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: FRACTRAN adds and subtracts using single fractions, but to do anything more
    requires additional fractions. The file *max.frac* contains
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our first FRACTRAN program to use more than one fraction. The claim
    is that *max.frac* finds the largest of two integers, *a* and *b*. The input state
    looks familiar: register v2 = *a* and v3 = *b* with v5 holding the larger of the
    two when the program ends. Let’s try it and see.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-3: Finding the maximum of two integers*'
  prefs: []
  type: TYPE_NORMAL
- en: The input state is 2⁹3⁸ = 3,359,232 and the output state is 5⁹ = 1,953,125,
    which is correct, as 9 > 8\. Let’s follow the state step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 2⁹3⁸ → 2⁸3⁷5¹ → 2⁷3⁶5² → 2⁶3⁵5³ → 2⁵3⁴5⁴ →
  prefs: []
  type: TYPE_NORMAL
- en: → 2⁴3³5⁵ → 2³3²5⁶ → 2²3¹5⁷ → 2¹3⁰5⁸ → 5⁹
  prefs: []
  type: TYPE_NORMAL
- en: Each state is the prime factorization of the sequence of integers shown in [Listing
    8-3](ch08.xhtml#ch08list3).
  prefs: []
  type: TYPE_NORMAL
- en: The state sequence shows us how the program progresses, but as we have multiple
    fractions, it doesn’t show us exactly what is happening. Therefore, let’s trace
    the program’s actual execution.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0228-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that 5/6 is written as 5/(2¹3¹) to make it clear that 5/6 decrements v2
    and v3 when both are greater than 0, and 0 exponents are used to emphasize that
    a particular register has 0 value.
  prefs: []
  type: TYPE_NORMAL
- en: From the sequence of steps, we see that 5/6 starts a loop, decrementing v2 and
    v3 for as long as both of them are greater than 0\. At the same time, the loop
    increments v5\. Once v2 or v3 are 0, 5/6 does not fire, so the next fraction,
    5/2, is tested. In this case, v3 = 0 and v2 > 0, so 5/2 fires, incrementing v5
    and decrementing v2\. Then, and this is important, as there is a new state, the
    program loops *from the beginning* so both 5/6 and 5/2 are tested again. As v3
    is 0, 5/6 doesn’t fire. Additionally, v2 is now 0, so 5/2 doesn’t fire, either.
    That leaves 5/3, but v3 is 0 already, so 5/3 does not fire. There are no more
    fractions, so the program ends with v2 = 0, v3 = 0, and v5 = 9, as it should in
    this case. If the program were run with v2=8 and v3 = 9, then after 5/6 stops
    firing, 5/2 would not fire, but 5/3 would count v3 to 0 while still incrementing
    v5.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write *max.frac* in a more familiar way. [Listing 8-4](ch08.xhtml#ch08list4)
    presents a Python implementation of the algorithm implied by *max.frac* using
    register names (see *max.py*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-4: The FRACTRAN max program in Python*'
  prefs: []
  type: TYPE_NORMAL
- en: The outer `while` loop runs until both v2 and v3 are 0\. This is equivalent
    to restarting the scan of fractions from the beginning every time the state changes.
    The first `if` acts like 5/6, looping for as long as both v2 and v3 are greater
    than 0\. Notice that because of the `continue`, the following `if` statements
    are not even considered until at least one of v2 or v3 are 0.
  prefs: []
  type: TYPE_NORMAL
- en: The second `if` acts like 5/2\. It loops if v3 is 0 but v2 is not. The `continue`
    here starts the outer `while` loop again, meaning the first `if` is evaluated
    yet again; however, as v3 must be 0 for the second `if` to fire, the first `if`
    does not execute.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, if v2 is decremented to 0 first by the first `if`, then the last `if`
    fires to decrement v3 until 0\. Notice that each `if` statement increments v5
    every time it fires.
  prefs: []
  type: TYPE_NORMAL
- en: The first `if` decrements both v2 and v3 while incrementing v5\. This removes
    the value in common between v2 and v3\. The following two `if` statements provide
    clean up. One or the other will fire until whichever register that isn’t yet 0,
    either v2 or v3, becomes 0\. As v5 is always incremented regardless of which `if`
    fires, v5 will ultimately contain v2 or v3, whichever is larger. Note also that
    this program is destructive; both v2 and v3 will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: '***Copying a Register***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: FRACTRAN fractions fire when all of the prime factors of the denominator, to
    at least the power present in the denominator, are likewise present in the current
    state. In other words, the registers corresponding to the prime factors of the
    fraction’s denominator must have a value at least as large as the exponent of
    the denominator’s prime factors. Additionally, the act of firing necessarily decrements
    a register’s value. This is exactly how 3/2 operates in *add.frac*.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, to move the value of register v2 to, say, v7, we need a single fraction,
    7/2\. This is because every time it fires, v2 is decremented and v7 is incremented
    until v2 is 0\. The value of v2 is now in v7 and is no longer in v2\. What if
    instead we want to copy the value in v2 to v7 while leaving it in v2? Learning
    how to do this in FRACTRAN will teach us what we need to know to understand our
    next example, multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: Our copying-a-register code is based on an example found on Chris Lomont’s blog
    (see *[http://lomont.org/posts/2017/fractran/](http://lomont.org/posts/2017/fractran/)*).
    In this example, he not only gives detailed descriptions of various FRACTRAN programs,
    but presents a FRACTRAN interpreter written in FRACTRAN. Do take a look.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no getting around decrementing our source register, as that’s the
    only way we’ll get the fraction to fire. The trick, according to Chris, is to
    move the register’s value to *two* other registers: the desired target register
    and an auxiliary register. Then, when the move is complete, copy the auxiliary
    register back to the source.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-5](ch08.xhtml#ch08list5) shows *copy.frac*, which copies the contents
    of v2 to v3.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-5: Copying v2 to v3*'
  prefs: []
  type: TYPE_NORMAL
- en: Our plan of attack is to define what each register will do, show the code again
    using prime factors, and, lastly, walk through the steps to copy v2 = 3 to v3.
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy v2 to v3, we clearly need at least those two registers. The source
    is v2 and the target is v3\. We’ll use v5 as the second copy of v2\. The copy
    algorithm is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Decrement v2; increment v3 and v5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat Step 1 until v2 is 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decrement v5; increment v2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat Step 3 until v5 is 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need two loops, one to increment v3 and v5 running v2 times and another incrementing
    v2 running v5 times. FRACTRAN always scans fractions from the first onward, so
    loops are implemented by flags triggering the next scan of the code. Two loops
    imply that we need two additional registers to act as flags. However, to fire
    a fraction, we must always decrement at least one register, so using a single
    register to cause a loop destroys the flag value. Two registers are needed—one
    to trigger the loop and another to restore the flag after it was decremented.
    We’ll use v7 and v11 as flags for the first loop. Registers v13 and v17 will handle
    the second loop.
  prefs: []
  type: TYPE_NORMAL
- en: We now have our registers. Let’s review the code again, but this time using
    prime factors with labels and comments.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Label** | **Fraction** | **Comment** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| A | ![Image](Images/f0231-03.jpg) | Inc v3,v5; Dec v2,v7 |'
  prefs: []
  type: TYPE_TB
- en: '| B | ![Image](Images/f0231-04.jpg) | Reset v7 |'
  prefs: []
  type: TYPE_TB
- en: '| C | ![Image](Images/f0231-05.jpg) | Clear v7; Set v13 |'
  prefs: []
  type: TYPE_TB
- en: '| D | ![Image](Images/f0231-06.jpg) | Inc v2; Dec v5 |'
  prefs: []
  type: TYPE_TB
- en: '| E | ![Image](Images/f0231-07.jpg) | Reset v13 |'
  prefs: []
  type: TYPE_TB
- en: '| F | ![Image](Images/f0231-08.jpg) | Clear v13 |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s take a walk through the code. We set the initial state to 2³7 = 56 to
    set v2 = 3 and v7, the flag for the first loop. The program then runs like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0231-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The numbers represent the state after each fraction fires. The label above
    the arrow shows which fraction fired. The loops are evident: fractions A and B
    repeat three times. This decrements v2 and increments v3 and v5\. Then fraction
    C fires to clear v7 and set v13\. Doing this initiates the second loop. The second
    loop runs three times, with fractions D and E firing to decrement v5 and increment
    v2, thereby restoring its initial value. The very last fraction, F, then fires
    to clear v13\. After this, no other fractions fire, so the program ends with v2
    = v3 = 3, as intended.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look a bit more closely at the paired flags. The program begins with
    v7 set. Fraction A fires because both v2 and v7 are greater than 0\. Register
    v2 is decremented along with v7\. The numerator of fraction A increments v3 and
    v5 and sets v11\. To continue the loop, we must set v7 again. That’s what fraction
    B does: it fires when v11 is set (>0) and resets v7\. The loop then continues
    firing fraction A again because v2 and v7 are both greater than 0, that is, the
    state contains factors of 2 and 7\. When v2 is drained, v3 and v5 are both set
    to what v2 was initially. Fraction C then fires to clear v7 and set v13 to begin
    the second loop to move v5 back to v2 using fractions D and E. To end the program
    with no flags set, fraction F clears v13.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how this double-move loop structure can be used to implement
    multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: '***Multiplication***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Multiplication of two integers is repeated addition. To find the product of
    *a* × *b*, we either add *a* to itself *b* times or add *b* to itself *a* times.
    This is likely the origin of using the word *times* for multiplication. The copy
    example given earlier showed us how to use flags to set up independent loops and
    how to increment a register a set number of times while preserving the source
    register’s value. Let’s use repeated addition along with copying to implement
    multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we want a FRACTRAN program that takes an input state of 2^(*a*)3^(*b*)
    and generates a final state of 5^(*ab*) by adding v2 to v5 v3 times. We’ll implement
    the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: While v2 > 0, increment v5 and v7.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While v7 > 0, increment v2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While v3 > 0, repeat from Step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first loop is Step 1, which decrements v2 while incrementing v5 and v7\.
    Register v5 holds the product, so we’ll only increment it. Register v7 is used
    to hold v2 as v2 is drained while adding it to v5\. Step 2 restores v2 by moving
    v7 back to v2 just as we did in *copy.frac*. Steps 1 and 2 repeat until v3 is
    0, thereby adding v2 to v5 v3 times.
  prefs: []
  type: TYPE_NORMAL
- en: There are three loops, but we can combine Steps 2 and 3 into a single loop.
    For Step 1, we need a pair of registers for the flag; we’ll use v11 and v13\.
    The initial version of this program added v17 for the other loop, but that would
    only be necessary if there were code after the multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-6](ch08.xhtml#ch08list6) shows the end result (see *mult.frac*).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-6: Multiplication by repeated addition*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s label the fractions A through F as we did earlier. Doing this gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Label** | **Fraction** | **Comment** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| A | ![Image](Images/f0233-03.jpg) | Inc v5, v7; Set v13; Dec v2; Clear v11
    |'
  prefs: []
  type: TYPE_TB
- en: '| B | ![Image](Images/f0233-04.jpg) | Reset v11 |'
  prefs: []
  type: TYPE_TB
- en: '| C | ![Image](Images/f0233-05.jpg) | Clear v11 |'
  prefs: []
  type: TYPE_TB
- en: '| D | ![Image](Images/f0233-06.jpg) | Inc v2; Dec v7 |'
  prefs: []
  type: TYPE_TB
- en: '| E | ![Image](Images/f0233-07.jpg) | Dec v3; Set v11 |'
  prefs: []
  type: TYPE_TB
- en: '| F | ![Image](Images/f0233-08.jpg) | Dec v2 |'
  prefs: []
  type: TYPE_TB
- en: 'With this table, we can walk through a trace of 3 × 2 = 6\. The input state
    is 2³3² = 72 and the expected output state is 5⁶ = 15625\. First, let’s see that
    *mult.frac* actually works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as expected. Now, let’s trace the evolution of the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0233-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first fraction to fire is E, which decrements v3 and sets v11 to cause the
    add-v2-to-v5 loop to execute. The add loop, fractions A and B, repeats three times
    to increment v5 and v7\. After the third iteration, there is no longer a factor
    of 2 in the state (v2 = 0), so fraction C fires next to clear v11 and begin the
    outer loop.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the outer loop uses D to decrement v7 and increment v2, thereby
    restoring v2 to its original value. After the third time through that loop, v7
    is 0 and 7 is no longer a factor of the state, so fraction E fires to decrement
    v3 and set v11 to add v2 to v5 again.
  prefs: []
  type: TYPE_NORMAL
- en: The add loop of fractions A and B runs another three times. At this point, we
    have our answer in v5, and v2 and v3 are both 0, but fraction C fires again because
    v7 is not 0\. Fraction C fires three times to make v7 0 and v2 = 3\. However,
    v3 is now 0, so v11 is never set. Register v7 is now also 0 and the state is only
    v2 = 3 and v5 = 6\. Therefore, no fraction fires until F, which fires three times
    to decrement v2 to 0\. Lastly, the state is only v5 = 6, and no fraction has a
    factor of 5 in its denominator, so no fractions fire and the program ends. [Listing
    8-6](ch08.xhtml#ch08list6) multiplies, but cleaning up after calculating the answer
    requires many additional operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change gears now and explore the first FRACTRAN program Conway presented:
    PRIMEGAME.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Conway’s PRIMEGAME***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When Conway first presented PRIMEGAME, he did so by writing the fractions in
    [Listing 8-7](ch08.xhtml#ch08list7) and claiming that not only does every power
    of two generated by the program have a prime exponent, the primes are in order.
    Let’s explore in this section what he meant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-7: Conway’s PRIMEGAME*'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the copy and multiply examples above, we won’t step through [Listing
    8-7](ch08.xhtml#ch08list7). Conway does so in lectures available on the internet
    (for example, see *[https://www.youtube.com/watch?v=548BH-YFT1E/](https://www.youtube.com/watch?v=548BH-YFT1E/)*).
    Instead, we’ll capture the output of [Listing 8-7](ch08.xhtml#ch08list7) to see,
    empirically, that Conway’s claim is true. I leave it as an exercise for the motivated
    reader to work through the operation of [Listing 8-7](ch08.xhtml#ch08list7).
  prefs: []
  type: TYPE_NORMAL
- en: The primes program never halts, so we need to tell the interpreter to display
    every new state. If you run *primes.frac* with an initial state of 2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: your screen would immediately fill with large numbers. Some of these numbers
    are powers of two. Those are the numbers we want to display. We could modify *FRACTRAN.py*
    to display only the powers of two, but why alter the code for the interpreter
    when we can instead feed the output of *primes.frac* to the input of a second
    program that takes the output and, if it is a power of two, displays it?
  prefs: []
  type: TYPE_NORMAL
- en: The script *power_of_two.py* does what we want. It uses `input` to read the
    number FRACTRAN displays and checks whether it is a power of two. [Listing 8-8](ch08.xhtml#ch08list8)
    contains the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-8: A Python script to check for powers of two*'
  prefs: []
  type: TYPE_NORMAL
- en: The script accepts the input from FRACTRAN as an integer ➌, passes it to `isPowerOfTwo`,
    which returns `True` if the input (`d`) is a power of two and then prints it along
    with the exponent (`p`). This process repeats forever because of the `while` loop
    ➋.
  prefs: []
  type: TYPE_NORMAL
- en: The function `isPowerOfTwo` ➊ must check whether its argument is a power of
    two. We could call a log base-2 function here, but we’ll quickly encounter integers
    too large for any function expecting a floating-point argument. If an integer
    is a power of two, that means there is only one digit in its binary representation
    that is a 1\. So `d` is converted to binary and stored as a string in `s`. Then
    we set `n` to the number of 1s by using `count`. If `d` is a power of two, the
    exponent is the number of digits in `d` minus one (`p`). Lastly, any power of
    two is displayed along with its exponent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To link the output of FRACTRAN to the input expected by [Listing 8-8](ch08.xhtml#ch08list8),
    we use a Unix pipe character, `|`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'which feeds the output of FRACTRAN to the input of *power_of_two.py* to display
    powers of two. For example, the output begins as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here the exponents are all primes and, more than that, primes in the correct
    order with no gaps, just like Conway promised. The rate at which new primes are
    generated slows as the primes get larger. For example, the file *powers_of_two.txt*
    contains the output generated by letting the code run over-night. The largest
    prime found was 953.
  prefs: []
  type: TYPE_NORMAL
- en: Devin Kilminster made a nine fraction version of PRIMEGAME that outputs the
    primes as powers of 10 instead of two. See [Listing 8-9](ch08.xhtml#ch08list9)
    (*prime10.frac*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-9: Kilminster’s primes*'
  prefs: []
  type: TYPE_NORMAL
- en: Run *prime10.frac* with *power_of_ten.py* as we did for Conway’s game above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The output sequence using powers of 10 generates the primes, in order.
  prefs: []
  type: TYPE_NORMAL
- en: We might wonder which prime generator is faster. I modified *power_of* *_two.py*
    and *power_of_ten.py* to stop after the 100th prime, 541, and timed how long each
    program took using the Racket version of the FRACTRAN interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: '| Program | Runtime(s) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Conway | 3317 |'
  prefs: []
  type: TYPE_TB
- en: '| Kilminster | 783 |'
  prefs: []
  type: TYPE_TB
- en: Not only is Kilminster’s program shorter than Conway’s original PRIMEGAME, it’s
    also significantly faster.
  prefs: []
  type: TYPE_NORMAL
- en: Our next example generates the Collatz sequence for an integer. Don’t worry,
    I’ll explain what that means.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Collatz Conjecture***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Lothar Collatz was a German mathematician. In 1937, he speculated that the
    following sequence, for any initial integer, *x*[0] = *n*, will always end with
    1 (see Equation 8.6):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/08eqa06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For example, the sequence for *n* = 10 is
  prefs: []
  type: TYPE_NORMAL
- en: 10 → 5 → 16 → 8 → 4 → 2 → 1
  prefs: []
  type: TYPE_NORMAL
- en: Once the output is 4, the sequence 4 → 2 → 1 will repeat forever because 3(1)
    + 1 = 4.
  prefs: []
  type: TYPE_NORMAL
- en: To date, no one has succeeded in proving the Collatz conjecture, and all empirical
    tests have always ended in 1\. There is a deep connection between FRACTRAN and
    the Collatz conjecture that we’ll get to in the discussion below. For now, let’s
    run Conway’s FRACTRAN program to generate the Collatz sequence for any integer,
    *n*. (It’s highly likely Conway wrote this code, but solid proof has not been
    forthcoming.) The code is in *collatz.frac* and [Listing 8-10](ch08.xhtml#ch08list10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-10: FRACTRAN code to generate the Collatz sequence*'
  prefs: []
  type: TYPE_NORMAL
- en: The input is 2^(*n*) and the final output is 2¹. All states that are powers
    of two represent a number in the Collatz sequence. So we must filter the output
    using *power_of_two.py* as we did for PRIMEGAME above. Let’s try a few runs beginning
    with *n* = 128.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The large starting state is 2^(128). The Collatz sequence ends after seven steps.
    Not all sequences are so short. For example, changing from *n* = 128 to *n* =
    129 generates
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: for a total of 121 steps. As with PRIMEGAME, parsing the algorithm in *collatz.frac*
    is left as an exercise for the ambitious reader.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the sequence for 129 included values as large as 9,232\. This means
    the state contained a factor of 2^(9232), a number with 2,780 digits. Although
    *collatz.frac* will work for any integer, the intermediate values become quite
    large. Play around with *collatz.frac* or, if you are impatient, the much faster
    Python version, *collatz.py*. Do you notice anything interesting about the largest
    value in each sequence for *n* from 5 to 200?
  prefs: []
  type: TYPE_NORMAL
- en: '***A FRACTRAN Greeting***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ll end with an example more cute than it is useful. However, it does one
    interesting thing: the program’s goal is not a specific set of register values,
    per se, but the decimal value of the single integer representing the final state.
    The code is in *hello.frac* and [Listing 8-11](ch08.xhtml#ch08list11).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-11: A FRACTRAN greeting*'
  prefs: []
  type: TYPE_NORMAL
- en: First, run the program to verify that it produces the claimed output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Next, pipe the output to *hello.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The *hello.py* script is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This reads the FRACTRAN output as a string, breaking it up into pairs of digits
    and outputting the ASCII character corresponding to that pair of digits.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through *hello.frac*. The starting state is 2³5¹7¹11¹. The denominators
    of the fractions are also 2, 5, 7, and 11\. Therefore, the initial state will
    match each fraction, but the fractions’ order means it matches 3/2 first. The
    product of the state and 3/2 decrements v2 and increments v3, then starts again
    from the beginning, matching 3/2 a second time. Now v2 = 1 and v3 = 2\. Looping
    again sets v2 to 0 and v3 to 3\. Now the state has no factor of 2, so 3/2 does
    not fire, and FRACTRAN moves to 41/5\. The state is 3³5¹7¹11¹, which does have
    a factor of 5, so v5 is decremented, v41 is incremented, and the program loops.
    There are only factors of 7 and 11 left to match fractions. First, the fraction
    with a denominator of 7 matches and fires followed by the fraction with a denominator
    of 11.
  prefs: []
  type: TYPE_NORMAL
- en: The final state of the system is
  prefs: []
  type: TYPE_NORMAL
- en: 3³41¹6701021¹9800132160937639¹ = 72697676794432877982766833
  prefs: []
  type: TYPE_NORMAL
- en: 'which is precisely what we want it to be: a string of ASCII character codes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We wanted *hello.frac* to produce the integer corresponding to the sentence
    `HELLO, WORLD!`. That determined the printed output. The prime factorization of
    that output determined the final registers and their values. The included *primeFactors.py*
    searches for prime factors, but it is too slow to factor a large integer like
    the output of *hello.frac*. For that, I used WolframAlpha (see *[https://www.wolframalpha.com/](https://www.wolframalpha.com/)*).
    Prime factors in hand, the program itself was straightforward: set the initial
    state to v2 = 3, v5 = 1, v7 = 1, and v11 = 1\. Then, use the prime factors as
    the numerators to increment v3, v41, and so on for the necessary number of times:
    3, 1, 1, and 1.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we could initialize the program with the desired output state and,
    using a fraction with no factor in the denominator matching the state, produce
    the desired output immediately, but that would be boring.
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s discuss two aspects of FRACTRAN: Turing completeness and its relation
    to the Collatz conjecture. After that, we’ll conclude with some final thoughts.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Is FRACTRAN Turing Complete?***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Is FRACTRAN Turing complete? Yes, it is. FRACTRAN has looping and an infinite
    number of registers as there are an infinite number of primes. Additionally, FRACTRAN
    can implement FRACTRAN, as Chris Lomont’s blog post mentioned previously demonstrates.
    Also, FRACTRAN is a Minsky-style register machine, a machine that has been proven
    to be Turing complete, so FRACTRAN is also Turing complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conway himself included a universal FRACTRAN program in his description of
    FRACTRAN: POLYGAME. See “FRACTRAN: A Simple Universal Programming Language for
    Arithmetic” in *Open Problems in Communication and Computation* (Springer, 1987).'
  prefs: []
  type: TYPE_NORMAL
- en: 'POLYGAME is a FRACTRAN program capable of computing any function when given
    the proper “catalogue number” as Conway called it. We’ll use the British spelling
    henceforth. Here is POLYGAME:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0239-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The input is *c*2^(2^(*n*)), with *n* the argument and *c* the catalogue number.
    The output is 2^(2^m) to implement *f*[*c*](*n*) = *m*. For example, the increment
    function *n* →*n* + 1 has catalogue number 2,268,945\. Therefore, to increment
    4, the input to FRACTRAN is
  prefs: []
  type: TYPE_NORMAL
- en: (2,268,945)2^(2⁴) = 148,697,579,520
  prefs: []
  type: TYPE_NORMAL
- en: to produce the output
  prefs: []
  type: TYPE_NORMAL
- en: 2^(2⁵) = 4,294,967,296
  prefs: []
  type: TYPE_NORMAL
- en: which is exactly what we get if we run POLYGAME.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'POLYGAME can implement *all* functions given the proper *c*. Another example
    is *c* = 255, the identity function: *n* → *n*. The most interesting example Conway
    gives is *c*[*π*]. It’s an integer, but good luck calculating'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0270-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Yes, that is a 5 raised to the power of two raised to the factorial of 101\.
    Given the insane size of *c*[*π*], we’ll take Conway’s word for it that *c*[*π*]
    is the catalogue number for a function, *π*(*n*), returning the *n*th digit of
    *π*.
  prefs: []
  type: TYPE_NORMAL
- en: '***FRACTRAN and the Collatz Conjecture***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Equation 8.6 defined the Collatz sequence for an integer, *n*. The equation
    describes how to generate the next number in the sequence based on whether the
    current number is even or odd. Another way to formulate Equation 8.6 is shown
    in Equation 8.7.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/08eqa07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: meaning *x*[*i*+1] = *x*[*i*]/2 if *x*[*i*]/2 is an integer; otherwise, *x*[*i*+1]
    = 3*x*[*i*] + 1, which is always an integer.
  prefs: []
  type: TYPE_NORMAL
- en: The Collatz sequence is what Conway terms a *bipartite linear function*, meaning
    a function that can be written as
  prefs: []
  type: TYPE_NORMAL
- en: '*g*(*n*) = *g*[1](*n*) *|* *g*[2](*n*)'
  prefs: []
  type: TYPE_NORMAL
- en: with *g*(*n*) returning whichever of *g*[1](*n*) or *g*[2](*n*) returns an integer
    first when evaluating left to right. Each *g*[*i*](*n*) is of the form
  prefs: []
  type: TYPE_NORMAL
- en: '*g**[i]*(*n*) = *a**[i]**n* + *b**[i]*'
  prefs: []
  type: TYPE_NORMAL
- en: which is a linear function (a line). For the Collatz sequence, *a*[1] = 1/2
    and *b*[1] = 0\. Similarly, *a*[2] = 3 and *b*[2] = 1.
  prefs: []
  type: TYPE_NORMAL
- en: There is no reason why *g*(*n*) should be limited to only two parts. A *k*-partite
    linear function is
  prefs: []
  type: TYPE_NORMAL
- en: '*g*(*n*) = *g*[1](*n*) *|* *g*[2](*n*) *|* *g*[3](*n*) *|* … *|* *g**[k]*(*n*)'
  prefs: []
  type: TYPE_NORMAL
- en: Conway calls *k*-partite functions with *g*[*i*](*n*) = *a*[*i*]*n* + *b*[*i*]
    *Collatzian games*. The rule for evaluating *g*(*n*) is to calculate *g*[1](*n*)
    followed by *g*[2](*n*) and so on until one of them returns an integer. If none
    of them return an integer, or if the integer returned is some specified value,
    like 1, stop.
  prefs: []
  type: TYPE_NORMAL
- en: This rule sounds familiar. If we set all the *b*[*i*]s to 0 and all the *a*[*i*]s
    to rationals, then *g*(*n*) is a FRACTRAN program. Therefore, FRACTRAN programs
    are Collatzian games. However, note that the Collatz conjecture is not a FRACTRAN
    program, as *b*[2] = 1.
  prefs: []
  type: TYPE_NORMAL
- en: Gödel’s incompleteness theorem states that arithmetic contains true statements
    it cannot prove using the axioms of arithmetic. Alan Turing translated this concept
    into the *halting problem*, which states that it is impossible to find an algorithm
    that will correctly decide in all cases whether a program (a Turing machine) with
    a finite input will eventually stop or run forever. The term to describe these
    cases is *undecidable*. An undecidable problem has been *proven* to be so; there
    is no algorithm that will correctly decide in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: FRACTRAN programs are undecidable, and FRACTRAN programs are a type of Collatzian
    game. Therefore, there are Collatzian games that are undecidable, games for which
    it is impossible to prove that the game ends as desired for all inputs, *n*. This
    fact does not solve the question of the Collatz conjecture, as the conjecture
    applies to a Collatzian game that is not a FRACTRAN program. However, showing
    there are undecidable Collatzian games is an important result all the same. It
    may be that the Collatz conjecture is undecidable, too.
  prefs: []
  type: TYPE_NORMAL
- en: '***Final Thoughts on FRACTRAN***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When first encountered, FRACTRAN might appear to be a cute but useless esolang,
    much like the original form of ABC from [Chapter 7](ch07.xhtml#ch07). The trick
    of using Gödel numbering to hold the state of the program makes FRACTRAN more
    interesting, but still, it’s just another esolang, though now a clever one.
  prefs: []
  type: TYPE_NORMAL
- en: The universality of FRACTRAN adds to its intellectual attractiveness. However,
    the fact that FRACTRAN links Gödel’s incompleteness theorem with Turing’s halting
    problem and Conway’s Collatzian games is brilliant. FRACTRAN is set apart from
    the other languages we’ll explore. I hope it causes you to ponder deeper issues
    related to programming, computation, what can and cannot be known, and what it
    even means to know that you cannot know.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we explored FRACTRAN, an esolang that at first glance seems
    like nothing more than a clever game. After implementing the language in both
    Racket and Python, we tested it and struggled to understand how it worked. Next,
    we explored multiple examples of FRACTRAN programs to help build our intuition
    about what coding in FRACTRAN entails. Along the way, we learned about the Collatz
    conjecture, itself an interesting intellectual exercise.
  prefs: []
  type: TYPE_NORMAL
- en: We closed the chapter by discussing the connections between FRACTRAN, Gödel’s
    incompleteness theorem, Turing’s halting problem, and Collatzian games, all of
    which provide much food for thought.
  prefs: []
  type: TYPE_NORMAL
- en: FRACTRAN forced us to think mathematically. Now, let’s mix things up with Piet,
    a language that forces us to think visually.
  prefs: []
  type: TYPE_NORMAL
