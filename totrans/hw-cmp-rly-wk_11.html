<html><head></head><body>
<span epub:type="pagebreak" id="page_233"/>&#13;
<h2 class="h2"><strong><span class="big">11</span><br/>THE INTERNET</strong></h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindents">So far, we’ve focused on computing that occurs on a single device. In this chapter and the next, we look at computing that spans multiple devices. We’re going to examine two significant innovations in computing, the internet and the world wide web, which are not the same thing! This chapter focuses on the internet, and we begin by defining key terms. Then we look at a layered model of networks and dig into some of the foundational protocols used on the internet.</p>&#13;
<h3 class="h3" id="lev1_84"><strong>Networking Terms Defined</strong></h3>&#13;
<p class="noindent">To discuss the internet and networks in general, you first need to become familiar with some concepts and terms, which we cover here. A <em>computer</em> <span epub:type="pagebreak" id="page_234"/><em>network</em> is a system that allows computing devices to communicate with each other, as illustrated in <a href="ch11.xhtml#ch11fig1">Figure 11-1</a>. Networks can be connected wirelessly, using technologies like Wi-Fi, which transmits data using radio waves. Networks can also be connected with cables, such as copper wiring or fiber optics. Computing devices on a network must use a common <em>communications protocol</em>, a set of rules that describe how information is to be exchanged.</p>&#13;
<div class="image" id="ch11fig1"><img src="../images/fig11-1.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 11-1: A computer network</em></p>&#13;
<p class="indent">The <em>internet</em> is a globally connected set of computer networks that all use a suite of common protocols. The internet is a <em>network of networks</em>, connecting networks from various organizations all around the world, as shown in <a href="ch11.xhtml#ch11fig2">Figure 11-2</a>.</p>&#13;
<div class="image" id="ch11fig2"><img src="../images/fig11-2.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 11-2: The internet: a network of networks</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_235"/>A <em>host</em> or <em>node</em> is a single computing device attached to a network. A host can act as a server or a client on the network, or sometimes both. A network <em>server</em> is a host that listens for inbound network connections and provides services to other hosts. Examples are a web server and an email server. A network <em>client</em> is a host that makes outbound connections and requests services from network servers. Example clients are smartphones or laptops running web browsers or email apps. A client makes a <em>request</em> to a server, and the server replies with a <em>response</em>, as illustrated in <a href="ch11.xhtml#ch11fig3">Figure 11-3</a>.</p>&#13;
<div class="image" id="ch11fig3"><img src="../images/fig11-3.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 11-3: A client makes a request to a server, and the server responds</em></p>&#13;
<p class="indent">The term <em>server</em>, as just used, refers to any device that accepts inbound requests and provides services to clients. However, <em>server</em> can also refer to a class of computer hardware that’s specifically intended to act as a network server. These specialized computers are physically designed to be mounted into racks of computers in a datacenter and often include hardware redundancy and management capabilities not found in a typical PC. However, any device with the right software can act as a server on a network.</p>&#13;
<h3 class="h3" id="lev1_85"><strong>The Internet Protocol Suite</strong></h3>&#13;
<p class="noindent">Physically connecting the networks of the world isn’t enough to allow the devices on those networks to communicate with each other. All participating computers need to communicate in the same way. The <em>internet protocol suite</em> standardizes the method of communication on the internet, ensuring that all devices on the network speak the same language. The two foundational protocols in the internet protocol suite are <em>Transmission Control Protocol (TCP)</em> and <em>Internet Protocol (IP)</em>, collectively known as <em>TCP/IP</em>.</p>&#13;
<p class="indent">Network protocols operate in a layered model, and an implementation of such a model is referred to as a <em>network stack</em> (not to be confused with a stack in memory, as covered in <a href="ch09.xhtml">Chapter 9</a>). The protocols at the lowest layer interact with the underlying networking hardware, whereas applications interact with protocols in the upper layers. Protocols in the intermediate layers provide services such as addressing and reliable delivery of data. A protocol at a certain layer doesn’t have to concern itself with the entire networking stack, only the layers with which it interfaces, simplifying the overall design. This is another example of encapsulation.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_236"/>The internet protocol suite is designed around a four-layer model. This is sometimes called the <em>TCP/IP model</em>. The four layers of the TCP/IP model, starting from the bottom up, are the link layer, the internet layer, the transport layer, and the application layer, as shown in <a href="ch11.xhtml#ch11fig4">Figure 11-4</a>.</p>&#13;
<div class="image" id="ch11fig4"><img src="../images/fig11-4.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 11-4: The internet protocol suite model of networking</em></p>&#13;
<div class="sidebar">&#13;
<p class="exercise"><strong>OSI—ANOTHER NETWORK MODEL</strong></p>&#13;
<p class="exercise-para">Another commonly used model for network protocols is the <em>Open Systems Interconnection (OSI) model</em>. The OSI model divides protocols into seven layers rather than four. This model is often referenced in technical literature, but the internet is based on the internet protocol suite, so this book focuses on the TCP/IP model.</p>&#13;
</div>&#13;
<p class="indent">These networking layers represent an abstraction, a model for us to use when discussing the operation of the internet. In practice, each layer is realized with specific networking protocols. Each network layer represents a scope of responsibilities, and protocols must fulfill the responsibilities of their assigned layer. <a href="ch11.xhtml#ch11tab1">Table 11-1</a> provides a description of each layer.</p>&#13;
<p class="tabcap" id="ch11tab1"><strong>Table 11-1:</strong> Description of the Four Layers of the Internet Protocol Suite</p>&#13;
<span epub:type="pagebreak" id="page_237"/>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Layer</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Description</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Example protocols</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Application</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Protocols that operate at the application layer provide application-specific functionality, such as sending an email or retrieving a web page. These protocols accomplish tasks that end users (or backend services) wish to complete. Application layer protocols structure the data used in process-to-process communication across a network. All the lower layer protocols exist as “plumbing” to support the application layer.</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">HTTP, SSH</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">Transport</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">Transport layer protocols provide a communications channel for applications to send and receive data between hosts. An application structures data according to an application layer protocol and then hands off that data to a transport layer protocol for delivery to a remote host.</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">TCP, UDP</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Internet</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Internet layer protocols provide a mechanism for communicating across networks. This layer is responsible for identifying hosts with addresses and enabling the routing of data from network to network across the internet. The transport layer relies on the internet layer for addressing and routing.</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">IP</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">Link</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">Link layer protocols provide a way to communicate on a local network. Protocols at this layer are closely associated with the type of networking hardware on a local network, such as Wi-Fi. Protocols at the internet layer rely on link layer protocols to communicate on a local network.</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">Wi-Fi, Ethernet</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Protocols at each layer communicate with the protocols in adjacent layers. An outgoing transmission from a host travels down through the network layers, from an application layer protocol, to a transport layer protocol, to an internet layer protocol, and finally to a link layer protocol. An incoming transmission to a host travels up through the network layers, reversing the order just described.</p>&#13;
<p class="indent">Although network hosts (such as a client or server) make use of protocols from all four layers, other types of networking hardware (such as switches and routers) only use protocols associated with lower layers. Such devices can perform their jobs without bothering to examine the higher layer protocol data contained in a network transmission.</p>&#13;
<p class="indent">An outgoing request from a client to a server, and its relationship to the networking layers, is illustrated in <a href="ch11.xhtml#ch11fig5">Figure 11-5</a>.</p>&#13;
<span epub:type="pagebreak" id="page_238"/>&#13;
<div class="image" id="ch11fig5"><img src="../images/fig11-5.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 11-5: A network request travels through various network layers</em></p>&#13;
<p class="indent">Let’s walk through the flow of <a href="ch11.xhtml#ch11fig5">Figure 11-5</a>. An application on the client device forms a request using an application layer protocol. That request is handed off to a transport layer protocol, then to an internet layer protocol, and finally to a link layer protocol. All of this happens on the client device. At this point the request is transmitted onto the local network, labeled Network 1 in the diagram. The request makes its way across the internet, going from network to network. In this example, Router A routes the request from Network 1 to Network 2, and Router B routes the request from Network 2 to Network 3. Once the request reaches the destination server, it works its way up through the networking protocols, starting with a link layer protocol, and ending at an application layer protocol. A process running on the server receives the request, which is formatted according to the application layer protocol originally used by the client. The server process interprets the request and responds in an appropriate manner.</p>&#13;
<p class="indent">Let’s now take a look at each layer, starting from the bottom.</p>&#13;
<h4 class="h4" id="lev2_31"><strong><em>Link Layer</em></strong></h4>&#13;
<p class="noindent">The lowest level of the internet protocol suite is the <em>link layer</em>. The physical and logical connections between hosts are known as network <em>links</em>. Link layer protocols are used by devices on the same network to communicate with each other. Each device on a link has a network address that uniquely identifies it. For many link layer protocols, this address is known as a <em>media access control address</em> (or <em>MAC address</em>). Link layer data is divided into small units known as <em>frames</em>, each including a header describing the frame, a payload of data, and finally, a frame footer used to detect errors. This is illustrated in <a href="ch11.xhtml#ch11fig6">Figure 11-6</a>.</p>&#13;
<div class="image" id="ch11fig6"><img src="../images/fig11-6.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 11-6: A link layer frame</em></p>&#13;
<p class="indent">The frame header contains source and destination MAC addresses. The header also includes a descriptor of the type of data carried in the frame data section.</p>&#13;
<p class="indent">If your home has a Wi-Fi network, Wi-Fi is the link between the hosts on your network. The Wi-Fi protocol, defined by the IEEE 802.11 specifications, doesn’t know or care what type of data is being sent over the wireless network; it simply enables communication between devices. Each device connected to the Wi-Fi network has a MAC address and receives frames sent to its address. MAC addresses are only useable on a local network; a computer on a remote network cannot directly send data to a MAC address on your local network.</p>&#13;
<p class="indent">Another notable link layer technology is <em>Ethernet</em>, used for wired physical connections. Ethernet is defined by the IEEE 802.3 standards. Ethernet typically uses a cable with pairs of copper wires inside that ends in a connector commonly known as <em>RJ45</em>, shown in <a href="ch11.xhtml#ch11fig7">Figure 11-7</a>.</p>&#13;
<span epub:type="pagebreak" id="page_239"/>&#13;
<div class="image" id="ch11fig7"><img src="../images/fig11-7.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 11-7: The cable commonly used for Ethernet</em></p>&#13;
<p class="indent">All devices connected to the internet participate in the link layer. This is required, since it’s the link layer that provides connectivity (either wired or wireless) to a local network. A host, like a laptop or smartphone, participates in all layers, but certain networking devices operate at the link layer only. The most basic example of this is a hub. A <em>network hub</em> is a networking device that connects multiple devices on a local network without any intelligence regarding the frames being sent. A simple hub might provide multiple Ethernet ports for connecting devices. The hub simply retransmits every frame it receives on one physical port to all its other ports. A more intelligent link layer device is a <em>network switch</em>, which examines the MAC addresses in the frames it receives and sends those frames to the physical port where the device with the destination MAC address is connected.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch11.xhtml#proj29">Project #29</a> on <a href="ch11.xhtml#page_254">page 254</a>, where you can look at link layer devices and MAC addresses</em>.</p>&#13;
</div>&#13;
<h4 class="h4" id="lev2_32"><strong><em>Internet Layer</em></strong></h4>&#13;
<p class="noindent">The <em>internet layer</em> allows data to travel beyond the local network. The primary protocol used in this layer is simply called Internet Protocol (IP). It enables <em>routing</em>, the process of determining a path for data that’s transmitted between networks. Every host on the internet is assigned an <em>IP address</em>, a number that uniquely identifies the host on the global internet. It’s also possible to have private IP addresses that aren’t directly exposed on the internet. IP addresses are usually assigned by a server on the local network, and a device’s IP address typically changes when it connects to a new network. We’ll cover more on address assignment and private IP addresses later.</p>&#13;
<p class="indent">Data sent over the internet layer is called a <em>packet</em>, which is enclosed in a link layer frame. <a href="ch11.xhtml#ch11fig8">Figure 11-8</a> illustrates the idea that a packet fits within a frame’s data section.</p>&#13;
<p class="indent">The IP packet header contains a source IP address and a destination IP address. The header also includes information that describes the packet, such as the IP version in use and the header length. The data section of the IP packet contains the payload that the IP layer is carrying.</p>&#13;
<span epub:type="pagebreak" id="page_240"/>&#13;
<div class="image" id="ch11fig8"><img src="../images/fig11-8.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 11-8: A packet is contained in the data section of a frame</em></p>&#13;
<p class="indent">Two versions of Internet Protocol are in use on the internet today. <em>Internet Protocol Version 4 (IPv4)</em> is the dominant version in use, and the other active version is <em>Internet Protocol Version 6 (IPv6)</em>. You may wonder what happened to IPv5. No such protocol ever existed, but an experimental protocol called Internet Stream Protocol identified its IP version as 5, and so IPv5 was skipped when the successor to IPv4 was developed. A significant difference between IPv4 and IPv6 is the size of an IP address. An IPv4 address is 32 bits in length, whereas an IPv6 address is 128 bits. This difference allows for a vastly larger number of addresses with IPv6. This change in address size is meant to help deal with the relatively short supply of IPv4 addresses. In this book, we focus on IPv4 addresses (and just refer to them as <em>IP addresses</em>), as they are still the primary means of addressing on the internet today.</p>&#13;
<p class="indent">A 32-bit IP address is typically displayed in dotted decimal notation, meaning the 32 bits are separated into four groups of 8 bits each, the 8-bit numbers are displayed in decimal (rather than hexadecimal or binary), and the four decimal numbers are separated by periods (dots). An example IP address, displayed in dotted decimal notation, is 192.168.1.23. Each 8-bit decimal number can be referred to as an <em>octet</em>.</p>&#13;
<p class="indent">Computers connected to the same local network have IP addresses that begin with the same leading bits and are said to be on the same <em>subnet</em>. Computers that are on the same subnet are able to communicate directly with each other at the link layer because they are operating on the same physical network. Computers that are on different subnets must send their traffic through a <em>router</em>, a device that connects subnets and operates at the internet layer.</p>&#13;
<p class="indent">Subnetting divides the IP address into two parts: the <em>network prefix</em>, which all devices on the same subnet share, and the <em>host identifier</em>, which is unique to a host on that subnet. The number of bits included in the network prefix varies based on the network configuration.</p>&#13;
<p class="indent">Let’s look at an example. Assume a subnet uses a 24-bit network prefix, leaving us with 8 bits to represent the host. Also assume that a host on this subnet uses the example IP address from earlier—192.168.1.23. Given this IP address and network prefix, the IP address is divided as shown in <a href="ch11.xhtml#ch11fig9">Figure 11-9</a>.</p>&#13;
<p class="indent">In this example, all hosts on the local subnet have an IP address that begins with 192.168.1. Each host has a different value for the last octet, with <span class="literal">23</span> being assigned to this specific host. This example uses a 24-bit prefix length, meaning the prefix neatly aligns with the first three octets of the IP address. <span epub:type="pagebreak" id="page_241"/>This makes for a nice example, but the prefix length doesn’t always align with an octet boundary. A 25-bit prefix, for example, would also include the first bit of the last octet, leaving only 7 bits for identifying the host.</p>&#13;
<div class="image" id="ch11fig9"><img src="../images/fig11-9.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 11-9: An example IP address using a 24-bit network prefix</em></p>&#13;
<p class="indent">The number of bits reserved for the network prefix is commonly expressed in one of two ways. <em>Classless Inter-Domain Routing (CIDR) notation</em> lists an IP address followed by a slash (/), and then the number of bits used for the network prefix. In our example this would be 192.168.1.23/24. Another common way to represent the number of prefix bits is with a <em>subnet mask</em>, a 32-bit number where a binary 1 is used for each bit that’s part of the network prefix and a 0 is used for each bit that’s part of the host number. Subnet masks are also written in dotted decimal notation, so our example of a 24-bit network prefix would result in a subnet mask of 255.255.255.0, as shown in <a href="ch11.xhtml#ch11fig10">Figure 11-10</a>.</p>&#13;
<div class="image" id="ch11fig10"><img src="../images/fig11-10.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 11-10: A 24-bit network prefix expressed as a subnet mask</em></p>&#13;
<p class="indent">Let’s look at how this is useful in practice. Say your computer has an IP address of 192.168.0.133 and a subnet mask of 255.255.255.224, or, expressed in CIDR notation, 192.168.0.133/27. Your computer wishes to connect to another computer with an IP address of 192.168.0.84. As mentioned earlier, two computers can communicate directly if they are on the same subnet, and if not, they must go through a router. So your computer must determine if the other computer is on the same subnet. How can it do this?</p>&#13;
<span epub:type="pagebreak" id="page_242"/>&#13;
<p class="indent">Performing a bitwise logical AND of an IP address and its subnet mask produces the first address in a subnet. This first address, where the host bits are all 0, serves as an identifier for the subnet itself. This is commonly referred to as the <em>network ID</em>. Two computers that share a network ID are on the same subnet. A host can perform this AND operation against both its own IP address and the IP address it wishes to connect to, to see if they share a network ID and thus are on the same subnet. Let’s try this with our example computer’s IP address, as shown here:</p>&#13;
<p class="programs">  IP = 192.168.0.133   = 11000000.10101000.00000000.10000101<br/>&#13;
MASK = 255.255.255.224 = 11111111.11111111.11111111.11100000<br/>&#13;
 AND = 192.168.0.128   = 11000000.10101000.00000000.10000000 = The network ID</p>&#13;
<p class="indent">Now perform the same operation for the second computer in our example:</p>&#13;
<p class="programs">  IP = 192.168.0.84    = 11000000.10101000.00000000.01010100<br/>&#13;
MASK = 255.255.255.224 = 11111111.11111111.11111111.11100000<br/>&#13;
 AND = 192.168.0.64    = 11000000.10101000.00000000.01000000 = The network ID</p>&#13;
<p class="indent">As you can see from this example, this operation produced two different network IDs (<span class="literal">192.168.0.128</span> and <span class="literal">192.168.0.64</span>). This means that the second computer is not on the same subnet as your computer. To communicate, these computers need to send their messages through a router connecting the two subnets.</p>&#13;
<div class="sidebar">&#13;
<p class="exercise" id="ch11ex1"><strong>EXERCISE 11-1: WHICH IPS ARE ON THE SAME SUBNET?</strong></p>&#13;
<p class="exercise-para">Is IP address 192.168.0.200 on the same subnet as your computer? Assume your computer has an IP address of 192.168.0.133 and a subnet mask of 255.255.255.224.</p>&#13;
</div>&#13;
<p class="indent">Here’s another way to look at this: the network prefix describes the range of addresses that can be used on a subnet. The first address in that range is defined as the network prefix bits followed by all binary 0s for the host identifier. Continuing with our example computer at 192.168.0.133, the first address on its subnet is 192.168.0.128. The last address in the range is the network prefix bits followed by all binary 1s for the host identifier. In our example that’s 192.168.0.159. The first and last addresses have special meanings—the first identifies the network, the last is the <em>broadcast address</em> (used for sending a message to all hosts on the subnet). All the addresses in between can be used for hosts on the subnet. Our example IP address of 192.168.0.133 is clearly in this range (from 192.168.0.128 to 192.168.0.159), while the other computer with an IP address of 192.168.0.84 is outside this range.</p>&#13;
<p class="indent">You can also use the number of bits reserved for the host identifier to determine how many IP addresses are available for hosts on a subnet. In <span epub:type="pagebreak" id="page_243"/>our example, 27 bits are reserved for the network prefix, leaving 5 bits for host identifiers. These 5 bits give us 32 possible host addresses, since 2<sup>5</sup> is 32. However, as mentioned earlier, the first and last addresses have special purposes, so really only 30 hosts can be identified using this network prefix. This aligns with our earlier findings: the first host identifier is 128, and 128 + 32 gives us 160, the first address in the next subnet, so 159 would be the last host in our range.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch11.xhtml#proj30">Project #30</a> on <a href="ch11.xhtml#page_255">page 255</a>, where you can look at the internet layer using your Raspberry Pi</em>.</p>&#13;
</div>&#13;
<h4 class="h4" id="lev2_33"><strong><em>Transport Layer</em></strong></h4>&#13;
<p class="noindent">The <em>transport layer</em> provides a communications channel that applications may use to send and receive data. There are two commonly used transport layer protocols: Transmission Control Protocol (TCP) and <em>User Datagram Protocol (UDP)</em>. TCP provides a reliable connection between two hosts. It ensures that errors are minimized, data arrives in order, lost data is resent, and so forth. Data sent with TCP is known as a <em>segment</em>. On the other hand, UDP is a “best effort” protocol, meaning its delivery is unreliable. UDP is preferred when speed is valued over reliability. Data sent with UDP is known as a <em>datagram</em>. Both protocols have their place, but to keep things simple, I cover only TCP for the remainder of the chapter. <a href="ch11.xhtml#ch11fig11">Figure 11-11</a> illustrates the idea that a TCP segment fits within a packet’s data section, which in turn fits within a frame’s data section.</p>&#13;
<p class="indent">As we saw earlier, the link layer includes a destination MAC address in the frame header to identify a local network interface, and the internet layer includes a destination IP address in the packet header to identify the host on the internet. That’s enough information to get a packet to a specific device on the internet. Once a packet has reached its destination host, the transport layer header includes a destination network <em>port number</em> that identifies the specific service or process that will receive the data. A host with a single IP address can have multiple active ports, each used for performing a different type of activity on the network.</p>&#13;
<div class="image" id="ch11fig11"><img src="../images/fig11-11.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 11-11: A TCP segment is contained in the data section of an IP packet</em></p>&#13;
<p class="indent">To use an analogy, an IP address is like the street address of an office building, and a network port number is like the office number of a worker <span epub:type="pagebreak" id="page_244"/>in that office building. The IP address uniquely identifies a host computer, just as a street address uniquely identifies an office building. Using internet protocol, a packet can be delivered to a host in the same way that a package can be delivered to an office building. However, once a packet arrives at the computer, the operating system must decide what to do with it. The packet isn’t intended for the OS itself, but for some process running on the computer. In the same way, a package arriving at an office building likely isn’t intended for the mailroom worker but for someone else in the building. An operating system examines the port number and delivers the inbound data to the process listening on the specified port, just as a mailroom worker examines the name or office number on the package to deliver the package to the right person.</p>&#13;
<p class="indent">Network ports in the range of 0 to 1,023 are called <em>well-known ports</em>, whereas ports in the range of 1,024 to 49,151 can be registered with the Internet Assigned Numbers Authority (IANA) and are known as <em>registered ports</em>. Ports with a value greater than 49,151 are <em>dynamic ports</em>. Technically, any process with sufficient privileges can listen on any port that isn’t already in use on a system, potentially ignoring the typical use case for that port number. However, when a client application wishes to connect to a remote service on another computer, it needs to know what port to use, so it makes sense to standardize port numbers. For example, web servers typically listen on port 80 and port 443 (for encrypted connections). A web browser assumes that it should use port 80 or 443 unless directed otherwise.</p>&#13;
<div class="sidebar">&#13;
<p class="exercise" id="ch11ex2"><strong>EXERCISE 11-2: RESEARCH COMMON PORTS</strong></p>&#13;
<p class="exercise-para">Find the port numbers for common application layer protocols. What are the port numbers for Domain Name System (DNS), Secure Shell (SSH), and Simple Mail Transfer Protocol (SMTP)? You can find this information online with a search, or by looking at the IANA registry, here: <em><a href="http://www.iana.org/assignments/port-numbers">http://www.iana.org/assignments/port-numbers</a></em>. The IANA listings sometimes use an unexpected term for the service name. For example, DNS is simply listed as “domain.”</p>&#13;
</div>&#13;
<p class="indent">Servers use well-known ports to make it easy for clients to connect. However, most network communication is a two-way street (a client sends a request and a server responds), so the client needs to have an open port as well so that it can receive data from the server. A client only needs to temporarily open such a port, just long enough for it to complete its communication with a server. Such ports are called <em>ephemeral ports</em> and are assigned by the networking components in the operating system. For example, a client web browser connects to a web server on port 80, and an ephemeral port on the client is also opened, let’s say port number 61,348. The client sends its web request to port 80 on the server, and the server sends its response to port 61,348 on the client.</p>&#13;
<span epub:type="pagebreak" id="page_245"/>&#13;
<p class="indent">An IP address plus a port number form an <em>endpoint</em>, and an instance of an endpoint is known as a <em>socket</em>. A socket can listen for new connections, or it can represent an established connection. If multiple clients connect to the same endpoint, each has its own socket.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch11.xhtml#proj31">Project #31</a> on <a href="ch11.xhtml#page_256">page 256</a>, where you can look at the port usage of your Raspberry Pi</em>.</p>&#13;
</div>&#13;
<h4 class="h4" id="lev2_34"><strong><em>Application Layer</em></strong></h4>&#13;
<p class="noindent">The <em>application layer</em> is the final, topmost layer of the internet protocol suite. While the lower three layers provide a generalized foundation for communication over the internet, the protocols at the application layer focus on accomplishing a specific task. For example, web servers use <em>HyperText Transfer Protocol (HTTP)</em> for retrieving and updating web content. Email servers use <em>Simple Mail Transfer Protocol (SMTP)</em> for sending and receiving email messages. File transfer servers use <em>File Transfer Protocol (FTP)</em> to, you guessed it, transfer files! In other words, the application layer is where we get to the protocols that describe the behavior of applications, whereas the lower layers of the stack are the “plumbing” that enables applications to do the things they want to do over the internet. <a href="ch11.xhtml#ch11fig12">Figure 11-12</a> provides a completed view of the four layers.</p>&#13;
<div class="image" id="ch11fig12"><img src="../images/fig11-12.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 11-12: The application layer’s data is contained in the segment’s data section.</em></p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11fig12">Figure 11-12</a> is a breakout view of how each layer fits in the lower layer’s data payload. Assembling all the layers together in <a href="ch11.xhtml#ch11fig13">Figure 11-13</a>, we can see a representation of what is contained in a frame sent to a device on the internet.</p>&#13;
<div class="image" id="ch11fig13"><img src="../images/fig11-13.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 11-13: A frame containing an IP packet, a TCP segment, and application data</em></p>&#13;
<span epub:type="pagebreak" id="page_246"/>&#13;
<p class="indent">We’ve walked through the contents of a network frame from the bottom up, starting with the layer closest to hardware. When a frame is received by a host, it is processed by the host in that same order, from the link layer up to the application layer. In contrast, when a frame is sent from a host, the frame is assembled in the reverse order. A process prepares application data that is enclosed in a segment, a packet, and finally, a frame.</p>&#13;
<h3 class="h3" id="lev1_86"><strong>A Trip Through the Internet</strong></h3>&#13;
<p class="noindent">Now that you’re familiar with each of the four layers in the TCP/IP networking model, let’s look at an example of how data travels across the internet. We’ll see how various devices along the way interact with each of the networking layers. <a href="ch11.xhtml#ch11fig14">Figure 11-14</a> illustrates this, showing a client in the upper left communicating with a server in the lower left.</p>&#13;
<div class="image" id="ch11fig14"><img src="../images/fig11-14.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 11-14: Different devices interact at different layers of the networking stack</em></p>&#13;
<p class="indent">I’ll set up the scenario in <a href="ch11.xhtml#ch11fig14">Figure 11-14</a>. A client device (upper left of diagram) is connected to a wireless Wi-Fi network. That network is connected to the internet via a router. Somewhere else we have a server (lower left of diagram), which has a wired connection to the internet through a switch and router. A user of the client device opens a web browser and requests a web page hosted on the server. For simplicity, let’s assume that the client already knows the IP address of the server.</p>&#13;
<p class="indent">The web browser on the client “speaks” HTTP, the application layer protocol of the web, so it forms an HTTP request intended for the destination server. The browser then hands off the HTTP request to the operating system’s TCP/IP software stack, asking that the data be delivered to the server—specifically the server’s IP address and port 80, the standard port for HTTP. The TCP/IP software stack on the client operating system then encapsulates the HTTP payload in a TCP segment (transport layer), setting the destination <span epub:type="pagebreak" id="page_247"/>port to 80 in the segment header. If necessary, TCP divides the application layer data into multiple segments, each with its own header. The internet layer software on the client then wraps the TCP segment in an IP packet, which includes the destination IP address of the server in the packet header. If necessary, IP divides the packet into multiple smaller fragments in preparation for transmission over the network link. At the link layer on the client, the IP packet is encapsulated in a frame with the MAC address of the local router in its header. This frame is wirelessly transmitted by the client device’s Wi-Fi hardware.</p>&#13;
<p class="indent">The wireless access point receives the frame. The access point, operating at the link layer, sends the frame along to the router. The router examines the internet layer packet to determine the destination IP address. To reach the server, the request needs to travel through multiple routers on the internet. The local router encapsulates the packet in a new frame, with a new destination MAC address (the address of the next router), and sends the new frame on its way. This routing process continues through multiple routers on the internet until the request reaches the router on the subnet where the server is connected.</p>&#13;
<p class="indent">The last router encapsulates the packet in a frame suitable for the server’s local network. This frame’s header includes the MAC address of the server. The switch on the server’s subnet looks at the MAC address in the frame and forwards the frame out the appropriate physical port. There’s no need for the switch to look at any higher layers. The server receives the frame, and the driver for the network interface passes the TCP/IP packet up to the TCP/IP software stack, which in turn, hands off the HTTP data to the process listening on TCP port 80. Web server software, listening on port 80, handles the request. This includes replying to the client, and to do that, this entire process happens again, except in reverse order.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch11.xhtml#proj32">Project #32</a> on <a href="ch11.xhtml#page_258">page 258</a>, where you can see the route from your Raspberry Pi to a host on the internet</em>.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1_87"><strong>Foundational Internet Capabilities</strong></h3>&#13;
<p class="noindent">Whereas TCP/IP provides the necessary plumbing for reliable transfer of data across the internet, other protocols provide additional foundational internet capabilities. These features are implemented as application layer protocols. Let’s now look at two such protocols (DHCP and DNS) and a system for translating IP addresses (NAT).</p>&#13;
<h4 class="h4" id="lev2_35"><strong><em>Dynamic Host Configuration Protocol</em></strong></h4>&#13;
<p class="noindent">Every host on the internet needs an IP address, a subnet mask, and the IP address of its router (also called its <em>default gateway</em>) in order to communicate with other hosts. How are IP addresses assigned? A device can be given a <em>static IP address</em>, which requires someone to edit the configuration on the device and set its IP information manually. This is sometimes useful, but it requires the user to ensure that the IP address in question isn’t already <span epub:type="pagebreak" id="page_248"/>taken and is valid for the subnet. Most end users don’t have the expertise to manually configure the IP settings for their devices, nor do they want to deal with the hassle of manual configuration. Fortunately, most IP addresses are assigned dynamically using <em>Dynamic Host Configuration Protocol (DHCP)</em>. With DHCP, when a device connects to a network, it receives an IP address and related information without user intervention.</p>&#13;
<p class="indent">For DHCP to be available on a network, a device on the network must be configured as a <em>DHCP server</em>. This server has a pool of IP addresses that it’s allowed to assign to devices on the network. The flow of DHCP is illustrated in <a href="ch11.xhtml#ch11fig15">Figure 11-15</a>.</p>&#13;
<div class="image" id="ch11fig15"><img src="../images/fig11-15.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 11-15: A DHCP conversation</em></p>&#13;
<p class="indent">Let’s walk through <a href="ch11.xhtml#ch11fig15">Figure 11-15</a>. When a device connects to a network, it broadcasts a message to discover any DHCP servers. A <em>broadcast</em> is a special kind of packet that’s addressed to all hosts on the local network. When the DHCP server receives this broadcast, it offers an IP address to the client device. If the client wishes to accept the offered IP address, it replies to the server with a request for the offered address. The DHCP server then acknowledges the request, and the IP address is assigned to the client. The IP address is <em>leased</em> to the client, and it eventually expires if the client does not renew its lease.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch11.xhtml#proj33">Project #33</a> on <a href="ch11.xhtml#page_258">page 258</a>, where you can see the IP address your Raspberry Pi has leased using DHCP</em>.</p>&#13;
</div>&#13;
<h4 class="h4" id="lev2_36"><strong><em>Private IP Addresses and Network Address Translation</em></strong></h4>&#13;
<p class="noindent">The number of available IP addresses is limited, so most home internet service providers (ISPs) only assign a single IP address to a customer. This IP address is assigned to the device that’s directly attached to the ISP’s network, usually a router. However, many customers have multiple devices on their home network. Let’s look at how multiple devices can share a single public IP address by leveraging private IP addresses and Network Address Translation.</p>&#13;
<span epub:type="pagebreak" id="page_249"/>&#13;
<p class="indent">Certain ranges of IP addresses are considered <em>private IP addresses</em>, addresses intended to be used on <em>private networks</em>, such as those in homes or offices, where the devices aren’t directly connected to the internet. Any address that matches the pattern of 10.<em>x.x.x</em>, 172.16.<em>x.x</em>, or 192.168.<em>x.x</em> is a private IP address. Anyone can use these ranges of IP addresses without asking permission. The catch is that private IP addresses are nonroutable—they can’t be used on the public internet. A DHCP server on a home network can assign these addresses without worrying about whether any other network is using the same addresses. Unlike public IP addresses that must be unique, private IP addresses are intended to be used simultaneously on multiple private networks. It doesn’t matter if multiple networks use the same addresses, since the addresses won’t ever be seen outside of the private network anyway. Private IP addresses solve the problem of an ISP only providing a single public IP address to a home or business, but how are private IP addresses useful if they aren’t routable on the internet?</p>&#13;
<p class="indent"><em>Network Address Translation (NAT)</em> allows devices on a private network, often a home network, to all use the same public IP address on the internet. As packets flow through a NAT router, the router modifies the IP address information in those packets. When a packet originating from the private home network arrives at the NAT router, it modifies the source IP address field to match the public IP address, as shown in <a href="ch11.xhtml#ch11fig16">Figure 11-16</a>.</p>&#13;
<div class="image" id="ch11fig16"><img src="../images/fig11-16.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 11-16: A NAT router replaces private IP addresses with its own public IP address</em></p>&#13;
<p class="indent">When a response comes back to the router, it sets the destination IP address to the private address of the host that originated the request. In this way, all traffic from the home appears to originate from the same public IP address, even if there are actually multiple devices on the private network. NAT also has the side benefit of security: the devices on the private network aren’t directly exposed to the public internet, so a malicious user on the internet can’t initiate a connection directly to a private device. Most routers sold to consumers for home use are NAT routers, often with built-in wireless access point capabilities as well.</p>&#13;
<p class="indent">Private IP addresses are valuable not only for home networks, but also for businesses that don’t want their computers exposed to the public internet. Many corporate networks use a <em>proxy server</em> rather than a NAT router. A <span epub:type="pagebreak" id="page_250"/>proxy server is similar to a NAT router in that it allows devices on a private network to access the internet, but a proxy server differs in that it typically operates at the application layer rather than the internet layer. Proxies also usually provide additional features such as user authentication, traffic logging, and content filtering.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch11.xhtml#proj34">Project #34</a> on <a href="ch11.xhtml#page_259">page 259</a>, where you can see if the IP address your device is assigned is a public IP address or a private IP address</em>.</p>&#13;
</div>&#13;
<h4 class="h4" id="lev2_37"><strong><em>The Domain Name System</em></strong></h4>&#13;
<p class="noindent">We’ve seen that hosts on the internet are identified by IP addresses. However, most users of the internet rarely, if ever, directly deal with IP addresses. Although IP addresses work well for computers, they aren’t very user friendly. No one wants to remember sets of four numbers separated by periods. Fortunately, we have the <em>Domain Name System (DNS)</em> to make things easier for us. DNS is an internet service that maps names to IP addresses. This allows us to refer to a host by a name like <em>www.example.com</em> rather than by its IP address.</p>&#13;
<p class="indent">A computer’s full DNS name is known as a <em>fully qualified domain name</em>, or <em>FQDN</em>. A name like <em>travel.example.com</em> is an FQDN. This name is composed of a short, local <em>hostname (travel)</em> and a domain suffix <em>(example.com</em>). The term <em>hostname</em> is often used interchangeably to mean either the computer’s short name or the FQDN. Later in this section, we use <em>hostname</em> to mean a computer’s FQDN. A <em>domain</em>, like <em>example.com</em>, represents a grouping of network resources managed by an organization. Both <em>example.com</em> and <em>travel.example.com</em> are domain names. The former represents a network domain; the latter represents a specific host on that domain.</p>&#13;
<p class="indent">Software needs to be able to query DNS to convert hostnames to IP addresses—this is known as <em>resolving</em> a hostname. To enable this functionality, hosts are configured with a list of the IP addresses of DNS servers. This list is usually provided by DHCP, and it typically is composed of DNS servers maintained by the internet service provider or running on the local network. When a client wants to connect to a server by name, it asks a DNS server for the IP address corresponding to that name. The server replies with the requested IP address, if it can. This is illustrated in <a href="ch11.xhtml#ch11fig17">Figure 11-17</a>.</p>&#13;
<div class="image" id="ch11fig17"><img src="../images/fig11-17.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 11-17: A simplified DNS query. The IP address of</em> example.com <em>is not intended to be accurate</em>.</p>&#13;
<span epub:type="pagebreak" id="page_251"/>&#13;
<p class="indent">Once the client has the server’s IP, it proceeds to communicate with the server using the IP address, as described earlier. I’ve heard DNS described as the phone book of the internet, although that analogy may fall short for some readers since phone books aren’t as common as they once were!</p>&#13;
<p class="indent">You might assume that there’s a one-to-one mapping between IP addresses and names. That actually isn’t the case. A name can map to multiple IP addresses. In that scenario, different clients query DNS for a certain name, and they may all receive a different IP address as a response. This is useful for situations in which the load for a given service needs to be distributed across multiple servers. This can be done geographically, so that clients in Europe, for example, get a different IP address than clients in Asia, allowing clients in each region to connect to the IP address of a server that’s physically close to them.</p>&#13;
<p class="indent">The reverse is possible too: multiple names can map to the same IP address. In this scenario, a query for different names may return a single IP address. This is useful when a server hosts multiple instances of the same type of service, each identified by name. This is common in web hosting, where a single server hosts multiple websites, each identified by its DNS name.</p>&#13;
<p class="indent">Each entry in DNS is known as a <em>record</em>. There are various kinds of records; the most basic is an <em>A record</em>, which simply maps a hostname to an IP address. Other examples are <em>CNAME (canonical name)</em> records that map one hostname to another hostname, and <em>MX (mail exchanger)</em> records used for email services.</p>&#13;
<p class="indent">No single organization would want to undertake the task of managing the many, many DNS records that exist today. Fortunately, this isn’t needed; DNS is implemented in a way that allows for shared responsibility. A DNS name like <em>www.example.com</em> actually represents a hierarchy of records, and different DNS servers are responsible for maintaining the records at different levels of the hierarchy. The DNS hierarchy, as applied to <em>www.example.com</em>, is illustrated in <a href="ch11.xhtml#ch11fig18">Figure 11-18</a>.</p>&#13;
<div class="image" id="ch11fig18"><img src="../images/fig11-18.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 11-18: Example DNS hierarchy, highlighting</em> www.example.com</p>&#13;
<p class="indent">At the top of this hierarchical tree is the <em>root domain</em>. The root domain doesn’t get a textual representation in a DNS name like <em>www.example.com</em>, but it’s an essential part of the DNS hierarchy. The root domain contains <span epub:type="pagebreak" id="page_252"/>records for all the <em>top-level domains (TLDs)</em> like <em>.com</em>, <em>.org</em>, <em>.edu</em>, <em>.net</em>, and so forth. As of 2020, there are 13 root name servers worldwide, each responsible for knowing the details of all the top-level domain servers. Let’s say you want to look up a record in a domain that ends with <em>.com</em>. A root server can point you to a TLD server that knows about domains under <em>.com</em>.</p>&#13;
<p class="indent">A top-level DNS server is responsible for knowing about all the second-level domains under its hierarchy. A top-level DNS server for <em>.com</em> could point you to the second-level DNS server for <em>example.com</em>. The DNS servers for second-level domains maintain records for hosts and third-level domains that fall under second-level domains. This means that the DNS server(s) for <em>example.com</em> are responsible for maintaining the records for hosts like <em>www.example.com</em> and <em>mail.example.com</em>. This pattern continues, allowing for nested domains. Once a domain is registered under a top-level domain, the owner of that domain can create as many records as needed under their domain.</p>&#13;
<p class="indent">As mentioned earlier, when a computer needs to find the IP address for an FQDN, it sends a request to its configured DNS server. What does the DNS server do with this request? If the server has recently looked up the requested record, it may have a copy of that record stored in its cache, and it can immediately return the IP address to the client. If the DNS server doesn’t have the response in cache, it may query other DNS servers as needed to get the answer. This involves starting at the root and working down the hierarchy of servers to find the record in question. Once the server has the record, it can cache it so that it can immediately respond to future queries for that record. Eventually the cached record is removed to ensure that the server always provides reasonably recent data.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch11.xhtml#proj35">Project #35</a> on <a href="ch11.xhtml#page_260">page 260</a>, where you can look up information in DNS</em>.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1_88"><strong>Networking Is Computing</strong></h3>&#13;
<p class="noindent">Let’s take a moment to consider how the internet fits in with the broader picture of computing that we’ve already covered in this book. Networking may seem like a tangential topic, but really it isn’t so far removed from computing in general. The internet is composed of hardware and software working together to allow communication between devices. Data sent over the internet boils down to 0s and 1s, represented in various forms such as voltages on a wire. From the perspective of a computer, a networking interface like a Wi-Fi or Ethernet adapter is just another I/O device. An operating system interacts with such adapters via device drivers, and the OS includes software libraries that allow applications to easily communicate over the internet. Networking devices like routers and switches are computers too, although highly specialized ones. The internet, and networking in general, is an extension of local computing, allowing for data transfer and processing beyond the boundaries of a single device.</p>&#13;
<span epub:type="pagebreak" id="page_253"/>&#13;
<h3 class="h3" id="lev1_89"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter we covered the internet, a globally connected set of computer networks that all use a suite of common protocols. You learned about the four layers of the internet protocol suite—the link layer, the internet layer, the transport layer, and the application layer. You saw how data travels through the internet and how devices interact at various layers. You learned how DHCP provides networking configuration data, how NAT allows devices on private networks to connect to the internet, and how DNS provides friendly names that can be used in place of IP addresses. In the next chapter you’ll learn about the World Wide Web, a set of resources delivered by HTTP over the internet.</p>&#13;
<span epub:type="pagebreak" id="page_254"/>&#13;
<div class="sidebarp">&#13;
<p class="exercise" id="proj29"><strong><span class="black1">PROJECT #29: EXAMINE THE LINK LAYER</span></strong></p>&#13;
<p class="exercise-para">Prerequisite: A Raspberry Pi, running Raspberry Pi OS. I recommend that you flip to <a href="appb.xhtml">Appendix B</a> and read the entire “Raspberry Pi” section if you haven’t already.</p>&#13;
<p class="exercise-parai">In this project, you’ll use your Raspberry Pi to check out the link layer of your local network. Let’s start with the following command, which lists the MAC address of your Ethernet adapter:</p>&#13;
<p class="programs">$ <span class="codestrong1">ifconfig eth0 | grep ether</span></p>&#13;
<p class="exercise-parai">The output should look something like the following:</p>&#13;
<p class="programs">        ether b8:27:eb:12:34:56  txqueuelen 1000  (Ethernet)</p>&#13;
<p class="exercise-parai">In this example, the MAC address is <span class="literal">b8:27:eb:12:34:56</span>. That’s a hexadecimal representation of a 48-bit number. Remember, each hex character represents 4 bits, so that’s 12 characters × 4 bits = 48 bits.</p>&#13;
<p class="exercise-parai">The first 24 bits of a MAC address represent the vendor/manufacturer of the hardware. This number is known as an <em>organizationally unique identifier (OUI)</em> and is managed by the <em>Institute of Electrical and Electronics Engineers (IEEE)</em>. In this case the OUI is B827EB, which is assigned to the Raspberry Pi Foundation. You can see the current OUI listings here: <em><a href="http://standards-oui.ieee.org/oui.txt">http://standards-oui.ieee.org/oui.txt</a></em>.</p>&#13;
<p class="exercise-parai">Your Raspberry Pi’s Wi-Fi adapter has its own MAC address. View it like this:</p>&#13;
<p class="programs">$ <span class="codestrong1">ifconfig wlan0 | grep ether</span><br/>&#13;
        ether b8:27:eb:78:9a:bc  txqueuelen 1000  (Ethernet)</p>&#13;
<p class="exercise-parai">On my system, the OUI (the first 24 bits of the MAC address) of the Wi-Fi adapter is the same as the OUI of the Ethernet adapter. This is because both adapters are internal Raspberry Pi hardware and use the OUI for the Raspberry Pi Foundation.</p>&#13;
<p class="exercise-parai">From your Raspberry Pi, you can also see the MAC address of other devices on your local network. To do this you can use a tool called <span class="literal">arp-scan</span> that attempts to connect to every computer on your local network and retrieve its MAC address.</p>&#13;
<p class="exercise-parai">First, install the tool:</p>&#13;
<p class="programs">$ <span class="codestrong1">sudo apt-get install arp-scan</span></p>&#13;
<p class="exercise-parai">Then run this command (that’s a lowercase L at the end of the command, not the number 1):</p>&#13;
<p class="programs">$ <span class="codestrong1">sudo arp-scan -l</span></p>&#13;
<p class="exercise-parai">You should get a list of IP addresses (which we cover elsewhere in this chapter) and MAC addresses, plus a column that attempts to match the MAC prefix to the manufacturer. I got 10 results on my local network, some of which I didn’t immediately recognize. You may see some duplicate results returned, indicated with <span class="literal">DUP</span> in the third column. The returned list typically does not include the address of the computer from which you ran the scan.</p>&#13;
<span epub:type="pagebreak" id="page_255"/>&#13;
<p class="exercise-parai">You may have some results in the third column that show as <span class="literal">(Unknown)</span>. This means that the <span class="literal">arp-scan</span> tool wasn’t able to match the OUI number to a known manufacturer, probably because the tool is using an outdated version of the OUI list. You can try to fix this by downloading the current list of OUI numbers from IEEE and then running the scan again, like this:</p>&#13;
<p class="programs">$ <span class="codestrong1">get-oui</span><br/>&#13;
$ <span class="codestrong1">sudo arp-scan -l</span></p>&#13;
<p class="exercise-parai">When I see multiple devices on my home network that I can’t identify right away, I have an immediate urge to figure out what they are! As a bonus challenge for you, identify every device returned from <span class="literal">arp-scan</span>. Now, this may be impractical if you’re running this tool on a network you don’t control (say, at a coffee shop or library), but if you’re at home, this is something you can do. You’ll probably need to log on to each device on your network and dig through its settings to find its IP address or MAC address and see if it matches one of the entries returned from <span class="literal">arp-scan</span>. Hint: use the <span class="literal">ifconfig</span> utility on Linux or Mac, or the <span class="literal">ipconfig</span> tool on Windows. On mobile devices, look at the user interface for network settings.</p>&#13;
</div>&#13;
<div class="sidebarp">&#13;
<p class="exercise" id="proj30"><strong><span class="black1">PROJECT #30: EXAMINE THE INTERNET LAYER</span></strong></p>&#13;
<p class="exercise-para">Prerequisite: A Raspberry Pi, running Raspberry Pi OS.</p>&#13;
<p class="exercise-parai">In this project, you’ll look at the internet layer using your Raspberry Pi. Let’s begin with the following command, which lists all the network interfaces on your device and their associated IP addresses.</p>&#13;
<p class="programs">$ <span class="codestrong1">ifconfig</span></p>&#13;
<p class="exercise-parai">You’ll typically see three interfaces: <span class="literal">eth0</span>, <span class="literal">lo</span>, and <span class="literal">wlan0</span>. The <span class="literal">lo</span> interface is a special case; it’s the <em>loopback</em> interface. It’s used for processes running on the Pi that wish to communicate with each other using TCP/IP, but without actually sending any traffic over the network. That is, the traffic stays on the device. The loopback interface has an IP address of 127.0.0.1. This is a special address that is not routable and can’t be used as an address on the local subnet, because any attempt to deliver messages to that address results in the messages coming right back to the sending computer. In other words, every computer considers 127.0.0.1 to be its own IP address.</p>&#13;
<p class="exercise-parai">As we covered in the previous project, <span class="literal">eth0</span> is the wired Ethernet interface and <span class="literal">wlan0</span> is the wireless Wi-Fi interface. If you’re connected to a network on either or both of these interfaces, you should see an IP address beside the text <span class="literal">inet</span> in the <span class="literal">ifconfig</span> output. You may also see an IPv6 address listed beside <span class="literal">inet6</span>. Here’s example <span class="literal">wlan0</span> output from <span class="literal">ifconfig</span>:</p>&#13;
<p class="programs">wlan0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br/>&#13;
        inet 192.168.1.138  netmask 255.255.255.0  broadcast 192.168.1.255<br/>&#13;
        inet6 fe80::8923:91b2:13e0:ed2a  prefixlen 64  scopeid 0x20&lt;link&gt;</p>&#13;
<span epub:type="pagebreak" id="page_256"/>&#13;
<p class="exercise-parai">In this output you can see that the assigned IP address is <span class="literal">192.168.1.138</span>. The <span class="literal">netmask</span> value (subnet mask) is <span class="literal">255.255.255.0</span>, and the <span class="literal">broadcast</span> address is <span class="literal">192.168.1.255</span>.</p>&#13;
<p class="exercise-parai">The <span class="literal">ifconfig</span> command gives us information about the various network interfaces on the Raspberry Pi, but it doesn’t tell us about how routing is configured. Let’s take a look at that using the <span class="literal">ip route</span> command. I’ve included sample output here; your results may vary.</p>&#13;
<p class="programs">$ <span class="codestrong1">ip route</span><br/>&#13;
default via 192.168.1.1 dev wlan0 src 192.168.1.138 metric 303<br/>&#13;
192.168.1.0/24 dev wlan0 proto kernel scope link src 192.168.1.138 metric 303</p>&#13;
<p class="exercise-parai">This command’s output can be a little difficult to interpret. In short, the first line gives the default route. This is where packets should be sent when there isn’t a specific route that applies. In this particular example, every packet that doesn’t match a specific routing rule should be sent to <span class="literal">192.168.1.1</span>. That means that <span class="literal">192.168.1.1</span> is the IP address of the local router, also known as the <em>default gateway</em>.</p>&#13;
<p class="exercise-parai">The next line is a routing entry that tells you that any packet sent to an IP address in the range of <span class="literal">192.168.1.0/24</span> should be sent through device <span class="literal">wlan0</span>. That’s the Wi-Fi adapter on the local subnet. In other words, this routing rule ensures that communication with IP addresses on the local subnet happens directly, without going through a router.</p>&#13;
<p class="exercise-parai">To summarize, this output tells you that any packet sent to an IP address that matches <span class="literal">192.168.1.0/24</span> should be sent directly to the destination address via the <span class="literal">wlan0</span> interface. Any other traffic uses the default route, which sends traffic to the router at <span class="literal">192.168.1.1</span>. The end result is that local subnet traffic is sent directly to the target device, while traffic to devices on other subnets, likely on the internet, is sent to the default gateway.</p>&#13;
</div>&#13;
<div class="sidebarp">&#13;
<p class="exercise" id="proj31"><strong><span class="black1">PROJECT #31: EXAMINE PORT USAGE</span></strong></p>&#13;
<p class="exercise-para">Prerequisite: A Raspberry Pi, running Raspberry Pi OS.</p>&#13;
<p class="exercise-parai">In this project, you’ll see which network ports are in use on a Raspberry Pi. You’ll then examine ports on other computers. Let’s begin with the following command that shows you the listening and established TCP sockets on your Raspberry Pi.</p>&#13;
<p class="programs">$ <span class="codestrong1">netstat -nat</span></p>&#13;
<p class="exercise-parai">Let’s break down the <span class="literal">-nat</span> options used in the command. The <span class="literal">n</span> option indicates that numeric output should be used to show the port numbers. The <span class="literal">a</span> option means show all connections (both listening and established), and <span class="literal">t</span> means limit the output to TCP. On my device, I see a list like so:</p>&#13;
<p class="programs">Active Internet connections (servers and established)<br/>&#13;
Proto Recv-Q Send-Q Local Address           Foreign Address         State<br/>&#13;
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN<br/>&#13;
tcp        0     36 192.168.1.138:22         192.168.1.125:52654    ESTABLISHED<br/>&#13;
tcp        0      0 192.168.1.138:22         192.168.1.125:51778    ESTABLISHED<br/>&#13;
tcp6       0      0 :::22                   :::*                    LISTEN</p>&#13;
<span epub:type="pagebreak" id="page_257"/>&#13;
<p class="exercise-parai">Here you see four sockets, all related to SSH. I can tell they are related to SSH because all the sockets are using port <span class="literal">22</span>. I have SSH enabled on my Raspberry Pi to allow remote terminal connections. The first and last lines show that the Pi is listening on port <span class="literal">22</span> for new incoming SSH connections using both TCP and TCP over IPv6. The middle two lines show that I have two established SSH connections to this device, both of them from my laptop (with an IP of <span class="literal">192.168.1.125</span>) to the Pi (with an IP of <span class="literal">192.168.1.138</span>). Note how both the established connections go to the same server port on the Pi (<span class="literal">22</span>), whereas the client port on my laptop varies (<span class="literal">52654</span> and <span class="literal">51778</span>), as they are ephemeral ports.</p>&#13;
<p class="exercise-parai">Run the command again, this time adding the <span class="codestrong">p</span> option and prefixing the command with <span class="codestrong">sudo</span>:</p>&#13;
<p class="programs">$ <span class="codestrong1">sudo netstat -natp</span></p>&#13;
<p class="exercise-parai">This gives you the same list, but with the process ID (PID) and program name to which the socket belongs. Any traffic sent to the socket is directed to the PID, which handles the traffic and responds as needed. On my computer I see that the program using this port is <span class="literal">sshd</span>—the daemon for SSH.</p>&#13;
<p class="exercise-parai">Now that you’ve examined which ports are in use on your Raspberry Pi, let’s examine the ports on a remote computer. For this, you’ll use a tool called <span class="literal">nmap</span>, which must first be installed on your Raspberry Pi:</p>&#13;
<p class="programs">$ <span class="codestrong1">sudo apt-get install nmap</span></p>&#13;
<p class="exercise-parai">Once the tool is installed, select a target host that you wish to scan. This can be either a device on your network (say your router or a laptop) or a host on the internet. Note that repeatedly scanning a host that you don’t control may look suspicious to the administrators of that server, so I strongly recommend that you only scan devices that you own.</p>&#13;
<p class="exercise-parai">In my case, I decided to scan my default gateway, which happens to be at 192.168.1.1. The following <span class="literal">nmap</span> command scans for open TCP ports on the specified IP address. Try this on your Raspberry Pi, replacing the IP address with the address of the device you wish to scan. If you want to scan your own router, see <a href="ch11.xhtml#proj30">Project #30</a> for a reminder of how to get the IP address of your default gateway.</p>&#13;
<p class="programs">$ <span class="codestrong1">nmap -sT</span> <span class="codeitalic1">192.168.1.1</span></p>&#13;
<p class="exercise-parai">A partial listing of the results from my scan showed these ports:</p>&#13;
<p class="programs">PORT      STATE SERVICE<br/>&#13;
53/tcp    open  domain<br/>&#13;
80/tcp    open  http</p>&#13;
<p class="exercise-parai">This tells me that the device acts not only as a router, but as a DNS server (port <span class="literal">53</span>) and web server (port <span class="literal">80</span>). It’s normal for a home router to provide these services.</p>&#13;
</div>&#13;
<span epub:type="pagebreak" id="page_258"/>&#13;
<div class="sidebarp">&#13;
<p class="exercise" id="proj32"><strong><span class="black1">PROJECT #32: TRACE THE ROUTE TO A HOST ON THE INTERNET</span></strong></p>&#13;
<p class="exercise-para">Prerequisite: A Raspberry Pi, running Raspberry Pi OS.</p>&#13;
<p class="exercise-parai">In this project, you’ll examine the route a packet travels from your Raspberry Pi to a host on the internet. First, you need to choose a host on the internet. This can be a website like <em>www.example.com</em>, or the IP address or FQDN of any internet host you happen to know. Once you’ve decided on a host, enter the following command, replacing <em><span class="literal">www.example.com</span></em> with the name or IP address of the host you wish to see.</p>&#13;
<p class="programs">$ <span class="codestrong1">traceroute</span> <span class="codeitalic1">www.example.com</span></p>&#13;
<p class="exercise-parai">The <span class="literal">traceroute</span> tool attempts to show the routers that are encountered on a packet’s journey across the internet. The output should be read line by line. Each line is sequentially numbered and shows the name (if available) and IP address of the router encountered at that step of the packet’s trip. If there is no response after a short time, the output displays an asterisk (<span class="literal">*</span>) and moves on to the next router. You may also see more than one IP address per line, indicating multiple possible routes.</p>&#13;
</div>&#13;
<div class="sidebarp">&#13;
<p class="exercise" id="proj33"><strong><span class="black1">PROJECT #33: SEE YOUR LEASED IP ADDRESS</span></strong></p>&#13;
<p class="exercise-para">Prerequisite: A Raspberry Pi, running Raspberry Pi OS.</p>&#13;
<p class="exercise-parai">In this project, you’ll look at the lease information associated with your Raspberry Pi’s IP address obtained from a DHCP server. Of course, this assumes that your Raspberry Pi is configured to use DHCP (which is the default) rather than a static IP address. To do this, look at the system log:</p>&#13;
<p class="programs">$ <span class="codestrong1">cat /var/log/syslog | grep leased</span></p>&#13;
<p class="exercise-parai">Expect to see output similar to the following:</p>&#13;
<p class="programs">Jan 24 19:17:09 pi dhcpcd[341]: eth0: leased 192.168.1.104 for 604800 seconds</p>&#13;
<p class="exercise-parai">Here you can see that IP address <span class="literal">192.168.1.104</span> was leased from a DHCP server for use on network interface <span class="literal">eth0</span>, the Ethernet interface on the Raspberry Pi. Your output likely shows a different IP address and perhaps a different interface, maybe <span class="literal">wlan0</span>.</p>&#13;
<p class="exercise-parai">By default, the <em>syslog</em> file is periodically cleared, and its contents are moved to a backup file. Because of this, you may not see a DHCP entry in your <em>syslog</em> file. You can release your current IP address, request a new one, and look again for the lease entry like so:</p>&#13;
<p class="programs">$ <span class="codestrong1">sudo dhclient –r wlan0</span><br/>&#13;
$ <span class="codestrong1">sudo dhclient wlan0</span><br/>&#13;
$ <span class="codestrong1">cat /var/log/syslog | grep leased</span></p>&#13;
<p class="exercise-parai">Replace <span class="literal">wlan0</span> with <span class="literal">eth0</span> if you want to do this for Ethernet rather than Wi-Fi.</p>&#13;
</div>&#13;
<span epub:type="pagebreak" id="page_259"/>&#13;
<div class="sidebarp">&#13;
<p class="exercise" id="proj34"><strong><span class="black1">PROJECT #34: IS YOUR DEVICE’S IP PUBLIC OR PRIVATE?</span></strong></p>&#13;
<p class="exercise-para">Prerequisite: A Raspberry Pi, running Raspberry Pi OS.</p>&#13;
<p class="exercise-parai">In this project, you’ll see if the IP address of your Raspberry Pi is public or private. If your device has a private IP address, you’ll also find the public IP address that is used for your communication over the internet. As before, you can use the following utility to see your device’s assigned IP address(es).</p>&#13;
<p class="programs">$ <span class="codestrong1">ifconfig</span></p>&#13;
<p class="exercise-parai">When looking for your device’s assigned IP address, you’ll likely see an entry for 127.0.0.1; you can ignore this one since it’s used for loopback (see <a href="ch11.xhtml#proj30">Project #30</a>). As mentioned earlier, any address that matches the pattern of 10.<em>x.x.x</em>, 172.16.<em>x.x</em>, or 192.168.<em>x.x</em> is a private IP address. Now, even if you have a private IP address like one of these, when you access resources on the internet, you’re also indirectly making use of a public IP address. This is the address that websites or other internet services see when you connect to them. If you’re on a home network, that public IP address is likely assigned to your router. If you’re on a business network, that public IP address may be assigned to a proxy device on the edge of your corporate network. In either case, all the network traffic from inside your local network to the internet originates from that public address.</p>&#13;
<p class="exercise-parai">To find the public IP address that your device uses when connecting to a device on the internet, one option is to log on to your router or proxy server and check its network configuration. If you know how to query your router or proxy server for this information, feel free to do so. However, since every model of network device is somewhat different, I won’t walk you through the steps here.</p>&#13;
<p class="exercise-parai">A more universal option is to query an online service that can return your current public IP address. This is possible because every internet server that your device connects to knows your IP address; it’s simply a matter of finding a service that’s willing to tell you what IP address it sees. If you’re running a web browser on your device, perhaps the simplest thing to do is query Google for something like “my IP address.” This usually returns the information you want.</p>&#13;
<p class="exercise-parai">If you’re working from a terminal, like on the Raspberry Pi, you can use the <span class="literal">curl</span> utility to make an HTTP request to a website that returns your current IP address. The following are a few examples of services that are available for this at the time of this writing:</p>&#13;
<p class="programs">$ <span class="codestrong1">curl http://ipinfo.io/ip</span><br/>&#13;
$ <span class="codestrong1">curl http://checkip.amazonaws.com/</span><br/>&#13;
$ <span class="codestrong1">curl http://ipv4.icanhazip.com/</span><br/>&#13;
$ <span class="codestrong1">curl http://ifconfig.me/ip</span></p>&#13;
<p class="exercise-parai">Any of these should return your public IP address to the terminal window. Compare this address with the address you got earlier from <span class="literal">ifconfig</span>. If they are the same, then your device is directly assigned a public IP address. If they differ, then your device likely has a private IP assigned to it, and you’re connecting to the internet through a NAT router or proxy server.</p>&#13;
</div>&#13;
<span epub:type="pagebreak" id="page_260"/>&#13;
<div class="sidebarp">&#13;
<p class="exercise" id="proj35"><strong><span class="black1">PROJECT #35: FIND INFORMATION IN DNS</span></strong></p>&#13;
<p class="exercise-para">Prerequisite: A Raspberry Pi, running Raspberry Pi OS.</p>&#13;
<p class="exercise-parai">In this project, you’ll use your Raspberry Pi to query DNS records. Let’s begin by looking up the IP address of a website. You’ll use the <span class="literal">host</span> utility to do this. The following command returns the IP address of <em><span class="literal">www.example.com</span></em>, the hostname of the site I’m interested in. Feel free to substitute the name of another host you wish to look up.</p>&#13;
<p class="programs">$ <span class="codestrong1">host</span> <span class="codeitalic1">www.example.com</span></p>&#13;
<p class="exercise-parai">You should see output that gives the IP address of the host. You may also see an IPv6 address. Depending on the hostname you queried, you may get back multiple records, since a DNS name can map to multiple IP addresses. You may also learn that the name you typed is actually an alias for a different name, which in turn maps to an IP address.</p>&#13;
<p class="exercise-parai">DNS also allows for reverse lookups, where you specify an IP address and a hostname is returned. This doesn’t always work, since DNS records need to be in place to support it. To give this a try, just use <span class="literal">host</span> with an IP address. In the following command, replace <em><span class="literal">a.b.c.d</span></em> with your public IP address that you found in <a href="ch11.xhtml#proj34">Project #34</a>, or any other public IP address you wish to query. Again, this works only for IP addresses that have DNS records in place to support reverse lookups.</p>&#13;
<p class="programs">$ <span class="codestrong1">host</span> <span class="codeitalic1">a.b.c.d</span></p>&#13;
<p class="exercise-parai">By default, the <span class="literal">host</span> utility uses the DNS server your device is configured to use. You may also query a specific DNS server using <span class="literal">host</span> by specifying the IP address of that server. Internet service providers include DNS services for their customers, but many free alternate DNS services are available as well. For example, at the time of this writing, Google provides a DNS server at 8.8.8.8 and Cloudflare provides a DNS server at 1.1.1.1. If you want to use the DNS server at 1.1.1.1 to look up <em>www.example.com</em>, you could enter this:</p>&#13;
<p class="programs">$ <span class="codestrong1">host</span> <span class="codeitalic1">www.example.com</span> <span class="codestrong1">1.1.1.1</span></p>&#13;
<p class="exercise-parai">This should output IP address information as before, along with some text indicating which DNS server was used for the lookup.</p>&#13;
<p class="exercise-parai">If you’re curious about the details of the DNS query, you can use the <span class="literal">-v</span> option with the host command, which provides verbose output.</p>&#13;
<p class="programs">$ <span class="codestrong1">host -v</span> <span class="codeitalic1">www.example.com</span></p>&#13;
</div>&#13;
</body></html>