["```\nand( %1_1111_1111_1111_0000_0000_0000, eax );\n```", "```\nand( %1_1111_1111_1111_0000_0000_0000, eax );\n  cmp( eax, %1_0010_1111_0011_0000_0000_0000 );\n```", "```\nand( %1_1111_1111_1111_0000_0000_0000, eax );\n  cmp( eax, $12F3 << 12 );  // \"<<12\" shifts $12F3 to the left 12 bits.\n```", "```\nand( %1_1111_1111_1111_0000_0000_0000, eax );\n     shr( 12, eax );\n     cmp( eax, $12F3 );\n     << Other operations that require the bit string at bit #0 >>\n```", "```\nand( $1FFF, eax );      // Strip all but bits 0..12 from eax.\n     and( $FE00_0FFF, ebx ); // Clear bits 12..24 in ebx.\n     shl( 12, eax );         // Move bits 0..12 to 12..24 in eax.\n     or( eax, ebx );         // Merge the bits into ebx.\n```", "```\nconst\n     StartPosn := 12;\n     BitMask: dword := $1FFF << StartPosn; // Mask occupies bits 12..24.\n          .\n          .\n          .\n          shl( StartPosn, eax );  // Move into position.\n          and( BitMask, eax );    // Strip all but bits 12..24 from eax.\n          and( !BitMask, ebx );   // Clear bits 12..24 in ebx.\n          or( eax, ebx );         // Merge the bits into ebx.\n```", "```\ntest( %1_0000, eax ); // Check bit #4 to see if it is 0/1.\n     if( @nz ) then\n\n          << Do this if the bit is set. >>\n\n     else\n\n          << Do this if the bit is clear. >>\n\n     endif;\n```", "```\ntest( %1001_0110, eax );\n     if( @nz ) then // At least one of the bits is set.\n\n          << Do whatever needs to be done if one of the bits is set. >>\n\n     endif;\n```", "```\nand( bitMask, eax );\n     cmp( eax, bitMask );\n     if( @e ) then\n\n          // All the bit positions in eax corresponding to the set\n          // bits in bitMask are equal to 1 if we get here.\n\n          << Do whatever needs to be done if the bits match. >>\n\n     endif;\n```", "```\nnot( eax );\n test( bitMask, eax );\n if( @z ) then\n   // At this point, eax contained all ones in the bit positions\n   // occupied by ones in the bitMask constant.\n\n   << Do whatever needs to be done at this point. >>\n\n endif;\n```", "```\nbt*`x`*( *`BitNumber`*, *`BitsToTest`* );\nbt*`x`*( *`reg16`*, *`reg16`* );\nbt*`x`*( *`reg32`*, *`reg32`* );\nbt*`x`*( *`constant`*, *`reg16`* );\nbt*`x`*( *`constant`*, *`reg32`* );\nbt*`x`*( *`reg16`*, *`mem16`* );\nbt*`x`*( *`reg32`*, *`mem32`* );\nbt*`x`*( *`constant`*, *`mem16`* );\nbt*`x`*( *`constant`*, *`mem32`* );\n```", "```\nshl( 5, bx );\n     and( %111111000011111, ax );\n     or( bx, ax );\n```", "```\nreadonly\n     // The index into the following table specifies the length\n     // of the bit string at each position:\n\n     MaskByLen: dword[ 33 ] :=\n           [\n               0,  $1,  $3,  $7, $f, $1f, $3f, $7f,\n               $ff, $1ff, $3ff, $7ff, $fff, $1fff, $3fff, $7fff, $ffff,\n               $1_ffff, $3_ffff, $7_ffff, $f_ffff,\n               $1f_ffff, $3f_ffff, $7f_ffff, $ff_ffff,\n               $1ff_ffff, $3ff_ffff, $7ff_ffff, $fff_ffff,\n               $1fff_ffff, $3fff_ffff, $7fff_ffff, $ffff_ffff\n          ];\n               .\n               .\n               .\n     movzx( *`Length`*, edx );\n     mov( MaskByLen[ edx*4 ], edx );\n     mov( *`StartingPosition`*, cl );\n     shl( cl, edx );\n     not( edx );\n     shl( cl, ebx );\n     and( edx, eax );\n     or( ebx, eax );\n```", "```\nmov( ebx, eax );            // Copy data to destination.\n     and( %1_1110_0000, eax );   // Strip unwanted bits.\n     shr( 5, eax );              // Right justify to bit position 0.\n```", "```\nmovzx( *`Length`*, edx );\n     mov( MaskByLen[ edx*4 ], edx );\n     mov( *`StartingPosition`*, cl );\n     mov( ebx, eax );\n     shr( cl, eax );\n     and( edx, eax );\n```", "```\nand( !%1111_0001_0000_0000_0000, ebx );// Mask out destination bits.\n shl( 12, eax );                        // Move source bits into position.\n or( eax, ebx );                        // Merge the bit set into ebx.\n```", "```\nand( !%1111_0001_0000_0000_0000, ebx );\n shl( 3, eax );   // Spread out the bits: 1-4 goes to 4-7 and 0 to 3.\n btr( 3, eax );   // Bit 3->carry and then clear bit 3.\n rcl( 12, eax );  // Shift in carry and put bits into final position.\n or( eax, ebx );  // Merge the bit set into ebx.\n```", "```\nmov( ebx, eax );\n and( %1111_0001_0000_0000_0000, eax );  // Strip unwanted bits.\n shr( 5, eax );                          // Put bit 12 into bit 7, etc.\n shr( 3, ah );                           // Move bits 11..14 to 8..11.\n shr( 7, eax );                          // Move down to bit 0.\n```", "```\n// eax- Originally contains some value into which we\n//        insert bits from ebx.\n// ebx- L.O. bits contain the values to insert into eax.\n// edx- Bitmap with ones indicating the bit positions in eax to insert.\n// cl-  Scratchpad register.\n\n          mov( 32, cl );   // Count number of bits we rotate.\n          jmp DistLoop;\n\nCopyToEAX:rcr( 1, ebx );   // Don't use SHR here, must preserve Z-flag.\n          rcr( 1, eax );\n          jz  Done;\nDistLoop: dec( cl );\n          shr( 1, edx );\n          jc CopyToEAX;\n          ror( 1, eax );   // Keep current bit in eax.\n          jnz DistLoop;\n\nDone:     ror( cl, eax );  // Reposition remaining bits.\n```", "```\n// eax- Destination register.\n// ebx- Source register.\n// edx- Bitmap with ones representing bits to copy to eax.\n// ebx and edx are not preserved.\n     sub( eax, eax );  // Clear destination register.\n     jmp ShiftLoop;\n\nShiftInEAX:\n     rcl( 1, ebx );   // Up here we need to copy a bit from\n     rcl( 1, eax );   // ebx to eax.\nShiftLoop:\n     shl( 1, edx );   // Check mask to see if we need to copy a bit.\n     jc ShiftInEAX;   // If carry set, go copy the bit.\n     rcl( 1, ebx );   // Current bit is uninteresting, skip it.\n     jnz ShiftLoop;   // Repeat as long as there are bits in edx.\n```", "```\n*`Element_Address_in_bits`* =\n        *`Base_address_in_bits`* + *`index`* * *`element_size_in_bits`*\n```", "```\n*`Byte_of_1st_bit`* =\n    *`Base_Address`* + (*`index`* * *`element_size_in_bits`* )/8\n\n*`Offset_to_1st_bit`* =\n    (*`index`* * *`element_size_in_bits`*) % 8 (note \"%\" = MOD)\n```", "```\nstatic\n     AO3Bobjects: byte[ int32((200*3)/8 + 2) ];  // \"+2\" handles\n                                                 // truncation.\n```", "```\n// Extract the ith group of 3 bits in AO3Bobjects\n// and leave this value in eax.\n\n    sub( ecx, ecx );         // Put i/8 remainder here.\n    mov( i, eax );           // Get the index into the array.\n    lea( eax, [eax+eax*2] ); // eax := eax * 3 (3 bits/element).\n    shrd( 3, eax, ecx );     // eax/8 -> eax and eax mod 8 -> ecx\n                             // (H.O. bits).\n    shr( 3, eax );           // Remember, shrd doesn't modify eax.\n    rol( 3, ecx );           // Put remainder into L.O. 3\n                             // bits of ecx.\n\n    // Okay, fetch the word containing the 3 bits we want to\n    // extract. We have to fetch a word because the last bit or two\n    // could wind up crossing the byte boundary (i.e., bit offset 6\n    // and 7 in the byte).\n\n    mov( (type word AO3Bobjects[eax]), ax );\n    shr( cl, ax );           // Move bits down to bit 0.\n    and( %111, eax );        // Remove the other bits.\n```", "```\n// Insert the L.O. 3 bits of ax into the ith element\n// of AO3Bobjects:\n\nreadonly\n     Masks:\n        word[8] :=\n        [\n            !%0111,             !%0011_1000,\n            !%0001_1100_0000,   !%1110,\n            !%0111_0000,        !%0011_1000_0000,\n            !%0001_1100,        !%1110_0000\n        ];\n                    .\n                    .\n                    .\n\n        mov( i, ebx );              // Get the index into the array.\n        mov( ebx, ecx );            // Use L.O. 3 bits as index\n        and( %111, ecx );           // into Masks table.\n        mov( Masks[ecx*2], dx );    // Get bit mask.\n\n        // Convert index into the array into a bit index.\n        // To do this, multiply the index by 3:\n\n        lea( ebx, [ebx+ebx*2]);\n\n        // Divide by 8 to get the byte index into ebx\n        // and the bit index (the remainder) into ecx:\n\n        shrd( 3,ebx, ecx );\n        shr( 3, ebx );\n        rol( 3, ecx );\n\n        // Grab the bits and clear those we're inserting.\n\n        and( (type word AO3Bobjects[ ebx ]), dx );\n\n        // Put our 3 bits in their proper location.\n\n        shl( cl, ax );\n\n        // Merge bits into destination.\n\n        or( ax, dx );\n\n        // Store back into memory.\n\n        mov( dx, (type word AO3Bobjects[ ebx ]) );\n```", "```\nmov( −32, ecx );  // Count off the bit positions in ecx.\nTstLp:    shr( 1, eax );    // Check to see if current bit\n                            // position contains a 1.\n          jc Done;          // Exit loop if it does.\n          inc( ecx );       // Bump up our bit counter by 1.\n          jnz TstLp;        // Exit if we execute this loop 32 times.\n\nDone:     add( 32, cl );    // Adjust loop counter so it holds\n                            // the bit position.\n\n// At this point, ecx contains the bit position of the first set bit.\n// ecx contains 32 if eax originally contained 0 (no set bits).\n```", "```\nbsr( *`source`*, *`destReg`* );\n          bsf( *`source`*, *`destReg`* );\n```", "```\nmov( *`SomeValue`*, ebx );  // Value whose bits we want to check.\n      bsf( ebx, eax );        // Put position of first set bit in eax.\n      jz *`NoBitsSet`*;           // Branch if *`SomeValue`* contains 0.\n      mov( eax, *`FirstBit`* );   // Save location of first set bit.\n                .\n                .\n                .\n```", "```\nbsf( eax, ecx );       // Locate first set bit in eax.\n          if( @nz ) then         // If we found a bit, clear it.\n\n               btr( ecx, eax );  // Clear the bit we just found.\n\n          endif;\n```", "```\n// BitCount1:\n//\n// Counts the bits in the eax register, returning the count in ebx.\n\n          mov( 32, cl );   // Count the 32 bits in eax.\n          sub( ebx, ebx ); // Accumulate the count here.\nCntLoop:  shr( 1, eax );   // Shift next bit out of eax and into Carry.\n          adc( 0, bl );    // Add the carry into the ebx register.\n          dec( cl );       // Repeat 32 times.\n          jnz CntLoop;\n```", "```\n// bitCount\n     //\n     //  Counts the number of \"1\" bits in a dword value.\n     //  This function returns the dword count value in eax.\n\n     procedure bitCount( BitsToCnt:dword ); @nodisplay;\n\n     const\n          EveryOtherBit        := $5555_5555;\n          EveryAlternatePair   := $3333_3333;\n          EvenNibbles          := $0f0f_0f0f;\n\n     begin bitCount;\n\n          push( edx );\n          mov( BitsToCnt, eax );\n          mov( eax, edx );\n\n          // Compute sum of each pair of bits\n          // in eax. The algorithm treats\n          // each pair of bits in eax as a\n          // 2-bit number and calculates the\n          // number of bits as follows (description\n          // is for bits 0 and 1, it generalizes\n          // to each pair):\n          //\n          // edx =   Bit1 Bit0\n          // eax = 0 Bit1\n          //\n          // edx-eax =   00 if both bits were 0.\n          // 01 if Bit0=1 and Bit1=0.\n          // 01 if Bit0=0 and Bit1=1.\n          // 10 if Bit0=1 and Bit1=1.\n          //\n          // Note that the result is left in edx.\n\n          shr( 1, eax );\n          and( EveryOtherBit, eax );\n          sub( eax, edx );\n\n          // Now sum up the groups of 2 bits to\n          // produces sums of 4 bits. This works\n          // as follows:\n          //\n          // edx = bits 2,3, 6,7, 10,11, 14,15, ..., 30,31\n          // in bit positions 0,1, 4,5, ..., 28,29 with\n          // zeros in the other positions.\n          //\n          // eax = bits 0,1, 4,5, 8,9, ... 28,29 with zeros\n          // in the other positions.\n          //\n          // edx+eax produces the sums of these pairs of bits.\n\n          // The sums consume bits 0,1,2, 4,5,6, 8,9,10, ... 28,29,30\n          // in eax with the remaining bits all containing 0.\n\n          mov( edx, eax );\n          shr( 2, edx );\n          and( EveryAlternatePair, eax );\n          and( EveryAlternatePair, edx );\n          add( edx, eax );\n\n          // Now compute the sums of the even and odd nibbles in the\n          // number. Because bits 3, 7, 11, etc. in eax all contain\n          // 0 from the above calculation, we don't need to AND\n          // anything first, just shift and add the two values.\n          // This computes the sum of the bits in the 4 bytes\n          // as four separate values in eax (al contains number of\n          // bits in original al, ah contains number of bits in\n          // original ah, etc.)\n\n          mov( eax, edx );\n          shr( 4, eax );\n          add( edx, eax );\n          and( EvenNibbles, eax );\n\n          // Now for the tricky part.\n          // We want to compute the sum of the 4 bytes\n          // and return the result in eax. The following\n          // multiplication achieves this. It works\n          // as follows:\n          // (1) the $01 component leaves bits 24..31\n          //     in bits 24..31.\n          //\n          // (2) the $100 component adds bits 17..23\n          //     into bits 24..31.\n          //\n          // (3) the $1_0000 component adds bits 8..15\n          //     into bits 24..31.\n          //\n          // (4) the $1000_0000 component adds bits 0..7\n          //     into bits 24..31.\n          //\n          // Bits 0..23 are filled with garbage, but bits\n          // 24..31 contain the actual sum of the bits\n          // in eax's original value. The shr instruction\n          // moves this value into bits 0..7 and zeros\n          // out the H.O. bits of eax.\n\n          intmul( $0101_0101, eax );\n          shr( 24, eax );\n\n          pop( edx );\n\n     end bitCount;\n```", "```\n// Reverse the 32-bits in eax, leaving the result in ebx:\n\n               mov( 32, cl );\nRvsLoop:       shr( 1, eax );  // Move current bit in eax to\n                               // the carry flag.\n               rcl( 1, ebx );  // Shift the bit back into\n                               // ebx, backwards.\n               dec( cl );\n               jnz RvsLoop;\n```", "```\nmov( eax, edx );         // Make a copy of the odd bits.\n     shr( 1, eax );           // Move even bits to the odd positions.\n     and( $5555_5555, edx );  // Isolate the odd bits.\n     and( $5555_5555, eax );  // Isolate the even bits.\n     shl( 1, edx );           // Move odd bits to even positions.\n     or( edx, eax );          // Merge the bits and complete the swap.\n```", "```\nmov( eax, edx );  // Make a copy of the odd-numbered bit pairs.\n     shr( 2, eax );    // Move the even bit pairs to the odd position.\n     and( $3333_3333, edx ); // Isolate the odd pairs.\n     and( $3333_3333, eax ); // Isolate the even pairs.\n     shl( 2, edx );    // Move the odd pairs to the even positions.\n     or( edx, eax );   // Merge the bits and complete the swap.\n```", "```\nmov( eax, edx );  // Make a copy of the odd-numbered nibbles.\n     shr( 4, eax );    // Move the even nibbles to the odd position.\n     and( $0f0f_0f0f, edx );  // Isolate the odd nibbles.\n     and( $0f0f_0f0f, eax );  // Isolate the even nibbles.\n     shl( 4, edx );    // Move the odd pairs to the even positions.\n     or( edx, eax );   // Merge the bits and complete the swap.\n```", "```\nbswap( *`reg32`* );\n```", "```\nmov( eax, edx );    // Make a copy of the odd bits in the data.\n shr( 1, eax );      // Move the even bits to the odd positions.\n and( $5555_5555, edx ); // Isolate the odd bits.\n and( $5555_5555, eax ); // Isolate the even bits.\n shl( 1, edx );      // Move the odd bits to the even positions.\n or( edx, eax );     // Merge the bits and complete the swap.\n\n mov( eax, edx );    // Make a copy of the odd numbered bit pairs.\n shr( 2, eax );      // Move the even bit pairs to the odd position.\n and( $3333_3333, edx ); // Isolate the odd pairs.\n and( $3333_3333, eax ); // Isolate the even pairs.\n shl( 2, edx );      // Move the odd pairs to the even positions.\n or( edx, eax );     // Merge the bits and complete the swap.\n\n mov( eax, edx );   // Make a copy of the odd numbered nibbles.\n shr( 4, eax );     // Move the even nibbles to the odd position.\n and( $0f0f_0f0f, edx ); // Isolate the odd nibbles.\n and( $0f0f_0f0f, eax ); // Isolate the even nibbles.\n shl( 4, edx );     // Move the odd pairs to the even positions.\n or( edx, eax );    // Merge the bits and complete the swap.\n\n bswap( eax );      // Swap the bytes and words.\n```", "```\n// Merge two 16-bit strings into a single 32-bit string.\n// ax - Source for even numbered bits.\n// bx - Source for odd numbered bits.\n// cl - Scratch register.\n// edx- Destination register.\n\n          mov( 16, cl );\nMergeLp:  shrd( 1, eax, edx );     // Shift a bit from eax into edx.\n          shrd( 1, ebx, edx );     // Shift a bit from ebx into edx.\n          dec( cl );\n          jne MergeLp;\n```", "```\nshrd( 6, eax, edx );\n          shrd( 5, ebx, edx );\n          shrd( 6, eax, edx );\n          shrd( 11, ebx, edx );\n          shrd( 4, eax, edx );\n```", "```\nmov( 16, cl );   // Count the loop iterations.\nExtractLp: shr( 1, eax );   // Extract even bits to (e)bx.\n           rcr( 1, ebx );\n           shr( 1, eax );   // Extract odd bits to (e)dx.\n           rcr( 1, edx );\n           dec( cl );       // Repeat 16 times.\n           jnz ExtractLp;\n           shr( 16, ebx );  // Need to move the results from the H.O.\n           shr( 16, edx );  // bytes of ebx/edx to the L.O. bytes.\n```", "```\n// Swap bits at positions (1,2), (5,6), (9,10), (13,14), (17,18),\n// (21,22), (25,26), and (29, 30).\n\n     mov( eax, edx );\n     and( $9999_9999, eax );  // Mask out the bits we'll keep for now.\n     mov( edx, ecx );\n     shr( 1, edx );           // Move 1st bits in tuple above to the\n     and( $2222_2222, ecx );  // correct position and mask out the\n     and( $2222_2222, edx );  // unneeded bits.\n     shl( 1, ecx );           // Move 2nd bits in tuples above.\n     or( edx, ecx );          // Merge all the bits back together.\n     or( ecx, eax );\n\n// Swap bit pairs at positions ((2,3), (4,5)),\n// ((10,11), (12,13)), etc.\n\n     mov( eax, edx );\n     and( $c3c3_c3c3, eax ); // The bits we'll leave alone.\n     mov( edx, ecx );\n     shr( 2, edx );\n     and( $0c0c_0c0c, ecx );\n     and( $0c0c_0c0c, edx );\n     shl( 2, ecx );\n     or( edx, ecx );\n     or( ecx, eax );\n\n// Swap nibbles at nibble positions (1,2), (5,6), (9,10), etc.\n\n     mov( eax, edx );\n     and( $f00f_f00f, eax );\n     mov( edx, ecx );\n     shr(4, edx );\n     and( $0f0f_0f0f, ecx );\n     and( $0f0f_0f0f, ecx );\n     shl( 4, ecx );\n     or( edx, ecx );\n     or( ecx, eax );\n\n// Swap bits at positions 1 and 2.\n\n     ror( 8, eax );\n     xchg( al, ah );\n     rol( 8, eax );\n```", "```\nmov( 28, cl );      // 28 attempts because 32−4 = 28\n                              // (len(src) - len(pat)).\n          mov( %1111, ch );   // Mask for the comparison.\n          mov( *`pattern`*, al ); // Pattern to search for.\n          and( ch, al );      // Mask unnecessary bits in al.\n          mov( *`source`*, ebx ); // Get the source value.\nScanLp:   mov( bl, dl );      // Copy the L.O. 4 bits of ebx\n          and( ch, dl );      // Mask unwanted bits.\n          cmp( dl, al );      // See if we match the pattern.\n          jz Matched;\n          dec( cl );          // Repeat the specified number of times.\n          shl( 1, ebx );\n          jnz ScanLp;\n\n// Do whatever needs to be done if we failed to match the bit string.\n\n          jmp Done;\n\nMatched:\n\n// If we get to this point, we matched the bit string. We can compute\n// the position in the original source as 28-cl.\n\nDone:\n```", "```\nprocedure bits.cnt( b:dword ); @returns( \"eax\" );\n```", "```\n// Compute the number of bits in a 16-bit register:\n\n     pushw( 0 );\n     push( ax );\n     call bits.cnt;\n\n// If you prefer to use a higher-level syntax, try the following:\n\n     bits.cnt( #{ pushw(0); push(ax); }# );\n\n// Compute the number of bits in a 16-bit memory location:\n\n     pushw( 0 );\n     push( *`mem16`* );\n     call bits.cnt;\n```", "```\nprocedure bits.distribute( source:dword; mask:dword; dest:dword );\n     @returns( \"eax\" );\n```", "```\nprocedure bits.coalesce( source:dword; mask:dword );\n     @returns( \"eax\" );\n```", "```\nprocedure bits.extract( var d:dword );\n     @returns( \"eax\" ); // Really a macro.\n```", "```\nprocedure bits.reverse32( d:dword ); @returns( \"eax\" );\nprocedure bits.reverse16( w:word ); @returns( \"ax\" );\nprocedure bits.reverse8( b:byte ); @returns( \"al\" );\n```", "```\nprocedure bits.merge32( even:dword; odd:dword ); @returns( \"edx:eax\" );\nprocedure bits.merge16( even:word; odd:word ); @returns( \"eax\" );\nprocedure bits.merge8( even:byte; odd:byte ); @returns( \"ax\" );\n```", "```\nprocedure bits.nibbles32( d:dword ); @returns( \"edx:eax\" );\nprocedure bits.nibbles16( w:word ); @returns( \"eax\" );\nprocedure bits.nibbles8( b:byte ); @returns( \"ax\" );\n```"]