- en: '**LEDS**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blinking an LED**
  prefs: []
  type: TYPE_NORMAL
- en: In this first project, you’ll connect an LED to your Pi and make it blink with
    a python script. Learning how to blink an LED using the GPIO pins is an important
    step in your Pi education; once you know how to control an LED, you can control
    practically any output, whether it’s a motor, a lamp, or even a toaster.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0037-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: Breadboard
  prefs: []
  type: TYPE_NORMAL
- en: 5 mm LED
  prefs: []
  type: TYPE_NORMAL
- en: 330 Ω resistor
  prefs: []
  type: TYPE_NORMAL
- en: Jumper wires
  prefs: []
  type: TYPE_NORMAL
- en: '**INTRODUCING THE GPIO PINS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *General Purpose Input/Output (GPIO)* pins allow you to connect electronic
    hardware, like LEDs and sensors, to your Pi. They can be used to both read and
    send information, allowing your Pi to interact with the real world.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi 3 Model B board has a double row of 40 GPIO pins, shown in
    [Figure 1-1](ch01.xhtml#ch01fig1). This layout is the same for the Pi 2 Model
    B and Pi 1 Model B+, but slightly different from the Pi 1 Model A and B, which
    have only the first 26 pins. Check the [“Raspberry Pi GPIO Pin Guide”](app01.xhtml#app01)
    on [page 261](app01.xhtml#page_261) if you’re using a board other than the Raspberry
    Pi 3 Model B.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0038-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 1-1:** Raspberry Pi GPIO layout'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to refer to a GPIO pin: its name (which is known as GPIO
    numbering or Broadcom numbering) or by its corresponding pin number (which is
    known as physical numbering). For example, GPIO 25 corresponds to pin 22\. Throughout
    this book, we''ll refer to GPIO pins by their names. GPIO pins can be set to HIGH,
    which outputs 3.3 V and turns a component on, or LOW, which outputs 0 V and turns
    the component off.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **FUNCTION** | **NAME** | **NUMBER** | **NUMBER** | **NAME** | **FUNCTION**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| DC power | 3.3 V | 1 | 2 | 5 V | DC power |'
  prefs: []
  type: TYPE_TB
- en: '| SDA1, I²C | GPIO 2 | 3 | 4 | 5 V | DC power |'
  prefs: []
  type: TYPE_TB
- en: '| SCL1, I²C | GPIO 3 | 5 | 6 | GND |  |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO_GCLK | GPIO 4 | 7 | 8 | GPIO 14 | TXD0 |'
  prefs: []
  type: TYPE_TB
- en: '|  | GND | 9 | 10 | GPIO 15 | RXD0 |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO_GEN0 | GPIO 17 | 11 | 12 | GPIO 18 | GPIO_GEN1 |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO_GEN2 | GPIO 27 | 13 | 14 | GND |  |'
  prefs: []
  type: TYPE_TB
- en: '| GPIO_GEN3 | GPIO 22 | 15 | 16 | GPIO 23 | GPIO_GEN4 |'
  prefs: []
  type: TYPE_TB
- en: '| **FUNCTION** | **NAME** | **NUMBER** | **NUMBER** | **NAME** | **FUNCTION**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| DC power | 3.3 V | 17 | 18 | GPIO 24 | GPIO_GEN5 |'
  prefs: []
  type: TYPE_TB
- en: '| SPI_MOSI | GPIO 10 | 19 | 20 | GND |  |'
  prefs: []
  type: TYPE_TB
- en: '| SPI_MISO | GPIO 9 | 21 | 22 | GPIO 25 | GPIO_GEN6 |'
  prefs: []
  type: TYPE_TB
- en: '| SPI_CLK | GPIO 11 | 23 | 24 | GPIO 8 | SPI_CE0_N |'
  prefs: []
  type: TYPE_TB
- en: '|  | GND | 25 | 26 | GPIO 7 | SPI_CE1_N |'
  prefs: []
  type: TYPE_TB
- en: '| I²C ID EEPROM | DNC | 27 | 28 | DNC | I²C ID EEPROM |'
  prefs: []
  type: TYPE_TB
- en: '|  | GPIO 5 | 29 | 30 | GND |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | GPIO 6 | 31 | 32 | GPIO 12 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | GPIO 13 | 33 | 34 | GND |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | GPIO 19 | 35 | 36 | GPIO 16 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | GPIO 26 | 37 | 38 | GPIO 20 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | GND | 39 | 40 | GPIO 21 |  |'
  prefs: []
  type: TYPE_TB
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The GPIO pins are designed to work at 3.3 V, so if you connect them to higher
    voltages, you’ll permanently damage your Raspberry Pi.*'
  prefs: []
  type: TYPE_NORMAL
- en: The pins highlighted in gray, pins 27 and 28, are DNC, or “do not connect,”
    pins. The Raspberry Pi also has eight GND (ground) pins—highlighted in black in
    the table—for connecting ground to your circuits. There are four power pins, two
    5 V pins and two 3.3 V—highlighted in red and orange, respectively—to supply power.
    Several pins have special features; for example, the pins highlighted in yellow
    are used in serial peripheral interface (SPI) communication, and the ones highlighted
    in green are used for inter-integrated circuit (I²C) communication. You’ll learn
    about these communication protocols in [Project 3](ch03.xhtml#ch03) and [Project
    7](ch07.xhtml#ch07), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**INTRODUCING LEDs**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: LEDs come in a wide variety of sizes, shapes, and colors, and some can even
    mix colors to produce almost any color. In this project you’ll use a simple 5
    mm red LED.
  prefs: []
  type: TYPE_NORMAL
- en: An *LED*, or *light-emitting diode*, is—as its name suggests—a diode that emits
    light. Diodes are electronic components that have *polarity*, meaning they allow
    current to flow in only one direction, from positive to negative. LEDs, like all
    diodes, have a positive connection known as an *anode*, and a negative connection
    known as a *cathode*. The two legs, or *leads*, on LEDs are different lengths
    to help you identify which is positive and which is negative, illustrated in [Figure
    1-2](ch01.xhtml#ch01fig2). The longer lead is the anode (+) and the shorter lead
    is the cathode (–).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0040-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 1-2:** A 5 mm red LED'
  prefs: []
  type: TYPE_NORMAL
- en: FINDING THE RIGHT RESISTOR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'LEDs can handle only so much current before they overload and burn out, which
    can potentially damage the LED and even the Pi board. To prevent this, you must
    always connect LEDs in series with a *resistor*: a small component that limits
    the amount of current passing through it.'
  prefs: []
  type: TYPE_NORMAL
- en: Resistors come in all sorts of values, and you need one that’s strong enough
    to protect your component without being so strong that it limits the component’s
    capabilities. For example, a stronger resistor can dull the light an LED gives
    off. The appropriate resistance value depends on the LED you’re using—most LEDs
    you’ll use in electronics can handle a maximum current rating of 20 mA. For the
    LED in this project, picking up a resistor of any value between 220 Ω and 470
    Ω is fine, and within this range, a lower resistance value will result in a slightly
    brighter LED.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We recommend that you purchase a 1/4 W resistor assortment that spans a wide
    range of resistance values. These will meet most of your needs.*'
  prefs: []
  type: TYPE_NORMAL
- en: The resistance value is indicated by the color bands on the resistor. Resistors
    usually have four bands, as shown in [Figure 1-3](ch01.xhtml#ch01fig3). The first
    two represent the first two digits of the value. The third is a multiplier representing
    the number of zeros after the first two digits. The fourth is the *tolerance*
    of the resistance, which notes the percentage that the actual resistance might
    be above or below the given value. For example, a 330 Ω resistor with a 5 percent
    tolerance might be any value between 313.5 Ω and 346.5 Ω.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0040-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 1-3:** A 330 Ω resistor'
  prefs: []
  type: TYPE_NORMAL
- en: If you need help identifying a resistor, check the resistor color card in [“Decoding
    Resistor Values”](app02.xhtml#app02) on [page 264](app02.xhtml#page_264).
  prefs: []
  type: TYPE_NORMAL
- en: '**WIRING THE CIRCUIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you’re ready to build your first circuit. All the projects in this book
    use a *solderless breadboard*, which gives you an inexpensive and easy way to
    build circuits without having to connect the components using solder. If you’ve
    never used a breadboard before, make sure to read [“How Does a Breadboard Work?”](ch01.xhtml#ch01box1)
    on [page 42](ch01.xhtml#page_42) before beginning.
  prefs: []
  type: TYPE_NORMAL
- en: To wire an LED to the Raspberry Pi, follow these next steps. Use the wiring
    diagram in [Figure 1-4](ch01.xhtml#ch01fig4) as a reference, and review [Figure
    1-1](ch01.xhtml#ch01fig1) for pin locations if you need to.
  prefs: []
  type: TYPE_NORMAL
- en: Connect a blue breadboard rail to one of the Raspberry Pi GND pins (pins 6,
    9, 14, 20, 25, 30, 34, and 39 all provide GND).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the LED into the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the 330 Ω resistor into the breadboard so that one side is connected
    to the LED anode (the longer, positive lead).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the other side of the resistor to GPIO 25 (pin 22) with a jumper wire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the LED cathode (the shorter, negative lead) to the GND power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0041-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**LISTING 1-1:** Wiring an LED to the Raspberry Pi. The LED lead with a bend
    in it is the anode.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve given you instructions on where to place the resistor, but really it doesn’t
    matter whether it’s connected to the anode or cathode as long as it is connected
    to one. You might wonder why we didn’t just connect the LED cathode directly to
    pin 6 (GND), since we only need the GND rail for that one connection. The reason
    is that it’s good practice to use the breadboard GND rails, which will become
    more useful in more advanced circuits.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW DOES A BREADBOARD WORK?**'
  prefs: []
  type: TYPE_NORMAL
- en: Wiring a circuit using a breadboard is as easy as plugging and unplugging components.
    A breadboard has rows of holes that connect with copper strips underneath, so
    you just need to insert the components into those holes and then use jumper wires
    to connect them. The breadboard holes are connected to each other in a specific
    way, shown here by the orange lines.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0042-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each individual line is electrically isolated from the others. The horizontal
    lines are the *power rails*, used to connect the power supply: the blue rails
    are used to connect GND and the red rails to connect power. In the middle of the
    breadboard is a divide that splits the rows on either side. You should place your
    components in these rows. Components in the same row, on the same side of the
    center divide, will be connected by the copper strips beneath.'
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING THE SCRIPT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To keep all your projects organized, create a folder called *Projects* in your
    desktop environment to save all your projects’ scripts. Inside the newly created
    folder, create a new folder called *LEDs* where you’ll save the LED projects in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In simple terms, the blinking LED project works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The LED turns on for 1 second—GPIO 25 set to HIGH.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The LED turns off for 1 second—GPIO 25 set to LOW.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The LED is on again for 1 second—GPIO 25 set to HIGH.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The LED is off again for 1 second—GPIO 25 set to LOW.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This pattern continues until you tell the program to stop.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we’ll control the Raspberry Pi GPIOs using a Python library
    called gpiozero. The gpiozero library provides a collection of interfaces for
    everyday components like LEDs, buttons, potentiometers, sensors, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: '**Entering the Script**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Open **Python 3 (IDLE)** and go to **File** ▸ **New File** to create a new
    script. Copy the following code to the Python Editor and save the script as *blinking_led.py*
    inside the *LEDs* folder (remember that you can download all the scripts at *[https://www.nostarch.com/RaspberryPiProject/](https://www.nostarch.com/RaspberryPiProject/)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There’s quite a lot going on here, so we’ll go through each major code section
    one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing Libraries**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At ➊ you import `LED` from the gpiozero library to control the GPIO that the
    LED is connected to. Then you import the `sleep()` function from the `time` module
    ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '**Declaring the Pin**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At ➌ you create an `LED` object called `led` that refers to GPIO 25, which is
    the GPIO the LED is connected to. When you create and use this `LED` object, Python
    knows GPIO 25 is an output and thus should be set to HIGH or LOW. After this declaration,
    you can use `led` to refer to your GPIO 25.
  prefs: []
  type: TYPE_NORMAL
- en: '**Starting the while Loop**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At ➎ you start a `while` loop with the condition `True`, which means this loop
    will run forever until you stop the program yourself. The lines of code that follow
    the loop declaration are indented, telling Python that this is the content of
    the loop to be run as long as the `while` condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting the Digital Output**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next you need to set the digital output for the LED. You use the `led.on()`
    function ➏ to set GPIO 25 to HIGH, turning the LED on, and the `led.off()` function
    ➑ to set GPIO 25 to LOW, turning the LED off. There is a pause of 1 second between
    each LED state using the `sleep()` function ➐, which creates the blinking effect.
    The code stops where it is and waits for the amount of time specified in the `delay`
    variable (given in seconds) ➍ before proceeding to the next line of code. This
    allows you to keep the LED on or off for a given period of time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the Script**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To run the script, first save it and then press **F5** or go to **Run** ▸ **Run
    Module**. Your circuit should look something like Figure 1-5, with your LED turning
    on and off every second. To stop the running program, press CTRL-C.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0044-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 1-4:** The completed project'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations—you’ve just built your first working project!
  prefs: []
  type: TYPE_NORMAL
- en: '**TAKING IT FURTHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The best way to learn electronics and programming is by experimenting. Here
    are two simple ideas for modifications you could try:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the delay time in the script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the circuit and script to control more than one LED.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See if you can use what you learned in this project to figure out each task.
  prefs: []
  type: TYPE_NORMAL
- en: '**2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pushbutton LED Flashlight**
  prefs: []
  type: TYPE_NORMAL
- en: This LED flashlight will teach you to use pushbuttons, an essential skill in
    electronic circuits. You’ll learn how to use a pushbutton in your circuit to trigger
    an event—in this case, lighting an LED—when the pushbutton is pressed and stop
    the event when it’s released.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0047-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: Breadboard
  prefs: []
  type: TYPE_NORMAL
- en: 5 mm LED
  prefs: []
  type: TYPE_NORMAL
- en: 330 Ω resistor
  prefs: []
  type: TYPE_NORMAL
- en: Jumper wires
  prefs: []
  type: TYPE_NORMAL
- en: '**INTRODUCING SWITCHES AND BUTTONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Switches are everywhere. You use them to turn on lights, adjust the speed of
    your blender, light your stove, and so much more. There’s a wide variety of switches
    available, but some of the ones you’ll see around the house include pushbutton,
    toggle, rotary, and magnetic reed switches. [Figure 2-1](ch02.xhtml#ch02fig1)
    shows a few different switches commonly used in electronics.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0048-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 2-1:** Several types of switches used in electronics'
  prefs: []
  type: TYPE_NORMAL
- en: A switch can act either as an *interrupter*, interrupting the electric current
    to allow or restrict power to a certain component, or as a *diverter*, diverting
    the current to another part of the circuit. This project will use a simple pushbutton—an
    interrupter switch that is great for electronics because it is cheap, fits perfectly
    into a breadboard, and is easy to manipulate.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main types of pushbuttons: normally open and normally closed.
    *Normally open* pushbuttons, shown in [Figure 2-2](ch02.xhtml#ch02fig2), have
    a circuit that’s open by default, preventing the current from flowing through
    it. When you press the pushbutton, the two sides are connected, the circuit closes,
    and current flows.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0049-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 2-2:** A normally open pushbutton’s internal connection'
  prefs: []
  type: TYPE_NORMAL
- en: '*Normally closed* pushbuttons have a closed circuit when the button is not
    being pressed, allowing current to flow through until you press the pushbutton
    to open the circuit and stop its flow.'
  prefs: []
  type: TYPE_NORMAL
- en: Pushbuttons can have either two or four legs. Four-leg pushbuttons are more
    common in prototyping projects because they fit well into the breadboard. The
    right side of [Figure 2-2](ch02.xhtml#ch02fig2) shows a diagram of a typical normally
    open, four-leg pushbutton. Legs 1 and 2 are always connected. The same is true
    for legs 3 and 4.
  prefs: []
  type: TYPE_NORMAL
- en: In this project you’ll use a normally open pushbutton with four legs. This pushbutton
    allows current to flow only *while* the button is being pressed, so unlike a light
    switch, the LED in this project will be lit only for the duration that the button
    is held down.
  prefs: []
  type: TYPE_NORMAL
- en: '**WIRING THE CIRCUIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this project, you want the LED to turn on only when the button is being pressed,
    so your Raspberry Pi needs to be able to tell when the button is being pressed
    and when it isn’t. Your Raspberry Pi will get this information through the GPIO
    pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create your circuit, using [Figure 2-3](ch02.xhtml#ch02fig3)
    as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect GND to the blue power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert an LED into the breadboard and connect the positive LED lead to GPIO
    25 through a 330 Ω resistor, as we did in [Project 1](ch01.xhtml#ch01). Connect
    the negative lead to the GND rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the pushbutton in the middle of the breadboard so that two legs are on
    either side of the divide. You want to make sure there isn’t a connection between
    the two top pins and the two bottom pins. (Remember that the connection in the
    rows of holes is broken in this center strip.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect one side of the pushbutton to GPIO 2 and the other to GND, as shown
    in [Figure 2-3](ch02.xhtml#ch02fig3).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0050-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 2-3:** The LED flashlight circuit'
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING THE SCRIPT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This script will trigger different events depending on whether the pushbutton
    is being pressed or released. The following *pseudoscript*—a plain English version
    of the code instructions—should help you understand the Python script. Writing
    a pseudoscript is a great way to outline your program. Here’s what the program
    should do:'
  prefs: []
  type: TYPE_NORMAL
- en: When the pushbutton is being pressed, the LED is set to on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the pushbutton is not being pressed (that is, when it’s released), the
    LED stays off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open **Python 3 (IDLE)** and go to **File** ▸ **New File** to create a new
    script. Copy the following code into the Python Editor and then save the script
    as *led_flashlight.py* in the *LEDs* folder (remember that you can download all
    the scripts at *[https://www.nostarch.com/RaspberryPiProject/](https://www.nostarch.com/RaspberryPiProject/)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This script is straightforward to understand. You first import the LED and the
    Button libraries to control the LED and the pushbutton; then, you import `pause`
    from the signal library ➊. The `pause()` ➎ function keeps the program running
    even after all the code has run through to detect events—in this case, it’s continuously
    checking the pushbutton state.
  prefs: []
  type: TYPE_NORMAL
- en: You create an `LED` object called `led` that refers to GPIO 25, the pin the
    LED is connected to, and a `Button` object called `button` that refers to GPIO
    2, the pin the pushbutton is connected to ➋.
  prefs: []
  type: TYPE_NORMAL
- en: The `button.when_pressed` function turns the LED on when the pushbutton is being
    pressed by calling `led.on` when a pushbutton press is detected ➌. Likewise, the
    `button.when_released` function calls `led.off` to turn the LED off when the pushbutton
    is not being pressed ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Press **F5** or go to **Run** ▸ **Run Module** to run the script. The LED should
    be on while the pushbutton is pressed down. To stop the program, press CTRL-C.
  prefs: []
  type: TYPE_NORMAL
- en: '**TAKING IT FURTHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With what you’ve learned in this simple project, you can create countless other
    projects. Here are some ideas to test your skills:'
  prefs: []
  type: TYPE_NORMAL
- en: Add more pushbuttons and LEDs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the code to change the LED state when you press the pushbutton so that
    you don’t have to hold the button to keep the LED lit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a traffic light.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LED Dimmer Switch**
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll build a light dimmer by controlling the brightness of
    an LED using a potentiometer. The power in this project lies in your ability to
    read analog inputs with the Raspberry Pi and output pulse-width modulation signals.
    These will be incredibly useful skills in future projects and in your Pi learning.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0053-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: Breadboard
  prefs: []
  type: TYPE_NORMAL
- en: 10 kΩ potent iometer
  prefs: []
  type: TYPE_NORMAL
- en: MCP 3008 chip
  prefs: []
  type: TYPE_NORMAL
- en: 5 mm LED
  prefs: []
  type: TYPE_NORMAL
- en: 330 Ω resistor
  prefs: []
  type: TYPE_NORMAL
- en: Jumper wires
  prefs: []
  type: TYPE_NORMAL
- en: '**INTRODUCING POTENTIOMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Potentiometers are like power dials and are used in a wide variety of applications
    in your daily life, such as controlling the volume of the radio, adjusting the
    brightness of a display, setting the speed on a fan, and much more. The potentiometer
    you’ll use in this project is shown in [Figure 3-1](ch03.xhtml#ch03fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0054-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 3-1:** A 10 kΩ potentiometer'
  prefs: []
  type: TYPE_NORMAL
- en: A potentiometer, also referred to as *pot*, is a manually adjustable variable
    resistor. This means that you can change the amount of resistance it applies to
    a circuit by rotating the knob, changing the amount of current reaching a particular
    component.
  prefs: []
  type: TYPE_NORMAL
- en: A potentiometer has three pins, as shown in [Figure 3-2](ch03.xhtml#ch03fig2).
    The two outer pins, shown in blue and red, are connected to a resistive element,
    while the third, shown in black, is connected to a conductive adjustable *wiper*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0054-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 3-2:** How a potentiometer works'
  prefs: []
  type: TYPE_NORMAL
- en: The position of the wiper determines how much resistance is in the circuit.
    In this project, you’ll control the resistance in the circuit to make the LED
    brighter or dimmer.
  prefs: []
  type: TYPE_NORMAL
- en: '**READING ANALOG SIGNALS WITH RASPBERRY PI**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Raspberry Pi GPIOs can read only digital signals, which means they can read
    either HIGH (3.3 V ) or LOW (0 V ) but nothing in between. However, the potentiometer
    is an analog input, and rotating the knob changes its output voltage from 0 V
    up to 3.3 V. You want the Pi to be able to read all the values in between—like
    1 V, 1.4 V, 1.8 V, and so on—so you have gradations of light, not just on and
    off. For this, you need to convert the analog signal to digital with an analog-to-digital
    converter chip, and then create imitation analog signals using pulse-width modulation.
    Let’s go over these two topics before you begin your build.
  prefs: []
  type: TYPE_NORMAL
- en: '**Analog-to-Digital Converters**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The analog-to-digital converter (ADC) chip (MCP3008), shown in [Figure 3-3](ch03.xhtml#ch03fig3),
    converts the potentiometer analog signals to digital signals.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0055-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 3-3:** MCP3008 chip analog-to-digital converter'
  prefs: []
  type: TYPE_NORMAL
- en: This chip has 16 pins, 8 of which are analog inputs you can connect to analog
    devices. The other 8 connect to the Raspberry Pi GPIOs. The chip pinout is shown
    in [Figure 3-4](ch03.xhtml#ch03fig4). To identify each pin, orient the chip with
    the half-circle at the top as shown in the figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0055-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 3-4:** MCP3008 chip'
  prefs: []
  type: TYPE_NORMAL
- en: The following table gives the function for each pin.
  prefs: []
  type: TYPE_NORMAL
- en: '| **PIN** | **SYMBOL** | **DESCRIPTION** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | CH0 | Analog input (channel 0) |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | CH1 | Analog input (channel 1) |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | CH2 | Analog input (channel 2) |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | CH3 | Analog input (channel 3) |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | CH4 | Analog input (channel 4) |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | CH5 | Analog input (channel 5) |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | CH6 | Analog input (channel 6) |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | CH7 | Analog input (channel 7) |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | DGND | Digital ground |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | CS/SHDN | Chip select/shutdown input |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | D[IN] | Serial data in |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | D[OUT] | Serial data out |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | CLK | Serial clock |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | AGND | Analog ground |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | V[REF] | Reference voltage input |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | V[DD] | +2.7 V to 5.5 V power supply |'
  prefs: []
  type: TYPE_TB
- en: '**Pulse-Width Modulation**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we mentioned earlier, the Raspberry Pi GPIOs can be set to either HIGH or
    LOW, but they can’t output any voltages in between. However, you can output “fake”
    mid-level voltages using *pulse-width modulation (PWM)*, which is how you’ll produce
    varying levels of LED brightness for this project.
  prefs: []
  type: TYPE_NORMAL
- en: If you alternate an LED’s voltage between HIGH and LOW very fast, your eyes
    can’t keep up with the speed at which the LED switches on and off; you’ll simply
    see some gradations in brightness. That’s basically how PWM works—by producing
    an output that changes between HIGH and LOW at a very high *frequency*. The *duty
    cycle* is the fraction of the period of time at which the LED is set to HIGH.
    [Figure 3-5](ch03.xhtml#ch03fig5) illustrates how PWM works.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0057-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 3-5:** How PWM works'
  prefs: []
  type: TYPE_NORMAL
- en: A duty cycle of 50 percent results in 50 percent LED brightness, a duty cycle
    of 0 means the LED is fully off, and a duty cycle of 100 means the LED is fully
    on. Changing the duty cycle is how you produce different levels of brightness.
  prefs: []
  type: TYPE_NORMAL
- en: '**WIRING THE CIRCUIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this circuit you’ll need to connect an LED, the MCP3008 chip, and a potentiometer
    to the Pi. Follow these instructions to build the circuit, using [Figure 3-6](ch03.xhtml#ch03fig6)
    as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: Connect GND to the blue breadboard rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect 3.3 V to the red breadboard rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert an LED into the breadboard, connecting the longer LED lead to GPIO 17
    through a 330 Ω resistor and the shorter lead to the GND rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the MCP3008 chip in the middle of the breadboard and connect it as shown
    in the following table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **MCP3008** | **RASPBERRY PI** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 | Potentiometer middle lead |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 9 | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 10 | GPIO 8 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 11 | GPIO 10 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 12 | GPIO 9 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 13 | GPIO 11 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 14 | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 15 | 3.3 V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 16 | 3.3 V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**NOTE**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Before applying power to the circuit, make sure you’ve connected the MCP3008
    chip correctly using the pinout in [Figure 3-4](ch03.xhtml#ch03fig4), or you could
    damage the chip.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Connect one of the outer leads of the potentiometer to GND and the other to
    3.3 V—it doesn’t matter which lead you use for which connection. Connect the middle
    lead to MCP3008 chip pin 1 if you haven’t already.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0058-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 3-6:** Circuit to control the LED brightness with a potentiometer'
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING THE SCRIPT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Pi reads the analog values from the MCP3008 chip using SPI communication,
    so you’ll need to enable that first.
  prefs: []
  type: TYPE_NORMAL
- en: From the taskbar main menu, select **Preferences** ▸ **Raspberry Pi Configuration**.
    In the Interfaces tab, enable SPI as shown in [Figure 3-7](ch03.xhtml#ch03fig7)
    and click **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0059-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 3-7:** Enabling SPI communication'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your script needs to be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Read an analog input value from the potentiometer through the MCP3008 chip.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control the brightness of your LED with PWM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the duty cycle of the PWM according to the input value read from the
    potentiometer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entering the Script**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Open **Python 3 (IDLE)** and go to **File** ▸ **New File** to create a new
    script. Copy the following code to the Python Editor and save the script as *brightness_controller.py*
    inside the *LEDs* folder (remember that you can download all the scripts at *[https://www.nostarch.com/RaspberryPiProject/](https://www.nostarch.com/RaspberryPiProject/)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As usual, you start your code by importing the required libraries. Then you
    create an object called `pot` ➊ that refers to MCP3008 channel 0, the channel
    the potentiometer is connected to. Channel 0 corresponds to MCP3008 pin 1, channel
    1 to pin 2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting a PWM Pin and Reading Analog Values**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The gpiozero library allows you to control an LED’s brightness with PWM by using
    a `PWMLED` object. So at ➋, you create a `PWMLED` object called `led` that refers
    to the pin the LED is connected to, in this case, GPIO17.
  prefs: []
  type: TYPE_NORMAL
- en: To read an analog value using the gpiozero library, you simply get the potentiometer
    value with `pot.value`. Remember that `pot` refers to MCP3008 channel 0\. You’ll
    get decimal values between `0` and `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adjusting the Brightness**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To adjust the LED brightness using PWM, you need to change its duty cycle. To
    adjust the duty cycle, you simply have to attribute a value between `0` and `1`
    to the `led.value`, in which `0` corresponds to a fully off LED and `1` to a fully
    on LED.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this script, a `while` loop ➌ that is always `True` keeps the program running.
    This loop is constantly checking the potentiometer values: if the value read from
    the potentiometer is below `0.001` ➍, the duty cycle is set to `0`, which turns
    your LED off ➎. Otherwise, the code enters the `else` block ➏, in which the duty
    cycle changes according to the value read from the potentiometer.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the Script**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Press **F5** or go to **Run** ▸ **Run Module** to run the script. Now you should
    be able to rotate the potentiometer to control the brightness of the LED.
  prefs: []
  type: TYPE_NORMAL
- en: '**TAKING IT FURTHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Knowing how to read analog values and control output pins with PWM opens you
    up to a huge variety of projects. Give some of these a try for starters:'
  prefs: []
  type: TYPE_NORMAL
- en: Control several LEDs with the same potentiometer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a bar graph of LEDs that you can control with a potentiometer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control the blinking speed of an LED using a potentiometer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Graphical User Interface for a Multicolor LED**
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we’ll introduce you to the multicolor RGB LED, and you’ll learn
    how to build a simple graphical user interface in Tkinter to control your electronics.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0062-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: Breadboard
  prefs: []
  type: TYPE_NORMAL
- en: Common cathode RGB LED
  prefs: []
  type: TYPE_NORMAL
- en: Three 330 Ω resistors
  prefs: []
  type: TYPE_NORMAL
- en: Jumper wires
  prefs: []
  type: TYPE_NORMAL
- en: '**INTRODUCING RGB LEDS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RGB LEDs are three LEDs in one—red, green, and blue—that can produce almost
    any color by combining those three colors.
  prefs: []
  type: TYPE_NORMAL
- en: With an RGB LED you can, of course, produce red, green, and blue light, and
    by configuring the intensity of each LED, you can produce other colors as well.
    For example, to produce purely blue light, you’d set the blue LED to the highest
    intensity and the green and red LEDs to the lowest intensity. For a white light,
    you’d set all three LEDs to the highest intensity. [Figure 4-1](ch04.xhtml#ch04fig1)
    shows a simplified RGB color-mixing chart to give you an idea of how to combine
    red, green, and blue to produce different colors.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0063-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 4-1:** Simple RGB color mixing'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of RGB LEDs: a *common cathode* LED, where each color LED
    shares a negative connection, and a *common anode*, where each LED shares a positive
    connection. [Figure 4-2](ch04.xhtml#ch04fig2) illustrates a common anode and a
    common cathode LED.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0063-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 4-2:** Common anode and common cathode RGB LEDs'
  prefs: []
  type: TYPE_NORMAL
- en: RGB LEDs have four leads—one for each LED and another for the common anode or
    cathode. You can identify each lead by its length, as shown in [Figure 4-3](ch04.xhtml#ch04fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0064-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 4-3:** Common anode and common cathode RGB LED leads'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the LED facing you so the anode or cathode (the longest lead) is second
    from the left, the leads should be in the following order: red, anode or cathode,
    green, and blue. We’ll be using a common cathode LED for this project, but if
    you already have a common anode LED it’s fine to use that; just watch out for
    the differences noted in the circuit wiring.'
  prefs: []
  type: TYPE_NORMAL
- en: '**WIRING THE CIRCUIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Wiring an RGB LED to the Raspberry Pi is really straightforward and not much
    different than wiring a simple LED. You’ll need three current limiting resistors—one
    for each LED color.
  prefs: []
  type: TYPE_NORMAL
- en: Follow these instructions, using [Figure 4-4](ch04.xhtml#ch04fig4) as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: Connect the LED pins in the breadboard and add a 330 Ω current-limiting resistor
    in series for each color lead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect GND to the breadboard blue rail, and wire the RGB LED to the Raspberry
    Pi’s GPIO according to the following table, with red connected to GPIO 23, the
    cathode to GND, green to GPIO 24, and blue to GPIO 25\. Check [Figure 4-3](ch04.xhtml#ch04fig3)
    to make sure you’re orienting the LED correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using a common anode RGB LED, connect the longest lead (the anode)
    to 3.3 V.
  prefs: []
  type: TYPE_NORMAL
- en: '| **RGB LED** | **RASPBERRY PI** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| First lead: red | GPIO 23 |'
  prefs: []
  type: TYPE_TB
- en: '| Second lead: cathode | GND |'
  prefs: []
  type: TYPE_TB
- en: '| Third lead: green | GPIO 24 |'
  prefs: []
  type: TYPE_TB
- en: '| Fourth lead: blue | GPIO 25 |'
  prefs: []
  type: TYPE_TB
- en: '![image](../images/f0065-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 4-4:** Wiring a common cathode RGB LED to the Raspberry Pi'
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING THE SCRIPT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In your script, you’ll use a library called Tkinter to create a user interface
    window in your desktop environment that you can use to control the RGB LED. Tkinter
    is already installed with your Raspbian system, so you just need to import it
    in your script.
  prefs: []
  type: TYPE_NORMAL
- en: The interface window will have three sliders (with values of `0` to `1`) to
    control the intensity of the built-in red, green, and blue LEDs, and a close button
    to shut down the program. By adjusting the values’ intensities with the sliders,
    you can change the color of the RGB LED.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open **Python 3 (IDLE)** and go to **File** ▸ **New File** to create a
    new script. Then, enter the following code into the Python Editor and save the
    script as *rgb_led_controller.py* inside the *LEDs* folder (remember that you
    can download all the scripts at *[https://www.nostarch.com/RaspberryPiProject/](https://www.nostarch.com/RaspberryPiProject/)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**USER-DEFINED FUNCTIONS**'
  prefs: []
  type: TYPE_NORMAL
- en: To define a new function, you use the word `def` followed by the name you want
    to give the function and a set of parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the parentheses you add a colon (`:`) and then tell the function what
    instructions to perform. Python knows which instructions are part of the function
    definition by the use of the colon and indentation: every indented line after
    the colon is part of the function. Later, you can run the instructions you’ve
    set inside the function by entering the name of the function, also known as *calling*
    the function.'
  prefs: []
  type: TYPE_NORMAL
- en: First, you import `PWMLED` from the gpiozero library to control the LED with
    PWM, and import the tkinter library to build the user interface ➊. Next, you create
    the function to control the LED color. Remember that a function is basically a
    block of reusable code that will perform a certain action. Python has many built-in
    functions, like `print()`, `int()`, and `input()`, but you can also build your
    own *user-defined functions*, as in this script. Read the [“User-Defined Functions”](ch04.xhtml#ch04box1)
    box to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: '**Controlling the Intensity and Closing the Window**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `change_color()` function ➋ changes the LED’s duty cycle as you adjust the
    value of the slider, which in turn changes the intensity of the LED and therefore
    the color it produces. This function is called every time the sliders move, so
    you should see an instantaneous change on the LED when you move the slider. At
    ➍, you create `PWMLED` objects to refer to each color of the RGB LED.
  prefs: []
  type: TYPE_NORMAL
- en: The `close_window()` function ➌ closes the window with `window.destroy()`. This
    function is called when you press the Close button in the Tkinter interface. We’ll
    look at how to create the Tkinter interface next.
  prefs: []
  type: TYPE_NORMAL
- en: '**Designing the User Interface with Tkinter**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At ➎, you define the main window of your interface. You create a variable called
    `window` that is a `tkinter` window with the line `window = Tk()`. You then give
    your window a title and set the window dimensions with the `title()` and `geometry()`
    methods, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating Sliders and Buttons**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: After creating the window, you can start adding the controls, known as *widgets*,
    like buttons, labels, and sliders. You’re using a `Button` widget to close the
    window and three `Scale` widgets to add the sliders to your window.
  prefs: []
  type: TYPE_NORMAL
- en: 'You then create three sliders, one for each RGB color ➏, using the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The master argument is the window you’ll add the widget to, and each option
    argument allows you to personalize your sliders. In the *rgb_led_controller.py*
    script, you use the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`from_` defines the lower end of the scale’s range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`to` defines the upper end of the scale’s range. In our case, the range is
    0 to 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resolution` sets the resolution of the slider—the minimum difference between
    two consecutive values. Here, the resolution is `0.01`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orient` defines the slider orientation, either `HORIZONTAL` or `VERTICAL`.
    This script sets the sliders to `HORIZONTAL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label` sets the slider label. You label each slider in this script according
    to the LED color it controls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`troughcolor` sets the background color of the slider. Each slider background
    is the color of the LED it controls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length` defines the length of the slider in pixels. All of the sliders are
    set to `200`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`command` dictates the procedure that will be called every time the slider
    is moved. In this case, moving the slider calls the `change_color()` function,
    which changes the LED’s duty cycle and thus the color it produces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After creating the slider, you use the `pack()` method to place the widgets
    in the main `window`. As you’re not passing any argument to the `pack()` method,
    the widgets are placed in the window according to the default settings: widgets
    fill only their minimal dimension, and they are packed against the top of the
    window or against the widget above.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you create the Close button ➐ using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In your code, you use these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text` defines the text that will be displayed on the button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`command` dictates the procedure that will be called when the button is pressed—here,
    the `close_window()` function, which closes the window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using the Main Loop**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The script’s final statement calls the `mainloop()` function ➑, which is an
    infinite loop that allows windows to be drawn and events to be processed. The
    `mainloop()` function is what keeps your program running.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the Script**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Press **F5** or go to **Run** ▸ **Run Module** to run the script. Your interface
    window should pop up, as shown in [Figure 4-5](ch04.xhtml#ch04fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0069-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 4-5:** The RGB LED controller user interface'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You’ve made your own component user interface! Now try moving
    the sliders to change the LED color. When you change each slider’s position, the
    RGB LED color should change accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: To close the program, just press the Close button.
  prefs: []
  type: TYPE_NORMAL
- en: '**TAKING IT FURTHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you know how to make a graphical user interface, we encourage you
    to edit its parameters to customize its look to suit your tastes. Here are some
    other project ideas you could try:'
  prefs: []
  type: TYPE_NORMAL
- en: Build a graphical user interface that controls turning an LED on and off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a graphical user interface that controls the brightness of the LED.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alter the user interface to control several LEDs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rainbow Light Strip**
  prefs: []
  type: TYPE_NORMAL
- en: In this project you’ll create a rainbow light effect using an addressable RGB
    LED strip. You’ll use a pushbutton to start and stop the rainbow effect, and you’ll
    control the rainbow’s speed and brightness using two potentiometers.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0071-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: Breadboard
  prefs: []
  type: TYPE_NORMAL
- en: WS2812B addressable RGB LED strip
  prefs: []
  type: TYPE_NORMAL
- en: Logic level conver ter module BSS 138
  prefs: []
  type: TYPE_NORMAL
- en: Two 10 kΩ potentiometers
  prefs: []
  type: TYPE_NORMAL
- en: MCP 3 008 chip
  prefs: []
  type: TYPE_NORMAL
- en: Pushbutton
  prefs: []
  type: TYPE_NORMAL
- en: Three header pins
  prefs: []
  type: TYPE_NORMAL
- en: Jumper wires
  prefs: []
  type: TYPE_NORMAL
- en: '**SOFTWARE REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: WS2 81X library
  prefs: []
  type: TYPE_NORMAL
- en: '**INTRODUCING THE WS2812B ADDRESSABLE RGB LED STRIP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the rainbow light effect, you’ll use the WS2812B RGB LED strip, which is
    available in many different sizes. The strip comes in a reel, as shown in [Figure
    5-1](ch05.xhtml#ch05fig1), and you can cut off as long a section as you need.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0072-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5-1:** WS2812B addressable RGB LED strip on a reel'
  prefs: []
  type: TYPE_NORMAL
- en: The strip shown in [Figure 5-1](ch05.xhtml#ch05fig1) is 5 meters long with 300
    addressable WS2812B RGB LEDs wired in series, and later you’ll cut a section of
    14 LEDs to use in this project. There are cutting marks, shown in [Figure 5-2](ch05.xhtml#ch05fig2),
    along the entire length of the strip.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0072-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5-2:** WS2812B addressable RGB LED strip pins'
  prefs: []
  type: TYPE_NORMAL
- en: The color and brightness of each LED can be controlled individually, allowing
    you to produce amazing effects easily. Each LED has an integrated circuit (IC)
    built right in, which means you can control the whole strip using just one GPIO
    pin, connected to the middle pin—the Data pin—at the end of the strip (see [Figure
    5-2](ch05.xhtml#ch05fig2)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepare the LED strip for this project as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Cut a strip of 14 LEDs along the cutting marks shown on the strip.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solder header pins to the 5 V, Data, and GND pins as shown in [Figure 5-2](ch05.xhtml#ch05fig2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ve found that a Raspberry Pi 5 V pin (such as pin 2 or pin 4) is capable
    of powering a strip of 20 LEDs or fewer, but in projects where you’re using a
    longer strip, you’ll need to use an external 5 V power supply to provide enough
    current.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now you need to figure out your power supply. The LED strip requires a 5 V power
    source. You can determine the amps you need from the amount of power each LED
    requires. An individual LED draws up to 60 mA at full brightness (which produces
    white light), but since you’ll rarely need all LEDs at their maximum value for
    any length of time, you can safely estimate 20 mA per LED. So if your strip is
    14 LEDs long, you’ll need a 5 V power source with approximately 20 × 14 = 280
    mA.
  prefs: []
  type: TYPE_NORMAL
- en: The Data pin that controls the strip needs a 5 V signal, but the Pi GPIOs operate
    at 3.3 V. To get the 5 V you need, you’ll use a component called a logic level
    converter.
  prefs: []
  type: TYPE_NORMAL
- en: '**INTRODUCING THE LOGIC LEVEL CONVERTER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *logic level converter* allows you to convert 3.3 V signals to 5 V signals.
    There are many types of logic level converter, but in this project you’ll use
    the two-channel logic level converter bidirectional module shown in [Figure 5-3](ch05.xhtml#ch05fig3).
    (To find the same logic level converter module we’re using, search online for
    *logic level converter module bss138*.)
  prefs: []
  type: TYPE_NORMAL
- en: The bidirectionality of this module allows you to convert data in both ways—from
    3.3 V to 5 V and from 5 V to 3.3 V. You won’t need to convert 5 V to 3.3 V in
    this project, but having this more flexible model in your toolkit (versus a unidirectional
    model) can come in handy for future projects. This logic level converter also
    has two channels, channel 1 and channel 2\. In this project you’ll use only one
    of the channels to control the LED strip’s Data pin.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0073-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5-3:** Two-channel logic level converter bidirectional module'
  prefs: []
  type: TYPE_NORMAL
- en: More likely than not, your module will come with the header pins separate, so
    you’ll need to solder the pins to it to make it breadboard-friendly. Break off
    two rows of six header pins, and solder one pin to each tiny hole.
  prefs: []
  type: TYPE_NORMAL
- en: The module has a low-voltage side (left side of [Figure 5-3](ch05.xhtml#ch05fig3)),
    to which you attach everything that’s at 3.3 V, and a high-voltage side (right
    side), where you attach everything at 5 V. For this project, you need to use one
    of the pins highlighted in red, as you want to send 3.3 V data and convert it
    to 5 V.
  prefs: []
  type: TYPE_NORMAL
- en: To use the logic level converter, connect GND on both sides, 3.3 V on the low-voltage
    side, and 5 V on the high-voltage side. Then, connect data from the Pi on one
    of the TX1 pins—you can use either channel 1 or channel 2—and get the 5 V data
    on the corresponding TX0 pin.
  prefs: []
  type: TYPE_NORMAL
- en: '**WIRING THE CIRCUIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, you should have cut your strip to size (14 LEDs) and soldered
    header pins both to the end of the strip and to the logic level converter. Now
    you’re ready to wire the circuit. To do so, you’ll connect together a pushbutton,
    two potentiometers via the MCP3008 chip, and the addressable RGB LED strip using
    the logic level converter module, as shown in [Figure 5-4](ch05.xhtml#ch05fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0074-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5-4:** Circuit for controlling the RGB LED strip'
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that you can’t connect 5 V to the Pi GPIOs, as that can permanently
    damage your board.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To identify the MCP3008 pins, orient the chip so it’s facing you with the
    half-circle cutout at the top. The first pin is the top left and the last pin
    is the top right. See [“Analog-to-Digital Converters”](ch03.xhtml#lev41) on [page
    55](ch03.xhtml#page_55) for a full MCP3008 pinout description.*'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the GND and 3.3 V pins to the breadboard rails.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the MCP3008 chip in the middle of the breadboard with the two sides straddling
    the center divide.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert two potentiometers in the breadboard, wiring one’s outer lead to GND
    and the other’s outer lead to 3.3 V.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the MCP3008 chip as shown in the following table. It doesn’t matter
    which potentiometer you connect to which pins; they will work the same way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **MCP3008** | **CONNECT TO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 | One potentiometer’s middle lead |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 2 | Other potentiometer’s middle lead |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 9 | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 10 | GPIO 8 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 11 | GPIO 10 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 12 | GPIO 9 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 13 | GPIO 11 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 14 | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 15 | 3.3 V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 16 | 3.3 V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Insert a pushbutton into the breadboard, straddling the center divide. On one
    side of the center divide, connect one pin to GND and the other pin to GPIO 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the RGB LED strip pins into the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the logic level converter into the breadboard. Connect the low-voltage
    side as directed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **LOGIC LEVEL CONVERTER** | **RASPBERRY PI** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| TX1 (channel 2) | GPIO 18 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| LV | 3.3 V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Connect the high-voltage side as directed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **LOGIC LEVEL CONVERTER** | **CONNECT TO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| TX0 (channel 2) | RGB LED strip’s Data pin (middle pin) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| HV | 5 V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: With the logic level converter connected, connect the RGB LED strip as directed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **RGB LED STRIP** | **CONNECT TO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 5 V | 5 V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Din | Logic level converter TX0 pin |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you choose to do this project with a strip of more than 20 LEDs, you’ll
    need to connect your 5 V power source to the strip’s 5 V pin and the GND power
    source to the GND rail.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING THE SCRIPT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This script relies on the WS281X library to control the individual LEDs, so
    you need to install that library and then enable the Serial Peripheral Interface
    (SPI) communication the strip needs to communicate with the Pi.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing the WS281X Library**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are a few steps to installing the WS281X library, as it requires you to
    set up the libraries it depends on first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal window and install the scons, python3-dev, and swig libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still in the terminal, navigate to the desktop, create a folder called *Libraries*,
    and then navigate to the newly created folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Clone the library to download it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move to the *rpi_ws281x* library folder and run the `scons` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the *python* folder and install the WS281X library on your Pi:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now you’re ready to use the WS281X library in your code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Enabling SPI Communication**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To communicate with the MCP3008 chip, you need to enable SPI communication.
    Go to the taskbar main menu and select **Preferences** ▸ **Raspberry Pi Configuration**.
    In the Interfaces tab, click **Enabled** in the SPI row, as shown in [Figure 5-5](ch05.xhtml#ch05fig5),
    and then click **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0077-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 5-5:** Enabling SPI communication'
  prefs: []
  type: TYPE_NORMAL
- en: '**ENTERING THE SCRIPT**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s recap how the circuit works to help you better understand the script
    before entering it:'
  prefs: []
  type: TYPE_NORMAL
- en: Your RGB LED strip displays a moving rainbow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One potentiometer controls the rainbow speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another potentiometer controls the rainbow brightness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pushbutton starts and stops the rainbow animation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING CRAZY PIXELS**'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of this writing, there is an issue with the strip pixels on newer
    versions of Raspbian. The pin used to control the strip is shared with analog
    audio output, so the pixels can go crazy and not work properly. If this happens
    when you load the code, you need to add two lines to the *config.txt* file. Go
    to the terminal and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file that opens, add the following two lines (anywhere should be fine):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Press CTRL-X to save the file and then, when prompted, type **Y** and press
    ENTER. Reboot your Pi for the changes to take effect, and then proceed to the
    library installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open **Python 3 (IDLE)** and go to **File** ▸ **New File** to create a new
    script. Copy the code in [Listing 5-1](ch05.xhtml#ch05list1) to the Python Editor
    and save the script as *rainbow_effect.py* inside the *LEDs* folder (remember
    that you can download all the scripts at *[https://www.nostarch.com/RaspberryPiProject/](https://www.nostarch.com/RaspberryPiProject/)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 5-1:** The Rainbow Strip *rainbow_effect.py* code'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: First, you import the libraries you’ll use to control the project ➊. You need
    the neopixel library to control the LED strip, the time library to import the
    `sleep()` function for controlling the delay time, and from gpiozero you import
    the `Button()` and `MCP3008()` interfaces to read the pushbutton and potentiometer
    values, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting the Strip Parameters**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At ➋, you create variables for configuring the RGB LED strip, including the
    number of LEDs and the GPIO pin used. Then, at ➌, you create objects to refer
    to the two potentiometers, with the brightness on MCP3008 channel 0 (pin 1) and
    the speed on MCP3008 channel 1 (pin 2), and an object for the button on GPIO 2\.
    You also create a variable for starting and stopping the animation called `running_animation`,
    which takes a Boolean and is `False` (off ) by default.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the Rainbow Effect Functions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At ➍ and ➎, you create the functions that produce the moving rainbow effect.
    These functions are the same as the ones used in the *strandtest.py* example that
    comes with the neopixel library. In simple terms, the `wheel()` function generates
    the color spectrum by varying each color parameter between 0 and 255\. Each color
    is composed of red, green, and blue (RGB) parameters, and varying each parameter
    between 0 and 255 produces different colors, resulting in a rainbow effect. The
    `rainbowCycle()` function distributes the rainbow across the number of LEDs on
    your strip.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➏ sets the delay time for the `sleep()` function. To calculate the
    delay time, you multiply the value read from one of the potentiometers (which
    is between 0 and 1) by 40 and then divide that result by 1,000\. Multiplying the
    potentiometer value by 40 produces a noticeable delay time; otherwise, the delay
    would be so short that the rainbow effect would happen too fast for you to detect
    the movement of the lights. Dividing by 1,000 gives you a delay time in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: '**Controlling the Pushbutton**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Using the gpiozero library, you assign a particular action to a pushbutton
    press as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The function_name function refers to a generic function that will be called
    when the button is pressed; that function must be defined before it is called.
    In this case, that function is `start_animation` ➑, defined at ➐. Notice that
    function_name doesn’t have parentheses. This happens because we’re just assigning
    a function to another function instead of running the function. In our case, we’re
    telling the code to run the `start_animation` function when the `button_start.when_pressed`
    function is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: When the button is pressed, the `running_animation` value changes. When the
    `running_animation` variable is `False` and the button is pressed, it changes
    to `True`, and vice versa. This allows you to start and stop the rainbow effect.
  prefs: []
  type: TYPE_NORMAL
- en: '**Controlling the Animation with the while Loop**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At ➒, you create an `Adafruit_Neopixel` object called `strip` that takes in
    the strip parameters you defined earlier at ➋. To control the strip’s LED brightness,
    you use `int(pot_brightness.value*255)`. The brightness changes according to the
    value read from one of the potentiometers (between 0 and 1). You multiply that
    value by 255 because the strip’s LED brightness has a range of 0 to 255\. Using
    the `int()` function rounds the number to an integer. This way, you can adjust
    the LED brightness by rotating the potentiometer.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you use `strip.begin()`, which you need to call before making other calls
    on the `Adafruit_Neopixel` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop ➓ keeps the program running. Then, you set the strip brightness
    before starting the animation. If the `running_animation` variable is equal to
    `True`, the `rainbowCycle()` function will run, starting the animation. If you
    press the pushbutton, the `running_animation` variable changes to `False`, and
    the animation stops.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the Script**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To run this script, you need to use the terminal window. Running it from the
    Python 3 IDLE editor will give you a permissions error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the script as *rainbow_effect.py* inside the *LEDs* folder within the
    *Projects* directory, and open the terminal. Then, navigate to the *LEDs* folder
    and run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now you can control the speed and brightness by rotating their respective potentiometers
    and stop and start the animation by pressing the pushbutton.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have an awesome decoration for your home!
  prefs: []
  type: TYPE_NORMAL
- en: '**TAKING IT FURTHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some simple ideas you can try if you want to increase your level of
    control over the strip:'
  prefs: []
  type: TYPE_NORMAL
- en: Light up a specific LED in the middle of the strip.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Light all the LEDs in just one color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a pushbutton to change between preset effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blink the LEDs like Christmas lights.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invent your own effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
