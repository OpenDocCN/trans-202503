- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PROGRAM
    STRUCTURE</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '*with Aaron Ballman*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Any real-world system is made up of multiple components, such as source files,
    headers, and libraries. Many contain resources including images, sounds, and configuration
    files. Composing a program from smaller logical components is good software engineering
    practice, because these components are easier to manage than a single large file.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to structure your program into multiple units
    consisting of both source and include files. You’ll also learn how to link multiple
    object files together to create libraries and executable files.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Principles of Componentization</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nothing prevents you from writing your entire program within the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function of a single source file. However, as the function grows, that approach
    will quickly become unmanageable. For this reason, it makes sense to decompose
    your program into a collection of components that exchange information across
    a shared boundary, or *interface*. Organizing source code into components makes
    it easier to understand and allows you to reuse the code elsewhere in the program,
    or even with other programs.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how best to decompose a program typically requires experience.
    Many of the decisions programmers make are driven by performance. For example,
    you may need to minimize communication over a high-latency interface. Bad hardware
    can only go so far; you need bad software to really screw up performance.
  prefs: []
  type: TYPE_NORMAL
- en: Performance is only one software quality attribute (ISO/IEC 25000:2014) and
    must be balanced with maintainability, code readability, understandability, safety,
    and security. For example, you may design a client application to handle input
    field validation from the user interface to avoid a round trip to the server.
    This helps performance but can hurt security if inputs to the server are not validated.
    A simple solution is to validate inputs in both locations.
  prefs: []
  type: TYPE_NORMAL
- en: Developers frequently do strange things for illusionary gains. The strangest
    of these is invoking the undefined behavior of signed integer overflow to improve
    performance. Frequently, these local code optimizations have no impact on overall
    system performance and are considered *premature optimizations*. Donald Knuth,
    author of *The Art of Computer Programming* (Addison-Wesley, 1997), described
    premature optimization as “the root of all evil.”
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll cover some principles of component-based software engineering.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Coupling and Cohesion</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to performance, the aim of a well-structured program is to achieve
    desirable properties like low coupling and high cohesion. *Cohesion* is a measure
    of the commonality between elements of a programming interface. Assume, for example,
    that a header exposes functions for calculating the length of a string, calculating
    the tangent of a given input value, and creating a thread. This header has low
    cohesion because the exposed functions are unrelated to each other. Conversely,
    a header that exposes functions to calculate the length of a string, concatenate
    two strings together, and search for a substring within a string has high cohesion
    because all the functionality is related. This way, if you need to work with strings,
    you need only to include the string header. Similarly, related functions and type
    definitions that form a public interface should be exposed by the same header
    to provide a highly cohesive interface of limited functionality. We’ll discuss
    public interfaces further in “Data Abstractions” on [page 215](#pg_215).
  prefs: []
  type: TYPE_NORMAL
- en: '*Coupling* is a measure of the interdependency of programming interfaces. For
    example, a tightly coupled header can’t be included in a program by itself; instead,
    it must be included with other headers in a specific order. You may couple interfaces
    for a variety of reasons, such as a mutual reliance on data structures, interdependence
    between functions, or the use of a shared global state. But when interfaces are
    tightly coupled, modifying program behavior becomes difficult because changes
    can have a ripple effect across the system. You should always strive to have loose
    coupling between interface components, regardless of whether they’re members of
    a public interface or implementation details of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: By separating your program logic into distinct, highly cohesive components,
    you make it easier to reason about the components and test the program (because
    you can verify the correctness of each component independently). The result is
    a more maintainable, less buggy system.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Code Reuse</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Code reuse* is the practice of implementing functionality once and then reusing
    it in various parts of the program without duplicating the code. Code duplication
    can lead to subtly unexpected behavior, oversized and bloated executables, and
    increased maintenance costs. And anyway, why write the same code more than once?'
  prefs: []
  type: TYPE_NORMAL
- en: '*Functions* are the lowest-level reusable units of functionality. Any logic
    that you might repeat more than once is a candidate for encapsulating in a function.
    If the functionality has only minor differences, you might be able to create a
    parameterized function that serves multiple purposes. Each function should perform
    work that isn’t duplicated by any other function. You can then compose individual
    functions to solve increasingly sophisticated problems.'
  prefs: []
  type: TYPE_NORMAL
- en: Packaging reusable logic into functions can improve maintainability and eliminate
    defects. For example, though you could determine the length of a null-terminated
    string by writing a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, it’s more maintainable to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>
    function from the C standard library. Because other programmers are already familiar
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function,
    they’ll have an easier time understanding what that function is doing than what
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is doing. Furthermore,
    if you reuse existing functionality, you’re less likely to introduce behavioral
    differences in ad hoc implementations, and you make it easier to globally replace
    the functionality with a better-performing algorithm or more secure implementation,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: When designing functional interfaces, a balance must be struck between *generality*
    and *specificity*. An interface that’s specific to the current requirement may
    be lean and effective but hard to modify when requirements change. A general interface
    might allow for future requirements but be cumbersome for foreseeable needs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Data Abstractions</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *data abstraction* is any reusable software component that enforces a clear
    separation between the abstraction’s public interface and the implementation details.
    The *public interface* for each data abstraction includes the data type definitions,
    function declarations, and constant definitions required by the users of the data
    abstraction and is placed in headers. The implementation details of how the data
    abstraction is coded, as well as any private utility functions, are hidden within
    source files or in headers that are in a separate location from the public interface
    headers. This separation of the public interface from the private implementation
    allows you to change the implementation details without breaking code that depends
    on your component.
  prefs: []
  type: TYPE_NORMAL
- en: '*Header files* typically contain function declarations and type definitions
    for the component. For example, the C standard library <samp class="SANS_TheSansMonoCd_W5Regular_11"><string.h></samp>
    header provides the public interface for string-related functionality, while <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><threads.h></samp> provides utility functions
    for threading. This logical separation has low coupling and high cohesion, making
    it easier to access only the specific components you need and reduce compile time
    and the likelihood of name collisions. You don’t need to know anything about threading
    application programming interfaces (APIs), for example, if all you need is the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function.'
  prefs: []
  type: TYPE_NORMAL
- en: Another consideration is whether you should explicitly include the headers required
    by your header or require the users of the header to include them first. It’s
    a good idea for data abstractions to be self-contained and include the headers
    they use. Not doing so is a burden on the users of the abstraction and leaks implementation
    details about the data abstraction. Examples in this book don’t always follow
    this practice to keep these file listings concise.
  prefs: []
  type: TYPE_NORMAL
- en: '*Source files* implement the functionality declared by a given header or the
    application-specific program logic used to perform whatever actions are needed
    for a given program. For example, if you have a *network.h* header that describes
    a public interface for network communications, you may have a *network.c* source
    file (or *network_win32.c* for Windows only and *network _linux.c* for Linux only)
    that implements the network communication logic.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to share implementation details between two source files by using
    a header, but the header file should be placed in a distinct location from the
    public interface to prevent accidentally exposing implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: A *collection* is a good example of a data abstraction that separates the basic
    functionality from the implementation or underlying data structure. A collection
    groups data elements and supports operations such as adding elements to the collection,
    removing data elements from the collection, and checking whether the collection
    contains a specific data element.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to implement a collection. For example, a collection of
    data elements may be represented as a flat array, a binary tree, a directed (possibly
    acyclic) graph, or a different structure. The choice of data structure can impact
    an algorithm’s performance, depending on what kind of data you’re representing
    and how much data there is to represent. For example, a binary tree may be a better
    abstraction for a large amount of data that needs good lookup performance, whereas
    a flat array is likely a better abstraction for a small amount of data of fixed
    size. Separating the interface of the collection data abstraction from the implementation
    of the underlying data structure allows the implementation to change without requiring
    changes to code that relies on the collection interface.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Opaque Types</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Data abstractions are most effective when used with opaque data types that hide
    information. In C, *opaque* (or *private*) data types are those expressed using
    an incomplete type, such as a forward-declared structure type. An *incomplete
    type* is a type that describes an identifier but lacks information needed to determine
    the size of objects of that type or their layout. Hiding internal-only data structures
    discourages programmers who use the data abstraction from writing code that depends
    on implementation details, which may change. The incomplete type is exposed to
    users of the data abstraction, while the fully defined type is accessible only
    to the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we want to implement a collection that supports a limited number of operations,
    such as adding an element, removing an element, and searching for an element.
    The following example implements <samp class="SANS_TheSansMonoCd_W5Regular_11">collection_type</samp>
    as an opaque type, hiding the implementation details of the data type from the
    library’s user. To accomplish this, we create two headers: an external *collection.h*
    header included by the user of the data type and an internal header included only
    in files that implement the functionality of the data type.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">collection.h</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">collection_type</samp> identifier
    is aliased to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct collection_type</samp>
    (an incomplete type). Consequently, functions in the public interface must accept
    a pointer to this type, instead of an actual value type, because of the constraints
    placed on the use of incomplete types in C.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the internal header, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    collection_type</samp> is fully defined but not visible to a user of the data
    abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">collection_priv.h</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Users of the data abstraction include only the external *collection.h* file,
    whereas modules that implement the abstract data type also include the internal
    definitions *collection_priv.h* file. This allows the implementation of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">collection_type</samp> data type to remain
    private.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Executables</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 9](chapter9.xhtml), we learned that the compiler is a pipeline of
    translation phases and that the compiler’s ultimate output is object code. The
    last phase of translation, called the *link phase*, takes the object code for
    all the translation units in the program and links them together to form a final
    executable. This can be an executable that a user can run, such as *a.out* or
    *foo.exe*, a library, or a more specialized program such as a device driver or
    a firmware image (machine code to be burned onto read-only memory [ROM]). Linking
    allows you to separate your code into distinct source files that can be compiled
    independently, which helps to build reusable components.
  prefs: []
  type: TYPE_NORMAL
- en: '*Libraries* are executable components that cannot be executed independently.
    Instead, you incorporate libraries into executable programs. You can invoke the
    functionality of the library by including the library’s headers in your source
    code and calling the declared functions. The C standard library is an example
    of a library—you include the headers from the library, but you do not directly
    compile the source code that implements the library functionality. Instead, the
    implementation ships with a prebuilt version of the library code.'
  prefs: []
  type: TYPE_NORMAL
- en: Libraries allow you to build on the work of others for the generic components
    of a program so you can focus on developing the logic that is unique to your program.
    For example, when writing a video game, reusing existing libraries should allow
    you to focus on developing the game logic, not worrying about the details of retrieving
    user input, network communications, or graphics rendering. Libraries compiled
    with one compiler can often be used by programs built with a different compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries are linked into your application and can be either static or dynamic.
    A *static library*, also known as an *archive*, incorporates its machine or object
    code directly into the resulting executable, which means that a static library
    is often tied to a specific release of the program. Because a static library is
    incorporated at link time, the contents of the static library can be further optimized
    for your program’s use of the library. Library code used by the program can be
    made available for link-time optimizations (for example, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">-flto</samp>
    flag), while unused library code can be stripped from the final executable.
  prefs: []
  type: TYPE_NORMAL
- en: A *dynamic library*, also referred to as a *shared library* or a *dynamic shared
    object*, is an executable without the startup routines. It can be packaged with
    the executable or installed separately but must be available when the executable
    calls a function provided by the dynamic library. Many modern operating systems
    will load the dynamic library code into memory once and share it across all the
    applications that need it. You can replace a dynamic library with different versions
    as necessary after your application has been deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Letting the library evolve separately from the program comes with its own set
    of benefits and risks. A developer can correct bugs in the library after an application
    has already shipped without requiring the application to be recompiled, for instance.
    However, dynamic libraries provide the potential opportunity for a malicious attacker
    to replace a library with a nefarious one or an end user to accidentally use an
    incorrect version of the library. It’s also possible to make a *breaking change*
    in a new library release that results in an incompatibility with existing applications
    that use the library. Static libraries might execute somewhat faster because the
    object code (binary) is included in the executable file, enabling further optimizations.
    The benefits of using dynamic libraries usually outweigh the disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Each library has one or more headers that contain the public interface to the
    library and one or more source files that implement the logic for the library.
    You can benefit from structuring your code as a collection of libraries even if
    the components aren’t turned into actual libraries. Using an actual library makes
    it harder to accidentally design a tightly coupled interface where one component
    has special knowledge of the internal details of another component.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Linkage</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Linkage* is a process that controls whether an interface is public or private
    and determines whether any two identifiers refer to the same entity. Ignoring
    macros and macro parameters that are replaced early in the translation phases,
    an *identifier* can denote a standard attribute, an attribute prefix, or an attribute
    name; an object; a function; a tag or a member of a structure, union, or enumeration;
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> name; or a label
    name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'C provides three kinds of linkage: external, internal, or none. Each declaration
    of an identifier with *external linkage* refers to the same function or object
    everywhere in the program. Identifiers referring to declarations with internal
    linkage refer to the same entity only within the translation unit containing the
    declaration. If two translation units both refer to the same internal linkage
    identifier, they refer to different instances of the entity. If a declaration
    has *no linkage*, it’s a unique entity in each translation unit.'
  prefs: []
  type: TYPE_NORMAL
- en: The linkage of a declaration is either explicitly declared or implied. If you
    declare an entity at file scope without explicitly specifying <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>, the entity is
    implicitly given external linkage. Identifiers that have no linkage include function
    parameters, block scope identifiers declared without an <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>
    storage class specifier, or enumeration constants.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-1](chapter10.xhtml#Lis10-1) shows examples of declarations of each
    kind of linkage.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-1: Examples of internal,
    external, and no linkage</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If you explicitly declare an identifier with the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    storage class specifier at file scope, it has internal linkage. The <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    keyword gives internal linkage only to file scope entities. Declaring a variable
    at block scope as <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    creates an identifier with no linkage, but it does give the variable static storage
    duration. As a reminder, static storage duration means its lifetime is the entire
    execution of the program, and its stored value is initialized only once, prior
    to program startup. The different meanings of *static* when used in different
    contexts are obviously confusing and consequently a common interview question.
  prefs: []
  type: TYPE_NORMAL
- en: You can create an identifier with external linkage by declaring it with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> storage class specifier.
    This works only if you haven’t previously declared the linkage for that identifier.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> storage class
    specifier has no effect if a prior declaration gave the identifier linkage.
  prefs: []
  type: TYPE_NORMAL
- en: Declarations with conflicting linkage can lead to undefined behavior; see CERT
    C rule DCL36-C, “Do not declare an identifier with conflicting linkage classifications,”
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-2](chapter10.xhtml#Lis10-2) shows sample declarations with implicit
    linkage.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">foo.c</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-2: Examples of implicit
    linkage</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-3](chapter10.xhtml#Lis10-3) shows sample declarations with explicit
    linkage.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">bar.c</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-3: Examples of explicit
    linkage</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The identifiers in your public interface should have external linkage so that
    they can be called from outside their translation unit. Identifiers that are implementation
    details should be declared with internal or no linkage (provided they don’t need
    to be referenced from another translation unit). A common approach to achieving
    this is to declare your public interface functions in a header with or without
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> storage
    class specifier (the declarations implicitly have external linkage, but there
    is no harm in explicitly declaring them with <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>)
    and define the public interface functions in a source file in a similar manner.
  prefs: []
  type: TYPE_NORMAL
- en: However, within the source file, all declarations that are implementation details
    should be explicitly declared <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    to keep them private—accessible to just that source file. You can include the
    public interface declared within the header by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>
    preprocessor directive to access its interface from another file. A good rule
    of thumb is that file-scope entities that don’t need to be visible outside the
    file should be declared as <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>.
    This practice limits the global namespace pollution and decreases the chances
    of surprising interactions between translation units.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Structuring a Simple Program</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn how to structure a complex, real-world program, let’s develop a simple
    program to determine whether a number is prime. A *prime number* (or a *prime*)
    is a natural number that cannot be formed by multiplying two smaller natural numbers.
    We’ll write two separate components: a static library containing the testing functionality
    and a command line application that provides a user interface for the library.'
  prefs: []
  type: TYPE_NORMAL
- en: The *primetest* program accepts a whitespace-delimited list of integer values
    as input and then outputs whether each value is a prime number. If any of the
    inputs are invalid, the program will output a helpful message explaining how to
    use the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Before exploring how to structure the program, let’s examine the user interface.
    First, we print the help text for the command line program, as shown in [Listing
    10-4](chapter10.xhtml#Lis10-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-4: Printing help
    text</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">print_help</samp> function
    prints usage information about how to use the command to the standard output.
  prefs: []
  type: TYPE_NORMAL
- en: Next, because the command line arguments are passed to the program as textual
    input, we define a utility function to convert them to integer values, as shown
    in [Listing 10-5](chapter10.xhtml#Lis10-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-5: Converting a
    single command line argument</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_arg</samp> function
    accepts a string argument as input and uses an output parameter to report the
    converted argument. An *output parameter* returns a function result to the caller
    via a pointer, allowing multiple values to be returned in addition to the function
    return value. The function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    if the argument conversion succeeds and <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>
    if it fails. The <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_arg</samp>
    function uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">strtoull</samp>
    function to convert the string to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long long</samp> integer value and takes care to properly handle conversion errors.
    Additionally, because the definition of a prime number excludes 0, 1, and negative
    values, the <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_arg</samp> function
    treats those as invalid inputs.
  prefs: []
  type: TYPE_NORMAL
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_arg</samp>
    utility function in the <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_cmd_line_args</samp>
    function, shown in [Listing 10-6](chapter10.xhtml#Lis10-6), which loops over all
    the command line arguments provided and attempts to convert each argument from
    a string to an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-6: Processing all
    the command line arguments</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If any argument fails to convert, it calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">print_help</samp>
    function to report the proper command line usage to the user and then returns
    a null pointer. This function is responsible for allocating a sufficiently large
    buffer to hold the array of integers. It also handles all error conditions, such
    as running out of memory or failing to convert an argument. If the function succeeds,
    it returns an array of integers to the caller and writes the converted number
    of arguments into the <samp class="SANS_TheSansMonoCd_W5Regular_11">num_args</samp>
    parameter. The returned array is allocated storage and must be deallocated when
    no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to determine whether a number is prime. The naive approach
    is to test a value *N* by determining whether it is evenly divisible by [2..*N*
    – 1]. This approach has poor performance characteristics as the value of *N* gets
    larger. Instead, we’ll use one of the many algorithms designed for testing primality.
    [Listing 10-7](chapter10.xhtml#Lis10-7) shows a nondeterministic implementation
    of the Miller-Rabin primality test that’s suitable for quickly testing whether
    a value is probably prime (Schoof 2008). Please see the Schoof paper for an explanation
    of the mathematics behind the Miller-Rabin primality test algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-7: The Miller-Rabin
    primality test algorithm</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface to the Miller-Rabin primality test is the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_prime</samp>
    function shown in [Listing 10-8](chapter10.xhtml#Lis10-8). This function accepts
    two arguments: the number to test (<samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>)
    and the number of times to perform the test (<samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>).
    Larger values of <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp> provide
    a more accurate result but worsen performance. We’ll place the algorithm from
    [Listing 10-6](chapter10.xhtml#Lis10-6) in a static library, along with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">is_prime</samp> function, which will provide
    the library’s public interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-8: The interface
    to the Miller-Rabin primality test algorithm</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to compose these utility functions into a program. [Listing
    10-9](chapter10.xhtml#Lis10-9) shows the implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function. It uses a fixed number of iterations of the Miller-Rabin test and reports
    whether the input values are probably prime or definitely not prime. It also handles
    deallocating the memory allocated by <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_cmd_line_args</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-9: The</samp> <samp
    class="I">main</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function calls
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_cmd_line_args</samp>
    function to convert the command line arguments into an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long long</samp> integers. For each argument in this array, the program loops,
    calling <samp class="SANS_TheSansMonoCd_W5Regular_11">is_prime</samp> to determine
    whether each value is probably prime or not prime using the Miller-Rabin primality
    test implemented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_prime</samp>
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve implemented the program logic, we’ll produce the required build
    artifacts. Our goal is to produce a static library containing the Miller-Rabin
    implementation and a command line application driver.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Building the Code</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new file named *isprime.c* with the code from Listings 10-8 and 10-9
    (in that order), adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>
    directives for <samp class="SANS_TheSansMonoCd_W5Regular_11">"isprime.h"</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdlib.h></samp> at the top
    of the file. The quotes and angle brackets surrounding the headers are important
    for telling the preprocessor where to search for those files, as discussed in
    [Chapter 9](chapter9.xhtml). Next, create a header named *isprime.h* with the
    code from [Listing 10-10](chapter10.xhtml#Lis10-10) to provide the public interface
    for the static library, with a header guard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-10: The public interface
    for the static library</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named *driver.c* with the code from Listings 10-5, 10-6,
    10-7, and 10-10 (in that order), adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>
    directives for the following: <samp class="SANS_TheSansMonoCd_W5Regular_11">"isprime.h"</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><assert.h></samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11"><errno.h></samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdlib.h></samp> at the top
    of the file. All three files are in the same directory in our example, but in
    a real-world project, you would likely put the files in different directories,
    depending on the conventions of your build system. Create a local directory named
    *bin*, which is where the build artifacts from this example will be created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use Clang to create the static library and executable program, but both
    GCC and Clang support the command line arguments in the example, so either compiler
    will work. First, compile both C source files into object files placed in the
    *bin* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For older compilers, it may be necessary to replace <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c23</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c2x</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: If you execute the command and get an error such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: then create the local *bin* directory and try the command again. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp>
    flag instructs the compiler to compile the source into an object file without
    invoking the linker to produce executable output. We’ll need the object files
    to create a library. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-o</samp>
    flag specifies the pathname of the output file.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing the commands, the *bin* directory should contain two object
    files: *isprime.o* and *driver.o*. These files contain the object code for each
    translation unit. You could link them together directly to create the executable
    program. However, in this case, we’ll make a static library. To do this, execute
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ar</samp> command to generate
    the static library named *libPrimalityUtilities.a* in the *bin* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp> option instructs
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ar</samp> command to replace
    any existing files in the archive with the new files, the <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    option creates the archive, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    option writes an object-file index into the archive (which is equivalent to running
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ranlib</samp> command). This
    creates a single archive file that’s structured to allow retrieval of the original
    object files used to create the archive, like a compressed tarball or ZIP file.
    By convention, static libraries on Unix systems are prefixed with *lib* and have
    a *.a* file extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now link the driver object file to the *libPrimalityUtilities.a* static
    library to produce an executable named *primetest*. This can be accomplished either
    by invoking the compiler without the <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp>
    flag, which invokes the default system linker with the appropriate arguments,
    or by invoking the linker directly. Invoke the compiler to use the default system
    linker as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-L</samp> flag instructs the
    linker to look in the local *bin* directory for libraries to link, and the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-l</samp> flag instructs the linker to
    link the *libPrimalityUtilities.a* library to the output. Omit the *lib* prefix
    and the *.a* suffix from the command line argument because the linker adds them
    implicitly. For example, to link against the *libm* math library, specify <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-lm</samp> as the link target. As with
    compiling source files, the output of the linked files is specified by the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-o</samp> flag.
  prefs: []
  type: TYPE_NORMAL
- en: You can now test the program to see whether values are probably prime or definitely
    not prime. Be sure to try out cases like negative numbers, known prime and nonprime
    numbers, and incorrect input, as shown in [Listing 10-11](chapter10.xhtml#Lis10-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-11: Running the</samp>
    <samp class="SANS_Futura_Std_Book_11">primetest</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">program
    with sample input</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The number 8,675,309 is prime.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about the benefits of loose coupling, high cohesion,
    data abstractions, and code reuse. Additionally, you learned about related language
    constructs such as opaque data types and linkage. You were introduced to some
    best practices on how to structure the code in your projects and saw an example
    of building a simple program with different types of executable components. These
    skills are important as you transition from writing practice programs to developing
    and deploying real-world systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll learn how to use various tools and techniques to
    create high-quality systems, including assertions, debugging, testing, and static
    and dynamic analysis. These skills are all necessary to develop safe, secure,
    and performant modern systems.
  prefs: []
  type: TYPE_NORMAL
