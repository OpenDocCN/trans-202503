<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Online Account Management"><div class="titlepage"><div><div><h1 class="title"><a id="online_account_management"/>Chapter 8. Online Account Management</h1></div></div></div><p><a id="iddle1904" class="indexterm"/>While enterprise services usually employ PKI for user authentication, most publicly available online services rely on passwords to authenticate their users. However, typing complex passwords on a touch screen mobile device multiple times a day for different sites is not a very pleasant exercise.</p><p>In an effort to improve the user experience when accessing online services, Android provides a centralized registry of user accounts that can cache and reuse credentials. This account registry can be accessed by third-party applications, allowing them to access web services on behalf of the device user without the need for apps to handle passwords directly. In this chapter, we discuss how Android manages a user’s online account credentials and the APIs that applications can use to take advantage of cached credentials and to register custom accounts. We then show how Google experience devices (devices on which the Google Play Store is preinstalled) store Google account information and allow access to Google APIs and other online services by using the stored credentials.</p><div class="sect1" title="Android Account Management Overview"><div class="titlepage"><div><div><h1 class="title"><a id="android_account_management_overview"/>Android Account Management Overview</h1></div></div></div><p><a id="iddle1042" class="indexterm"/><a id="iddle1045" class="indexterm"/><a id="iddle1244" class="indexterm"/>While early Android devices had built-in support for Google accounts and automatic background data synchronization with Google services such as Gmail, no APIs for this functionality were originally provided. Android 2.0 (API Level 5) introduced the concept of centralized account management with a public API. The central piece in the API is the <code class="literal">AccountManager</code> class, which “provides access to a centralized registry of the user’s online accounts. The user enters credentials (username and password) once per account, granting applications access to online resources with ‘one-click’ approval.”<sup>[<a id="ch08fn01" href="#ftn.ch08fn01" class="footnote">78</a>]</sup> Another major feature of the class is that it lets you get an authentication token for supported accounts, allowing third-party applications to authenticate to online services without needing to actually handle the user password. On some older Android versions, the <code class="literal">AccountManager</code> would also monitor your SIM card and wipe cached credentials if you swapped cards, but this feature was removed in Android 2.3.4 and later versions.</p></div><div class="sect1" title="Account Management Implementation"><div class="titlepage"><div><div><h1 class="title"><a id="account_management_implementation"/>Account Management Implementation</h1></div></div></div><p>As with most Android system APIs, the <code class="literal">AccountManager</code> is just a facade for the <code class="literal">AccountManagerService</code>, which does the actual work. The service doesn’t provide an implementation for any particular form of authentication, though. It merely coordinates a number of pluggable authenticator modules for different account types (Google, Twitter, Microsoft Exchange, and so on). Any application can register an authenticator module by implementing an account authenticator and related classes, if needed. We show how to write and register a custom authenticator module in “<a class="xref" href="ch08.html#adding_an_authenticator_module" title="Adding an Authenticator Module">Adding an Authenticator Module</a>”.</p><p>Registering a new account type with the system lets you take advantage of a number of Android infrastructure services, including the ability to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Use a centralized credential storage in a system database</p></li><li class="listitem"><p>Issue tokens to third-party apps</p></li><li class="listitem"><p>Take advantage of Android’s automatic background synchronization (via a sync adapter)</p></li></ul></div><p><a class="xref" href="ch08.html#account_management_components" title="Figure 8-1. Account management components">Figure 8-1</a> shows the main components of Android’s account management subsystems and their relationships. Each component and its role will be described in the following sections.</p><div class="figure"><a id="account_management_components"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00029"/><img src="figs/web/08fig01.png.jpg" alt="Account management components"/></div></div><p class="title">Figure 8-1. Account management components</p></div><div class="sect2" title="AccountManagerService and AccountManager"><div class="titlepage"><div><div><h2 class="title"><a id="accountmanagerservice_and_accountmanager"/>AccountManagerService and AccountManager</h2></div></div></div><p><a id="iddle1021" class="indexterm"/><a id="iddle1024" class="indexterm"/><a id="iddle1046" class="indexterm"/><a id="iddle1050" class="indexterm"/>The central piece here is the <code class="literal">AccountManagerService</code>, which coordinates all other components and persists account data in the accounts database. The <code class="literal">AccountManager</code> class is the facade that exposes a subset of its functionality to third-party applications. It starts worker threads for asynchronous methods and posts the results (or error details) back to the caller. Additionally, <code class="literal">AccountManager</code> shows an account chooser when the requested token or feature can be provided by more than one account. However, it doesn’t enforce any permissions; all caller permissions are checked by the <code class="literal">AccountManagerService</code> and we’ll discuss the concrete permissions shortly.</p></div><div class="sect2" title="Authenticator Modules"><div class="titlepage"><div><div><h2 class="title"><a id="authenticator_modules"/>Authenticator Modules</h2></div></div></div><p><a id="iddle1004" class="indexterm"/><a id="iddle1018" class="indexterm"/><a id="iddle1031" class="indexterm"/><a id="iddle1032" class="indexterm"/><a id="iddle1047" class="indexterm"/><a id="iddle1246" class="indexterm"/><a id="iddle1247" class="indexterm"/><a id="iddle1942" class="indexterm"/><a id="iddle2404" class="indexterm"/><a id="iddle2603" class="indexterm"/>As mentioned above, the functionality of each registered account is provided by a pluggable authenticator module, but what exactly is an authenticator module? <span class="emphasis"><em>Authenticator modules</em></span> are defined and hosted by applications, and each is simply a bound service that implements the <code class="literal">android.accounts.IAccountAuthenticator</code> AIDL interface. This interface has methods for adding an account, prompting the user for their credentials, getting an authentication token, and for updating account metadata. In practice, applications don’t implement this interface directly, but instead extend the <code class="literal">android.accounts.AbstractAccountAuthenticator</code> class which links implementation methods to an internal AIDL stub.</p><p>The <code class="literal">AbstractAccountAuthenticator</code> also ensures that all callers of the AIDL stub hold the <code class="literal">ACCOUNT_MANAGER</code> permission; a system signature permission that only allows system components to call authenticator modules directly. All other clients need to go through the <code class="literal">AccountManagerService</code>.</p><p>Each authenticator module implements an account identified uniquely by a string called the <span class="emphasis"><em>account type</em></span>. Account types are typically in reverse domain notation (like Java packages) and are usually named using the base package name of the defining application concatenated with the account type, or the <span class="emphasis"><em>account</em></span> or <span class="emphasis"><em>auth</em></span> strings (Android does not enforce this rule, however, and there are no explicit guidelines). For example, in <a class="xref" href="ch08.html#account_management_components" title="Figure 8-1. Account management components">Figure 8-1</a>, the <code class="literal">com.example.app</code> application defines an account with type <code class="literal">com.example.account</code>, and the <code class="literal">org.foo.app</code> application defines an account with type <code class="literal">org.foo.account</code>.</p><p>Authenticator modules are implemented by adding a service that can be bound to by using the <span class="emphasis"><em>android.accounts.AccountAuthenticator</em></span> intent action to the host application. The account type, as well as other metadata, is linked to the service by adding a <code class="literal">&lt;meta-data&gt;</code> tag to the service declaration. The <code class="literal">resource</code> attribute of the tag points to an XML file that contains account metadata (see <a class="xref" href="ch08.html#declaring_an_account_authenticator_servi" title="Example 8-8. Declaring an account authenticator service in AndroidManifest.xml">Example 8-8</a> for an example).</p><div class="note" title="Note"><h3 class="title"><a id="ch08note01"/>Note</h3><p><span class="emphasis"><em>A</em></span> <span class="emphasis"><em><code class="literal">&lt;meta-data&gt;</code></em></span> <span class="emphasis"><em>tag allows a name-value pair containing arbitrary data to be associated with its parent component. The data can be a literal value, such as a string or an integer, or a reference to an Android resource file. Multiple</em></span> <span class="emphasis"><em><code class="literal">&lt;meta-data&gt;</code></em></span> <span class="emphasis"><em>tags per component are also supported. The values from all</em></span> <span class="emphasis"><em><code class="literal">&lt;meta-data&gt;</code></em></span> <span class="emphasis"><em>tags are collected in a single</em></span> <span class="emphasis"><em><code class="literal">Bundle</code></em></span> <span class="emphasis"><em>object and made available as the</em></span> <span class="emphasis"><em><code class="literal">metaData</code></em></span> <span class="emphasis"><em>field of the</em></span> <span class="emphasis"><em><code class="literal">PackageItemInfo</code></em></span> <span class="emphasis"><em>class (the base class of concrete classes that encapsulate component attribute values, such as</em></span> <span class="emphasis"><em><code class="literal">ServiceInfo</code></em></span><span class="emphasis"><em>). The interpretation of the associated metadata is component-specific.</em></span></p></div></div><div class="sect2" title="The Authenticator Module Cache"><div class="titlepage"><div><div><h2 class="title"><a id="authenticator_module_cache"/>The Authenticator Module Cache</h2></div></div></div><p>“Pluggability” is provided by the <code class="literal">AccountAuthenticatorCache</code> class, which scans for packages that define authenticator modules and makes them available to the <code class="literal">AccountManagerService</code>. The <code class="literal">AccountAuthenticatorCache</code> is one implementation of the more general registered service cache facility that Android provides. The cache is built on demand (lazily) by interrogating the <code class="literal">PackageManagerService</code> about installed packages that register a particular intent action and metadata file. The cache is kept up-to-date by a broadcast <a id="iddle1019" class="indexterm"/><a id="iddle1020" class="indexterm"/>receiver that triggers an update when packages are added, updated, or removed. The cache is persistent and written to disk each time a change is detected, with cache files written to the <span class="emphasis"><em>/data/system/registered_services/</em></span> directory and named after the intent action they scan for. The authenticator module cache is saved to the <span class="emphasis"><em>android.accounts.AccountAuthenticator.xml</em></span> file and might look like <a class="xref" href="ch08.html#contents_of_the_accountauthenticatordotx" title="Example 8-1. Contents of the AccountAuthenticator.xml registered services cache file">Example 8-1</a>.</p><div class="example"><a id="contents_of_the_accountauthenticatordotx"/><p class="title">Example 8-1. <span class="emphasis"><em>Contents of the</em></span> AccountAuthenticator.xml <span class="emphasis"><em>registered services cache file</em></span></p><div class="example-contents"><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;
&lt;services&gt;
    &lt;service uid="10023" type="com.android.exchange" /&gt;➊
    &lt;service uid="10023" type="com.android.email" /&gt;➋
    &lt;service uid="10069" type="com.example.account" /&gt;➌
    &lt;service uid="10074" type="org.foo.account" /&gt;➍
    --<span class="emphasis"><em>snip</em></span>--
    &lt;service uid="1010023" type="com.android.email" /&gt;➎
    &lt;service uid="1010023" type="com.android.exchange" /&gt;➏
    &lt;service uid="1010069" type="com.example.account" /&gt;➐
    --<span class="emphasis"><em>snip</em></span>--
&lt;/services&gt;</pre></div></div><p>Here, the <span class="emphasis"><em>com.android.exchange</em></span> and <span class="emphasis"><em>com.android.email</em></span> account types (➊ and ➋) are registered by the stock Email application, and <span class="emphasis"><em>com.example. account</em></span> and <span class="emphasis"><em>org.foo.account</em></span> (➌ and ➍) are registered by third-party applications. On a multi-user device, the cache file will have entries for the accounts available to each user.</p><p>In this example, the first secondary user (user ID 10) can use <span class="emphasis"><em>com.android.exchange</em></span>, <span class="emphasis"><em>com.android.email</em></span>, and <span class="emphasis"><em>com.example.account</em></span> (➎, ➏, and ➐), but not the <span class="emphasis"><em>org.foo.account</em></span> account (because there is no entry for it in the file). When the <code class="literal">AccountManagerService</code> needs to perform an action with a particular account, it queries the <code class="literal">AccountAuthenticatorCache</code> for the implementing service by passing the account type. If an account implementation for that type is registered for the current user, <code class="literal">AccountAuthenticatorCache</code> returns details about the implementing service that contain the name of the implementing component and the UID of the host package. The <code class="literal">AccountManagerService</code> uses this information to bind to the service in order to be able to call methods of the <code class="literal">IAccountAuthenticator</code> interface that the service implements.</p></div><div class="sect2" title="AccountManagerService Operations and Permissions"><div class="titlepage"><div><div><h2 class="title"><a id="accountmanagerservice_operations_and_per"/>AccountManagerService Operations and Permissions</h2></div></div></div><p>As shown in <a class="xref" href="ch08.html#account_management_components" title="Figure 8-1. Account management components">Figure 8-1</a>, <code class="literal">AccountManagerService</code> implements its functionality by either calling into authenticator modules or by using cached data from the accounts database. Third-party components can only use the API that <code class="literal">AccountManagerService</code> exposes; they can’t access authenticator modules or the accounts database. This centralized interface guarantees operation workflow and enforces access rules for each operation.</p><p><code class="literal">AccountManagerService</code> implements access control using a combination of permissions and caller UID and signature checks. Let’s look at the operations it provides and the respective permission checks.</p><div class="sect3" title="Listing and Authenticating Accounts"><div class="titlepage"><div><div><h3 class="title"><a id="listing_and_authenticating_accounts"/>Listing and Authenticating Accounts</h3></div></div></div><p><a id="iddle1022" class="indexterm"/><a id="iddle1023" class="indexterm"/><a id="iddle1048" class="indexterm"/><a id="iddle1049" class="indexterm"/><a id="iddle1098" class="indexterm"/><a id="iddle1102" class="indexterm"/><a id="iddle1241" class="indexterm"/><a id="iddle1627" class="indexterm"/><a id="iddle1852" class="indexterm"/><a id="iddle1877" class="indexterm"/><a id="iddle1887" class="indexterm"/><a id="iddle2180" class="indexterm"/><a id="iddle2436" class="indexterm"/><a id="iddle2770" class="indexterm"/><a id="iddle2788" class="indexterm"/><a id="iddle2794" class="indexterm"/>Clients can get a list of accounts that match certain criteria (including type, declaring package, and other features) by calling one of the <code class="literal">getAccounts()</code> methods, and they can check to see if a particular account has the required features by calling the <code class="literal">hasFeatures()</code> method. These operations require the <code class="literal">GET_ACCOUNTS</code> permission, which has the <span class="emphasis"><em>normal</em></span> protection level. A new account of a particular type can be added by calling the <code class="literal">addAccount()</code> method (which starts an implementation-specific <span class="emphasis"><em>authenticator activity</em></span> that collects credentials from the user) or silently by calling the <code class="literal">addAccountExplicitly()</code> method, which takes the account, password, and any associated user data as parameters. The first method requires callers to hold the <code class="literal">MANAGE_ACCOUNTS</code> permission, and the second requires that they both hold the <code class="literal">AUTHENTICATE_ACCOUNTS</code> permission and have the same UID as the account’s authenticator. Both permissions have protection level <span class="emphasis"><em>dangerous</em></span> and therefore require user confirmation when the app is installed. Requiring callers of <code class="literal">addAccountExplicitly()</code> to have the same UID as the authenticator ensures that only the same app, or apps that belong to the same shared user ID (see <a class="xref" href="ch02.html" title="Chapter 2. Permissions">Chapter 2</a> for details), can add accounts without user interaction.</p><p>Other operations that require the caller to both hold the <code class="literal">AUTHENTICATE_ ACCOUNTS</code> permission and have the same UID as the account’s authenticator are listed below. (We’ve omitted <code class="literal">AccountManager</code> method parameters here and in the following sections for clarity. See the reference documentation of the <code class="literal">AccountManager</code> class<sup>[<a id="ch08fn02" href="#ftn.ch08fn02" class="footnote">79</a>]</sup> for full method signatures and additional information.)</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="getPassword()"><span class="title"><strong><span class="strong"><strong><code class="literal">getPassword()</code></strong></span></strong></span>. Returns the raw cached password.</p></li><li class="listitem"><p title="getUserData()"><span class="title"><strong><span class="strong"><strong><code class="literal">getUserData()</code></strong></span></strong></span>. Returns authenticator-specific account metadata that matches a specified key.</p></li><li class="listitem"><p title="peekAuthToken()"><span class="title"><strong><span class="strong"><strong><code class="literal">peekAuthToken()</code></strong></span></strong></span>. Returns a cached token of the specified type (if available).</p></li><li class="listitem"><p title="setAuthToken()"><span class="title"><strong><span class="strong"><strong><code class="literal">setAuthToken()</code></strong></span></strong></span>. Adds or replaces an authentication token for an account.</p></li><li class="listitem"><p title="setPassword()"><span class="title"><strong><span class="strong"><strong><code class="literal">setPassword()</code></strong></span></strong></span>. Sets or clears the cached password for an account.</p></li><li class="listitem"><p title="setUserData()"><span class="title"><strong><span class="strong"><strong><code class="literal">setUserData()</code></strong></span></strong></span>. Sets or clears the metadata entry with the specified key.</p></li></ul></div></div><div class="sect3" title="Managing Accounts"><div class="titlepage"><div><div><h3 class="title"><a id="managing_accounts"/>Managing Accounts</h3></div></div></div><p>Just as when adding a new account, removing an existing account requires the <code class="literal">MANAGE_ACCOUNTS</code> permission. However, if the calling device user has the <code class="literal">DISALLOW_MODIFY_ACCOUNTS</code> restriction set (see <a class="xref" href="ch04.html" title="Chapter 4. User Management">Chapter 4</a> for more details on user restrictions), they cannot add or remove accounts, even if the calling application holds the <code class="literal">MANAGE_ACCOUNTS</code> permission. Other methods that require this permission are those that modify account properties or credentials as listed next.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="clearPassword()"><span class="title"><strong><span class="strong"><strong><code class="literal">clearPassword()</code></strong></span></strong></span>. <a id="iddle1026" class="indexterm"/><a id="iddle1052" class="indexterm"/><a id="iddle1393" class="indexterm"/><a id="iddle1415" class="indexterm"/><a id="iddle1699" class="indexterm"/><a id="iddle1855" class="indexterm"/><a id="iddle1984" class="indexterm"/><a id="iddle2181" class="indexterm"/><a id="iddle2593" class="indexterm"/><a id="iddle2982" class="indexterm"/><a id="iddle2997" class="indexterm"/>Clears a cached password.</p></li><li class="listitem"><p title="confirmCredentials()"><span class="title"><strong><span class="strong"><strong><code class="literal">confirmCredentials()</code></strong></span></strong></span>. Explicitly confirms that the user knows the password (even if it is already cached) by showing a password entry UI.</p></li><li class="listitem"><p title="editProperties()"><span class="title"><strong><span class="strong"><strong><code class="literal">editProperties()</code></strong></span></strong></span>. Shows a UI that allows the user to change global authenticator settings.</p></li><li class="listitem"><p title="invalidateAuthToken()"><span class="title"><strong><span class="strong"><strong><code class="literal">invalidateAuthToken()</code></strong></span></strong></span>. Removes an authentication token from the cache. (This can also be called if the caller holds the <code class="literal">USE_CREDENTIALS</code> permission.)</p></li><li class="listitem"><p title="removeAccount()"><span class="title"><strong><span class="strong"><strong><code class="literal">removeAccount()</code></strong></span></strong></span>. Removes an existing account.</p></li><li class="listitem"><p title="updateCredentials()"><span class="title"><strong><span class="strong"><strong><code class="literal">updateCredentials()</code></strong></span></strong></span>. Asks the user the enter the current password and updates the saved credentials accordingly.</p></li></ul></div></div><div class="sect3" title="Using Account Credentials"><div class="titlepage"><div><div><h3 class="title"><a id="using_account_credentials"/>Using Account Credentials</h3></div></div></div><p>The final permission the <code class="literal">AccountManagerService</code> might require its clients to hold is <code class="literal">USE_CREDENTIALS</code>. This permission protects methods that return or modify <span class="emphasis"><em>authentication tokens</em></span>, a service-dependent credential string that clients can use to authenticate requests to the server without sending their password with each request.</p><p>Typically, servers return an authentication token after the client successfully authenticates with their username and password (or other permanent credentials). The token is identified by a string called the <span class="emphasis"><em>token type</em></span>, which describes what type of access the token grants (for example, read-only or read-write). The token is reusable and can be used for sending multiple requests, but might have a limited validity period. Additionally, if a user account is believed to have been compromised, or if a user changes their password, all existing authentication tokens for that user are usually invalidated on the server. In this case, requests that use cached authentication tokens will fail with an authentication error. Because the <code class="literal">AccountManagerService</code> is protocol- and application-agnostic, it doesn’t automatically invalidate cached tokens, even if they have expired or been invalidated on the server. Applications are responsible for cleaning up such invalid cached tokens by calling the <code class="literal">invalidateAuthToken()</code> method.</p><p>These are the methods that require <code class="literal">USE_CREDENTIALS</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="getAuthToken()"><span class="title"><strong><span class="strong"><strong><code class="literal">getAuthToken()</code></strong></span></strong></span>. Gets an authentication token of the specified type for a particular account.</p></li><li class="listitem"><p title="invalidateAuthToken()"><span class="title"><strong><span class="strong"><strong><code class="literal">invalidateAuthToken()</code></strong></span></strong></span>. Removes an authentication token from the cache. (This can also be called if the caller holds the <code class="literal">MANAGE_ACCOUNTS</code> permission.)</p></li></ul></div><div class="figure"><a id="account_access_request_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00030"/><img src="figs/web/08fig02.png.jpg" alt="Account access request dialog"/></div></div><p class="title">Figure 8-2. Account access request dialog</p></div></div><div class="sect3" title="Requesting Authentication Token Access"><div class="titlepage"><div><div><h3 class="title"><a id="requesting_authentication_token_access"/>Requesting Authentication Token Access</h3></div></div></div><p><a id="iddle1025" class="indexterm"/><a id="iddle1051" class="indexterm"/><a id="iddle2998" class="indexterm"/>Besides holding the <code class="literal">USE_CREDENTIALS</code> permission, in order to obtain an authentication token of a particular type, callers of the <code class="literal">getAuthToken()</code> (or any of its wrapper methods as provided by the <code class="literal">AccountManager</code> facade class) must explicitly be granted access to the requested token type. This is accomplished by showing a confirmation dialog like the one shown in <a class="xref" href="ch08.html#account_access_request_dialog" title="Figure 8-2. Account access request dialog">Figure 8-2</a>. The dialog shows both the name of the requesting application (in the first bullet, “Account Requestor,” in this example), the account type and name (in the second bullet, “Example” and “example_user”, respectively), and a short description (below the bullets, “Full access to example data”) of the type of data access that will be permitted if the access request is granted. If the user grants access, this decision is cached and the dialog won’t be shown if a token of the same type is requested again. Applications running under the same UID as the authenticator module are allowed access to its tokens without showing a confirmation dialog. Additionally, privileged system applications are implicitly allowed access to all token types without user confirmation, so the dialog is not shown if the token request comes from a privileged application.</p></div></div><div class="sect2" title="The Accounts Database"><div class="titlepage"><div><div><h2 class="title"><a id="accounts_database"/>The Accounts Database</h2></div></div></div><p>We’ve introduced authenticator modules, the authenticator cache, and the main features of the <code class="literal">AccountManagerService</code>. Now let’s see how this service uses the <span class="emphasis"><em>accounts database</em></span>, an SQLite database stored in each user’s system directory with the <span class="emphasis"><em>accounts.db</em></span> filename, to register accounts and cache credentials.</p><p>The accounts database is found at <span class="emphasis"><em>/data/system/users/0/accounts.db</em></span> on single-user devices. On multi-user devices, this file stores account information for the primary user, and secondary users each have their own instance at <span class="emphasis"><em>/data/system/users/&lt;user ID&gt;/accounts.db</em></span>. The database consists of six tables: <code class="literal">accounts</code>, <code class="literal">extras</code>, <code class="literal">authtokens</code>, <code class="literal">grants</code>, <code class="literal">shared_users</code>, and <code class="literal">meta</code>. As of this writing, the <code class="literal">meta</code> table appears to be unused; all other tables and their relationships are shown in <a class="xref" href="ch08.html#account_management_components" title="Figure 8-1. Account management components">Figure 8-1</a>.</p><div class="sect3" title="Table Schema"><div class="titlepage"><div><div><h3 class="title"><a id="table_schema"/>Table Schema</h3></div></div></div><p><a id="iddle1029" class="indexterm"/><a id="iddle1055" class="indexterm"/><a id="iddle1249" class="indexterm"/><a id="iddle1913" class="indexterm"/>The <code class="literal">accounts</code> table stores the name, type, and password of registered accounts, and all other tables directly or indirectly link to it. It might contain data similar to <a class="xref" href="ch08.html#contents_of_the_accounts_table" title="Example 8-2. Contents of the accounts table">Example 8-2</a>.</p><div class="example"><a id="contents_of_the_accounts_table"/><p class="title">Example 8-2. Contents of the accounts table</p><div class="example-contents"><pre class="programlisting"><span class="strong"><strong>sqlite&gt; select * from accounts;</strong></span>
_id|name             |type                   |password
1  |user1@gmail.com  |com.google             |1/......➊
2  |user1@example.com|com.google.android.pop3|password➋
3  |example_user     |com.example.account    |pass1234➌</pre></div></div><p>Here, ➊ is a Google account (type <span class="emphasis"><em>com.google</em></span>) which allows access to Gmail, the Google Play Store, and other Google services. Google accounts depend on proprietary system components and are only available on Google experience devices. (You’ll find more details on Google accounts in “<a class="xref" href="ch08.html#google_login_service" title="The Google Login Service">The Google Login Service</a>”.) The account at ➋ is a POP3 mail account (type <span class="emphasis"><em>com.google.android.pop3</em></span>) registered by the stock email application, and ➌ is a custom account (type <span class="emphasis"><em>com.example.account</em></span>) registered by a third-party application. Each account can be associated with zero or more metadata key-value pairs that are stored in the <code class="literal">extras</code> table and link to the account by using its primary key (in the <code class="literal">_id</code> column). For example, if our custom application (➌ in <a class="xref" href="ch08.html#contents_of_the_accounts_table" title="Example 8-2. Contents of the accounts table">Example 8-2</a>, <code class="literal">_id=3</code>) does background data synchronization, it might have entries similar to those in <a class="xref" href="ch08.html#contents_of_the_extras_table" title="Example 8-3. Contents of the extras table">Example 8-3</a>.</p><div class="example"><a id="contents_of_the_extras_table"/><p class="title">Example 8-3. Contents of the <code class="literal">extras</code> table</p><div class="example-contents"><pre class="programlisting"><span class="strong"><strong>sqlite&gt; select * from extras where accounts_id=3;</strong></span>
_id|accounts_id|key      |value
11 |3          |device_id|0123456789
12 |3          |last_sync|1395297374
13 |3          |user_id  |abcdefghij
14 |3          |option1  |1</pre></div></div><p>The <code class="literal">authtokens</code> table stores tokens that have been issued for an account. For our custom application, it might look like <a class="xref" href="ch08.html#contents_of_the_authtokens_table" title="Example 8-4. Contents of the authtokens table">Example 8-4</a>.</p><div class="example"><a id="contents_of_the_authtokens_table"/><p class="title">Example 8-4. Contents of the <code class="literal">authtokens</code> table</p><div class="example-contents"><pre class="programlisting"><span class="strong"><strong>sqlite&gt; select * from authtokens where accounts_id=3;</strong></span>
_id|accounts_id|type            |authtoken
16 |3          |com.example.auth|abcdefghij0123456789</pre></div></div><p>The <code class="literal">grants</code> table associates application UIDs with the types of tokens they’re allowed to use. Grants are added when the user OK’s the access confirmation dialog for a particular account type and token (see <a class="xref" href="ch08.html#account_access_request_dialog" title="Figure 8-2. Account access request dialog">Figure 8-2</a>). For example, if an application with UID 10291 has requested and been granted access to tokens of type <span class="emphasis"><em>com.example.auth</em></span> as in our sample application (see <a id="iddle1028" class="indexterm"/><a id="iddle1054" class="indexterm"/><a id="iddle1394" class="indexterm"/><a id="iddle1856" class="indexterm"/><a id="iddle1878" class="indexterm"/><a id="iddle2789" class="indexterm"/><a id="iddle2811" class="indexterm"/><a class="xref" href="ch08.html#contents_of_the_authtokens_table" title="Example 8-4. Contents of the authtokens table">Example 8-4</a>), the grant will be represented by the following row in the <code class="literal">grants</code> table (see <a class="xref" href="ch08.html#contents_of_the_grants_table" title="Example 8-5. Contents of the grants table">Example 8-5</a>). A new row is added for each combination of account ID, token type, and granted application UID.</p><div class="example"><a id="contents_of_the_grants_table"/><p class="title">Example 8-5. Contents of the <code class="literal">grants</code> table</p><div class="example-contents"><pre class="programlisting">sqlite&gt; <span class="strong"><strong>select * from grants;</strong></span>
accounts_id|auth_token_type |uid
3          |com.example.auth|10291</pre></div></div><p>The <code class="literal">shared_accounts</code> table is used when sharing the device owner’s accounts with one of the restricted users on the device. (You’ll find more details on its contents and usage in “<a class="xref" href="ch08.html#multi-user_support-id00015" title="Multi-User Support">Multi-User Support</a>”.)</p></div><div class="sect3" title="Table Access"><div class="titlepage"><div><div><h3 class="title"><a id="table_access"/>Table Access</h3></div></div></div><p>Now we’ll examine the relationship between tables and data in the accounts database and the key methods of the <code class="literal">AccountManagerService</code>. At a high level the relationship is fairly straightforward (if we ignore caching and synchronization): methods that retrieve or manipulate account details access the <code class="literal">accounts</code> table, and methods that handle user data associated with an account access the <code class="literal">extras</code> table. APIs that handle authentication tokens access the <code class="literal">authtokens</code> table, and save per-application token access grants in the <code class="literal">grants</code> table. We describe each method and the data it accesses next.</p><p>When you add an account of a particular type by calling one of the <code class="literal">addAccount()</code> methods, the <code class="literal">AccountManagerService</code> inserts a row in the <code class="literal">accounts</code> table containing its type, username, and password. Calling one of the <code class="literal">getPassword()</code>, <code class="literal">setPassword()</code>, or <code class="literal">clearPassword()</code> methods results in the <code class="literal">AccountManagerService</code> accessing or updating the <code class="literal">password</code> column of the <code class="literal">accounts</code> table. If you get or set user data for the account using the <code class="literal">getUserdata()</code> or <code class="literal">setUserdata()</code> methods, the <code class="literal">AccountManagerService</code> fetches the matching entry from or saves it to the <code class="literal">extras</code> table.</p><p>When you request a token for a particular account, things become a bit more complex. If a token with the specified type has never been issued before, <code class="literal">AccountManagerService</code> shows a confirmation dialog (see <a class="xref" href="ch08.html#account_access_request_dialog" title="Figure 8-2. Account access request dialog">Figure 8-2</a>) asking the user to approve access for the requesting application. If they accept, the UID of the requesting app and the token type are saved to the <code class="literal">grants</code> table. (Authenticators can declare that they use custom tokens by setting the <code class="literal">customTokens</code> account metadata attribute to <code class="literal">true</code>. In this case, they’re responsible for managing tokens, and Android neither shows the token access dialog nor automatically saves tokens to the <code class="literal">authtokens</code> table). If a grant already exits, <code class="literal">AccountManagerService</code> checks the <code class="literal">authtokens</code> table for tokens matching the request. If a valid one exists, it’s returned. If a matching token is not found, the <code class="literal">AccountManagerService</code> finds the authenticator for the specified account type in the cache and calls its <code class="literal">getAuthToken()</code> method to request a token. This usually involves the authenticator fetching the user-name and password from the <code class="literal">accounts</code> table (via the <code class="literal">getPassword()</code> method) and calling its respective online service to get a fresh token. When a token is returned, it gets cached in the <code class="literal">authtokens</code> table and then is returned to the <a id="iddle1027" class="indexterm"/><a id="iddle1039" class="indexterm"/><a id="iddle1053" class="indexterm"/><a id="iddle1250" class="indexterm"/><a id="iddle1879" class="indexterm"/><a id="iddle2238" class="indexterm"/><a id="iddle2594" class="indexterm"/>requesting app (usually asynchronously via a callback). Invalidating a token results in deleting the row that stores it from the <code class="literal">authtokens</code> table. Finally, when an account is removed by calling the <code class="literal">removeAccount()</code> method, its row is deleted from the <code class="literal">accounts</code> table and a database trigger cleans up all linked rows from the <code class="literal">authtokens</code>, <code class="literal">extras</code>, and <code class="literal">grants</code> tables.</p></div><div class="sect3" title="Password Security"><div class="titlepage"><div><div><h3 class="title"><a id="password_security"/>Password Security</h3></div></div></div><p>One thing to note is that while credentials (usually usernames and passwords) are stored in a central database under <span class="emphasis"><em>/data/system/</em></span> that is only accessible to system applications, credentials are not encrypted; encrypting or otherwise protecting credentials is left to the authenticator module to implement as necessary. In fact, if you have a rooted device, you’ll likely find that a listing of the contents of the accounts table will show certain passwords in cleartext, especially for the stock email application (the <code class="literal">com.android.email</code> or <code class="literal">com.google.android.email</code> package). For example, in <a class="xref" href="ch08.html#contents_of_the_accounts_table" title="Example 8-2. Contents of the accounts table">Example 8-2</a>, the strings <span class="emphasis"><em>password</em></span> ➋ and <span class="emphasis"><em>pass1234</em></span> ➌ are the cleartext passwords for a POP account used by the stock application and a custom <span class="emphasis"><em>com.example.account</em></span> account, respectively.</p><div class="note" title="Note"><h3 class="title"><a id="ch08note02"/>Note</h3><p><span class="emphasis"><em>Email applications may need to store the password instead of a password hash or an authentication token in order to support several challenge-response authentication methods that take the password as input, such as DIGEST-MD5 and CRAM-MD5.</em></span></p></div><p>Because the <code class="literal">AccountManger.getPassword()</code> method can be called only by apps with the same UID as the account’s authenticator, cleartext passwords are not accessible to other applications at runtime, but they may be included in backups or device dumps. In order to avoid this potential security risk, applications can encrypt passwords with a device-specific key or choose to replace a password with a revokable master token after initial authentication succeeds. For example, the official Twitter client does not store the user password in the <code class="literal">accounts</code> table, but only saves obtained authentication tokens (in the <code class="literal">authtokens</code> table). Google accounts are another example (account type <span class="emphasis"><em>com.google</em></span>): as shown in “<a class="xref" href="ch08.html#google_login_service" title="The Google Login Service">The Google Login Service</a>”, instead of the user password, Google accounts store a master token that is exchanged for service-specific authentication tokens.</p></div></div><div class="sect2" title="Multi-User Support"><div class="titlepage"><div><div><h2 class="title"><a id="multi-user_support-id00015"/>Multi-User Support</h2></div></div></div><p>Recall from <a class="xref" href="ch04.html" title="Chapter 4. User Management">Chapter 4</a> that on multi-user devices, Android allows each user to have their own set of applications, application data, and system settings. This user isolation extends to online accounts as well and users can have their own accounts registered with the system’s account manager service. Android 4.3 added support for restricted profiles, which are not fully independent users but share installed applications with the primary user. Additionally, restricted profiles can have a number of restrictions applied. Apps that use the <code class="literal">AccountManager</code> APIs can add explicit support for restricted <a id="iddle1005" class="indexterm"/><a id="iddle1040" class="indexterm"/><a id="iddle1041" class="indexterm"/><a id="iddle1101" class="indexterm"/><a id="iddle1851" class="indexterm"/><a id="iddle2239" class="indexterm"/><a id="iddle2240" class="indexterm"/><a id="iddle2812" class="indexterm"/>profiles, thus allowing restricted profiles to see and use a subset of the primary user’s accounts within supported apps. We explain this feature in detail in “Shared Accounts” below.</p><p>The following sections discuss how Android implements account isolation and sharing on multi-user devices.</p><div class="sect3" title="Per-User Account Databases"><div class="titlepage"><div><div><h3 class="title"><a id="per-user_account_databases"/>Per-User Account Databases</h3></div></div></div><p>As mentioned in “<a class="xref" href="ch08.html#accounts_database" title="The Accounts Database">The Accounts Database</a>”, the accounts databases that <code class="literal">AccountManagerServices</code> uses to store account information and cache authentication tokens are stored in each user’s system directory in <span class="emphasis"><em>/data/system/users/&lt;user ID&gt;/accounts.db</em></span>. This allows each user to have dedicated account storage, and different users might even have separate instances of the same type of online account. Aside from the database location, everything else works in exactly the same way as it does for the owner user, including permissions, access grants, and so on. When a user is removed, the system deletes all of its data, including the accounts database.</p></div><div class="sect3" title="Shared Accounts"><div class="titlepage"><div><div><h3 class="title"><a id="shared_accounts"/>Shared Accounts</h3></div></div></div><p>Primary user accounts are shared with a restricted profile by simply cloning the account data into the restricted profile’s accounts database. Thus, restricted profiles do not access the primary user’s account data directly, but have their own copy. When a new restricted profile is added, the name and type of all current accounts of the primary user are copied into the <code class="literal">shared_accounts</code> table of the restricted profile’s accounts database. However, because the new user is not started yet, the <code class="literal">accounts</code> table is empty at this point and the shared accounts are not yet usable.</p><p>The <code class="literal">shared_accounts</code> table has the same structure as the <code class="literal">accounts</code> table, without the <code class="literal">password</code> column. It might look like <a class="xref" href="ch08.html#contents_of_the_sharedunderscoreaccounts" title="Example 8-6. Contents of the shared_accounts table">Example 8-6</a> for a restricted profile.</p><div class="example"><a id="contents_of_the_sharedunderscoreaccounts"/><p class="title">Example 8-6. Contents of the <code class="literal">shared_accounts</code> table</p><div class="example-contents"><pre class="programlisting"><span class="strong"><strong>sqlite&gt; select * from shared_accounts;</strong></span>
_id|name             |type
1  |user1@gmail.com  |com.google
2  |user1@example.com|com.google.android.pop3
3  |example_user     |com.example.account</pre></div></div><p>Shared accounts are not cloned directly by copying data from the owner’s <code class="literal">accounts</code> table; instead, cloning is performed via the authenticator that declared the account. By default, the <code class="literal">AbstractAccountAuthenticator</code>, which all authenticator classes derive from, does not support account cloning.</p><p>Implementations that want to support shared accounts for restricted profiles need to do so explicitly, by overriding a couple of methods that were introduced in Android 4.3, along with restricted profile support: <code class="literal">getAccountCredentialsForCloning()</code>, which returns a <code class="literal">Bundle</code> containing all data needed to clone the account, and <code class="literal">addAccountFromCredentials()</code>, which receives this <code class="literal">Bundle</code> as a parameter and is responsible for creating the account based <a id="iddle1006" class="indexterm"/><a id="iddle1030" class="indexterm"/><a id="iddle1099" class="indexterm"/><a id="iddle1103" class="indexterm"/><a id="iddle1245" class="indexterm"/><a id="iddle1943" class="indexterm"/><a id="iddle2609" class="indexterm"/><a id="iddle2978" class="indexterm"/>on credentials in the <code class="literal">Bundle</code>. The <code class="literal">AccountManagerService</code> delays the cloning of a shared account until a restricted user is actually started. If the owner user adds any new accounts, they are added to the <code class="literal">shared_accounts</code> table and similarly cloned.</p><p>Even when accounts are successfully cloned, they may not be available to an application started by a restricted profile. Recall from <a class="xref" href="ch04.html" title="Chapter 4. User Management">Chapter 4</a> that if an application wants to support shared accounts, it must explicitly declare the account type it requires with the <code class="literal">restrictedAccountType</code> attribute of the <code class="literal">&lt;application&gt;</code> manifest tag. The <code class="literal">AccountManagerServices</code> uses the value of the <code class="literal">restrictedAccountType</code> attribute to filter accounts before passing them to applications running within a restricted profile. As of this writing, an application can declare only one type of account with this attribute.</p><div class="note" title="Note"><h3 class="title"><a id="ch08note03"/>Note</h3><p><span class="emphasis"><em>Secondary users do not share accounts with the owner, and therefore their</em></span> <span class="emphasis"><em><code class="literal">shared_accounts</code></em></span> <span class="emphasis"><em>tables are always empty and owner accounts are never cloned.</em></span></p></div></div></div><div class="sect2" title="Adding an Authenticator Module"><div class="titlepage"><div><div><h2 class="title"><a id="adding_an_authenticator_module"/>Adding an Authenticator Module</h2></div></div></div><p>In “<a class="xref" href="ch08.html#authenticator_modules" title="Authenticator Modules">Authenticator Modules</a>”, we showed that an authentcator module is a bound service that implements the <code class="literal">android.accounts.IAccountAuthenticator</code> AIDL interface and which can be bound to by using the <span class="emphasis"><em>android.accounts.AccountAuthenticator</em></span> intent action. In this section, we’ll show how an application can implement and declare an authenticator module.</p><p>Most of the authenticator logic, including adding accounts, checking user-supplied credentials, and fetching authentication tokens, is implemented in an authenticator class derived from the base class that Android provides—namely, <code class="literal">AbstractAccountAuthenticator</code>.<sup>[<a id="ch08fn03" href="#ftn.ch08fn03" class="footnote">80</a>]</sup> The authenticator class needs to provide implementation of all abstract methods, but if not all functionality is needed, implemented methods can return <code class="literal">null</code> or throw <code class="literal">UnsupportedOperationException</code>. In order to store the account password, an implementation should implement at least the <code class="literal">addAccount()</code> method and display a UI that collects the password from the user. The password can then be added to the accounts database by calling the <code class="literal">addAccountExplicitly()</code> method of <code class="literal">AccountManager</code>. Activities that implement credential collection and login can extend from the <code class="literal">AccountAuthenticatorActivity</code>,<sup>[<a id="ch08fn04" href="#ftn.ch08fn04" class="footnote">81</a>]</sup> which provides a convenience method to pass back collected credentials to the <code class="literal">AccountManager</code>.</p><div class="note" title="Note"><h3 class="title"><a id="ch08note04"/>Note</h3><p><span class="emphasis"><em>Remember that the</em></span> <span class="emphasis"><em><code class="literal">addAccountExplicitly()</code></em></span> <span class="emphasis"><em>method does not encrypt or otherwise protect the password that is stored in cleartext by default. If required, encryption should be implemented separately, and the encrypted password or token should be passed to</em></span> <span class="emphasis"><em><code class="literal">addAccountExplicitly()</code></em></span> <span class="emphasis"><em>instead of the cleartext version.</em></span></p></div><p><a id="iddle1100" class="indexterm"/><a id="iddle1242" class="indexterm"/>Once you have an account authenticator implementation, you simply create a service that returns its Binder interface when invoked with the <span class="emphasis"><em>android.accounts.AccountAuthenticator</em></span> intent action, as shown in <a class="xref" href="ch08.html#account_authenticator_service_implementa" title="Example 8-7. Account authenticator service implementation">Example 8-7</a> (<code class="literal">AbstractAccountAuthenticator</code> method implementations have been omitted).</p><div class="example"><a id="account_authenticator_service_implementa"/><p class="title">Example 8-7. Account authenticator service implementation</p><div class="example-contents"><pre class="programlisting">public class ExampleAuthenticatorService extends Service {

    public static class ExampleAuthenticator extends
            AbstractAccountAuthenticator{
        // ...
    }

    private ExampleAuthenticator authenticator;

    @Override
    public void onCreate() {
        super.onCreate();
        authenticator = new ExampleAuthenticator(this);
    }

    @Override
    public IBinder onBind(Intent intent) {
        if (AccountManager.ACTION_AUTHENTICATOR_INTENT.equals(intent.
                getAction())) {
            return authenticator.getIBinder();
        }
        return null;
    }
}</pre></div></div><p>In order to be picked up by the <code class="literal">AccountAuthenticatorCache</code> and made available via the <code class="literal">AccountManagerService</code>, the service needs to declare the <span class="emphasis"><em>android.accounts.AccountAuthenticator</em></span> intent action and matching metadata as shown in <a class="xref" href="ch08.html#declaring_an_account_authenticator_servi" title="Example 8-8. Declaring an account authenticator service in AndroidManifest.xml">Example 8-8</a>. Permissions needed to access accounts and tokens need to be added to the manifest as well. In this example, we only add the <code class="literal">AUTHENTICATE_ACCOUNTS</code> permission, which is the minimum required in order to be able to add an account with <code class="literal">addAccountExplicitly()</code>.</p><div class="example"><a id="declaring_an_account_authenticator_servi"/><p class="title">Example 8-8. Declaring an account authenticator service in <span class="roman">AndroidManifest.xml</span></p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest 
    package="com.example.app"
    android:versionCode="1" android:versionName="1.0" &gt;

    &lt;uses-permission android:name="android.permission.AUTHENTICATE_ACCOUNTS" /&gt;

    &lt;application ...&gt;
        <span class="emphasis"><em>--snip--</em></span>
        &lt;service android:name=".ExampleAuthenticatorService" &gt;
            &lt;intent-filter&gt;
                &lt;action android:name="android.accounts.AccountAuthenticator" /&gt;
            &lt;/intent-filter&gt;
            &lt;meta-data
                android:name="android.accounts.AccountAuthenticator"
                android:resource="@xml/authenticator" /&gt;
        &lt;/service&gt;
    &lt;/application&gt;
&lt;/manifest&gt;</pre></div></div><p>Finally, the account type, label, and icons must be declared in the referenced XML resource file as shown in <a class="xref" href="ch08.html#declaring_account_metadata_in_an_xml_res" title="Example 8-9. Declaring account metadata in an XML resource file">Example 8-9</a>. Here, the account type is <span class="emphasis"><em>com.example.account</em></span> and we’re simply using the app icon as the account icon.</p><div class="example"><a id="declaring_account_metadata_in_an_xml_res"/><p class="title">Example 8-9. Declaring account metadata in an XML resource file</p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;account-authenticator
    
    android:accountType="com.example.account"
    android:label="@string/account_label"
    android:icon="@drawable/ic_launcher"
    android:smallIcon="@drawable/ic_launcher"/&gt;</pre></div></div><p>After the application that declares our new account is installed, <span class="emphasis"><em>com.example.account</em></span> accounts can be added via the <code class="literal">AccountManager</code> API or the system Settings UI by selecting <span class="strong"><strong>Add an account</strong></span>. The new account should show up in the list of supported accounts, as shown in <a class="xref" href="ch08.html#adding_a_custom_account_via_the_system_s" title="Figure 8-3. Adding a custom account via the system Settings UI">Figure 8-3</a>.</p><p>Custom accounts can be used for convenience only by the declaring application, or when creating a sync adapter, which requires a dedicated account. In order to allow third-party applications to authenticate using your custom account, you must implement authentication tokens, because as we saw in “<a class="xref" href="ch08.html#listing_and_authenticating_accounts" title="Listing and Authenticating Accounts">Listing and Authenticating Accounts</a>”, third-party applications cannot access an account password via the <code class="literal">AccountManager.getPassword()</code> API, unless they are signed with the same key and certificate as the application hosting the target account’s authenticator module.</p><div class="figure"><a id="adding_a_custom_account_via_the_system_s"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00031"/><img src="figs/web/08fig03.png.jpg" alt="Adding a custom account via the system Settings UI"/></div></div><p class="title">Figure 8-3. Adding a custom account via the system Settings UI</p></div></div></div><div class="sect1" title="Google Accounts Support"><div class="titlepage"><div><div><h1 class="title"><a id="google_accounts_support"/>Google Accounts Support</h1></div></div></div><p><a id="iddle1034" class="indexterm"/><a id="iddle1035" class="indexterm"/><a id="iddle1038" class="indexterm"/><a id="iddle1894" class="indexterm"/><a id="iddle1895" class="indexterm"/><a id="iddle1897" class="indexterm"/><a id="iddle1898" class="indexterm"/><a id="iddle1901" class="indexterm"/><a id="iddle1905" class="indexterm"/><a id="iddle1907" class="indexterm"/><a id="iddle1915" class="indexterm"/>The main goal of Android’s account management facility is to make it easier to integrate online services into the OS, and to allow for seamless access to user data via background synchronization. The first versions of the system account management service were built to support Android integration with Google online services, and the service was later decoupled and made part of the OS. In Android versions 2.0 and later, Google account and online service support is bundled as a set of components that provide account authenticators (for the <span class="emphasis"><em>com.google</em></span> account type) and sync adapters (for Gmail, Calendar, contacts, and so on), using standard OS APIs. However, there are a few notable differences from other third-party authenticator modules and sync adapters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The Google accounts components are bundled with the system and thus are granted extra permissions.</p></li><li class="listitem"><p>A lot of the actual functionality is implemented on the server side.</p></li><li class="listitem"><p>The account authenticator does not store passwords in plain text on the device.</p></li></ul></div><div class="sect2" title="The Google Login Service"><div class="titlepage"><div><div><h2 class="title"><a id="google_login_service"/>The Google Login Service</h2></div></div></div><p>The two main components that implement Google account and service support are the Google Services Framework (GSF) and the Google Login Service (GLS, displayed as <span class="emphasis"><em>Google Account Manager</em></span> in recent versions). The former provides common services to all Google apps, such as centralized settings and feature toggle management, while the latter implements the authentication provider for Google accounts and will be the main topic of this section.</p><p>Google provides numerous online services, and supports a handful of different methods to authenticate to those services, both via a user-facing web UI and several dedicated authentication APIs. Android’s Google Login Service, however, doesn’t call those public authentication APIs directly, but rather via a dedicated online service, which lives at <span class="emphasis"><em><a class="ulink" href="https://android.clients.google.com">https://android.clients.google.com</a></em></span>. It has endpoints both for authentication, authorization token issuing, and different data feeds (mail, calendar, and so on) that are used for data synchronization.</p><p>While a lot of the authentication and authorization logic is implemented on the server side, some sort of locally stored credentials are also required, especially for background syncing. On-device credential management is one of the services GLS provides, and while as of this writing there is no source code or reference documentation publicly available, we can observe what data GLS stores on the device and infer how authentication is implemented.</p><p>As mentioned earlier, GLS plugs into the system account framework, so cached credentials, tokens, and associated extra data are stored in the system’s accounts database of the current user, just as it is for other account <a id="iddle1001" class="indexterm"/><a id="iddle2341" class="indexterm"/><a id="iddle2373" class="indexterm"/><a id="iddle2944" class="indexterm"/>types. Unlike most other applications, however, GLS doesn’t store Google account passwords directly. Instead, in place of a password, GLS stores an opaque master token (probably some form of an OAuth refresh token) in the <code class="literal">password</code> column of the <code class="literal">accounts</code> table and exchanges it for authentication tokens for different Google services by calling an associated web service endpoint. The token is obtained when a Google account is first added to the device by sending the username and password entered in the sign-in activity shown in <a class="xref" href="ch08.html#google_account_sign-in_activity" title="Figure 8-4. Google account sign-in activity">Figure 8-4</a>.</p><p>If the target Google account is using the default password-only authentication method and the correct password is entered, the GLS online service returns the master token and the account is added to the user’s accounts database. All subsequent authentication requests use the master token to obtain service- or scope-specific tokens that are used for synchronization or automatic web login. If the Google account is set to use two-factor authentication (2FA), the user is prompted to enter their one-time password (OTP, called <span class="emphasis"><em>verification code</em></span> in the web UI) in an embedded web view like the one shown in <a class="xref" href="ch08.html#one-time_password_entry_as_part_of_addin" title="Figure 8-5. One-time password entry as part of adding a Google account">Figure 8-5</a>.</p><div class="figure"><a id="google_account_sign-in_activity"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00032"/><img src="figs/web/08fig04.png.jpg" alt="Google account sign-in activity"/></div></div><p class="title">Figure 8-4. Google account sign-in activity</p></div><div class="figure"><a id="one-time_password_entry_as_part_of_addin"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00033"/><img src="figs/web/08fig05.png.jpg" alt="One-time password entry as part of adding a Google account"/></div></div><p class="title">Figure 8-5. One-time password entry as part of adding a Google account</p></div><p>If the OTP is successfully verified, the master token is added to the accounts database and a list of services that support background synchronization is shown (see <a class="xref" href="ch08.html#list_of_google_services_that_support_bac" title="Figure 8-6. List of Google services that support background synchronization">Figure 8-6</a>).</p><div class="figure"><a id="list_of_google_services_that_support_bac"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00034"/><img src="figs/web/08fig06.png.jpg" alt="List of Google services that support background synchronization"/></div></div><p class="title">Figure 8-6. List of Google services that support background synchronization</p></div><p>Note that only the initial login process differs for Google accounts that have 2FA enabled: all subsequent authentication requests use the cached master token and do not require entering an OTP. Thus, once cached, the master token grants full access to a Google account and can be used not only for data synchronization, but for other types of account access as well, including web login.</p><p>While it’s very handy to have an all-powerful authentication token cached, this trade-off in favor of convenience has enabled several attacks on Google accounts, and as a result many Google services now require additional authentication when sensitive data is displayed or account settings are changed. The master token can be invalidated by changing the Google account password, by enabling two-factor authentication, or by removing the Android device from the <span class="emphasis"><em>Account Permissions</em></span> page of the associated Google account (see <a class="xref" href="ch08.html#android_device_entry_in_the_account_perm" title="Figure 8-7. Android device entry in the Account Permissions page of a Google account">Figure 8-7</a>). Any of these actions will require the user to reauthenticate with their new credentials on the device the next time it tries to get a Google authentication token via the <code class="literal">AccountManager</code> API.</p><div class="figure"><a id="android_device_entry_in_the_account_perm"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00035"/><img src="figs/web/08fig07.png.jpg" alt="Android device entry in the Account Permissions page of a Google account"/></div></div><p class="title">Figure 8-7. Android device entry in the Account Permissions page of a Google account</p></div></div><div class="sect2" title="Google Services Authentication and Authorization"><div class="titlepage"><div><div><h2 class="title"><a id="google_services_authentication_and_autho"/>Google Services Authentication and Authorization</h2></div></div></div><p><a id="iddle1033" class="indexterm"/><a id="iddle1396" class="indexterm"/><a id="iddle1896" class="indexterm"/><a id="iddle2347" class="indexterm"/>Besides user-facing online services with a web UI such as Gmail, Google Calendar and, of course, search, Google provides programmatic access to many of its services via different web APIs. Most of these require authentication, either in order to be able to access a subset of a particular user’s data, or for quota and billing purposes. Several standard or Google-proprietary authentication and authorization methods have been used over the years, with the current trend being to migrate everything to OAuth 2.0<sup>[<a id="ch08fn05" href="#ftn.ch08fn05" class="footnote">82</a>]</sup> and OpenID Connect.<sup>[<a id="ch08fn06" href="#ftn.ch08fn06" class="footnote">83</a>]</sup> However, many services still use older, proprietary protocols, so we’ll briefly look into those as well.</p><p>Most authentication protocols have two variations: one for web applications and one for the so-called installed applications. Web applications run in a browser and are expected to be able to take advantage of all standard browser features including rich UI, free-form user interaction, cookie store, and the ability to follow redirects. Installed applications, on the other hand, don’t have a native way to preserve session information, and may not have the full web capabilities of a browser. Android native applications (mostly) fall into the “installed applications” category, so let’s see what protocols are available for them.</p><div class="sect3" title="ClientLogin"><div class="titlepage"><div><div><h3 class="title"><a id="clientlogin"/>ClientLogin</h3></div></div></div><p>The oldest and, as of this writing, still widely used authorization protocol for installed applications is <span class="emphasis"><em>ClientLogin</em></span>.<sup>[<a id="ch08fn07" href="#ftn.ch08fn07" class="footnote">84</a>]</sup> This protocol assumes that the application has access to the user’s account name and password and lets you get an authorization token for a particular service that can be saved and used for accessing that service on behalf of the user. Services are identified by proprietary service names, such as <span class="emphasis"><em>cl</em></span> for Google Calendar and <span class="emphasis"><em>ah</em></span> for Google App engine. You’ll find a list of many supported service names in the Google Data API reference,<sup>[<a id="ch08fn08" href="#ftn.ch08fn08" class="footnote">85</a>]</sup> but here are a few Android-specific ones not listed in the reference: <span class="emphasis"><em>ac2dm</em></span>, <span class="emphasis"><em>android</em></span>, <span class="emphasis"><em>androidsecure</em></span>, <span class="emphasis"><em>androiddeveloper</em></span>, and <span class="emphasis"><em>androidmarket</em></span>.</p><p>The authorization tokens for these services can be fairly long-lived (up to two weeks), but cannot be refreshed and the application must obtain a new token when the current token expires. Unfortunately, there is no way to validate a token short of accessing the associated service: if you get an <span class="emphasis"><em>OK</em></span> HTTP status (200) the token is valid, but if 403 is returned you need to consult the additional error code and retry or get a new token.</p><p>Another limitation of ClientLogin authorization tokens is that they don’t offer fine-grained access to a service’s resources: access is all or nothing, and you cannot specify read-only access or access to a particular resource only.</p><p><a id="iddle1037" class="indexterm"/><a id="iddle1900" class="indexterm"/><a id="iddle2328" class="indexterm"/><a id="iddle3102" class="indexterm"/>The biggest drawback for mobile apps though is that ClientLogin requires access to the actual user password. Therefore, unless you want to force users to enter their password each time a new token is required, the password must be saved on the device, which poses various problems and potential security issues. Android avoids storing the raw password by storing a master token on the device and uses GLS and the associated online service to exchange the master token for ClientLogin tokens. Getting a token is as simple as calling the appropriate <code class="literal">AccountManger</code> method, which either returns a cached token or issues an API request to fetch a fresh one.</p><p>Despite its many limitations, the ClientLogin protocol is easy to understand and straightforward to implement, so it has been widely used. It was officially deprecated in April 2012 though, and apps using it are encouraged to migrate to OAuth 2.0.</p></div><div class="sect3" title="OAuth 2.0"><div class="titlepage"><div><div><h3 class="title"><a id="oauth_2dot0"/>OAuth 2.0</h3></div></div></div><p>The OAuth 2.0 authorization framework became an official Internet standard in late 2012. It defines different <span class="emphasis"><em>authorization flows</em></span> for different use cases, but we won’t try to present all of them here. We’ll only discuss how OAuth 2.0 relates to native mobile applications. (For more detail on the actual protocol, see RFC 6749.)</p><p>The OAuth 2.0 specification defines four basic flows for getting an authorization token for a resource. It also defines two that don’t require the client (in our scenario, an Android app) to directly handle user credentials (such as the Google account username and password), namely the <span class="emphasis"><em>authorization code grant</em></span> flow and the <span class="emphasis"><em>implicit grant</em></span> flow. Both of these require the authorization server (Google’s) to authenticate the resource owner (the Android app user) in order to establish whether to grant or deny the access request (say, read-only access to profile information). In a typical browser-based web application, this is straightforward: the user is redirected to an authentication page, then to an access grant page that basically says “Do you allow app X to access data Y and Z?” If the user agrees, another redirect, which includes an authorization token, takes the user back to the original application. The browser simply needs to pass the token in the next request in order to gain access to the target resource.</p><p>Things are not so simple with a native app. A native app can either use the system browser to handle the grant permission step, or embed a <code class="literal">WebView</code> or a similar control in the app’s UI. Using the system browser requires launching a third-party application (the browser), detecting success or failure, and finally figuring out a way to return the token back to the calling application. Embedding a <code class="literal">WebView</code> is a bit more user-friendly, as it doesn’t involve switching back and forth between applications, but still results in showing a non-native web UI, and requires complex code to detect success and extract the access token. Neither option is ideal, and both are confusing to the user.</p><p><a id="iddle1036" class="indexterm"/><a id="iddle1899" class="indexterm"/><a id="iddle1910" class="indexterm"/>This integration complexity and UI impedance mismatch are the problems that OAuth 2.0 support via native Android APIs aims to solve. Android offers two APIs that can be used to obtain OAuth 2.0 tokens: the platform <code class="literal">AccountManager</code> via the special <span class="emphasis"><em>oauth2:scope</em></span> token type syntax, and Google Play Services (discussed in the next section). When using either of those APIs to obtain a token, user authentication is implemented transparently by passing the saved master token to the server-side component of GLS, which produces the native <code class="literal">AccountManager</code> access grant dialog (see <a class="xref" href="ch08.html#oauth_token_access_request_dialog" title="Figure 8-8. OAuth token access request dialog">Figure 8-8</a>) instead of a <code class="literal">WebView</code> with a permission grant page. If you grant token access to the requesting application, a second request is sent to convey this to the server, which returns the requested token. The access token is then directly delivered to the app, without passing through an intermediary component such as a <code class="literal">WebView</code>. This is essentially the same flow as for web applications, except that it doesn’t require context switching from native to browser and back, and it’s much more user-friendly. Of course, this native authorization flow only works for Google accounts, and writing a client for some other online service that uses OAuth 2.0 still requires integrating its web interface into your app. For example, Twitter clients often use <code class="literal">WebView</code> to process the permission grant callback URL returned by the Twitter API.</p></div></div><div class="sect2" title="Google Play Services"><div class="titlepage"><div><div><h2 class="title"><a id="google_play_services"/>Google Play Services</h2></div></div></div><p><span class="emphasis"><em>Google Play Services (GPS)</em></span><sup>[<a id="ch08fn09" href="#ftn.ch08fn09" class="footnote">86</a>]</sup> was announced at Google I/O 2012 as an easy-to-use platform that offers third-party Android apps a way to integrate with Google products. Since then, it has grown into a giant all-in-one package (with over 14,000 Java methods!) that provides access to Google APIs and proprietary OS extensions.</p><div class="figure"><a id="oauth_token_access_request_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00036"/><img src="figs/web/08fig08.png.jpg" alt="OAuth token access request dialog"/></div></div><p class="title">Figure 8-8. OAuth token access request dialog</p></div><p>As mentioned in the previous section, getting OAuth 2.0 tokens via the standard <code class="literal">AccountManager</code> interface has been supported since Android 2.2 and higher, but it didn’t work reliably across different Android builds because their different bundled GLS versions resulted in slightly different behavior between devices. Additionally, the permission grant dialog shown when requesting a token was not particularly user friendly because it showed the raw OAuth 2.0 scope in some cases, which meant little to most users (see <a class="xref" href="ch08.html#oauth_token_access_request_dialog" title="Figure 8-8. OAuth token access request dialog">Figure 8-8</a>). While human-readable aliases for certain scopes were partially supported (for example, the <span class="emphasis"><em>Manage your tasks</em></span> string was displayed instead of the raw OAuth scope <span class="emphasis"><em>oauth2:<a class="ulink" href="https://www.googleapis.com/auth/tasks">https://www.googleapis.com/auth/tasks</a></em></span> in some versions), that solution was neither ideal nor universally available, as it too depended on the pre-installed GLS version.</p><p>Generally, while Android’s account management framework is well-integrated into the OS and extensible via third-party authenticator modules, its API is not particularly flexible, and adding support for multi-step authentication or authorization flows such as those used in OAuth 2.0 is far from straightforward. GPS manages to achieve this with the help of an online service, which does its best to hide the complexity of OAuth 2.0 and provides web APIs compatible with Android’s account management framework. We discuss the details of this integration next.</p><p>GPS adds universal supports for displaying a user-friendly OAuth scope description by making token issuance a two-step process:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Much like before, the first request includes the account name, master token, and requested service, in the <span class="emphasis"><em>oauth2:scope</em></span> format. GPS adds two new parameters to the request: the app’s package name and the SHA-1 hash of its signing certificate. The response includes some human-readable details about the requested scope and requesting application, which GPS shows in a permission grant dialog like the one shown in <a class="xref" href="ch08.html#google_play_services_account_access_perm" title="Figure 8-9. Google Play Services account access permission dialog">Figure 8-9</a>.</p></li><li class="listitem"><p>If the user grants permission, that decision is recorded in the <code class="literal">extras</code> table in a proprietary format that includes the requesting app’s package name, signing certificate hash, and granted OAuth 2.0 scope. (Note that the <code class="literal">grants</code> table is not used.) GPS then resends the authorization request, setting the <span class="emphasis"><em>has_permission</em></span> parameter to 1. On success, this results in an OAuth 2.0 token and its expiration date in the response. The expiration date is saved in the <code class="literal">extras</code> table, and the token is cached in the <code class="literal">authtokens</code> table in a similar format.</p></li></ol></div><div class="figure"><a id="google_play_services_account_access_perm"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00037"/><img src="figs/web/08fig09.png.jpg" alt="Google Play Services account access permission dialog"/></div></div><p class="title">Figure 8-9. Google Play Services account access permission dialog</p></div><p>The GPS app has the same shared user ID as the GSF and GLS packages (<span class="emphasis"><em>com.google.uid.shared</em></span>), so it can directly interact with those services. This allows it, among other things, to directly get and write Google account credentials and tokens to the accounts database. As can be expected, GPS runs in a remote service that’s accessed by a client library which is linked into apps that use GPS. The major selling point against the legacy <code class="literal">AccountManager</code> API is that while its underlying authenticator modules (GLS and GSF) are part of the system (and as such cannot be updated without an OTA), GPS is a user-installable app that can be easily updated via Google Play. In fact, it is auto-updating, so app developers presumably won’t have to rely on users to update it if they want to use newer features (unless GPS is disabled altogether). This update mechanism is designed to provide “agility in rolling out new platform capabilities,” but as GPS has come to integrate very diverse APIs and functionalities that require extensive testing, updates have been infrequent. That said, if your app uses OAuth 2.0 tokens to authenticate to Google APIs (the preferred method as of this writing), you should definitely consider using GPS over “raw” <code class="literal">AccountManager</code> access.</p><div class="note" title="Note"><h3 class="title"><a id="ch08note05"/>Note</h3><p><span class="emphasis"><em>In order to be able to actually use a Google API, you must register your app’s package name and signing key in Google’s API console. The registration lets services validating the token query Google about what app the token was issued for, thus identifying the calling app. This validation process has one subtle but important side effect: you don’t have to embed an API key in your app and send it with every request. Of course, for a third-party published app, you can easily discover both the package name and the signing certificate so it’s not particularly hard to get a token issued in the name of some other app (though not via the official API, of course).</em></span></p></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00016"/>Summary</h1></div></div></div><p>Android provides a centralized registry of user online accounts via the <code class="literal">AccountManager</code> class, which lets you get tokens for existing accounts without having to handle the raw user credentials and register your own custom account types. Registering a custom account type gives you access to powerful system features, such as authentication token caching and automatic background synchronization. Google experience devices include built-in support for Google accounts, which lets third-party apps access Google online services without having to directly request authentication information from the user. The Google Play Services app and companion client library further improve support for Google accounts by making it easy to use OAuth 2.0 tokens from third-party applications.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch08fn01" href="#ch08fn01" class="para">78</a>] </sup>Google, <span class="emphasis"><em>Android API Reference</em></span>, “AccountManager,” <span class="emphasis"><em><a class="ulink" href="http://developer.android.com/reference/android/accounts/AccountManager.html">http://developer.android.com/reference/android/accounts/AccountManager.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch08fn02" href="#ch08fn02" class="para">79</a>] </sup>Google, <span class="emphasis"><em>Android API Reference</em></span>, “AccountManager,” <span class="emphasis"><em><a class="ulink" href="http://developer.android.com/reference/android/accounts/AccountManager.html">http://developer.android.com/reference/android/accounts/AccountManager.html</a></em></span>.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch08fn03" href="#ch08fn03" class="para">80</a>] </sup>Google, <span class="emphasis"><em>Android API Reference</em></span>, “AbstractAccountAuthenticator,” <span class="emphasis"><em><a class="ulink" href="http://developer.android.com/reference/android/accounts/AbstractAccountAuthenticator.html">http://developer.android.com/reference/android/accounts/AbstractAccountAuthenticator.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch08fn04" href="#ch08fn04" class="para">81</a>] </sup>Google, <span class="emphasis"><em>Android API Reference</em></span>, “AccountAuthenticatorActivity,” <span class="emphasis"><em><a class="ulink" href="http://developer.android.com/reference/android/accounts/AccountAuthenticatorActivity.html">http://developer.android.com/reference/android/accounts/AccountAuthenticatorActivity.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch08fn05" href="#ch08fn05" class="para">82</a>] </sup>D. Hardt, <span class="emphasis"><em>The OAuth 2.0 Authorization Framework</em></span>, <span class="emphasis"><em><a class="ulink" href="http://tools.ietf.org/html/rfc6749">http://tools.ietf.org/html/rfc6749</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch08fn06" href="#ch08fn06" class="para">83</a>] </sup>N. Sakimura et al., <span class="emphasis"><em>OpenID Connect Core 1.0</em></span>, <span class="emphasis"><em><a class="ulink" href="http://openid.net/specs/openid-connect-core-1_0.html">http://openid.net/specs/openid-connect-core-1_0.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch08fn07" href="#ch08fn07" class="para">84</a>] </sup>Google, <span class="emphasis"><em>Google Accounts Authentication and Authorization</em></span>, “ClientLogin for Installed Applications,” <span class="emphasis"><em><a class="ulink" href="https://developers.google.com/accounts/docs/AuthForInstalledApps">https://developers.google.com/accounts/docs/AuthForInstalledApps</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch08fn08" href="#ch08fn08" class="para">85</a>] </sup>Google, <span class="emphasis"><em>Google Data APIs</em></span>, “Frequently Asked Questions,” <span class="emphasis"><em><a class="ulink" href="https://developers.google.com/gdata/faq#clientlogin">https://developers.google.com/gdata/faq#clientlogin</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch08fn09" href="#ch08fn09" class="para">86</a>] </sup>Google, “Google Play Services,” <span class="emphasis"><em><a class="ulink" href="http://developer.android.com/google/play-services/index.html">http://developer.android.com/google/play-services/index.html</a></em></span></p></div></div></div></body></html>