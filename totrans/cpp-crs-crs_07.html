<html><head></head><body>
<h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_132"/><span epub:type="pagebreak" id="page_133"/><strong><span class="big">5</span><br/>RUNTIME POLYMORPHISM</strong></h2>&#13;
<p class="quote"><em>One day Trurl the constructor put together a machine that could create anything starting with</em> n.<br/>—<em>Stanislaw Lem</em>, The Cyberiad</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">In this chapter, you’ll learn what polymorphism is and the problems it solves. You’ll then learn how to achieve runtime polymorphism, which allows you to change the behavior of your programs by swapping out components during program execution. The chapter starts with a discussion of several crucial concepts in runtime polymorphic code, including interfaces, object composition, and inheritance. Next, you’ll develop an ongoing example of logging bank transactions with multiple kinds of loggers. You’ll finish the chapter by refactoring this initial, naive solution with a more elegant, interface-based solution.</p>&#13;
<h3 class="h3" id="ch05lev1sec1"><span epub:type="pagebreak" id="page_134"/>Polymorphism</h3>&#13;
<p class="noindent"><em>Polymorphic code</em> is code you write once and can reuse with different types. Ultimately, this flexibility yields loosely coupled and highly reusable code. It eliminates tedious copying and pasting, making your code more maintainable and readable.</p>&#13;
<p class="indent">C++ offers two polymorphic approaches. <em>Compile-time polymorphic code</em> incorporates polymorphic types you can determine at compile time. The other approach is <em>runtime polymorphism</em>, which instead incorporates types determined at runtime. Which approach you choose depends on whether you know the types you want to use with your polymorphic code at compile time or at runtime. Because these closely related topics are fairly involved, they’re separated into two chapters. <a href="ch06.xhtml#ch06">Chapter 6</a> will focus on compile-time polymorphism.</p>&#13;
<h3 class="h3" id="ch05lev1sec2">A Motivating Example</h3>&#13;
<p class="indent">Suppose you’re in charge of implementing a <code>Bank</code> class that transfers money between accounts. Auditing is very important for the <code>Bank</code> class’s transactions, so you provide support for logging with a <code>ConsoleLogger</code> class, as shown in <a href="ch05.xhtml#ch05ex01">Listing 5-1</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct ConsoleLogger {&#13;
  void log_transfer(long from, long to, double amount) { <span class="ent">➊</span>&#13;
    printf("%ld -&gt; %ld: %f\n", from, to, amount); <span class="ent">➋</span>&#13;
  }&#13;
};&#13;
&#13;
struct Bank {&#13;
  void make_transfer(long from, long to, double amount) { <span class="ent">➌</span>&#13;
    --<span class="codeitalic1">snip</span>-- <span class="ent">➍</span>&#13;
    logger.log_transfer(from, to, amount); <span class="ent">➎</span>&#13;
  }&#13;
  ConsoleLogger logger;&#13;
};&#13;
&#13;
int main() {&#13;
  Bank bank;&#13;
  bank.make_transfer(1000, 2000, 49.95);&#13;
  bank.make_transfer(2000, 4000, 20.00);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">1000 -&gt; 2000: 49.950000</span>&#13;
<span class="color1">2000 -&gt; 4000: 20.000000</span></pre>&#13;
<p class="listing"><a id="ch05ex01"/><em>Listing 5-1: A <code>ConsoleLogger</code> and a <code>Bank</code> class that uses it</em></p>&#13;
<p class="indent">First, you implement <code>ConsoleLogger</code> with a <code>log_transfer</code> method <span class="ent">➊</span>, which accepts the details of a transaction (sender, recipient, amount) and prints <span epub:type="pagebreak" id="page_135"/>them <span class="ent">➋</span>. The <code>Bank</code> class has the <code>make_transfer</code> method <span class="ent">➌</span>, which (notionally) processes the transaction <span class="ent">➍</span> and then uses the <code>logger</code> member <span class="ent">➎</span> to log the transaction. The <code>Bank</code> and the <code>ConsoleLogger</code> have separate concerns—the <code>Bank</code> deals with bank logic, and the <code>ConsoleLogger</code> deals with logging.</p>&#13;
<p class="indent">Suppose you have a requirement to implement different kinds of loggers. For example, you might require a remote server logger, a local file logger, or even a logger that sends jobs to a printer. In addition, you must be able to change how the program logs at runtime (for example, an administrator might need to switch from logging over the network to logging to the local filesystem because of some server maintenance).</p>&#13;
<p class="indent">How can you accomplish such a task?</p>&#13;
<p class="indent">A simple approach is to use an <code>enum</code> <code>class</code> to switch between the various loggers. <a href="ch05.xhtml#ch05ex02">Listing 5-2</a> adds a <code>FileLogger</code> to <a href="ch05.xhtml#ch05ex01">Listing 5-1</a>.</p>&#13;
&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;stdexcept&gt;&#13;
&#13;
struct FileLogger {&#13;
  void log_transfer(long from, long to, double amount) { <span class="ent">➊</span>&#13;
    --<span class="codeitalic1">snip</span>--&#13;
    printf("[file] %ld,%ld,%f\n", from, to, amount);&#13;
  }&#13;
};&#13;
&#13;
struct ConsoleLogger {&#13;
  void log_transfer(long from, long to, double amount) {&#13;
    printf("[cons] %ld -&gt; %ld: %f\n", from, to, amount);&#13;
  }&#13;
};&#13;
&#13;
enum class LoggerType { <span class="ent">➋</span>&#13;
  Console,&#13;
  File&#13;
};&#13;
&#13;
struct Bank {&#13;
  Bank() : type { LoggerType::Console } { } <span class="ent">➌</span>&#13;
  void set_logger(LoggerType new_type) { <span class="ent">➍</span>&#13;
    type = new_type;&#13;
  }&#13;
&#13;
  void make_transfer(long from, long to, double amount) {&#13;
    --<span class="codeitalic1">snip</span>--&#13;
    switch(type) { <span class="ent">➎</span>&#13;
    case LoggerType::Console: {&#13;
      consoleLogger.log_transfer(from, to, amount);&#13;
      break;&#13;
    } case LoggerType::File: {&#13;
      fileLogger.log_transfer(from, to, amount);&#13;
      break;&#13;
    } default: {&#13;
<span epub:type="pagebreak" id="page_136"/>      throw std::logic_error("Unknown Logger type encountered.");&#13;
    } }&#13;
  }&#13;
private:&#13;
  LoggerType type;&#13;
  ConsoleLogger consoleLogger;&#13;
  FileLogger fileLogger;&#13;
};&#13;
&#13;
int main() {&#13;
  Bank bank;&#13;
  bank.make_transfer(1000, 2000, 49.95);&#13;
  bank.make_transfer(2000, 4000, 20.00);&#13;
  bank.set_logger(LoggerType::File); <span class="ent">➏</span>&#13;
  bank.make_transfer(3000, 2000, 75.00);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">[cons] 1000 -&gt; 2000: 49.950000</span>&#13;
<span class="color1">[cons] 2000 -&gt; 4000: 20.000000</span>&#13;
<span class="color1">[file] 3000,2000,75.000000</span></pre>&#13;
<p class="listing"><a id="ch05ex02"/><em>Listing 5-2: An updated <a href="ch05.xhtml#ch05ex01">Listing 5-1</a> with a runtime polymorphic logger</em></p>&#13;
<p class="indent">You (notionally) add the ability to log to a file <span class="ent">➊</span> by implementing a <code>FileLogger</code>. You also create an <code>enum class LoggerType</code> <span class="ent">➋</span> so you can switch logging behavior at runtime. You initialize the type field to <code>Console</code> within the <code>Bank</code> constructor <span class="ent">➌</span>. Within the updated <code>Bank</code> class, you add a <code>set_logger</code> function <span class="ent">➍</span> to perform the desired logging behavior. You use the <code>type</code> within <code>make_transfer</code> to <code>switch</code> on the correct logger <span class="ent">➎</span>. To alter a <code>Bank</code> class’s logging behavior, you use the <code>set_logger</code> method <span class="ent">➏</span>, and the object handles dispatching internally.</p>&#13;
<h4 class="h4" id="ch05lev2sec1"><strong><em>Adding New Loggers</em></strong></h4>&#13;
<p class="noindent"><a href="ch05.xhtml#ch05ex02">Listing 5-2</a> works, but this approach suffers from several design problems. Adding a new kind of logging requires you to make several updates throughout the code:</p>&#13;
<ol>&#13;
<li class="noindent">You need to write a new logger type.</li>&#13;
<li class="noindent">You need to add a new <code>enum</code> value to the <code>enum class LoggerType</code>.</li>&#13;
<li class="noindent">You must add a new case in the <code>switch</code> statement <span class="ent">➎</span>.</li>&#13;
<li class="noindent">You must add the new logging class as a member to <code>Bank</code>.</li>&#13;
</ol>&#13;
<p class="indent">That’s a lot of work for a simple change!</p>&#13;
<p class="indent">Consider an alternative approach where <code>Bank</code> holds a pointer to a logger. This way, you can set the pointer directly and get rid of <code>LoggerType</code> entirely. You exploit the fact that your loggers have the same function prototype. This is the idea behind an interface: the <code>Bank</code> class doesn’t need to know the implementation details of the <code>Logger</code> reference it holds, just how to invoke its methods.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_137"/>Wouldn’t it be nice if we could swap out the <code>ConsoleLogger</code> for another type that supports the same operations? Say, a <code>FileLogger</code>?</p>&#13;
<p class="indent">Allow me to introduce you to the <em>interface</em>.</p>&#13;
<h4 class="h4" id="ch05lev2sec2"><strong><em>Interfaces</em></strong></h4>&#13;
<p class="noindent">In software engineering, an <em>interface</em> is a shared boundary that contains no data or code. It defines function signatures that all implementations of the interface agree to support. An <em>implementation</em> is code or data that declares support for an interface. You can think of an interface as a contract between classes that implement the interface and users (also called <em>consumers</em>) of that class.</p>&#13;
<p class="indent">Consumers know how to use implementations because they know the contract. In fact, the consumer never needs to know the underlying implementation type. For example, in <a href="ch05.xhtml#ch05ex01">Listing 5-1</a> <code>Bank</code> is a consumer of <code>ConsoleLogger</code>.</p>&#13;
<p class="indent">Interfaces impose stringent requirements. A consumer of an interface can use only the methods explicitly defined in the interface. The <code>Bank</code> class doesn’t need to know anything about how <code>ConsoleLogger</code> performs its function. All it needs to know is how to call the <code>log_transfer</code> method.</p>&#13;
<p class="indent">Interfaces promote highly reusable and loosely coupled code. You can understand the notation for specifying an interface, but you’ll need to know a bit about object composition and implementation inheritance.</p>&#13;
<h4 class="h4" id="ch05lev2sec3"><strong><em>Object Composition and Implementation Inheritance</em></strong></h4>&#13;
<p class="noindent"><em>Object composition</em> is a design pattern where a class contains members of other class types. An alternate, antiquated design pattern called <em>implementation inheritance</em> achieves runtime polymorphism. Implementation inheritance allows you to build hierarchies of classes; each child inherits functionality from its parents. Over the years, accumulated experience with implementation inheritance has convinced many that it’s an anti-pattern. For example, Go and Rust—two new and increasingly popular system-programming languages—have zero support for implementation inheritance. A brief discussion of implementation inheritance is warranted for two reasons:</p>&#13;
<ul>&#13;
<li class="noindent">You might encounter it infecting legacy code.</li>&#13;
<li class="noindent">The quirky way you define C++ interfaces has a shared lineage with implementation inheritance, so you’ll be familiar with the mechanics anyway.</li>&#13;
</ul>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>	If you’re dealing with implementation inheritance–laden C++ code, see <a href="ch20.xhtml#ch20">Chapters 20</a> and <a href="ch21.xhtml#ch21">21</a> of</em>  The C++ Programming Language, <em>4th Edition, by Bjarne Stroustrup</em>.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch05lev1sec3"><strong><span epub:type="pagebreak" id="page_138"/>Defining Interfaces</strong></h3>&#13;
<p class="noindent">Unfortunately, there’s no <code>interface</code> keyword in C++. You have to define interfaces using antiquated inheritance mechanisms. This is just one of those archaisms you have to deal with when programming in a 40+ year-old language.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05ex03">Listing 5-3</a> illustrates a fully specified <code>Logger</code> interface and a corresponding <code>ConsoleLogger</code> that implements the interface. At least four constructions in <a href="ch05.xhtml#ch05ex03">Listing 5-3</a> will be unfamiliar to you, and this section covers each of them.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct Logger {&#13;
  virtual<span class="ent">➊</span> ~Logger()<span class="ent">➋</span> = default;&#13;
  virtual void log_transfer(long from, long to, double amount) = 0<span class="ent">➌</span>;&#13;
};&#13;
&#13;
struct ConsoleLogger : Logger <span class="ent">➍</span> {&#13;
  void log_transfer(long from, long to, double amount) override <span class="ent">➎</span> {&#13;
    printf("%ld -&gt; %ld: %f\n", from, to, amount);&#13;
  }&#13;
};</pre>&#13;
<p class="listing"><a id="ch05ex03"/><em>Listing 5-3: A <code>Logger</code> interface and a refactored <code>ConsoleLogger</code></em></p>&#13;
<p class="indent">To parse <a href="ch05.xhtml#ch05ex03">Listing 5-3</a>, you’ll need to understand the <code>virtual</code> keyword <span class="ent">➊</span>, the virtual destructor <span class="ent">➋</span>, the <code>=0</code> suffix and pure-virtual methods <span class="ent">➌</span>, base class inheritance <span class="ent">➍</span>, and the <code>override</code> keyword <span class="ent">➎</span>. Once you understand these, you’ll know how to define an interface. The sections that follow discuss these concepts in detail.</p>&#13;
<h4 class="h4" id="ch05lev2sec4"><strong><em>Base Class Inheritance</em></strong></h4>&#13;
<p class="noindent"><a href="ch04.xhtml">Chapter 4</a> delved into how the <code>exception</code> class is the base class for all other stdlib exceptions and how the <code>logic_error</code> and <code>runtime_error</code> classes derived from <code>exception</code>. These two classes, in turn, form the base classes for other derived classes that describe error conditions in even greater detail, such as <code>invalid_argument</code> and <code>system_error</code>. Nested exception classes form an example of a class hierarchy and represent an implementation inheritance design.</p>&#13;
<p class="indent">You declare derived classes using the following syntax:</p>&#13;
<pre>struct DerivedClass : BaseClass {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};</pre>&#13;
<p class="indent">To define an inheritance relationship for <code>DerivedClass</code>, you use a colon (<code>:</code>) followed by the name of the base class, <code>BaseClass</code>.</p>&#13;
<p class="indent">Derived classes are declared just like any other class. The benefit is that you can treat derived class references as if they were of base class reference type. <a href="ch05.xhtml#ch05ex04">Listing 5-4</a> uses a <code>DerivedClass</code> reference in place of a <code>BaseClass</code> reference.</p>&#13;
<pre><span epub:type="pagebreak" id="page_139"/>struct BaseClass {}; <span class="ent">➊</span>&#13;
struct DerivedClass : BaseClass {}; <span class="ent">➋</span>&#13;
void are_belong_to_us(BaseClass&amp; base) {} <span class="ent">➌</span>&#13;
&#13;
int main() {&#13;
  DerivedClass derived;&#13;
  are_belong_to_us(derived); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch05ex04"/><em>Listing 5-4: A program using a derived class in place of a base class</em></p>&#13;
<p class="indent">The <code>DerivedClass</code> <span class="ent">➋</span> derives from <code>BaseClass</code> <span class="ent">➊</span>. The <code>are_belong_to_us</code> function takes a reference-to-<code>BaseClass</code> argument <code>base</code> <span class="ent">➌</span>. You can invoke it with an instance of a <code>DerivedClass</code> because <code>DerivedClass</code> derives from <code>BaseClass</code> <span class="ent">➍</span>.</p>&#13;
<p class="indent">The opposite is not true. <a href="ch05.xhtml#ch05ex05">Listing 5-5</a> attempts to use a base class in place of a derived class.</p>&#13;
<pre>struct BaseClass {}; <span class="ent">➊</span>&#13;
struct DerivedClass : BaseClass {}; <span class="ent">➋</span>&#13;
void all_about_that(DerivedClass&amp; derived) {} <span class="ent">➌</span>&#13;
&#13;
int main() {&#13;
  BaseClass base;&#13;
  all_about_that(base); // No! Trouble! <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch05ex05"/><em>Listing 5-5: This program attempts to use a base class in place of a derived class. (This listing won’t compile.)</em></p>&#13;
<p class="indent">Here, <code>BaseClass</code> <span class="ent">➊</span> doesn’t derive from <code>DerivedClass</code> <span class="ent">➋</span>. (The inheritance relationship is the other way around.) The <code>all_about_that</code> function takes a <code>DerivedClass</code> argument <span class="ent">➌</span>. When you attempt to invoke <code>all_about_that</code> with a <code>BaseClass</code> <span class="ent">➍</span>, the compiler yields an error.</p>&#13;
<p class="indent">The main reason you’d want to derive from a class is to inherit its members.</p>&#13;
<h4 class="h4" id="ch05lev2sec5"><strong><em>Member Inheritance</em></strong></h4>&#13;
<p class="noindent">Derived classes inherit non-private members from their base classes. Classes can use inherited members just like normal members. The supposed benefit of member inheritance is that you can define functionality once in a base class and not have to repeat it in the derived classes. Unfortunately, experience has convinced many in the programming community to avoid member inheritance because it can easily yield brittle, hard-to-reason-about code compared to composition-based polymorphism. (This is why so many modern programming languages exclude it.)</p>&#13;
<p class="indent">The class in <a href="ch05.xhtml#ch05ex06">Listing 5-6</a> illustrates member inheritance.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct BaseClass {&#13;
  int the_answer() const { return 42; } <span class="ent">➊</span>&#13;
<span epub:type="pagebreak" id="page_140"/>  const char* member = "gold"; <span class="ent">➋</span>&#13;
private:&#13;
  const char* holistic_detective = "Dirk Gently"; <span class="ent">➌</span>&#13;
};&#13;
&#13;
struct DerivedClass : BaseClass <span class="ent">➍</span> &#13;
  void announce_agency() {&#13;
    // This line doesn't compile:&#13;
    // printf("%s's Holistic Detective Agency\n", holistic_detective); { <span class="ent">➎</span>&#13;
  }&#13;
};&#13;
&#13;
int main() {&#13;
  DerivedClass x;&#13;
  printf("The answer is %d\n", x.the_answer()); <span class="ent">➏</span>&#13;
  printf("%s member\n", x.member); { <span class="ent">➐</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">The answer is 42 <span class="ent">➏</span></span>&#13;
<span class="color1">gold member <span class="ent">➐</span></span></pre>&#13;
<p class="listing"><a id="ch05ex06"/><em>Listing 5-6: A program using inherited members</em></p>&#13;
<p class="indent">Here, <code>BaseClass</code> has a public method <span class="ent">➊</span>, a public field <span class="ent">➋</span>, and a private field <span class="ent">➌</span>. You declare a <code>DerivedClass</code> deriving from <code>BaseClass</code> <span class="ent">➍</span> and then use it in <code>main</code>. Because they’re inherited as public members, <code>the_answer</code> <span class="ent">➏</span> and <code>member</code> <span class="ent">➐</span> are available on the <code>DerivedClass x</code>. However, uncommenting <span class="ent">➎</span> yields a compiler error because <code>holistic_detective</code> is private and thus not inherited by derived classes.</p>&#13;
<h4 class="h4" id="ch05lev2sec6"><strong><em>virtual Methods</em></strong></h4>&#13;
<p class="noindent">If you want to permit a derived class to override a base class’s methods, you use the <code>virtual</code> keyword. By adding <code>virtual</code> to a method’s definition, you declare that a derived class’s implementation should be used if one is supplied. Within the implementation, you add the <code>override</code> keyword to the method’s declaration, as demonstrated in <a href="ch05.xhtml#ch05ex07">Listing 5-7</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct BaseClass {&#13;
  virtual<span class="ent">➊</span> const char* final_message() const {&#13;
    return "We apologize for the incontinence.";&#13;
  }&#13;
};&#13;
&#13;
struct DerivedClass : BaseClass <span class="ent">➋</span> {&#13;
  const char* final_message() const override <span class="ent">➌</span> {&#13;
    return "We apologize for the inconvenience.";&#13;
  }&#13;
};&#13;
&#13;
int main() {&#13;
  BaseClass base;&#13;
  DerivedClass derived;&#13;
  BaseClass&amp; ref = derived;&#13;
<span epub:type="pagebreak" id="page_141"/>  printf("BaseClass:    %s\n", base.final_message()); <span class="ent">➍</span>&#13;
  printf("DerivedClass: %s\n", derived.final_message()); <span class="ent">➎</span>&#13;
  printf("BaseClass&amp;:   %s\n", ref.final_message()); <span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">BaseClass:    We apologize for the incontinence. <span class="ent">➍</span></span>&#13;
<span class="color1">DerivedClass: We apologize for the inconvenience. <span class="ent">➎</span></span>&#13;
<span class="color1">BaseClass&amp;:   We apologize for the inconvenience. <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch05ex07"/><em>Listing 5-7: A program using virtual members</em></p>&#13;
<p class="indent">The <code>BaseClass</code> contains a virtual member <span class="ent">➊</span>. In the <code>DerivedClass</code> <span class="ent">➋</span>, you override the inherited member and use the <code>override</code> keyword <span class="ent">➌</span>. The implementation of <code>BaseClass</code> is used only when a <code>BaseClass</code> instance is at hand <span class="ent">➍</span>. The implementation of <code>DerivedClass</code> is used when a <code>DerivedClass</code> instance is at hand <span class="ent">➎</span>, even if you’re interacting with it through a <code>BaseClass</code> reference <span class="ent">➏</span>.</p>&#13;
<p class="indent">If you want to <em>require</em> a derived class to implement the method, you can append the <code>=0</code> suffix to a method definition. You call methods with both the <code>virtual</code> keyword and <code>=0</code> suffix pure virtual methods. You can’t instantiate a class containing any pure virtual methods. In <a href="ch05.xhtml#ch05ex08">Listing 5-8</a>, consider the refactor of <a href="ch05.xhtml#ch05ex07">Listing 5-7</a> that uses a pure virtual method in the base class.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct BaseClass {&#13;
  virtual const char* final_message() const = 0; <span class="ent">➊</span>&#13;
};&#13;
&#13;
struct DerivedClass : BaseClass <span class="ent">➋</span> {&#13;
  const char* final_message() const override <span class="ent">➌</span> {&#13;
    return "We apologize for the inconvenience.";&#13;
  }&#13;
};&#13;
&#13;
int main() {&#13;
  // BaseClass base; // Bang! <span class="ent">➍</span>&#13;
  DerivedClass derived;&#13;
  BaseClass&amp; ref = derived;&#13;
  printf("DerivedClass: %s\n", derived.final_message()); <span class="ent">➎</span>&#13;
  printf("BaseClass&amp;:   %s\n", ref.final_message()); <span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">DerivedClass: We apologize for the inconvenience. <span class="ent">➎</span></span>&#13;
<span class="color1">BaseClass&amp;:   We apologize for the inconvenience. <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch05ex08"/><em>Listing 5-8: A refactor of <a href="ch05.xhtml#ch05ex07">Listing 5-7</a> using a pure virtual method</em></p>&#13;
<p class="indent">The <code>=0</code> suffix specifies a pure virtual method <span class="ent">➊</span>, meaning you can’t instantiate a <code>BaseClass</code>—only derive from it. <code>DerivedClass</code> still derives from <code>BaseClass</code> <span class="ent">➋</span>, and you provide the requisite <code>final_message</code> <span class="ent">➌</span>. Attempting to instantiate a <code>BaseClass</code> would result in a compiler error <span class="ent">➍</span>. Both <code>DerivedClass</code> and the <code>BaseClass</code> reference behave as before <span class="ent">➎➏</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_142"/><em>Virtual functions can incur runtime overhead, although the cost is typically low (within 25 percent of a regular function call). The compiler generates</em> virtual function tables (vtables) <em>that contain function pointers. At runtime, a consumer of an interface doesn’t generally know its underlying type, but it knows how to invoke the interface’s methods (thanks to the vtable). In some circumstances, the linker can detect all uses of an interface and</em> devirtualize <em>a function call. This removes the function call from the vtable and thus eliminates associated runtime cost</em>.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch05lev2sec7"><strong><em>Pure-Virtual Classes and Virtual Destructors</em></strong></h4>&#13;
<p class="noindent">You achieve interface inheritance through deriving from base classes that contain only pure-virtual methods. Such classes are referred to as <em>pure-virtual classes</em>. In C++, interfaces are always pure-virtual classes. Usually, you add virtual destructors to interfaces. In some rare circumstances, it’s possible to leak resources if you fail to mark destructors as virtual. Consider <a href="ch05.xhtml#ch05ex09">Listing 5-9</a>, which illustrates the danger of not adding a virtual destructor.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct BaseClass {};&#13;
&#13;
struct DerivedClass : BaseClass<span class="ent">➊</span> {&#13;
  DerivedClass() { <span class="ent">➋</span>&#13;
    printf("DerivedClass() invoked.\n");&#13;
  }&#13;
  ~DerivedClass() { <span class="ent">➌</span>&#13;
    printf("~DerivedClass() invoked.\n");&#13;
  }&#13;
};&#13;
&#13;
int main() {&#13;
  printf("Constructing DerivedClass x.\n");&#13;
  BaseClass* x{ new DerivedClass{} }; <span class="ent">➍</span>&#13;
  printf("Deleting x as a BaseClass*.\n");&#13;
  delete x; <span class="ent">➎</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Constructing DerivedClass x.</span>&#13;
<span class="color1">DerivedClass() invoked.</span>&#13;
<span class="color1">Deleting x as a BaseClass*.</span></pre>&#13;
<p class="listing"><a id="ch05ex09"/><em>Listing 5-9: An example illustrating the dangers of non-virtual destructors in base classes</em></p>&#13;
<p class="indent">Here you see a <code>DerivedClass</code> deriving from <code>BaseClass</code> <span class="ent">➊</span>. This class has a constructor <span class="ent">➋</span> and destructor <span class="ent">➌</span> that print when they’re invoked. Within <code>main</code>, you allocate and initialize a <code>DerivedClass</code> with <code>new</code> and set the result to a <code>BaseClass</code> pointer <span class="ent">➍</span>. When you <code>delete</code> the pointer <span class="ent">➎</span>, the <code>BaseClass</code> destructor gets invoked, but the <code>DerivedClass</code> destructor doesn’t!</p>&#13;
<p class="indent">Adding virtual to the <code>BaseClass</code> destructor solves the problem, as demonstrated in <a href="ch05.xhtml#ch05ex10">Listing 5-10</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_143"/>#include &lt;cstdio&gt;&#13;
&#13;
struct BaseClass {&#13;
  virtual ~BaseClass() = default; <span class="ent">➊</span>&#13;
};&#13;
&#13;
struct DerivedClass : BaseClass {&#13;
  DerivedClass() {&#13;
    printf("DerivedClass() invoked.\n");&#13;
  }&#13;
  ~DerivedClass() {&#13;
    printf("~DerivedClass() invoked.\n"); <span class="ent">➋</span>&#13;
  }&#13;
};&#13;
&#13;
int main() {&#13;
  printf("Constructing DerivedClass x.\n");&#13;
  BaseClass* x{ new DerivedClass{} };&#13;
  printf("Deleting x as a BaseClass*.\n");&#13;
  delete x; <span class="ent">➌</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Constructing DerivedClass x.</span>&#13;
<span class="color1">DerivedClass() invoked.</span>&#13;
<span class="color1">Deleting x as a BaseClass*.</span>&#13;
<span class="color1">~DerivedClass() invoked. <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch05ex10"/><em>Listing 5-10: A refactor of <a href="ch05.xhtml#ch05ex09">Listing 5-9</a> with a virtual destructor</em></p>&#13;
<p class="indent">Adding the virtual destructor <span class="ent">➊</span> causes the <code>DerivedClass</code> destructor to get invoked when you delete the <code>BaseClass</code> pointer <span class="ent">➌</span>, which results in the <code>DerivedClass</code> destructor printing the message <span class="ent">➋</span>.</p>&#13;
<p class="indent">Declaring a virtual destructor is optional when declaring an interface, but beware. If you forget that you haven’t implemented a virtual destructor in the interface and accidentally do something like <a href="ch05.xhtml#ch05ex09">Listing 5-9</a>, you can leak resources, and the compiler won’t warn you.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Declaring a protected non-virtual destructor is a good alternative to declaring a public virtual destructor because it will cause a compilation error when writing code that deletes a base class pointer. Some don’t like this approach because you eventually have to make a class with a public destructor, and if you derive from that class, you run into the same issues.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch05lev2sec8"><strong><em>Implementing Interfaces</em></strong></h4>&#13;
<p class="noindent">To declare an interface, declare a pure virtual class. To implement an interface, derive from it. Because the interface is pure virtual, an implementation must implement all of the interface’s methods.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_144"/>It’s good practice to mark these methods with the <code>override</code> keyword. This communicates that you intend to override a virtual function, allowing the compiler to save you from simple mistakes.</p>&#13;
<h4 class="h4" id="ch05lev2sec9"><strong><em>Using Interfaces</em></strong></h4>&#13;
<p class="noindent">As a consumer, you can only deal in references or pointers to interfaces. The compiler cannot know ahead of time how much memory to allocate for the underlying type: if the compiler could know the underlying type, you would be better off using templates.</p>&#13;
<p class="indent">There are two options for how to set the member:</p>&#13;
<p class="bq"><strong>Constructor injection</strong> With constructor injection, you typically use an interface reference. Because references cannot be reseated, they won’t change for the lifetime of the object.</p>&#13;
<p class="bq"><strong>Property injection</strong> With property injection, you use a method to set a pointer member. This allows you to change the object to which the member points.</p>&#13;
<p class="indent">You can combine these approaches by accepting an interface pointer in a constructor while also providing a method to set the pointer to something else.</p>&#13;
<p class="indent">Typically, you’ll use constructor injection when the injected field won’t change throughout the lifetime of the object. If you need the flexibility of modifying the field, you’ll provide methods to perform property injection.</p>&#13;
<h3 class="h3" id="ch05lev1sec4"><strong>Updating the Bank Logger</strong></h3>&#13;
<p class="noindent">The <code>Logger</code> interface allows you to provide multiple logger implementations. This allows a <code>Logger</code> consumer to log transfers with the <code>log_transfer</code> method without having to know the logger’s implementation details. You’ve already implemented a <code>ConsoleLogger</code> in <a href="ch05.xhtml#ch05ex02">Listing 5-2</a>, so let’s consider how you can add another implementation called <code>FileLogger</code>. For simplicity, in this code you’ll only modify the log output’s prefix, but you can imagine how you might implement some more complicated behavior.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05ex11">Listing 5-11</a> defines a <code>FileLogger</code>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct Logger {&#13;
  virtual ~Logger() = default; <span class="ent">➊</span>&#13;
  virtual void log_transfer(long from, long to, double amount) = 0; <span class="ent">➋</span>&#13;
};&#13;
&#13;
struct ConsoleLogger : Logger <span class="ent">➌</span> {&#13;
  void log_transfer(long from, long to, double amount) override <span class="ent">➍</span> {&#13;
    printf("[cons] %ld -&gt; %ld: %f\n", from, to, amount);&#13;
  }&#13;
};&#13;
&#13;
<span epub:type="pagebreak" id="page_145"/>struct FileLogger : Logger <span class="ent">➎</span> {&#13;
  void log_transfer(long from, long to, double amount) override <span class="ent">➏</span> {&#13;
    printf("[file] %ld,%ld,%f\n", from, to, amount);&#13;
  }&#13;
};</pre>&#13;
<p class="listing"><a id="ch05ex11"/><em>Listing 5-11: <code>Logger</code>, <code>ConsoleLogger</code>, and <code>FileLogger</code></em></p>&#13;
<p class="indent"><code>Logger</code> is a pure virtual class (interface) with a default virtual destructor <span class="ent">➊</span> and a single method <code>log_transfer</code> <span class="ent">➋</span>. <code>ConsoleLogger</code> and <code>FileLogger</code> are <code>Logger</code> implementations, because they derive from the interface <span class="ent">➌➎</span>. You’ve implemented <code>log_transfer</code> and placed the <code>override</code> keyword on both <span class="ent">➍➏</span>.</p>&#13;
<p class="indent">Now we’ll look at how you could use either constructor injection or property injection to update <code>Bank</code>.</p>&#13;
<h4 class="h4" id="ch05lev2sec10"><strong><em>Constructor Injection</em></strong></h4>&#13;
<p class="noindent">Using constructor injection, you have a <code>Logger</code> reference that you pass into the <code>Bank</code> class’s constructor. <a href="ch05.xhtml#ch05ex12">Listing 5-12</a> adds to <a href="ch05.xhtml#ch05ex11">Listing 5-11</a> by incorporating the appropriate <code>Bank</code> constructor. This way, you establish the kind of logging that a particular <code>Bank</code> instantiation will perform.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
// Include <a href="ch05.xhtml#ch05ex11">Listing 5-11</a>&#13;
struct Bank {&#13;
  Bank(Logger&amp; logger) : logger{ logger }<span class="ent">➊</span> { }&#13;
  void make_transfer(long from, long to, double amount) {&#13;
    --<span class="codeitalic1">snip</span>--&#13;
    logger.log_transfer(from, to, amount);&#13;
  }&#13;
private:&#13;
  Logger&amp; logger;&#13;
};&#13;
&#13;
int main() {&#13;
  ConsoleLogger logger;&#13;
  Bank bank{ logger }; <span class="ent">➋</span>&#13;
  bank.make_transfer(1000, 2000, 49.95);&#13;
  bank.make_transfer(2000, 4000, 20.00);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">[cons] 1000 -&gt; 2000: 49.950000</span>&#13;
<span class="color1">[cons] 2000 -&gt; 4000: 20.000000</span></pre>&#13;
<p class="listing"><a id="ch05ex12"/><em>Listing 5-12: Refactoring <a href="ch05.xhtml#ch05ex02">Listing 5-2</a> using constructor injection, interfaces, and object composition to replace the clunky <code>enum class</code> approach</em></p>&#13;
<p class="indent">The <code>Bank</code> class’s constructor sets the value of <code>logger</code> using a member initializer <span class="ent">➊</span>. References can’t be reseated, so the object that <code>logger</code> points to doesn’t change for the lifetime of <code>Bank</code>. You fix your logger choice upon <code>Bank</code> construction <span class="ent">➋</span>.</p>&#13;
<h4 class="h4" id="ch05lev2sec11"><strong><em><span epub:type="pagebreak" id="page_146"/>Property Injection</em></strong></h4>&#13;
<p class="noindent">Instead of using constructor injection to insert a <code>Logger</code> into a <code>Bank</code>, you could use property injection. This approach uses a pointer instead of a reference. Because pointers can be reseated (unlike references), you can change the behavior of <code>Bank</code> whenever you like. <a href="ch05.xhtml#ch05ex13">Listing 5-13</a> is a property-injected variant of <a href="ch05.xhtml#ch05ex12">Listing 5-12</a>.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
// Include <a href="ch05.xhtml#ch05ex10">Listing 5-11</a>&#13;
&#13;
struct Bank {&#13;
  void set_logger(Logger* new_logger) {&#13;
    logger = new_logger;&#13;
  }&#13;
  void make_transfer(long from, long to, double amount) {&#13;
  <a id="_idTextAnchor320"/><a id="_idTextAnchor321"/>  if (logger) logger-&gt;log_transfer(from, to, amount);&#13;
  }&#13;
private:&#13;
  Logger* logger{};&#13;
};&#13;
&#13;
int main() {&#13;
  ConsoleLogger console_logger;&#13;
  FileLogger file_logger;&#13;
  Bank bank;&#13;
  bank.set_logger(&amp;console_logger); <span class="ent">➊</span>&#13;
  bank.make_transfer(1000, 2000, 49.95); <span class="ent">➋</span>&#13;
  bank.set_logger(&amp;file_logger); <span class="ent">➌</span>&#13;
  bank.make_transfer(2000, 4000, 20.00); <span class="ent">➍</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">[cons] 1000 -&gt; 2000: 49.950000 <span class="ent">➋</span></span>&#13;
<span class="color1">[file] 2000,4000,20.000000 <span class="ent">➍</span></span></pre>&#13;
<p class="listing"><a id="ch05ex13"/><em>Listing 5-13: Refactoring <a href="ch05.xhtml#ch05ex12">Listing 5-12</a> using property injection</em></p>&#13;
<p class="indent">The <code>set_logger</code> method enables you to inject a new logger into a <code>Bank</code> object at any point during the life cycle. When you set the logger to a <code>ConsoleLogger</code> instance <span class="ent">➊</span>, you get a <code>[cons]</code> prefix on the logging output <span class="ent">➋</span>. When you set the logger to a <code>FileLogger</code> instance <span class="ent">➌</span>, you get a <code>[file]</code> prefix <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch05lev2sec12"><strong><em>Choosing Constructor or Property Injection</em></strong></h4>&#13;
<p class="noindent">Whether you choose constructor or property injection depends on design requirements. If you need to be able to modify underlying types of an object’s members throughout the object's life cycle, you should choose pointers and the property injector method. But the flexibility of using pointers and property injection comes at a cost. In the <code>Bank</code> example in this chapter, you must make sure that you either don’t set <code>logger</code> to <code>nullptr</code> or that you check for this condition before using <code>logger</code>. There’s also the question of what the default behavior is: what is the initial value of <code>logger</code>?</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_147"/>One possibility is to provide constructor and property injection. This encourages anyone who uses your class to think about initializing it. <a href="ch05.xhtml#ch05ex14">Listing 5-14</a> illustrates one way to implement this strategy.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
struct Logger {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct Bank {&#13;
  Bank(Logger* logger) : logger{ logger }{} <span class="ent">➊</span>&#13;
  void set_logger(Logger* new_logger) { <span class="ent">➋</span>&#13;
    logger = new_logger;&#13;
  }&#13;
  void make_transfer(long from, long to, double amount) {&#13;
    if (logger) logger-&gt;log_transfer(from, to, amount);&#13;
  }&#13;
private:&#13;
    Logger* logger;&#13;
};</pre>&#13;
<p class="listing"><a id="ch05ex14"/><em>Listing 5-14: A refactor of the <code>Bank</code> to include constructor and property injection</em></p>&#13;
<p class="indent">As you can see, you can include a constructor <span class="ent">➊</span> and a setter <span class="ent">➋</span>. This requires the user of a <code>Bank</code> to initialize logger with a value, even if it’s just <code>nullptr</code>. Later on, the user can easily swap out this value using property injection.</p>&#13;
<h3 class="h3" id="ch05lev1sec5"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you learned how to define interfaces, the central role that virtual functions play in making inheritance work, and some general rules for using constructor and property injectors. Whichever approach you choose, the combination of interface inheritance and composition provides sufficient flexibility for most runtime polymorphic applications. You can achieve type-safe runtime polymorphism with little or no overhead. Interfaces encourage encapsulation and loosely coupled design. With simple, focused interfaces, you can encourage code reuse by making your code portable across projects.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_148"/><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>5-1.</strong> You didn’t implement an accounting system in your <code>Bank</code>. Design an interface called <code>AccountDatabase</code> that can retrieve and set amounts in bank accounts (identified by a <code>long</code> id).</p>&#13;
<p class="noindent"><strong>5-2.</strong> Generate an <code>InMemoryAccountDatabase</code> that implements <code>AccountDatabase</code>.</p>&#13;
<p class="noindent"><strong>5-3.</strong> Add an <code>AccountDatabase</code> reference member to <code>Bank</code>. Use constructor injection to add an <code>InMemoryAccountDatabase</code> to the <code>Bank</code>.</p>&#13;
<p class="noindent"><strong>5-4.</strong> Modify <code>ConsoleLogger</code> to accept a <code>const char*</code> at construction. When <code>ConsoleLogger</code> logs, prepend this string to the logging output. Notice that you can modify logging behavior without having to modify <code>Bank</code>.</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>API Design for C++</em> by Martin Reddy (Elsevier, 2011)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>