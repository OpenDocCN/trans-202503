<html><head></head><body>
<h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_132"/><span epub:type="pagebreak" id="page_133"/><strong><span class="big">5</span><br/>RUNTIME POLYMORPHISM</strong></h2>&#13;
<p class="quote"><em>One day Trurl the constructor put together a machine that could create anything starting with</em> n.<br/>—<em>Stanislaw Lem</em>, The Cyberiad</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">In this chapter, you’ll learn what polymorphism is and the problems it solves. You’ll then learn how to achieve runtime polymorphism, which allows you to change the behavior of your programs by swapping out components during program execution. The chapter starts with a discussion of several crucial concepts in runtime polymorphic code, including interfaces, object composition, and inheritance. Next, you’ll develop an ongoing example of logging bank transactions with multiple kinds of loggers. You’ll finish the chapter by refactoring this initial, naive solution with a more elegant, interface-based solution.</p>&#13;
<h3 class="h3" id="ch05lev1sec1"><span epub:type="pagebreak" id="page_134"/>Polymorphism</h3>&#13;
<p class="noindent"><em>Polymorphic code</em> is code you write once and can reuse with different types. Ultimately, this flexibility yields loosely coupled and highly reusable code. It eliminates tedious copying and pasting, making your code more maintainable and readable.</p>&#13;
<p class="indent">C++ offers two polymorphic approaches. <em>Compile-time polymorphic code</em> incorporates polymorphic types you can determine at compile time. The other approach is <em>runtime polymorphism</em>, which instead incorporates types determined at runtime. Which approach you choose depends on whether you know the types you want to use with your polymorphic code at compile time or at runtime. Because these closely related topics are fairly involved, they’re separated into two chapters. <a href="ch06.xhtml#ch06">Chapter 6</a> will focus on compile-time polymorphism.</p>&#13;
<h3 class="h3" id="ch05lev1sec2">A Motivating Example</h3>&#13;
<p class="indent">Suppose you’re in charge of implementing a <span class="literal">Bank</span> class that transfers money between accounts. Auditing is very important for the <span class="literal">Bank</span> class’s transactions, so you provide support for logging with a <span class="literal">ConsoleLogger</span> class, as shown in <a href="ch05.xhtml#ch05ex01">Listing 5-1</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct ConsoleLogger {&#13;
  void log_transfer(long from, long to, double amount) { <span class="ent">➊</span>&#13;
    printf("%ld -&gt; %ld: %f\n", from, to, amount); <span class="ent">➋</span>&#13;
  }&#13;
};&#13;
&#13;
struct Bank {&#13;
  void make_transfer(long from, long to, double amount) { <span class="ent">➌</span>&#13;
    --<span class="codeitalic1">snip</span>-- <span class="ent">➍</span>&#13;
    logger.log_transfer(from, to, amount); <span class="ent">➎</span>&#13;
  }&#13;
  ConsoleLogger logger;&#13;
};&#13;
&#13;
int main() {&#13;
  Bank bank;&#13;
  bank.make_transfer(1000, 2000, 49.95);&#13;
  bank.make_transfer(2000, 4000, 20.00);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">1000 -&gt; 2000: 49.950000</span>&#13;
<span class="color1">2000 -&gt; 4000: 20.000000</span></pre>&#13;
<p class="listing"><a id="ch05ex01"/><em>Listing 5-1: A <span class="literal">ConsoleLogger</span> and a <span class="literal">Bank</span> class that uses it</em></p>&#13;
<p class="indent">First, you implement <span class="literal">ConsoleLogger</span> with a <span class="literal">log_transfer</span> method <span class="ent">➊</span>, which accepts the details of a transaction (sender, recipient, amount) and prints <span epub:type="pagebreak" id="page_135"/>them <span class="ent">➋</span>. The <span class="literal">Bank</span> class has the <span class="literal">make_transfer</span> method <span class="ent">➌</span>, which (notionally) processes the transaction <span class="ent">➍</span> and then uses the <span class="literal">logger</span> member <span class="ent">➎</span> to log the transaction. The <span class="literal">Bank</span> and the <span class="literal">ConsoleLogger</span> have separate concerns—the <span class="literal">Bank</span> deals with bank logic, and the <span class="literal">ConsoleLogger</span> deals with logging.</p>&#13;
<p class="indent">Suppose you have a requirement to implement different kinds of loggers. For example, you might require a remote server logger, a local file logger, or even a logger that sends jobs to a printer. In addition, you must be able to change how the program logs at runtime (for example, an administrator might need to switch from logging over the network to logging to the local filesystem because of some server maintenance).</p>&#13;
<p class="indent">How can you accomplish such a task?</p>&#13;
<p class="indent">A simple approach is to use an <span class="literal">enum</span> <span class="literal">class</span> to switch between the various loggers. <a href="ch05.xhtml#ch05ex02">Listing 5-2</a> adds a <span class="literal">FileLogger</span> to <a href="ch05.xhtml#ch05ex01">Listing 5-1</a>.</p>&#13;
&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;stdexcept&gt;&#13;
&#13;
struct FileLogger {&#13;
  void log_transfer(long from, long to, double amount) { <span class="ent">➊</span>&#13;
    --<span class="codeitalic1">snip</span>--&#13;
    printf("[file] %ld,%ld,%f\n", from, to, amount);&#13;
  }&#13;
};&#13;
&#13;
struct ConsoleLogger {&#13;
  void log_transfer(long from, long to, double amount) {&#13;
    printf("[cons] %ld -&gt; %ld: %f\n", from, to, amount);&#13;
  }&#13;
};&#13;
&#13;
enum class LoggerType { <span class="ent">➋</span>&#13;
  Console,&#13;
  File&#13;
};&#13;
&#13;
struct Bank {&#13;
  Bank() : type { LoggerType::Console } { } <span class="ent">➌</span>&#13;
  void set_logger(LoggerType new_type) { <span class="ent">➍</span>&#13;
    type = new_type;&#13;
  }&#13;
&#13;
  void make_transfer(long from, long to, double amount) {&#13;
    --<span class="codeitalic1">snip</span>--&#13;
    switch(type) { <span class="ent">➎</span>&#13;
    case LoggerType::Console: {&#13;
      consoleLogger.log_transfer(from, to, amount);&#13;
      break;&#13;
    } case LoggerType::File: {&#13;
      fileLogger.log_transfer(from, to, amount);&#13;
      break;&#13;
    } default: {&#13;
<span epub:type="pagebreak" id="page_136"/>      throw std::logic_error("Unknown Logger type encountered.");&#13;
    } }&#13;
  }&#13;
private:&#13;
  LoggerType type;&#13;
  ConsoleLogger consoleLogger;&#13;
  FileLogger fileLogger;&#13;
};&#13;
&#13;
int main() {&#13;
  Bank bank;&#13;
  bank.make_transfer(1000, 2000, 49.95);&#13;
  bank.make_transfer(2000, 4000, 20.00);&#13;
  bank.set_logger(LoggerType::File); <span class="ent">➏</span>&#13;
  bank.make_transfer(3000, 2000, 75.00);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">[cons] 1000 -&gt; 2000: 49.950000</span>&#13;
<span class="color1">[cons] 2000 -&gt; 4000: 20.000000</span>&#13;
<span class="color1">[file] 3000,2000,75.000000</span></pre>&#13;
<p class="listing"><a id="ch05ex02"/><em>Listing 5-2: An updated <a href="ch05.xhtml#ch05ex01">Listing 5-1</a> with a runtime polymorphic logger</em></p>&#13;
<p class="indent">You (notionally) add the ability to log to a file <span class="ent">➊</span> by implementing a <span class="literal">FileLogger</span>. You also create an <span class="literal">enum class LoggerType</span> <span class="ent">➋</span> so you can switch logging behavior at runtime. You initialize the type field to <span class="literal">Console</span> within the <span class="literal">Bank</span> constructor <span class="ent">➌</span>. Within the updated <span class="literal">Bank</span> class, you add a <span class="literal">set_logger</span> function <span class="ent">➍</span> to perform the desired logging behavior. You use the <span class="literal">type</span> within <span class="literal">make_transfer</span> to <span class="literal">switch</span> on the correct logger <span class="ent">➎</span>. To alter a <span class="literal">Bank</span> class’s logging behavior, you use the <span class="literal">set_logger</span> method <span class="ent">➏</span>, and the object handles dispatching internally.</p>&#13;
<h4 class="h4" id="ch05lev2sec1"><strong><em>Adding New Loggers</em></strong></h4>&#13;
<p class="noindent"><a href="ch05.xhtml#ch05ex02">Listing 5-2</a> works, but this approach suffers from several design problems. Adding a new kind of logging requires you to make several updates throughout the code:</p>&#13;
<ol>&#13;
<li class="noindent">You need to write a new logger type.</li>&#13;
<li class="noindent">You need to add a new <span class="literal">enum</span> value to the <span class="literal">enum class LoggerType</span>.</li>&#13;
<li class="noindent">You must add a new case in the <span class="literal">switch</span> statement <span class="ent">➎</span>.</li>&#13;
<li class="noindent">You must add the new logging class as a member to <span class="literal">Bank</span>.</li>&#13;
</ol>&#13;
<p class="indent">That’s a lot of work for a simple change!</p>&#13;
<p class="indent">Consider an alternative approach where <span class="literal">Bank</span> holds a pointer to a logger. This way, you can set the pointer directly and get rid of <span class="literal">LoggerType</span> entirely. You exploit the fact that your loggers have the same function prototype. This is the idea behind an interface: the <span class="literal">Bank</span> class doesn’t need to know the implementation details of the <span class="literal">Logger</span> reference it holds, just how to invoke its methods.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_137"/>Wouldn’t it be nice if we could swap out the <span class="literal">ConsoleLogger</span> for another type that supports the same operations? Say, a <span class="literal">FileLogger</span>?</p>&#13;
<p class="indent">Allow me to introduce you to the <em>interface</em>.</p>&#13;
<h4 class="h4" id="ch05lev2sec2"><strong><em>Interfaces</em></strong></h4>&#13;
<p class="noindent">In software engineering, an <em>interface</em> is a shared boundary that contains no data or code. It defines function signatures that all implementations of the interface agree to support. An <em>implementation</em> is code or data that declares support for an interface. You can think of an interface as a contract between classes that implement the interface and users (also called <em>consumers</em>) of that class.</p>&#13;
<p class="indent">Consumers know how to use implementations because they know the contract. In fact, the consumer never needs to know the underlying implementation type. For example, in <a href="ch05.xhtml#ch05ex01">Listing 5-1</a> <span class="literal">Bank</span> is a consumer of <span class="literal">ConsoleLogger</span>.</p>&#13;
<p class="indent">Interfaces impose stringent requirements. A consumer of an interface can use only the methods explicitly defined in the interface. The <span class="literal">Bank</span> class doesn’t need to know anything about how <span class="literal">ConsoleLogger</span> performs its function. All it needs to know is how to call the <span class="literal">log_transfer</span> method.</p>&#13;
<p class="indent">Interfaces promote highly reusable and loosely coupled code. You can understand the notation for specifying an interface, but you’ll need to know a bit about object composition and implementation inheritance.</p>&#13;
<h4 class="h4" id="ch05lev2sec3"><strong><em>Object Composition and Implementation Inheritance</em></strong></h4>&#13;
<p class="noindent"><em>Object composition</em> is a design pattern where a class contains members of other class types. An alternate, antiquated design pattern called <em>implementation inheritance</em> achieves runtime polymorphism. Implementation inheritance allows you to build hierarchies of classes; each child inherits functionality from its parents. Over the years, accumulated experience with implementation inheritance has convinced many that it’s an anti-pattern. For example, Go and Rust—two new and increasingly popular system-programming languages—have zero support for implementation inheritance. A brief discussion of implementation inheritance is warranted for two reasons:</p>&#13;
<ul>&#13;
<li class="noindent">You might encounter it infecting legacy code.</li>&#13;
<li class="noindent">The quirky way you define C++ interfaces has a shared lineage with implementation inheritance, so you’ll be familiar with the mechanics anyway.</li>&#13;
</ul>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>	If you’re dealing with implementation inheritance–laden C++ code, see <a href="ch20.xhtml#ch20">Chapters 20</a> and <a href="ch21.xhtml#ch21">21</a> of</em>  The C++ Programming Language, <em>4th Edition, by Bjarne Stroustrup</em>.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch05lev1sec3"><strong><span epub:type="pagebreak" id="page_138"/>Defining Interfaces</strong></h3>&#13;
<p class="noindent">Unfortunately, there’s no <span class="literal">interface</span> keyword in C++. You have to define interfaces using antiquated inheritance mechanisms. This is just one of those archaisms you have to deal with when programming in a 40+ year-old language.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05ex03">Listing 5-3</a> illustrates a fully specified <span class="literal">Logger</span> interface and a corresponding <span class="literal">ConsoleLogger</span> that implements the interface. At least four constructions in <a href="ch05.xhtml#ch05ex03">Listing 5-3</a> will be unfamiliar to you, and this section covers each of them.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct Logger {&#13;
  virtual<span class="ent">➊</span> ~Logger()<span class="ent">➋</span> = default;&#13;
  virtual void log_transfer(long from, long to, double amount) = 0<span class="ent">➌</span>;&#13;
};&#13;
&#13;
struct ConsoleLogger : Logger <span class="ent">➍</span> {&#13;
  void log_transfer(long from, long to, double amount) override <span class="ent">➎</span> {&#13;
    printf("%ld -&gt; %ld: %f\n", from, to, amount);&#13;
  }&#13;
};</pre>&#13;
<p class="listing"><a id="ch05ex03"/><em>Listing 5-3: A <span class="literal">Logger</span> interface and a refactored <span class="literal">ConsoleLogger</span></em></p>&#13;
<p class="indent">To parse <a href="ch05.xhtml#ch05ex03">Listing 5-3</a>, you’ll need to understand the <span class="literal">virtual</span> keyword <span class="ent">➊</span>, the virtual destructor <span class="ent">➋</span>, the <span class="literal">=0</span> suffix and pure-virtual methods <span class="ent">➌</span>, base class inheritance <span class="ent">➍</span>, and the <span class="literal">override</span> keyword <span class="ent">➎</span>. Once you understand these, you’ll know how to define an interface. The sections that follow discuss these concepts in detail.</p>&#13;
<h4 class="h4" id="ch05lev2sec4"><strong><em>Base Class Inheritance</em></strong></h4>&#13;
<p class="noindent"><a href="ch04.xhtml">Chapter 4</a> delved into how the <span class="literal">exception</span> class is the base class for all other stdlib exceptions and how the <span class="literal">logic_error</span> and <span class="literal">runtime_error</span> classes derived from <span class="literal">exception</span>. These two classes, in turn, form the base classes for other derived classes that describe error conditions in even greater detail, such as <span class="literal">invalid_argument</span> and <span class="literal">system_error</span>. Nested exception classes form an example of a class hierarchy and represent an implementation inheritance design.</p>&#13;
<p class="indent">You declare derived classes using the following syntax:</p>&#13;
<pre>struct DerivedClass : BaseClass {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};</pre>&#13;
<p class="indent">To define an inheritance relationship for <span class="literal">DerivedClass</span>, you use a colon (<span class="literal">:</span>) followed by the name of the base class, <span class="literal">BaseClass</span>.</p>&#13;
<p class="indent">Derived classes are declared just like any other class. The benefit is that you can treat derived class references as if they were of base class reference type. <a href="ch05.xhtml#ch05ex04">Listing 5-4</a> uses a <span class="literal">DerivedClass</span> reference in place of a <span class="literal">BaseClass</span> reference.</p>&#13;
<pre><span epub:type="pagebreak" id="page_139"/>struct BaseClass {}; <span class="ent">➊</span>&#13;
struct DerivedClass : BaseClass {}; <span class="ent">➋</span>&#13;
void are_belong_to_us(BaseClass&amp; base) {} <span class="ent">➌</span>&#13;
&#13;
int main() {&#13;
  DerivedClass derived;&#13;
  are_belong_to_us(derived); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch05ex04"/><em>Listing 5-4: A program using a derived class in place of a base class</em></p>&#13;
<p class="indent">The <span class="literal">DerivedClass</span> <span class="ent">➋</span> derives from <span class="literal">BaseClass</span> <span class="ent">➊</span>. The <span class="literal">are_belong_to_us</span> function takes a reference-to-<span class="literal">BaseClass</span> argument <span class="literal">base</span> <span class="ent">➌</span>. You can invoke it with an instance of a <span class="literal">DerivedClass</span> because <span class="literal">DerivedClass</span> derives from <span class="literal">BaseClass</span> <span class="ent">➍</span>.</p>&#13;
<p class="indent">The opposite is not true. <a href="ch05.xhtml#ch05ex05">Listing 5-5</a> attempts to use a base class in place of a derived class.</p>&#13;
<pre>struct BaseClass {}; <span class="ent">➊</span>&#13;
struct DerivedClass : BaseClass {}; <span class="ent">➋</span>&#13;
void all_about_that(DerivedClass&amp; derived) {} <span class="ent">➌</span>&#13;
&#13;
int main() {&#13;
  BaseClass base;&#13;
  all_about_that(base); // No! Trouble! <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch05ex05"/><em>Listing 5-5: This program attempts to use a base class in place of a derived class. (This listing won’t compile.)</em></p>&#13;
<p class="indent">Here, <span class="literal">BaseClass</span> <span class="ent">➊</span> doesn’t derive from <span class="literal">DerivedClass</span> <span class="ent">➋</span>. (The inheritance relationship is the other way around.) The <span class="literal">all_about_that</span> function takes a <span class="literal">DerivedClass</span> argument <span class="ent">➌</span>. When you attempt to invoke <span class="literal">all_about_that</span> with a <span class="literal">BaseClass</span> <span class="ent">➍</span>, the compiler yields an error.</p>&#13;
<p class="indent">The main reason you’d want to derive from a class is to inherit its members.</p>&#13;
<h4 class="h4" id="ch05lev2sec5"><strong><em>Member Inheritance</em></strong></h4>&#13;
<p class="noindent">Derived classes inherit non-private members from their base classes. Classes can use inherited members just like normal members. The supposed benefit of member inheritance is that you can define functionality once in a base class and not have to repeat it in the derived classes. Unfortunately, experience has convinced many in the programming community to avoid member inheritance because it can easily yield brittle, hard-to-reason-about code compared to composition-based polymorphism. (This is why so many modern programming languages exclude it.)</p>&#13;
<p class="indent">The class in <a href="ch05.xhtml#ch05ex06">Listing 5-6</a> illustrates member inheritance.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct BaseClass {&#13;
  int the_answer() const { return 42; } <span class="ent">➊</span>&#13;
<span epub:type="pagebreak" id="page_140"/>  const char* member = "gold"; <span class="ent">➋</span>&#13;
private:&#13;
  const char* holistic_detective = "Dirk Gently"; <span class="ent">➌</span>&#13;
};&#13;
&#13;
struct DerivedClass : BaseClass <span class="ent">➍</span> &#13;
  void announce_agency() {&#13;
    // This line doesn't compile:&#13;
    // printf("%s's Holistic Detective Agency\n", holistic_detective); { <span class="ent">➎</span>&#13;
  }&#13;
};&#13;
&#13;
int main() {&#13;
  DerivedClass x;&#13;
  printf("The answer is %d\n", x.the_answer()); <span class="ent">➏</span>&#13;
  printf("%s member\n", x.member); { <span class="ent">➐</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">The answer is 42 <span class="ent">➏</span></span>&#13;
<span class="color1">gold member <span class="ent">➐</span></span></pre>&#13;
<p class="listing"><a id="ch05ex06"/><em>Listing 5-6: A program using inherited members</em></p>&#13;
<p class="indent">Here, <span class="literal">BaseClass</span> has a public method <span class="ent">➊</span>, a public field <span class="ent">➋</span>, and a private field <span class="ent">➌</span>. You declare a <span class="literal">DerivedClass</span> deriving from <span class="literal">BaseClass</span> <span class="ent">➍</span> and then use it in <span class="literal">main</span>. Because they’re inherited as public members, <span class="literal">the_answer</span> <span class="ent">➏</span> and <span class="literal">member</span> <span class="ent">➐</span> are available on the <span class="literal">DerivedClass x</span>. However, uncommenting <span class="ent">➎</span> yields a compiler error because <span class="literal">holistic_detective</span> is private and thus not inherited by derived classes.</p>&#13;
<h4 class="h4" id="ch05lev2sec6"><strong><em>virtual Methods</em></strong></h4>&#13;
<p class="noindent">If you want to permit a derived class to override a base class’s methods, you use the <span class="literal">virtual</span> keyword. By adding <span class="literal">virtual</span> to a method’s definition, you declare that a derived class’s implementation should be used if one is supplied. Within the implementation, you add the <span class="literal">override</span> keyword to the method’s declaration, as demonstrated in <a href="ch05.xhtml#ch05ex07">Listing 5-7</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct BaseClass {&#13;
  virtual<span class="ent">➊</span> const char* final_message() const {&#13;
    return "We apologize for the incontinence.";&#13;
  }&#13;
};&#13;
&#13;
struct DerivedClass : BaseClass <span class="ent">➋</span> {&#13;
  const char* final_message() const override <span class="ent">➌</span> {&#13;
    return "We apologize for the inconvenience.";&#13;
  }&#13;
};&#13;
&#13;
int main() {&#13;
  BaseClass base;&#13;
  DerivedClass derived;&#13;
  BaseClass&amp; ref = derived;&#13;
<span epub:type="pagebreak" id="page_141"/>  printf("BaseClass:    %s\n", base.final_message()); <span class="ent">➍</span>&#13;
  printf("DerivedClass: %s\n", derived.final_message()); <span class="ent">➎</span>&#13;
  printf("BaseClass&amp;:   %s\n", ref.final_message()); <span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">BaseClass:    We apologize for the incontinence. <span class="ent">➍</span></span>&#13;
<span class="color1">DerivedClass: We apologize for the inconvenience. <span class="ent">➎</span></span>&#13;
<span class="color1">BaseClass&amp;:   We apologize for the inconvenience. <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch05ex07"/><em>Listing 5-7: A program using virtual members</em></p>&#13;
<p class="indent">The <span class="literal">BaseClass</span> contains a virtual member <span class="ent">➊</span>. In the <span class="literal">DerivedClass</span> <span class="ent">➋</span>, you override the inherited member and use the <span class="literal">override</span> keyword <span class="ent">➌</span>. The implementation of <span class="literal">BaseClass</span> is used only when a <span class="literal">BaseClass</span> instance is at hand <span class="ent">➍</span>. The implementation of <span class="literal">DerivedClass</span> is used when a <span class="literal">DerivedClass</span> instance is at hand <span class="ent">➎</span>, even if you’re interacting with it through a <span class="literal">BaseClass</span> reference <span class="ent">➏</span>.</p>&#13;
<p class="indent">If you want to <em>require</em> a derived class to implement the method, you can append the <span class="literal">=0</span> suffix to a method definition. You call methods with both the <span class="literal">virtual</span> keyword and <span class="literal">=0</span> suffix pure virtual methods. You can’t instantiate a class containing any pure virtual methods. In <a href="ch05.xhtml#ch05ex08">Listing 5-8</a>, consider the refactor of <a href="ch05.xhtml#ch05ex07">Listing 5-7</a> that uses a pure virtual method in the base class.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct BaseClass {&#13;
  virtual const char* final_message() const = 0; <span class="ent">➊</span>&#13;
};&#13;
&#13;
struct DerivedClass : BaseClass <span class="ent">➋</span> {&#13;
  const char* final_message() const override <span class="ent">➌</span> {&#13;
    return "We apologize for the inconvenience.";&#13;
  }&#13;
};&#13;
&#13;
int main() {&#13;
  // BaseClass base; // Bang! <span class="ent">➍</span>&#13;
  DerivedClass derived;&#13;
  BaseClass&amp; ref = derived;&#13;
  printf("DerivedClass: %s\n", derived.final_message()); <span class="ent">➎</span>&#13;
  printf("BaseClass&amp;:   %s\n", ref.final_message()); <span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">DerivedClass: We apologize for the inconvenience. <span class="ent">➎</span></span>&#13;
<span class="color1">BaseClass&amp;:   We apologize for the inconvenience. <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch05ex08"/><em>Listing 5-8: A refactor of <a href="ch05.xhtml#ch05ex07">Listing 5-7</a> using a pure virtual method</em></p>&#13;
<p class="indent">The <span class="literal">=0</span> suffix specifies a pure virtual method <span class="ent">➊</span>, meaning you can’t instantiate a <span class="literal">BaseClass</span>—only derive from it. <span class="literal">DerivedClass</span> still derives from <span class="literal">BaseClass</span> <span class="ent">➋</span>, and you provide the requisite <span class="literal">final_message</span> <span class="ent">➌</span>. Attempting to instantiate a <span class="literal">BaseClass</span> would result in a compiler error <span class="ent">➍</span>. Both <span class="literal">DerivedClass</span> and the <span class="literal">BaseClass</span> reference behave as before <span class="ent">➎➏</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_142"/><em>Virtual functions can incur runtime overhead, although the cost is typically low (within 25 percent of a regular function call). The compiler generates</em> virtual function tables (vtables) <em>that contain function pointers. At runtime, a consumer of an interface doesn’t generally know its underlying type, but it knows how to invoke the interface’s methods (thanks to the vtable). In some circumstances, the linker can detect all uses of an interface and</em> devirtualize <em>a function call. This removes the function call from the vtable and thus eliminates associated runtime cost</em>.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch05lev2sec7"><strong><em>Pure-Virtual Classes and Virtual Destructors</em></strong></h4>&#13;
<p class="noindent">You achieve interface inheritance through deriving from base classes that contain only pure-virtual methods. Such classes are referred to as <em>pure-virtual classes</em>. In C++, interfaces are always pure-virtual classes. Usually, you add virtual destructors to interfaces. In some rare circumstances, it’s possible to leak resources if you fail to mark destructors as virtual. Consider <a href="ch05.xhtml#ch05ex09">Listing 5-9</a>, which illustrates the danger of not adding a virtual destructor.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct BaseClass {};&#13;
&#13;
struct DerivedClass : BaseClass<span class="ent">➊</span> {&#13;
  DerivedClass() { <span class="ent">➋</span>&#13;
    printf("DerivedClass() invoked.\n");&#13;
  }&#13;
  ~DerivedClass() { <span class="ent">➌</span>&#13;
    printf("~DerivedClass() invoked.\n");&#13;
  }&#13;
};&#13;
&#13;
int main() {&#13;
  printf("Constructing DerivedClass x.\n");&#13;
  BaseClass* x{ new DerivedClass{} }; <span class="ent">➍</span>&#13;
  printf("Deleting x as a BaseClass*.\n");&#13;
  delete x; <span class="ent">➎</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Constructing DerivedClass x.</span>&#13;
<span class="color1">DerivedClass() invoked.</span>&#13;
<span class="color1">Deleting x as a BaseClass*.</span></pre>&#13;
<p class="listing"><a id="ch05ex09"/><em>Listing 5-9: An example illustrating the dangers of non-virtual destructors in base classes</em></p>&#13;
<p class="indent">Here you see a <span class="literal">DerivedClass</span> deriving from <span class="literal">BaseClass</span> <span class="ent">➊</span>. This class has a constructor <span class="ent">➋</span> and destructor <span class="ent">➌</span> that print when they’re invoked. Within <span class="literal">main</span>, you allocate and initialize a <span class="literal">DerivedClass</span> with <span class="literal">new</span> and set the result to a <span class="literal">BaseClass</span> pointer <span class="ent">➍</span>. When you <span class="literal">delete</span> the pointer <span class="ent">➎</span>, the <span class="literal">BaseClass</span> destructor gets invoked, but the <span class="literal">DerivedClass</span> destructor doesn’t!</p>&#13;
<p class="indent">Adding virtual to the <span class="literal">BaseClass</span> destructor solves the problem, as demonstrated in <a href="ch05.xhtml#ch05ex10">Listing 5-10</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_143"/>#include &lt;cstdio&gt;&#13;
&#13;
struct BaseClass {&#13;
  virtual ~BaseClass() = default; <span class="ent">➊</span>&#13;
};&#13;
&#13;
struct DerivedClass : BaseClass {&#13;
  DerivedClass() {&#13;
    printf("DerivedClass() invoked.\n");&#13;
  }&#13;
  ~DerivedClass() {&#13;
    printf("~DerivedClass() invoked.\n"); <span class="ent">➋</span>&#13;
  }&#13;
};&#13;
&#13;
int main() {&#13;
  printf("Constructing DerivedClass x.\n");&#13;
  BaseClass* x{ new DerivedClass{} };&#13;
  printf("Deleting x as a BaseClass*.\n");&#13;
  delete x; <span class="ent">➌</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Constructing DerivedClass x.</span>&#13;
<span class="color1">DerivedClass() invoked.</span>&#13;
<span class="color1">Deleting x as a BaseClass*.</span>&#13;
<span class="color1">~DerivedClass() invoked. <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch05ex10"/><em>Listing 5-10: A refactor of <a href="ch05.xhtml#ch05ex09">Listing 5-9</a> with a virtual destructor</em></p>&#13;
<p class="indent">Adding the virtual destructor <span class="ent">➊</span> causes the <span class="literal">DerivedClass</span> destructor to get invoked when you delete the <span class="literal">BaseClass</span> pointer <span class="ent">➌</span>, which results in the <span class="literal">DerivedClass</span> destructor printing the message <span class="ent">➋</span>.</p>&#13;
<p class="indent">Declaring a virtual destructor is optional when declaring an interface, but beware. If you forget that you haven’t implemented a virtual destructor in the interface and accidentally do something like <a href="ch05.xhtml#ch05ex09">Listing 5-9</a>, you can leak resources, and the compiler won’t warn you.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Declaring a protected non-virtual destructor is a good alternative to declaring a public virtual destructor because it will cause a compilation error when writing code that deletes a base class pointer. Some don’t like this approach because you eventually have to make a class with a public destructor, and if you derive from that class, you run into the same issues.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch05lev2sec8"><strong><em>Implementing Interfaces</em></strong></h4>&#13;
<p class="noindent">To declare an interface, declare a pure virtual class. To implement an interface, derive from it. Because the interface is pure virtual, an implementation must implement all of the interface’s methods.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_144"/>It’s good practice to mark these methods with the <span class="literal">override</span> keyword. This communicates that you intend to override a virtual function, allowing the compiler to save you from simple mistakes.</p>&#13;
<h4 class="h4" id="ch05lev2sec9"><strong><em>Using Interfaces</em></strong></h4>&#13;
<p class="noindent">As a consumer, you can only deal in references or pointers to interfaces. The compiler cannot know ahead of time how much memory to allocate for the underlying type: if the compiler could know the underlying type, you would be better off using templates.</p>&#13;
<p class="indent">There are two options for how to set the member:</p>&#13;
<p class="bq"><strong>Constructor injection</strong> With constructor injection, you typically use an interface reference. Because references cannot be reseated, they won’t change for the lifetime of the object.</p>&#13;
<p class="bq"><strong>Property injection</strong> With property injection, you use a method to set a pointer member. This allows you to change the object to which the member points.</p>&#13;
<p class="indent">You can combine these approaches by accepting an interface pointer in a constructor while also providing a method to set the pointer to something else.</p>&#13;
<p class="indent">Typically, you’ll use constructor injection when the injected field won’t change throughout the lifetime of the object. If you need the flexibility of modifying the field, you’ll provide methods to perform property injection.</p>&#13;
<h3 class="h3" id="ch05lev1sec4"><strong>Updating the Bank Logger</strong></h3>&#13;
<p class="noindent">The <span class="literal">Logger</span> interface allows you to provide multiple logger implementations. This allows a <span class="literal">Logger</span> consumer to log transfers with the <span class="literal">log_transfer</span> method without having to know the logger’s implementation details. You’ve already implemented a <span class="literal">ConsoleLogger</span> in <a href="ch05.xhtml#ch05ex02">Listing 5-2</a>, so let’s consider how you can add another implementation called <span class="literal">FileLogger</span>. For simplicity, in this code you’ll only modify the log output’s prefix, but you can imagine how you might implement some more complicated behavior.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05ex11">Listing 5-11</a> defines a <span class="literal">FileLogger</span>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct Logger {&#13;
  virtual ~Logger() = default; <span class="ent">➊</span>&#13;
  virtual void log_transfer(long from, long to, double amount) = 0; <span class="ent">➋</span>&#13;
};&#13;
&#13;
struct ConsoleLogger : Logger <span class="ent">➌</span> {&#13;
  void log_transfer(long from, long to, double amount) override <span class="ent">➍</span> {&#13;
    printf("[cons] %ld -&gt; %ld: %f\n", from, to, amount);&#13;
  }&#13;
};&#13;
&#13;
<span epub:type="pagebreak" id="page_145"/>struct FileLogger : Logger <span class="ent">➎</span> {&#13;
  void log_transfer(long from, long to, double amount) override <span class="ent">➏</span> {&#13;
    printf("[file] %ld,%ld,%f\n", from, to, amount);&#13;
  }&#13;
};</pre>&#13;
<p class="listing"><a id="ch05ex11"/><em>Listing 5-11: <span class="literal">Logger</span>, <span class="literal">ConsoleLogger</span>, and <span class="literal">FileLogger</span></em></p>&#13;
<p class="indent"><span class="literal">Logger</span> is a pure virtual class (interface) with a default virtual destructor <span class="ent">➊</span> and a single method <span class="literal">log_transfer</span> <span class="ent">➋</span>. <span class="literal">ConsoleLogger</span> and <span class="literal">FileLogger</span> are <span class="literal">Logger</span> implementations, because they derive from the interface <span class="ent">➌➎</span>. You’ve implemented <span class="literal">log_transfer</span> and placed the <span class="literal">override</span> keyword on both <span class="ent">➍➏</span>.</p>&#13;
<p class="indent">Now we’ll look at how you could use either constructor injection or property injection to update <span class="literal">Bank</span>.</p>&#13;
<h4 class="h4" id="ch05lev2sec10"><strong><em>Constructor Injection</em></strong></h4>&#13;
<p class="noindent">Using constructor injection, you have a <span class="literal">Logger</span> reference that you pass into the <span class="literal">Bank</span> class’s constructor. <a href="ch05.xhtml#ch05ex12">Listing 5-12</a> adds to <a href="ch05.xhtml#ch05ex11">Listing 5-11</a> by incorporating the appropriate <span class="literal">Bank</span> constructor. This way, you establish the kind of logging that a particular <span class="literal">Bank</span> instantiation will perform.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
// Include <a href="ch05.xhtml#ch05ex11">Listing 5-11</a>&#13;
struct Bank {&#13;
  Bank(Logger&amp; logger) : logger{ logger }<span class="ent">➊</span> { }&#13;
  void make_transfer(long from, long to, double amount) {&#13;
    --<span class="codeitalic1">snip</span>--&#13;
    logger.log_transfer(from, to, amount);&#13;
  }&#13;
private:&#13;
  Logger&amp; logger;&#13;
};&#13;
&#13;
int main() {&#13;
  ConsoleLogger logger;&#13;
  Bank bank{ logger }; <span class="ent">➋</span>&#13;
  bank.make_transfer(1000, 2000, 49.95);&#13;
  bank.make_transfer(2000, 4000, 20.00);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">[cons] 1000 -&gt; 2000: 49.950000</span>&#13;
<span class="color1">[cons] 2000 -&gt; 4000: 20.000000</span></pre>&#13;
<p class="listing"><a id="ch05ex12"/><em>Listing 5-12: Refactoring <a href="ch05.xhtml#ch05ex02">Listing 5-2</a> using constructor injection, interfaces, and object composition to replace the clunky <span class="literal">enum class</span> approach</em></p>&#13;
<p class="indent">The <span class="literal">Bank</span> class’s constructor sets the value of <span class="literal">logger</span> using a member initializer <span class="ent">➊</span>. References can’t be reseated, so the object that <span class="literal">logger</span> points to doesn’t change for the lifetime of <span class="literal">Bank</span>. You fix your logger choice upon <span class="literal">Bank</span> construction <span class="ent">➋</span>.</p>&#13;
<h4 class="h4" id="ch05lev2sec11"><strong><em><span epub:type="pagebreak" id="page_146"/>Property Injection</em></strong></h4>&#13;
<p class="noindent">Instead of using constructor injection to insert a <span class="literal">Logger</span> into a <span class="literal">Bank</span>, you could use property injection. This approach uses a pointer instead of a reference. Because pointers can be reseated (unlike references), you can change the behavior of <span class="literal">Bank</span> whenever you like. <a href="ch05.xhtml#ch05ex13">Listing 5-13</a> is a property-injected variant of <a href="ch05.xhtml#ch05ex12">Listing 5-12</a>.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
// Include <a href="ch05.xhtml#ch05ex10">Listing 5-11</a>&#13;
&#13;
struct Bank {&#13;
  void set_logger(Logger* new_logger) {&#13;
    logger = new_logger;&#13;
  }&#13;
  void make_transfer(long from, long to, double amount) {&#13;
  <a id="_idTextAnchor320"/><a id="_idTextAnchor321"/>  if (logger) logger-&gt;log_transfer(from, to, amount);&#13;
  }&#13;
private:&#13;
  Logger* logger{};&#13;
};&#13;
&#13;
int main() {&#13;
  ConsoleLogger console_logger;&#13;
  FileLogger file_logger;&#13;
  Bank bank;&#13;
  bank.set_logger(&amp;console_logger); <span class="ent">➊</span>&#13;
  bank.make_transfer(1000, 2000, 49.95); <span class="ent">➋</span>&#13;
  bank.set_logger(&amp;file_logger); <span class="ent">➌</span>&#13;
  bank.make_transfer(2000, 4000, 20.00); <span class="ent">➍</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">[cons] 1000 -&gt; 2000: 49.950000 <span class="ent">➋</span></span>&#13;
<span class="color1">[file] 2000,4000,20.000000 <span class="ent">➍</span></span></pre>&#13;
<p class="listing"><a id="ch05ex13"/><em>Listing 5-13: Refactoring <a href="ch05.xhtml#ch05ex12">Listing 5-12</a> using property injection</em></p>&#13;
<p class="indent">The <span class="literal">set_logger</span> method enables you to inject a new logger into a <span class="literal">Bank</span> object at any point during the life cycle. When you set the logger to a <span class="literal">ConsoleLogger</span> instance <span class="ent">➊</span>, you get a <span class="literal">[cons]</span> prefix on the logging output <span class="ent">➋</span>. When you set the logger to a <span class="literal">FileLogger</span> instance <span class="ent">➌</span>, you get a <span class="literal">[file]</span> prefix <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch05lev2sec12"><strong><em>Choosing Constructor or Property Injection</em></strong></h4>&#13;
<p class="noindent">Whether you choose constructor or property injection depends on design requirements. If you need to be able to modify underlying types of an object’s members throughout the object's life cycle, you should choose pointers and the property injector method. But the flexibility of using pointers and property injection comes at a cost. In the <span class="literal">Bank</span> example in this chapter, you must make sure that you either don’t set <span class="literal">logger</span> to <span class="literal">nullptr</span> or that you check for this condition before using <span class="literal">logger</span>. There’s also the question of what the default behavior is: what is the initial value of <span class="literal">logger</span>?</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_147"/>One possibility is to provide constructor and property injection. This encourages anyone who uses your class to think about initializing it. <a href="ch05.xhtml#ch05ex14">Listing 5-14</a> illustrates one way to implement this strategy.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
struct Logger {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct Bank {&#13;
  Bank(Logger* logger) : logger{ logger }{} <span class="ent">➊</span>&#13;
  void set_logger(Logger* new_logger) { <span class="ent">➋</span>&#13;
    logger = new_logger;&#13;
  }&#13;
  void make_transfer(long from, long to, double amount) {&#13;
    if (logger) logger-&gt;log_transfer(from, to, amount);&#13;
  }&#13;
private:&#13;
    Logger* logger;&#13;
};</pre>&#13;
<p class="listing"><a id="ch05ex14"/><em>Listing 5-14: A refactor of the <span class="literal">Bank</span> to include constructor and property injection</em></p>&#13;
<p class="indent">As you can see, you can include a constructor <span class="ent">➊</span> and a setter <span class="ent">➋</span>. This requires the user of a <span class="literal">Bank</span> to initialize logger with a value, even if it’s just <span class="literal">nullptr</span>. Later on, the user can easily swap out this value using property injection.</p>&#13;
<h3 class="h3" id="ch05lev1sec5"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you learned how to define interfaces, the central role that virtual functions play in making inheritance work, and some general rules for using constructor and property injectors. Whichever approach you choose, the combination of interface inheritance and composition provides sufficient flexibility for most runtime polymorphic applications. You can achieve type-safe runtime polymorphism with little or no overhead. Interfaces encourage encapsulation and loosely coupled design. With simple, focused interfaces, you can encourage code reuse by making your code portable across projects.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_148"/><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>5-1.</strong> You didn’t implement an accounting system in your <span class="literal">Bank</span>. Design an interface called <span class="literal">AccountDatabase</span> that can retrieve and set amounts in bank accounts (identified by a <span class="literal">long</span> id).</p>&#13;
<p class="noindent"><strong>5-2.</strong> Generate an <span class="literal">InMemoryAccountDatabase</span> that implements <span class="literal">AccountDatabase</span>.</p>&#13;
<p class="noindent"><strong>5-3.</strong> Add an <span class="literal">AccountDatabase</span> reference member to <span class="literal">Bank</span>. Use constructor injection to add an <span class="literal">InMemoryAccountDatabase</span> to the <span class="literal">Bank</span>.</p>&#13;
<p class="noindent"><strong>5-4.</strong> Modify <span class="literal">ConsoleLogger</span> to accept a <span class="literal">const char*</span> at construction. When <span class="literal">ConsoleLogger</span> logs, prepend this string to the logging output. Notice that you can modify logging behavior without having to modify <span class="literal">Bank</span>.</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>API Design for C++</em> by Martin Reddy (Elsevier, 2011)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>