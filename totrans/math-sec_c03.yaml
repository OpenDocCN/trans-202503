- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Securing Networks with Graph Theory
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图论保障网络安全
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'Graph theory is a powerful but often overlooked tool in a security analyst’s
    arsenal. A *graph* is a mathematical structure that shows relationships (called
    *edges* or *connections*) between things (called *nodes* or *vertices*), and graph
    theory provides a suite of algorithms for analyzing the structure and importance
    of these different, often interlinked, relationships. As technical a topic as
    security is, at its core it’s about relationships: between computers and networks,
    users and systems, pieces of information, and so on. By modeling a computer network
    or social network as a graph, you can examine the composition of the relationships
    to determine, for example, which computers are integral to a business’s communications,
    or which employees are most likely to forward a spam message, and to whom. Knowing
    which nodes (machines or employees) pose the greatest risk allows you to intelligently
    distribute your security resources.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 图论是安全分析师工具箱中一个强大但常被忽视的工具。*图*是一种数学结构，显示了事物之间的关系（称为*边*或*连接*），这些事物被称为*节点*或*顶点*，而图论提供了一套用于分析这些不同、通常相互关联的关系的算法。尽管安全是一个技术性很强的话题，但其核心依然是关于关系：计算机与网络、用户与系统、信息片段之间的关系，等等。通过将计算机网络或社交网络建模为图，你可以检查关系的组成，例如，确定哪些计算机对一个企业的通信至关重要，或哪些员工最可能转发垃圾邮件，并且会转发给谁。了解哪些节点（机器或员工）带来最大风险，能够帮助你智能地分配安全资源。
- en: This chapter starts by discussing the diverse applications of graph theory to
    information security, then goes over the theory itself. We’ll cover types of graphs,
    how to create them efficiently in Python, and some interesting measurements you
    can perform on them. Chapters [4](c04.xhtml) through [6](c06.xhtml) then walk
    you through applying what you’ve learned here to analyze computer and social networks,
    the two types of network you’ll face most often as a security engineer. We’ll
    answer questions like which computers in a network received the most data, which
    members in a group are most influential, and how quickly information is likely
    to spread through a social network.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先讨论图论在信息安全中的多种应用，然后介绍图论本身的理论。我们将涵盖图的类型，如何高效地在Python中创建它们，以及你可以在它们上执行的一些有趣的测量。接下来的[第4章](c04.xhtml)到[第6章](c06.xhtml)将带你逐步应用你在这里学到的内容，分析计算机网络和社交网络，这两种网络是你作为安全工程师最常遇到的类型。我们将回答诸如哪个计算机在网络中接收了最多的数据，哪个成员在小组中最具影响力，以及信息可能如何在社交网络中传播的速度等问题。
- en: Graph Theory for Security Applications
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图论在安全应用中的作用
- en: Before we discuss how we can apply graph theory in practice, let’s take a look
    at a simple travel graph example in [Figure 3-1](#figure3-1).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论如何实际应用图论之前，让我们先看看[图3-1](#figure3-1)中的一个简单旅行图例。
- en: '![](image_fi/502567c03/f03001.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c03/f03001.png)'
- en: 'Figure 3-1: A travel graph'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-1：旅行图
- en: As mentioned previously, a graph is defined by nodes and edges. In this example,
    the nodes (the circles) represent airports in major cities, and the edges (the
    arrows) represent the cost of a plane ticket between two cities. A graph like
    this could save you money as you plan a trip. For example, if you wanted to travel
    from Seattle to New York, you could fly from SEA to LAX, then to MIA, and finally
    to JFK for a total cost of $396.00\. You could also fly from SEA to ORD and then
    to JFK for $198.00, or directly from SEA to JFK for $250.00\.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，图是由节点和边定义的。在这个例子中，节点（圆圈）代表主要城市的机场，边（箭头）代表两个城市之间机票的费用。这样的图可以帮助你节省旅行成本。例如，如果你想从西雅图到纽约，你可以先飞从SEA到LAX，再飞到MIA，最后飞到JFK，总费用为396.00美元。你也可以选择从SEA飞到ORD，再到JFK，费用为198.00美元，或者直接从SEA飞到JFK，费用为250.00美元。
- en: I don’t know about you, but when I fly I don’t think just about the cost; I
    also consider the travel time. In addition to the cost of each potential trip,
    you can also use this graph to determine the smallest number of stops between
    any two cities. Fewer stops means shorter trips. As you can see, even a simple
    graph can contain a lot of information.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你怎么样，但我每次飞行时不仅仅考虑费用，还会考虑旅行时间。除了每次旅行的费用，你还可以利用这个图来确定两个城市之间的最少中途停留次数。停留次数越少，旅行的时间就越短。正如你所看到的，即使是一个简单的图也可以包含大量的信息。
- en: When analyzing a computer network, the first step for both attackers and defenders
    is to get “the lay of the land.” That means they can’t start to attack or defend
    anything until they’ve built a graph of what’s available around them. One way
    to create such a graph is to define computers as nodes and the network connections
    as edges; this is typical of most network maps. In one of the upcoming projects,
    we’ll model a computer network from a raw packet capture. In this definition,
    the nodes will be the individual computers, and the edges will indicate when one
    machine sends packets to another.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析计算机网络时，攻击者和防守者的第一步是了解“地形”。这意味着，在构建出周围可用资源的图形之前，他们无法开始任何攻击或防御工作。创建这种图形的一种方式是将计算机定义为节点，将网络连接定义为边；这在大多数网络图中很常见。在接下来的项目中，我们将从原始数据包捕获中建模一个计算机网络。在这个定义中，节点将是单独的计算机，边将表示一台机器何时向另一台机器发送数据包。
- en: Similarly, analyzing a social network can reveal key people and relationships,
    like the employees who will forward spam messages, or important members of a criminal
    organization. You can use that information to target or protect members of the
    network (depending on your job). For example, the FBI uses undercover agents to
    get information on organized crime families, then builds a social network graph,
    determines the key figures, and attempts to arrest them. Now, with the prevalence
    of social media, any amateur sleuth with a laptop can build an alarmingly accurate
    graph of an organization’s (or individual’s) social network and use that information
    to target key members for their own means.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，分析社交网络可以揭示关键人物和关系，比如那些会转发垃圾邮件的员工，或者犯罪组织中的重要成员。你可以利用这些信息来针对或保护网络中的成员（取决于你的工作）。例如，FBI利用卧底特工获取有关有组织犯罪家庭的信息，然后建立一个社交网络图，确定关键人物，并尝试将其逮捕。如今，随着社交媒体的普及，任何有笔记本电脑的业余侦探都可以建立一个惊人精确的组织（或个人）社交网络图，并利用这些信息针对关键成员以实现自己的目的。
- en: Researchers also apply graph theory, using it to map technologies like cellular
    networks and cloud computing. For example, scholars have presented ways to apply
    shortest-path algorithms (similar to limiting the number of airport stops in [Figure
    3-1](#figure3-1)) to pick secure routes through graphs representing 5G cellular
    networks. The research analyzes how messages travel from point to point in the
    physical layer (OSI model) of the network.^([1](b01.xhtml#c03-endnote-001)) We’ll
    use a similar analytical model in [Chapter 4](c04.xhtml) when we graph a computer
    network from packet data. Other modern research has focused on graphing the logical
    relationship of components hosted in the cloud. By mapping code usage and typical
    hypervisor loading activities, scientists have presented a formal way to describe
    cloud security concerns for virtualization platforms.^([2](b01.xhtml#c03-endnote-002))
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员还应用图论，用它来绘制如蜂窝网络和云计算等技术。例如，学者们提出了应用最短路径算法（类似于限制[图3-1](#figure3-1)中机场停留次数的方式）来选择穿越表示5G蜂窝网络的图形中的安全路线。这项研究分析了消息如何在网络的物理层（OSI模型）中从一个点传播到另一个点。^([1](b01.xhtml#c03-endnote-001))
    在[第4章](c04.xhtml)中，我们将在从数据包数据绘制计算机网络时使用类似的分析模型。其他现代研究则集中于绘制云中托管的组件之间的逻辑关系。通过映射代码使用和典型的虚拟机管理程序负载活动，科学家们提出了一种正式的方式来描述虚拟化平台的云安全问题。^([2](b01.xhtml#c03-endnote-002))
- en: Graph theory is also applied to *open source intelligence (OSINT)*, which, in
    short, collates publicly available information to gain intelligence about a target.
    An application named Maltego crawls the public web for related terms, email addresses,
    places, machines, and other details, and creates a graph of where they appear
    online, like in [Figure 3-2](#figure3-2). In 2017 at DEF CON, the annual information
    security convention, Andrew Hay gave an excellent introductory presentation on
    applied graph theory for OSINT.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图论也应用于*开放源代码情报（OSINT）*，简而言之，它通过收集公开可用的信息来获取目标的情报。一个名为Maltego的应用程序会爬取公开网页，寻找相关的术语、电子邮件地址、地点、机器以及其他细节，并创建一个图形，显示它们在线上的出现位置，如[图3-2](#figure3-2)所示。在2017年的DEF
    CON年度信息安全大会上，Andrew Hay做了一场关于图论在OSINT应用中的精彩入门演讲。
- en: '![](image_fi/502567c03/f03002.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c03/f03002.png)'
- en: 'Figure 3-2: An intelligence-gathering application of graph theory'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-2：图论在情报收集中的应用
- en: Applications like Maltego blend these logically different types of networks
    together in one graph, leading to very interesting insights. In one example, my
    team was able to locate a covert communication channel between two users of different
    forums. Although the forums were run by different companies, they resided on a
    shared hosting server. User A joined site X while user B joined site Y. Then,
    by manipulating the forum software, the two users were able to use local file
    reads and writes to pass messages on the underlying server. Had my team examined
    only the social network connections, we would have been stumped, but when we combined
    information about the social networks and the underlying machine networks, we
    realized that both accounts could access the same hardware. Of course, you don’t
    need to rely on other people’s tools; once you know the inner workings, you can
    produce your own OSINT-gathering tools, complete with pretty, yet functional,
    graph displays.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Maltego 这样的应用程序将这些逻辑上不同类型的网络融合到一个图中，从而得出非常有趣的洞察。在一个例子中，我的团队能够定位到两个不同论坛用户之间的隐秘通讯渠道。尽管这些论坛由不同的公司运营，但它们托管在同一服务器上。用户
    A 加入了 X 网站，而用户 B 加入了 Y 网站。然后，通过操控论坛软件，两名用户能够利用本地文件的读写操作，在底层服务器上传递消息。如果我的团队只检查了社交网络连接，我们可能会被难住，但当我们将社交网络信息和底层机器网络的信息结合起来时，我们意识到这两个账户可以访问相同的硬件。当然，你不必依赖其他人的工具；一旦你了解了内部工作原理，你可以制作自己的
    OSINT 收集工具，配上既美观又实用的图形显示。
- en: Graphs can also be used to describe how you can go from one condition to another
    by taking some action. For example, you can go from somewhat secure to completely
    unsecured by removing the locks from your doors. In this definition, secured and
    unsecured are called *states*, and removing the locks is the *action* that changes
    you from one state to another, known as a *transition*. [Figure 3-3](#figure3-3)
    shows such a graph, known as a *state machine graph*, that describes the potential
    for an attacker to move through an environment. [Chapter 6](c06.xhtml) will cover
    state machines in detail.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图还可以用来描述如何通过采取某些行动从一个状态过渡到另一个状态。例如，你可以通过移除门上的锁从相对安全变为完全不安全。在这个定义中，安全和不安全被称为
    *状态*，而移除锁则是将你从一个状态转换到另一个状态的 *动作*，称为 *过渡*。[图 3-3](#figure3-3) 显示了这样一个图，称为 *状态机图*，它描述了攻击者在环境中移动的潜力。[第
    6 章](c06.xhtml) 将详细讲解状态机。
- en: 'You interpret the graph like so: if you’re on the internet, and you want to
    take over an employee’s system at your target organization, you can try phishing
    their customer service team. When you get a willing employee, you send them a
    remote-controlled malicious payload. You would then be on the employee system,
    but you might still need to perform some form of privilege escalation to completely
    take over the system. You can also see that this is just one path you could follow
    to achieve your objective.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样解释这个图：如果你在互联网上，想要接管目标组织中的一名员工的系统，你可以尝试对其客户服务团队进行钓鱼攻击。当你获得一名愿意配合的员工后，你将向他们发送一个远程控制的恶意载荷。然后你将进入该员工的系统，但你可能仍然需要执行某种特权提升操作，才能完全接管系统。你还可以看到，这只是你可以采取的实现目标的一个路径。
- en: '![](image_fi/502567c03/f03003.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c03/f03003.png)'
- en: 'Figure 3-3: A state machine graph'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-3：状态机图
- en: Now that you have an idea of what to do with graph theory, let’s discuss the
    math behind it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对图论的应用有了大致了解，让我们来讨论一下它背后的数学原理。
- en: Introduction to Graph Theory
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图论简介
- en: 'A graph *G* comprises the set of nodes *V* and the set of edges *E*. Information
    travels between nodes along a set of nonrepeating edges that connect them, called
    a *path*. A node may forward information to any node it’s directly connected to
    by an edge; the receiving node is the *neighbor* of the sending node. By convention
    I’ll denote an edge as a tuple (*u*, *v*) containing an origin node *u* and a
    terminal node *v*, where both *u* and *v* are in *V* and are unique (not equivalent).
    We can write this in set notation as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个图 *G* 包含节点集 *V* 和边集 *E*。信息通过一组不重复的边在节点之间传递，这组边将节点连接在一起，称为 *路径*。一个节点可以将信息转发给任何与其直接相连的节点；接收节点是发送节点的
    *邻居*。按照惯例，我将边表示为一个元组 (*u*, *v*)，其中 *u* 是源节点，*v* 是终端节点，且 *u* 和 *v* 都属于 *V* 且唯一（不等价）。我们可以用集合表示法写成如下：
- en: E ⊆ ( u, v ) ∈ V 2 ∧ u ≠ v
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: E ⊆ ( u, v ) ∈ V 2 ∧ u ≠ v
- en: Sometimes an edge in a graph points back to the same node (breaking my *u* ≠
    *v* assumption); this is known as *self-looping*. For example, if you create a
    graph of function calls in a program that contains a recursive function, there
    will be an edge that leaves the recursive function and points directly back to
    it. Self-loops don’t show up too often, but when they do they complicate the analysis
    and require specialized algorithms, so I recommend leaving them alone until you’re
    very comfortable with the basics of graph theory.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候图中的一条边会指向同一个节点（这打破了我的*u* ≠ *v*假设）；这被称为*自环*。例如，如果你创建一个包含递归函数的程序中的函数调用图，那么会有一条边从递归函数离开，并直接指向它本身。自环并不常见，但一旦出现，它们会使分析变得复杂，需要专门的算法，因此我建议在你对图论的基础知识非常熟悉之前，尽量避免处理自环。
- en: Depending on the type of graph, edges may be bidirectional (*undirected graphs*)
    or directional (*directed graphs*). If the direction of communication is important
    to the question at hand, use a directed graph. Otherwise, use an undirected graph.
    In practical implementation, undirected graphs are usually faster to work with
    since you assume (*u*, *v*) = (*v*, *u*). A lot of problem descriptions require
    directed edges, though. In the travel graph from [Figure 3-1](#figure3-1), flying
    from LAX to MIA has a different cost than flying from MIA to LAX, so we need to
    use directed edges between those two nodes to capture the directional information.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 根据图的类型，边可能是双向的（*无向图*）或单向的（*有向图*）。如果通信的方向对当前问题很重要，就使用有向图；否则，使用无向图。在实际应用中，无向图通常处理起来更快，因为你假设（*u*,
    *v*）=（*v*, *u*）。不过，很多问题描述需要有向边。例如，在[图3-1](#figure3-1)的旅行图中，从LAX飞往MIA的费用与从MIA飞往LAX的费用不同，因此我们需要在这两个节点之间使用有向边来捕捉方向信息。
- en: An edge may contain *edge attributes*, additional pieces of information beyond
    the two nodes it connects. Nodes may also contain additional information called
    *node attributes*. When one of these attributes is used in ranking a node or edge,
    it’s referred to as the node’s or edge’s *weight*, and a graph with weights is
    called a *weighted graph*. In some cases you may even need to add more than one
    edge connecting two nodes (called *edge multiplicity*) to account for different
    edge attributes or weights. I’ll cover edge multiplicity in its own section later
    in the chapter, but for now we can extend the travel graph from [Figure 3-1](#figure3-1)
    for a simple example. Suppose we find out there are multiple flights leaving SEA
    for LAX. We may choose to add an edge for each additional flight, along with its
    cost as the weight. Adding these edges for all city pairs would give us a sense
    of which airports had the most travel options for our trip. We’ll use multiple
    edges, edge attributes, and weighted graphs to inform our investigations in meaningful
    ways in the following chapters.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一条边可能包含*边属性*，即除了它连接的两个节点之外的额外信息。节点也可以包含额外的信息，称为*节点属性*。当这些属性用于排名节点或边时，它们被称为节点或边的*权重*，而包含权重的图称为*加权图*。在某些情况下，你甚至可能需要为连接两个节点添加多个边（称为*边的多重性*），以考虑不同的边属性或权重。我将在本章后面单独讨论边的多重性，但现在我们可以扩展[图3-1](#figure3-1)中的旅行图，来做一个简单的示例。假设我们发现有多趟航班从SEA飞往LAX。我们可以选择为每个额外的航班添加一条边，并将其费用作为权重。为所有城市对添加这些边会让我们了解哪些机场有更多的旅行选择。我们将在接下来的章节中使用多条边、边属性和加权图，以有意义的方式推动我们的研究。
- en: '*Simple graphs* are unweighted, undirected graphs containing no self-looping
    or edge multiplicity. *Nonsimple* graphs (or, less commonly, *pseudographs*),
    those that do contain self-loops or multiple edges, comprise the vast majority
    of interesting graphs you’ll encounter in practice.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*简单图*是无权重、无向的图，且不包含自环或边的多重性。*非简单图*（或不太常见的*伪图*）包含自环或多条边，它们占大多数实际中你会遇到的有趣图的类型。'
- en: A *cycle* of a graph *G* is a nonempty subset of *E* that forms a path such
    that the first node of the path corresponds to the last, and no other node is
    repeated along the path. This is a fancy way of saying a path that forms a closed
    loop. A self-loop is a special case of a graph cycle with a strict path length
    of 1\. A *cyclic graph* is one that contains at least one graph cycle. A graph
    that is not cyclic (has no loops) is *acyclic*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 *G* 的 *环* 是 *E* 的一个非空子集，形成一条路径，使得路径的第一个节点与最后一个节点相同，且路径中没有其他节点重复。这是说，路径形成了一个闭合的循环。自环是图环的一种特殊情况，其路径长度严格为
    1。*有向图* 是指至少包含一个图环的图。如果图中没有环（没有闭环），则该图是 *无环* 的。
- en: Before we go any further into the theory, let’s walk through how to build one
    of these graph objects programmatically. In the next section we’ll go over the
    current de facto standard library for Python graphs, NetworkX. Having access to
    the tools in this library will help you construct the examples in this book and
    play around with the theory at your own pace. The documentation for NetworkX also
    serves as a great reference to the theory that underlies each function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论理论之前，让我们先来看看如何通过编程构建这些图对象。在下一节中，我们将介绍当前 Python 图形的事实标准库 NetworkX。使用这个库中的工具将帮助你构建本书中的示例，并按自己的节奏玩转理论。NetworkX
    的文档也是理解每个函数背后理论的一个很好的参考。
- en: Creating Graphs in NetworkX
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 NetworkX 中创建图
- en: You can use NetworkX (which contains implementations of most graph algorithms)
    and Pyplot (a part of the Matplotlib library) to generate and display an undirected
    graph. [Listing 3-1](#listing3-1) creates a graph with seven nodes and six weighted
    edges, then displays it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 NetworkX（它包含大多数图算法的实现）和 Pyplot（Matplotlib 库的一部分）来生成并显示一个无向图。[示例 3-1](#listing3-1)
    创建了一个有七个节点和六条加权边的图，并将其显示出来。
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 3-1: Creating a basic weighted undirected graph'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-1：创建一个基本的加权无向图
- en: First, we import the two libraries required to build and display the graph ❶.
    (Aliasing NetworkX as `nx` and Pyplot as `plt` is a common convention in examples
    online.) Then, we create a basic undirected graph with the NetworkX `Graph` constructor
    ❷. Defining a graph in this way returns an empty graph (with no nodes or edges).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入构建和显示图形所需的两个库 ❶。（将 NetworkX 别名为`nx`，将 Pyplot 别名为`plt`，这是网络示例中的常见约定。）然后，我们使用
    NetworkX 的 `Graph` 构造函数 ❷ 创建一个基本的无向图。以这种方式定义的图会返回一个空图（没有节点或边）。
- en: 'To manually define the graph’s structure, or *topography*, we can add either
    nodes or edges. To add a node to the graph, we use the `graph.add_node` function
    ❸ with an argument to use as an identifier (ID) for the node (during lookups,
    for example). In this case, the ID is the string literal `f`, but an ID can be
    any object that could act as a key to a Python dictionary (tuples, for instance).
    The `graph.add_edge` function, which takes two nodes and optional edge attributes
    as arguments, adds edges directly to the graph ❹. If either `a` or `b` (or both,
    as in this case) doesn’t exist in the graph, NetworkX will helpfully add the missing
    node(s) before adding the edge. With directed graphs, the order in which you pass
    the nodes to `graph.add_edge` specifies the edge’s direction: the edge starts
    at the first node and concludes at the second.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了手动定义图的结构或 *拓扑*，我们可以添加节点或边。要向图中添加节点，我们使用 `graph.add_node` 函数 ❸，并传入一个参数作为节点的标识符（例如，在查找时）。在这个例子中，ID
    是字符串字面量 `f`，但 ID 可以是任何能作为 Python 字典键的对象（例如元组）。`graph.add_edge` 函数接受两个节点和可选的边属性作为参数，直接将边添加到图中
    ❹。如果 `a` 或 `b`（或者两者，如此例）在图中不存在，NetworkX 会在添加边之前帮助你添加缺失的节点。对于有向图，你传递给 `graph.add_edge`
    的节点顺序决定了边的方向：边从第一个节点开始，到达第二个节点。
- en: 'The real strength of graphs lies in their visual interpretations, as humans
    very often can detect patterns in information visually that they wouldn’t have
    found otherwise. NetworkX supports several options for displaying graph information,
    including Matplotlib and Graphviz. For this example, we lay out the graph with
    one of NetworkX’s built-in layout functions, `nx.layout.spring_layout` ❺, which
    uses a physics model of spring motion to position the nodes. The nodes’ initial
    positions are randomly generated, but you can pass in the `seed` argument to make
    the image reproducible, which can be important if you want to share the conclusions
    from your research with others. The resulting node positions are stored in the
    dictionary `pos`, with structure `{node ID: (``x-coordinate``,` `y-coordinate``)}`.
    The function `nx.draw` creates a plot object using these node positions, and Matplotlib
    displays the resulting figure. The additional parameters to `nx.draw`, `labels`
    and `font_color`, control the look of the graph, shown in [Figure 3-4](#figure3-4).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '图形的真正优势在于它们的视觉解读，因为人类往往能在信息中通过视觉发现模式，这是其他方式难以做到的。NetworkX 支持多种显示图形信息的选项，包括
    Matplotlib 和 Graphviz。在这个示例中，我们使用 NetworkX 内置的布局函数之一 `nx.layout.spring_layout`
    ❺ 来布局图形，它利用弹簧运动的物理模型来定位节点。节点的初始位置是随机生成的，但你可以传入 `seed` 参数使图形可复现，这在你想与他人分享研究结论时非常重要。最终的节点位置存储在字典
    `pos` 中，结构为 `{node ID: (``x-coordinate``, ``y-coordinate``)}`。函数 `nx.draw` 使用这些节点位置创建一个绘图对象，Matplotlib
    显示结果图形。`nx.draw` 的附加参数 `labels` 和 `font_color` 控制图形的外观，见 [图 3-4](#figure3-4)。'
- en: '![](image_fi/502567c03/f03004.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c03/f03004.png)'
- en: 'Figure 3-4: An undirected graph'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-4：一个无向图
- en: If you remove the `seed` parameter and rerun the code your graph may look different,
    but it’s guaranteed to be mathematically equivalent to the one in [Figure 3-4](#figure3-4).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你移除 `seed` 参数并重新运行代码，图形可能会有所不同，但它与 [图 3-4](#figure3-4) 中的图形在数学上是等效的。
- en: Now that we have a way to codify and visualize graphs, let’s look at some interesting
    measurements you can use in your analysis.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种编码和可视化图形的方法，让我们来看一些你可以在分析中使用的有趣度量。
- en: Discovering Relationships in Data
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现数据中的关系
- en: In this section, we’ll examine a few of the most-used graph properties that
    can give us insight into the underlying relationships in our data. These properties
    are expressed as statistical relationships, such as the ratio of the number of
    possible paths between two nodes to the total number of paths in the graph. Typically
    we’re interested in learning things like which nodes are isolated from other nodes,
    what are the shortest or longest possible paths between nodes, and how many different
    nodes can be reached from a particular starting node. There are dozens of possible
    graph properties to explore, but some are suitable only for certain types of graphs,
    while others are specialized use cases of these more general properties. The ones
    described here will give you everything you need to understand the projects in
    the next three chapters, but it’s by no means a complete list.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考察一些最常用的图形属性，这些属性能帮助我们洞察数据中的潜在关系。这些属性以统计关系的形式表现出来，例如两个节点之间可能路径数与图中总路径数的比率。通常我们关心的是了解哪些节点与其他节点隔离，节点之间的最短或最长可能路径是什么，以及从特定起始节点可以到达多少个不同的节点。有数十种可能的图形属性可供探索，但有些属性仅适用于某些类型的图形，而另一些则是这些更一般属性的特定应用场景。这里描述的属性将为你理解接下来三章的项目提供所需的所有知识，但这并不是一个完整的列表。
- en: Measuring Node Importance
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 衡量节点重要
- en: A key concept in security is measuring the importance of different assets, be
    they human or machine, and the impact that compromising them may have on the operation
    of the organization as a whole. To do so, we need a way to measure which nodes
    are in critical positions. *Closeness* measures the connectivity of two nodes
    relative to the other connections in the graph.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全性中，一个关键概念是衡量不同资产的重要性，无论是人类还是机器，以及破坏它们可能对整个组织运营产生的影响。为此，我们需要一种衡量哪些节点处于关键位置的方法。*紧密度*衡量两个节点相对于图中其他连接的连通性。
- en: 'When you apply closeness across all nodes in the graph, you’re measuring some
    type of *centrality* (roughly, “importance”) for each node. There are several
    types of centrality defined for graphs. The proper one to use depends on the behavior
    and structure of the network you’re trying to analyze.^([3](b01.xhtml#c03-endnote-003))
    Sometimes you won’t know in advance which measure of centrality makes the most
    sense for your problem. In these cases, start with simpler metrics (like closeness
    centrality) and move on to testing with other, more complex ones. We’ll cover
    two types of centrality: betweenness centrality and degree centrality.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在图中的所有节点上应用接近度时，你实际上是在测量每个节点的某种*中心性*（大致上是“重要性”）。图中定义了几种类型的中心性。选择使用哪种类型取决于你试图分析的网络的行为和结构。^([3](b01.xhtml#c03-endnote-003))有时你无法预先知道哪种中心性度量最适合你的问题。在这些情况下，先从较简单的度量（如接近中心性）开始，然后再尝试其他更复杂的度量。我们将介绍两种中心性：介于中心性和度数中心性。
- en: Finding Nodes That Facilitate Connections
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 寻找促进连接的节点
- en: '*Betweenness centrality* considers nodes that connect other nodes together
    as more central to the graph. Consider a computer network like the one in [Figure
    3-5](#figure3-5), where some systems act as proxies to connect users to databases.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*介于中心性*将连接其他节点的节点视为图中更中心的节点。考虑一个计算机网络，如[图3-5](#figure3-5)所示，其中一些系统充当代理，将用户连接到数据库。'
- en: '![](image_fi/502567c03/f03005.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c03/f03005.png)'
- en: 'Figure 3-5: A simple proxy network'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-5：一个简单的代理网络
- en: Betweenness centrality rates the gray proxy nodes much higher than any of the
    other nodes (the users and databases), since five of the seven users must connect
    to one of the two proxies to reach either database. The light gray circle at the
    top is between six paths (3 users × 2 databases = 6 paths) and the dark gray circle
    at the bottom is between four paths (2 users × 2 databases = 4 paths). The centrality
    is further strengthened by the fact that these five users must pass through their
    respective proxy to reach the databases.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 介于中心性将灰色代理节点的评分大大高于其他任何节点（如用户和数据库），因为七个用户中的五个必须通过两个代理之一才能到达任一数据库。顶部的浅灰色圆圈位于六条路径之间（3个用户
    × 2个数据库 = 6条路径），底部的深灰色圆圈位于四条路径之间（2个用户 × 2个数据库 = 4条路径）。此外，由于这五个用户必须通过各自的代理才能访问数据库，中心性进一步得到增强。
- en: 'Formally speaking, betweenness centrality of a node *u* is the sum of ratios
    of all shortest paths from node *s* to node *t*, which pass through node *u* (noted
    as σ[(][*s*][,] [*t*][)](*u*)), compared to the total number of shortest paths
    between node *s* and node *t* (noted as σ[(][*s*][,] [*t*][)]) for all paths where
    *s* ≠ *u* ≠ *t*. Putting it all together looks like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从正式的角度来看，节点*u*的介于中心性是从节点*s*到节点*t*的所有最短路径的比率之和，这些路径必须通过节点*u*（记作σ[(][*s*][,] [*t*][)](*u*)），与节点*s*和节点*t*之间所有最短路径的总数（记作σ[(][*s*][,]
    [*t*][)]）相比，适用于所有*s* ≠ *u* ≠ *t*的路径。将这一切汇总起来如下所示：
- en: '![](image_fi/502567c03/m03001.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c03/m03001.png)'
- en: 'The betweenness scores can be normalized to the number of nodes in *G*. The
    normalization function is 2 / ((*n* – 1)(*n* – 2)) for undirected graphs, and
    1 / ((*n* – 1)(*n* – 2)) for directed graphs (where *n* is the number of nodes
    in the graph). The difference is due to the impact of directionality on the normalization.
    For undirected graphs, adding an edge between two nodes affects the betweenness
    score of both nodes and therefore carries twice as much influence as the same
    edge in a directed graph that impacts only one node (the source node). The normalization
    scores for both a directed and an undirected graph with five nodes each are calculated
    as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 介于中心性分数可以归一化到图中节点的数量*G*。归一化函数对于无向图为 2 / ((*n* – 1)(*n* – 2))，对于有向图为 1 / ((*n*
    – 1)(*n* – 2))（其中*n*是图中节点的数量）。这种差异源于方向性对归一化的影响。对于无向图，在两个节点之间添加一条边会影响这两个节点的介于中心性分数，因此它的影响是有向图中相同边的两倍（后者仅影响一个节点，即源节点）。计算具有五个节点的有向图和无向图的归一化分数如下所示：
- en: '![](image_fi/502567c03/m03002.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c03/m03002.png)'
- en: Unlike some other measures of centrality (such as closeness centrality), normalizing
    betweenness centrality is optional in NetworkX, and is specified by the Boolean
    keyword argument `normalized=True`. [Listing 3-2](#listing3-2) shows how we can
    retrieve the betweenness centrality scores for the map generated in [Listing 3-1](#listing3-1).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与某些其他中心性度量（如接近中心性）不同，NetworkX 中的介于中心性是否归一化是可选的，可以通过布尔关键字参数`normalized=True`来指定。[列表3-2](#listing3-2)展示了我们如何检索在[列表3-1](#listing3-1)中生成的图的介于中心性分数。
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 3-2: Betweenness centrality for the graph created in [Listing 3-1](#listing3-1)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 清单3-2：在[清单3-1](#listing3-1)中创建的图的中介中心性
- en: The normalized result for the example graph should be approximately 0.8\. There
    are a total of 15 shortest paths between all node pairs in [Figure 3-4](#figure3-4)
    (excluding pairs with *c* as the start or end node). Of those 15, 12 paths pass
    through *c* at some point (12 / 15 = 0.8). The Jupyter notebook for this example
    shows how you can manually calculate the betweenness score by looping over the
    node pairs and counting the number of shortest paths that contain the target node.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例图的归一化结果应约为0.8。在[图3-4](#figure3-4)中，共有15条最短路径连接所有节点对（排除以*c*作为起始或结束节点的对）。在这15条路径中，12条路径在某些点上经过*c*（12
    / 15 = 0.8）。该示例的Jupyter笔记本展示了如何通过循环遍历节点对并计算包含目标节点的最短路径数量，手动计算中介中心性分数。
- en: Betweenness centrality has many applications within information security and
    network analysis because it represents the degree to which a node facilitates
    communication between other nodes. For example, a node in a computer network with
    high betweenness centrality would have more control over the network traffic,
    because more packets will eventually pass through it. For this reason, betweenness
    centrality can also be used to identify good places to perform inspections on
    network traffic. Another application is understanding critical points of failure
    in social networks, which we’ll discuss more in [Chapter 6](c06.xhtml).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 中介中心性在信息安全和网络分析中有许多应用，因为它表示一个节点在多大程度上促进了其他节点之间的通信。例如，在计算机网络中，一个具有高中介中心性的节点将对网络流量有更多的控制，因为更多的数据包最终会经过它。因此，中介中心性也可以用来识别在网络流量中进行检查的合适位置。另一个应用是理解社交网络中的关键故障点，我们将在[第6章](c06.xhtml)中进一步讨论。
- en: Measuring the Number of Node Connections
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测量节点连接数
- en: Centrality can also be measured by how many neighbors a node has; this is known
    as *degree centrality*. Intuitively, degree centrality favors nodes that have
    a larger number of connections to other nodes in the graph. (Betweenness centrality
    can be seen as a specific measure of degree centrality.)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 中心性还可以通过节点拥有的邻居数量来衡量；这被称为*度中心性*。直观地说，度中心性偏向于那些与图中其他节点连接数量较多的节点。（中介中心性可以视为度中心性的一个特定衡量标准。）
- en: For undirected graphs, degree centrality is calculated as the fraction of all
    nodes that are connected directly to a node *u*. You’ll commonly see the neighbors
    of a node *u* annotated as *Γ*[(][*u*][)].
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无向图，度中心性计算为与节点*u*直接连接的所有节点的比例。你通常会看到节点*u*的邻居标注为*Γ*[(][*u*][)]。
- en: '![](image_fi/502567c03/m03003.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c03/m03003.png)'
- en: Remember from the math primer at the start of the book that the absolute value
    of a set of nodes (|*V*|, for example) is the same as the number of nodes in the
    set. We subtract 1 from the length of *V* to account for the fact that node *c*
    cannot be a neighbor of itself. Undirected degree centrality is calculated using
    `nx.degree_centrality`, as shown in [Listing 3-3](#listing3-3). The bold areas
    show the few changes required from [Listing 3-2](#listing3-2).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在书本开头的数学入门部分，节点集合的绝对值（例如|*V*|）与集合中节点的数量相同。我们从*V*的长度中减去1，以考虑到节点*c*不能是其自身的邻居。无向度中心性通过`nx.degree_centrality`来计算，如[清单3-3](#listing3-3)所示。粗体部分显示了与[清单3-2](#listing3-2)相比所需的少量更改。
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 3-3: Degree centrality with changes from [Listing 3-2](#listing3-2)
    in bold'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 清单3-3：带有来自[清单3-2](#listing3-2)更改的度中心性（粗体部分）
- en: The output of this code should be approximately 0.66, meaning node *c* is neighbors
    with two-thirds of the total number of nodes in the graph. In [Figure 3-4](#figure3-4)
    you can see that node *c* has four neighbors and, excluding *c*, there are a total
    of six nodes that could be neighbors of *c*. That gives us 4 / 6 = 2 / 3 = 0.66,
    which matches the `nx.degree_centrality` result.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出应约为0.66，这意味着节点*c*与图中三分之二的节点是邻居。如[图3-4](#figure3-4)所示，节点*c*有四个邻居，除去*c*，总共有六个节点可能是*c*的邻居。于是我们得到4
    / 6 = 2 / 3 = 0.66，这与`nx.degree_centrality`的结果一致。
- en: For directed graphs, the degree centrality measure gets split in two pieces.
    The first deals with edges leading into a node, aptly named *in-degree centrality*.
    The second measure deals with edges leading out of a node, called *out-degree
    centrality*. The calculation for each is the same as for degree centrality, except
    that it considers only the subset of edges matching the specified direction. We
    denote these sets of edges as
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有向图，度数中心性度量被分为两个部分。第一个部分涉及指向节点的边，称为*入度中心性*。第二个部分涉及从节点指向其他节点的边，称为*出度中心性*。每个度量的计算方法与度数中心性相同，只不过它只考虑符合指定方向的边的子集。我们将这些边的集合表示为
- en: ( u → ) = E( u, )
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ( u → ) = E( u, )
- en: for out-degree and
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于出度和
- en: ( u ← ) = E( ,u )
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ( u ← ) = E( ,u )
- en: for in-degree. [Listing 3-4](#listing3-4) creates a directed version of the
    graph from [Listing 3-1](#listing3-1), then calculates in-degree and out-degree
    centrality for each node in the graph.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于入度。[清单 3-4](#listing3-4)创建了[清单 3-1](#listing3-1)的有向版本，然后计算了图中每个节点的入度和出度中心性。
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 3-4: Creating a directed graph to measure in-degree and out-degree
    centrality'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-4：创建有向图以衡量入度和出度中心性
- en: To make the graph directed, we replace the generator `nx.Graph` with `nx.DiGraph`
    ❶. Then, we use `nx.in_degree_centrality` ❷ and `nx.out_degree_centrality` ❸ to
    get their respective measures. The result of the code should be 0.33 for both
    values. If you examine the data, you’ll see that node *c* has two incoming edges
    and two outgoing edges of the six total edges we defined. For each measure, then,
    the math works out to be 2 / 6 = 1 / 3 = 0.33\. If you try running [Listing 3-4](#listing3-4)
    against an undirected graph, you’ll get an error of the type `NetworkXError`,
    because in-degree and out-degree are specific to the `nx.DiGraph` and `nx.MultiDiGraph`
    objects.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使图变为有向图，我们将生成器`nx.Graph`替换为`nx.DiGraph` ❶。然后，我们使用`nx.in_degree_centrality`
    ❷和`nx.out_degree_centrality` ❸来获得各自的度量值。代码的结果应该是两个值都为0.33。如果你检查数据，你会发现节点*c*有两条入边和两条出边，总共有六条边。对于每个度量来说，计算公式是2
    / 6 = 1 / 3 = 0.33。如果你尝试在无向图上运行[清单 3-4](#listing3-4)，你会得到一个`NetworkXError`类型的错误，因为入度和出度是特定于`nx.DiGraph`和`nx.MultiDiGraph`对象的。
- en: The family of degree metrics allows us to specify the direction of information
    flow while calculating the scores, whereas both the closeness and betweenness
    measures make assumptions about the directionality. To understand why this matters,
    consider analyzing network traffic related to a *distributed denial-of-service
    (DDoS)* attack. A DDoS attack floods a network or specific target machine with
    more traffic than it is capable of processing, thereby blocking legitimate users’
    access. As packets travel from one system to the next, they create directed edges
    on the graph. A sudden increase of in-degree centrality would be seen at the target
    nodes, which could allow a script to automatically detect and respond to this
    threat. By including the direction of information flow, you can often provide
    more meaningful context to your graphs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 度数度量的家族允许我们在计算得分时指定信息流的方向，而接近中心性和介数中心性度量则假设了方向性。为了理解为什么这很重要，考虑分析与*分布式拒绝服务攻击（DDoS）*相关的网络流量。DDoS攻击通过将超出目标机器处理能力的流量发送到网络或特定目标，从而阻塞合法用户的访问。随着数据包从一个系统传输到另一个系统，它们在图中形成有向边。在目标节点处，可以看到入度中心性突然增加，这可以让脚本自动检测并响应这一威胁。通过包括信息流的方向，通常可以为你的图提供更有意义的背景。
- en: Analyzing Cliques to Track Associations
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析团体以追踪关联
- en: Investigators use *clique analysis* to track the associations of different groups
    who aren’t kind enough to hand out membership lists. By collecting a list of who
    is talking to whom (and sometimes when), you can find interconnected clusters,
    or cliques. In theory, a clique *β* in graph *G* is any subset of *V* in which
    each node is adjacent to each other node in the set. Think of this as a group
    of friends who have all met each other, or a cluster of computers that are all
    connected. Some material may refer to these constructs as *complete subgraphs*.
    [Figure 3-6](#figure3-6) shows an undirected graph containing different cliques.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 调查人员使用*团体分析*来追踪不同群体之间的关联，这些群体通常不会主动提供成员名单。通过收集谁与谁在交流（有时还包括何时交流），你可以发现相互连接的簇，或者称为团体。从理论上讲，图*G*中的一个团体*β*是*V*的一个子集，其中每个节点都与子集中的其他节点相邻。可以把它看作是一群已经彼此见过面的朋友，或者是一群所有计算机都已连接的计算机集群。一些资料可能将这些构造称为*完全子图*。[图
    3-6](#figure3-6)展示了一个包含不同团体的无向图。
- en: '![](image_fi/502567c03/f03006.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c03/f03006.png)'
- en: 'Figure 3-6: A cartoon character graph'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'A node may be in zero or more cliques. In the graph in [Figure 3-6](#figure3-6),
    for example, Tom is in three cliques: Tom, Spike, and Jerry; Tom, Butch, and Jerry;
    and Tom, Squeek, and Butch. [Listing 3-5](#listing3-5) creates the graph from
    [Figure 3-6](#figure3-6) and calculates a clique membership score for each node.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 3-5: Creating the cartoon clique graph in [Figure 3-6](#figure3-6)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to `nx.algorithms.number_of_cliques` tallies the number of cliques
    each node belongs to, which you can use to easily find the node in the most cliques.
    To find the total number of cliques in the graph, we use `nx.graph_number_of_cliques`.
    We can then combine the number of cliques for each node and the total number of
    cliques to create a normalized score to determine which members of a network are
    key facilitators. The output from running this example code should be:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tom is in every clique, Jerry and Butch are each in two-thirds of the possible
    cliques, and Spike and Squeek are only in one-third of the possible cliques. Clearly,
    Tom is the best-known member of this network. In social networks, like a company
    or an organized crime syndicate, the members in the most cliques are key to facilitating
    the operations. If we wanted to disrupt the activities of this organization, removing
    Tom would go a long way toward achieving that. You can also measure clique membership
    in your network to identify nodes that act as gateways between otherwise separate
    parts of the network.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The function `nx.algorithms.number_of_cliques` finds the number of *maximal*
    cliques to which each node belongs—that is, the largest group of nodes that are
    all connected to one another. In undirected graphs, any two adjacent nodes could
    be considered a clique, and, in any graph, cliques of four or more nodes contain
    cliques of three and two nodes, so working with maximal cliques takes those subcliques
    into account.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: You can enumerate all the maximal cliques in a graph with the `nx.find_cliques`
    function, as shown in [Listing 3-6](#listing3-6).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 3-6: Creating a list of cliques from a directed graph'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The result is a `Generator` object, which is a built-in object type in Python
    3\. You can either use it directly or cast it to a `list`. We’ll see a practical
    application of finding cliques using `nx.find_cliques` in [Chapter 5](c05.xhtml)
    when we build a social network graph from posts.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Determining the Connectedness of the Network
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Graphs can be connected or disconnected. A *connected* graph is one where every
    node pair (*u*, *v*) has some connecting path (*ρ*). Therefore, a graph *G* is
    *disconnected* if any pair of nodes (*u*, *v*) doesn’t have a connecting path
    (*ρ*) using any subset of edges in *E*. The only way to know whether or not a
    graph is connected is to check every pair of nodes to see if they’re disconnected.
    We can write this out neatly using set notation and Boolean algebra:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c03/m03004.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: A Boolean statement such as *ρ*(*u*, *v*) ⊄ *E* returns `1` if it is true and
    `0` otherwise, so this equation technically counts all pairs of disconnected nodes.
    In practical implementations, we don’t need to continue searching all remaining
    pairs of *G* because once we discover a missing edge, we know it’s a disconnected
    graph. We can only say a graph is connected, however, once we’ve checked every
    pair of nodes and found no disconnected pairs. You can go through this exercise
    yourself with the graph from [Figure 3-1](#figure3-1) to determine if it’s a connected
    or disconnected map.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-7](#figure3-7) shows the graph from [Figure 3-6](#figure3-6) extended
    to be a disconnected graph.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c03/f03007.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-7: A disconnected graph'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'A disconnected graph is made up of two or more disparate sections called *connected
    components* (or just *components*). Formally speaking, a connected component of
    an undirected graph *G* (ϕ[*i*](*G*)) is a subgraph in which every pair of nodes
    (*u*, *v*) is connected by a path *ρ*(*u*, *v*) ∈ *E* (annotated *ρ*(ϕ[*i*], *u*,
    *v*) for a path in the *i*th component subgraph). Additionally, none of the nodes
    in ϕ may be connected to any additional nodes in the superset *V*. For example,
    the graph shown in [Figure 3-7](#figure3-7) has two connected components: one
    comprising cartoon characters, and the other comprising former bandmates.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Using Graph Edges to Capture Important Details
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final graph property we’ll examine is one I mentioned earlier, edge multiplicity.
    This property is powerful once you know how to leverage the flexibility it brings
    to your analysis. In many practical instances, like the packet analysis project
    in the next chapter, there may be multiple edges between nodes that contain valuable
    information we want to keep for analysis.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: For example, graphing the TCP handshake requires multiple directed edges between
    two nodes. The connecting machine (also called the *client*) sends a synchronization
    request to the target machine (a SYN packet), which creates one directed edge
    from *u* to *v* in the graph. The target machine then responds with an acknowledgment
    as well as a request of its own to synchronize (a SYN-ACK packet), which creates
    a directed edge from *v* back to *u*. (In an undirected graph, this response would
    count as a duplicate of the first edge.) Finally, the connecting machine sends
    the target machine its own acknowledgment packet (an ACK packet), which creates
    a second directed edge from *u* to *v* in the graph. [Figure 3-8](#figure3-8)
    shows two versions of the same graph data containing TCP handshakes between two
    different groups of systems.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c03/f03008.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-8: Comparing single- and multi-edge graphs'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: On the left is a standard `DiGraph` representation, which treats repeated communications
    between two nodes as a single directed edge. Examining this graph alone, you couldn’t
    determine which nodes participated in a TCP handshake. On the right is a `MultiDiGraph`
    representation of the same data, which retains an edge for each occurrence of
    communication. Examining this graph, you can easily see that node *c* initiated
    a handshake-like exchange with node *d*. Node *a* also initiated a handshake with
    node *b*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two schools of thought for dealing with edge multiplicity. The first
    school says you should summarize multiple edges based on their weight ω (and potentially
    other attributes) into a singular edge, like so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c03/m03005.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: 'If the constituent edges are unweighted, the weight is the number of edges
    making up the composite:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: ( u → v ) ω = | ( u → v ) | ∈ E
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: This summation must take into account the directionality of edges when dealing
    with directed graphs. (If you’re using complex values for edge attributes—such
    as ranges, which require specialized processing to summarize—you’ll be better
    off implementing your own definition of edge summation in a function within your
    code.)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The second school of thought is to graph each edge individually and summarize
    edges only when it comes time to analyze them. Doing so allows you to retain more
    of the underlying structure. As an example, consider timestamp information on
    network packets. If you sum the edges into a single edge like the preceding example,
    you can’t see the order in which the edges are created. Retaining each edge allows
    you to order their creation by timestamp and look for interesting patterns, like
    call and response pairs in edges.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: There’s no generally right or wrong way to handle edge multiplicity in a graph.
    The correct approach is often a little of both schools of thought, as we’ll see
    in the next chapter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The power of graph theory lies in the flexible interpretation of nodes and
    edges. Do nodes represent people, computers, cities, or something else entirely?
    Do edges measure physical distances or intangible relationships? The answer to
    all these questions is yes. Be warned, though: this freedom of perception is a
    double-edged sword. Because there are no strict definitions of what a node or
    edge represents, you can create a graph whose edges and analysis have no meaningful
    relationship to reality. An example would be using nodes that represent computers
    and edges that represent the physical distance between two cities where the computers
    are located. We typically don’t think about how far a message travels on the internet
    in terms of physical distance, but rather in terms of the number of network “hops”
    it has to make before reaching its destination. Over the next three chapters,
    I’ll explain the justification for different interpretations of information in
    more depth, because the meaning of a result, such as closeness centrality, relies
    on the meaning of an edge’s weight and needs a bit of context to make sense.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a lot more useful theory than what I’ve covered here. The book *Introduction
    to Graph Theory* by Richard Trudeau (Dover, 2001) is an excellent resource.^([4](b01.xhtml#c03-endnote-004))
    If you’re looking for a more advanced discussion, check out *Graph Theory and
    Complex Networks: An Introduction* by Maarten van Steen (author, 2010).^([5](b01.xhtml#c03-endnote-005))
    Both books make the topics easy to understand and the math easy to follow. For
    something more security focused, check out the paper “Applied Graph Theory to
    Security: A Qualitative Placement of Security Solutions within IoT networks,”
    published in the *Journal of Information Security and Applications* in December
    2020, which uses graph theory to analyze the security of IoT network devices and
    determine suitable locations for monitoring device traffic.^([6](b01.xhtml#c03-endnote-006))'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: In the next two chapters, we’ll put these theoretical concepts to work by examining
    both a computer network and a human social network to learn which nodes are important
    to the network, what information is being exchanged, and other important insights
    about the underlying graph structure. The final graph theory project, in [Chapter
    6](c06.xhtml), will give you the tools you need to simulate changes to a network
    over time. Once you understand the concepts and interpretations, the insights
    you can gain will make graph theory one of the most powerful and versatile weapons
    in your analytical arsenal.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
