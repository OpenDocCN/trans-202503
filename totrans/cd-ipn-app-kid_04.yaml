- en: '**3**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MAKING CHOICES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we’ve covered how to create constants and variables, you’re ready to
    learn how to tell your computer to make choices. This chapter is about controlling
    the flow of a computer program by telling the computer which path to take. When
    we talk about *flow* , we’re referring to the order in which the statements of
    the program are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, you’ve only seen statements performed in the order you’ve
    typed them. You’ve done some cool things with this, but by telling the computer
    how to make choices about the order of executing statements, you can do even more.
    To get the computer to make a choice, we’ll use *conditional statements* that
    tell the computer to run some code based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: You already use conditional statements to make choices every day! For example,
    before you leave home in the morning, you check the weather. If it’s sunny, you
    may put on a pair of sunglasses. If it’s raining, you grab your umbrella. In each
    case, you’re checking a condition. If the condition “it is raining” is true, then
    you take your umbrella when you leave the house. When the condition could be true
    or false, it’s called a *Boolean expression* . The Bool data type that you learned
    about in [Chapter 2](text00012.html#ch02) is used to represent the value true
    or false .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00076.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common type of Boolean expression is one that compares two values using a
    *comparison operator* . There are six comparison operators. Let’s start with two
    simple ones: *is equal* and *is not equal* .'
  prefs: []
  type: TYPE_NORMAL
- en: '**IS EQUAL AND IS NOT EQUAL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try them both out in the playground!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: MAKING CHOICES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we’ve covered how to create constants and variables, you’re ready to
    learn how to tell your computer to make choices. This chapter is about controlling
    the flow of a computer program by telling the computer which path to take. When
    we talk about *flow* , we’re referring to the order in which the statements of
    the program are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, you’ve only seen statements performed in the order you’ve
    typed them. You’ve done some cool things with this, but by telling the computer
    how to make choices about the order of executing statements, you can do even more.
    To get the computer to make a choice, we’ll use *conditional statements* that
    tell the computer to run some code based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: You already use conditional statements to make choices every day! For example,
    before you leave home in the morning, you check the weather. If it’s sunny, you
    may put on a pair of sunglasses. If it’s raining, you grab your umbrella. In each
    case, you’re checking a condition. If the condition “it is raining” is true, then
    you take your umbrella when you leave the house. When the condition could be true
    or false, it’s called a *Boolean expression* . The Bool data type that you learned
    about in [Chapter 2](text00012.html#ch02) is used to represent the value true
    or false .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00076.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common type of Boolean expression is one that compares two values using a
    *comparison operator* . There are six comparison operators. Let’s start with two
    simple ones: *is equal* and *is not equal* .'
  prefs: []
  type: TYPE_NORMAL
- en: '**IS EQUAL AND IS NOT EQUAL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try them both out in the playground!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![image](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we’ve covered how to create constants and variables, you’re ready to
    learn how to tell your computer to make choices. This chapter is about controlling
    the flow of a computer program by telling the computer which path to take. When
    we talk about *flow* , we’re referring to the order in which the statements of
    the program are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, you’ve only seen statements performed in the order you’ve
    typed them. You’ve done some cool things with this, but by telling the computer
    how to make choices about the order of executing statements, you can do even more.
    To get the computer to make a choice, we’ll use *conditional statements* that
    tell the computer to run some code based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: You already use conditional statements to make choices every day! For example,
    before you leave home in the morning, you check the weather. If it’s sunny, you
    may put on a pair of sunglasses. If it’s raining, you grab your umbrella. In each
    case, you’re checking a condition. If the condition “it is raining” is true, then
    you take your umbrella when you leave the house. When the condition could be true
    or false, it’s called a *Boolean expression* . The Bool data type that you learned
    about in [Chapter 2](text00012.html#ch02) is used to represent the value true
    or false .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00076.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common type of Boolean expression is one that compares two values using a
    *comparison operator* . There are six comparison operators. Let’s start with two
    simple ones: *is equal* and *is not equal* .'
  prefs: []
  type: TYPE_NORMAL
- en: '**IS EQUAL AND IS NOT EQUAL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try them both out in the playground!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we’ve covered how to create constants and variables, you’re ready to
    learn how to tell your computer to make choices. This chapter is about controlling
    the flow of a computer program by telling the computer which path to take. When
    we talk about *flow* , we’re referring to the order in which the statements of
    the program are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, you’ve only seen statements performed in the order you’ve
    typed them. You’ve done some cool things with this, but by telling the computer
    how to make choices about the order of executing statements, you can do even more.
    To get the computer to make a choice, we’ll use *conditional statements* that
    tell the computer to run some code based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: You already use conditional statements to make choices every day! For example,
    before you leave home in the morning, you check the weather. If it’s sunny, you
    may put on a pair of sunglasses. If it’s raining, you grab your umbrella. In each
    case, you’re checking a condition. If the condition “it is raining” is true, then
    you take your umbrella when you leave the house. When the condition could be true
    or false, it’s called a *Boolean expression* . The Bool data type that you learned
    about in [Chapter 2](text00012.html#ch02) is used to represent the value true
    or false .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00076.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common type of Boolean expression is one that compares two values using a
    *comparison operator* . There are six comparison operators. Let’s start with two
    simple ones: *is equal* and *is not equal* .'
  prefs: []
  type: TYPE_NORMAL
- en: '**IS EQUAL AND IS NOT EQUAL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try them both out in the playground!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Up to this point, you’ve only seen statements performed in the order you’ve
    typed them. You’ve done some cool things with this, but by telling the computer
    how to make choices about the order of executing statements, you can do even more.
    To get the computer to make a choice, we’ll use *conditional statements* that
    tell the computer to run some code based on a condition’s value.
  prefs: []
  type: TYPE_NORMAL
- en: You already use conditional statements to make choices every day! For example,
    before you leave home in the morning, you check the weather. If it’s sunny, you
    may put on a pair of sunglasses. If it’s raining, you grab your umbrella. In each
    case, you’re checking a condition. If the condition “it is raining” is true, then
    you take your umbrella when you leave the house. When the condition could be true
    or false, it’s called a *Boolean expression* . The Bool data type that you learned
    about in [Chapter 2](text00012.html#ch02) is used to represent the value true
    or false .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00076.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common type of Boolean expression is one that compares two values using a
    *comparison operator* . There are six comparison operators. Let’s start with two
    simple ones: *is equal* and *is not equal* .'
  prefs: []
  type: TYPE_NORMAL
- en: '**IS EQUAL AND IS NOT EQUAL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try them both out in the playground!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You already use conditional statements to make choices every day! For example,
    before you leave home in the morning, you check the weather. If it’s sunny, you
    may put on a pair of sunglasses. If it’s raining, you grab your umbrella. In each
    case, you’re checking a condition. If the condition “it is raining” is true, then
    you take your umbrella when you leave the house. When the condition could be true
    or false, it’s called a *Boolean expression* . The Bool data type that you learned
    about in [Chapter 2](text00012.html#ch02) is used to represent the value true
    or false .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00076.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common type of Boolean expression is one that compares two values using a
    *comparison operator* . There are six comparison operators. Let’s start with two
    simple ones: *is equal* and *is not equal* .'
  prefs: []
  type: TYPE_NORMAL
- en: '**IS EQUAL AND IS NOT EQUAL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try them both out in the playground!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![image](Image00076.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common type of Boolean expression is one that compares two values using a
    *comparison operator* . There are six comparison operators. Let’s start with two
    simple ones: *is equal* and *is not equal* .'
  prefs: []
  type: TYPE_NORMAL
- en: '**IS EQUAL AND IS NOT EQUAL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try them both out in the playground!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common type of Boolean expression is one that compares two values using a
    *comparison operator* . There are six comparison operators. Let’s start with two
    simple ones: *is equal* and *is not equal* .'
  prefs: []
  type: TYPE_NORMAL
- en: '**IS EQUAL AND IS NOT EQUAL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try them both out in the playground!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A common type of Boolean expression is one that compares two values using a
    *comparison operator* . There are six comparison operators. Let’s start with two
    simple ones: *is equal* and *is not equal* .'
  prefs: []
  type: TYPE_NORMAL
- en: '**IS EQUAL AND IS NOT EQUAL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try them both out in the playground!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**IS EQUAL AND IS NOT EQUAL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try them both out in the playground!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try them both out in the playground!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s try them both out in the playground!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![Image](Image00077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![Image](Image00078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**GREATER THAN AND LESS THAN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![Image](Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 3-1:** Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 3-2:** Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| **Symbol** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![Image](Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Try changing the value of age to 18 to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![Image](Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now test out OR by entering this code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![Image](Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![image](Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![Image](Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**CONDITIONAL STATEMENTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![image](Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**else Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**else if Statements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![image](Image00086.jpg)![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![image](Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**CODE WITH STYLE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![Image](Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![image](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
