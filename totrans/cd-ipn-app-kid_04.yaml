- en: '**3**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: MAKING CHOICES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做出选择
- en: '![image](Image00001.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00001.jpg)'
- en: Now that we’ve covered how to create constants and variables, you’re ready to
    learn how to tell your computer to make choices. This chapter is about controlling
    the flow of a computer program by telling the computer which path to take. When
    we talk about *flow* , we’re referring to the order in which the statements of
    the program are executed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讲解了如何创建常量和变量，你准备好学习如何告诉计算机做出选择了。本章将讲解如何通过告诉计算机选择程序的执行路径来控制程序的流程。当我们谈论*流程*时，我们指的是程序语句执行的顺序。
- en: Up to this point, you’ve only seen statements performed in the order you’ve
    typed them. You’ve done some cool things with this, but by telling the computer
    how to make choices about the order of executing statements, you can do even more.
    To get the computer to make a choice, we’ll use *conditional statements* that
    tell the computer to run some code based on a condition’s value.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只看到过按照你输入的顺序执行的语句。你已经用这些语句做了些很酷的事情，但通过告诉计算机如何根据语句的执行顺序做出选择，你可以做得更多。为了让计算机做出选择，我们将使用*条件语句*，它告诉计算机根据条件的值执行一些代码。
- en: You already use conditional statements to make choices every day! For example,
    before you leave home in the morning, you check the weather. If it’s sunny, you
    may put on a pair of sunglasses. If it’s raining, you grab your umbrella. In each
    case, you’re checking a condition. If the condition “it is raining” is true, then
    you take your umbrella when you leave the house. When the condition could be true
    or false, it’s called a *Boolean expression* . The Bool data type that you learned
    about in [Chapter 2](text00012.html#ch02) is used to represent the value true
    or false .
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你每天都在使用条件语句做出选择！例如，在早上离开家之前，你会查看天气。如果是晴天，你可能会戴上太阳镜。如果下雨了，你会拿起雨伞。在每种情况下，你都在检查一个条件。如果条件“下雨了”成立，那么你出门时就会带上雨伞。当条件可能为真或假时，这称为*布尔表达式*。你在[第2章](text00012.html#ch02)中学到的
    Bool 数据类型用于表示真或假的值。
- en: '![image](Image00076.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00076.jpg)'
- en: '**BOOLEAN EXPRESSIONS**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**布尔表达式**'
- en: 'A common type of Boolean expression is one that compares two values using a
    *comparison operator* . There are six comparison operators. Let’s start with two
    simple ones: *is equal* and *is not equal* .'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的布尔表达式是使用*比较运算符*来比较两个值。比较运算符有六种。我们先从两个简单的开始：*相等* 和 *不相等*。
- en: '**IS EQUAL AND IS NOT EQUAL**'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**等于与不等于**'
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你将经常使用 *相等* 和 *不相等* 这两个比较运算符。*相等* 用两个等号表示，写作 ==。*不相等* 用一个感叹号和一个等号表示，写作 !=。
- en: Let’s try them both out in the playground!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Playground 中试试这两者！
- en: '![Image](Image00077.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00077.jpg)'
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的语言来说，➊ 这一行表示“3 加 2 等于 5”，这是一个正确的陈述，右侧面板的输出将在你输入完这行代码后确认这一点。在 ➋ 这一行，写的是“3
    不等于 5”，这也是一个正确的陈述。请注意 ➌ 是一个错误。你知道为什么吗？虽然 = 和 == 看起来很相似，但记住单个等号 (=) 是用于赋值的。那行代码的意思是，“将
    8 的值赋给名为 3 + 5 的变量”，这显然是不可行的。
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，== 操作符不仅适用于数字，还可以用于其他数据类型。我们来尝试进行一些其他的比较。
- en: '![Image](Image00078.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00078.jpg)'
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行是个难点；你是否预料到它为真？这两个字符串很相似，但并不完全相同，*相等* 的比较仅在两个值完全匹配时才为真。常量 myName 的值是 "Gloria"，字母
    *G* 是大写的，这与 "gloria"（小写 *g*）不同。
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得在[第2章](text00012.html#ch02)中我们说过，您不能在不同数据类型的事物上使用数学运算符如+和*吗？比较运算也是如此。在②处，由于一个是String，另一个是Double，所以会导致错误。
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**大于和小于**'
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看其他四个比较运算符。我们将从*大于*（表示为>）和*小于*（表示为<）开始。您可能已经对这些运算符的工作原理有了很好的理解。例如，布尔表达式9
    > 7，表示“9大于7”，是true的。通常，您还想知道某些事物是否大于或等于某些事物，或者是否小于或等于某些事物。有两个运算符可以涵盖这些情况：*大于或等于*（看起来像>=）和*小于或等于*（看起来像<=）。让我们通过更多示例来尝试这些：
- en: '![Image](Image00079.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Image00079.jpg)'
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意*大于或等于*处于➊和*大于*处于➋之间的差异。3 + 4的和不大于7，但大于或等于7。同样，5 + 6小于或等于11➌，但不小于11➍。
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格3-1](text00013.html#ch3tab1) 总结了六个比较运算符。'
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格3-1:** 比较运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| == | Is equal to |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| == | 等于 |'
- en: '| != | Is not equal to |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| != | 不等于 |'
- en: '| > | Is greater than |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| > | 大于 |'
- en: '| < | Is less than |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| < | 小于 |'
- en: '| >= | Is greater than or equal to |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| >= | 大于或等于 |'
- en: '| <= | Is less than or equal to |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| <= | 小于或等于 |'
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写条件语句时，您经常会发现自己经常使用这些运算符。
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合布尔表达式**'
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 复合布尔表达式是简单布尔表达式的组合。这很像在英语中用*and*和*or*来制作复合句子。在编程中，还有第三种情况：*not*。在Swift中，我们称这些词为*逻辑运算符*。Swift中的三个逻辑运算符显示在[表格3-2](text00013.html#ch3tab2)中。
- en: '**Table 3-2:** Logical Operators'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格3-2:** 逻辑运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| && | Logical AND |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| && | 逻辑与 |'
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| &#124;&#124; | 逻辑或 |'
- en: '| ! | Logical NOT |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| ! | 逻辑非 |'
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑运算符，您可以编写测试值是否落在范围内的语句，例如“这个人的年龄是否在10到15岁之间？”您可以通过同时测试年龄是否大于10且小于15来做到这一点，就像这样：
- en: '![Image](Image00080.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Image00080.jpg)'
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 语句age > 10 && age < 15是true，因为两个条件都成立：age大于10且小于15。AND语句仅在两个条件都为true时才为true。
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将年龄的值更改为18，看看会发生什么：
- en: '![Image](Image00081.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Image00081.jpg)'
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将年龄改为18岁，所以语句的一侧是真的。变量年龄仍大于10，但不再小于15，因此我们的表达式评估为false。
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过在代码环境中输入以下代码来测试 OR：
- en: '![Image](Image00082.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00082.jpg)'
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为Jacqueline的人，通过将常量名称设置为“Jacqueline”。接下来，我们测试一些条件，看看它们是否为真或假。因为 name
    == "Jacqueline" 为真，即使 name == "Jack" 为假，➊ 处的 OR 语句仍然为真。在英语中，这个语句的意思是：“这个人的名字是
    Jack *或者* 这个人的名字是 Jacqueline。”在 OR 语句中，只有一个条件为真时，整个表达式才为真。
- en: '![image](Image00083.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00083.jpg)'
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着使用一些 NOT 语句。在你的代码环境中输入以下内容：
- en: '![Image](Image00084.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00084.jpg)'
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '! 操作符在复合布尔语句 ➊ 中被使用，你可以把它读作“我们这个人是*不是*女孩*并且*我们这个人叫 Jack。”这个语句包含了两个逻辑运算符，! 和
    &&。你可以根据需要在编写复合布尔表达式时组合任意多个逻辑运算符。'
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，使用括号是个好主意，它可以告诉计算机优先评估什么。括号还可以让代码更易于阅读。这类似于你在一个方程中使用多个数学运算时如何使用括号，正如在 “[使用括号排序运算](text00012.html#ch02lev2sec8)”中所描述的，在[第30页](text00012.html#page_30)的内容一样。在
    ➋ 处，我们使用括号告诉计算机首先检查 !isAGirl && name == "Jack"，然后再检查 isAGirl && name == "Jacqueline"。在评估完这两部分后，计算机可以评估整个语句的
    OR 部分，由于第二部分为真，所以整个表达式为真。同样，在 OR 语句中，只要有任何一个条件为真，整个表达式就是对的。
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-3](text00013.html#ch3tab3) 显示了三种逻辑运算符以及你可以用它们构建的复合表达式，并且给出了它们对应的布尔值。'
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-3：** 布尔逻辑运算符的复合表达式'
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **逻辑运算符** | **复合表达式** | **值** |'
- en: '| --- | --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| NOT (! ) | !true | false |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| NOT (! ) | !true | false |'
- en: '| NOT (! ) | !false | true |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| NOT (! ) | !false | true |'
- en: '| AND (&& ) | true && true | true |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | true && true | true |'
- en: '| AND (&& ) | true && false | false |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | true && false | false |'
- en: '| AND (&& ) | false && true | false |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | false && true | false |'
- en: '| AND (&& ) | false && false | false |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | false && false | false |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 表格的第一项显示了“不为真”的东西是假的。同样，“不为假”的东西就为真。
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AND 操作符时，只有 true && true 才为真。这意味着 && 操作符两边的表达式必须为真，&& 表达式才会为真。一个 true &&
    false 的复合表达式会被评估为假。两个条件都为假的复合 && 表达式也会评估为假。
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 OR 运算符，|| 运算符两边的任意一个表达式为真时，|| 表达式就为真。因此，true || true 为真，true || false 也为真。只有当复合
    OR 表达式两边的条件都为假时，才会返回假。
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**条件语句**'
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句分为两类：if 语句和 switch 语句。这些语句向计算机提供一个条件，计算机根据该条件做出选择。
- en: '**IF STATEMENTS**'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**IF 语句**'
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: if 语句以关键字 if 开始，后面跟一个 *条件*，该条件始终是一个布尔表达式。计算机会检查条件，如果条件为真，则执行 if 语句中的代码；如果条件为假，则跳过该代码。让我们编写一些代码，测试孩子是否足够高可以乘坐过山车。请在你的代码编辑器中输入以下代码：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 48 英寸设为孩子可以独自乘坐过山车的最小身高，并将骑行者的身高设为 49.5 英寸。在 ➊ 处，我们测试骑行者的身高是否大于或等于 heightToRideAlone。如果是，程序就会说他们足够高，可以乘坐过山车。为了编写
    if 语句，我们在条件 height >= heightToRideAlone 前加上关键字 if，然后将当条件为真时要执行的代码放在一对大括号 ➋ 中。因为骑行者足够高，计算机将打印“你足够高，可以乘坐这个过山车。”
- en: '![image](Image00085.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00085.jpg)'
- en: Hooray!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 万岁！
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果改变骑行者的身高会发生什么。将身高改为小于 48.0 的数字。这次，因为 if 语句中的条件评估为假，程序会跳过 if 语句中的所有代码，什么都不会发生。
- en: '**else Statements**'
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else 语句**'
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会希望告诉计算机，当条件为真时执行一件事，当条件为假时执行另一件事。为此，在 if 语句和代码块后，只需键入关键字 else，后面跟着另一个你希望在
    if 条件不成立时执行的代码块。如果骑行者的身高不够满足条件，让我们让计算机告诉他们不能乘坐过山车：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你将骑行者的身高改为不到 48 英寸，你会看到“抱歉，你不能乘坐这个过山车。” 这是因为 ➊ 处的 else 语句告诉计算机，当条件判断为假时，打印该消息。用简单的语言来说，这就像是在说，“如果骑行者足够高，可以乘坐过山车，就说他们可以乘坐。否则，说他们不能。”
- en: '**else if Statements**'
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else if 语句**'
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以测试骑行者身高的不同条件，为乘坐过山车创建更多规则。我们可以通过添加 else if 条件来做到这一点。让我们添加一个新的最小身高要求，要求孩子必须与成人一起乘坐：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的else if语句检查骑乘者的身高是否大于或等于heightToRideWithAdult。如果骑乘者的身高在48英寸以下但大于36英寸，则结果面板中会出现“你可以和成人一起坐这个过山车。”如果他们太矮，无法单独或与成人一起骑行，计算机会打印“抱歉，你不能坐这个过山车。”
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: else if语句很简洁，因为你可以用它们来测试许多不同的条件，但非常重要的一点是，你必须关注这些条件的顺序。为了说明这一点，将骑乘者的身高更改为50.0，以便他们足够高可以单独骑行。然后，通过将height
    >= heightToRideWithAdult作为第一个条件，height >= heightToRideAlone作为第二个条件，来更改我们if else语句中的条件顺序。你认为会打印什么？查看[图3-1](text00013.html#ch03fig1)来了解答案。
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00086.jpg)![image](Image00087.jpg)'
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-1：小心else if语句的顺序。*'
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，尽管骑乘者的身高高于heightToRideAlone，程序仍然打印出“你可以和成人一起坐这个过山车。”这是预期的输出，适用于身高大于heightToRideWithAdult但小于heightToRideAlone的骑乘者。我们得到这个结果是因为骑乘者的身高符合第一个条件，因此计算机打印了第一个句子，并且不会检查其他条件。
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦if或else if语句的任何部分被发现为真，后面的条件就不会再被检查。在[图3-1](text00013.html#ch03fig1)的示例中，第一个条件为真，因此其他条件被跳过。这可能会导致程序出现意外结果，所以如果你在if或else
    if语句中遇到问题，请检查条件的顺序！
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在使用if、else或else if语句时，有一些重要的规则。第一个是，你不能有else或else if语句，除非你先写一个if语句。第二个是，虽然你可以在if后面使用任意多个else
    if语句，但只能有一个else——而且这个else必须放在最后。如果没有其他条件成立，else将作为一个捕捉所有情况的语句。
- en: '**CODE WITH STYLE**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**优雅的编码**'
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请密切注意我们在本书中使用的编码风格。所谓*编码风格*，是指代码的写法、使用的空格数量、某些行的缩进以及新的一行应该写什么。请看一下这段代码：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在if条件之后，我们留出了一个空格，然后在同一行上放置了左大括号{。代码块的右大括号}总是位于下一行的开头。大括号内的语句缩进四个空格。这是Xcode自动为你做的，以使代码更具可读性。如果这样做更容易阅读，可以随意添加空行。通常，在一段代码（如if语句）之前应该始终有至少一个空行。
- en: '![image](Image00088.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00088.jpg)'
- en: '**SWITCH STATEMENTS**'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**SWITCH 语句**'
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 而if语句仅用于评估布尔表达式（即必须为真或为假），switch语句则可以根据多个条件进行评估和分支。你可以使用switch来检查整数的值，并告诉计算机如果整数等于1就做一件事，如果整数等于2则做另一件事，依此类推。或者，你可以创建一个字符串dayOfTheWeek，并编写一个switch语句，根据dayOfTheWeek的值让计算机做不同的事情。
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机找到第一个匹配项时，相应的代码块会执行。看看以下代码，它为不同年级的学生分配项目：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: switch语句以关键字switch开头，后面跟着*控制表达式*。在这个示例中，控制表达式是变量studentGrade。
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 控制表达式之后，从➊开始一个大括号，switch语句的主体就在这些大括号内。
- en: '![Image](Image00089.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00089.jpg)'
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: switch语句的主体由一个或多个case组成。在这个示例中，总共有六个case。每个case以关键字case开头，后面跟着一个值和冒号，如➋所示。如果case语句与控制表达式匹配，紧接着的代码就会执行。每个case必须至少有一行代码，否则会出现错误。在这个示例中，switch语句用于将分配给变量studentProject的字符串从“待确定”更改为与控制表达式匹配的case中的字符串。
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以有多个案例都执行相同的操作。你可以看到6年级、7年级和8年级的学生都可以选择他们自己的项目 ➌。我们通过写关键字case，然后列出以逗号分隔的值来指定这一点。
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，switch语句必须涵盖控制表达式的所有可能情况或值。在我们的示例中，由于studentGrade是一个Int类型，所以下面的switch语句需要包含所有可能的Int值的case。但这样写会非常耗时，因为有太多！例如，–7是一个Int，1,000也是。你真的想写1,000个case吗？
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用关键字default作为最后一个case，而不是为每个值单独写一个case，就像我们在➍中所做的那样。你只需输入default后跟冒号（default:），然后写下当其他case不匹配时需要执行的代码。请注意，默认case前面没有case这个词。默认case对于处理可能不期望的值非常有用，可以让你避免写太多的case语句。在这个例子中，我们只期望studentGrade的值为1到8，所以我们使用默认case来处理所有其他可能的值。
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行这个switch语句，看看结果。然后尝试更改值来测试不同的条件。玩一玩吧！
- en: '**WHAT YOU LEARNED**'
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何编程让计算机根据条件做出选择，使用了if和switch语句。你学会了如何编写布尔表达式和复合表达式，并了解了不同的比较运算符。条件语句是一个重要的编程工具，几乎在每个有用的程序中都能看到。在[第4章](text00014.html#ch04)，我们将讨论另一种重要的编程语句——循环。循环告诉计算机重复做某件事，直到该停止时为止。
- en: '![image](Image00090.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00090.jpg)'
- en: MAKING CHOICES
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做出选择
- en: '![image](Image00001.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00001.jpg)'
- en: Now that we’ve covered how to create constants and variables, you’re ready to
    learn how to tell your computer to make choices. This chapter is about controlling
    the flow of a computer program by telling the computer which path to take. When
    we talk about *flow* , we’re referring to the order in which the statements of
    the program are executed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了如何创建常量和变量，你准备好学习如何让计算机做出选择了。本章将讨论如何通过告诉计算机选择执行路径来控制计算机程序的流程。当我们谈到*流程*时，指的是程序语句执行的顺序。
- en: Up to this point, you’ve only seen statements performed in the order you’ve
    typed them. You’ve done some cool things with this, but by telling the computer
    how to make choices about the order of executing statements, you can do even more.
    To get the computer to make a choice, we’ll use *conditional statements* that
    tell the computer to run some code based on a condition’s value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只看到过按输入顺序执行的语句。你已经做了一些很酷的事情，但通过告诉计算机如何根据执行语句的顺序做出选择，你可以做得更多。为了让计算机做出选择，我们将使用*条件语句*，它根据条件的值告诉计算机执行某些代码。
- en: You already use conditional statements to make choices every day! For example,
    before you leave home in the morning, you check the weather. If it’s sunny, you
    may put on a pair of sunglasses. If it’s raining, you grab your umbrella. In each
    case, you’re checking a condition. If the condition “it is raining” is true, then
    you take your umbrella when you leave the house. When the condition could be true
    or false, it’s called a *Boolean expression* . The Bool data type that you learned
    about in [Chapter 2](text00012.html#ch02) is used to represent the value true
    or false .
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你每天都在使用条件语句做选择！例如，早上出门前你会查看天气。如果是晴天，你可能会戴上一副太阳镜。如果下雨，你就拿起雨伞。在每种情况下，你都在检查一个条件。如果“下雨”这个条件为真，那么当你离开家时，你会带上雨伞。当条件可能为真或为假时，它就叫做*布尔表达式*。你在[第2章](text00012.html#ch02)中学到的Bool数据类型用于表示真或假的值。
- en: '![image](Image00076.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00076.jpg)'
- en: '**BOOLEAN EXPRESSIONS**'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**布尔表达式**'
- en: 'A common type of Boolean expression is one that compares two values using a
    *comparison operator* . There are six comparison operators. Let’s start with two
    simple ones: *is equal* and *is not equal* .'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的布尔表达式是使用*比较运算符*比较两个值。共有六种比较运算符。让我们从两个简单的运算符开始：*相等*和*不相等*。
- en: '**IS EQUAL AND IS NOT EQUAL**'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**相等与不相等**'
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你会经常使用 *等于* 和 *不等于* 的比较运算符。*等于* 用两个等号写在一起，像这样：==。*不等于* 用感叹号和一个等号写在一起，像这样：!=。
- en: Let’s try them both out in the playground!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在游乐场中同时尝试这两个！
- en: '![Image](Image00077.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00077.jpg)'
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 用通俗的语言来说，➊ 处的代码表示“3 加 2 等于 5”，这是一个正确的陈述，右侧面板的输出会在你输入完成后确认这一点。➋ 处的代码表示“3 不等于
    5”，这也是一个正确的陈述。注意 ➌ 处是错误的。你知道为什么吗？虽然 = 和 == 看起来很相似，但记住单个等号（=）是用来赋值的。那行代码的意思是，“将
    8 的值赋给名为 3 + 5 的东西”，这是不行的。
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，== 运算符也适用于其他数据类型，而不仅仅是数字。让我们尝试一些其他的比较。
- en: '![Image](Image00078.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00078.jpg)'
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行比较棘手；你预计它为真吗？这两个字符串接近，但并不完全相同，*相等*的比较只有在两个值完全匹配时才为真。常量 myName 的值是 "Gloria"，大写的
    *G* ，这与 "gloria"（小写的 *g*）不相同。
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在[第 2 章](text00012.html#ch02)时我们说过，你不能对不同数据类型的东西使用数学运算符，如 + 和 * 吗？比较时也是如此。你不能比较不同类型的东西。➋
    处的代码会导致错误，因为一个是字符串（String），另一个是双精度浮点数（Double）。
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**大于和小于**'
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下其他四个比较运算符。我们从 *大于*（表示为 >）和 *小于*（表示为 <）开始。你可能已经对这些运作有了很好的理解。像 9 > 7 这样的布尔表达式，意思是“9
    大于 7”，它为真。通常，你还会想知道某个东西是否大于或等于某个东西，或者是否小于或等于某个东西。还有两个运算符可以处理这些情况：*大于或等于*（表示为 >=）和
    *小于或等于*（表示为 <=）。让我们用更多的例子来尝试这些：
- en: '![Image](Image00079.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00079.jpg)'
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 ➊ 处的 *大于或等于* 与 ➋ 处的 *大于* 之间的区别。3 + 4 的和不大于 7，但它大于或等于 7。同样，5 + 6 小于或等于 11
    ➌ ，但它不小于 11 ➍。
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-1](text00013.html#ch3tab1)总结了六个比较运算符。'
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-1：** 比较运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| == | Is equal to |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| == | 等于 |'
- en: '| != | Is not equal to |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| != | 不等于 |'
- en: '| > | Is greater than |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| > | 大于 |'
- en: '| < | Is less than |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| < | 小于 |'
- en: '| >= | Is greater than or equal to |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| >= | 大于或等于 |'
- en: '| <= | Is less than or equal to |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| <= | 小于或等于 |'
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写条件语句时，你会经常使用这些运算符。
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合布尔表达式**'
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 复合布尔表达式是将多个简单布尔表达式连接在一起。它有点像在英语中使用“*and*”和“*or*”构成复合句。在编程中，还有第三种情况：*not*。在Swift中，我们称这些词为*逻辑运算符*。逻辑运算符可以将一个布尔表达式与另一个表达式结合，或者对其取反。Swift中的三种逻辑运算符如[表3-2](text00013.html#ch3tab2)所示。
- en: '**Table 3-2:** Logical Operators'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-2：** 逻辑运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| && | Logical AND |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| && | 逻辑与 |'
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| &#124;&#124; | 逻辑或 |'
- en: '| ! | Logical NOT |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| ! | 逻辑非 |'
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑运算符，你可以编写测试某个值是否在范围内的语句，例如：“这个人的年龄在10到15岁之间吗？”你可以通过测试年龄是否大于10 *且* 小于15来实现，像这样：
- en: '![Image](Image00080.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00080.jpg)'
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 语句`age > 10 && age < 15`为真，因为两个条件都为真：年龄大于10且小于15。一个AND语句只有在两个条件都为真时才为真。
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将age的值改为18，看看会发生什么：
- en: '![Image](Image00081.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00081.jpg)'
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将年龄改为18，所以只有一边的条件为真。变量age仍然大于10，但不再小于15，所以我们的表达式的值为假。
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过在你的演示区输入以下代码来测试OR运算符：
- en: '![Image](Image00082.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00082.jpg)'
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过将常量name设置为"Jacqueline"来创建一个名为Jacqueline的人物。接下来，我们测试一些条件以查看它们是对还是错。因为`name
    == "Jacqueline"`为真，所以➊处的OR语句为真，尽管`name == "Jack"`为假。用英语来说，这个语句的意思是：“这个人的名字是Jack
    *或者* 这个人的名字是Jacqueline。”在OR语句中，只需要有一个条件为真，整个表达式才为真。
- en: '![image](Image00083.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00083.jpg)'
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用一些NOT语句。将以下内容输入到你的演示区：
- en: '![Image](Image00084.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00084.jpg)'
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`!`运算符用于复合布尔语句➊中，你可以将其理解为“我们的人*不是*女孩*且*我们的人叫Jack。”该语句有两个逻辑运算符，`!`和`&&`。在编写复合布尔表达式时，你可以组合任意多个逻辑运算符。'
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，使用括号来告诉计算机先计算哪个部分是一个好主意。括号还可以让代码更容易阅读。这就像你在一个数学方程中使用多个运算时使用括号一样，正如在 “[使用括号来排序操作](text00012.html#ch02lev2sec8)”
    第 30 页中描述的那样。在 ➋ 处，我们使用括号告诉计算机首先检查 !isAGirl && name == "Jack"，然后检查 isAGirl &&
    name == "Jacqueline"。在计算完这两个部分后，计算机可以计算整个语句的 OR 部分，结果为 true，因为第二部分为 true。在 OR
    语句中，如果任何条件为 true，整个表达式就为 true。
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-3](text00013.html#ch3tab3) 显示了三个逻辑运算符及其复合表达式，并列出了它们对应的布尔值。'
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-3：** 使用逻辑运算符的复合布尔表达式'
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| **逻辑运算符** | **复合表达式** | **值** |'
- en: '| --- | --- | --- |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| NOT (! ) | !true | false |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 非 (! ) | !true | false |'
- en: '| NOT (! ) | !false | true |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 非 (! ) | !false | true |'
- en: '| AND (&& ) | true && true | true |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 与 (&& ) | true && true | true |'
- en: '| AND (&& ) | true && false | false |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 与 (&& ) | true && false | false |'
- en: '| AND (&& ) | false && true | false |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 与 (&& ) | false && true | false |'
- en: '| AND (&& ) | false && false | false |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 与 (&& ) | false && false | false |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 或 (&#124;&#124; ) | true &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 或 (&#124;&#124; ) | true &#124;&#124; false | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 或 (&#124;&#124; ) | false &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 或 (&#124;&#124; ) | false &#124;&#124; false | false |'
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 表格的第一项显示，NOT true 是 false。同理，NOT false 是 true。
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AND 运算符时，只有 true && true 为 true。这意味着 && 运算符两边的表达式必须都为 true，&& 表达式才为 true。一个复合表达式
    true && false 的结果为 false。如果两个条件都为 false，复合 && 表达式的结果也会是 false。
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到 OR 运算符时，|| 运算符两边的表达式中只需一个为 true，整个 || 表达式就为 true。因此，true || true 为 true，true
    || false 也是 true。只有当两个条件都为 false 时，复合 OR 表达式才为 false。
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**条件语句**'
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句分为两类：if 语句和 switch 语句。这些语句向计算机提供一个条件，计算机根据该条件做出选择。
- en: '**IF STATEMENTS**'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**IF 语句**'
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: if 语句以关键字 if 开头，后面跟着一个 *条件*，该条件始终是一个布尔表达式。计算机会检查该条件，如果条件为 true，则执行 if 语句中的代码；如果条件为
    false，则跳过该代码。让我们写一些代码，测试一个孩子是否足够高，能乘坐过山车。请将以下代码输入到你的编程环境中：
- en: '[PRE5]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将 48 英寸设为孩子单独乘坐过山车的最低身高，并将骑行者的身高设置为 49.5 英寸。在 ➊ 处，我们测试骑行者的身高是否大于或等于 `heightToRideAlone`。如果是，程序会说他们足够高，可以乘坐过山车。为了编写我们的
    `if` 语句，我们在条件 `height >= heightToRideAlone` 前面加上关键字 `if`。然后，我们将希望在该条件为真时执行的代码括在一对大括号
    ➋ 中。因为我们的骑行者足够高，计算机会打印 "You are tall enough to ride this roller coaster."（你足够高，可以乘坐这个过山车）。
- en: '![image](Image00085.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00085.jpg)'
- en: Hooray!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 耶！
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果改变骑行者的身高会发生什么。将身高更改为低于 48.0 的数值。这一次，由于 `if` 语句中的条件评估为 false，程序会跳过 `if`
    语句中的所有代码，什么也不会发生。
- en: '**else Statements**'
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else 语句**'
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会希望告诉计算机，如果某个语句为真，做一件事；如果该语句为假，做另一件事。为此，在 `if` 语句和代码块后面，只需输入关键字 `else`，然后输入另一个代码块，当
    `if` 条件不为真时执行。如果骑行者的身高不够，我们让计算机告诉他们不能乘坐过山车：
- en: '[PRE6]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你将骑行者的身高更改为低于 48 英寸，你会看到 "Sorry. You cannot ride this roller coaster."（抱歉，你不能乘坐这个过山车）。这是因为
    ➊ 处的 `else` 语句告诉计算机，如果条件评估为 false，就打印该信息。通俗地说，这就像是说：“如果骑行者足够高可以乘坐过山车，就说他们可以。如果不行，就说他们不行。”
- en: '**else if Statements**'
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else if 语句**'
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试骑行者身高的不同条件，以创建更多的过山车乘坐规则。我们可以通过添加 `else if` 条件来实现这一点。让我们增加一个新的最小身高，要求孩子与成人一起乘坐：
- en: '[PRE7]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的 `else if` 语句检查骑行者的身高是否大于或等于 `heightToRideWithAdult`。如果骑行者身高低于 48 英寸，但高于
    36 英寸，那么在结果面板中会出现 "You can ride this roller coaster with an adult."（你可以与成人一起乘坐过山车）这一行。如果他们的身高不够，无法单独或与成人一起乘坐过山车，计算机会打印
    "Sorry. You cannot ride this roller coaster."（抱歉，你不能乘坐这个过山车）。
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`else if` 语句很整洁，因为你可以用它们测试许多不同的条件，但非常重要的一点是，你需要关注这些条件的顺序。为了展示我们的意思，请将骑行者的身高改为
    50.0，以便他们足够高，可以单独骑行。然后，通过将条件 `height >= heightToRideWithAdult` 移到第一个条件，将 `height
    >= heightToRideAlone` 移到第二个条件，来改变我们 `if else` 语句中的条件顺序。你认为会打印什么内容？查看[图 3-1](text00013.html#ch03fig1)来了解答案。'
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00086.jpg)![image](Image00087.jpg)'
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-1：小心`else if`语句的顺序。*'
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，尽管骑行者的身高高于`heightToRideAlone`，程序还是输出了“你可以和成人一起乘坐这过山车。” 这是对于身高大于`heightToRideWithAdult`但小于`heightToRideAlone`的骑行者的预期输出。我们得到这个结果是因为骑行者的身高符合第一个条件，因此计算机输出了第一个句子，并且不会检查其他条件。
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`if`或`else if`语句的某部分被判定为`true`，其余的条件将不再被检查。在我们[图3-1](text00013.html#ch03fig1)中的例子中，第一个条件为真，因此跳过了其余的条件。这可能会导致程序中出现意外的结果，所以如果你在`if`或`else
    if`语句中遇到问题，请检查条件的顺序！
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`if`、`else`或`else if`语句时，有一些重要的规则。第一个规则是，除非你先写一个`if`语句，否则不能有`else`或`else
    if`语句。第二个规则是，虽然在`if`语句后可以有任意数量的`else if`语句，但只能有一个`else`，而且这个`else`必须是最后一个。`else`是用于捕捉所有其他条件都不成立的情况。
- en: '**CODE WITH STYLE**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**风格化编程**'
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请特别注意我们在本书中使用的编码风格。所谓*编码风格*，是指代码的写法、使用的空格数量、某些行的缩进，以及哪些内容放在新的一行。看看这段代码：
- en: '[PRE8]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`if`条件之后，我们留出一个空格，然后将大括号`{`放在同一行。代码块的闭合大括号`}`总是放在下一行的开始位置。大括号内的语句缩进四个空格。这是Xcode自动为你做的，以使代码更具可读性。如果空白行能让你更容易阅读，欢迎添加。一般来说，在像`if`语句这样的代码块之前，你应该始终留出至少一行空白行。
- en: '![image](Image00088.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00088.jpg)'
- en: '**SWITCH STATEMENTS**'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**切换语句**'
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句仅用于评估布尔表达式（必须为真或假的东西），而`switch`语句可以评估并根据多个条件进行分支。你可以使用`switch`来检查一个整数的值，并告诉计算机如果该整数等于1，就执行某个操作，等于2时执行另一个操作，依此类推。或者，你可以创建一个名为`dayOfTheWeek`的字符串，并编写一个`switch`语句，根据`dayOfTheWeek`的值让计算机执行不同的操作。'
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机找到第一个匹配项时，相关的代码块就会被执行。看看下面这段代码，它为不同年级的学生分配项目：
- en: '[PRE9]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句以关键字`switch`开始，后面跟着*控制表达式*。在这个例子中，控制表达式是变量`studentGrade`。'
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制表达式之后，一组大括号从 ➊ 开始，`switch` 语句的主体位于这些大括号内。
- en: '![Image](Image00089.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00089.jpg)'
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句的主体由一个或多个 `case` 组成。在这个例子中，总共有六个 `case`。每个 `case` 以关键字 `case` 开头，后跟一个值和冒号，如
    ➋ 所示。如果某个 `case` 语句与控制表达式匹配，则紧跟在 `case` 后的代码将会执行。每个 `case` 必须至少有一行代码，否则会报错。在这个例子中，`switch`
    用于将字符串 "To be determined" 所赋值的变量 `studentProject` 改为与控制表达式匹配的 `case` 中的字符串。'
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以有多个案例，它们都执行相同的操作。您可以看到，6、7 和 8 年级的学生都可以选择自己的项目 ➌。我们通过编写关键字 `case` 和一个由逗号分隔的值列表来指定这一点。
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`switch` 语句必须考虑控制表达式的所有可能的 `case` 或值。在我们的例子中，由于 `studentGrade` 是一个 `Int`
    类型，我们的 `switch` 语句需要有一个适用于所有可能的 `Int` 值的 `case`。但是这将需要非常长的时间来编写，因为有太多可能的值！例如，–7
    是 `Int` 类型，1,000 也是。你真的想写 1,000 个 `case` 吗？
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 不必为每个值编写一个单独的 `case`，你可以将关键字 `default` 用作最后一个 `case`，正如我们在 ➍ 处所做的那样。你只需输入 `default`
    后跟冒号（`default:`），然后写下如果其他 `case` 都不匹配时要执行的代码。注意，`default` 语句前面没有 `case` 这个词。`default`
    语句对于处理你可能没有预料到的值非常有帮助，并且可以避免编写那么多的 `case` 语句。在这个例子中，我们只期望 `studentGrade` 的值为 1
    到 8 之间的整数，因此我们使用 `default` 语句来处理所有其他可能的值。
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行这个 `switch` 语句，看看你得到的结果。然后尝试更改值以测试不同的条件。玩玩看吧！
- en: '**WHAT YOU LEARNED**'
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何通过使用 `if` 和 `switch` 语句编写程序，使计算机根据条件做出选择。您学会了如何编写布尔表达式和复合表达式，以及不同的比较运算符。条件语句是一个至关重要的编程工具，几乎所有有用的程序中都能看到它们。在[第
    4 章](text00014.html#ch04)，我们将探讨另一种重要的编程语句——循环。循环告诉计算机反复做某事，直到停止循环。
- en: '![image](Image00090.jpg) ![image](Image00001.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00090.jpg) ![image](Image00001.jpg)'
- en: Now that we’ve covered how to create constants and variables, you’re ready to
    learn how to tell your computer to make choices. This chapter is about controlling
    the flow of a computer program by telling the computer which path to take. When
    we talk about *flow* , we’re referring to the order in which the statements of
    the program are executed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了如何创建常量和变量，你已经准备好学习如何让计算机做出选择。本章将介绍如何通过告诉计算机走哪条路径来控制计算机程序的流程。当我们谈论*流程*时，我们指的是程序中语句执行的顺序。
- en: Up to this point, you’ve only seen statements performed in the order you’ve
    typed them. You’ve done some cool things with this, but by telling the computer
    how to make choices about the order of executing statements, you can do even more.
    To get the computer to make a choice, we’ll use *conditional statements* that
    tell the computer to run some code based on a condition’s value.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只见过按你输入的顺序执行的语句。你已经用这些做了一些很酷的事情，但通过告诉计算机如何根据执行语句的顺序做出选择，你可以做得更多。为了让计算机做出选择，我们将使用*条件语句*，告诉计算机根据条件的值来运行一些代码。
- en: You already use conditional statements to make choices every day! For example,
    before you leave home in the morning, you check the weather. If it’s sunny, you
    may put on a pair of sunglasses. If it’s raining, you grab your umbrella. In each
    case, you’re checking a condition. If the condition “it is raining” is true, then
    you take your umbrella when you leave the house. When the condition could be true
    or false, it’s called a *Boolean expression* . The Bool data type that you learned
    about in [Chapter 2](text00012.html#ch02) is used to represent the value true
    or false .
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你每天都在使用条件语句做选择！例如，在早上出门前，你会查看天气。如果是晴天，你可能会戴上太阳镜。如果下雨，你则会拿起雨伞。在这两种情况下，你都在检查一个条件。如果条件“下雨”是真的，那么你出门时会拿起雨伞。当条件可能为真或假时，这就叫做*布尔表达式*。你在[第二章](text00012.html#ch02)中学到的
    Bool 数据类型用来表示 true 或 false 的值。
- en: '![image](Image00076.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00076.jpg)'
- en: '**BOOLEAN EXPRESSIONS**'
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**布尔表达式**'
- en: 'A common type of Boolean expression is one that compares two values using a
    *comparison operator* . There are six comparison operators. Let’s start with two
    simple ones: *is equal* and *is not equal* .'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的布尔表达式类型是使用*比较运算符*来比较两个值。有六种比较运算符。我们先从两个简单的开始：*相等*与*不相等*。
- en: '**IS EQUAL AND IS NOT EQUAL**'
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**相等与不相等**'
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你会经常使用*相等*与*不相等*比较运算符。*相等*用两个等号紧挨着写，像这样：==。*不相等*用感叹号和一个等号写，像这样：!=。
- en: Let’s try them both out in the playground!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Playground 中试试这两个！
- en: '![Image](Image00077.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00077.jpg)'
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的英语来说，➊ 这一行表示“3 加 2 等于 5”，这是一个正确的陈述，当你输入完成后，右侧窗格的输出会确认这一点。在 ➋ 处，这一行表示“3 不等于
    5”，这也是一个正确的陈述。注意，➌ 是一个错误。你知道为什么吗？虽然 = 和 == 看起来很像，但请记住，单个等号 (=) 是用来赋值的。那行代码的意思是，“将
    8 的值赋给叫做 3 + 5 的东西”，这显然是行不通的。
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，== 运算符不仅适用于数字，还适用于其他数据类型。我们来尝试进行一些其他比较。
- en: '![Image](Image00078.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00078.jpg)'
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行有点棘手；你期望它为真吗？这两个字符串很相似，但并不完全相同，*相等*比较只有在两个值完全匹配时才为真。常量 myName 的值是 "Gloria"，大写的*G*，这与
    "gloria"（小写的*g*）不同。
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在 [第二章](text00012.html#ch02) 中我们说过，你不能对不同数据类型的东西使用数学运算符，如 + 和 * 吗？比较也一样，你不能比较不同类型的东西。➋
    处的这一行将导致错误，因为一个是 String 类型，另一个是 Double 类型。
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**大于与小于**'
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看另外四个比较运算符。我们从 *大于*（写作 >）和 *小于*（写作 <）开始。你可能已经大致了解它们是如何工作的。像 9 > 7 这样的布尔表达式，意思是“9
    大于 7”，它为真。通常，你还需要知道某个值是否大于或等于另一个值，或者小于或等于另一个值。还有两个运算符可以覆盖这些情况：*大于或等于*（写作 >=）和
    *小于或等于*（写作 <=）。我们通过一些例子来试试这些：
- en: '![Image](Image00079.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00079.jpg)'
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 ➊ 处的 *大于或等于* 和 ➋ 处的 *大于* 之间的区别。3 + 4 的和不是大于 7，但它大于或等于 7。类似地，5 + 6 小于或等于
    11 ➌，但它不小于 11 ➍。
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-1](text00013.html#ch3tab1) 总结了六个比较运算符。'
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-1：** 比较运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| == | Is equal to |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| == | 等于 |'
- en: '| != | Is not equal to |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| != | 不等于 |'
- en: '| > | Is greater than |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| > | 大于 |'
- en: '| < | Is less than |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| < | 小于 |'
- en: '| >= | Is greater than or equal to |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| >= | 大于或等于 |'
- en: '| <= | Is less than or equal to |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| <= | 小于或等于 |'
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写条件语句时，你会经常使用这些运算符。
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合布尔表达式**'
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 复合布尔表达式是由简单布尔表达式组合而成的。这有点像在英语中用 *and* 和 *or* 构成复合句。在编程中，还有第三种情况：*not*。在 Swift
    中，我们将这些词称为 *逻辑运算符*。逻辑运算符要么将一个布尔表达式与另一个表达式结合，要么对其进行否定。Swift 中的三种逻辑运算符如 [表 3-2](text00013.html#ch3tab2)
    所示。
- en: '**Table 3-2:** Logical Operators'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-2：** 逻辑运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| && | Logical AND |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| && | 逻辑与 |'
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| &#124;&#124; | 逻辑或 |'
- en: '| ! | Logical NOT |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| ! | 逻辑非 |'
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑运算符，你可以编写测试某个值是否在某个范围内的语句，例如，“这个人的年龄是否在 10 到 15 之间？”你可以通过测试年龄是否大于 10 *且*
    小于 15 来实现，像这样：
- en: '![Image](Image00080.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00080.jpg)'
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 语句 age > 10 && age < 15 为真，因为两个条件都为真：age 大于 10 且小于 15。只有当两个条件都为真时，AND 语句才为真。
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将 age 的值改为 18，看看会发生什么：
- en: '![Image](Image00081.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00081.jpg)'
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将 age 改为 18，所以语句只有一边为真。变量 age 仍然大于 10，但不再小于 15，因此我们的表达式求值为 false。
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过在你的编程环境中输入以下代码来测试 OR 运算符：
- en: '![Image](Image00082.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00082.jpg)'
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过将常量 name 设置为 "Jacqueline" 来创造一个名叫 Jacqueline 的人。接下来，我们测试一些条件，看看它们是 true
    还是 false 。因为 name == "Jacqueline" 为 true ，所以即使 name == "Jack" 为 false，➊ 处的 OR
    语句仍然为 true 。用英语表达就是：“这个人叫 Jack *或者* 这个人叫 Jacqueline。”在 OR 语句中，只要其中一个条件为 true，整个表达式就为
    true 。
- en: '![image](Image00083.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00083.jpg)'
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着使用一些 NOT 语句。将以下代码输入到你的编程环境中：
- en: '![Image](Image00084.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00084.jpg)'
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '! 运算符用于复合布尔语句 ➊ ，你可以理解为“我们的人*不是*女孩*并且*我们的人叫Jack。”这个语句包含两个逻辑运算符，! 和 && 。在编写复合布尔表达式时，你可以根据需要组合任意多个逻辑运算符。'
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，使用括号来告诉计算机首先评估哪些内容是一个好主意。括号还能使代码更易于阅读。这就像你在一个数学公式中使用多个运算符时，会用括号来表明运算顺序一样，正如在
    “[使用括号对运算顺序进行排序](text00012.html#ch02lev2sec8)” 中所描述的那样，在 [第30页](text00012.html#page_30)
    。在 ➋ 中，我们使用括号告诉计算机首先检查 !isAGirl && name == "Jack"，然后检查 isAGirl && name == "Jacqueline"。当计算机评估完这两部分之后，它可以评估整个
    OR 语句，因为第二部分为 true ，整个语句的值也为 true 。再次强调，在 OR 语句中，只要任何一个条件为 true，整个表达式就为 true 。
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-3](text00013.html#ch3tab3) 显示了三种逻辑运算符及其可以组成的复合表达式，以及它们对应的布尔值。'
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-3：** 使用逻辑运算符的复合布尔表达式'
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| **逻辑运算符** | **复合表达式** | **值** |'
- en: '| --- | --- | --- |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| NOT (! ) | !true | false |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| NOT (! ) | !true | false |'
- en: '| NOT (! ) | !false | true |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| NOT (! ) | !false | true |'
- en: '| AND (&& ) | true && true | true |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | true && true | true |'
- en: '| AND (&& ) | true && false | false |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | true && false | false |'
- en: '| AND (&& ) | false && true | false |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | false && true | false |'
- en: '| AND (&& ) | false && false | false |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | false && false | false |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中的第一项显示，不为 true 的值为 false 。类似地，不为 false 的值为 true 。
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AND 运算符时，只有同时满足 true && true 时，结果才为 true 。这意味着 && 运算符两边的表达式必须都为 true ，整个
    && 表达式才为 true 。如果一个复合表达式是 true && false ，结果将为 false 。而且，如果复合 && 表达式两边的条件都为 false
    ，结果也会是 false 。
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用OR运算符时，只有在||运算符两边的表达式中至少有一个为真时，||表达式才为真。因此，true || true为真，true || false也为真。只有在两个侧面都为假时，复合OR表达式才为假。
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**条件语句**'
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句分为两类：if语句和switch语句。这些语句向计算机提供一个条件，计算机根据这个条件做出选择。
- en: '**IF STATEMENTS**'
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**IF语句**'
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: if语句以关键字if开始，后面跟着一个*条件*，它总是一个布尔表达式。计算机会检查条件，如果条件为真，则执行if语句中的代码；如果条件为假，则跳过这段代码。让我们编写一些代码，测试一个孩子是否足够高可以坐过山车。将以下代码输入到你的编程环境中：
- en: '[PRE10]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置48英寸为孩子单独坐过山车的最低身高，并将骑车者的身高设置为49.5英寸。在➊处，我们测试骑车者的身高是否大于或等于heightToRideAlone。如果是，程序会说他们足够高可以坐过山车。为了编写我们的if语句，我们在条件height
    >= heightToRideAlone前加上关键字if。然后将我们希望在该条件为真时执行的代码用一对大括号括起来➋。由于我们的骑车者足够高，计算机会打印“你足够高可以坐这个过山车。”
- en: '![image](Image00085.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00085.jpg)'
- en: Hooray!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果改变骑车者的身高会发生什么。如果将身高改为小于48.0，这次，因为if语句中的条件评估为假，程序会跳过if语句中的所有代码，什么也不发生。
- en: '**else Statements**'
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else 语句**'
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会希望在一个条件为真时让计算机做一件事，而在条件为假时做另一件事。为此，在if语句和代码块后，直接输入关键字else，后面跟着你希望在if条件不为真时执行的代码块。如果骑车者的身高不符合条件，我们可以让计算机告诉他们不能坐过山车：
- en: '[PRE11]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你将骑车者的身高改为低于48英寸，你将看到“对不起，你不能坐这个过山车。”这是因为在➊处的else语句告诉计算机，如果条件评估为假，则打印该消息。用通俗的话来说，这就像是在说：“如果骑车者足够高可以坐过山车，就说他们可以坐；否则，说他们不能坐。”
- en: '**else if Statements**'
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else if 语句**'
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试骑车者的身高的不同条件，以为坐过山车创建更多规则。我们可以通过添加else if条件来实现这一点。让我们添加一个新的最低身高要求，要求孩子与成年人一起坐：
- en: '[PRE12]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的else if语句检查骑行者的身高是否大于或等于heightToRideWithAdult。如果骑行者的身高在48英寸以下但超过36英寸，那么“你可以和成年人一起坐这个过山车。”将会出现在结果面板中。如果他们的身高既不够高到能单独坐，也不够高到能和成年人一起坐，那么计算机将打印出“抱歉，你不能坐这个过山车。”
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: else if语句很整洁，因为你可以用它们来测试很多不同的条件，但非常重要的是要注意这些条件的顺序。为了展示我们的意思，把骑行者的身高改为50.0，这样他们就足够高，可以单独乘坐。然后，调整if
    else语句中条件的顺序，将height >= heightToRideWithAdult放在第一个条件，height >= heightToRideAlone放在第二个条件。你认为会打印出什么？看看[图3-1](text00013.html#ch03fig1)来了解。
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00086.jpg)![image](Image00087.jpg)'
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-1：注意else if语句的顺序。*'
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，尽管骑行者的身高大于heightToRideAlone，程序仍然打印出“你可以和成年人一起坐这个过山车。”这是对于身高大于heightToRideWithAdult但小于heightToRideAlone的骑行者来说预期的输出。我们得到这个结果是因为骑行者的身高符合第一个条件，所以计算机打印出第一句，而不会继续检查其他条件。
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦if或else if语句的某部分被判定为真，剩余的条件将不会再被检查。在我们[图3-1](text00013.html#ch03fig1)的例子中，第一个条件为真，所以剩余的条件被跳过了。这可能会导致程序中的意外结果，因此如果你在if或else
    if语句中遇到问题，检查条件的顺序！
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在使用if、else或else if语句时，有一些重要的规则。首先，除非你先写了一个if语句，否则不能有else或else if语句。其次，虽然你可以在if后面写任意多的else
    if语句，但只能有一个else，而且这个else必须是最后的。else是一个兜底情况，用来处理其他条件都不成立的情况。
- en: '**CODE WITH STYLE**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**风格化编程**'
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 请密切关注本书中使用的编码风格。我们所说的*编码风格*，是指代码的书写方式、使用的空格数、某些行的缩进以及哪些内容应该另起一行。请看这段代码：
- en: '[PRE13]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `if` 条件后，我们留出一个空格，然后将左大括号 `{` 放在同一行。代码块的右大括号 `}` 总是放在下一行的开头。大括号内的语句缩进四个空格。这是
    Xcode 自动为你做的，以提高代码的可读性。如果这样更容易阅读，你可以随意添加空行。通常，你应该在代码块（如 `if` 语句）前至少留一个空行。
- en: '![image](Image00088.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00088.jpg)'
- en: '**SWITCH STATEMENTS**'
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**SWITCH 语句**'
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `if` 语句仅用于评估布尔表达式（必须为真或假的内容），`switch` 语句可以评估并根据多个条件分支。你可以使用 `switch` 来检查整数的值，并告诉计算机如果该整数等于
    1，就做一件事，等于 2 就做另一件事，依此类推。或者，你可以创建一个字符串 `dayOfTheWeek`，并编写一个 `switch` 语句，根据 `dayOfTheWeek`
    的值让计算机做不同的事情。
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机找到第一个匹配项时，就会执行该代码块。看看以下代码，它为不同年级的学生分配项目：
- en: '[PRE14]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句以关键字 `switch` 开始，后跟 *控制表达式*。在这个例子中，控制表达式是变量 `studentGrade`。'
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制表达式后，开始了一对大括号 ➊ ，`switch` 语句的主体就在这些大括号内。
- en: '![Image](Image00089.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00089.jpg)'
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句的主体由一个或多个 `case` 组成。在这个例子中，总共有六个 `case`。每个 `case` 以关键字 `case` 开头，后跟一个值和一个冒号，如
    ➋ 所示。如果某个 `case` 语句匹配控制表达式，则紧跟在 `case` 后的代码将执行。每个 `case` 必须至少有一行代码，否则会报错。在这个例子中，`switch`
    用来将分配给变量 `studentProject` 的字符串从 "待定" 更改为与控制表达式匹配的 `case` 中的字符串。'
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以让多个 case 做相同的事情。你可以看到，6、7 和 8 年级的学生都可以选择自己的项目 ➌ 。我们通过写关键字 `case`，然后列出一个用逗号分隔的值来指定这一点。
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个 `switch` 语句必须考虑控制表达式的所有可能的情况或值。在我们的例子中，由于 `studentGrade` 是一个 Int 类型，`switch`
    语句需要为所有可能的 Int 值提供一个 case。但是，由于可能的值太多，这样写会非常耗时！例如，–7 是一个 Int 类型，1,000 也是。你真的想写
    1,000 个 case 吗？
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像我们在步骤➍中所做的那样，使用默认（default）关键字作为最后一个案例，而不是为每个值写一个单独的案例。你只需输入default后跟一个冒号（default:），然后编写你希望在其他案例不匹配时执行的代码。注意，默认案例前面没有case这个词。默认案例对于处理你可能没有预料到的值非常有用，它可以让你避免写太多的case语句。在这个例子中，我们只期望学生成绩（studentGrade）的值在1到8之间，因此我们使用默认案例来覆盖所有其他可能的值。
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行这个switch语句，看看你得到什么结果。然后尝试更改值来测试不同的条件。尽情玩玩吧！
- en: '**WHAT YOU LEARNED**'
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何通过使用if和switch语句，根据条件来编程让计算机做出选择。你学会了如何编写布尔表达式和复合表达式，以及不同的比较运算符。条件语句是一个重要的编程工具，几乎在每个有用的程序中都可以看到它们。在[第4章](text00014.html#ch04)中，我们将探讨另一种重要的编程语句——循环。循环告诉计算机反复执行某个操作，直到该停止时为止。
- en: '![image](Image00090.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00090.jpg)'
- en: Now that we’ve covered how to create constants and variables, you’re ready to
    learn how to tell your computer to make choices. This chapter is about controlling
    the flow of a computer program by telling the computer which path to take. When
    we talk about *flow* , we’re referring to the order in which the statements of
    the program are executed.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讲解了如何创建常量和变量，接下来你准备好学习如何告诉计算机做出选择。本章内容是关于通过告诉计算机选择哪条路径来控制计算机程序的流程。当我们谈论*流程*时，我们指的是程序语句执行的顺序。
- en: Up to this point, you’ve only seen statements performed in the order you’ve
    typed them. You’ve done some cool things with this, but by telling the computer
    how to make choices about the order of executing statements, you can do even more.
    To get the computer to make a choice, we’ll use *conditional statements* that
    tell the computer to run some code based on a condition’s value.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只看到了按你输入的顺序执行的语句。你已经用这些做了一些很酷的事情，但通过告诉计算机如何根据语句执行的顺序做出选择，你可以做得更多。为了让计算机做出选择，我们将使用*条件语句*，它告诉计算机根据条件的值运行一些代码。
- en: You already use conditional statements to make choices every day! For example,
    before you leave home in the morning, you check the weather. If it’s sunny, you
    may put on a pair of sunglasses. If it’s raining, you grab your umbrella. In each
    case, you’re checking a condition. If the condition “it is raining” is true, then
    you take your umbrella when you leave the house. When the condition could be true
    or false, it’s called a *Boolean expression* . The Bool data type that you learned
    about in [Chapter 2](text00012.html#ch02) is used to represent the value true
    or false .
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你每天都在使用条件语句做出选择！例如，早上离家前，你会检查天气。如果是晴天，你可能会戴上太阳镜；如果下雨了，你会拿起雨伞。在每种情况下，你都在检查一个条件。如果“下雨了”这个条件为真，那么你离开家时就会带上雨伞。当条件可能为真或假时，这被称为*布尔表达式*。你在[第2章](text00012.html#ch02)中学到的Bool数据类型用于表示true或false值。
- en: '![image](Image00076.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00076.jpg)'
- en: '**BOOLEAN EXPRESSIONS**'
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**布尔表达式**'
- en: 'A common type of Boolean expression is one that compares two values using a
    *comparison operator* . There are six comparison operators. Let’s start with two
    simple ones: *is equal* and *is not equal* .'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的布尔表达式是使用*比较运算符*来比较两个值。比较运算符一共有六种。让我们从两个简单的运算符开始：*等于*和*不等于*。
- en: '**IS EQUAL AND IS NOT EQUAL**'
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**等于与不等于**'
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你会经常使用*等于*和*不等于*的比较运算符。*等于*用两个等号表示，像这样：==。*不等于*用一个感叹号和一个等号表示，像这样：!=。
- en: Let’s try them both out in the playground!
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Playground中试一试这两个运算符吧！
- en: '![Image](Image00077.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00077.jpg)'
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的英语来说，➊处的代码表示，“三加二等于五”，这是一个正确的陈述，当你输入完后，右侧的输出会确认这一点。➋处的代码表示，“三不等于五”，这也是一个正确的陈述。注意➌处有个错误。你知道为什么吗？虽然=和==看起来很像，但记住单个等号（=）是用来赋值的。那条语句的意思是，“把8的值赋给名为3
    + 5的东西”，这是不成立的。
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，==运算符不仅适用于数字，还适用于其他数据类型。我们来试着做一些其他的比较。
- en: '![Image](Image00078.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00078.jpg)'
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的代码有点棘手；你以为它会是对的吗？这两个字符串接近但并不完全相同，*等于*比较只有在两个值完全匹配时才为真。常量myName的值是“Gloria”，大写的*G*，这与小写的*g*的“gloria”不同。
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在[第二章](text00012.html#ch02)中我们说过，不能对不同数据类型的事物使用数学运算符，比如 + 和 * 吗？比较也是一样的。你不能比较不同类型的事物。➋处的代码会导致错误，因为一个是String类型，另一个是Double类型。
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-356
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**大于和小于**'
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看其他四个比较运算符。我们从*大于*（写作>）和*小于*（写作<）开始。你可能已经对这些运算符有了很好的理解。例如，布尔表达式9 > 7，表示“9大于7”，这是正确的。你可能还想知道某个值是否大于或等于另一个值，或者是否小于或等于另一个值。还有两个运算符可以处理这些情况：*大于或等于*（看起来像>=）和*小于或等于*（看起来像<=）。让我们通过更多例子来试一试：
- en: '![Image](Image00079.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00079.jpg)'
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 注意➊处的*大于或等于*和➋处的*大于*之间的区别。3 + 4的和不大于7，但它大于或等于7。同样，5 + 6小于或等于11 ➌，但它不小于11 ➍。
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-1](text00013.html#ch3tab1)总结了六个比较运算符。'
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-1：** 比较运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| == | Is equal to |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| == | 等于 |'
- en: '| != | Is not equal to |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| != | 不等于 |'
- en: '| > | Is greater than |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| > | 大于 |'
- en: '| < | Is less than |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| < | 小于 |'
- en: '| >= | Is greater than or equal to |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| >= | 大于或等于 |'
- en: '| <= | Is less than or equal to |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| <= | 小于或等于 |'
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写条件语句时，你会经常使用这些运算符。
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合布尔表达式**'
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 复合布尔表达式是由多个简单布尔表达式组合而成的。它就像用 *and* 和 *or* 这两个词在英语中构成复合句。在编程中，还有第三种情况：*not*。在
    Swift 中，我们将这些词称为 *逻辑运算符*。逻辑运算符可以将一个布尔表达式与另一个布尔表达式结合起来，或者对其取反。Swift 中的三种逻辑运算符如下表
    [Table 3-2](text00013.html#ch3tab2) 所示。
- en: '**Table 3-2:** Logical Operators'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**Table 3-2:** 逻辑运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| && | Logical AND |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| && | 逻辑与 |'
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| &#124;&#124; | 逻辑或 |'
- en: '| ! | Logical NOT |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| ! | 逻辑非 |'
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑运算符，你可以编写语句来测试一个值是否在某个范围内，例如：“这个人的年龄在 10 到 15 岁之间吗？”你可以通过同时测试年龄是否大于 10 *并且*
    小于 15 来实现，像这样：
- en: '![Image](Image00080.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00080.jpg)'
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 语句 age > 10 && age < 15 为真，因为两个条件都为真：年龄大于 10 且小于 15。一个与语句只有在两个条件都为真时才为真。
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将 age 的值更改为 18 来看看会发生什么：
- en: '![Image](Image00081.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00081.jpg)'
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将年龄改为 18，所以只有一边的条件为真。变量 age 仍然大于 10，但不再小于 15，因此我们的表达式计算结果为假。
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过在你的 playground 中输入以下代码来测试 OR：
- en: '![Image](Image00082.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00082.jpg)'
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过将常量 name 设置为“Jacqueline”来构造一个名为 Jacqueline 的人。接着，我们测试一些条件，看它们是对还是错。因为
    name == "Jacqueline" 为真，即使 name == "Jack" 为假，➊ 处的或语句也为真。在英语中，这句话的意思是：“这个人叫 Jack
    *或者* 这个人叫 Jacqueline。”在一个或语句中，只要有一个条件为真，整个表达式就为真。
- en: '![image](Image00083.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00083.jpg)'
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用一些 NOT 语句。在你的 playground 中输入以下内容：
- en: '![Image](Image00084.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00084.jpg)'
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '! 运算符在复合布尔语句 ➊ 中被使用，你可以将其读作“我们这个人是 *不是* 女孩 *并且* 我们这个人叫 Jack。”该语句有两个逻辑运算符，!
    和 &&。你可以在编写复合布尔表达式时组合任意数量的逻辑运算符。'
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，使用括号来让计算机知道先计算什么是个好主意。括号也使代码更易读。这就像你在一个方程式中使用多个数学运算时如何使用括号一样，如在“[使用括号排序运算](text00012.html#ch02lev2sec8)”中描述的那样，在[第
    30 页](text00012.html#page_30) 中。 在 ➋ 中，我们使用括号告诉计算机首先检查 !isAGirl && name == "Jack"，然后检查
    isAGirl && name == "Jacqueline"。在评估了这两部分后，计算机可以评估整个语句的 OR 部分，结果为真，因为第二部分为真。再次强调，在
    OR 语句中，如果任何条件为真，整个表达式为真。
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-3](text00013.html#ch3tab3)展示了三种逻辑运算符及其所能构造的复合表达式，以及它们对应的布尔值。'
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-3：** 带有逻辑运算符的复合布尔表达式'
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| **逻辑运算符** | **复合表达式** | **值** |'
- en: '| --- | --- | --- |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| NOT (! ) | !true | false |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| NOT (! ) | !true | false |'
- en: '| NOT (! ) | !false | true |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| NOT (! ) | !false | true |'
- en: '| AND (&& ) | true && true | true |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | true && true | true |'
- en: '| AND (&& ) | true && false | false |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | true && false | false |'
- en: '| AND (&& ) | false && true | false |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | false && true | false |'
- en: '| AND (&& ) | false && false | false |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | false && false | false |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的第一项显示，任何不为真的东西为假。类似地，任何不为假的东西为真。
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 AND 运算符，只有 true && true 才为真。这意味着 && 运算符两侧的表达式必须都为真，&& 表达式才为真。一个 true && false
    的复合表达式会评估为假。而两个条件都为假的复合 && 表达式也会评估为假。
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 OR 运算符，只有 || 运算符两侧的表达式中有一个为真，|| 表达式才为真。因此，true || true 为真，true || false 也为真。只有两个侧面都是假时，复合
    OR 表达式才为假。
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**条件语句**'
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句分为两类：if 语句和 switch 语句。这些语句给计算机提供一个条件，计算机会根据这个条件做出选择。
- en: '**IF STATEMENTS**'
  id: totrans-412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**IF 语句**'
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: if 语句以关键字 if 开头，后跟一个 *条件*，这个条件始终是一个布尔表达式。计算机会检查条件，如果条件为真，则执行 if 语句中的代码；如果条件为假，则跳过这些代码。我们来写些代码，测试一个小孩是否足够高，能坐过山车。将以下代码输入到你的编程环境中：
- en: '[PRE15]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了48英寸作为孩子单独乘坐过山车的最小身高，并将骑行者的身高设置为49.5英寸。在➊处，我们测试骑行者的身高是否大于或等于`heightToRideAlone`。如果是，程序将说他们足够高，可以乘坐过山车。为了编写`if`语句，我们将关键字`if`放在条件`height
    >= heightToRideAlone`前面。然后我们将希望在该条件为真时执行的代码包裹在一对大括号➋中。由于我们的骑行者足够高，计算机将打印“你足够高，可以乘坐这个过山车。”
- en: '![image](Image00085.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00085.jpg)'
- en: Hooray!
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 好极了！
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们改变骑行者的身高会发生什么。将身高改为小于48.0。此时，由于`if`语句中的条件评估为假，程序跳过`if`语句中的所有代码，什么也不发生。
- en: '**else Statements**'
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else 语句**'
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会希望告诉计算机，如果某个条件为真，就执行一件事；如果条件为假，就执行另一件事。为此，在`if`语句和代码块后面，输入关键字`else`，然后跟上你希望在`if`条件不成立时执行的代码块。如果骑行者的身高不足以满足条件，让我们让计算机告诉他们不能乘坐过山车：
- en: '[PRE16]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你将骑行者的身高更改为低于48英寸，你将看到“抱歉，你不能乘坐这个过山车。”这是因为在➊处的`else`语句告诉计算机，如果条件为假，就打印这个信息。用通俗的话说，这就像是说：“如果骑行者足够高，可以乘坐过山车，就说他们可以；否则，说他们不能。”
- en: '**else if Statements**'
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else if 语句**'
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试骑行者身高的不同条件，以制定更多的过山车乘坐规则。我们可以通过添加`else if`条件来实现这一点。让我们添加一个新的最小身高要求，要求孩子必须和成人一起乘坐：
- en: '[PRE17]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的`else if`语句检查骑行者的身高是否大于或等于`heightToRideWithAdult`。如果骑行者的身高在48英寸以下但又高于36英寸，那么结果窗格中将出现“你可以和成人一起乘坐这个过山车。”如果骑行者太矮，无法单独或与成人一起乘坐，那么计算机将打印“抱歉，你不能乘坐这个过山车。”
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`else if`语句非常整洁，因为你可以用它来测试许多不同的条件，但非常重要的一点是，你必须注意这些条件的顺序。为了让你明白我们的意思，先将骑行者的身高改为50.0，这样他们就足够高可以单独乘坐。然后，通过将`height
    >= heightToRideWithAdult`设为第一个条件，`height >= heightToRideAlone`设为第二个条件，来改变`if else`语句中条件的顺序。你认为会打印什么？请查看[图3-1](text00013.html#ch03fig1)来找出答案。'
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00086.jpg)![image](Image00087.jpg)'
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：小心 else if 语句的顺序。*'
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，尽管骑车者的身高高于 heightToRideAlone ，程序依然打印出 "You can ride this roller coaster
    with an adult." 这是预期的输出，因为骑车者的身高大于 heightToRideWithAdult 但小于 heightToRideAlone
    。我们得到这个结果是因为骑车者的身高匹配了第一个条件，因此计算机打印了第一个句子，并且不再检查其他条件。
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 if 或 else if 语句的某个部分为真，其它条件就不会被检查。在我们在 [图 3-1](text00013.html#ch03fig1) 中的例子中，第一个条件为真，所以其后的条件被跳过。这可能会导致程序出现意外结果，所以如果你遇到
    if 或 else if 语句的问题，请检查条件的顺序！
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 if 、else 或 else if 语句时，有一些重要的规则。第一个规则是，除非先写一个 if 语句，否则不能有 else 或 else if
    语句。第二个规则是，虽然你可以在 if 后面添加任意数量的 else if 语句，但只能有一个 else ——且该 else 必须放在最后。else 是一个通用情况，当其他条件都不成立时执行。
- en: '**CODE WITH STYLE**'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '**带有风格的代码**'
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 密切注意我们在本书中使用的编码风格。所谓 *编码风格* ，是指代码书写的方式、空格的使用数量、某些行的缩进以及哪些内容放在新的一行。请看这段代码：
- en: '[PRE18]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 if 条件后，我们留一个空格，然后将开括号 { 放在同一行。代码块的闭括号 } 总是放在下一行的开头。括号内的语句缩进四个空格。这是 Xcode
    自动为你完成的，使代码更加易读。如果觉得加空行能让你更容易阅读，尽管加。在一般情况下，代码块如 if 语句前应该至少有一行空白行。
- en: '![image](Image00088.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00088.jpg)'
- en: '**SWITCH STATEMENTS**'
  id: totrans-438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**switch 语句**'
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 如果说 if 语句仅用于评估一个布尔表达式（即必须为真或假的东西），那么 switch 语句可以在任何数量的条件上进行评估和分支。你可以使用 switch
    来检查一个整数的值，如果该整数等于 1，就让计算机做一件事，如果等于 2，就做另一件事，依此类推。或者，你可以创建一个名为 dayOfTheWeek 的字符串，并编写一个
    switch 语句，使计算机根据 dayOfTheWeek 的值执行不同的操作。
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机找到第一个匹配项时，相关代码块会被执行。请看以下代码，它为不同年级的学生分配项目：
- en: '[PRE19]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: switch 语句以关键字 switch 开始，后面跟着 *控制表达式*。在这个例子中，控制表达式是变量 studentGrade。
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制表达式后，花括号从➊开始，`switch`语句的主体就在这些花括号内。
- en: '![Image](Image00089.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00089.jpg)'
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句的主体由一个或多个`case`组成。在这个示例中，共有六个`case`。每个`case`都以关键字`case`开始，后面跟着一个值和一个冒号，如➋所示。如果一个`case`语句与控制表达式匹配，紧接在该`case`后的代码将会执行。每个`case`必须至少有一行代码，否则会报错。在这个示例中，`switch`用于将赋给变量`studentProject`的字符串从“待定”改为与控制表达式匹配的`case`中的字符串。'
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以让多个`case`执行相同的操作。你可以看到6、7和8年级的学生都可以选择自己的项目➌。我们通过编写关键字`case`，然后用逗号分隔的值列表来指定这一点。
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`switch`语句必须考虑控制表达式的每个可能的情况或值。在我们的示例中，因为`studentGrade`是一个Int类型，我们的`switch`语句需要为所有可能的Int值编写一个`case`。但这将需要很长时间来编写，因为有太多可能性了！例如，–7是一个Int，1,000也是一个Int。你真的想为1,000个不同的情况写代码吗？
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 与其为每个值编写一个单独的`case`，你可以使用关键字`default`作为最后一个`case`，就像我们在➍所做的那样。你只需输入`default`，后面跟一个冒号（`default:`），然后输入如果没有其他`case`匹配时你希望运行的代码。注意，`default`语句前面没有`case`这个词。`default`语句对于处理你可能没有预料到的值非常有用，它让你避免写这么多`case`语句。在这个示例中，我们只期望`studentGrade`的值为1到8之间，因此我们使用`default`语句来覆盖所有其他可能的值。
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行这个`switch`语句，看看结果。然后尝试更改值来测试不同的条件。试试看吧！
- en: '**WHAT YOU LEARNED**'
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何编程让计算机根据条件做出选择，使用了`if`和`switch`语句。你学会了如何编写布尔表达式和复合表达式，以及不同的比较运算符。条件语句是编程中的一个基本工具，几乎每个有用的程序中都会看到它们。在[第4章](text00014.html#ch04)中，我们将探讨另一种重要的编程语句——循环。循环告诉计算机反复执行某个操作，直到需要停止循环为止。
- en: '![image](Image00090.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00090.jpg)'
- en: Up to this point, you’ve only seen statements performed in the order you’ve
    typed them. You’ve done some cool things with this, but by telling the computer
    how to make choices about the order of executing statements, you can do even more.
    To get the computer to make a choice, we’ll use *conditional statements* that
    tell the computer to run some code based on a condition’s value.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只见过按你输入的顺序执行的语句。你已经用这些做了一些很酷的事情，但通过告诉计算机如何选择执行语句的顺序，你可以做更多的事情。为了让计算机做出选择，我们将使用*条件语句*，它告诉计算机根据条件的值运行某些代码。
- en: You already use conditional statements to make choices every day! For example,
    before you leave home in the morning, you check the weather. If it’s sunny, you
    may put on a pair of sunglasses. If it’s raining, you grab your umbrella. In each
    case, you’re checking a condition. If the condition “it is raining” is true, then
    you take your umbrella when you leave the house. When the condition could be true
    or false, it’s called a *Boolean expression* . The Bool data type that you learned
    about in [Chapter 2](text00012.html#ch02) is used to represent the value true
    or false .
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 你每天都会使用条件语句做出选择！比如，早上离开家之前，你会查看天气。如果天气晴朗，你可能会戴上太阳镜。如果下雨了，你就拿上雨伞。在每种情况下，你都在检查一个条件。如果条件“正在下雨”是真的，那么当你离开家时，你会拿上雨伞。当条件可能为真或为假时，这就叫做*布尔表达式*。你在[第2章](text00012.html#ch02)中学到的
    Bool 数据类型用于表示真假值。
- en: '![image](Image00076.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00076.jpg)'
- en: '**BOOLEAN EXPRESSIONS**'
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**布尔表达式**'
- en: 'A common type of Boolean expression is one that compares two values using a
    *comparison operator* . There are six comparison operators. Let’s start with two
    simple ones: *is equal* and *is not equal* .'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的布尔表达式是使用*比较运算符*比较两个值。比较运算符有六种。让我们从两个简单的开始：*相等* 和 *不相等*。
- en: '**IS EQUAL AND IS NOT EQUAL**'
  id: totrans-458
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**相等和不相等**'
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 你会经常使用 *相等* 和 *不相等* 比较运算符。*相等* 用两个等号表示，像这样：==。*不相等* 用一个感叹号和一个等号表示，像这样：!=。
- en: Let’s try them both out in the playground!
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来 Playground 中试试这两个吧！
- en: '![Image](Image00077.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00077.jpg)'
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的英语来说，➊ 处的代码表示：“三加二等于五”，这是一个真实的陈述，当你输入完后，右侧面板的输出会确认这一点。在➋ 处，代码表示，“三不等于五”，这也是一个真实的陈述。注意，➌
    是一个错误。你知道为什么吗？虽然 = 和 == 看起来很相似，但请记住，单个等号 (=) 是用于赋值的。那条语句的意思是：“将 8 的值赋给名为 3 + 5
    的变量”，但这行不通。
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，== 运算符不仅适用于数字，还适用于其他数据类型。我们来尝试进行一些其他比较吧。
- en: '![Image](Image00078.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00078.jpg)'
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码有点棘手，你期待它是真的么？这两个字符串很相近，但并不完全相同，*相等* 比较只有在两个值完全匹配时才为真。常量 myName 的值是 "Gloria"，首字母是大写
    *G*，这与 "gloria"（小写 *g*）不同。
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在[第2章](text00012.html#ch02)中我们说过，你不能对不同数据类型的东西使用数学运算符，比如 + 和 * 吗？比较也是一样的。你不能比较不同类型的东西。➋
    处的代码会导致错误，因为一个是字符串 (String)，另一个是双精度浮点数 (Double)。
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-467
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**大于和小于**'
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看另外四个比较运算符。我们从 *大于*（写作 >）和 *小于*（写作 <）开始。你可能已经对它们的工作原理有了很好的了解。一个布尔表达式像
    9 > 7，表示“9 大于 7”，它为真。通常，你还想知道某个值是否大于或等于某个值，或者小于或等于某个值。还有两个运算符可以处理这些情况：*大于或等于*（写作
    >=）和 *小于或等于*（写作 <=）。我们来通过一些例子试试看：
- en: '![Image](Image00079.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00079.jpg)'
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 注意➊处的*大于或等于*与➋处的*大于*的区别。3 + 4 的和不大于 7，但它大于或等于 7。同样，5 + 6 小于或等于 11 ➌，但它不小于 11
    ➍。
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-1](text00013.html#ch3tab1) 总结了六个比较运算符。'
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-1：** 比较运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| == | Is equal to |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| == | 等于 |'
- en: '| != | Is not equal to |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| != | 不等于 |'
- en: '| > | Is greater than |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| > | 大于 |'
- en: '| < | Is less than |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| < | 小于 |'
- en: '| >= | Is greater than or equal to |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| >= | 大于或等于 |'
- en: '| <= | Is less than or equal to |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| <= | 小于或等于 |'
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写条件语句时，你会经常使用这些运算符。
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-482
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合布尔表达式**'
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 复合布尔表达式是简单的布尔表达式，通过逻辑运算符连接在一起。它有点像在英语中用 *和* 或 *或* 连接复合句。在编程中，还有第三种情况：*非*。在 Swift
    中，我们称这些词为 *逻辑运算符*。逻辑运算符要么将一个布尔表达式与另一个布尔表达式结合，要么对其进行取反。Swift 中的三个逻辑运算符见 [表 3-2](text00013.html#ch3tab2)。
- en: '**Table 3-2:** Logical Operators'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-2：** 逻辑运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| && | Logical AND |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| && | 逻辑 AND |'
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| &#124;&#124; | 逻辑 OR |'
- en: '| ! | Logical NOT |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| ! | 逻辑 NOT |'
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑运算符，你可以编写测试一个值是否落在某个范围内的语句，比如：“这个人的年龄是否在 10 到 15 之间？”你可以通过同时测试 age 是否大于
    10 *且*小于 15 来实现，像这样：
- en: '![Image](Image00080.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00080.jpg)'
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 语句 age > 10 && age < 15 为真，因为两个条件都为真：age 大于 10 且小于 15。AND 语句仅在两个条件都为真时才为真。
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将 age 的值改为 18 来看看会发生什么：
- en: '![Image](Image00081.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00081.jpg)'
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将 age 改为 18，所以只有一边的语句为真。变量 age 仍然大于 10，但不再小于 15，所以我们的表达式结果为假。
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过在你的游乐场中输入以下代码来测试 OR：
- en: '![Image](Image00082.jpg)'
  id: totrans-497
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00082.jpg)'
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过将常量名称设置为“Jacqueline”来创造一个名为Jacqueline的人。接着，我们测试一些条件，看看它们是否为真或假。由于 name
    == "Jacqueline" 为真，即使 name == "Jack" 为假，➊处的或（OR）语句也为真。用英语来说，这个语句意思是：“此人的名字是Jack
    *或者*此人的名字是Jacqueline。”在或（OR）语句中，只需要有一个条件为真，整个表达式就为真。
- en: '![image](Image00083.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00083.jpg)'
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用一些 NOT 语句。将以下内容输入到你的操作环境中：
- en: '![Image](Image00084.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00084.jpg)'
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '! 运算符在复合布尔语句 ➊ 中使用，你可以将其理解为：“我们的人*不是*女孩*并且*我们的人叫Jack。”该语句有两个逻辑运算符：! 和 &&。在编写复合布尔表达式时，你可以结合任意多个逻辑运算符。'
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，使用括号是一个好主意，它可以告诉计算机先进行哪些运算。括号也能使代码更易于阅读。这就像你在一个方程式中使用多个数学运算时使用括号一样，如 “[使用括号排序运算](text00012.html#ch02lev2sec8)”一节中描述的那样。
    在➋处，我们使用括号告诉计算机先检查 !isAGirl && name == "Jack"，然后再检查 isAGirl && name == "Jacqueline"。在计算了这两部分后，计算机就可以对整个语句的
    OR 部分进行求值，因为第二部分为真。再次强调，在 OR 语句中，只要任何条件为真，整个表达式就为真。
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '[表3-3](text00013.html#ch3tab3)展示了三种逻辑运算符以及可以使用它们构建的复合表达式，并给出了它们对应的布尔值。'
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-3：** 布尔逻辑运算符的复合表达式'
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '| **逻辑运算符** | **复合表达式** | **值** |'
- en: '| --- | --- | --- |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| NOT (! ) | !true | false |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '| 非（! ）| !true | false |'
- en: '| NOT (! ) | !false | true |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| 非（! ）| !false | true |'
- en: '| AND (&& ) | true && true | true |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| 与（&& ）| true && true | true |'
- en: '| AND (&& ) | true && false | false |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| 与（&& ）| true && false | false |'
- en: '| AND (&& ) | false && true | false |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| 与（&& ）| false && true | false |'
- en: '| AND (&& ) | false && false | false |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| 与（&& ）| false && false | false |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| 或（&#124;&#124; ）| true &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| 或（&#124;&#124; ）| true &#124;&#124; false | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| 或（&#124;&#124; ）| false &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| 或（&#124;&#124; ）| false &#124;&#124; false | false |'
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中的第一项显示，不为真的东西是假。同样，不为假的东西是真的。
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与（&&）运算符时，只有同时为真&&真时结果才为真。这意味着&&运算符两边的表达式必须都为真，整个&&表达式才为真。一个复合表达式如果是真&&假，将计算为假。如果一个复合&&表达式两边的条件都为假，结果也会计算为假。
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 OR 运算符，只有在 || 运算符两边的表达式中至少一个为真时，|| 表达式才为真。因此，true || true 为真，true || false
    也为真。只有在两个表达式都为假时，复合的 OR 表达式才会为假。
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**条件语句**'
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句分为两类：if 语句和 switch 语句。这些语句向计算机提供一个条件，计算机会基于该条件做出选择。
- en: '**IF STATEMENTS**'
  id: totrans-523
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**IF 语句**'
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: if 语句以关键字 if 开头，后面跟着一个 *条件*，它总是一个布尔表达式。计算机会检查条件，如果条件为真，则执行 if 语句中的代码；如果条件为假，则跳过这些代码。让我们写一些代码来测试一个孩子是否足够高，能够乘坐过山车。将以下代码输入到你的操作平台中：
- en: '[PRE20]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 48 英寸设为孩子可以单独乘坐过山车的最低身高，并将乘客的身高设为 49.5 英寸。在 ➊ 处，我们测试乘客的身高是否大于或等于 heightToRideAlone。如果是，程序会显示他们足够高，可以乘坐过山车。为了写这个
    if 语句，我们在条件 height >= heightToRideAlone 前面加上关键字 if。然后，我们将希望在该条件为真时执行的代码包裹在一对大括号
    ➋ 中。由于我们的乘客身高足够，计算机会打印出“你足够高，可以乘坐这个过山车。”
- en: '![image](Image00085.jpg)'
  id: totrans-527
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00085.jpg)'
- en: Hooray!
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 耶！
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们改变乘客的身高会发生什么。将身高改为小于 48.0。由于 if 语句中的条件为假，程序跳过了 if 语句中的所有代码，因此没有任何反应。
- en: '**else Statements**'
  id: totrans-530
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else 语句**'
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你会希望在某个条件为真时让计算机执行一件事，而在该条件为假时执行另一件事。为此，在 if 语句和代码块之后，只需键入关键字 else，然后跟随另一个代码块，当
    if 条件不成立时执行该代码块。如果乘客的身高不足以满足条件，我们可以让计算机告诉他们不能乘坐过山车：
- en: '[PRE21]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你将乘客的身高更改为小于 48 英寸，你将看到“抱歉，你不能乘坐这个过山车。”这是因为在 ➊ 的 else 语句告诉计算机，当条件为假时打印该消息。用通俗的话来说，这就像是在说：“如果乘客足够高，可以乘坐过山车，就告诉他们可以坐；否则，就告诉他们不能坐。”
- en: '**else if Statements**'
  id: totrans-534
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else if 语句**'
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试不同的条件，以为乘客的身高设置更多规则，从而决定是否能乘坐过山车。我们可以通过添加 else if 条件来实现这一点。让我们增加一个新的最低身高要求，要求孩子与成人一起乘坐：
- en: '[PRE22]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的 else if 语句检查骑车者的身高是否大于或等于 heightToRideWithAdult。如果骑车者的身高在 48 英寸以下但大于 36
    英寸，那么结果面板上会出现“你可以和成人一起乘坐这个过山车。”如果他们太矮，无法单独或与成人一起乘坐过山车，则计算机会打印“抱歉，你不能单独乘坐这个过山车。”
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: else if 语句很整洁，因为你可以用它来测试许多不同的条件，但非常重要的一点是，你必须注意这些条件的顺序。为了展示我们的意思，请将骑车者的身高改为
    50.0，这样他们就足够高，可以单独乘坐。然后，修改我们的 if else 语句中的条件顺序，把 height >= heightToRideWithAdult
    放在第一个条件，height >= heightToRideAlone 放在第二个条件。你认为会打印出什么？请查看[图 3-1](text00013.html#ch03fig1)来找答案。
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00086.jpg)![image](Image00087.jpg)'
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：小心排列 else if 语句的顺序。*'
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，尽管骑车者的身高高于 heightToRideAlone，程序仍然打印出“你可以和成人一起乘坐这个过山车。”这是因为骑车者的身高大于 heightToRideWithAdult
    但小于 heightToRideAlone。我们得到这个结果是因为骑车者的身高符合第一个条件，所以计算机会打印第一句话，并且不再检查其他条件。
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 if 或 else if 语句的某部分被判断为 true，程序将不会再检查其他条件。在我们[图 3-1](text00013.html#ch03fig1)中的示例中，第一个条件为真，因此其余条件被跳过。这可能会导致程序中出现意外的结果，因此，如果你在使用
    if 或 else if 语句时遇到问题，请检查条件的顺序！
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 if、else 或 else if 语句时，有几个重要的规则。第一个是，你不能在没有先写 if 语句的情况下使用 else 或 else if
    语句。第二个是，尽管在 if 后可以有任意多个 else if 语句，但只能有一个 else —— 并且这个 else 必须是最后一个。else 语句用于捕获所有其他情况，如果之前的条件都没有成立，就会执行它。
- en: '**CODE WITH STYLE**'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '**有风格的代码**'
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 请密切关注我们在本书中使用的编码风格。这里所说的*编码风格*，指的是代码的书写方式、使用的空格数量、某些行的缩进方式以及哪些内容需要放在新的一行。请看这段代码：
- en: '[PRE23]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`if`条件之后，我们留一个空格，然后将打开的大括号 `{` 放在同一行。块的关闭大括号 `}` 总是放在下一行的开头。大括号中的语句缩进四个空格。这是Xcode自动为你完成的操作，使代码更具可读性。如果这样做让你更容易阅读，随意添加空行。通常，在像`if`语句这样的代码块之前，你应该至少有一个空行。
- en: '![image](Image00088.jpg)'
  id: totrans-548
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00088.jpg)'
- en: '**SWITCH STATEMENTS**'
  id: totrans-549
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**SWITCH语句**'
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 而`if`语句仅用于评估布尔表达式（必须为真或假的东西），`switch`语句可以评估并根据任意数量的条件进行分支。你可以使用`switch`来检查一个整数的值，并告诉计算机当整数等于1时做某事，当整数等于2时做另一件事，依此类推。或者，你可以创建一个名为`dayOfTheWeek`的字符串，并编写一个`switch`语句，根据`dayOfTheWeek`的值让计算机做不同的事情。
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机找到第一个匹配项时，那个代码块会被执行。看看以下代码，它为不同年级的学生分配项目：
- en: '[PRE24]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句以`switch`关键字开始，后面跟着*控制表达式*。在这个例子中，控制表达式是变量`studentGrade`。'
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制表达式之后，一组大括号从 ➊ 开始，`switch`语句的主体在这些大括号内。
- en: '![Image](Image00089.jpg)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00089.jpg)'
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句的主体由一个或多个`case`组成。在这个例子中，总共有六个`case`。每个`case`以`case`关键字开头，后面跟着一个值和一个冒号，如
    ➋ 所示。如果一个`case`语句与控制表达式匹配，紧随其后的代码将会执行。每个`case`必须至少有一行代码，否则会报错。在这个例子中，`switch`用于将分配给变量`studentProject`的字符串从"待定"更改为与控制表达式匹配的`case`中的字符串。'
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以有多个`case`都执行相同的操作。你可以看到，6、7、8年级的学生都可以选择自己的项目 ➌。我们通过写`case`关键字，然后是一个以逗号分隔的值列表来指定这一点。
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`switch`语句必须考虑控制表达式的每个可能的`case`或值。在我们的例子中，由于`studentGrade`是`Int`类型，我们的`switch`语句需要包含所有可能的`Int`值的`case`。但这将需要很长时间来编写，因为有这么多！例如，–7是`Int`类型，1000也是`Int`类型。你真的想写1000个`case`吗？
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用关键字 default 作为最后一个 case，而不是为每个值写一个单独的 case，就像我们在 ➍ 处所做的那样。你只需输入 default
    后跟一个冒号（default:），然后写下你希望在其他 case 不匹配时运行的代码。注意，default case 前没有 case 这个词。default
    case 对于处理你可能没有预料到的值非常有用，并且可以让你避免写太多的 case 语句。在这个例子中，我们只期望 studentGrade 的值在 1 到
    8 之间，所以我们使用 default case 来涵盖所有其他可能的值。
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行这个 switch 语句，看看你得到的结果。然后尝试改变这些值，测试不同的条件。尽情尝试吧！
- en: '**WHAT YOU LEARNED**'
  id: totrans-561
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何通过 if 和 switch 语句编写程序，让计算机根据条件做出选择。你学会了如何编写布尔表达式和复合表达式，以及不同的比较运算符。条件语句是一个重要的编程工具，几乎在每个有用的程序中都能看到它们。在[第4章](text00014.html#ch04)中，我们将探讨另一种重要的编程语句——循环。循环告诉计算机重复执行某些操作，直到停止循环的条件成立。
- en: '![image](Image00090.jpg)'
  id: totrans-563
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00090.jpg)'
- en: You already use conditional statements to make choices every day! For example,
    before you leave home in the morning, you check the weather. If it’s sunny, you
    may put on a pair of sunglasses. If it’s raining, you grab your umbrella. In each
    case, you’re checking a condition. If the condition “it is raining” is true, then
    you take your umbrella when you leave the house. When the condition could be true
    or false, it’s called a *Boolean expression* . The Bool data type that you learned
    about in [Chapter 2](text00012.html#ch02) is used to represent the value true
    or false .
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 你每天都会使用条件语句来做出选择！例如，早上离家前，你会检查天气。如果是晴天，你可能会戴上一副太阳镜。如果下雨了，你会拿上雨伞。在每种情况下，你都在检查一个条件。如果“下雨”这个条件为真，那么你离开家时就会带上雨伞。当条件可能为真或假时，这叫做*布尔表达式*。你在[第2章](text00012.html#ch02)中学到的
    Bool 数据类型用于表示真或假的值。
- en: '![image](Image00076.jpg)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00076.jpg)'
- en: '**BOOLEAN EXPRESSIONS**'
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**布尔表达式**'
- en: 'A common type of Boolean expression is one that compares two values using a
    *comparison operator* . There are six comparison operators. Let’s start with two
    simple ones: *is equal* and *is not equal* .'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的布尔表达式是通过*比较运算符*比较两个值。比较运算符有六种。让我们从两个简单的开始：*等于*和*不等于*。
- en: '**IS EQUAL AND IS NOT EQUAL**'
  id: totrans-568
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**等于与不等于**'
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 你将经常使用*等于*和*不等于*比较运算符。*等于*用两个等号紧挨着写，如：==。*不等于*用感叹号和一个等号写，如：!=。
- en: Let’s try them both out in the playground!
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在练习场中试试这两个运算符！
- en: '![Image](Image00077.jpg)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00077.jpg)'
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的英语来说，➊ 这一行表示，“三加二等于五”，这是一个正确的陈述，右侧窗格的输出会在你输入完成后确认这一点。在➋，这一行表示，“三不等于五”，这也是一个正确的陈述。请注意，➌
    是一个错误。你知道为什么吗？虽然 = 和 == 看起来非常相似，但请记住，单个等号（=）用于赋值。那条语句的意思是，“将 8 的值放入名为 3 + 5 的东西中”，这是不成立的。
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，==运算符也可以与其他数据类型一起使用，而不仅仅是数字。让我们试着进行一些其他的比较。
- en: '![Image](Image00078.jpg)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00078.jpg)'
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的代码有点棘手；你预料到它是对的吗？那两个字符串相似但不完全相同，*等于*的比较只有在两个值完全匹配时才为真。常量myName的值是"Gloria"，首字母*G*大写，这与"gloria"（小写*g*）不同。
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住在[第2章](text00012.html#ch02)时我们提到过，不能对不同数据类型的东西使用数学运算符，如+和*。比较也是如此。你不能比较不同类型的东西。➋处的代码会导致错误，因为一个是字符串，另一个是双精度浮点数（Double）。
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-577
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**大于与小于**'
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下另外四个比较运算符。我们从*大于*（写作>）和*小于*（写作<）开始。你可能已经对它们的工作原理有了一个很好的了解。像9 > 7这样的布尔表达式，表示“9大于7”，它是对的。通常，你还会想知道某个东西是否大于或等于某个东西，或者是否小于或等于某个东西。还有两个运算符可以处理这些情况：*大于或等于*（看起来像>=）和*小于或等于*（看起来像<=）。让我们通过一些例子来试试这些运算符：
- en: '![Image](Image00079.jpg)'
  id: totrans-579
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00079.jpg)'
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 注意➊处的*大于等于*与➋处的*大于*之间的区别。3 + 4的和不大于7，但它大于或等于7。同样，5 + 6小于或等于11 ➌，但它不小于11 ➍。
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '[表3-1](text00013.html#ch3tab1)总结了六个比较运算符。'
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-1：** 比较运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| == | Is equal to |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '| == | 等于 |'
- en: '| != | Is not equal to |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
  zh: '| != | 不等于 |'
- en: '| > | Is greater than |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
  zh: '| > | 大于 |'
- en: '| < | Is less than |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '| < | 小于 |'
- en: '| >= | Is greater than or equal to |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
  zh: '| >= | 大于或等于 |'
- en: '| <= | Is less than or equal to |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '| <= | 小于或等于 |'
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写条件语句时，你会经常使用这些运算符。
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-592
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合布尔表达式**'
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 复合布尔表达式是将简单布尔表达式连接在一起的表达式。它很像用*和*和*或*在英语中构造复合句。在编程中，还有第三种情况：*非*。在Swift中，我们称这些词为*逻辑运算符*。逻辑运算符要么将一个布尔表达式与另一个布尔表达式结合，要么对其进行取反。Swift中的三个逻辑运算符如[表3-2](text00013.html#ch3tab2)所示。
- en: '**Table 3-2:** Logical Operators'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-2：** 逻辑运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-596
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| && | Logical AND |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '| && | 逻辑与 |'
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '| &#124;&#124; | 逻辑或 |'
- en: '| ! | Logical NOT |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '| ! | 逻辑非 |'
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑运算符，你可以编写测试某个值是否位于某个范围内的语句，例如：“这个人的年龄是否在10到15岁之间？”你可以通过同时测试年龄是否大于10*且*小于15来实现，像这样：
- en: '![Image](Image00080.jpg)'
  id: totrans-601
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00080.jpg)'
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 语句 age > 10 && age < 15 为真，因为两个条件都为真：age 大于 10 且小于 15。AND 语句只有在两个条件都为真时才为真。
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将 age 的值改为 18，看看会发生什么：
- en: '![Image](Image00081.jpg)'
  id: totrans-604
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00081.jpg)'
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将 age 改为 18，所以语句只有一侧为真。变量 age 仍然大于 10，但不再小于 15，因此我们的表达式评估为假。
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过在 playground 中输入以下代码来测试 OR：
- en: '![Image](Image00082.jpg)'
  id: totrans-607
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00082.jpg)'
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过将常量 name 设置为 "Jacqueline" 来构造一个名为 Jacqueline 的人。接下来，我们测试一些条件来查看它们是对还是错。由于
    name == "Jacqueline" 为真，➊ 处的 OR 语句为真，即使 name == "Jack" 为假。用英文来说，这个语句表示：“此人的名字是
    Jack *或* 此人的名字是 Jacqueline。”在 OR 语句中，只要其中一个条件为真，整个表达式就为真。
- en: '![image](Image00083.jpg)'
  id: totrans-609
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00083.jpg)'
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用一些 NOT 语句。在你的 playground 中输入以下内容：
- en: '![Image](Image00084.jpg)'
  id: totrans-611
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00084.jpg)'
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 在复合布尔表达式 ➊ 中使用了 ! 运算符，你可以将其理解为“我们的这个人*不是*女孩*并且*我们这个人的名字是 Jack。”该语句有两个逻辑运算符，!
    和 &&。你可以在编写复合布尔表达式时组合任意多个逻辑运算符。
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候使用括号来告诉计算机先计算什么是个好主意。括号还能让代码更容易阅读。这就像你在一个数学方程式中使用多个运算符时使用括号的方式，正如在 “[使用括号排列运算](text00012.html#ch02lev2sec8)”中所描述的，在[第30页](text00012.html#page_30)中。
    在 ➋ 处，我们使用括号告诉计算机首先检查 !isAGirl && name == "Jack"，然后检查 isAGirl && name == "Jacqueline"。在计算完这两个部分后，计算机可以计算整个语句的
    OR 部分，这将为真，因为第二部分为真。再次强调，在 OR 语句中，如果任何条件为真，整个表达式就为真。
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-3](text00013.html#ch3tab3) 显示了三种逻辑运算符以及你可以用它们创建的复合表达式，以及它们对应的布尔值。'
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-3：** 使用逻辑运算符的复合布尔表达式'
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '| **逻辑运算符** | **复合表达式** | **值** |'
- en: '| --- | --- | --- |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| NOT (! ) | !true | false |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
  zh: '| NOT (! ) | !true | false |'
- en: '| NOT (! ) | !false | true |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
  zh: '| NOT (! ) | !false | true |'
- en: '| AND (&& ) | true && true | true |'
  id: totrans-620
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | true && true | true |'
- en: '| AND (&& ) | true && false | false |'
  id: totrans-621
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | true && false | false |'
- en: '| AND (&& ) | false && true | false |'
  id: totrans-622
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | false && true | false |'
- en: '| AND (&& ) | false && false | false |'
  id: totrans-623
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | false && false | false |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-625
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 表格的第一项显示，不成立的东西是假的。同样，成立的东西就是真的。
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`AND`操作符时，只有`true && true`才为真。这意味着`&&`操作符两边的表达式都必须为真，整个`&&`表达式才为真。一个复合表达式`true
    && false`将评估为假。而一个`&&`复合表达式，如果两边条件都是假，也将评估为假。
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到`OR`操作符时，`||`操作符两边的表达式中，只要有一个为真，整个`||`表达式就为真。因此，`true || true`为真，`true ||
    false`也为真。只有当`||`表达式两边的条件都是假时，才会评估为假。
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-631
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**条件语句**'
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句分为两类：`if`语句和`switch`语句。这些语句给计算机提供了一个条件，计算机会根据该条件做出选择。
- en: '**IF STATEMENTS**'
  id: totrans-633
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**IF 语句**'
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`if`语句以关键字`if`开始，后面跟着一个*条件*，这个条件始终是一个布尔表达式。计算机会检查该条件，如果条件为真，则执行`if`语句内的代码；如果条件为假，则跳过这些代码。让我们编写一些代码，测试一个孩子是否足够高可以坐过山车。将以下代码输入到你的代码编辑器中：
- en: '[PRE25]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了48英寸为儿童可以单独乘坐过山车的最低身高，并将乘客的身高设置为49.5英寸。在➊处，我们测试乘客的身高是否大于或等于`heightToRideAlone`。如果是，程序会显示他们足够高，可以乘坐过山车。为了编写`if`语句，我们在条件`height
    >= heightToRideAlone`前加上关键字`if`。然后，我们将希望在该条件成立时执行的代码放在一对大括号➋中。由于我们的乘客足够高，计算机会打印出“你足够高，可以乘坐这个过山车。”
- en: '![image](Image00085.jpg)'
  id: totrans-637
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00085.jpg)'
- en: Hooray!
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 万岁！
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们改变乘客的身高会发生什么。将身高改为小于48.0的数字。这一次，因为`if`语句中的条件评估为假，程序会跳过`if`语句中的所有代码，什么也不会发生。
- en: '**else Statements**'
  id: totrans-640
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else 语句**'
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会希望告诉计算机，如果某个条件为真时做一件事，而当该条件为假时做另一件事。要实现这一点，在`if`语句和代码块之后，只需输入关键字`else`，然后再输入一个代码块，当`if`条件不成立时，计算机会执行这个代码块。如果乘客的身高不符合要求，那么让计算机告诉他们不能坐过山车：
- en: '[PRE26]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你将骑车者的身高改为低于 48 英寸，你会看到“抱歉，你不能乘坐这个过山车。” 这是因为 ➊ 处的 `else` 语句告诉计算机，如果语句为假，则打印该消息。通俗来说，这就像在说：“如果骑车者足够高可以乘坐过山车，就说他们可以乘坐；否则，说他们不能。”
- en: '**else if Statements**'
  id: totrans-644
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else if 语句**'
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试骑车者身高的不同条件，以制定更多的过山车乘坐规则。我们可以通过添加 `else if` 条件来实现这一点。让我们添加一个新的最小身高要求，要求孩子必须与成人一起乘坐：
- en: '[PRE27]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的 `else if` 语句检查骑车者的身高是否大于或等于 `heightToRideWithAdult`。如果骑车者的身高高于 36 英寸但低于
    48 英寸，那么结果面板中会出现“你可以和成人一起乘坐这个过山车。”如果他们太矮，无法独自乘坐或与成人一起乘坐，则计算机会打印“抱歉，你不能乘坐这个过山车。”
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '`else if` 语句很简洁，因为你可以用它来测试许多不同的条件，但非常重要的是要注意这些条件的顺序。为了说明我们的意思，将骑车者的身高改为 50.0，这样他们就足够高可以独自乘坐了。然后，通过将
    `height >= heightToRideWithAdult` 作为第一个条件，`height >= heightToRideAlone` 作为第二个条件，来改变
    `if else` 语句中的条件顺序。你认为会打印什么？查看[图 3-1](text00013.html#ch03fig1)看看答案。'
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-649
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00086.jpg)![image](Image00087.jpg)'
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：小心排列 `else if` 语句的顺序。*'
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，即使骑车者的身高超过了 `heightToRideAlone`，程序仍然打印出“你可以和成人一起乘坐这个过山车。” 这是因为骑车者的身高大于
    `heightToRideWithAdult` 但小于 `heightToRideAlone`，符合第一个条件，所以计算机打印了第一句，并且没有继续检查其他条件。
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `if` 或 `else if` 语句中的某个部分被判定为真，剩下的条件将不再被检查。在我们在[图 3-1](text00013.html#ch03fig1)中的例子中，第一个条件为真，因此其后的条件被跳过了。这可能导致程序中出现意外的结果，因此，如果你在使用
    `if` 或 `else if` 语句时遇到问题，请检查条件的顺序！
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `if`、`else` 或 `else if` 语句时，有一些重要的规则。第一条是，除非先写一个 `if` 语句，否则不能使用 `else` 或
    `else if` 语句。第二条是，尽管你可以在 `if` 后面有任意数量的 `else if` 语句，但只能有一个 `else`，并且这个 `else`
    必须放在最后。`else` 是在没有其他条件成立时的兜底选项。
- en: '**CODE WITH STYLE**'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '**有风格的代码**'
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 请密切关注我们在本书中使用的编码风格。所谓 *编码风格*，指的是代码的编写方式、使用的空格数量、某些行的缩进以及哪些内容应该放在新的一行。看看这段代码：
- en: '[PRE28]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 if 条件之后，我们留了一个空格，然后将左大括号 { 放在同一行上。代码块的右大括号 } 总是放在下一行的开头。大括号内的语句会缩进四个空格。这是
    Xcode 自动为你做的，以便让代码更具可读性。如果这样做能让你更容易阅读，欢迎添加空行。通常，在 if 语句等代码块之前，你应该至少留有一行空白。
- en: '![image](Image00088.jpg)'
  id: totrans-658
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00088.jpg)'
- en: '**SWITCH STATEMENTS**'
  id: totrans-659
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**SWITCH 语句**'
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 而 if 语句仅用于评估布尔表达式（必须为真或假的东西），switch 语句可以评估并根据任意多个条件进行分支。你可以使用 switch 来检查整数的值，并告诉计算机在整数等于
    1 时做一件事，在整数等于 2 时做另一件事，以此类推。或者，你可以创建一个名为 dayOfTheWeek 的字符串，并编写一个 switch 语句，根据
    dayOfTheWeek 的值让计算机做不同的事情。
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机找到第一个匹配项时，那个代码块会被执行。看看以下代码，它为不同年级的学生分配项目：
- en: '[PRE29]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: switch 语句以关键字 switch 开始，后跟 *控制表达式*。在这个例子中，控制表达式是变量 studentGrade。
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制表达式之后，从 ➊ 开始一对大括号，switch 语句的主体位于这些大括号内。
- en: '![Image](Image00089.jpg)'
  id: totrans-665
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00089.jpg)'
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: switch 语句的主体由一个或多个 case 组成。在这个例子中，总共有六个 case。每个 case 以关键字 case 开头，后跟一个值和冒号，如
    ➋ 所示。如果 case 语句与控制表达式匹配，紧跟在 case 后的代码将执行。每个 case 必须至少包含一行代码，否则会报错。在这个例子中，switch
    用于将分配给变量 studentProject 的字符串从 "To be determined" 改为与控制表达式匹配的 case 中的字符串。
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以让多个 case 执行相同的操作。你可以看到 6、7 和 8 年级的学生都可以选择自己的项目 ➌ 。我们通过编写关键字 case，然后列出用逗号分隔的值来指定这一点。
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，switch 语句必须考虑控制表达式的每个可能的 case 或值。在我们的例子中，因为 studentGrade 是一个 Int 类型，我们的 switch
    语句需要为所有可能的 Int 值设置 case。但是这将需要非常长的时间来编写，因为可能的值实在太多了！例如，–7 是 Int 类型，1000 也是 Int
    类型。你真的想写 1000 个 case 吗？
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 不必为每个值写一个单独的 case，你可以使用关键字 default 作为最后一个 case，就像我们在 ➍ 处做的那样。你只需要输入 default
    后跟冒号（default:），然后是你希望在其他 case 不匹配时运行的代码。注意，default case 前面没有写 case 关键字。default
    case 对于处理那些你可能没预料到的值非常有用，可以避免写太多的 case 语句。在这个例子中，我们期望 studentGrade 只有 1 到 8 之间的值，所以我们使用
    default case 来覆盖所有其他可能的值。
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行这个 switch 语句，看看你得到什么。然后试着修改值以测试不同的条件。尽情玩耍吧！
- en: '**WHAT YOU LEARNED**'
  id: totrans-671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何编程让计算机根据条件做出选择，使用了 if 和 switch 语句。你学会了如何编写布尔表达式和复合表达式，以及不同的比较运算符。条件语句是一个非常重要的编程工具，几乎每个有用的程序中都能看到它们。在
    [第 4 章](text00014.html#ch04) 中，我们将处理另一种重要的编程语句——循环。循环告诉计算机重复执行某个操作，直到停止循环。
- en: '![image](Image00090.jpg) ![image](Image00076.jpg)'
  id: totrans-673
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00090.jpg) ![图片](Image00076.jpg)'
- en: '**BOOLEAN EXPRESSIONS**'
  id: totrans-674
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**布尔表达式**'
- en: 'A common type of Boolean expression is one that compares two values using a
    *comparison operator* . There are six comparison operators. Let’s start with two
    simple ones: *is equal* and *is not equal* .'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的布尔表达式是使用 *比较运算符* 来比较两个值。共有六种比较运算符。我们从两个简单的开始：*等于* 和 *不等于*。
- en: '**IS EQUAL AND IS NOT EQUAL**'
  id: totrans-676
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**等于与不等于**'
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 你会经常使用 *等于* 和 *不等于* 比较运算符。*等于* 用两个等号写在一起，像这样：== 。*不等于* 用一个感叹号和一个等号写，像这样：!= 。
- en: Let’s try them both out in the playground!
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 playground 中试试这两者吧！
- en: '![Image](Image00077.jpg)'
  id: totrans-679
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00077.jpg)'
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的语言来说，➊ 这一行表示，“三加二等于五”，这是一个正确的陈述，右侧窗格中的输出会在你输入完成后立即确认这一点。➋ 处的那一行表示，“三不等于五”，这也是一个正确的陈述。注意，➌
    是一个错误。你知道为什么吗？虽然 = 和 == 看起来很相似，但记住单个等号（=）用于赋值。那条语句的意思是，“把 8 的值放入名为 3 + 5 的东西中”，这显然是行不通的。
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，== 运算符也可以与其他数据类型一起使用，不仅仅是数字。让我们尝试进行一些其他的比较。
- en: '![Image](Image00078.jpg)'
  id: totrans-682
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00078.jpg)'
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行有点棘手，你期待它为真吗？这两个字符串虽然很接近，但并不完全相同，*等于* 比较只有在两个值完全匹配时才会返回真。常量 myName 的值是
    "Gloria"，其中 *G* 是大写字母，而 "gloria" 则是小写的 *g*，这两者是不一样的。
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得在[第2章](text00012.html#ch02)中我们说过不能对不同数据类型的东西使用数学运算符如+和*吗？比较运算也是一样的。你不能比较不同类型的东西。➋
    处的这一行会导致错误，因为一个是字符串，另一个是双精度浮点数。
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-685
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**大于和小于**'
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看四个其他的比较运算符。我们先从*大于*（写作 >）和*小于*（写作 <）开始。你大概已经对这些运算符的用法有了较好的了解。像 9 > 7 这样的布尔表达式，“9大于7”是对的。通常，你还想知道某个值是否大于或等于某个值，或者小于或等于某个值。还有两个运算符可以处理这些情况：*大于或等于*（写作
    >=）和*小于或等于*（写作 <=）。让我们通过一些示例来试试这些运算符：
- en: '![Image](Image00079.jpg)'
  id: totrans-687
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00079.jpg)'
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 注意*大于或等于*（➊）和*大于*（➋）之间的区别。3 + 4 的和不是大于7，但它大于或等于7。同样，5 + 6 小于或等于11（➌），但它不是小于11（➍）。
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-1](text00013.html#ch3tab1)总结了六种比较运算符。'
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-1：** 比较运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-692
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| == | Is equal to |'
  id: totrans-693
  prefs: []
  type: TYPE_TB
  zh: '| == | 等于 |'
- en: '| != | Is not equal to |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
  zh: '| != | 不等于 |'
- en: '| > | Is greater than |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
  zh: '| > | 大于 |'
- en: '| < | Is less than |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
  zh: '| < | 小于 |'
- en: '| >= | Is greater than or equal to |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
  zh: '| >= | 大于或等于 |'
- en: '| <= | Is less than or equal to |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
  zh: '| <= | 小于或等于 |'
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在编写条件语句时经常使用这些运算符。
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-700
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合布尔表达式**'
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 复合布尔表达式是由简单布尔表达式组成的，类似于英语中用*and*和*or*连接的复合句。在编程中，还有第三种情况：*not*。在Swift中，我们称这些词为*逻辑运算符*。逻辑运算符要么将一个布尔表达式与另一个布尔表达式结合，要么否定它。Swift中的三个逻辑运算符见[表3-2](text00013.html#ch3tab2)。
- en: '**Table 3-2:** Logical Operators'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-2：** 逻辑运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-703
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-704
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| && | Logical AND |'
  id: totrans-705
  prefs: []
  type: TYPE_TB
  zh: '| && | 逻辑与 |'
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
  zh: '| &#124;&#124; | 逻辑或 |'
- en: '| ! | Logical NOT |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
  zh: '| ! | 逻辑非 |'
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑运算符，你可以写出测试值是否在某个范围内的语句，例如：“这个人的年龄在10到15岁之间吗？”你可以通过测试年龄是否大于10 *并且* 小于15来实现，像这样：
- en: '![Image](Image00080.jpg)'
  id: totrans-709
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00080.jpg)'
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 语句 age > 10 && age < 15 为真，因为两个条件都为真：年龄大于10且小于15。只有当两个条件都为真时，AND语句才为真。
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将年龄的值改为18，看看会发生什么：
- en: '![Image](Image00081.jpg)'
  id: totrans-712
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00081.jpg)'
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将年龄改为18，所以语句的只有一边为真。变量年龄仍然大于10，但不再小于15，因此我们的表达式评估为假。
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过在你的操作区中输入这段代码来测试OR：
- en: '![Image](Image00082.jpg)'
  id: totrans-715
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00082.jpg)'
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过将常量名称设置为"Jacqueline"来构造一个名为Jacqueline的人物。接下来，我们测试一些条件以判断它们是对还是错。因为name
    == "Jacqueline"为真，所以即使name == "Jack"为假，➊处的OR语句依然为真。在英文中，这句话的意思是：“这个人的名字是Jack *或者*
    这个人的名字是Jacqueline。”在OR语句中，只有其中一个条件为真时，整个表达式就为真。
- en: '![image](Image00083.jpg)'
  id: totrans-717
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00083.jpg)'
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用一些NOT语句。将以下内容输入到你的操作区：
- en: '![Image](Image00084.jpg)'
  id: totrans-719
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00084.jpg)'
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '!运算符在复合布尔语句➊中使用，可以将其理解为“我们的人*不是*女孩*而且*我们的人叫Jack。”该语句包含两个逻辑运算符，!和&&。在编写复合布尔表达式时，你可以组合任意多个逻辑运算符。'
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，使用括号是个好主意，这样可以让计算机知道应该先计算什么。括号还使代码更易于阅读。这类似于在一个方程式中使用多个数学运算时使用括号，就像在 “[使用括号排序运算](text00012.html#ch02lev2sec8)”中描述的那样，见[第30页](text00012.html#page_30)。在➋处，我们使用括号告诉计算机首先检查!isAGirl
    && name == "Jack"，然后检查isAGirl && name == "Jacqueline"。当计算机计算完这两部分后，它可以评估整个语句的OR部分，这将为真，因为第二部分为真。再次强调，在OR语句中，如果任何条件为真，整个表达式就为真。
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 3-3](text00013.html#ch3tab3)展示了三种逻辑运算符和你可以用它们构造的复合表达式，以及它们对应的布尔值。'
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 3-3：** 布尔逻辑运算符的复合布尔表达式'
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-724
  prefs: []
  type: TYPE_TB
  zh: '| **逻辑运算符** | **复合表达式** | **值** |'
- en: '| --- | --- | --- |'
  id: totrans-725
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| NOT (! ) | !true | false |'
  id: totrans-726
  prefs: []
  type: TYPE_TB
  zh: '| NOT (! ) | !true | false |'
- en: '| NOT (! ) | !false | true |'
  id: totrans-727
  prefs: []
  type: TYPE_TB
  zh: '| NOT (! ) | !false | true |'
- en: '| AND (&& ) | true && true | true |'
  id: totrans-728
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | true && true | true |'
- en: '| AND (&& ) | true && false | false |'
  id: totrans-729
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | true && false | false |'
- en: '| AND (&& ) | false && true | false |'
  id: totrans-730
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | false && true | false |'
- en: '| AND (&& ) | false && false | false |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | false && false | false |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中的第一项显示，NOT true等于false。同样，NOT false等于true。
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AND运算符时，只有true && true才为真。这意味着&&运算符两边的表达式必须都为真，&&表达式才会为真。一个true && false的复合表达式将评估为假。而且，如果&&表达式两边的条件都为假，它的结果也会是假的。
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 对于OR运算符，只有在||运算符两侧的表达式中至少有一个为真时，||表达式才为真。因此，true || true为真，true || false也为真。只有当两个侧面的表达式都为假时，复合OR表达式才会为假。
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-739
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**条件语句**'
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句分为两类：if语句和switch语句。这些语句向计算机提供一个条件，计算机根据该条件做出选择。
- en: '**IF STATEMENTS**'
  id: totrans-741
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**IF语句**'
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: if语句以关键字if开头，后面跟着一个*条件*，它始终是一个布尔表达式。计算机检查该条件，如果条件为真，则执行if语句中的代码；如果条件为假，则跳过该代码。让我们编写一些代码，测试一个孩子是否足够高可以乘坐过山车。将以下代码输入到你的操作环境中：
- en: '[PRE30]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了48英寸为孩子可以独自乘坐过山车的最小身高，并将骑乘者的身高设置为49.5英寸。在➊处，我们测试骑乘者的身高是否大于或等于heightToRideAlone。如果是，程序将告诉他们足够高，可以乘坐过山车。为了编写我们的if语句，我们在条件height
    >= heightToRideAlone前面加上关键字if。然后我们将希望在该条件为真时执行的代码包裹在一对大括号中➋。因为我们的骑乘者足够高，计算机将打印“你足够高，可以乘坐这个过山车。”
- en: '![image](Image00085.jpg)'
  id: totrans-745
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00085.jpg)'
- en: Hooray!
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 欢呼！
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们改变骑乘者的身高会发生什么。将身高设置为小于48.0的数字。这次，因为if语句中的条件判断结果为false，程序跳过了if语句中的所有代码，因此没有任何反应。
- en: '**else Statements**'
  id: totrans-748
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else语句**'
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会想告诉计算机，如果某个条件为真，就做一件事；如果该条件为假，则做另一件事。为此，在if语句和代码块后面，直接输入关键字else，后跟另一个你想在if条件不成立时执行的代码块。如果骑乘者的身高不足以满足条件，我们让计算机告诉他们不能坐过山车：
- en: '[PRE31]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你将骑乘者的身高改为小于48英寸，你将看到“抱歉，您不能乘坐此过山车。”这是因为在➊处的else语句告诉计算机在条件为假时打印出该消息。用通俗的话来说，这就像是说：“如果骑乘者足够高，可以乘坐过山车，则说他们可以乘坐；否则，说他们不能乘坐。”
- en: '**else if Statements**'
  id: totrans-752
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else if语句**'
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试骑乘者身高的不同条件，创建更多的过山车乘坐规则。我们可以通过添加else if条件来实现这一点。让我们增加一个新的最小身高要求，规定孩子必须与成人一起乘坐：
- en: '[PRE32]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的else if语句检查骑乘者的身高是否大于或等于heightToRideWithAdult。如果骑乘者的身高在48英寸以下但高于36英寸，那么结果面板中会显示“你可以和成年人一起坐这列过山车。”如果他们的身高不足以单独乘坐或与成年人一起乘坐，计算机会打印“抱歉，你不能坐这列过山车。”
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: else if语句很有用，因为你可以用它来测试多个不同的条件，但非常重要的一点是，你要注意这些条件的顺序。为了说明我们的意思，将骑乘者的身高改为50.0，使其足够高可以独自乘坐过山车。然后，通过将height
    >= heightToRideWithAdult作为第一个条件，height >= heightToRideAlone作为第二个条件，改变我们if else语句中条件的顺序。你认为会打印什么结果？查看[图3-1](text00013.html#ch03fig1)以了解答案。
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-757
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00086.jpg)![image](Image00087.jpg)'
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-1：小心else if语句的顺序。*'
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，尽管骑乘者的身高高于heightToRideAlone，但程序仍然输出“你可以和成年人一起坐这列过山车。”这是对于身高大于heightToRideWithAdult但小于heightToRideAlone的骑乘者的预期输出。我们得到这个结果是因为骑乘者的身高符合第一个条件，因此计算机打印了第一句话，而没有继续检查其他条件。
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦if或else if语句中的某个条件为真，其他条件就不会再被检查。在我们[图3-1](text00013.html#ch03fig1)的例子中，第一个条件为真，因此其后的条件会被跳过。这可能会导致程序出现意料之外的结果，所以如果你在if或else
    if语句中遇到问题，请检查条件的顺序！
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用if、else或else if语句时，有一些重要规则。首先，你不能在没有先写if语句的情况下使用else或else if语句。第二，虽然你可以在if语句后使用任意数量的else
    if语句，但只能有一个else，并且这个else必须放在最后。else是一个兜底条件，表示如果其他条件都不成立时的处理。
- en: '**CODE WITH STYLE**'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '**编程风格**'
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 请特别注意本书中使用的编程风格。我们所说的*编程风格*，指的是代码书写的方式、空格的使用、某些行的缩进，以及哪些内容放在新的一行。请看这段代码：
- en: '[PRE33]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在if条件后我们留一个空格，然后在同一行上放置开括号{。块的闭括号}总是放在下一行的开头。括号内的语句需要缩进四个空格。这是Xcode自动为您完成的操作，以提高代码的可读性。如果觉得更容易阅读，可以随意添加空行。通常，在像if语句这样的代码块之前，应该始终至少留一行空白行。
- en: '![image](Image00088.jpg)'
  id: totrans-766
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00088.jpg)'
- en: '**SWITCH STATEMENTS**'
  id: totrans-767
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**SWITCH语句**'
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 与if语句仅用于评估布尔表达式（必须为真或假的某种表达式）不同，switch语句可以评估并根据多个条件进行分支。您可以使用switch来检查一个整数的值，并指示计算机如果该整数等于1就做某件事，等于2就做另一件事，依此类推。或者，您可以创建一个名为dayOfTheWeek的字符串，并编写一个switch语句，根据dayOfTheWeek的值使计算机做出不同的操作。
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机找到第一个匹配项时，该代码块就会被执行。看一下下面的代码，它为不同年级的学生分配项目：
- en: '[PRE34]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: switch语句以关键字switch开头，后跟*控制表达式*。在这个例子中，控制表达式是变量studentGrade。
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 控制表达式后，一对大括号从➊开始，switch语句的主体位于这些大括号内。
- en: '![Image](Image00089.jpg)'
  id: totrans-773
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00089.jpg)'
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: switch语句的主体由一个或多个case组成。在这个例子中，总共有六个case。每个case以关键字case开头，后跟一个值和一个冒号，如➋所示。如果case语句匹配控制表达式，紧接着case的代码就会执行。每个case必须至少包含一行代码，否则会报错。在这个例子中，switch语句用于将字符串studentProject的值从"待定"更改为匹配控制表达式的case中的字符串。
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以让多个case执行相同的操作。您可以看到，6、7和8年级的学生都可以选择自己的项目➌。我们通过写下关键字case，然后列出一个用逗号分隔的值来指定这一点。
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，switch语句必须考虑控制表达式的所有可能情况或值。在我们的示例中，由于studentGrade是一个Int类型，我们的switch语句需要为所有可能的Int值编写case。但这样写起来会非常冗长，因为可能的值太多了！例如，–7是一个Int类型，1000也是一个Int类型。您真的想写1000个case吗？
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 与其为每个值编写单独的`case`，不如使用关键字`default`作为最后的`case`，就像我们在➍中所做的那样。你只需输入`default`后跟一个冒号（default:），然后编写你希望在其他`case`都不匹配时执行的代码。注意，`default`的`case`前面没有`case`这个词。`default`语句非常有用，可以处理那些你可能没有预料到的值，并且避免了写很多`case`语句。在这个示例中，我们只期望`studentGrade`的值为1到8之间的数字，因此我们使用`default`语句来覆盖所有其他可能的值。
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行这个`switch`语句，看看你得到什么。然后尝试更改值来测试不同的条件。尽情玩吧！
- en: '**WHAT YOU LEARNED**'
  id: totrans-779
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何通过使用`if`和`switch`语句编写程序，让计算机根据条件做出选择。你学习了如何编写布尔表达式和复合表达式，以及不同的比较运算符。条件语句是一个基本的编程工具，几乎所有有用的程序中都会出现。在[第4章](text00014.html#ch04)，我们将介绍另一种重要的编程语句——循环。循环指示计算机反复执行某个任务，直到该停止循环的时候。
- en: '![image](Image00090.jpg)'
  id: totrans-781
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00090.jpg)'
- en: '**BOOLEAN EXPRESSIONS**'
  id: totrans-782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**布尔表达式**'
- en: 'A common type of Boolean expression is one that compares two values using a
    *comparison operator* . There are six comparison operators. Let’s start with two
    simple ones: *is equal* and *is not equal* .'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的布尔表达式类型是使用*比较运算符*比较两个值。有六种比较运算符。我们从两个简单的开始：`is equal`和`is not equal`。
- en: '**IS EQUAL AND IS NOT EQUAL**'
  id: totrans-784
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**相等与不相等**'
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会经常使用`is equal`和`is not equal`比较运算符。`is equal`用两个等号写成，像这样：`==`。`is not equal`用一个感叹号和一个等号写成，像这样：`!=`。
- en: Let’s try them both out in the playground!
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在游乐场中试试这两者吧！
- en: '![Image](Image00077.jpg)'
  id: totrans-787
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00077.jpg)'
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的英语来说，➊这一行的意思是，“三加二等于五”，这是一个真实的陈述，右侧面板的输出会在你输入完成后确认这一点。在➋，这一行说，“三不等于五”，这也是一个真实的陈述。注意，➌是一个错误。你知道为什么吗？虽然`=`和`==`看起来很像，但记住，单个等号（`=`）用于赋值。那条语句的意思是，“把值8赋给一个叫做3
    + 5的东西”，这是行不通的。
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，`==`运算符不仅适用于数字，还可以用于其他数据类型。让我们尝试进行一些其他的比较。
- en: '![Image](Image00078.jpg)'
  id: totrans-790
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00078.jpg)'
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: ➊那一行很棘手；你期待它为真吗？这两个字符串相似但并不完全相同，`is equal`的比较只有在两个值完全相同的情况下才为真。常量`myName`的值是"Gloria"，首字母是大写的*G*，这与"gloria"（小写的*g*）是不一样的。
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在 [第二章](text00012.html#ch02) 中我们提到过，你不能对不同数据类型的变量使用数学运算符如 + 和 * 吗？比较也是如此。你不能比较不同类型的东西。➋
    这一行会引发错误，因为一个是字符串（String），另一个是双精度浮点数（Double）。
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-793
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**大于与小于**'
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看四个其他的比较运算符。我们从 *大于*（写作 >）和 *小于*（写作 <）开始。你可能已经对这些有了一个大致的了解。像 9 > 7 这样的布尔表达式，“9
    大于 7”是正确的。通常，你还想知道某个值是否大于或等于某个值，或者小于或等于某个值。还有两个运算符可以覆盖这些情况：*大于或等于*（写作 >=）和 *小于或等于*（写作
    <=）。让我们通过一些例子来试试这些运算符：
- en: '![Image](Image00079.jpg)'
  id: totrans-795
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00079.jpg)'
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 *大于或等于* ➊ 与 *大于* ➋ 的区别。3 + 4 的和不大于 7，但它大于或等于 7。同样，5 + 6 小于或等于 11 ➌，但它不小于
    11 ➍。
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '[Table 3-1](text00013.html#ch3tab1) 总结了六种比较运算符。'
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '**Table 3-1:** 比较运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-799
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-800
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| == | Is equal to |'
  id: totrans-801
  prefs: []
  type: TYPE_TB
  zh: '| == | 等于 |'
- en: '| != | Is not equal to |'
  id: totrans-802
  prefs: []
  type: TYPE_TB
  zh: '| != | 不等于 |'
- en: '| > | Is greater than |'
  id: totrans-803
  prefs: []
  type: TYPE_TB
  zh: '| > | 大于 |'
- en: '| < | Is less than |'
  id: totrans-804
  prefs: []
  type: TYPE_TB
  zh: '| < | 小于 |'
- en: '| >= | Is greater than or equal to |'
  id: totrans-805
  prefs: []
  type: TYPE_TB
  zh: '| >= | 大于或等于 |'
- en: '| <= | Is less than or equal to |'
  id: totrans-806
  prefs: []
  type: TYPE_TB
  zh: '| <= | 小于或等于 |'
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写条件语句时，你会经常使用这些运算符。
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-808
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合布尔表达式**'
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 复合布尔表达式是将简单布尔表达式连接起来的表达式。它很像用 *and* 和 *or* 这样的词构成复合句。在编程中，还有第三种情况：*not*。在 Swift
    中，我们称这些词为 *逻辑运算符*。逻辑运算符要么将布尔表达式与另一个表达式结合，要么取反它。Swift 中的三种逻辑运算符如下表 [Table 3-2](text00013.html#ch3tab2)
    所示。
- en: '**Table 3-2:** Logical Operators'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '**Table 3-2:** 逻辑运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-811
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-812
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| && | Logical AND |'
  id: totrans-813
  prefs: []
  type: TYPE_TB
  zh: '| && | 逻辑与 |'
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-814
  prefs: []
  type: TYPE_TB
  zh: '| &#124;&#124; | 逻辑或 |'
- en: '| ! | Logical NOT |'
  id: totrans-815
  prefs: []
  type: TYPE_TB
  zh: '| ! | 逻辑非 |'
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑运算符，你可以编写语句，测试某个值是否在一个范围内，比如，“这个人的年龄是否在 10 到 15 之间？”你可以通过测试 age 是否大于 10
    *且* 小于 15 来同时判断，像这样：
- en: '![Image](Image00080.jpg)'
  id: totrans-817
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00080.jpg)'
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 语句 age > 10 && age < 15 为真，因为两个条件都为真：age 大于 10 且小于 15。只有当两个条件都为真时，AND 语句才为真。
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将 age 的值改为 18，看看会发生什么：
- en: '![Image](Image00081.jpg)'
  id: totrans-820
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00081.jpg)'
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将 age 改为 18，只有一侧的条件为真。变量 age 仍然大于 10，但不再小于 15，所以我们的表达式的值为 false。
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过在你的游乐场中输入以下代码来测试 OR：
- en: '![Image](Image00082.jpg)'
  id: totrans-823
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00082.jpg)'
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过将常量 name 设置为 "Jacqueline" 来构造一个名为 Jacqueline 的人。接下来，我们测试一些条件，看看它们是 true
    还是 false。由于 name == "Jacqueline" 为真，➊ 处的 OR 语句为真，即使 name == "Jack" 为假。在英语中，这个语句表示：“这个人的名字是
    Jack *或* 这个人的名字是 Jacqueline。”在 OR 语句中，只要一个条件为真，整个表达式就为真。
- en: '![image](Image00083.jpg)'
  id: totrans-825
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00083.jpg)'
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些 NOT 语句。请输入以下内容到你的游乐场：
- en: '![Image](Image00084.jpg)'
  id: totrans-827
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00084.jpg)'
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '! 操作符用于复合布尔语句 ➊ ，你可以将其理解为“我们的人是*不是*女孩*并且*我们的人叫杰克”。该语句包含两个逻辑操作符，! 和 &&。你可以根据需要将多个逻辑操作符组合在一起，编写复合布尔表达式。'
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，使用括号是个好主意，这样可以让计算机知道先评估什么。括号还可以让代码更易读。这类似于你在一个方程中使用多个数学运算时，所使用的括号，就像在[“使用括号排序运算”（[Ordering
    Operations with Parentheses](text00012.html#ch02lev2sec8)）](text00012.html#page_30)中描述的那样。在
    ➋ 处，我们使用括号告诉计算机首先检查 !isAGirl && name == "Jack"，然后再检查 isAGirl && name == "Jacqueline"。在评估了两个部分后，计算机可以评估整个语句的
    OR 部分，结果为真，因为第二部分为真。同样，在 OR 语句中，如果任何条件为真，整个表达式就为真。
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-3](text00013.html#ch3tab3) 显示了三种逻辑操作符以及你可以使用它们组合的复合表达式，并给出了它们对应的布尔值。'
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-3：** 布尔逻辑运算符与复合布尔表达式'
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-832
  prefs: []
  type: TYPE_TB
  zh: '| **逻辑操作符** | **复合表达式** | **值** |'
- en: '| --- | --- | --- |'
  id: totrans-833
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| NOT (! ) | !true | false |'
  id: totrans-834
  prefs: []
  type: TYPE_TB
  zh: '| NOT (! ) | !true | false |'
- en: '| NOT (! ) | !false | true |'
  id: totrans-835
  prefs: []
  type: TYPE_TB
  zh: '| NOT (! ) | !false | true |'
- en: '| AND (&& ) | true && true | true |'
  id: totrans-836
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | true && true | true |'
- en: '| AND (&& ) | true && false | false |'
  id: totrans-837
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | true && false | false |'
- en: '| AND (&& ) | false && true | false |'
  id: totrans-838
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | false && true | false |'
- en: '| AND (&& ) | false && false | false |'
  id: totrans-839
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | false && false | false |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-840
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-841
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-842
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-843
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中的第一项显示，不是真的东西为假。同样，假的东西不是真的为真。
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AND 操作符时，只有 true && true 的结果才为真。这意味着 && 操作符两侧的表达式必须都为真，&& 表达式才为真。一个 true
    && false 的复合表达式会评估为假。而一个两个条件都为假的复合 && 表达式也会评估为假。
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`OR`操作符，只要`||`操作符两边的任一表达式为真，整个`||`表达式就为真。因此，`true || true`为真，`true || false`也为真。只有在两个表达式都为假时，复合的`OR`表达式才会为假。
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-847
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**条件语句**'
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句分为两类：`if`语句和`switch`语句。这些语句向计算机提供一个条件，计算机会根据该条件做出选择。
- en: '**IF STATEMENTS**'
  id: totrans-849
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**IF 语句**'
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句以关键字`if`开头，后面跟着一个*条件*，这个条件通常是一个布尔表达式。计算机会检查这个条件，如果条件为真，就执行`if`语句中的代码；如果条件为假，则跳过这些代码。让我们编写一些代码来测试孩子是否足够高，能够骑过山车。请将以下代码输入到你的编程环境中：'
- en: '[PRE35]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将48英寸设置为孩子单独骑过山车的最低身高，并将骑乘者的身高设置为49.5英寸。在➊处，我们测试骑乘者的身高是否大于或等于`heightToRideAlone`。如果是，程序就会说他们足够高，能够骑过山车。为了编写我们的`if`语句，我们在条件`height
    >= heightToRideAlone`前加上`if`关键字。然后，我们将当该条件为真时希望执行的代码包裹在一对大括号➋中。因为我们的骑乘者足够高，计算机会打印“你足够高，能够骑这个过山车。”
- en: '![image](Image00085.jpg)'
  id: totrans-853
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00085.jpg)'
- en: Hooray!
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 万岁！
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果改变骑乘者的身高会发生什么。将身高改为小于48.0的数字。这一次，因为`if`语句中的条件为假，程序会跳过`if`语句中的所有代码，什么也不会发生。
- en: '**else Statements**'
  id: totrans-856
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else 语句**'
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你需要告诉计算机在语句为真时做一件事，而在语句为假时做另一件事。为了实现这一点，在`if`语句和代码块后，输入关键字`else`，后面跟着你希望在`if`条件为假时执行的另一块代码。如果骑乘者的身高不足以满足条件，我们可以让计算机告诉他们不能骑过山车：
- en: '[PRE36]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你将骑乘者的身高改为低于48英寸，你会看到“抱歉，你不能骑这个过山车。”这是因为在➊处的`else`语句告诉计算机，如果条件为假，就打印出这个消息。用简单的语言来说，这就像是在说：“如果骑乘者足够高，能骑过山车，就说他们能骑；否则，就说他们不能骑。”
- en: '**else if Statements**'
  id: totrans-860
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else if 语句**'
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试不同的条件来根据骑乘者的身高创建更多的过山车骑行规则。我们可以通过添加`else if`条件来实现这一点。让我们添加一个新的最低身高要求，规定孩子必须和成人一起骑乘：
- en: '[PRE37]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的 `else if` 语句检查骑行者的身高是否大于或等于 `heightToRideWithAdult`。如果骑行者的身高在 36 英寸到 48
    英寸之间，则结果面板会显示 "You can ride this roller coaster with an adult." 如果身高太矮，既不能单独骑行，也不能与成人一起骑行，则计算机会打印出
    "Sorry. You cannot ride this roller coaster."
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '`else if` 语句很有条理，因为你可以用它们来测试许多不同的条件，但非常重要的一点是你必须注意这些条件的顺序。为了说明我们的意思，将骑行者的身高改为
    50.0，使其足够高以便独自骑行。然后，通过将 `height >= heightToRideWithAdult` 作为第一个条件，将 `height >=
    heightToRideAlone` 作为第二个条件，来改变我们 `if else` 语句中条件的顺序。你认为会打印出什么？查看 [图 3-1](text00013.html#ch03fig1)
    来找出答案。'
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-865
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00086.jpg)![image](Image00087.jpg)'
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1: 注意 `else if` 语句的顺序。*'
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，尽管骑行者的身高大于 `heightToRideAlone`，程序仍然打印出 "You can ride this roller coaster
    with an adult." 这是因为对于一个身高大于 `heightToRideWithAdult` 但小于 `heightToRideAlone` 的骑行者来说，这是预期的输出。我们得到这个结果是因为骑行者的身高符合第一个条件，所以计算机打印了第一行并跳过了其他条件。
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `if` 或 `else if` 语句的某个部分被判断为真，剩下的条件将不会被检查。在我们在 [图 3-1](text00013.html#ch03fig1)
    中的示例中，第一个条件为真，因此其余条件被跳过。这可能会导致你的程序出现意外结果，所以如果你在 `if` 或 `else if` 语句中遇到问题，请检查条件的顺序！
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在处理 `if`、`else` 或 `else if` 语句时，有一些重要的规则。第一个规则是，除非先写一个 `if` 语句，否则不能有 `else`
    或 `else if` 语句。第二个规则是，尽管你可以在一个 `if` 后面有任意数量的 `else if`，但只能有一个 `else`，并且这个 `else`
    必须放在最后。`else` 是一个用于捕捉所有其他情况的默认语句，当没有其他条件满足时会执行。
- en: '**CODE WITH STYLE**'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '**优雅的代码**'
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 请密切关注我们在本书中使用的编码风格。所谓 *编码风格*，指的是代码的写作方式，使用的空格数，某些行的缩进以及哪些内容应该写在新的一行。来看一下这段代码：
- en: '[PRE38]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在if条件之后，我们留出一个空格，然后将左花括号{放在同一行上。代码块的右花括号}始终位于下一行的开头。花括号中的语句缩进四个空格。这是Xcode自动为你做的，以提高代码的可读性。如果这样做让你更容易阅读，可以随意添加空行。通常，应该在代码块之前至少留一行空白行，例如if语句之前。
- en: '![image](Image00088.jpg)'
  id: totrans-874
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00088.jpg)'
- en: '**SWITCH STATEMENTS**'
  id: totrans-875
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**SWITCH 语句**'
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 与if语句只用于评估布尔表达式（必须为真或假的东西）不同，switch语句可以评估并根据任意数量的条件进行分支。你可以使用switch来检查一个整数的值，并告诉计算机如果整数等于1就做某事，如果整数等于2就做另一件事，依此类推。或者，你可以创建一个名为dayOfTheWeek的字符串，并编写一个switch语句，使计算机根据dayOfTheWeek的值执行不同的操作。
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机找到第一个匹配项时，那个代码块会被执行。看看以下代码，它为不同年级的学生分配项目：
- en: '[PRE39]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: switch语句以关键字switch开头，后跟*控制表达式*。在这个例子中，控制表达式是变量studentGrade。
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制表达式之后，花括号从➊开始，switch语句的主体位于这些花括号内部。
- en: '![Image](Image00089.jpg)'
  id: totrans-881
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00089.jpg)'
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: switch语句的主体由一个或多个case组成。在这个例子中，共有六个case。每个case都以关键字case开头，后跟一个值和一个冒号，如➋所示。如果某个case语句匹配控制表达式，紧跟在该case后的代码就会执行。每个case必须至少有一行代码，否则会报错。在这个例子中，switch用于将分配给变量studentProject的字符串从“To
    be determined”更改为与控制表达式匹配的case中的字符串。
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以让多个case执行相同的操作。你可以看到，6年级、7年级和8年级的学生都可以选择自己的项目➌。我们通过写下关键字case，然后列出一个逗号分隔的值列表来指定这一点。
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，switch语句必须考虑控制表达式的所有可能case或值。在我们的例子中，由于studentGrade是一个Int类型，switch语句需要为所有可能的Int值提供case。但是这会写得非常长，因为有很多可能的值！例如，–7是一个Int，1000也是一个Int。你真的想写1000个case吗？
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 不必为每个值写一个单独的 case，你可以使用关键字 default 作为最后一个 case，就像我们在 ➍ 处所做的那样。你只需键入 default
    后跟冒号（default:），然后编写如果其他 case 不匹配时要执行的代码。注意，default case 前面没有加上 case 关键字。默认 case
    对处理那些你可能没有预料到的值非常有用，可以避免写太多的 case 语句。在这个例子中，我们只期望 studentGrade 的值在 1 到 8 之间，因此我们使用
    default case 来覆盖所有其他可能的值。
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行这个 switch 语句，看看你得到什么结果。然后尝试更改值来测试不同的条件。动手试试吧！
- en: '**WHAT YOU LEARNED**'
  id: totrans-887
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用 if 和 switch 语句让计算机根据条件做出选择。你学习了如何编写布尔表达式和复合表达式，并了解了不同的比较操作符。条件语句是编程中的一项基本工具，几乎每个有用的程序中都会看到它们。在
    [第 4 章](text00014.html#ch04) 中，我们将探讨另一种重要的编程语句——循环。循环告诉计算机重复做某件事，直到停止循环的条件满足为止。
- en: '![image](Image00090.jpg)'
  id: totrans-889
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00090.jpg)'
- en: 'A common type of Boolean expression is one that compares two values using a
    *comparison operator* . There are six comparison operators. Let’s start with two
    simple ones: *is equal* and *is not equal* .'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的布尔表达式是使用 *比较操作符* 比较两个值的表达式。比较操作符共有六种。让我们从两个简单的开始：*相等* 和 *不相等*。
- en: '**IS EQUAL AND IS NOT EQUAL**'
  id: totrans-891
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**相等与不相等**'
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 你将经常使用 *相等* 和 *不相等* 比较操作符。*相等* 使用两个等号连在一起表示，如：==。*不相等* 使用一个感叹号和一个等号表示，如：!=。
- en: Let’s try them both out in the playground!
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 playground 中试试这两个操作！
- en: '![Image](Image00077.jpg)'
  id: totrans-894
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00077.jpg)'
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的英语来说，➊ 处的这一行表示“3 加 2 等于 5”，这是一个正确的陈述，当你输入完后，右侧面板将会确认这一点。➋ 处的这一行表示“3 不等于
    5”，这也是一个正确的陈述。注意，➌ 处是一个错误。你知道为什么吗？虽然 = 和 == 看起来很相似，但记住单个等号（=）是用来赋值的。那条语句的意思是：“把
    8 的值放入一个名为 3 + 5 的东西”，这是不成立的。
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，== 操作符不仅适用于数字，也适用于其他数据类型。让我们试试做一些其他的比较。
- en: '![Image](Image00078.jpg)'
  id: totrans-897
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00078.jpg)'
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的这一行是一个难点；你是否认为它为真？这两条字符串很相似，但并不完全相同，*相等*比较只有在两个值完全匹配时才会返回真。常量 myName 的值是
    "Gloria"，首字母为大写 *G*，这与 "gloria"（首字母小写 *g*）不同。
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得在[第2章](text00012.html#ch02)中我们说过，你不能对不同数据类型的东西使用数学运算符，如 + 和 * 吗？对于比较也是一样的。你不能比较不同类型的东西。➋处的代码会引发错误，因为一个是字符串（String），另一个是双精度浮点数（Double）。
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-900
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**大于和小于**'
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看另外四个比较运算符。我们先从*大于*（写作 >）和*小于*（写作 <）开始。你可能已经对它们的工作原理有了不错的理解。像 9 > 7 这样的布尔表达式，意思是“9大于7”，结果为真。通常，你还会想知道某个值是否大于或等于某个值，或者是否小于或等于某个值。还有两个运算符可以覆盖这些情况：*大于或等于*（写作
    >=）和*小于或等于*（写作 <=）。让我们通过一些例子来试试这些：
- en: '![Image](Image00079.jpg)'
  id: totrans-902
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00079.jpg)'
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意➊处的*大于或等于*与➋处的*大于*之间的区别。3 + 4 的和不是大于7，但它大于或等于7。同样，5 + 6 小于或等于11 ➌，但它不小于11
    ➍。
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '[表3-1](text00013.html#ch3tab1)总结了六个比较运算符。'
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-1：** 比较运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-906
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-907
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| == | Is equal to |'
  id: totrans-908
  prefs: []
  type: TYPE_TB
  zh: '| == | 等于 |'
- en: '| != | Is not equal to |'
  id: totrans-909
  prefs: []
  type: TYPE_TB
  zh: '| != | 不等于 |'
- en: '| > | Is greater than |'
  id: totrans-910
  prefs: []
  type: TYPE_TB
  zh: '| > | 大于 |'
- en: '| < | Is less than |'
  id: totrans-911
  prefs: []
  type: TYPE_TB
  zh: '| < | 小于 |'
- en: '| >= | Is greater than or equal to |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
  zh: '| >= | 大于或等于 |'
- en: '| <= | Is less than or equal to |'
  id: totrans-913
  prefs: []
  type: TYPE_TB
  zh: '| <= | 小于或等于 |'
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写条件语句时，你会经常使用这些运算符。
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-915
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合布尔表达式**'
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 复合布尔表达式是由多个简单的布尔表达式组合而成的。这就像用英语中的“and”和“or”连接复合句一样。在编程中，还有第三种情况：*not*。在Swift中，我们称这些为*逻辑运算符*。逻辑运算符要么将一个布尔表达式与另一个表达式结合，要么对其取反。Swift中的三个逻辑运算符如[表3-2](text00013.html#ch3tab2)所示。
- en: '**Table 3-2:** Logical Operators'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-2：** 逻辑运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-918
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-919
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| && | Logical AND |'
  id: totrans-920
  prefs: []
  type: TYPE_TB
  zh: '| && | 逻辑与 |'
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-921
  prefs: []
  type: TYPE_TB
  zh: '| &#124;&#124; | 逻辑或 |'
- en: '| ! | Logical NOT |'
  id: totrans-922
  prefs: []
  type: TYPE_TB
  zh: '| ! | 逻辑非 |'
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑运算符，你可以编写判断某个值是否落在某个范围内的语句，例如，“这个人的年龄是否介于10到15岁之间？”你可以通过同时测试年龄是否大于10*并*小于15来实现，例如这样：
- en: '![Image](Image00080.jpg)'
  id: totrans-924
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00080.jpg)'
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 语句 age > 10 && age < 15 为真，因为两个条件都为真：年龄大于10并且小于15。与（AND）语句仅在两个条件都为真时才为真。
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将年龄（age）的值改为18，看看会发生什么：
- en: '![Image](Image00081.jpg)'
  id: totrans-927
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00081.jpg)'
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将年龄改为18，只有一边的条件成立。变量年龄仍然大于10，但不再小于15，因此我们的表达式计算结果为假（false）。
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过在你的练习场中输入以下代码来测试 OR：
- en: '![Image](Image00082.jpg)'
  id: totrans-930
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00082.jpg)'
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过将常量 name 设置为“Jacqueline”来创造一个名叫 Jacqueline 的人。接着，我们测试一些条件，看看它们是对还是错。因为
    name == "Jacqueline" 为真，所以即使 name == "Jack" 为假，在 ➊ 处的 OR 语句也是对的。在英文中，这个语句表示：“这个人叫
    Jack *或者* 这个人叫 Jacqueline。”在 OR 语句中，只要一个条件为真，整个表达式就为真。
- en: '![image](Image00083.jpg)'
  id: totrans-932
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00083.jpg)'
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着使用一些 NOT 语句。将以下内容输入到你的练习场中：
- en: '![Image](Image00084.jpg)'
  id: totrans-934
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00084.jpg)'
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '! 运算符在复合布尔语句 ➊ 中被使用，你可以将其解读为“我们的人 *不是* 一个女孩 *并且* 我们的人叫 Jack”。该语句有两个逻辑运算符，!
    和 &&。在编写复合布尔表达式时，你可以组合任意多的逻辑运算符。'
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，使用括号来告诉计算机优先评估哪个部分是一个好主意。括号还可以让代码更容易阅读。这类似于你在一个方程式中使用多个数学运算时使用括号的方式，正如在[《使用括号来排序运算》](text00012.html#ch02lev2sec8)中所描述的那样，位于[第30页](text00012.html#page_30)。在
    ➋ 处，我们使用括号来告诉计算机首先检查 !isAGirl && name == "Jack"，然后检查 isAGirl && name == "Jacqueline"。在评估完这两个部分之后，计算机可以评估整个语句的
    OR 部分，因为第二部分为真。所以在 OR 语句中，如果任何条件为真，整个表达式就为真。
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-3](text00013.html#ch3tab3) 显示了三种逻辑运算符以及你可以用它们创建的复合表达式，并给出了它们对应的布尔值。'
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-3：** 带逻辑运算符的复合布尔表达式'
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-939
  prefs: []
  type: TYPE_TB
  zh: '| **逻辑运算符** | **复合表达式** | **值** |'
- en: '| --- | --- | --- |'
  id: totrans-940
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| NOT (! ) | !true | false |'
  id: totrans-941
  prefs: []
  type: TYPE_TB
  zh: '| NOT (! ) | !true | false |'
- en: '| NOT (! ) | !false | true |'
  id: totrans-942
  prefs: []
  type: TYPE_TB
  zh: '| NOT (! ) | !false | true |'
- en: '| AND (&& ) | true && true | true |'
  id: totrans-943
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | true && true | true |'
- en: '| AND (&& ) | true && false | false |'
  id: totrans-944
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | true && false | false |'
- en: '| AND (&& ) | false && true | false |'
  id: totrans-945
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | false && true | false |'
- en: '| AND (&& ) | false && false | false |'
  id: totrans-946
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | false && false | false |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-947
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-948
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-949
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-950
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中的第一个项目表明，某些东西如果 *不是* 真，那么它就是假。类似地，某些东西如果 *不是* 假，那么它就是对的。
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AND 运算符时，只有 true && true 才为真。这意味着 && 运算符两侧的表达式都必须为真，&& 表达式才会为真。一个 true &&
    false 的复合表达式会评估为假。而且，一个两边条件都是假的复合 && 表达式也会评估为假。
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 OR 运算符时，只有在 || 运算符两侧的表达式中至少有一个为真，整个 || 表达式才为真。因此，true || true 为真，true ||
    false 也为真。只有当两个表达式都为假时，复合 OR 表达式才会为假。
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-954
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**条件语句**'
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句分为两类：if 语句和 switch 语句。这些语句为计算机提供一个条件，计算机根据该条件做出选择。
- en: '**IF STATEMENTS**'
  id: totrans-956
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**IF 语句**'
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: if 语句以关键字 if 开头，后面跟着一个 *条件*，这个条件总是一个布尔表达式。计算机会检查该条件，如果条件为真，则执行 if 语句中的代码，如果条件为假，则跳过这些代码。让我们编写一些代码来测试一个孩子是否足够高，可以乘坐过山车。将以下代码输入到你的
    Playground 中：
- en: '[PRE40]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 48 英寸设置为孩子可以独自乘坐过山车的最小身高，并将骑行者的身高设置为 49.5 英寸。在 ➊ 处，我们测试骑行者的身高是否大于或等于
    heightToRideAlone。如果是，程序会说他们足够高可以乘坐过山车。为了编写我们的 if 语句，我们在条件 height >= heightToRideAlone
    前面加上关键字 if，然后将我们希望在该条件为真时执行的代码包裹在一对大括号 ➋ 中。由于我们的骑行者足够高，计算机会打印 "你足够高可以乘坐这个过山车"。
- en: '![image](Image00085.jpg)'
  id: totrans-960
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00085.jpg)'
- en: Hooray!
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 万岁！
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们改变骑行者的身高会发生什么。将身高改为小于 48.0 的数字。这时，由于 if 语句中的条件计算结果为假，程序会跳过 if 语句中的所有代码，什么都不会发生。
- en: '**else Statements**'
  id: totrans-963
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else 语句**'
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会希望在条件为真时让计算机做一件事，而在条件为假时做另一件事。为此，在 if 语句和代码块之后，只需键入关键字 else，并跟上你希望在 if
    条件不成立时执行的另一个代码块。如果骑行者的身高不符合条件，我们可以让计算机告诉他们不能乘坐过山车：
- en: '[PRE41]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你将骑行者的身高改为小于 48 英寸，你会看到 "抱歉，您不能乘坐这个过山车。" 这是因为 ➊ 处的 else 语句告诉计算机在条件计算结果为假时打印这个消息。用通俗的语言来说，这就像是在说：“如果骑行者足够高可以乘坐过山车，那么就说他们可以坐；否则，就说他们不能坐。”
- en: '**else if Statements**'
  id: totrans-967
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else if 语句**'
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试骑行者身高的不同条件，以为乘坐过山车制定更多规则。我们可以通过添加 else if 条件来实现这一点。让我们添加一个新的最小身高要求，要求孩子和成人一起乘坐：
- en: '[PRE42]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: '➊处的else if语句检查骑乘者的身高是否大于或等于heightToRideWithAdult。如果骑乘者的身高低于48英寸但高于36英寸，那么结果面板中会出现"您可以与成年人一起乘坐这列过山车。"如果身高过矮，无法单独或与成年人一起乘坐，则计算机会打印"抱歉，您不能乘坐这列过山车。"  '
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 'else if语句很整洁，因为你可以用它来测试许多不同的条件，但非常重要的一点是，你必须注意这些条件的顺序。为了向你展示我们的意思，将骑乘者的身高改为50.0，使他们足够高，可以单独乘坐。然后，通过将height
    >= heightToRideWithAdult条件放在第一个，height >= heightToRideAlone条件放在第二个，改变我们if else语句中的条件顺序。你认为会打印什么？查看[图3-1](text00013.html#ch03fig1)以了解答案。  '
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-972
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00086.jpg)![image](Image00087.jpg)'
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-1：小心else if语句的顺序。*  '
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，尽管骑乘者的身高高于heightToRideAlone，但程序仍然打印"您可以与成年人一起乘坐这列过山车。"这正是对于身高大于heightToRideWithAdult但小于heightToRideAlone的骑乘者预期的输出。我们得到这个结果是因为骑乘者的身高符合第一个条件，因此计算机打印了第一句话，并且不再检查其他条件。  '
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦if或else if语句中的某个条件为真，其他条件就不会被检查。在[图3-1](text00013.html#ch03fig1)的示例中，第一个条件为真，因此跳过了剩余的条件。这可能导致程序中的意外结果，因此如果你在使用if或else
    if语句时遇到问题，检查条件的顺序吧！  '
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: '当你使用if、else或else if语句时，有一些重要的规则。第一个规则是，除非你先写一个if语句，否则不能有else或else if语句。第二个规则是，虽然在if语句后可以有任意多个else
    if语句，但只能有一个else——而且else必须放在最后。else是一个“兜底”的情况，当其他条件都不满足时会执行它。  '
- en: '**CODE WITH STYLE**'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码风格**  '
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '请密切注意我们在本书中使用的编码风格。所谓*编码风格*，指的是代码书写的方式、使用的空格数、某些行的缩进，以及哪些内容应该另起一行。看一下这段代码：  '
- en: '[PRE43]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在if条件后，我们在同一行留一个空格，然后放上左花括号“{”。代码块的右花括号“}”总是放在下一行的开头。花括号内的语句缩进四个空格。这是Xcode为你自动处理的，使代码更加易读。如果这样做让你更容易阅读，也可以添加空行。通常，在写if语句等代码块之前，你应该至少有一行空行。
- en: '![image](Image00088.jpg)'
  id: totrans-981
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00088.jpg)'
- en: '**SWITCH STATEMENTS**'
  id: totrans-982
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**SWITCH语句**'
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语句仅用于评估布尔表达式（必须为真或假的某种情况），那么if语句就是用来做这个的；而switch语句可以评估并根据多个条件进行分支。你可以使用switch来检查一个整数的值，并告诉计算机，如果整数等于1就做一件事，等于2就做另一件事，依此类推。或者，你可以创建一个叫做dayOfTheWeek的字符串，并写一个switch语句，让计算机根据dayOfTheWeek的值做不同的事情。
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机找到第一个匹配时，那个代码块将被执行。请看以下代码，这段代码为不同年级的学生分配项目：
- en: '[PRE44]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: switch语句以关键字switch开始，后面跟着*控制表达式*。在这个例子中，控制表达式是变量studentGrade。
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制表达式之后，花括号从➊开始，switch语句的主体就在这些花括号内。
- en: '![Image](Image00089.jpg)'
  id: totrans-988
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00089.jpg)'
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: switch语句的主体由一个或多个case组成。在这个例子中，总共有六个case。每个case以关键字case开始，后跟一个值和一个冒号，如➋所示。如果一个case语句匹配控制表达式，则紧跟在case后的代码将被执行。每个case必须至少包含一行代码，否则会报错。在这个例子中，switch被用来将字符串“待定”赋值给变量studentProject，直到遇到与控制表达式匹配的case字符串。
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以让多个case执行相同的操作。你可以看到，6年级、7年级和8年级的学生都可以选择自己的项目➌。我们通过编写关键字case和逗号分隔的值列表来指定这一点。
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，switch语句必须考虑到控制表达式的所有可能情况或值。在我们的例子中，因为studentGrade是一个整数类型（Int），所以我们的switch语句需要为所有可能的Int值创建case。但这样写会非常繁琐，因为可能的值太多了！例如，–7是一个Int，1,000也是。你真的想写1,000个case吗？
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 与其为每个值写一个单独的 case，你可以像我们在 ➍ 处所做的那样，使用关键字 default 作为最后一个 case。你只需输入 default 后跟一个冒号（default:），然后写上你希望在没有其他
    case 匹配时运行的代码。请注意，default case 前面没有 case 这个词。default case 对于处理你可能没有预料到的值非常有帮助，它能帮助你避免写太多的
    case 语句。在这个例子中，我们只期望学生成绩（studentGrade）为 1 到 8 之间的值，因此我们使用 default case 来覆盖所有其他可能的值。
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行这个 switch 语句，看看你得到什么结果。然后尝试更改数值，测试不同的条件。尽情玩玩看吧！
- en: '**WHAT YOU LEARNED**'
  id: totrans-994
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何编写程序，使计算机根据条件做出选择，使用了 if 和 switch 语句。你学习了如何编写布尔表达式和复合表达式，以及不同的比较运算符。条件语句是编程中的一种基本工具，几乎在每个有用的程序中都会出现。在[第4章](text00014.html#ch04)中，我们将讨论另一种重要的编程语句——循环。循环告诉计算机在停止之前重复做某件事。
- en: '![image](Image00090.jpg)'
  id: totrans-996
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00090.jpg)'
- en: '**IS EQUAL AND IS NOT EQUAL**'
  id: totrans-997
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**相等和不相等**'
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 你会经常使用 *相等* 和 *不相等* 这两个比较运算符。*相等* 用两个等号写在一起，像这样：==。*不相等* 用一个感叹号和一个等号写在一起，像这样：!=。
- en: Let’s try them both out in the playground!
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 playground 中试一下这两个字符串吧！
- en: '![Image](Image00077.jpg)'
  id: totrans-1000
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00077.jpg)'
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的英语来说，➊ 处的代码表示，“三加二等于五”，这是一个正确的陈述，右侧窗格中的输出会在你输入完后确认这一点。在➋ 处，代码表示，“三不等于五”，这也是一个正确的陈述。注意，➌
    处是错误的。你知道为什么吗？虽然 = 和 == 看起来很相似，但记住单个等号（=）是赋值操作。那行代码的意思是，“将 8 的值赋给名为 3 + 5 的东西”，这是不成立的。
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，== 运算符也适用于其他数据类型，而不仅仅是数字。让我们试着做一些其他的比较。
- en: '![Image](Image00078.jpg)'
  id: totrans-1003
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00078.jpg)'
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的这一行是个 tricky 的问题，你是否预计它会为 true？这两个字符串很接近，但并不完全相同，*相等* 的比较只有在两个值完全匹配时才为 true。常量
    myName 的值是 "Gloria"，其中的 *G* 是大写的，这与 "gloria"（小写 g）不一样。
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得在[第2章](text00012.html#ch02)中我们说过，你不能对不同数据类型的东西使用加法和乘法运算符吗？比较操作也是一样的。你不能比较不同类型的东西。➋
    处的代码会导致错误，因为一个是字符串（String），另一个是双精度浮点数（Double）。
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-1006
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**大于和小于**'
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看四个其他的比较运算符。我们从*大于*（表示为>）和*小于*（表示为<）开始。你可能已经对这些运算符的用法有了很好的了解。像9 > 7这样的布尔表达式，意思是“9大于7”，它为真。通常，你还希望知道某个值是否大于或等于某个值，或者是否小于或等于某个值。有两个运算符可以覆盖这些情况：*大于或等于*（表示为>=）和*小于或等于*（表示为<=）。我们可以通过一些例子来尝试这些运算符：
- en: '![Image](Image00079.jpg)'
  id: totrans-1008
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00079.jpg)'
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 注意区分➊处的*大于或等于*和➋处的*大于*。3 + 4的和并不大于7，但它是大于或等于7的。同样，5 + 6小于或等于11 ➌，但它并不小于11 ➍。
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '[表3-1](text00013.html#ch3tab1)总结了六个比较运算符。'
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-1：** 比较运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-1012
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-1013
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| == | Is equal to |'
  id: totrans-1014
  prefs: []
  type: TYPE_TB
  zh: '| == | 等于 |'
- en: '| != | Is not equal to |'
  id: totrans-1015
  prefs: []
  type: TYPE_TB
  zh: '| != | 不等于 |'
- en: '| > | Is greater than |'
  id: totrans-1016
  prefs: []
  type: TYPE_TB
  zh: '| > | 大于 |'
- en: '| < | Is less than |'
  id: totrans-1017
  prefs: []
  type: TYPE_TB
  zh: '| < | 小于 |'
- en: '| >= | Is greater than or equal to |'
  id: totrans-1018
  prefs: []
  type: TYPE_TB
  zh: '| >= | 大于或等于 |'
- en: '| <= | Is less than or equal to |'
  id: totrans-1019
  prefs: []
  type: TYPE_TB
  zh: '| <= | 小于或等于 |'
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写条件语句时，你会经常使用这些运算符。
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-1021
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合布尔表达式**'
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 复合布尔表达式是将简单的布尔表达式结合在一起。它就像在英语中用*and*和*or*构造复合句一样。在编程中，还有第三种情况：*not*。在Swift中，我们称这些词为*逻辑运算符*。逻辑运算符要么将布尔表达式与另一个布尔表达式结合，要么对其进行否定。Swift中的三个逻辑运算符如下表所示：[表3-2](text00013.html#ch3tab2)。
- en: '**Table 3-2:** Logical Operators'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-2：** 逻辑运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-1024
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-1025
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| && | Logical AND |'
  id: totrans-1026
  prefs: []
  type: TYPE_TB
  zh: '| && | 逻辑与 |'
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-1027
  prefs: []
  type: TYPE_TB
  zh: '| &#124;&#124; | 逻辑或 |'
- en: '| ! | Logical NOT |'
  id: totrans-1028
  prefs: []
  type: TYPE_TB
  zh: '| ! | 逻辑非 |'
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑运算符，你可以编写语句来测试一个值是否落在某个范围内，例如：“这个人的年龄是否在10到15之间？”你可以通过同时测试年龄大于10*且*小于15来实现，像这样：
- en: '![Image](Image00080.jpg)'
  id: totrans-1030
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00080.jpg)'
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 语句age > 10 && age < 15为真，因为两个条件都为真：age大于10且小于15。AND语句只有在两个条件都为真时才为真。
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将age的值改为18，看看会发生什么：
- en: '![Image](Image00081.jpg)'
  id: totrans-1033
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00081.jpg)'
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将age改为18，所以只有一边的条件为真。变量age仍然大于10，但不再小于15，因此我们的表达式求值为假。
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过在你的操作环境中输入这段代码来测试OR：
- en: '![Image](Image00082.jpg)'
  id: totrans-1036
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00082.jpg)'
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过将常量 name 设置为 "Jacqueline"，虚构了一个名叫 Jacqueline 的人。接下来，我们测试一些条件，看看它们是 true
    还是 false。因为 name == "Jacqueline" 为 true，即使 name == "Jack" 为 false，➊ 处的 OR 语句依然为
    true。用英语来说，这个语句表示“此人叫 Jack *或者* 此人叫 Jacqueline。”在 OR 语句中，只需要有一个条件为 true，整个表达式就为
    true。
- en: '![image](Image00083.jpg)'
  id: totrans-1038
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00083.jpg)'
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用一些 NOT 语句。在你的练习场中输入以下内容：
- en: '![Image](Image00084.jpg)'
  id: totrans-1040
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00084.jpg)'
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '! 操作符用于复合布尔语句 ➊，你可以将其理解为“我们的人*不是*女孩*并且*我们的人叫 Jack。”该语句有两个逻辑操作符，! 和 &&。你可以在写复合布尔表达式时组合任意多个逻辑操作符。'
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，使用括号来让计算机知道首先评估什么是个好主意。括号还能让代码更容易阅读。这就像在一个方程式中使用多个数学运算时所用的括号一样，正如在“[使用括号来排列操作顺序](text00012.html#ch02lev2sec8)”中所描述的，参见[第
    30 页](text00012.html#page_30)。在 ➋ 中，我们使用括号告诉计算机首先检查 !isAGirl && name == "Jack"，然后再检查
    isAGirl && name == "Jacqueline"。当计算机评估完两部分后，它就可以评估整个语句的 OR 部分，因为第二部分为 true，所以整个表达式为
    true。同样，在 OR 语句中，只要有一个条件为 true，整个表达式就为 true。
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-3](text00013.html#ch3tab3) 显示了三种逻辑操作符以及可以用它们构造的复合表达式，并列出了它们对应的布尔值。'
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-3：** 布尔逻辑操作符与复合布尔表达式'
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-1045
  prefs: []
  type: TYPE_TB
  zh: '| **逻辑操作符** | **复合表达式** | **值** |'
- en: '| --- | --- | --- |'
  id: totrans-1046
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| NOT (! ) | !true | false |'
  id: totrans-1047
  prefs: []
  type: TYPE_TB
  zh: '| NOT (! ) | !true | false |'
- en: '| NOT (! ) | !false | true |'
  id: totrans-1048
  prefs: []
  type: TYPE_TB
  zh: '| NOT (! ) | !false | true |'
- en: '| AND (&& ) | true && true | true |'
  id: totrans-1049
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | true && true | true |'
- en: '| AND (&& ) | true && false | false |'
  id: totrans-1050
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | true && false | false |'
- en: '| AND (&& ) | false && true | false |'
  id: totrans-1051
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | false && true | false |'
- en: '| AND (&& ) | false && false | false |'
  id: totrans-1052
  prefs: []
  type: TYPE_TB
  zh: '| AND (&& ) | false && false | false |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-1053
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-1054
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-1055
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-1056
  prefs: []
  type: TYPE_TB
  zh: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 表格的第一项显示，NOT true 的值为 false。类似地，NOT false 的值为 true。
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AND 操作符时，只有当两个条件都为 true && true 时，结果才为 true。这意味着 && 操作符两边的表达式必须都为 true，&&
    表达式的结果才为 true。如果复合表达式为 true && false，它将计算为 false。而且，如果复合表达式中的两个条件都为 false，结果也将是
    false。
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 OR 运算符来说，只要 || 运算符两边的任意一个表达式为真，整个 || 表达式就为真。因此，true || true 为真，true || false
    也为真。只有两边都为假时，复合 OR 表达式才会为假。
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-1060
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**条件语句**'
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句分为两类：if 语句和 switch 语句。这些语句向计算机提供一个条件，计算机根据该条件做出选择。
- en: '**IF STATEMENTS**'
  id: totrans-1062
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**IF 语句**'
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: if 语句以关键字 if 开头，后面跟着一个*条件*，条件总是一个布尔表达式。计算机检查条件，如果条件为真，就执行 if 语句中的代码；如果条件为假，就跳过该代码。让我们写一些代码来测试一个孩子是否足够高以乘坐过山车。请在你的编程环境中输入以下代码：
- en: '[PRE45]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设定 48 英寸为孩子单独乘坐过山车的最小身高，并将骑车者的身高设为 49.5 英寸。在 ➊ 处，我们测试骑车者的身高是否大于或等于 heightToRideAlone。如果是，程序会说他们足够高，可以乘坐过山车。为了编写我们的
    if 语句，我们将关键字 if 放在条件 height >= heightToRideAlone 前面。然后，我们把希望在条件为真时执行的代码包裹在一对大括号
    ➋ 中。由于我们的骑车者足够高，计算机会打印出 "You are tall enough to ride this roller coaster."（你足够高，可以乘坐这辆过山车）。
- en: '![image](Image00085.jpg)'
  id: totrans-1066
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00085.jpg)'
- en: Hooray!
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 万岁！
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们改变骑车者的身高会发生什么。将身高改为小于 48.0 的数字。这时，由于 if 语句中的条件为假，程序会跳过所有的 if 语句中的代码，什么也不会发生。
- en: '**else Statements**'
  id: totrans-1069
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else 语句**'
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会希望计算机在某个语句为真时做一件事，而在该语句为假时做另一件事。为了做到这一点，在 if 语句和代码块后面，只需输入关键字 else，然后编写你希望在
    if 条件不成立时执行的代码块。如果骑车者的身高不足以满足条件，让计算机告诉他们不能骑过山车：
- en: '[PRE46]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你将骑车者的身高改为小于 48 英寸，你会看到 "Sorry. You cannot ride this roller coaster."（抱歉，你不能乘坐这辆过山车）。这是因为
    ➊ 处的 else 语句告诉计算机如果条件为假，就打印这个消息。通俗来说，这就像是在说：“如果骑车者足够高可以乘坐过山车，就告诉他们可以乘坐；否则，告诉他们不能乘坐。”
- en: '**else if Statements**'
  id: totrans-1073
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else if 语句**'
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试不同的条件来判断骑车者的身高，以创建更多的过山车骑行规则。我们可以通过添加 else if 条件来实现。让我们添加一个新的最小身高，要求孩子必须与成人一起骑行：
- en: '[PRE47]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的else if语句检查骑车者的身高是否大于或等于heightToRideWithAdult。如果骑车者的身高低于48英寸但高于36英寸，则结果窗格中会显示“你可以和成年人一起坐这个过山车”。如果他们的身高太矮，无法单独乘坐或和成年人一起乘坐，那么计算机会打印出“抱歉，你不能坐这个过山车”。
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: else if语句非常简洁，因为你可以用它来测试许多不同的条件，但非常重要的是要注意这些条件的顺序。为了说明我们的意思，将骑车者的身高改为50.0，使他们足够高可以单独乘坐。然后，通过将height
    >= heightToRideWithAdult作为第一个条件，将height >= heightToRideAlone作为第二个条件，来改变if else语句中条件的顺序。你认为会打印出什么？查看[图3-1](text00013.html#ch03fig1)来找出答案。
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-1078
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00086.jpg)![image](Image00087.jpg)'
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-1：小心else if语句的顺序。*'
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，尽管骑车者的身高高于heightToRideAlone，程序仍然打印出“你可以和成年人一起坐这个过山车。”这是对于一个身高大于heightToRideWithAdult但小于heightToRideAlone的骑车者来说的预期输出。我们得到这个结果是因为骑车者的身高符合第一个条件，因此计算机会打印出第一句话，并且不再检查其他条件。
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦if或else if语句中的某个部分被判断为真，其他条件就不会被检查了。在我们在[图3-1](text00013.html#ch03fig1)中的例子里，第一个条件为真，所以其他条件被跳过了。这可能会导致程序中出现意外的结果，所以如果你在if或else
    if语句中遇到问题，请检查条件的顺序！
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用if、else或else if语句时，有几个重要的规则。第一个是，除非你先写了if语句，否则不能有else或else if语句。第二个是，虽然你可以在if后面有任意多的else
    if，但只能有一个else——并且这个else必须放在最后。else语句是用来处理所有其他情况的，如果前面的条件都不满足的话。
- en: '**CODE WITH STYLE**'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: '**风格化编码**'
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 请密切关注本书中使用的编码风格。所谓的*编码风格*，指的是代码的书写方式、使用的空格数量、某些行的缩进以及哪些内容应该放在新的一行。看看这段代码：
- en: '[PRE48]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 if 条件之后，我们留有空格并将左花括号 { 放在同一行。块的右花括号 } 总是位于下一行的开头。花括号中的语句缩进四个空格。这是 Xcode
    自动为你做的，目的是使代码更易读。如果这样做能帮助你更容易阅读，可以随意添加空白行。通常，你在 if 语句等代码块之前，应该至少留一行空白行。
- en: '![image](Image00088.jpg)'
  id: totrans-1087
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00088.jpg)'
- en: '**SWITCH STATEMENTS**'
  id: totrans-1088
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**SWITCH 语句**'
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 与 if 语句仅用于评估布尔表达式（必须为真或假）不同，switch 语句可以评估并根据多个条件进行分支。你可以使用 switch 来检查一个整数的值，并告诉计算机如果该整数等于
    1 执行一件事，如果该整数等于 2 执行另一件事，以此类推。或者，你可以创建一个名为 dayOfTheWeek 的字符串，并编写一个 switch 语句，根据
    dayOfTheWeek 的值让计算机做不同的事情。
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机找到第一个匹配项时，那个代码块会被执行。请看下面的代码，它为不同年级的学生分配项目：
- en: '[PRE49]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: switch 语句以关键字 switch 开头，后面跟着 *控制表达式*。在这个例子中，控制表达式是变量 studentGrade。
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 控制表达式之后，在 ➊ 处开始了一组花括号，switch 语句的主体就在这些花括号内。
- en: '![Image](Image00089.jpg)'
  id: totrans-1094
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00089.jpg)'
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: switch 语句的主体由一个或多个 case 组成。在这个例子中，共有六个 case。每个 case 都以关键字 case 开头，后跟一个值和一个冒号，如
    ➋ 所示。如果某个 case 语句匹配了控制表达式，则紧随其后的代码将会执行。每个 case 必须至少有一行代码，否则会报错。在这个例子中，switch 被用来将赋值给变量
    studentProject 的字符串从 "To be determined" 更改为与控制表达式匹配的字符串。
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以让多个 case 执行相同的操作。你可以看到，6、7 和 8 年级的学生都可以选择他们自己的项目 ➌。我们通过编写关键字 case 和一个用逗号分隔的值列表来指定这一点。
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个 switch 语句必须考虑到控制表达式的每一个可能的 case 或值。在我们的例子中，由于 studentGrade 是一个 Int 类型，我们的
    switch 语句需要涵盖所有可能的 Int 值。但是这将需要非常长的时间来编写，因为有太多的可能值！例如，-7 是一个 Int 类型，1000 也是。你真的想写
    1000 个 case 吗？
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 与其为每个值编写一个单独的 case，你可以使用关键字 default 作为最后一个 case，就像我们在 ➍ 所做的那样。你只需输入 default
    后跟一个冒号（default:），然后输入当其他所有 case 不匹配时要执行的代码。注意，默认 case 前面没有 case 关键字。默认 case 对于处理你可能没有预料到的值非常有用，它能帮助你避免编写太多的
    case 语句。在这个例子中，我们只期望 studentGrade 的值为 1 到 8 之间，所以我们使用 default case 来覆盖所有其他可能的值。
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行这个 switch 语句，看看你得到的结果是什么。然后尝试更改值，测试不同的条件。玩一玩它吧！
- en: '**WHAT YOU LEARNED**'
  id: totrans-1100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用 if 和 switch 语句编写程序，让计算机根据条件做出选择。你学习了如何编写布尔表达式和复合表达式，以及不同的比较运算符。条件语句是编程中一个重要的工具，几乎在每一个有用的程序中都能看到它。
    在[第4章](text00014.html#ch04)中，我们将讨论另一种重要的编程语句——循环。循环告诉计算机反复执行某些操作，直到该停止时为止。
- en: '![image](Image00090.jpg)'
  id: totrans-1102
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00090.jpg)'
- en: 'You’ll use the *is equal* and *is not equal* comparison operators a lot. *Is
    equal* is written with two equal signs next to each other, like this: == . *Is
    not equal* is written with an exclamation mark and one equal sign, like this:
    != .'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 你会经常使用 *相等* 和 *不相等* 的比较运算符。*相等* 使用两个等号写成这样：== 。*不相等* 使用感叹号和一个等号写成这样：!= 。
- en: Let’s try them both out in the playground!
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在游乐场里试试这两者！
- en: '![Image](Image00077.jpg)'
  id: totrans-1105
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00077.jpg)'
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的语言来说，➊ 这一行的意思是，“三加二等于五，”这是一个正确的陈述，右侧面板的输出会在你输入完成后确认这一点。在 ➋ 中，这一行表示，“三不等于五，”这也是一个正确的陈述。注意
    ➌ 是一个错误。你知道为什么吗？虽然 = 和 == 看起来很相似，但记住，单个等号（=）是用来赋值的。那行代码的意思是，“将值 8 赋给名为 3 + 5 的东西，”这是不行的。
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，== 运算符不仅适用于数字，还适用于其他数据类型。让我们尝试做一些其他的比较。
- en: '![Image](Image00078.jpg)'
  id: totrans-1108
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00078.jpg)'
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行有点 tricky；你是否预期它是对的？那两个字符串非常相似，但并不完全相同，*相等* 的比较只有在两个值完全匹配时才会返回 true。常量
    myName 的值是 "Gloria"，首字母是大写的 *G* ，这与 "gloria"（小写的 *g*）不同。
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在[第2章](text00012.html#ch02)中我们说过，你不能对不同数据类型的内容使用数学运算符，比如 + 和 * 吗？比较也是一样的。你不能比较不同类型的东西。➋
    这一行会导致错误，因为一个是 String 类型，另一个是 Double 类型。
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-1111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**大于与小于**'
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看另外四个比较运算符。我们从 *大于*（写作 >）和 *小于*（写作 <）开始。你可能已经对它们的工作原理有了较好的了解。例如，布尔表达式
    9 > 7 ，意思是“9 大于 7”，这个表达式为真。通常，你还想知道某个值是否大于或等于某个值，或者是否小于或等于某个值。还有两个运算符可以处理这些情况：*大于或等于*（表示为
    >=）和 *小于或等于*（表示为 <=）。我们通过一些示例来试试这些运算符：
- en: '![Image](Image00079.jpg)'
  id: totrans-1113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00079.jpg)'
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意➊处的 *大于或等于* 和➋处的 *大于* 之间的区别。3 + 4 的和不是大于 7，但它大于或等于 7。同样，5 + 6 小于或等于 11 ➌ ，但它并不小于
    11 ➍。
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: '[表3-1](text00013.html#ch3tab1) 总结了六个比较运算符。'
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-1：** 比较运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-1117
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-1118
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| == | Is equal to |'
  id: totrans-1119
  prefs: []
  type: TYPE_TB
  zh: '| == | 等于 |'
- en: '| != | Is not equal to |'
  id: totrans-1120
  prefs: []
  type: TYPE_TB
  zh: '| != | 不等于 |'
- en: '| > | Is greater than |'
  id: totrans-1121
  prefs: []
  type: TYPE_TB
  zh: '| > | 大于 |'
- en: '| < | Is less than |'
  id: totrans-1122
  prefs: []
  type: TYPE_TB
  zh: '| < | 小于 |'
- en: '| >= | Is greater than or equal to |'
  id: totrans-1123
  prefs: []
  type: TYPE_TB
  zh: '| >= | 大于或等于 |'
- en: '| <= | Is less than or equal to |'
  id: totrans-1124
  prefs: []
  type: TYPE_TB
  zh: '| <= | 小于或等于 |'
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写条件语句时，你会发现自己经常使用这些运算符。
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-1126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合布尔表达式**'
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 复合布尔表达式是将多个简单的布尔表达式组合在一起的表达式。这就像是用 *and* 和 *or* 这样的词来构成英文的复合句。在编程中，还有第三种情况：*not*
    。在 Swift 中，我们称这些词为 *逻辑运算符* 。逻辑运算符可以将一个布尔表达式与另一个表达式结合起来，或者对其取反。Swift 中的三种逻辑运算符如[表3-2](text00013.html#ch3tab2)所示。
- en: '**Table 3-2:** Logical Operators'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-2：** 逻辑运算符'
- en: '| **Symbol** | **Definition** |'
  id: totrans-1129
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **定义** |'
- en: '| --- | --- |'
  id: totrans-1130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| && | Logical AND |'
  id: totrans-1131
  prefs: []
  type: TYPE_TB
  zh: '| && | 逻辑与 |'
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-1132
  prefs: []
  type: TYPE_TB
  zh: '| &#124;&#124; | 逻辑或 |'
- en: '| ! | Logical NOT |'
  id: totrans-1133
  prefs: []
  type: TYPE_TB
  zh: '| ! | 逻辑非 |'
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑运算符，你可以写出测试某个值是否在范围内的语句，例如：“这个人的年龄在 10 到 15 之间吗？”你可以通过测试年龄是否大于 10 *并且* 小于
    15 来实现，像这样：
- en: '![Image](Image00080.jpg)'
  id: totrans-1135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00080.jpg)'
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 语句 age > 10 && age < 15 为真，因为两个条件都成立：年龄大于 10 且小于 15。只有两个条件都为真时，*与* 语句才为真。
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将年龄的值更改为 18，看看会发生什么：
- en: '![Image](Image00081.jpg)'
  id: totrans-1138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00081.jpg)'
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将年龄更改为 18，所以语句的一侧仍然为真。变量 age 仍然大于 10，但它不再小于 15，所以我们的表达式结果为假。
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试在你的 playground 中输入以下代码，测试 OR 运算符：
- en: '![Image](Image00082.jpg)'
  id: totrans-1141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00082.jpg)'
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-1143
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-1145
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-1150
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1151
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-1152
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-1153
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-1154
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-1155
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-1156
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-1157
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-1158
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-1159
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-1160
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-1161
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于OR操作符，只需要||操作符两侧的任一表达式为真，整个||表达式就为真。因此，true || true为真，true || false也为真。只有在两个侧面都为假时，复合OR表达式才会评估为假。
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-1165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**条件语句**'
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句分为两类：if语句和switch语句。这些语句向计算机提供一个条件，计算机根据该条件做出选择。
- en: '**IF STATEMENTS**'
  id: totrans-1167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**IF语句**'
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: if语句以关键字if开头，后跟一个*条件*，该条件始终是一个布尔表达式。计算机会检查条件，如果条件为真，则执行if语句内的代码；如果条件为假，则跳过该代码。让我们写一些代码，测试孩子是否足够高以乘坐过山车。请将以下代码输入到你的编程环境中：
- en: '[PRE50]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了48英寸为孩子独自乘坐过山车的最低身高，并且将乘客的身高设置为49.5英寸。在➊处，我们测试乘客的身高是否大于或等于heightToRideAlone。如果是，程序会说他们足够高，可以乘坐过山车。为了编写if语句，我们在条件height
    >= heightToRideAlone前加上关键字if。然后，我们将当条件为真时要执行的代码放在一对大括号➋中。因为我们的乘客足够高，计算机会打印“你足够高，可以乘坐这个过山车。”
- en: '![image](Image00085.jpg)'
  id: totrans-1171
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00085.jpg)'
- en: Hooray!
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改变乘客的身高，看看会发生什么。将身高改为小于48.0的数字。这时，因为if语句中的条件评估为假，程序会跳过if语句中的所有代码，什么都不会发生。
- en: '**else Statements**'
  id: totrans-1174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else语句**'
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会想要让计算机在某个条件为真时执行一项操作，而在该条件为假时执行另一项操作。为此，在if语句和代码块后面，只需键入关键字else，后跟你希望在if条件不成立时执行的另一个代码块。如果乘客的身高不足以满足条件，那么让计算机告诉他们不能乘坐过山车：
- en: '[PRE51]'
  id: totrans-1176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你将乘客的身高改为小于48英寸，你会看到“抱歉，您不能乘坐这个过山车。”这是因为在➊处的else语句告诉计算机，如果条件评估为假，则打印此消息。通俗地说，这就像是在说，“如果乘客足够高可以乘坐过山车，就说他们可以乘坐。如果不行，就说他们不能。”
- en: '**else if Statements**'
  id: totrans-1178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**else if语句**'
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为乘客的身高测试不同的条件，以创建更多的过山车乘坐规则。我们可以通过添加else if条件来实现这一点。让我们添加一个新的最低身高要求，让孩子必须与成人一起乘坐：
- en: '[PRE52]'
  id: totrans-1180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的 else if 语句检查骑行者的身高是否大于或等于 heightToRideWithAdult。如果骑行者的身高在 48 英寸以下但又高于 36
    英寸，则会在结果窗格中出现 "你可以和成年人一起乘坐这列过山车。" 如果骑行者太矮，既不能单独乘坐也不能和成年人一起乘坐，则计算机会打印 "抱歉，你不能单独乘坐这列过山车。"
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: else if 语句非常简洁，因为你可以用它来测试许多不同的条件，但非常重要的是要注意这些条件的顺序。为了让你明白我们的意思，把骑行者的身高改为 50.0，这样他们就足够高可以单独乘坐了。然后，通过将条件的顺序进行调整，先把
    height >= heightToRideWithAdult 放为第一个条件，再将 height >= heightToRideAlone 放为第二个条件。你认为会打印什么？查看[图
    3-1](text00013.html#ch03fig1)来找出答案。
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-1183
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00086.jpg)![image](Image00087.jpg)'
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：小心 else if 语句的顺序。*'
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，尽管骑行者的身高超过了 heightToRideAlone 的要求，但程序打印了 "你可以和成年人一起乘坐这列过山车。" 这是预期的输出，因为骑行者的身高大于
    heightToRideWithAdult 但小于 heightToRideAlone。我们得到这个结果是因为骑行者的身高符合第一个条件，因此计算机打印了第一句话，并且没有继续检查其他条件。
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发现 if 或 else if 语句的某一部分为真，后续的条件将不会被检查。在我们在[图 3-1](text00013.html#ch03fig1)中的示例中，第一个条件为真，因此其余的条件被跳过。这可能会导致程序出现意外结果，所以如果你在
    if 或 else if 语句中遇到问题，请检查条件的顺序！
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 if、else 或 else if 语句时，有几个重要的规则。第一个规则是，除非先写一个 if 语句，否则不能使用 else 或 else if
    语句。第二个规则是，虽然你可以在 if 语句后使用任意数量的 else if，但只能有一个 else，而且这个 else 必须是最后一个。else 是一个捕获所有情况的语句，如果其他条件都不成立时执行。
- en: '**CODE WITH STYLE**'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '**有风格的编程**'
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 密切关注我们在本书中使用的编程风格。所谓 *编程风格*，是指代码的书写方式、使用的空格数量、某些行的缩进以及哪些内容应该单独成行。看看这段代码：
- en: '[PRE53]'
  id: totrans-1190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-1192
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-1193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-1199
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用关键字 default 作为最后一个 case，而不是为每个值编写单独的 case，就像我们在 ➍ 处所做的那样。你只需要输入 default
    后跟冒号（default:），然后是如果其他 case 不匹配时要执行的代码。注意，default case 前面没有 "case" 这个词。默认 case
    非常有用，可以处理你可能没有预料到的值，并且避免编写过多的 case 语句。在这个例子中，我们只期望 studentGrade 的值为 1 到 8，因此我们使用
    default case 来覆盖所有其他可能的值。
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行这个 switch 语句，看看结果。然后尝试更改值以测试不同的条件。动手玩一玩吧！
- en: '**WHAT YOU LEARNED**'
  id: totrans-1205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何编写计算机程序，使其根据条件作出选择，使用了 if 和 switch 语句。你学习了如何编写布尔表达式和复合表达式，并了解了不同的比较操作符。条件语句是编程中的重要工具，几乎在每个有用的程序中都会看到它们。在
    [第4章](text00014.html#ch04) 中，我们将讨论另一种重要的编程语句——循环。循环指示计算机重复执行某个操作，直到停止循环为止。
- en: '![image](Image00090.jpg)'
  id: totrans-1207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00090.jpg)'
- en: Let’s try them both out in the playground!
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 playground 中试试这两者！
- en: '![Image](Image00077.jpg)'
  id: totrans-1209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00077.jpg)'
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的英文来说，➊ 这一行表示 "三加二等于五"，这是一个正确的陈述，右侧面板的输出会在你输入完后确认这一点。在 ➋ 处，行表示 "三不等于五"，这也是一个正确的陈述。注意，➌
    是一个错误。你知道为什么吗？虽然 = 和 == 看起来很相似，但请记住单个等号（=）是用来赋值的。那条语句的意思是 "把 8 的值赋给名为 3 + 5 的东西"，这行不通。
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，== 操作符不仅适用于数字，还可以与其他数据类型一起使用。让我们试着进行一些其他的比较。
- en: '![Image](Image00078.jpg)'
  id: totrans-1212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00078.jpg)'
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行是个 tricky 题目；你是否预计它为真？这两个字符串很相似，但并不完全相同，只有在两个值完全匹配时，*相等* 的比较才为真。常量 myName
    的值是大写字母 *G* 的 "Gloria"，这与小写字母 *g* 的 "gloria" 不相同。
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得在 [第2章](text00012.html#ch02) 中我们提到过你不能对不同数据类型的东西使用数学运算符，如 + 和 * 吗？比较时也是如此。你不能比较不同类型的东西。➋
    这一行会导致错误，因为一个是字符串（String），另一个是浮点数（Double）。
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-1215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**大于与小于**'
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  id: totrans-1217
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-1221
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1222
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  id: totrans-1223
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  id: totrans-1224
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  id: totrans-1225
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  id: totrans-1226
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  id: totrans-1227
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  id: totrans-1228
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-1230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-1233
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1234
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  id: totrans-1235
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-1236
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  id: totrans-1237
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-1239
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-1242
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-1245
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-1247
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-1249
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-1254
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1255
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-1256
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-1257
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-1258
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-1259
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-1260
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-1261
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-1262
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-1263
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-1264
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-1265
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-1269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-1271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-1273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-1275
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-1278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-1280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-1282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-1284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的else if语句检查骑行者的身高是否大于或等于heightToRideWithAdult。如果骑行者的身高介于48英寸和36英寸之间，则结果面板中会显示"你可以和成人一起乘坐这个过山车。"
    如果他们太矮，既无法独自乘坐，也无法和成人一起乘坐，计算机会打印"抱歉，你不能乘坐这个过山车。"
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: else if语句很简洁，因为你可以用它来测试许多不同的条件，但非常重要的是要注意这些条件的顺序。为了让你理解我们的意思，请将骑行者的身高更改为50.0，以使他们足够高可以独自乘坐。然后，通过将height
    >= heightToRideWithAdult作为第一个条件，将height >= heightToRideAlone作为第二个条件，来改变if else语句中的条件顺序。你认为将会打印什么？查看[图3-1](text00013.html#ch03fig1)了解答案。
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-1287
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00086.jpg)![image](Image00087.jpg)'
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-1：小心排列else if语句的顺序。*'
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，即使骑行者的身高超过了heightToRideAlone，程序仍然打印出"你可以和成人一起乘坐这个过山车。" 这是因为骑行者的身高符合第一个条件，因此计算机会打印出第一个句子，且不再检查其他条件。
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦if或else if语句的某部分被判断为真，剩余的条件将不再被检查。在我们在[图3-1](text00013.html#ch03fig1)中的示例中，第一个条件为真，因此其余条件被跳过。这可能会导致程序出现意外结果，所以如果你在if或else
    if语句中遇到问题，检查条件的顺序吧！
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用if、else或else if语句时，有几个重要的规则。第一个是，除非先写一个if语句，否则不能有else或else if语句。第二个是，虽然在if后面可以有任意多个else
    if语句，但只能有一个else——并且这个else必须是最后一个。else语句是当其他条件都不成立时的兜底情况。
- en: '**CODE WITH STYLE**'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: '**有风格的代码**'
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 请密切关注我们在本书中使用的编码风格。*编码风格*指的是代码的书写方式、使用的空格数量、某些行的缩进，以及哪些内容应该另起一行。看看这段代码：
- en: '[PRE58]'
  id: totrans-1294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-1296
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-1297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-1300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-1303
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![Image](Image00077.jpg)'
  id: totrans-1311
  prefs: []
  type: TYPE_IMG
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00078.jpg)'
  id: totrans-1314
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-1317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  id: totrans-1319
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-1323
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1324
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  id: totrans-1325
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  id: totrans-1326
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  id: totrans-1327
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  id: totrans-1328
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  id: totrans-1329
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  id: totrans-1330
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-1332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-1335
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1336
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  id: totrans-1337
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-1338
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  id: totrans-1339
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-1341
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-1344
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-1347
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-1349
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-1351
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-1356
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1357
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-1358
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-1359
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-1360
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-1361
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-1362
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-1363
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-1364
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-1365
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-1366
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-1367
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-1371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-1373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-1375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-1377
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-1380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-1382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-1384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-1386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-1389
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-1396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-1398
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-1399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-1402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-1405
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-1413
  prefs: []
  type: TYPE_IMG
- en: In plain English, the line at ➊ says, “three plus two equals five,” which is
    a true statement, and the output in the right pane will confirm this as soon as
    you finish typing it. At ➋ , the line says, “three is not equal to five,” which
    is also a true statement. Note that ➌ is an error. Do you know why? While = and
    == look a lot alike, remember that a single equal sign (=) assigns values. That
    statement reads, “Put the value of 8 into something called 3 + 5,” which doesn’t
    work.
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00078.jpg)'
  id: totrans-1416
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-1419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  id: totrans-1421
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-1425
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1426
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  id: totrans-1427
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  id: totrans-1428
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  id: totrans-1429
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  id: totrans-1430
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  id: totrans-1431
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  id: totrans-1432
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-1434
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-1437
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1438
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  id: totrans-1439
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-1440
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  id: totrans-1441
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-1443
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-1446
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-1449
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-1451
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-1453
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-1458
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1459
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-1460
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-1461
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-1462
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-1463
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-1464
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-1465
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-1466
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-1467
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-1468
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-1469
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-1473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-1475
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-1477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-1479
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-1482
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-1484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-1486
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-1488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-1491
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-1498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-1500
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-1501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-1504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-1507
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1513
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-1515
  prefs: []
  type: TYPE_IMG
- en: In Swift, the == operator also works with other data types, not just numbers.
    Let’s try making some other comparisons.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00078.jpg)'
  id: totrans-1517
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-1520
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  id: totrans-1522
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-1526
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1527
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  id: totrans-1528
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  id: totrans-1529
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  id: totrans-1530
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  id: totrans-1531
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  id: totrans-1532
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  id: totrans-1533
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-1535
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-1538
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1539
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  id: totrans-1540
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-1541
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  id: totrans-1542
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-1544
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-1547
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-1550
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-1552
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-1554
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-1559
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1560
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-1561
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-1562
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-1563
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-1564
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-1565
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-1566
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-1567
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-1568
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-1569
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-1570
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-1574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-1576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-1578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-1580
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-1583
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-1585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-1587
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-1589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-1592
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-1599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-1601
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-1602
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-1605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-1608
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1614
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![Image](Image00078.jpg)'
  id: totrans-1616
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-1619
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  id: totrans-1621
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-1625
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1626
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  id: totrans-1627
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  id: totrans-1628
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  id: totrans-1629
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  id: totrans-1630
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  id: totrans-1631
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  id: totrans-1632
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-1634
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-1637
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1638
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  id: totrans-1639
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-1640
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  id: totrans-1641
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-1643
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-1646
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-1649
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-1651
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-1653
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-1658
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1659
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-1660
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-1661
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-1662
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-1663
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-1664
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-1665
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-1666
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-1667
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-1668
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-1669
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-1673
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-1675
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-1677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-1679
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-1682
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-1684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-1686
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-1688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-1691
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-1698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-1700
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-1701
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-1704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-1707
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1713
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-1715
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ is a tricky one; did you expect it to be true ? Those two strings
    are close but not exactly the same, and an *is equal* comparison is true only
    if the two values match exactly. The constant myName has a value of "Gloria" with
    a capital *G* , which is not the same as "gloria" with a lowercase *g* .
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-1718
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  id: totrans-1720
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-1724
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1725
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  id: totrans-1726
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  id: totrans-1727
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  id: totrans-1728
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  id: totrans-1729
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  id: totrans-1730
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  id: totrans-1731
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-1733
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-1736
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1737
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  id: totrans-1738
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-1739
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  id: totrans-1740
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-1742
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-1745
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-1748
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-1750
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-1752
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-1757
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1758
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-1759
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-1760
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-1761
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-1762
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-1763
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-1764
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-1765
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-1766
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-1767
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-1768
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-1772
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-1774
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-1776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-1778
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-1781
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-1783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-1785
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-1787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-1790
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-1797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-1799
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-1800
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-1803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-1806
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1812
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-1814
  prefs: []
  type: TYPE_IMG
- en: Remember in [Chapter 2](text00012.html#ch02) when we said that you can’t use
    math operators like + and * on things that aren’t the same data type? The same
    is true for comparisons. You can’t compare things that are different types. The
    line at ➋ will cause an error because one is a String and the other is a Double
    .
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-1816
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  id: totrans-1818
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-1822
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1823
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  id: totrans-1824
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  id: totrans-1825
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  id: totrans-1826
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  id: totrans-1827
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  id: totrans-1828
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  id: totrans-1829
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-1831
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-1834
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1835
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  id: totrans-1836
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-1837
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  id: totrans-1838
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-1840
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-1843
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-1846
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-1848
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-1850
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-1855
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1856
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-1857
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-1858
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-1859
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-1860
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-1861
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-1862
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-1863
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-1864
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-1865
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-1866
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-1870
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-1872
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-1874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-1876
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-1879
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-1881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-1883
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-1885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-1888
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-1895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-1897
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-1898
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-1901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-1902
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-1904
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1910
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-1912
  prefs: []
  type: TYPE_IMG
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-1913
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  id: totrans-1915
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-1919
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1920
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  id: totrans-1921
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  id: totrans-1922
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  id: totrans-1923
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  id: totrans-1924
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  id: totrans-1925
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  id: totrans-1926
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-1928
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-1929
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-1931
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1932
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  id: totrans-1933
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-1934
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  id: totrans-1935
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-1937
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-1940
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-1943
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-1945
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-1947
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-1949
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-1952
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1953
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-1954
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-1955
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-1956
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-1957
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-1958
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-1959
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-1960
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-1961
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-1962
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-1963
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-1964
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-1967
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-1969
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-1971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-1972
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-1973
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-1976
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-1978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-1980
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-1982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-1985
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-1987
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-1989
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-1991
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-1992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-1994
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-1995
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-1998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-1999
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-2001
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-2003
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2007
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-2009
  prefs: []
  type: TYPE_IMG
- en: 'Now let’s look at four other comparison operators. We’ll start with *greater
    than* (written as > ) and *less than* (written as < ). You probably already have
    a good idea of how these work. A Boolean expression like 9 > 7 , which reads “9
    is greater than 7,” is true . Often, you’ll also want to know if something is
    greater than or equal to something or less than or equal to something. There are
    two more operators that cover those cases: *greater than or equal to* (which looks
    like >= ) and *less than or equal to* (which looks like <= ). Let’s try these
    out with some more examples:'
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00079.jpg)'
  id: totrans-2011
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-2013
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-2015
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2016
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  id: totrans-2017
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  id: totrans-2018
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  id: totrans-2019
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  id: totrans-2020
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  id: totrans-2021
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  id: totrans-2022
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-2024
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-2027
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2028
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  id: totrans-2029
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-2030
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  id: totrans-2031
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-2033
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-2034
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-2036
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-2039
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-2040
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-2041
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-2043
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-2044
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-2046
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-2048
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-2049
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-2050
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-2051
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-2052
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-2053
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-2054
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-2055
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-2056
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-2057
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-2058
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-2059
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-2060
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-2061
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-2063
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-2065
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-2067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-2068
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-2069
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-2070
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-2072
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-2074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-2076
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-2078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-2079
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-2081
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-2082
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-2085
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-2087
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-2088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-2090
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-2091
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-2093
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-2094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-2095
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-2097
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-2099
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-2104
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![Image](Image00079.jpg)'
  id: totrans-2105
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-2106
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-2109
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2110
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  id: totrans-2111
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  id: totrans-2112
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  id: totrans-2113
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  id: totrans-2114
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  id: totrans-2115
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  id: totrans-2116
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-2117
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-2118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-2119
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-2121
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2122
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  id: totrans-2123
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-2124
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  id: totrans-2125
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-2126
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-2127
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-2130
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-2131
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-2133
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-2135
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-2136
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-2137
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-2138
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-2139
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-2140
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-2142
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-2143
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-2144
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-2145
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-2146
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-2147
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-2148
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-2149
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-2150
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-2151
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-2152
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-2153
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-2154
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-2155
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-2156
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-2157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-2158
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-2159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-2160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-2161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-2163
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-2166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-2167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-2168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-2169
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-2170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-2172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-2173
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-2175
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-2179
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-2181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-2182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-2183
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-2184
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-2185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-2187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-2188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-2189
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-2191
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-2192
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-2194
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-2196
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-2198
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-2199
  prefs: []
  type: TYPE_IMG
- en: Note the difference between *greater than or equal to* at ➊ and *greater than*
    at ➋ . The sum of 3 + 4 is not greater than 7 , but it is greater than or equal
    to 7 . Similarly, 5 + 6 is less than or equal to 11 ➌ , but it’s not less than
    11 ➍ .
  id: totrans-2200
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-2201
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-2203
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2204
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  id: totrans-2205
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  id: totrans-2206
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  id: totrans-2207
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  id: totrans-2208
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  id: totrans-2209
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  id: totrans-2210
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-2211
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-2212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-2213
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-2215
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2216
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  id: totrans-2217
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-2218
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  id: totrans-2219
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-2220
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-2221
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-2222
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-2224
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-2226
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-2227
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-2228
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-2229
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-2231
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-2232
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-2234
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-2236
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-2237
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-2238
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-2239
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-2240
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-2241
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-2242
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-2243
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-2244
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-2245
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-2246
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-2247
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-2248
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-2249
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-2250
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-2251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-2253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-2255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-2257
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-2258
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-2260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-2261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-2262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-2263
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-2264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-2266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-2268
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-2269
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-2270
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-2272
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-2276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-2278
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-2279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-2280
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-2281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-2282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-2284
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-2285
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-2287
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-2288
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-2292
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-2293
  prefs: []
  type: TYPE_IMG
- en: '[Table 3-1](text00013.html#ch3tab1) summarizes the six comparison operators.'
  id: totrans-2294
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-2295
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-2296
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2297
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  id: totrans-2298
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  id: totrans-2299
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  id: totrans-2300
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  id: totrans-2301
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  id: totrans-2302
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  id: totrans-2303
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-2305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  id: totrans-2307
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-2308
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2309
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  id: totrans-2310
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-2311
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  id: totrans-2312
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-2313
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-2314
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-2315
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-2316
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-2317
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-2318
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-2319
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-2320
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-2321
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-2322
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-2323
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-2324
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-2325
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-2327
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-2328
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-2329
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-2330
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-2331
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-2332
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-2333
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-2334
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-2335
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-2336
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-2337
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-2338
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-2339
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-2340
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-2342
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-2343
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-2344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-2346
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-2347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-2348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-2349
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-2350
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-2351
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-2352
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-2353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-2354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-2355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-2356
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-2357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-2358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-2359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-2360
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-2361
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-2362
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-2363
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-2364
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-2365
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-2367
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-2368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-2369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-2370
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-2371
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-2372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-2373
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-2374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-2375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-2376
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-2377
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-2378
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-2379
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-2380
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-2381
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-2382
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-2383
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-2385
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-2386
  prefs: []
  type: TYPE_IMG
- en: '**Table 3-1:** Comparison Operators'
  id: totrans-2387
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-2388
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2389
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  id: totrans-2390
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  id: totrans-2391
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  id: totrans-2392
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  id: totrans-2393
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  id: totrans-2394
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  id: totrans-2395
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-2396
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-2397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-2398
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  id: totrans-2399
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-2400
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2401
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  id: totrans-2402
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-2403
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  id: totrans-2404
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-2405
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-2406
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-2407
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-2409
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-2410
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-2411
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-2412
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-2413
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-2414
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-2416
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-2417
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-2418
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-2419
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-2420
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-2421
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-2422
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-2423
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-2424
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-2425
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-2426
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-2427
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-2428
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-2429
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-2430
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-2431
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-2432
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-2433
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-2434
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-2435
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-2436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-2437
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-2438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-2439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-2440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-2442
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-2443
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-2444
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-2445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-2446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-2447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-2448
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-2449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-2451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-2452
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-2453
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-2454
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-2455
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-2456
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-2457
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-2458
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-2459
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-2461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-2462
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-2463
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-2464
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-2466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-2467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-2468
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-2470
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-2471
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-2473
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-2475
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-2477
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-2478
  prefs: []
  type: TYPE_IMG
- en: '| **Symbol** | **Definition** |'
  id: totrans-2479
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2480
  prefs: []
  type: TYPE_TB
- en: '| == | Is equal to |'
  id: totrans-2481
  prefs: []
  type: TYPE_TB
- en: '| != | Is not equal to |'
  id: totrans-2482
  prefs: []
  type: TYPE_TB
- en: '| > | Is greater than |'
  id: totrans-2483
  prefs: []
  type: TYPE_TB
- en: '| < | Is less than |'
  id: totrans-2484
  prefs: []
  type: TYPE_TB
- en: '| >= | Is greater than or equal to |'
  id: totrans-2485
  prefs: []
  type: TYPE_TB
- en: '| <= | Is less than or equal to |'
  id: totrans-2486
  prefs: []
  type: TYPE_TB
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-2487
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-2488
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-2489
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  id: totrans-2490
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-2491
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2492
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  id: totrans-2493
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-2494
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  id: totrans-2495
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-2496
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-2497
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-2498
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-2499
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-2500
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-2502
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-2503
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-2504
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-2505
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-2507
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-2508
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-2509
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-2510
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-2511
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-2512
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-2513
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-2514
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-2515
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-2516
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-2517
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-2518
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-2519
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-2520
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-2521
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-2522
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-2523
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-2524
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-2525
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-2526
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-2527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-2528
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-2529
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-2530
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-2531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-2532
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-2533
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-2534
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-2535
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-2536
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-2537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-2538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-2539
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-2540
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-2541
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-2542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-2543
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-2544
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-2545
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-2546
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-2547
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-2548
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-2549
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-2550
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-2551
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-2552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-2553
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-2554
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-2555
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-2556
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-2557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-2558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-2559
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-2560
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-2561
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-2562
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-2563
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-2564
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-2565
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-2566
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-2568
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-2569
  prefs: []
  type: TYPE_IMG
- en: You’ll find yourself using these operators often when you write conditional
    statements.
  id: totrans-2570
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-2571
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-2572
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  id: totrans-2573
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-2574
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2575
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  id: totrans-2576
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-2577
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  id: totrans-2578
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-2579
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-2580
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-2581
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-2582
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-2583
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-2584
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-2585
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-2586
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-2587
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-2588
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-2589
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-2590
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-2591
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-2592
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-2593
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-2594
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-2595
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-2596
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-2597
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-2598
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-2599
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-2600
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-2601
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-2602
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-2603
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-2604
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-2605
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-2606
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-2607
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-2608
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-2609
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-2610
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-2611
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-2612
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-2613
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-2614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-2615
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-2616
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-2617
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-2618
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-2619
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-2620
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-2621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-2622
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-2623
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-2624
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-2625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-2626
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-2627
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-2628
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-2629
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-2630
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-2631
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-2632
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-2633
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-2634
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-2635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-2636
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-2637
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-2638
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-2639
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-2640
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-2641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-2642
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-2643
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-2644
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-2645
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-2646
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-2647
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-2649
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2650
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-2651
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-2652
  prefs: []
  type: TYPE_IMG
- en: '**COMPOUND BOOLEAN EXPRESSIONS**'
  id: totrans-2653
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-2654
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  id: totrans-2655
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-2656
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2657
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  id: totrans-2658
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-2659
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  id: totrans-2660
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-2661
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-2662
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-2663
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-2664
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-2665
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-2666
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-2667
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-2668
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-2669
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-2670
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-2671
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-2672
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-2673
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-2674
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-2675
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-2676
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-2677
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-2678
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-2679
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-2680
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-2681
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-2682
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-2683
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-2684
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-2685
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-2686
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-2687
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-2688
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-2689
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-2690
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-2691
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-2692
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-2693
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-2694
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-2695
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-2696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-2697
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-2698
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-2699
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-2700
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-2701
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-2702
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-2703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-2704
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-2705
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-2706
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-2707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-2708
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-2709
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-2710
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-2711
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-2712
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-2713
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-2714
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-2715
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-2716
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-2717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-2718
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-2719
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-2720
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-2721
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-2722
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-2723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-2724
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-2725
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-2726
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-2727
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-2728
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-2729
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-2730
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-2731
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2732
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-2733
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-2734
  prefs: []
  type: TYPE_IMG
- en: 'Compound Boolean expressions are simple Boolean expressions that have been
    joined together. It’s a lot like making compound sentences in English with the
    words *and* and *or* . In programming, there is a third case: *not* . In Swift,
    we call these words *logical operators* . A logical operator either combines a
    Boolean expression with another one or negates it. The three logical operators
    in Swift are shown in [Table 3-2](text00013.html#ch3tab2) .'
  id: totrans-2735
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Logical Operators'
  id: totrans-2736
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-2737
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2738
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  id: totrans-2739
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-2740
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  id: totrans-2741
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-2742
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-2743
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-2745
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-2746
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-2747
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-2748
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-2749
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-2750
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-2751
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-2752
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-2753
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-2754
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-2755
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-2756
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-2757
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-2758
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-2759
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-2760
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-2761
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-2762
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-2763
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-2764
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-2765
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-2766
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-2767
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-2768
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-2769
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-2770
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-2771
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-2772
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-2773
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-2774
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-2775
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-2776
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-2777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-2778
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-2779
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-2780
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-2781
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-2782
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-2783
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-2784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-2785
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-2786
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-2787
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-2788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-2789
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-2790
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-2791
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-2792
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-2793
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-2794
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-2795
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-2796
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-2797
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-2798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-2799
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-2800
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-2801
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-2802
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-2803
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-2804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-2805
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-2806
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-2807
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-2808
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-2809
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-2810
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-2811
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-2812
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2813
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-2814
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-2815
  prefs: []
  type: TYPE_IMG
- en: '**Table 3-2:** Logical Operators'
  id: totrans-2816
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Definition** |'
  id: totrans-2817
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2818
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  id: totrans-2819
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-2820
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  id: totrans-2821
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-2822
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-2823
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-2824
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-2825
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-2826
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-2827
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-2828
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-2829
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-2830
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-2831
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-2832
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-2833
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-2834
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-2835
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-2836
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-2837
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-2838
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-2839
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-2840
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-2841
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-2842
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-2843
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-2844
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-2845
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-2846
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-2847
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-2848
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-2849
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-2850
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-2851
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-2852
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-2853
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-2854
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-2855
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-2856
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-2857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-2858
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-2859
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-2860
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-2861
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-2862
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-2863
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-2864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-2865
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-2866
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-2867
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-2868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-2869
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-2870
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-2871
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-2872
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-2873
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-2874
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-2875
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-2876
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-2877
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-2878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-2879
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-2880
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-2881
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-2882
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-2883
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-2884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-2885
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-2886
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-2887
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-2888
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-2889
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-2890
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-2891
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-2892
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2893
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-2894
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-2895
  prefs: []
  type: TYPE_IMG
- en: '| **Symbol** | **Definition** |'
  id: totrans-2896
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-2897
  prefs: []
  type: TYPE_TB
- en: '| && | Logical AND |'
  id: totrans-2898
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Logical OR |'
  id: totrans-2899
  prefs: []
  type: TYPE_TB
- en: '| ! | Logical NOT |'
  id: totrans-2900
  prefs: []
  type: TYPE_TB
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-2901
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-2902
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-2903
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-2904
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-2905
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-2906
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-2907
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-2908
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-2909
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-2910
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-2911
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-2912
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-2913
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-2914
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-2915
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-2916
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-2917
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-2918
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-2919
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-2920
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-2921
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-2922
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-2923
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-2924
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-2925
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-2926
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-2927
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-2928
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-2929
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-2930
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-2931
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-2932
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-2933
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-2934
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-2935
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-2936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-2937
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-2938
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-2939
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-2940
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-2941
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-2942
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-2943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-2944
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-2945
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-2946
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-2947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-2948
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-2949
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-2950
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-2951
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-2952
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-2953
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-2954
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-2955
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-2956
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-2957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-2958
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-2959
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-2960
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-2961
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-2962
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-2963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-2964
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-2965
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-2966
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-2967
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-2968
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-2969
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-2970
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-2971
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2972
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-2973
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-2974
  prefs: []
  type: TYPE_IMG
- en: 'With logical operators, you can write statements that test if a value falls
    within a range, such as, “Is this person’s age between 10 and 15?” You would do
    this by testing if the age is greater than 10 *and* less than 15 at the same time,
    like this:'
  id: totrans-2975
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00080.jpg)'
  id: totrans-2976
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-2977
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-2978
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-2979
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-2980
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-2981
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-2982
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-2983
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-2984
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-2985
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-2986
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-2987
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-2988
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-2989
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-2990
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-2991
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-2992
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-2993
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-2994
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-2995
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-2996
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-2997
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-2998
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-2999
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-3000
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-3001
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-3002
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-3003
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-3004
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-3005
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-3006
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-3007
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-3008
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-3009
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-3010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-3011
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-3012
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-3013
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-3014
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-3015
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-3016
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-3017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-3018
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-3019
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-3020
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-3021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-3022
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-3023
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-3024
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-3025
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-3026
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-3027
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-3028
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-3029
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-3030
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-3031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-3032
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-3033
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-3034
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-3035
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-3036
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-3037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-3038
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-3039
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-3040
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-3041
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-3042
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-3043
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-3044
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-3045
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3046
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-3047
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![Image](Image00080.jpg)'
  id: totrans-3048
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-3049
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-3050
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-3051
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-3052
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-3053
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-3054
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-3055
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-3056
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-3057
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-3058
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-3059
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-3060
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-3061
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-3062
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-3063
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-3064
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-3065
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-3066
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-3067
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-3068
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-3069
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-3070
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-3071
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-3072
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-3073
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-3074
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-3075
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-3076
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-3077
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-3078
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-3079
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-3080
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-3081
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-3082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-3083
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-3084
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-3085
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-3086
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-3087
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-3088
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-3089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-3090
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-3091
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-3092
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-3093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-3094
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-3095
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-3096
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-3097
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-3098
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-3099
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-3100
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-3101
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-3102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-3103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-3104
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-3105
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-3106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-3107
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-3108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-3109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-3110
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-3111
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-3112
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-3113
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-3114
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-3115
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-3116
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-3117
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-3119
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-3120
  prefs: []
  type: TYPE_IMG
- en: 'The statement age > 10 && age < 15 is true because both the conditions are
    true : age is greater than 10 and less than 15\. An AND statement is true only
    if both conditions are true .'
  id: totrans-3121
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-3122
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-3123
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-3124
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-3125
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-3126
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-3127
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-3128
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-3129
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-3130
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-3131
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-3132
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-3133
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-3134
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-3135
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-3136
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-3137
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-3138
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-3139
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-3140
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-3141
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-3142
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-3143
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-3144
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-3145
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-3146
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-3147
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-3148
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-3149
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-3150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-3151
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-3152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-3153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-3154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-3155
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-3156
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-3157
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-3158
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-3159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-3160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-3161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-3162
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-3163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-3164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-3165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-3166
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-3167
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-3168
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-3169
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-3170
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-3171
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-3172
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-3173
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-3174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-3175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-3176
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-3177
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-3178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-3179
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-3180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-3181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-3182
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-3183
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-3184
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-3185
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-3186
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-3187
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-3188
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-3189
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-3191
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-3192
  prefs: []
  type: TYPE_IMG
- en: 'Try changing the value of age to 18 to see what happens:'
  id: totrans-3193
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00081.jpg)'
  id: totrans-3194
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-3195
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-3196
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-3197
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-3198
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-3199
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-3200
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-3201
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-3202
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-3203
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-3204
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-3205
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-3206
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-3207
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-3208
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-3209
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-3210
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-3211
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-3212
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-3213
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-3214
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-3215
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-3216
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-3217
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-3218
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-3219
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-3220
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-3221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-3222
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-3223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-3224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-3225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-3226
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-3227
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-3228
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-3229
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-3230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-3231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-3232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-3233
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-3234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-3235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-3236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-3237
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-3238
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-3239
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-3240
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-3241
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-3242
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-3243
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-3244
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-3245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-3246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-3247
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-3248
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-3249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-3250
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-3251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-3252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-3253
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-3254
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-3255
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-3256
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-3257
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-3258
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-3259
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-3260
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-3262
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![Image](Image00081.jpg)'
  id: totrans-3263
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-3264
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-3265
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-3266
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-3267
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-3268
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-3269
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-3270
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-3271
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-3272
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-3273
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-3274
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-3275
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-3276
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-3277
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-3278
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-3279
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-3280
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-3281
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-3282
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-3283
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-3284
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-3285
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-3286
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-3287
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-3288
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-3289
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-3290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-3291
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-3292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-3293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-3294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-3295
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-3296
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-3297
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-3298
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-3299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-3300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-3301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-3302
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-3303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-3304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-3305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-3306
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-3307
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-3308
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-3309
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-3310
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-3311
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-3312
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-3313
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-3314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-3315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-3316
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-3317
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-3318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-3319
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-3320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-3321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-3322
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-3323
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-3324
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-3325
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-3326
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-3327
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-3328
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-3329
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-3331
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-3332
  prefs: []
  type: TYPE_IMG
- en: Because we changed age to 18, only one side of the statement is true . The variable
    age is still greater than 10, but it’s no longer less than 15, so our expression
    evaluates to false .
  id: totrans-3333
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-3334
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-3335
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-3336
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-3337
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-3338
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-3339
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-3340
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-3341
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-3342
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-3343
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-3344
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-3345
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-3346
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-3347
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-3348
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-3349
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-3350
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-3351
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-3352
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-3353
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-3354
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-3355
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-3356
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-3357
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-3358
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-3359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-3360
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-3361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-3362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-3363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-3364
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-3365
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-3366
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-3367
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-3368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-3369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-3370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-3371
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-3372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-3373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-3374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-3375
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-3376
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-3377
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-3378
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-3379
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-3380
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-3381
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-3382
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-3383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-3384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-3385
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-3386
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-3387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-3388
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-3389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-3390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-3391
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-3392
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-3393
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-3394
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-3395
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-3396
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-3397
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-3398
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-3400
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-3401
  prefs: []
  type: TYPE_IMG
- en: 'Now test out OR by entering this code in your playground:'
  id: totrans-3402
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00082.jpg)'
  id: totrans-3403
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-3404
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-3405
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-3406
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-3407
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-3408
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-3409
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-3410
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-3411
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-3412
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-3413
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-3414
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-3415
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-3416
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-3417
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-3418
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-3419
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-3420
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-3421
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-3422
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-3423
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-3424
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-3425
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-3426
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-3427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-3428
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-3429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-3430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-3431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-3432
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-3433
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-3434
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-3435
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-3436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-3437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-3438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-3439
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-3440
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-3441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-3442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-3443
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-3444
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-3445
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-3446
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-3447
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-3448
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-3449
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-3450
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-3451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-3452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-3453
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-3454
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-3455
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-3456
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-3457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-3458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-3459
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-3460
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-3461
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-3462
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-3463
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-3464
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-3465
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-3466
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-3468
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![Image](Image00082.jpg)'
  id: totrans-3469
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-3470
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-3471
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-3472
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-3473
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-3474
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-3475
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-3476
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-3477
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-3478
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-3479
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-3480
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-3481
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-3482
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-3483
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-3484
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-3485
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-3486
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-3487
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-3488
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-3489
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-3490
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-3491
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-3492
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-3493
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-3494
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-3495
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-3496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-3497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-3498
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-3499
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-3500
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-3501
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-3502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-3503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-3504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-3505
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-3506
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-3507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-3508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-3509
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-3510
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-3511
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-3512
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-3513
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-3514
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-3515
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-3516
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-3517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-3518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-3519
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-3520
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-3521
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-3522
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-3523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-3524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-3525
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-3526
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-3527
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-3528
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-3529
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-3530
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-3531
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-3532
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-3534
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-3535
  prefs: []
  type: TYPE_IMG
- en: First, we make up a person named Jacqueline by setting the constant name to
    "Jacqueline" . Next, we test some conditions to see if they are true or false
    . Because name == "Jacqueline" is true , the OR statement at ➊ is true even though
    name == "Jack" is false . In English, this statement says, “This person’s name
    is Jack *or* this person’s name is Jacqueline.” In an OR statement, only one of
    the conditions needs to be true for the whole expression to be true .
  id: totrans-3536
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00083.jpg)'
  id: totrans-3537
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-3538
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-3539
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-3540
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-3541
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-3542
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-3543
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-3544
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-3545
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-3546
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-3547
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-3548
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-3549
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-3550
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-3551
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-3552
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-3553
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-3554
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-3555
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-3556
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-3557
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-3558
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-3559
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-3560
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-3561
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-3562
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-3563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-3564
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-3565
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-3566
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-3567
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-3568
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-3569
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-3570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-3571
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-3572
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-3573
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-3574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-3575
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-3576
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-3577
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-3578
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-3579
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-3580
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-3581
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-3582
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-3583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-3584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-3585
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-3586
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-3587
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-3588
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-3589
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-3590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-3591
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-3592
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-3593
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-3594
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-3595
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-3596
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-3597
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-3598
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3599
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-3600
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![image](Image00083.jpg)'
  id: totrans-3601
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-3602
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-3603
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-3604
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-3605
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-3606
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-3607
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-3608
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-3609
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-3610
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-3611
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-3612
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-3613
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-3614
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-3615
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-3616
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-3617
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-3618
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-3619
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-3620
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-3621
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-3622
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-3623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-3624
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-3625
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-3626
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-3627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-3628
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-3629
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-3630
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-3631
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-3632
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-3633
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-3634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-3635
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-3636
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-3637
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-3638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-3639
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-3640
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-3641
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-3642
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-3643
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-3644
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-3645
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-3646
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-3647
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-3648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-3649
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-3650
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-3651
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-3652
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-3653
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-3654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-3655
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-3656
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-3657
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-3658
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-3659
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-3660
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-3661
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-3662
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-3664
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-3665
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try using some NOT statements. Enter the following into your playground:'
  id: totrans-3666
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00084.jpg)'
  id: totrans-3667
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-3668
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-3669
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-3670
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-3671
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-3672
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-3673
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-3674
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-3675
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-3676
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-3677
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-3678
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-3679
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-3680
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-3681
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-3682
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-3683
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-3684
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-3685
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-3686
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-3687
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-3688
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-3689
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-3690
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-3691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-3692
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-3693
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-3694
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-3695
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-3696
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-3697
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-3698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-3699
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-3700
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-3701
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-3702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-3703
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-3704
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-3705
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-3706
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-3707
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-3708
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-3709
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-3710
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-3711
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-3712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-3713
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-3714
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-3715
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-3716
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-3717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-3718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-3719
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-3720
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-3721
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-3722
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-3723
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-3724
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-3725
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-3726
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3727
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-3728
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![Image](Image00084.jpg)'
  id: totrans-3729
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-3730
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-3731
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-3732
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-3733
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-3734
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-3735
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-3736
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-3737
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-3738
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-3739
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-3740
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-3741
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-3742
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-3743
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-3744
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-3745
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-3746
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-3747
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-3748
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-3749
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-3750
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-3751
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-3752
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-3753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-3754
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-3755
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-3756
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-3757
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-3758
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-3759
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-3760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-3761
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-3762
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-3763
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-3764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-3765
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-3766
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-3767
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-3768
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-3769
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-3770
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-3771
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-3772
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-3773
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-3774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-3775
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-3776
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-3777
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-3778
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-3779
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-3780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-3781
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-3782
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-3783
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-3784
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-3785
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-3786
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-3787
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-3788
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3789
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-3790
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-3791
  prefs: []
  type: TYPE_IMG
- en: The ! operator is used in the compound Boolean statement ➊ , which you could
    read as “Our person is *not* a girl *and* our person is named Jack.” That statement
    has two logical operators, ! and && . You can combine as many logical operators
    as you want when you write compound Boolean expressions.
  id: totrans-3792
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-3793
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-3794
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-3795
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-3796
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-3797
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-3798
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-3799
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-3800
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-3801
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-3802
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-3803
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-3804
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-3805
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-3806
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-3807
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-3808
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-3809
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-3810
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-3811
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-3812
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-3813
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-3814
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-3815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-3816
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-3817
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-3818
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-3819
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-3820
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-3821
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-3822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-3823
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-3824
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-3825
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-3826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-3827
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-3828
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-3829
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-3830
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-3831
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-3832
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-3833
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-3834
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-3835
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-3836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-3837
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-3838
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-3839
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-3840
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-3841
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-3842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-3843
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-3844
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-3845
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-3846
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-3847
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-3848
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-3849
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-3850
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3851
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-3852
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-3853
  prefs: []
  type: TYPE_IMG
- en: Sometimes it’s a good idea to use parentheses to let the computer know what
    to evaluate first. Parentheses also make the code easier to read. This is similar
    to how you use parentheses when you use several math operations in one equation,
    as described in “[Ordering Operations with Parentheses](text00012.html#ch02lev2sec8)
    ” on [page 30](text00012.html#page_30) . At ➋ , we use parentheses to tell the
    computer to first check !isAGirl && name == "Jack" and then check isAGirl && name
    == "Jacqueline" . After it has evaluated both parts, the computer can evaluate
    the OR part for the entire statement, which will be true because the second part
    is true . Again, in an OR statement, the whole expression is true if any of the
    conditions is true .
  id: totrans-3854
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-3855
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-3856
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-3857
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-3858
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-3859
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-3860
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-3861
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-3862
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-3863
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-3864
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-3865
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-3866
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-3867
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-3868
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-3869
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-3870
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-3871
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-3872
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-3873
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-3874
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-3875
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-3876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-3877
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-3878
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-3879
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-3880
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-3881
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-3882
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-3883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-3884
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-3885
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-3886
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-3887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-3888
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-3889
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-3890
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-3891
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-3892
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-3893
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-3894
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-3895
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-3896
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  id: totrans-3897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-3898
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-3899
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-3900
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-3901
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-3902
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-3903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-3904
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-3905
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-3906
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-3907
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-3908
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-3909
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-3910
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-3911
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3912
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-3913
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-3914
  prefs: []
  type: TYPE_IMG
- en: '[Table 3-3](text00013.html#ch3tab3) shows the three logical operators and the
    compound expressions you can make with them, as well as their corresponding Boolean
    values.'
  id: totrans-3915
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-3916
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-3917
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-3918
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-3919
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-3920
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-3921
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-3922
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-3923
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-3924
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-3925
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-3926
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-3927
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-3928
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-3929
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-3930
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-3931
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-3932
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-3933
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-3934
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-3935
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-3936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-3937
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-3938
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-3939
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-3940
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-3941
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-3942
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-3943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-3944
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-3945
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-3946
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  id: totrans-3947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-3948
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-3949
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-3950
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-3951
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-3952
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-3953
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-3954
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-3955
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-3956
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-3957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-3958
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-3959
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-3960
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-3961
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-3962
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  id: totrans-3963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-3964
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-3965
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-3966
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-3967
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-3968
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-3969
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-3970
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-3971
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-3972
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-3973
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-3974
  prefs: []
  type: TYPE_IMG
- en: '**Table 3-3:** Compound Boolean Expressions with Logical Operators'
  id: totrans-3975
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-3976
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-3977
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-3978
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-3979
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-3980
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-3981
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-3982
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-3983
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-3984
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-3985
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-3986
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-3987
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-3988
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-3989
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-3990
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-3991
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-3992
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-3993
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-3994
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  id: totrans-3995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-3996
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-3997
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-3998
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-3999
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-4000
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-4001
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  id: totrans-4002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-4003
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-4004
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4005
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  id: totrans-4006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4007
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4008
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4009
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4010
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4011
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4012
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4013
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4014
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4015
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  id: totrans-4016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4017
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4018
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4019
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4020
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4021
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  id: totrans-4022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4023
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4024
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4025
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4026
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4027
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4028
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4029
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4030
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4031
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4032
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4033
  prefs: []
  type: TYPE_IMG
- en: '| **Logical operator** | **Compound expression** | **Value** |'
  id: totrans-4034
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-4035
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !true | false |'
  id: totrans-4036
  prefs: []
  type: TYPE_TB
- en: '| NOT (! ) | !false | true |'
  id: totrans-4037
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && true | true |'
  id: totrans-4038
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | true && false | false |'
  id: totrans-4039
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && true | false |'
  id: totrans-4040
  prefs: []
  type: TYPE_TB
- en: '| AND (&& ) | false && false | false |'
  id: totrans-4041
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; true | true |'
  id: totrans-4042
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | true &#124;&#124; false | true |'
  id: totrans-4043
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; true | true |'
  id: totrans-4044
  prefs: []
  type: TYPE_TB
- en: '| OR (&#124;&#124; ) | false &#124;&#124; false | false |'
  id: totrans-4045
  prefs: []
  type: TYPE_TB
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-4046
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-4047
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-4048
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-4049
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-4050
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-4051
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-4052
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  id: totrans-4053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-4054
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-4055
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-4056
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-4057
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-4058
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-4059
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-4060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-4061
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-4062
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4063
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-4064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4065
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4066
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4067
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4068
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4069
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4070
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4071
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4072
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4073
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  id: totrans-4074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4075
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4076
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4077
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4078
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4079
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  id: totrans-4080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4081
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4082
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4083
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4084
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4085
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4086
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4087
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4088
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4089
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4090
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4091
  prefs: []
  type: TYPE_IMG
- en: The first item of the table shows that something that is NOT true is false .
    Similarly, something that is NOT false is true .
  id: totrans-4092
  prefs: []
  type: TYPE_NORMAL
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-4093
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-4094
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-4095
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-4096
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-4097
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-4098
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-4099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-4100
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-4101
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-4102
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-4103
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-4104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-4105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  id: totrans-4106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-4107
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-4108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-4110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4111
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4112
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4113
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4114
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4115
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4116
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4117
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4118
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  id: totrans-4120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4121
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4122
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4124
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  id: totrans-4126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4127
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4128
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4129
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4130
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4131
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4132
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4133
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4134
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4136
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4137
  prefs: []
  type: TYPE_IMG
- en: With the AND operator, only something that is true && true is true . This means
    that the expressions on both sides of the && operator must be true for the &&
    expression to be true . A compound expression that is true && false will evaluate
    to false . And a compound && expression in which both conditions are false will
    also evaluate to false .
  id: totrans-4138
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-4139
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-4140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-4141
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-4142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-4143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-4144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-4145
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-4146
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-4147
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-4148
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-4149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-4150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-4151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-4152
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-4153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  id: totrans-4155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4156
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4157
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4158
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4159
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4160
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4161
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4162
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4163
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  id: totrans-4165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4166
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4167
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4169
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  id: totrans-4171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4172
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4173
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4174
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4175
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4176
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4177
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4178
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4179
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4181
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4182
  prefs: []
  type: TYPE_IMG
- en: When it comes to the OR operator, only one of the expressions on either side
    of the || operator must be true for the || expression to be true . Therefore,
    a true || true is true , and a true || false is also true . Only a compound OR
    expression in which both sides are false ends up being false .
  id: totrans-4183
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-4184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-4185
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-4186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-4187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  id: totrans-4188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-4189
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-4190
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-4191
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-4192
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-4193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-4194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  id: totrans-4195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-4196
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-4197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  id: totrans-4199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4200
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4201
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4202
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4203
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4204
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4205
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4206
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4207
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  id: totrans-4209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4210
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4211
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4213
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  id: totrans-4215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4216
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4217
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4218
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4219
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4220
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4221
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4222
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4223
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4225
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4226
  prefs: []
  type: TYPE_IMG
- en: '**CONDITIONAL STATEMENTS**'
  id: totrans-4227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-4228
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-4229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-4230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  id: totrans-4231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-4232
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-4233
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-4234
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-4235
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-4236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-4237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  id: totrans-4238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-4239
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-4240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  id: totrans-4242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4243
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4244
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4245
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4246
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4247
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4248
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4249
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4250
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  id: totrans-4252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4253
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4254
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4256
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  id: totrans-4258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4259
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4260
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4261
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4262
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4263
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4264
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4265
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4266
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4268
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4269
  prefs: []
  type: TYPE_IMG
- en: 'Conditional statements fall into two categories: the if statement and the switch
    statement. These statements present the computer with a condition that the computer
    makes a choice based on.'
  id: totrans-4270
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  id: totrans-4271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-4272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  id: totrans-4273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-4274
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-4275
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-4276
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-4277
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-4278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-4279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  id: totrans-4280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-4281
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-4282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  id: totrans-4284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4285
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4286
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4287
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4288
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4289
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4290
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4291
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4292
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  id: totrans-4294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4295
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4296
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4298
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  id: totrans-4300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4301
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4302
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4303
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4304
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4305
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4306
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4307
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4308
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4310
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4311
  prefs: []
  type: TYPE_IMG
- en: '**IF STATEMENTS**'
  id: totrans-4312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-4313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  id: totrans-4314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-4315
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-4316
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-4317
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-4318
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-4319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-4320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  id: totrans-4321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-4322
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-4323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  id: totrans-4325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4326
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4327
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4328
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4329
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4330
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4331
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4332
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4333
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  id: totrans-4335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4336
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4337
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4339
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  id: totrans-4341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4342
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4343
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4344
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4345
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4346
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4347
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4348
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4349
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4351
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4352
  prefs: []
  type: TYPE_IMG
- en: 'An if statement starts with the keyword if followed by a *condition* , which
    is always a Boolean expression. The computer examines the condition and executes
    the code inside the if statement if the condition is true or skips over that code
    if the condition is false . Let’s write some code that tests whether a kid is
    tall enough to ride a roller coaster. Enter the following code into your playground:'
  id: totrans-4353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  id: totrans-4354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-4355
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-4356
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-4357
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-4358
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-4359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-4360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  id: totrans-4361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-4362
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-4363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  id: totrans-4365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4366
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4367
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4368
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4369
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4370
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4371
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4372
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4373
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  id: totrans-4375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4376
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4377
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4379
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  id: totrans-4381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4382
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4383
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4384
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4385
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4386
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4387
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4388
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4389
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4391
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4392
  prefs: []
  type: TYPE_IMG
- en: '[PRE270]'
  id: totrans-4393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-4394
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-4395
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-4396
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-4397
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-4398
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-4399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  id: totrans-4400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-4401
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-4402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  id: totrans-4404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4405
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4406
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4407
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4408
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4409
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4410
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4411
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4412
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  id: totrans-4414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4415
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4416
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4418
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  id: totrans-4420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4421
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4422
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4423
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4424
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4425
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4426
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4427
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4428
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4430
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4431
  prefs: []
  type: TYPE_IMG
- en: Here, we set 48 inches as the minimum height at which a kid can ride our roller
    coaster alone, and we set our rider’s height to 49.5 inches. At ➊ , we test whether
    the rider’s height is greater than or equal to heightToRideAlone . If it is, the
    program says that they are tall enough to ride the roller coaster. To write our
    if statement, we put the keyword if in front of the condition height >= heightToRideAlone
    . Then we wrap the code that we want to execute when that condition is true in
    a set of braces ➋ . Because our rider is tall enough, the computer will print
    "You are tall enough to ride this roller coaster."
  id: totrans-4432
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00085.jpg)'
  id: totrans-4433
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-4434
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-4435
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-4436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-4437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  id: totrans-4438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-4439
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-4440
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  id: totrans-4442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4443
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4444
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4445
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4446
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4447
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4448
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4449
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4450
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  id: totrans-4452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4453
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4454
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4455
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4456
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  id: totrans-4458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4459
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4460
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4461
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4462
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4463
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4464
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4465
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4466
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4468
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![image](Image00085.jpg)'
  id: totrans-4469
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-4470
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-4471
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-4472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-4473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  id: totrans-4474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-4475
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-4476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  id: totrans-4478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4479
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4480
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4481
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4482
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4483
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4484
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4485
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4486
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  id: totrans-4488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4489
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4490
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4491
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4492
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  id: totrans-4494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4495
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4496
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4497
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4498
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4499
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4500
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4501
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4502
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4504
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4505
  prefs: []
  type: TYPE_IMG
- en: Hooray!
  id: totrans-4506
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-4507
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-4508
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-4509
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  id: totrans-4510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-4511
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-4512
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  id: totrans-4514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4515
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4516
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4517
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4518
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4519
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4520
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4521
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4522
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  id: totrans-4524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4525
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4526
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4527
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4528
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4529
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  id: totrans-4530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4531
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4532
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4533
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4534
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4535
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4536
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4537
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4538
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4540
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4541
  prefs: []
  type: TYPE_IMG
- en: Let’s see what happens if we change our rider’s height. Change height to a number
    less than 48.0\. This time, because the condition in the if statement evaluates
    to false , the program skips all of the code in the if statement and nothing happens.
  id: totrans-4542
  prefs: []
  type: TYPE_NORMAL
- en: '**else Statements**'
  id: totrans-4543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-4544
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  id: totrans-4545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-4546
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-4547
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  id: totrans-4549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4550
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4551
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4552
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4553
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4554
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4555
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4556
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4557
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4558
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  id: totrans-4559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4560
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4561
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4562
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4563
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4564
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  id: totrans-4565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4566
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4567
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4568
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4569
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4570
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4571
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4572
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4573
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4575
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4576
  prefs: []
  type: TYPE_IMG
- en: '**else Statements**'
  id: totrans-4577
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-4578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  id: totrans-4579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-4580
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-4581
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4582
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  id: totrans-4583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4584
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4585
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4586
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4587
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4588
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4589
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4590
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4591
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4592
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  id: totrans-4593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4594
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4595
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4596
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4597
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  id: totrans-4599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4600
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4601
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4602
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4603
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4604
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4605
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4606
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4607
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4609
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4610
  prefs: []
  type: TYPE_IMG
- en: 'Often, you’ll want to tell the computer to do one thing if a statement is true
    but something else if that statement is false . To do this, after the if statement
    and block of code, just type the keyword else followed by another block of code
    that you want to execute when the if condition isn’t true . If the rider isn’t
    tall enough to meet the condition, let’s have the computer tell them they can’t
    ride the roller coaster:'
  id: totrans-4611
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  id: totrans-4612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-4613
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-4614
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4615
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  id: totrans-4616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4617
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4618
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4619
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4620
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4621
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4622
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4623
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4624
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4625
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  id: totrans-4626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4627
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4628
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4629
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4630
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4631
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  id: totrans-4632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4633
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4634
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4635
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4636
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4637
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4638
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4639
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4640
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4641
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4642
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4643
  prefs: []
  type: TYPE_IMG
- en: '[PRE299]'
  id: totrans-4644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-4645
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-4646
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4647
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  id: totrans-4648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4649
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4650
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4651
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4652
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4653
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4654
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4655
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4656
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4657
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  id: totrans-4658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4659
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4660
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4661
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4662
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4663
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  id: totrans-4664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4665
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4666
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4667
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4668
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4669
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4670
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4671
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4672
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4673
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4674
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4675
  prefs: []
  type: TYPE_IMG
- en: Now if you change the rider’s height to less than 48 inches, you’ll see "Sorry.
    You cannot ride this roller coaster." That’s because the else statement at ➊ tells
    the computer to print that message if the statement evaluates to false . In plain
    English, this is like saying, “If the rider is tall enough to ride the roller
    coaster, say they can ride it. Else, say they can’t.”
  id: totrans-4676
  prefs: []
  type: TYPE_NORMAL
- en: '**else if Statements**'
  id: totrans-4677
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4678
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  id: totrans-4679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4680
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4681
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4682
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4683
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4684
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4685
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4686
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4687
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4688
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  id: totrans-4689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4690
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4691
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4692
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4693
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4694
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  id: totrans-4695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4696
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4697
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4698
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4699
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4700
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4701
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4702
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4703
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4704
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4705
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4706
  prefs: []
  type: TYPE_IMG
- en: '**else if Statements**'
  id: totrans-4707
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4708
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  id: totrans-4709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4710
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4711
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4712
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4713
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4714
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4715
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4716
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4717
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4718
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  id: totrans-4719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4720
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4721
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4722
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4723
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4724
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  id: totrans-4725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4726
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4727
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4728
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4729
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4730
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4731
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4732
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4733
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4734
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4735
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4736
  prefs: []
  type: TYPE_IMG
- en: 'We could also test different conditions for the rider’s height to create more
    rules for riding the roller coaster. We can do this by adding else if conditions.
    Let’s add a new minimum height that requires the kid to ride with an adult:'
  id: totrans-4737
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  id: totrans-4738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4739
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4740
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4741
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4742
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4743
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4744
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4745
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4746
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4747
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  id: totrans-4748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4749
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4750
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4751
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4752
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4753
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  id: totrans-4754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4755
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4756
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4757
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4758
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4759
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4760
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4761
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4762
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4763
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4764
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4765
  prefs: []
  type: TYPE_IMG
- en: '[PRE312]'
  id: totrans-4766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4767
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4768
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4769
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4770
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4771
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4772
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4773
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4774
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4775
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  id: totrans-4776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4777
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4778
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4779
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4780
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4781
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  id: totrans-4782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4783
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4784
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4785
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4786
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4787
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4788
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4789
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4790
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4791
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4792
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4793
  prefs: []
  type: TYPE_IMG
- en: The else if statement at ➊ checks whether the rider’s height is greater than
    or equal to heightToRideWithAdult . If a rider is shorter than 48 inches but taller
    than 36 inches, then the line "You can ride this roller coaster with an adult."
    appears in the results pane. If they are too short to ride alone or with an adult,
    then the computer prints "Sorry. You cannot ride this roller coaster."
  id: totrans-4794
  prefs: []
  type: TYPE_NORMAL
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4795
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4796
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4797
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4798
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4799
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4800
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4801
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4802
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  id: totrans-4803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4804
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4805
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4806
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4807
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4808
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  id: totrans-4809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4810
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4811
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4812
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4813
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4814
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4815
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4816
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4817
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4818
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4819
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4820
  prefs: []
  type: TYPE_IMG
- en: else if statements are neat because you can use them to test lots of different
    conditions, but it’s very important that you pay attention to the order of these
    conditions. To show you what we mean, change the rider’s height to 50.0 so that
    they are tall enough to ride alone. Then, change the order of the conditions in
    our if else statement by making height >= heightToRideWithAdult the first condition
    and height >= heightToRideAlone the second condition. What do you think will be
    printed? Take a look at [Figure 3-1](text00013.html#ch03fig1) to find out.
  id: totrans-4821
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4822
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4823
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4824
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4825
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4826
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4827
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4828
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  id: totrans-4829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4830
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4831
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4832
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4833
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4834
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  id: totrans-4835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4836
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4837
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4838
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4839
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4840
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4841
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4842
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4843
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4844
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4845
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![image](Image00086.jpg)![image](Image00087.jpg)'
  id: totrans-4846
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4847
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4848
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4849
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4850
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4851
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4852
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  id: totrans-4853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4854
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4855
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4856
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4857
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4858
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  id: totrans-4859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4860
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4861
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4862
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4863
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4864
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4865
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4866
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4867
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4868
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4869
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![image](Image00087.jpg)'
  id: totrans-4870
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4871
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4872
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4873
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4874
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4875
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4876
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  id: totrans-4877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4878
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4879
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4880
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4881
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4882
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  id: totrans-4883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4884
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4885
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4886
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4887
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4888
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4889
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4890
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4891
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4892
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4893
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4894
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Be careful with your ordering of else if statements.*'
  id: totrans-4895
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4896
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4897
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4898
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4899
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4900
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  id: totrans-4901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4902
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4903
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4904
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4905
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4906
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  id: totrans-4907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4908
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4909
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4910
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4911
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4912
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4913
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4914
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4915
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4916
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4917
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4918
  prefs: []
  type: TYPE_IMG
- en: You can see that even though the rider is taller than heightToRideAlone , the
    program prints "You can ride this roller coaster with an adult." which is the
    expected output for a rider whose height is greater than heightToRideWithAdult
    but less than heightToRideAlone . We get this result because the rider’s height
    matches the first condition, so the computer prints the first sentence and doesn’t
    bother checking anything else.
  id: totrans-4919
  prefs: []
  type: TYPE_NORMAL
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4920
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4921
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4922
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4923
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  id: totrans-4924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4925
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4926
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4927
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4928
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4929
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  id: totrans-4930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4931
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4932
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4933
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4934
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4935
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4936
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4937
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4938
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4939
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4940
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4941
  prefs: []
  type: TYPE_IMG
- en: Once any part of an if or else if statement is found to be true , the rest of
    the conditions won’t be checked. In our example in [Figure 3-1](text00013.html#ch03fig1)
    , the first condition is true , so the rest of the conditions are skipped. This
    can lead to unexpected results in your programs, so if you ever run into problems
    in your if or else if statements, check the order of the conditions!
  id: totrans-4942
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4943
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4944
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4945
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  id: totrans-4946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4947
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4948
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4949
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4950
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4951
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  id: totrans-4952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4953
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4954
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4955
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4956
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4957
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4958
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4959
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4960
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4961
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4962
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4963
  prefs: []
  type: TYPE_IMG
- en: When you’re working with if , else , or else if statements, there are a few
    important rules. The first is that you can’t have an else or an else if statement
    unless you write an if statement first. The second is that although you can have
    as many else if s as you want after an if , you can have only one else —and that
    else must be last. The else is the catch-all case if none of the other things
    has happened.
  id: totrans-4964
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE WITH STYLE**'
  id: totrans-4965
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4966
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  id: totrans-4967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4968
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4969
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4970
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4971
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4972
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  id: totrans-4973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4974
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4975
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4976
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4977
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4978
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4979
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-4980
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-4981
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4982
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-4983
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-4984
  prefs: []
  type: TYPE_IMG
- en: '**CODE WITH STYLE**'
  id: totrans-4985
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the coding style that we use in this book. By *coding
    style* , we mean the way that the code is written, the number of spaces used,
    the indentation of certain lines, and what things go on a new line. Take a look
    at this code:'
  id: totrans-4986
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  id: totrans-4987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: Notice that after the if condition we leave a space and then place the opening
    brace, { , on the same line. The block’s closing brace, } , always goes at the
    start of the next new line. The statements contained within the braces are indented
    by four spaces. This is something that Xcode does automatically for you to make
    the code more readable. Feel free to add blank lines if it makes it easier for
    you to read. In general, you should always have at least one blank line before
    a chunk of code such as an if statement.
  id: totrans-4988
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00088.jpg)'
  id: totrans-4989
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-4990
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-4991
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-4992
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  id: totrans-4993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-4994
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-4995
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-4996
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-4997
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-4998
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-4999
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-5000
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-5001
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5002
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-5003
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-5004
  prefs: []
  type: TYPE_IMG
- en: '**SWITCH STATEMENTS**'
  id: totrans-5005
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-5006
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-5007
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  id: totrans-5008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-5009
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-5010
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-5011
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-5012
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-5013
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-5014
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-5015
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-5016
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5017
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-5018
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-5019
  prefs: []
  type: TYPE_IMG
- en: Whereas an if statement is used only to evaluate a Boolean expression (something
    that must be true or false ), a switch statement can evaluate and branch out on
    any number of conditions. You could use a switch to check the value of an integer
    and tell the computer to do one thing if the integer equals 1 , something else
    if the integer equals 2 , and so on. Or, you could create a string called dayOfTheWeek
    and write a switch statement that makes the computer do something different based
    on the value of dayOfTheWeek .
  id: totrans-5020
  prefs: []
  type: TYPE_NORMAL
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-5021
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  id: totrans-5022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-5023
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-5024
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-5025
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-5026
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-5027
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-5028
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-5029
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-5030
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5031
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-5032
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-5033
  prefs: []
  type: TYPE_IMG
- en: 'When the computer finds the first match, that block of code is executed. Take
    a look at the following code, which assigns student projects for different grade
    levels:'
  id: totrans-5034
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  id: totrans-5035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-5036
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-5037
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-5038
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-5039
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-5040
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-5041
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-5042
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-5043
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5044
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-5045
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-5046
  prefs: []
  type: TYPE_IMG
- en: '[PRE336]'
  id: totrans-5047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-5048
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-5049
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-5050
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-5051
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-5052
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-5053
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-5054
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-5055
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5056
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-5057
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-5058
  prefs: []
  type: TYPE_IMG
- en: The switch statement starts with the keyword switch followed by the *control
    expression* . In this example, the control expression is the variable studentGrade
    .
  id: totrans-5059
  prefs: []
  type: TYPE_NORMAL
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-5060
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-5061
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-5062
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-5063
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-5064
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-5065
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-5066
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5067
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-5068
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-5069
  prefs: []
  type: TYPE_IMG
- en: After the control expression, a set of braces begins at ➊ , and the body of
    the switch statement is inside these braces.
  id: totrans-5070
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00089.jpg)'
  id: totrans-5071
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-5072
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-5073
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-5074
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-5075
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-5076
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5077
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-5078
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![Image](Image00089.jpg)'
  id: totrans-5079
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-5080
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-5081
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-5082
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-5083
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-5084
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5085
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-5086
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-5087
  prefs: []
  type: TYPE_IMG
- en: The body of the switch statement is made up of one or more cases. In this example,
    there are six cases total. Each case starts with the keyword case followed by
    a value and a colon, as shown at ➋ . If a case statement matches the control expression,
    the code just after the case will run. Each case must have at least one line of
    code, or you’ll get an error. In this example, switch is used to change the string
    assigned to the variable studentProject from "To be determined" to the string
    in the case that matches the control expression.
  id: totrans-5088
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-5089
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-5090
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-5091
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-5092
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5093
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-5094
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-5095
  prefs: []
  type: TYPE_IMG
- en: Note that you can have multiple cases all do the same thing. You can see that
    students in grades 6, 7, and 8 all get to choose their own projects ➌ . We specify
    this by writing the keyword case and then a comma-separated list of values.
  id: totrans-5096
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-5097
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-5098
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-5099
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-5101
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-5102
  prefs: []
  type: TYPE_IMG
- en: Finally, a switch statement must account for every possible case or value of
    the control expression. In our example, because studentGrade is an Int , our switch
    statement needs to have a case for all possible Int values. But this would take
    a really long time to write since there are so many! For example, –7 is an Int
    , as is 1,000\. Do you really want to write 1,000 cases?
  id: totrans-5103
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-5104
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-5105
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-5107
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-5108
  prefs: []
  type: TYPE_IMG
- en: 'Instead of writing a separate case for every value, you can use the keyword
    default as the last case, as we did at ➍ . You simply type default followed by
    a colon (default: ) and then whatever code you want to run if none of the other
    cases match. Notice that the default case doesn’t have the word case in front
    of it. The default case is really helpful for taking care of values that you might
    not expect and lets you avoid writing so many case statements. In this example,
    we expect a value only of 1 through 8 for studentGrade , so we use the default
    case to cover all other possible values.'
  id: totrans-5109
  prefs: []
  type: TYPE_NORMAL
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-5110
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-5112
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-5113
  prefs: []
  type: TYPE_IMG
- en: Try running this switch statement and see what you get. Then try changing the
    values to test for different conditions. Play around with it!
  id: totrans-5114
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-5116
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-5117
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-5118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-5119
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg)'
  id: totrans-5120
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you learned how to program the computer to make choices based
    on conditions using if and switch statements. You learned how to write Boolean
    expressions and compound expressions, and about the different comparison operators.
    Conditional statements are an essential programming tool and are seen in almost
    every useful program. In [Chapter 4](text00014.html#ch04) , we’re going to tackle
    another important type of programming statement—the loop. Loops tell the computer
    to do something over and over again until it is time to stop the loop.
  id: totrans-5121
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00090.jpg) ![image](Image00090.jpg)'
  id: totrans-5122
  prefs: []
  type: TYPE_IMG
