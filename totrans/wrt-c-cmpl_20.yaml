- en: '![](../images/pg484.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg484.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-42.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-42.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">18</samp> <samp class="SANS_Dogma_OT_Bold_B_11">STRUCTURES</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">18</samp> <samp class="SANS_Dogma_OT_Bold_B_11">结构体</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: 'In this chapter, you’ll add one final language feature: structures. You’ll
    also implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operators to access structure
    members. In a fitting end to [Part II](part2.xhtml), you’ll draw on many of the
    skills, concepts, and techniques you learned in earlier chapters. In the identifier
    resolution stage, you’ll resolve structure tags along with function and variable
    identifiers. In the type checker, you’ll record structure definitions in a type
    table, much like you already record function and variable declarations in the
    symbol table. During TACKY generation, you’ll build on the strategy you used in
    [Chapter 14](chapter14.xhtml) to handle operations on dereferenced pointers and
    other objects. And on the backend, you’ll implement the part of the System V calling
    convention that specifies how to pass structures as function parameters and return
    values. Since unions are a close cousin to structures, you might want to implement
    those too. We won’t cover them in detail, but you can add them as an extra credit
    feature.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将添加一个最终的语言特性：结构体。你还将实现 <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> 运算符来访问结构成员。在[第二部分](part2.xhtml)的恰当结尾，你将运用前几章学到的许多技能、概念和技术。在标识符解析阶段，你将解析结构标签以及函数和变量标识符。在类型检查器中，你将像记录函数和变量声明在符号表中一样，在类型表中记录结构定义。在TACKY生成过程中，你将基于[第14章](chapter14.xhtml)中处理解引用指针和其他对象操作的策略进行扩展。而在后端，你将实现System
    V调用约定中指定如何将结构体作为函数参数和返回值传递的部分。由于联合体与结构体关系密切，你可能也想实现它们。我们不会详细讨论，但你可以将它们作为额外功能添加进去。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Declaring Structure Types</samp>'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">声明结构类型</samp>'
- en: You have to declare a structure type before you can use it. There are two kinds
    of structure type declarations. The first, shown in [Listing 18-1](chapter18.xhtml#list18-1),
    specifies the structure’s members.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在使用结构类型之前先声明它。结构类型声明有两种形式。第一种，如[清单 18-1](chapter18.xhtml#list18-1)所示，指定了结构的成员。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-1: A complete structure
    type declaration</samp>'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-1：一个完整的结构类型声明</samp>
- en: 'This listing declares a complete structure type with two members: a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. The identifier
    <samp class="SANS_TheSansMonoCd_W5Regular_11">complete_struct</samp> is this type’s
    *tag*, which we can use to specify the type later in the program. A complete structure
    type must have at least one member, so it’s illegal to declare a structure type
    with an empty member list:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单声明了一个包含两个成员的完整结构类型：一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    类型和一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 类型。标识符 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">complete_struct</samp> 是这个类型的 *标签*，我们可以在程序中稍后使用它来指定类型。一个完整的结构类型必须至少有一个成员，因此声明一个没有成员的结构类型是非法的：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The second kind of structure type declaration, shown in [Listing 18-2](chapter18.xhtml#list18-2),
    specifies a structure’s tag but not its members.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种结构类型声明，如[清单 18-2](chapter18.xhtml#list18-2)所示，指定了结构的标签，但没有指定其成员。
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-2: An incomplete
    structure type declaration</samp>'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-2：一个不完整的结构类型声明</samp>
- en: '[Listing 18-2](chapter18.xhtml#list18-2) declares an incomplete structure type.
    As you learned in the previous chapter, you can use incomplete types only in certain
    limited circumstances. For example, you can’t define a variable of type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct incomplete_struct</samp>, but you
    can define a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    incomplete_struct</samp>. (That’s because we know how much memory a pointer requires,
    but not how much memory this structure requires.) We’ll say that a structure declaration
    with no member list *declares* a type, while a structure declaration with a member
    list both *declares* and *defines* a type. This differs from the terminology you’ll
    see in the C standard and elsewhere; in particular, when people talk about “type
    definitions,” they usually mean aliases introduced with the <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    keyword.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 18-2](chapter18.xhtml#list18-2) 声明了一个不完整的结构类型。正如你在上一章学到的，你只能在某些有限的情况下使用不完整类型。例如，你不能定义一个类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct incomplete_struct</samp>
    的变量，但你可以定义一个指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct incomplete_struct</samp>
    的指针。（这是因为我们知道指针需要多少内存，但不知道这个结构需要多少内存。）我们可以说，带有成员列表的结构声明同时*声明*和*定义*了一个类型，而没有成员列表的结构声明仅仅*声明*了一个类型。这与
    C 标准以及其他地方的术语不同；特别是，当人们谈到“类型定义”时，他们通常指的是使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    关键字引入的别名。'
- en: Structure tags are visible only in the scope in which they’re declared, just
    like function and variable names. If a structure tag is declared at file scope,
    it’s visible from the point where it’s declared until the end of the file. If
    it’s declared at block scope, it’s visible until the end of the block. If two
    structure type declarations with the same tag appear in the same scope, they always
    declare the same type; if they appear in different scopes, they declare distinct
    types. (Type declarations don’t have linkage, so you can’t apply the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> keywords to them.)
    You can declare the same structure type multiple times, but you can’t define it
    more than once.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 结构标签仅在声明它们的作用域内可见，就像函数和变量名称一样。如果一个结构标签在文件作用域中声明，它从声明点开始一直可见直到文件末尾。如果它在块作用域中声明，它会一直可见直到块的末尾。如果在同一作用域中出现两个相同标签的结构类型声明，它们总是声明相同的类型；如果它们出现在不同的作用域中，则声明的是不同的类型。（类型声明没有链接性，所以你不能对它们应用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>
    关键字。）你可以多次声明相同的结构类型，但不能多次定义它。
- en: A structure type is complete once its definition is in scope, as [Listing 18-3](chapter18.xhtml#list18-3)
    illustrates.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦结构的定义在作用域内，它的类型就变成完整的，正如 [列表 18-3](chapter18.xhtml#list18-3) 所示。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-3: Declaring an
    incomplete type and then completing it</samp>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 18-3：声明一个不完整的类型并将其完成</samp>
- en: Between ❶ and ❷, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>
    is an incomplete type. It wouldn’t be legal to define a variable with type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> between these two points
    in the program, but it’s legal to define <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>,
    which is a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>.
    After the end of the type declaration that specifies its member list ❷, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> is a complete type, so
    it’s legal to define a variable with that type ❸.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❶ 和 ❷ 之间，<samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> 是一个不完整类型。在程序的这两点之间，定义类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> 的变量是不合法的，但定义 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>（指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> 的指针）是合法的。在指定其成员列表的类型声明结束之后 ❷，<samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> 成为一个完整类型，因此可以合法地定义该类型的变量 ❸。
- en: When the same structure tag is declared in two different scopes, one can shadow
    the other, as [Listing 18-4](chapter18.xhtml#list18-4) illustrates.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当相同的结构标签在两个不同的作用域中声明时，一个可以遮蔽另一个，正如 [列表 18-4](chapter18.xhtml#list18-4) 所示。
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-4: One structure
    type shadowing another</samp>'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 18-4：一个结构类型遮蔽另一个结构类型</samp>
- en: 'First, we define a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>
    type at file scope ❶. Its size is 4 bytes because it contains a single <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    The first <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expression
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> refers to this type
    ❷. Then, we define another <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> type at block scope ❸, shadowing the first type. This type contains a
    single <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, so its size
    is 8 bytes. The two definitions of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> don’t conflict, because they appear in different scopes. In the second
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expression ❹, the
    specifier <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> refers
    to the 8-byte structure type defined in the inner scope. Running this program
    gives the following output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在文件作用域中定义一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>
    类型 ❶。它的大小为 4 字节，因为它只包含一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 中的第一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    表达式引用了这个类型 ❷。然后，我们在块作用域中定义另一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> 类型 ❸，遮蔽了第一个类型。这个类型只包含一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>，因此它的大小为
    8 字节。两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> 的定义不会冲突，因为它们出现在不同的作用域中。在第二个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 表达式 ❹ 中，指定符 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> 引用的是内部作用域中定义的 8 字节结构体类型。运行该程序会输出以下内容：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Even when a structure’s tag is shadowed, its members are still visible. Consider
    [Listing 18-5](chapter18.xhtml#list18-5).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 即使结构体的标签被遮蔽，它的成员仍然是可见的。请参见 [示例 18-5](chapter18.xhtml#list18-5)。
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-5: Using a variable
    with a shadowed structure type</samp>'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 18-5：使用一个带有遮蔽结构类型的变量</samp>
- en: In this listing, we first declare a structure type, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    shadow</samp> ❶. Then, we define a variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">outer</samp>,
    with that type. In the inner scope, we declare another structure type with the
    same tag ❷, which shadows the outer declaration. We then declare a variable with
    this new type, <samp class="SANS_TheSansMonoCd_W5Regular_11">inner</samp>. In
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement, we
    can still access the members of both variables ❸. Even in the inner scope, the
    compiler knows about the original <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    shadow</samp> type, and it still knows that <samp class="SANS_TheSansMonoCd_W5Regular_11">outer</samp>
    belongs to that type; we just can’t specify that type with the <samp class="SANS_TheSansMonoCd_W5Regular_11">shadow</samp>
    tag.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先声明一个结构体类型，<samp class="SANS_TheSansMonoCd_W5Regular_11">struct shadow</samp>
    ❶。然后，我们用该类型定义一个变量，<samp class="SANS_TheSansMonoCd_W5Regular_11">outer</samp>。在内部作用域中，我们声明另一个具有相同标签的结构体类型
    ❷，它会遮蔽外部的声明。接着，我们用这个新类型声明一个变量，<samp class="SANS_TheSansMonoCd_W5Regular_11">inner</samp>。在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句中，我们仍然可以访问两个变量的成员
    ❸。即使在内部作用域中，编译器仍然知道原始的 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct shadow</samp>
    类型，并且仍然知道 <samp class="SANS_TheSansMonoCd_W5Regular_11">outer</samp> 属于该类型；我们只是不可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">shadow</samp> 标签来指定该类型。
- en: 'To keep all our structure types straight, we’ll treat structure tags a lot
    like variable names: in the identifier resolution pass, we’ll replace each user-defined
    tag with a unique identifier.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持所有结构体类型的一致性，我们将像处理变量名一样处理结构体标签：在标识符解析阶段，我们将用一个唯一标识符替换每个用户定义的标签。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Structure Member
    Declarations</samp>
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">结构体成员声明</samp>
- en: The members of a structure can have any complete type, including primitive types
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and derived types
    like arrays, pointers, or other structures. It’s illegal to declare a structure
    member with an incomplete type, however, because that makes it impossible to determine
    the size of the whole structure. This implies, as section 6.7.2.1, paragraph 3,
    of the C standard puts it, that “a structure shall not contain an instance of
    itself.” That is, a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>
    can’t contain a member of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp>. On the other hand, a structure can contain a pointer to itself because
    pointer types are always complete. The canonical example, shown in [Listing 18-6](chapter18.xhtml#list18-6),
    is a node in a linked list, which holds a value and a pointer to the next list
    entry.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体的成员可以是任何完整类型，包括原始类型如<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，以及派生类型如数组、指针或其他结构体。然而，声明一个不完整类型的结构体成员是非法的，因为这样会导致无法确定整个结构体的大小。正如C标准第6.7.2.1节第3段所说：“结构体不能包含其自身的实例。”也就是说，一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>不能包含类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp>的成员。另一方面，结构体可以包含指向自身的指针，因为指针类型总是完整的。经典的示例，如[Listing 18-6](chapter18.xhtml#list18-6)所示，是一个链表节点，它包含一个值和指向下一个列表条目的指针。
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-6: A structure type
    definition that contains a pointer to itself</samp>'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-6：包含指向自身指针的结构体类型定义</samp>
- en: After ❶, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct linked_list_node</samp>
    is visible as an incomplete type, so we can declare the member <samp class="SANS_TheSansMonoCd_W5Regular_11">next</samp>
    as a pointer to this type. After ❷, the type is complete.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在❶之后，<samp class="SANS_TheSansMonoCd_W5Regular_11">struct linked_list_node</samp>作为不完整类型是可见的，因此我们可以将成员<samp
    class="SANS_TheSansMonoCd_W5Regular_11">next</samp>声明为指向该类型的指针。在❷之后，该类型是完整的。
- en: It’s also illegal to declare functions as structure members. A structure can
    hold function pointers—which are complete types, just like any other pointer—but
    we don’t support function pointers, so that doesn’t matter to us.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 声明函数作为结构体成员也是不合法的。结构体可以包含函数指针——它们是完整类型，就像任何其他指针一样——但我们不支持函数指针，因此这对我们来说并不重要。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tag and Member Namespaces</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">标签和成员命名空间</samp>
- en: Structure tags are in a different namespace from functions and variables. This
    means the same identifier can be used as both a tag and a function or variable
    name, and neither identifier will shadow or conflict with the other. It’s perfectly
    legal, for example, to declare the type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> and a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    in the same scope. It’s possible to maintain these separate namespaces because
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> keyword tells
    the compiler that a particular identifier is a structure tag.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体标签位于与函数和变量不同的命名空间中。这意味着相同的标识符可以同时用作标签和函数或变量名，并且这两个标识符不会相互遮蔽或冲突。例如，在同一作用域内声明类型<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>和变量<samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>是完全合法的。之所以能保持这些独立的命名空间，是因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>关键字告诉编译器，某个特定的标识符是结构体标签。
- en: 'Similarly, each structure member list is its own namespace. A structure member
    can share a name with any function, variable, or structure type, including the
    structure type that contains it, like in the following example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，每个结构体成员列表都有自己的命名空间。结构体成员可以与任何函数、变量或结构体类型共享名称，包括包含它的结构体类型，如以下示例所示：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It’s also legal for members in different structures to have the same name:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不同结构体中的成员也可以拥有相同的名称：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When the identifier <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> appears
    in an expression, like <samp class="SANS_TheSansMonoCd_W5Regular_11">var->x</samp>,
    the compiler can figure out from context whether it refers to the member in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">s1</samp>, the member in <samp class="SANS_TheSansMonoCd_W5Regular_11">s2</samp>,
    or a function or variable. Unsurprisingly, it’s illegal for two members of the
    same structure to share a name.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当标识符 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 出现在表达式中，比如 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">var->x</samp> 时，编译器可以从上下文中推断出它是指 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">s1</samp> 中的成员、<samp class="SANS_TheSansMonoCd_W5Regular_11">s2</samp>
    中的成员，还是一个函数或变量。毫不意外，同一结构体的两个成员不能共享相同的名称。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Structure Type Declarations
    We Aren’t Implementing</samp>
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">我们没有实现的结构体类型声明</samp>
- en: C syntax doesn’t distinguish between structure type specifiers and type declarations,
    so you can simultaneously declare a new structure type and use that structure
    type in some larger construct. In [Listing 18-7](chapter18.xhtml#list18-7), for
    example, a single declaration defines a new structure type, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp>, and a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: C 语法不会区分结构体类型说明符和类型声明，因此你可以同时声明一个新的结构体类型，并在某个更大的构造中使用该结构体类型。例如，在[清单 18-7](chapter18.xhtml#list18-7)中，一个声明定义了一个新的结构体类型，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>，以及一个类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> 的变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>。
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-7: Defining and
    specifying a structure type in the same declaration</samp>'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-7：在同一个声明中定义并指定结构体类型</samp>
- en: 'To simplify parsing and semantic analysis, we’ll require every declaration
    to declare exactly one function, variable, or type. We won’t support declarations
    like [Listing 18-7](chapter18.xhtml#list18-7) that declare a new type and some
    other entity at the same time. This goes for incomplete types as well. The C standard
    lets you implicitly declare an incomplete structure type, just by specifying it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化解析和语义分析，我们要求每个声明必须只声明一个函数、变量或类型。我们不支持像[清单 18-7](chapter18.xhtml#list18-7)中那样同时声明新类型和其他实体的声明。这也适用于不完整类型。C
    标准允许你仅通过指定它来隐式声明一个不完整的结构体类型：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Even if <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> hasn’t
    yet been declared, this declaration is legal: it simultaneously declares <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> as an incomplete type
    and declares a function that returns a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp>. However, our implementation won’t permit this. Instead, we’ll require
    a separate declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> first:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> 尚未声明，该声明仍然是合法的：它同时将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> 声明为一个不完整类型，并声明了一个返回指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> 的指针的函数。然而，我们的实现不允许这样做。相反，我们要求首先声明
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Requiring types to be declared before they’re used also implies that you can’t
    nest one structure declaration inside another, like in [Listing 18-8](chapter18.xhtml#list18-8).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要求类型在使用之前声明，也意味着你不能在另一个结构体声明内嵌套一个结构体声明，像[清单 18-8](chapter18.xhtml#list18-8)中那样。
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-8: Declaring an</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">inner</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">structure
    type and declaring member</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">i</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">with that type in the same declaration</samp>'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-8：在同一个声明中声明</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">内部</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">结构体类型并声明具有该类型的成员</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">i</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">的声明</samp>
- en: We’ll impose a few other restrictions too. We’ll reject structure declarations
    without tags and structure members without names, even though the C standard permits
    them. We also won’t support *bit-field members*, which make it possible to address
    individual bits within a structure.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会施加一些其他限制。我们将拒绝没有标签的结构体声明和没有名称的结构体成员，尽管 C 标准允许它们。我们也不支持 *位字段成员*，这使得可以在结构体内对单个比特进行寻址。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Operating on Structures</samp>
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">操作结构体</samp>
- en: 'You can access the members of a structure with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    operator:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> 运算符访问结构体的成员：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you have a pointer to a structure, you can access the structure’s members
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operator. Continuing
    with the same example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个指向结构体的指针，你可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    运算符访问结构体的成员。继续使用相同的例子：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can apply the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operators only to complete
    structure types. You can’t access the members of an incomplete structure type,
    since those members haven’t been defined yet.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能对完整的结构体类型使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-></samp> 运算符。你不能访问不完整结构体类型的成员，因为这些成员尚未定义。
- en: Structures are aggregate types, like arrays. But structures don’t decay to pointers
    like arrays do, so you can use them in several ways that you can’t use arrays.
    For example, you can pass them as function arguments and return values. You can
    also assign to them, like in [Listing 18-9](chapter18.xhtml#list18-9).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体是聚合类型，像数组一样。但结构体不像数组那样会退化为指针，因此你可以以几种不能用于数组的方式使用它们。例如，你可以将它们作为函数参数和返回值。你还可以像
    [示例 18-9](chapter18.xhtml#list18-9) 中那样进行赋值。
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-9: Assigning to
    a structure</samp>'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 18-9：赋值给结构体</samp>
- en: 'You can assign to individual members of a structure too, as long as they’re
    lvalues. A structure member specified with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    operator is always an lvalue:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将值赋给结构体的单个成员，只要它们是左值。通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    运算符指定的结构体成员始终是左值：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Recall that all dereferenced pointers are lvalues. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    operator produces a dereferenced pointer, much like the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp> operators do, so the
    same rules apply.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，所有解引用的指针都是左值。<samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> 运算符产生一个解引用指针，就像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>
    运算符一样，因此同样的规则适用。
- en: 'If a structure is an lvalue, any members you access with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    operator are lvalues too. If a structure isn’t an lvalue, neither are its members.
    Therefore, this assignment expression is legal:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结构体是左值，那么你通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> 运算符访问的任何成员也是左值。如果结构体不是左值，那么它的成员也不是左值。因此，以下赋值表达式是合法的：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'But, because the result of a function call isn’t an lvalue, this is illegal:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，由于函数调用的结果不是左值，因此这是非法的：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Structures can appear in a few other expressions, pretty much where you’d expect.
    They can appear in the branches of conditional expressions, as long as both branches
    have the same structure type. You can get their size with <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    and cast them to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, but
    you can’t otherwise cast to or from structure types. And if a structure or structure
    member is an lvalue, you can take its address.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体还可以出现在其他一些表达式中，基本上是你预期出现的地方。它们可以出现在条件表达式的分支中，只要两个分支有相同的结构体类型。你可以使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 获取它们的大小，并将它们转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>，但你不能将它们转换为或从结构体类型进行转换。如果一个结构体或结构体成员是左值，你可以获取它的地址。
- en: 'There are two ways to initialize a structure. You can initialize it with an
    expression of the same structure type:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化结构体有两种方式。你可以使用与结构体类型相同的表达式进行初始化：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Or, you can use a compound initializer to initialize each member individually,
    like in [Listing 18-10](chapter18.xhtml#list18-10).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用复合初始化器单独初始化每个成员，像 [示例 18-10](chapter18.xhtml#list18-10) 中那样。
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-10: Initializing
    a structure with a compound initializer</samp>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 18-10：使用复合初始化器初始化结构体</samp>
- en: A compound initializer initializes a structure’s members in order. The initializer
    in [Listing 18-10](chapter18.xhtml#list18-10) initializes <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp>
    with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">2.0</samp>.
    The inner compound initializer initializes the three array elements in <samp class="SANS_TheSansMonoCd_W5Regular_11">array_member</samp>
    ❶. Note that compound initializers for arrays and structures have identical syntax.
    (The syntax for *designated initializers*, which initialize specific subobjects
    in an aggregate object, is different for array elements and structure members,
    but we won’t implement designated initializers.) By nesting compound initializers,
    you can initialize arrays of structures, structures that contain other structures,
    and so on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 复合初始化器按顺序初始化结构的成员。[清单 18-10](chapter18.xhtml#list18-10)中的初始化器将<sup class="SANS_TheSansMonoCd_W5Regular_11">member1</samp>初始化为<sup
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，将<sup class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>初始化为<sup
    class="SANS_TheSansMonoCd_W5Regular_11">2.0</samp>。[清单 18-10](chapter18.xhtml#list18-10)中的内嵌复合初始化器初始化<sup
    class="SANS_TheSansMonoCd_W5Regular_11">array_member</sup>中的三个数组元素 ❶。请注意，数组和结构的复合初始化器具有相同的语法。（用于*指定初始化器*的语法，它用于初始化聚合对象中的特定子对象，数组元素和结构成员的语法不同，但我们不会实现指定初始化器。）通过嵌套复合初始化器，你可以初始化结构数组、包含其他结构的结构等。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Structure Layout in Memory</samp>
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">结构在内存中的布局</samp>
- en: At this point, we have a pretty good sense of how structure types work in source
    code. Now let’s look at how they’re laid out in memory at runtime. This is specified
    partly by the C standard and partly by the System V ABI. It’s important to lay
    out structures exactly as the ABI specifies so that the code we compile can interoperate
    with other code that uses structures.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经对结构类型在源代码中的工作方式有了相当清晰的理解。现在让我们来看一下它们在运行时内存中的布局。内存布局部分由 C 标准规定，部分由
    System V ABI 规定。按照 ABI 的规定精确布局结构非常重要，这样我们编译的代码才能与其他使用结构的代码进行互操作。
- en: A structure’s members appear in the same order in memory as in the original
    structure declaration. The first member must have the same address as the structure
    as a whole; you can always convert a pointer to a structure into a pointer to
    its first member, and vice versa. Each subsequent member will be stored at the
    earliest free address with the correct alignment. Let’s use the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    example</samp> type from [Listing 18-10](chapter18.xhtml#list18-10) as an example.
    [Listing 18-11](chapter18.xhtml#list18-11) reproduces the definition of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct example</samp>.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 结构的成员在内存中的顺序与原始结构声明中的顺序相同。第一个成员必须具有与整个结构相同的地址；你总是可以将结构的指针转换为指向其第一个成员的指针，反之亦然。每个后续成员将存储在正确对齐的最早可用地址处。我们以[清单
    18-10](chapter18.xhtml#list18-10)中的<samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    example</samp>类型为例。[清单 18-11](chapter18.xhtml#list18-11)重复了<samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    example</samp>的定义。
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-11: A structure
    type with several members with different alignments</samp>'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-11：一个具有不同对齐方式的多个成员的结构类型</samp>
- en: The first member must start at the very beginning of the structure. Because
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp> is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    it occupies the structure’s first 4 bytes. Bytes in a structure are typically
    zero-indexed, so we’ll say that <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp>
    occupies bytes 0 through 3\. The next unused space is therefore at byte 4\. But
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    which is 8-byte aligned; its starting address must be a multiple of 8\. Therefore,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> will be stored in
    bytes 8 through 15\. We say that <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>
    has an offset of 8 bytes from the start of the structure. Between <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>, in bytes 4 through
    7, we have 4 bytes of padding.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个成员必须从结构的最开始处开始。因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp>
    是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型，它占用了结构的前4个字节。结构中的字节通常是零索引的，因此我们可以说
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp> 占用了字节 0 到 3。接下来的空闲空间因此位于字节
    4。但是 <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> 是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    类型，它需要 8 字节对齐；它的起始地址必须是 8 的倍数。因此，<samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>
    会存储在字节 8 到 15 之间。我们说 <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>
    从结构的起始位置有 8 字节的偏移。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> 之间，即字节 4 到 7 之间，我们有
    4 字节的填充。
- en: The last member, <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>,
    takes up 3 bytes and has an alignment of 1 byte. Since we don’t need any padding
    to align it correctly, we’ll store it right after <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>,
    in bytes 16 through 18.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的成员 <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> 占用了 3 个字节，且对齐方式为
    1 字节。由于我们不需要任何填充来正确对齐它，因此我们将其直接存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>
    后面，即字节 16 到 18 之间。
- en: We’ll also need padding at the end of the structure, after <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>.
    According to the System V ABI, the size of a type must be a multiple of its alignment.
    The ABI also states that a structure takes on the same alignment as its most strictly
    aligned member. The most strictly aligned member of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    example</samp> is the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>. Therefore, the whole
    structure must be 8-byte aligned, and its size must be a multiple of 8\. The three
    members of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct example</samp>
    and the padding between them occupy 19 bytes. We’ll add 5 bytes of padding to
    the end of the structure, bringing its total size to 24 bytes. [Figure 18-1](#fig18-1)
    illustrates the layout of the whole structure.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构的末尾，即 <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> 后面，我们还需要填充。根据
    System V ABI，一个类型的大小必须是其对齐方式的倍数。ABI 还指出，结构体必须具有与其对齐最严格成员相同的对齐方式。<samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    example</samp> 的最严格对齐成员是 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    类型的 <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>。因此，整个结构体必须是 8
    字节对齐的，且其大小必须是 8 的倍数。<samp class="SANS_TheSansMonoCd_W5Regular_11">struct example</samp>
    的三个成员及它们之间的填充共占用 19 个字节。我们将在结构体的末尾添加 5 个字节的填充，将其总大小调整为 24 字节。[图 18-1](#fig18-1)
    展示了整个结构的布局。
- en: '![](../images/fig18-1.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig18-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-1: The structure
    layout in memory [Description](description-43.xhtml)</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图18-1：内存中的结构布局 [描述](description-43.xhtml)</samp>
- en: The padding between members guarantees that each member will end up at a correctly
    aligned memory address. If the starting address of the entire structure is a multiple
    of 8 and the offset of <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>
    from the start is also a multiple of 8, we know that <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>’s
    runtime memory address will be a multiple of 8 too. The padding at the end of
    the structure guarantees that each element in an array of structures will have
    the correct alignment; if the initial element in an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    example</samp> objects is 8-byte aligned and its total size is 24 bytes, each
    subsequent element will be 8-byte aligned as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 成员之间的填充保证了每个成员最终会出现在正确对齐的内存地址。如果整个结构体的起始地址是 8 的倍数，并且 <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>
    从起始位置的偏移量也是 8 的倍数，那么我们可以知道 <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>
    的运行时内存地址也将是 8 的倍数。结构体末尾的填充保证了结构体数组中的每个元素都将正确对齐；如果一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    example</samp> 对象数组的第一个元素是 8 字节对齐，并且其总大小为 24 字节，那么每个后续元素也将是 8 字节对齐的。
- en: Now that you understand how to work with structures in C and how they’re laid
    out in memory, let’s get to work on implementing them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了如何在 C 中使用结构体以及它们在内存中的布局，我们开始着手实现它们吧。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">词法分析器</samp>
- en: 'You’ll add three new tokens in this chapter:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你将添加三个新令牌：
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">struct</samp> | A keyword indicating
    a structure type specifier |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">struct</samp> | 一个关键字，表示结构体类型说明符
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">.</samp> | A period, the structure
    member access operator |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">.</samp> | 一个句点，表示结构体成员访问运算符
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-></samp> | An arrow, the operator
    to access a structure member through a pointer |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-></samp> | 一个箭头运算符，用于通过指针访问结构体成员
    |'
- en: Keep in mind that a period can be either a structure member access operator
    or part of a floating-point constant. We’ll recognize a period as a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    token only if it’s followed by a non-digit character. If a period is followed
    by a digit, either it’s the start of a floating-point constant or it’s invalid.
    For example, if the lexer sees the input <samp class="SANS_TheSansMonoCd_W5Regular_11">.100u</samp>,
    it should try to parse this as a constant. It will then raise an error, since
    this doesn’t match the regular expression for any kind of constant. It should
    *not* lex this as a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> token
    followed by the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">100u</samp>.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，句点可以是结构体成员访问运算符，也可以是浮动点常量的一部分。我们只有在句点后跟着一个非数字字符时，才会将它识别为 <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    令牌。如果句点后跟着数字，那么它要么是浮动点常量的开始，要么是无效的。例如，如果词法分析器看到输入 <samp class="SANS_TheSansMonoCd_W5Regular_11">.100u</samp>，它应尝试将其解析为常量。然后它会报错，因为这不符合任何常量的正则表达式。它**不**应该把这个解析为一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> 令牌后面跟着常量 <samp class="SANS_TheSansMonoCd_W5Regular_11">100u</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">语法分析器</samp>
- en: 'We’ll add several new constructs to the AST in this chapter: structure declarations,
    structure type specifiers, and the two new structure operators. [Listing 18-12](chapter18.xhtml#list18-12)
    gives the AST definition for structure declarations.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向 AST 添加几个新构造：结构体声明、结构类型说明符和两个新的结构体运算符。[清单 18-12](chapter18.xhtml#list18-12)
    给出了结构声明的 AST 定义。
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-12: Representing
    structure declarations in the AST</samp>'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-12：在 AST 中表示结构声明</samp>
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_declaration</samp> consists
    of a tag and a list of members. To represent an incomplete structure type declaration,
    we’ll leave the member list empty. (Remember that a complete structure type must
    have at least one member.) We’ll represent each member with a <samp class="SANS_TheSansMonoCd_W5Regular_11">member_declaration</samp>,
    which includes a member name and a type.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_declaration</samp> 包含一个标签和一系列成员。为了表示一个不完整的结构类型声明，我们将把成员列表留空。（记住，完整的结构类型必须至少有一个成员。）我们将用一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member_declaration</samp> 来表示每个成员，其中包括成员名称和类型。
- en: 'Next, we’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp>
    AST node to support structure type declarations as well as function and variable
    declarations:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将扩展 <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp> AST
    节点，以支持结构类型声明以及函数和变量声明：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We’ll also extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    AST node to include structure type specifiers like <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp>:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将扩展 <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> AST 节点，以包含像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> 这样的结构类型说明符：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we’ll add two new expressions: the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operators, sometimes
    called the *structure member operator* and *structure pointer operator*, respectively.
    We’ll use the more concise names <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加两个新表达式：<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-></samp> 运算符，有时分别称为 *结构成员运算符* 和 *结构指针运算符*。我们将使用更简洁的名称
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Each of these operators takes an expression as its first operand and the name
    of a structure member as its second operand. [Listing 18-13](chapter18.xhtml#list18-13)
    defines the complete AST, with this chapter’s changes bolded.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符中的每一个都将一个表达式作为第一个操作数，结构成员的名称作为第二个操作数。[清单 18-13](chapter18.xhtml#list18-13)
    定义了完整的 AST，并以粗体突出显示了本章的更改。
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-13: The abstract
    syntax tree with structure types and the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">-></samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">operators</samp>'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-13：带有结构类型的抽象语法树及</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">和</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">-></samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">运算符</samp>
- en: '[Listing 18-14](chapter18.xhtml#list18-14) shows the corresponding changes
    to the grammar.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 18-14](chapter18.xhtml#list18-14) 显示了语法的相应变化。'
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-14: The grammar
    with structure types and the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">-></samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">operators</samp>'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-14：带有结构类型的语法及</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">.</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">和</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">-></samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">运算符</samp>
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11"><struct-declaration></samp>
    may include a brace-enclosed list of structure members ❶. This member list is
    optional, but if the braces are present they must contain at least one member.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 <samp class="SANS_TheSansMonoCd_W5Regular_11"><struct-declaration></samp>
    可能包含一个由大括号括起来的结构成员列表 ❶。这个成员列表是可选的，但如果存在大括号，它们必须包含至少一个成员。
- en: 'A structure member declaration has the same form as a variable declaration;
    it includes a list of type specifiers and a declarator and ends with a semicolon.
    Unlike a variable declaration, however, a structure member can’t have an initializer
    or a storage class. We’ll impose one syntactic requirement that isn’t reflected
    in the grammar: the parser should reject function declarators in structure member
    declarations, even though the <samp class="SANS_TheSansMonoCd_W5Regular_11"><member
    -declaration></samp> grammar rule allows them. For example, the parser should
    reject this declaration:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 结构成员声明的形式与变量声明相同；它包括一个类型说明符列表和一个声明符，并以分号结束。然而，与变量声明不同，结构成员不能有初始化器或存储类。我们将施加一个语法要求，尽管语法中并未体现：解析器应拒绝结构成员声明中的函数声明符，尽管
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><member -declaration></samp> 语法规则允许它们。例如，解析器应拒绝以下声明：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A structure type specifier consists of two tokens: the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    keyword and an identifier token, which specifies the structure tag. This specifier
    can’t be combined with other type specifiers, but it can be modified by a pointer,
    array, or function declarator.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 结构类型说明符由两个标记组成：<samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> 关键字和一个标识符标记，指定结构标签。该说明符不能与其他类型说明符结合使用，但可以通过指针、数组或函数声明符进行修饰。
- en: The new <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    operators are postfix operators, like the subscript operator we added in [Chapter
    15](chapter15.xhtml). All three postfix operators have higher precedence than
    any prefix operator. The new <samp class="SANS_TheSansMonoCd_W5Regular_11"><postfix-op></samp>
    symbol includes all three operators, which ensures that they’re all parsed with
    the correct precedence.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    操作符是后缀操作符，类似于我们在[第15章](chapter15.xhtml)中添加的下标操作符。所有这三种后缀操作符的优先级都高于任何前缀操作符。新的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><postfix-op></samp> 符号包括了所有三个操作符，这确保了它们会以正确的优先级进行解析。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp>
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">语义分析</samp>
- en: We haven’t made any substantive changes to the identifier resolution pass in
    a while. Now we’ll have it resolve structure tags along with function and variable
    names. This pass will assign every structure type a unique ID, replacing its original
    user-defined tag. It will also throw an error if a program tries to specify a
    structure type before declaring it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一段时间没有对标识符解析过程做出实质性改动了。现在，我们将让它解析结构标签以及函数和变量名称。这个过程将为每个结构类型分配一个唯一的ID，替换掉它原来的用户定义标签。如果程序在声明结构之前尝试指定结构类型，系统也会抛出错误。
- en: In the type checker, we’ll introduce a new table to track structure definitions.
    We’ll refer to these definitions when we type check initializers, member access
    operators, and other operations on structures. We’ll also use them to generate
    TACKY and assembly in later stages.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型检查器中，我们将引入一个新的表格来跟踪结构定义。当我们对初始化器、成员访问操作符以及其他结构操作进行类型检查时，我们会参考这些定义。我们还将在后续阶段使用它们来生成TACKY和汇编代码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Resolving Structure
    Tags</samp>
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">解析结构标签</samp>
- en: Let’s walk through how to handle structure tags during identifier resolution.
    We’ll rename these tags in basically the same way that we rename local variables.
    We’ll maintain a map from user-defined tags to unique identifiers. When we find
    a declaration of a new structure type, we’ll generate a new identifier and add
    it to the map. And when we encounter a structure type specifier, we’ll replace
    it with the corresponding unique identifier from the map. Because structure tags
    exist in a separate namespace from functions and variables, we’ll track them in
    a separate map.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何在标识符解析过程中处理结构标签。我们将以基本相同的方式重命名这些标签，就像我们重命名局部变量一样。我们将保持一个从用户定义标签到唯一标识符的映射。当我们找到新的结构类型声明时，我们会生成一个新的标识符并将其添加到映射中。当我们遇到结构类型说明符时，我们将用映射中对应的唯一标识符替换它。由于结构标签存在于与函数和变量不同的命名空间中，我们将把它们跟踪在一个单独的映射中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Defining the Structure Tag
    Map</samp>
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">定义结构标签映射</samp>
- en: 'In our existing identifier map, we track three pieces of information about
    each user-defined function or variable name: the unique identifier we’ll replace
    it with, whether it has linkage, and whether it was defined in the current scope.
    In the structure tag map, we’ll track each tag’s unique identifier and whether
    it was defined in the current scope, but we won’t track linkage, because that
    concept doesn’t apply to types. Go ahead and define this data structure. Then,
    we’ll look at how to resolve tags in type specifiers and declarations.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们现有的标识符映射中，我们追踪每个用户定义的函数或变量名称的三项信息：我们将替换它的唯一标识符，它是否有链接性，以及它是否在当前作用域中定义。在结构标签映射中，我们将跟踪每个标签的唯一标识符以及它是否在当前作用域中定义，但我们不会追踪链接性，因为这个概念不适用于类型。请定义这个数据结构。然后，我们将看看如何解析类型说明符和声明中的标签。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Resolving Type Specifiers</samp>
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">解析类型说明符</samp>
- en: '[Listing 18-15](chapter18.xhtml#list18-15) illustrates how to resolve a type
    specifier.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 18-15](chapter18.xhtml#list18-15) 展示了如何解析类型说明符。'
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-15: Replacing structure
    tags in a type specifier</samp>'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 18-15：在类型说明符中替换结构标签</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp> function
    accepts a type specifier and returns a copy of that specifier in which any structure
    tags have been replaced with unique IDs. When <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp>
    encounters a structure type, it replaces the tag with the corresponding identifier
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">structure_map</samp> ❶. If
    the tag isn’t in <samp class="SANS_TheSansMonoCd_W5Regular_11">structure _map</samp>,
    the structure hasn’t been declared yet, so it throws an error ❷. To resolve a
    derived type, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Pointer</samp>,
    we resolve its constituent types recursively. I’ve omitted the pseudocode for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Array</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">FunType</samp>,
    which we’ll handle the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">Pointer</samp>.
    We return any other type unchanged. We’ll process every type specifier in the
    AST with <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp>, including
    specifiers in function and variable declarations, cast and <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    expressions, and structure member declarations.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp> 函数接受一个类型说明符，并返回该说明符的副本，其中任何结构标签已被唯一
    ID 替换。当 <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp> 遇到结构类型时，它会用来自
    <samp class="SANS_TheSansMonoCd_W5Regular_11">structure_map</samp> ❶ 的相应标识符替换标签。如果标签不在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">structure_map</samp> 中，则表示该结构尚未声明，因此会抛出错误
    ❷。要解决派生类型（例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">Pointer</samp>），我们递归地解析其组成类型。我已经省略了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Array</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">FunType</samp>
    的伪代码，它们的处理方式与 <samp class="SANS_TheSansMonoCd_W5Regular_11">Pointer</samp> 相同。我们返回任何其他未变更的类型。我们将使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp> 处理 AST 中的每个类型说明符，包括函数和变量声明中的说明符、强制转换和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 表达式，以及结构成员声明。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Resolving Structure Type Declarations</samp>
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">解析结构类型声明</samp>
- en: Next, let’s look at the pseudocode in [Listing 18-16](chapter18.xhtml#list18-16),
    which illustrates how to resolve a structure type declaration.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 [Listing 18-16](chapter18.xhtml#list18-16) 中的伪代码，它展示了如何解析结构类型声明。
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-16: Adding structure
    type declarations to the structure tag map</samp>'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-16: 将结构类型声明添加到结构标签映射中</samp>'
- en: First, we look up the declaration’s tag in the structure tag map ❶. If this
    tag hasn’t been declared yet, or if it was declared in an outer scope, this declaration
    introduces a new type. We therefore generate a new identifier and add it to the
    structure tag map ❷. If the structure’s tag was already declared in the current
    scope, the current declaration just redeclares the same type. In this case, we
    don’t generate a new unique ID; instead, we use the one that’s already in the
    map ❸.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在结构标签映射中查找声明的标签 ❶。如果该标签尚未声明，或者它是在外部作用域声明的，则该声明引入了一个新类型。因此，我们生成一个新的标识符并将其添加到结构标签映射中
    ❷。如果该结构的标签已经在当前作用域中声明，则当前声明只是重新声明了相同的类型。在这种情况下，我们不会生成新的唯一 ID；相反，我们使用映射中已有的 ID
    ❸。
- en: At this point, the structure tag map is up to date. Now we transform the structure
    type declaration itself. If this declaration specifies the structure’s members,
    we resolve its member types by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp>
    on each of them ❹. We replace the declaration’s user-defined tag with <samp class="SANS_TheSansMonoCd_W5Regular_11">unique_tag</samp>,
    the ID that we generated or looked up earlier in the function. Finally, we return
    the transformed declaration ❺.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，结构标签映射已是最新的。接下来，我们转变结构类型声明本身。如果该声明指定了结构的成员，我们通过对每个成员调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp>
    来解析其成员类型 ❹。我们用 <samp class="SANS_TheSansMonoCd_W5Regular_11">unique_tag</samp>（即我们在函数中之前生成或查找的
    ID）替换声明的用户定义标签。最后，我们返回转换后的声明 ❺。
- en: 'Note that we add the new tag to <samp class="SANS_TheSansMonoCd_W5Regular_11">structure_map</samp>
    before processing any structure members. This lets us accept self-referential
    structures, like the linked list node from [Listing 18-6](chapter18.xhtml#list18-6):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在处理任何结构成员之前，将新标签添加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">structure_map</samp>
    中。这使我们能够接受自引用结构，例如来自 [Listing 18-6](chapter18.xhtml#list18-6) 的链表节点：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Also note that we don’t generate unique names for structure members. Variables
    and functions need unique identifiers because they’re all stored in a single symbol
    table, and structure tags need to be unique because they’re all stored in a single
    type table, but structure members won’t all be stored in one table. Instead, we’ll
    maintain a separate member list for each structure type, so members in different
    structures with the same name won’t conflict with each other.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，我们不会为结构体成员生成唯一名称。变量和函数需要唯一标识符，因为它们都存储在同一个符号表中，结构体标签需要唯一，因为它们都存储在同一个类型表中，但结构体成员不会全部存储在一个表中。相反，我们会为每个结构体类型维护一个单独的成员列表，因此不同结构体中具有相同名称的成员不会互相冲突。
- en: 'We’ll make two more updates to the identifier resolution pass. First, at the
    start of each new scope, we’ll make a copy of the structure tag map with each
    entry’s <samp class="SANS_TheSansMonoCd_W5Regular_11">from_current_scope</samp>
    attribute set to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>, just
    like we do for the identifier map. The second change is purely mechanical: we’ll
    extend <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> to process
    the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>
    expressions the same way it processes all the other kinds of expressions. I’ll
    skip the pseudocode for these changes, since they’re both straightforward.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对标识符解析过程进行两个更新。首先，在每个新作用域的开始，我们将复制结构体标签映射，并将每个条目的 <samp class="SANS_TheSansMonoCd_W5Regular_11">from_current_scope</samp>
    属性设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，就像我们对标识符映射所做的那样。第二个变化是纯粹的机械操作：我们将扩展
    <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> 来处理新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp> 表达式，就像它处理其他所有类型的表达式一样。我会跳过这些变化的伪代码，因为它们都很直白。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Structures</samp>
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">类型检查结构体</samp>
- en: Much like the type checker records information about every function and variable
    in the symbol table, it will also record information about every complete structure
    type in the *type table*. Let’s start by defining the type table; then, we’ll
    look at how to convert structure type declarations to type table entries. Finally,
    we’ll use the information in the type table to type check declarations, expressions,
    and initializers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 就像类型检查器会在符号表中记录关于每个函数和变量的信息一样，它也会在*类型表*中记录每个完整结构体类型的信息。让我们先定义类型表；然后，我们将看看如何将结构体类型声明转换为类型表条目。最后，我们将使用类型表中的信息来对声明、表达式和初始化器进行类型检查。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Defining the Type Table</samp>
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">定义类型表</samp>
- en: The type table maps the structure tags we generated in the previous stage to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp> constructs.
    [Listing 18-17](chapter18.xhtml#list18-17) defines <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表将我们在前一阶段生成的结构体标签映射到 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>
    结构体。[清单 18-17](chapter18.xhtml#list18-17) 定义了 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>。
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-17: An entry in
    the type table</samp>'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-17：类型表中的一个条目</samp>
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp> describes
    a structure type’s alignment, size, and members. We describe each member with
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">member_entry</samp> construct,
    which specifies the member’s name, its type, and its offset in bytes from the
    start of the structure. A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>
    should support two different ways of accessing <samp class="SANS_TheSansMonoCd_W5Regular_11">members</samp>:
    looking up specific members by name and getting the whole list of members in order.
    You might want to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">members</samp>
    as an ordered dictionary if your implementation language supports it.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp> 描述了一个结构体类型的对齐方式、大小和成员。我们通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member_entry</samp> 结构来描述每个成员，该结构指定成员的名称、类型以及它在结构体起始位置的偏移量（以字节为单位）。一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp> 应该支持两种不同的方式来访问
    <samp class="SANS_TheSansMonoCd_W5Regular_11">成员</samp>：按名称查找特定成员和获取成员的整个列表。你可能想将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">成员</samp> 表示为一个有序字典，如果你的实现语言支持的话。
- en: Like the symbol table, the type table should be a global variable or singleton
    that you can easily access from any stage of the compiler. (We’ll pass it explicitly
    in this section’s pseudocode for the sake of clarity.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与符号表一样，类型表应该是一个全局变量或单例，您可以在编译器的任何阶段轻松访问它。（为了清晰起见，我们将在本节的伪代码中显式地传递它。）
- en: Next, we’ll see how to add structure definitions to the type table as we traverse
    the AST.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何在遍历AST时将结构定义添加到类型表中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Populating the Type Table</samp>
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">填充类型表</samp>
- en: When the type checker encounters a definition of a complete structure type,
    it should validate the definition, then convert it into a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>
    and add it to the type table. The type checker can ignore any structure type declaration
    without a member list; a declaration with no member list either declares an incomplete
    type or redeclares a type that was already defined.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型检查器遇到一个完整结构类型的定义时，它应该验证该定义，然后将其转换为<samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>并将其添加到类型表中。类型检查器可以忽略没有成员列表的结构类型声明；没有成员列表的声明要么声明了一个不完整的类型，要么重新声明了一个已经定义的类型。
- en: To validate a structure type definition, we’ll start by checking whether this
    structure is in the type table already. If it is, that means there’s another definition
    of the same tag in the same scope, so we’ll throw an error. Then, we’ll make sure
    that no members of the structure share the same name, that no member has an incomplete
    type, and that no member type specifies an array with an incomplete element type.
    (Remember that arrays of incomplete type are illegal everywhere, not just in structure
    definitions.) You might also want to validate that no structure members have function
    type, but it isn’t strictly necessary since we already validated that during parsing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证结构类型定义，我们将首先检查该结构是否已经存在于类型表中。如果存在，意味着在相同作用域内有相同标签的另一个定义，这时我们将抛出错误。然后，我们将确保结构体的成员没有重复名称，且没有成员的类型是不完整的，也没有成员类型指定了不完整元素类型的数组。（请记住，不完整类型的数组在任何地方都是非法的，不仅仅在结构体定义中。）你可能还希望验证结构体成员是否有函数类型，但这不是严格必要的，因为我们在解析过程中已经验证过这一点。
- en: After validating that a structure type satisfies all these requirements, we’ll
    calculate each member’s offset and the whole structure’s size and alignment. Earlier
    in the chapter, we saw how to perform these calculations and walked through an
    example. Now let’s look at [Listing 18-18](chapter18.xhtml#list18-18), which demonstrates
    the whole process in pseudocode.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证结构类型满足所有这些要求之后，我们将计算每个成员的偏移量、整个结构的大小和对齐方式。在本章前面，我们已经展示了如何执行这些计算，并且通过一个示例进行了解释。现在让我们看一下[Listing
    18-18](chapter18.xhtml#list18-18)，它展示了整个过程的伪代码。
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-18: Calculating
    a structure definition</samp>'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-18: 计算结构定义</samp>'
- en: We start by checking whether this declaration includes a member list ❶. If it
    doesn’t, we return immediately, without making any changes to the type table.
    If it does have a member list, we validate that it meets the requirements described
    earlier in this section ❷. I won’t give you the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">validate_struct_definition</samp>,
    since it isn’t too complicated.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查该声明是否包含成员列表❶。如果没有，我们立即返回，且不对类型表进行任何更改。如果有成员列表，我们将验证其是否满足本节前面描述的要求❷。由于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">validate_struct_definition</samp>的伪代码并不复杂，我就不提供了。
- en: 'Then, we get to the interesting part: figuring out each member’s layout in
    memory. Here, we’ll define a <samp class="SANS_TheSansMonoCd_W5Regular_11">member_entry</samp>
    for each structure member ❸. As we go, we’ll maintain a running total of the structure’s
    size in bytes, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp>.
    We’ll also track the strictest member alignment we’ve seen so far as <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_alignment</samp>.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们进入有趣的部分：弄清楚每个成员在内存中的布局。在这里，我们将为每个结构成员定义一个<samp class="SANS_TheSansMonoCd_W5Regular_11">member_entry</samp>❸。在此过程中，我们将维护一个结构体大小的总计，单位为字节，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp>。我们还将跟踪到目前为止看到的最严格的成员对齐方式，记作<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct_alignment</samp>。
- en: To calculate a structure member’s offset, we take the next available offset,
    which is given by <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp>,
    and round it up to that member’s alignment ❹. (We’ll walk through how to look
    up each type’s size and alignment in a moment.) We construct its <samp class="SANS_TheSansMonoCd_W5Regular_11">member_entry</samp>
    ❺, then update <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_alignment</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp>.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算结构成员的偏移量，我们采用下一个可用的偏移量，该偏移量由<samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp>给出，并将其四舍五入到该成员的对齐方式❹。（稍后我们将介绍如何查找每个类型的大小和对齐方式。）我们构建其<samp
    class="SANS_TheSansMonoCd_W5Regular_11">member_entry</samp>❺，然后更新<samp class="SANS_TheSansMonoCd_W5Regular_11">struct_alignment</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp>。
- en: Once we’ve processed every member, we calculate the structure’s total size by
    rounding <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp> up to
    the nearest multiple of its alignment ❻. This rounded-up size will account for
    any padding at the end of the structure. Finally, we add the whole <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>
    to the type table ❼.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦处理完每个成员，我们通过将<samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp>四舍五入到其对齐方式的最接近倍数来计算结构的总大小❻。这个四舍五入的大小将考虑到结构末尾的任何填充。最后，我们将整个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>添加到类型表❼。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Handling Structures in Helper
    Functions</samp>
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">在辅助函数中处理结构体</samp>
- en: We’ve centralized a lot of type checking logic into a handful of helper functions,
    including <samp class="SANS_TheSansMonoCd_W5Regular_11">is_scalar</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp>. You’ve probably also
    written a few helper functions to look up each type’s size, alignment, and other
    properties, although I haven’t provided pseudocode for those yet. Now we’ll extend
    these helpers to handle structure types too.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将大量的类型检查逻辑集中到了一些辅助函数中，包括<samp class="SANS_TheSansMonoCd_W5Regular_11">is_scalar</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp>。您可能也编写了几个辅助函数，用于查找每个类型的大小、对齐方式以及其他属性，尽管我还没有为这些提供伪代码。现在我们将扩展这些助手函数，以处理结构类型。
- en: We defined <samp class="SANS_TheSansMonoCd_W5Regular_11">is_scalar</samp> back
    in [Listing 17-12](chapter17.xhtml#list17-12). [Listing 18-19](chapter18.xhtml#list18-19)
    gives the updated definition, with this chapter’s addition bolded.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[清单 17-12](chapter17.xhtml#list17-12)中定义了<samp class="SANS_TheSansMonoCd_W5Regular_11">is_scalar</samp>。[清单
    18-19](chapter18.xhtml#list18-19)给出了更新后的定义，本章新增的部分已加粗。
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-19: Checking whether
    a type is scalar</samp>'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-19：检查一个类型是否是标量</samp>
- en: Structure types aren’t scalar, so this is pretty simple. I’m guessing you’ve
    written similar helper functions to test whether a type is arithmetic, whether
    it’s an integer type, and so on. These will require similarly straightforward
    updates, which we won’t get into here.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 结构类型不是标量类型，因此这部分非常简单。我猜您可能已经编写了类似的辅助函数，用于测试类型是否为算术类型，是否为整数类型等等。这些都需要类似直接的更新，不过我们在这里不再深入探讨。
- en: Updating <samp class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp> is
    slightly more involved; we’ll need to consult the type table. [Listing 18-20](chapter18.xhtml#list18-20)
    gives the new definition of this function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 更新<samp class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp>稍微复杂一些；我们需要查阅类型表。[清单
    18-20](chapter18.xhtml#list18-20)给出了该函数的新定义。
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-20: Checking whether
    a type is complete</samp>'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-20：检查一个类型是否是完整的</samp>
- en: If a structure type is in the type table, it’s complete; if not, it’s incomplete.
    As we saw earlier, a structure type may be incomplete at one point in the program
    but complete later on. During type checking, the type table tells us whether the
    structure type is complete at the current point in the AST. Consider the code
    fragment in [Listing 18-21](chapter18.xhtml#list18-21).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个结构类型在类型表中，则它是完整的；如果不在，则它是不完整的。正如我们之前看到的，结构类型在程序中的某些时刻可能是不完整的，但后来会变得完整。在类型检查期间，类型表告诉我们在当前的抽象语法树（AST）中，结构类型是否完整。请参阅[清单
    18-21](chapter18.xhtml#list18-21)中的代码片段。
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-21: Declaring a
    variable with an incomplete structure type</samp>'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-21：声明一个包含不完整结构类型的变量</samp>
- en: Because the first declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> ❶ doesn’t specify any members, we won’t add it to the type table. Then,
    when we validate the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    t</samp> ❷, we’ll look up <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> in the type table. (Strictly speaking, we’ll look up the unique identifier
    that replaced <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> during the
    identifier resolution stage.) When we don’t find it, we’ll correctly conclude
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> is incomplete
    and throw an error. If the declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    t</samp> appeared after the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> ❸, we’d add <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>
    to the type table before processing <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    t</samp>, so we wouldn’t throw an error.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因为<samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> ❶的第一次声明没有指定任何成员，我们不会将其添加到类型表中。然后，当我们验证<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct t</samp> ❷的定义时，我们会在类型表中查找<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>。（严格来说，我们会查找在标识符解析阶段替代<samp
    class="SANS_TheSansMonoCd_W5Regular_11">s</samp>的唯一标识符。）当我们找不到它时，我们会正确地得出结论，认为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>是不完整的，并抛出错误。如果<samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    t</samp>的声明出现在<samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> ❸的定义之后，我们会在处理<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct t</samp>之前将<samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp>添加到类型表中，这样我们就不会抛出错误。
- en: We also need helper functions to find a type’s size and alignment. [Listing
    18-22](chapter18.xhtml#list18-22) shows the pseudocode for the <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>
    function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些辅助函数来查找类型的大小和对齐。[清单 18-22](chapter18.xhtml#list18-22)展示了<samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>函数的伪代码。
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-22: Calculating
    a type’s alignment</samp>'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-22：计算类型的对齐</samp>
- en: To find a structure’s alignment, we’ll look it up in the type table. To find
    an array’s alignment, we’ll recursively calculate the alignment of its element
    type. We’ll hardcode the alignments of other types, which are dictated by the
    ABI. I won’t provide pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>,
    which will look similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找一个结构体的对齐，我们将在类型表中查找它。要查找数组的对齐，我们将递归地计算其元素类型的对齐。我们将硬编码其他类型的对齐，这些对齐是由ABI决定的。我不会提供<samp
    class="SANS_TheSansMonoCd_W5Regular_11">size</samp>的伪代码，因为它与<samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>相似。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*We learned earlier that if a variable of array type is 16 bytes or larger,
    it must be 16-byte aligned. [Listing 18-22](chapter18.xhtml#list18-22) doesn’t
    reflect this requirement because it calculates the alignment of types, not variables.
    You’ll probably want to write a different helper function to calculate the alignment
    of variables, if you haven’t already.*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们之前学到，如果一个数组类型的变量大小为16字节或更大，它必须是16字节对齐的。[清单 18-22](chapter18.xhtml#list18-22)没有体现这一要求，因为它计算的是类型的对齐，而不是变量的对齐。如果你还没有这样做，你可能需要编写一个不同的辅助函数来计算变量的对齐。*'
- en: The other helper functions we defined in earlier chapters should handle structures
    correctly without any changes. Consider <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>,
    which we use to type check assignment expressions and other places where we convert
    a value to a specific type “as if by assignment.” [Listing 18-23](chapter18.xhtml#list18-23)
    reproduces the latest version of this code from [Listing 17-11](chapter17.xhtml#list17-11).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中定义的其他辅助函数应该能够正确处理结构体，无需任何修改。考虑一下<samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>，我们用它来进行赋值表达式和其他需要将值“像赋值一样”转换为特定类型的地方的类型检查。[清单
    18-23](chapter18.xhtml#list18-23)展示了这段代码的最新版本，来自[清单 17-11](chapter17.xhtml#list17-11)。
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-23: Converting an
    expression to a target type</samp>'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-23：将表达式转换为目标类型</samp>
- en: If we pass <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>
    an expression that already has the correct structure type, it will return the
    expression unchanged. In any other case with a source or target structure type,
    it will fail. That’s the correct behavior, since there’s no way to convert to
    or from a structure type.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>
    一个已经具有正确结构类型的表达式，它将返回原表达式而不做更改。在任何其他具有源或目标结构类型的情况下，它将失败。这是正确的行为，因为没有办法转换到或从结构类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Handling Incomplete Structure
    Types</samp>
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">处理不完整结构类型</samp>
- en: We need to enforce several restrictions on incomplete structure types. First,
    we’ll validate the use of these types in declarations; then, we’ll validate their
    use in expressions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对不完整结构类型施加若干限制。首先，我们将验证这些类型在声明中的使用；然后，我们将验证它们在表达式中的使用。
- en: 'It’s legal to declare, but not define, a function with parameters or a return
    value of incomplete structure type. (Remember that a function definition is a
    function declaration with a body.) If <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> is an incomplete type, the type checker should accept this declaration:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个带有不完整结构类型的参数或返回值的函数是合法的，但定义则不合法。（请记住，函数定义是带有函数体的函数声明。）如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> 是不完整类型，类型检查器应该接受以下声明：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'But it should reject this definition:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但是它应该拒绝这个定义：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Similarly, we’ll accept declarations of variables with incomplete structure
    type but reject any definitions of these variables, including tentative definitions.
    (This is more restrictive than the C standard, which permits tentative definitions
    of variables with incomplete types in certain limited circumstances.) Concretely,
    we’ll accept a variable declaration with an incomplete structure type only if
    it has the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> storage
    class and no initializer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将接受不完整结构类型的变量声明，但拒绝任何这些变量的定义，包括临时定义。（这比 C 标准更严格，C 标准在某些有限的情况下允许不完整类型的变量进行临时定义。）具体来说，只有在变量声明具有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> 存储类并且没有初始化器时，我们才接受不完整结构类型的变量声明。
- en: 'That takes care of declarations; now let’s consider expressions. There’s exactly
    one way to use a variable with incomplete type in an expression. You can take
    its address, as the following example demonstrates:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理了声明的问题；现在让我们考虑表达式。使用不完整类型的变量在表达式中只有一种合法方式。你可以获取它的地址，正如以下示例所演示的：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can then use <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> like
    any other pointer to an incomplete type.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以像使用任何其他不完整类型的指针一样使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>。
- en: 'Similarly, it’s legal (if not especially useful) to dereference a pointer to
    an incomplete structure and then take its address, resulting in the pointer you
    started with:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，解引用指向不完整结构的指针并再取其地址也是合法的（尽管不特别有用），结果是你开始时的指针：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Any other use of an expression with an incomplete structure type is invalid.
    You can’t even cast it to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    or use it as an expression statement, so the type checker should reject both of
    the following statements:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他对不完整结构类型的表达式使用都是无效的。你甚至不能将其转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    或将其作为表达式语句使用，因此类型检查器应该拒绝以下两条语句：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We’ll extend <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    to catch these invalid expressions. [Listing 18-24](chapter18.xhtml#list18-24)
    gives the updated definition of this function, with changes from the original
    definition in [Listing 15-19](chapter15.xhtml#list15-19) bolded.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展 <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    来捕获这些无效的表达式。[清单 18-24](chapter18.xhtml#list18-24) 给出了这个函数的更新定义，原定义中的变化部分在 [清单
    15-19](chapter15.xhtml#list15-19) 中已加粗。
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-24: Rejecting incomplete
    structure types in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">typecheck_and_convert</samp>'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-24：在</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">typecheck_and_convert</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">中拒绝不完整结构类型</samp>
- en: 'Remember that <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    processes every expression in the AST except for static initializers (which must
    be constants) and the operands of the <samp class="SANS_TheSansMonoCd_W5Regular_11">SizeOf</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions (which
    don’t undergo array decay). This makes <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    the most convenient place to put the new validation, even though it has nothing
    to do with the function’s original purpose, which is to implicitly convert arrays
    to pointers. With this new validation in place, we’ll handle incomplete types
    correctly in every kind of expression: we’ll permit incomplete structure types
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions, our
    existing validation will reject all incomplete types (including <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>)
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">SizeOf</samp> expressions, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp> will
    reject incomplete structure types everywhere else. Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    still accepts void expressions, which are legal in several places where expressions
    with incomplete structure types are not.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，<samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    处理 AST 中的每个表达式，除了静态初始化器（必须是常量）以及 <samp class="SANS_TheSansMonoCd_W5Regular_11">SizeOf</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> 表达式的操作数（这些表达式不进行数组衰减）。这使得
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp> 成为添加新验证的最便捷位置，尽管这与该函数的原始目的是隐式地将数组转换为指针无关。通过这项新验证，我们将在每种表达式中正确处理不完全类型：我们将允许在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> 表达式中使用不完全结构类型，我们现有的验证会拒绝在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SizeOf</samp> 表达式中使用所有不完全类型（包括 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>），而 <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    会在其他地方拒绝不完全结构类型。请注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    仍然接受 void 表达式，这在一些地方是合法的，而不完全结构类型的表达式则不合法。
- en: We’ve already implemented all the other validation we need for incomplete types.
    For example, we already require the pointer operands in pointer arithmetic expressions
    to point to complete types, and we already require the element types in array
    type specifiers to be complete.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了对不完全类型所需的所有其他验证。例如，我们已经要求指针运算表达式中的指针操作数指向完整类型，并且我们已经要求数组类型说明符中的元素类型必须是完整的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Type Checking the Member Access
    Operators</samp>
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">成员访问运算符的类型检查</samp>
- en: Next, let’s type check the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operators. In both
    cases, we’ll validate the expression, figure out the member type, and record that
    as the type of the whole expression. [Listing 18-25](chapter18.xhtml#list18-25)
    demonstrates how to type check a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    operator.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    运算符。在这两种情况下，我们会验证表达式，找出成员类型，并将其记录为整个表达式的类型。[示例 18-25](chapter18.xhtml#list18-25)
    展示了如何对 <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> 运算符进行类型检查。
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-25: Type checking
    the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operator</samp>'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 18-25：类型检查</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">运算符</samp>
- en: We start by type checking the first operand, <samp class="SANS_TheSansMonoCd_W5Regular_11">structure</samp>,
    with a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    (which throws an error if <samp class="SANS_TheSansMonoCd_W5Regular_11">structure</samp>
    has an incomplete type). Then, we validate that <samp class="SANS_TheSansMonoCd_W5Regular_11">structure</samp>
    really is a structure ❶. If it is, we look up its type in the type table ❷, then
    look up <samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp> in the resulting
    type table entry ❸. Finally, we annotate the expression with the member type ❹.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">structure</samp> isn’t a structure
    or doesn’t have a member with this name, we throw an error.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过调用`<samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>`来检查第一个操作数`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">structure</samp>`的类型（如果`<samp class="SANS_TheSansMonoCd_W5Regular_11">structure</samp>`具有不完整类型，则会抛出错误）。然后，我们验证`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">structure</samp>`确实是一个结构体 ❶。如果是，我们在类型表中查找其类型
    ❷，然后在结果类型表项中查找`<samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp>` ❸。最后，我们用成员类型标注表达式
    ❹。如果`<samp class="SANS_TheSansMonoCd_W5Regular_11">structure</samp>`不是结构体，或者没有这个名字的成员，我们将抛出错误。
- en: I won’t provide pseudocode for type checking the <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    operator, since it’s nearly identical; the only difference is that we validate
    that the first operand is a pointer to a structure, rather than a structure itself.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会提供关于类型检查`<samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>`操作符的伪代码，因为它几乎是相同的；唯一的区别在于，我们验证第一个操作数是指向结构体的指针，而不是结构体本身。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Validating Lvalues</samp>
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">验证左值</samp>
- en: An <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> expression is always
    an lvalue. To determine whether a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    expression is an lvalue, the type checker must recursively check whether its first
    operand is an lvalue. For example, the type checker should reject the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">f().member = 3</samp>. Because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">f()</samp> isn’t an lvalue, <samp class="SANS_TheSansMonoCd_W5Regular_11">f().member</samp>
    isn’t either.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>`表达式总是左值。为了确定`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">.</samp>`表达式是否是左值，类型检查器必须递归检查其第一个操作数是否是左值。例如，类型检查器应该拒绝表达式`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">f().member = 3</samp>`。因为`<samp class="SANS_TheSansMonoCd_W5Regular_11">f()</samp>`不是左值，`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">f().member</samp>`也不是。'
- en: This means we might encounter arrays that aren’t lvalues! It’s a type error
    to explicitly take the address of such an array, like in [Listing 18-26](chapter18.xhtml#list18-26).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可能会遇到不是左值的数组！显式地获取这种数组的地址是类型错误，就像在[清单18-26](chapter18.xhtml#list18-26)中那样。
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-26: Illegally taking
    the address of a non-lvalue</samp>'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单18-26：非法获取非左值的地址</samp>
- en: However, these arrays still decay to pointers, so their addresses are still
    loaded implicitly. The program in [Listing 18-27](chapter18.xhtml#list18-27),
    for example, is entirely legal.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些数组仍然会衰减为指针，因此它们的地址仍然会被隐式加载。例如，[清单18-27](chapter18.xhtml#list18-27)中的程序是完全合法的。
- en: '[PRE48]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-27: Implicitly converting
    a non-lvalue array to a pointer</samp>'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单18-27：隐式将非左值数组转换为指针</samp>
- en: When we type check this program, we’ll insert <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    to take the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">f().arr</samp>,
    just like when we type check any other expression of array type.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对这个程序进行类型检查时，我们会插入`<samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>`来获取`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">f().arr</samp>`的地址，就像我们对任何其他数组类型的表达式进行类型检查时一样。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Type Checking Structures in
    Conditional Expressions</samp>
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">条件表达式中的结构体类型检查</samp>
- en: The type checker should accept conditional expressions where both branches have
    the same structure type. It should reject conditional expressions where only one
    branch has a structure type or where the branches have two different structure
    types. To determine whether two structure types are identical, compare their tags,
    not their contents.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器应该接受条件表达式，其中两个分支具有相同的结构体类型。它应拒绝那些只有一个分支具有结构体类型，或者两个分支具有不同结构体类型的条件表达式。要判断两个结构体类型是否相同，应比较它们的标签，而不是它们的内容。
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Type Checking Structure
    Initializers</samp>'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">结构体初始化器的类型检查</samp>'
- en: Finally, we’ll deal with structure initializers. As you learned earlier in this
    chapter, you can initialize a structure either with a single expression of that
    structure type or with a compound initializer. The first case shouldn’t require
    any changes to the type checker.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将处理结构体初始化器。正如你在本章前面学到的，你可以使用一个结构体类型的单一表达式，或者使用一个复合初始化器来初始化结构体。在第一种情况下，类型检查器不需要做任何修改。
- en: To handle compound initializers, we’ll type check each item in the initializer
    list against the corresponding member type, as [Listing 18-28](chapter18.xhtml#list18-28)
    demonstrates.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理复合初始化器，我们将对初始化器列表中的每一项进行类型检查，以确保其与相应的成员类型匹配，正如[示例 18-28](chapter18.xhtml#list18-28)所示。
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-28: Type checking
    compound initializers for structures</samp>'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 18-28：结构体的复合初始化器类型检查</samp>
- en: We’ll start by looking up the structure in the type table ❶. We should have
    already validated that <samp class="SANS_TheSansMonoCd_W5Regular_11">target_type</samp>
    is complete before calling <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck
    _init</samp>, so at this point it’s safe to assume that the structure has been
    defined. Next, we’ll make sure the initializer list isn’t too long ❷. Just like
    when we process array initializers, we’ll reject an initializer list with too
    many elements but accept one with too few elements to initialize the whole object.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查找类型表中的结构体 ❶。我们应该已经验证过<samp class="SANS_TheSansMonoCd_W5Regular_11">target_type</samp>是完整的，在调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp>之前，所以此时可以安全地假设该结构体已经定义。接下来，我们将确保初始化器列表不会过长
    ❷。就像我们处理数组初始化器时一样，我们会拒绝包含过多元素的初始化器列表，但接受那些包含过少元素，无法初始化整个对象的初始化器列表。
- en: After performing this check, we’ll iterate through the initializer list ❸. To
    type check each initializer, we’ll look up the corresponding member type in the
    structure’s member list, then call <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp>
    recursively to make sure the initializer is compatible with that type. Finally,
    we’ll pad out any uninitialized structure members with zeros ❹.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此检查后，我们将遍历初始化器列表 ❸。为了进行类型检查，我们将在结构体的成员列表中查找相应的成员类型，然后递归调用<samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp>，确保初始化器与该类型兼容。最后，我们将用零填充任何未初始化的结构成员
    ❹。
- en: Once you’ve updated <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp>,
    you’ll need to extend <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>
    to handle structure types. To initialize a structure to zero, <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>
    should call itself recursively for each member type and return the results in
    a compound initializer.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 更新了<samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp>后，你还需要扩展<samp
    class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>以处理结构体类型。为了将结构体初始化为零，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>应递归地为每个成员类型调用自身，并将结果返回为一个复合初始化器。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Initializing Static Structures</samp>
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">初始化静态结构体</samp>
- en: 'If a structure has static storage duration, we’ll store its initial value as
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> list in the
    symbol table, just like we do for arrays. The key difference is that we’ll initialize
    any padding in the structure too. Let’s return to the example from [Listing 18-10](chapter18.xhtml#list18-10):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结构体具有静态存储持续时间，我们将把它的初始值作为<samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>列表存储在符号表中，就像我们处理数组一样。唯一的区别是，我们还会初始化结构体中的任何填充部分。让我们回到[示例
    18-10](chapter18.xhtml#list18-10)中的例子：
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We figured out that this structure included 4 bytes of padding between <samp
    class="SANS_TheSansMonoCd_W5Regular_11">member1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>
    and 5 bytes of padding after <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> is a static variable,
    we’ll use the construct in [Listing 18-29](chapter18.xhtml#list18-29) to represent
    its initial value.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现这个结构体在 <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> 之间包含了 4 个字节的填充，在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">array</samp> 之后有 5 个字节的填充。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    是一个静态变量，我们将使用[清单 18-29](chapter18.xhtml#list18-29)中的构造来表示其初始值。
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-29: Representing
    the initializer from [Listing 18-10](chapter18.xhtml#list18-10) as a</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">static_init</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">list</samp>'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-29：将来自[清单 18-10](chapter18.xhtml#list18-10)的初始化器表示为一个</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">static_init</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表</samp>
- en: We initialize padding with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    construct ❶❷ because the C standard requires the padding in static structures
    to be initialized to zero. [Listing 18-30](chapter18.xhtml#list18-30) demonstrates
    how to generate static initializer lists like the one in [Listing 18-29](chapter18.xhtml#list18-29).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> 构造来初始化填充
    ❶❷，因为 C 标准要求静态结构体中的填充部分必须初始化为零。[清单 18-30](chapter18.xhtml#list18-30) 展示了如何生成像[清单
    18-29](chapter18.xhtml#list18-29)中的静态初始化器列表。
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-30: Generating a
    static initializer for a structure</samp>'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-30：为结构体生成静态初始化器</samp>
- en: To process a compound initializer for a static structure, we first look up the
    structure in the type table ❶. We make sure the initializer list isn’t too long,
    just like we did for non-static initializers in <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp>.
    Then, we iterate over the initializer list, looking up the corresponding member
    definition for each element in the structure’s member list. As we go, we update
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">current_offset</samp> variable
    to track how many bytes we’ve initialized so far.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理静态结构体的复合初始化器，我们首先在类型表中查找该结构体 ❶。我们确保初始化器列表不过长，就像在处理非静态初始化器时对 <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp>
    做的那样。然后，我们遍历初始化器列表，为结构体成员列表中的每个元素查找对应的成员定义。过程中，我们更新 <samp class="SANS_TheSansMonoCd_W5Regular_11">current_offset</samp>
    变量来追踪已初始化的字节数。
- en: Each time we process the initializer for a structure member, we first check
    whether we’ve initialized enough bytes to bring us up to the expected offset.
    If we haven’t, we add the necessary padding with a <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    initializer ❷. We then create the initializer list for the structure member itself
    with a recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">create_static_init_list</samp>
    ❸. Next, we update <samp class="SANS_TheSansMonoCd_W5Regular_11">current _offset</samp>
    based on the offset and size of the member we just initialized.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 每次处理结构体成员的初始化器时，我们首先检查是否已经初始化了足够的字节，以达到预期的偏移量。如果没有，我们会使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    初始化器 ❷ 来添加必要的填充。然后，我们通过递归调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">create_static_init_list</samp>
    ❸ 来为结构体成员本身创建初始化器列表。接下来，我们根据刚刚初始化的成员的偏移量和大小来更新 <samp class="SANS_TheSansMonoCd_W5Regular_11">current_offset</samp>。
- en: Once we’ve initialized every structure member, we add another <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>,
    if necessary, to pad out the structure to the correct size ❹. This last <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> zeroes out any structure
    members that weren’t explicitly initialized as well as any trailing padding after
    the last member.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们初始化了所有结构体成员，如果需要，我们会添加另一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>，以将结构体填充到正确的大小
    ❹。这个最后的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> 会将任何未显式初始化的结构体成员以及最后一个成员后的任何填充部分置为零。
- en: Because there are no constants of structure type, initializing a static structure
    with a <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleInit</samp> expression
    is a type error ❺.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有结构体类型的常量，用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleInit</samp>
    表达式初始化静态结构体是一个类型错误 ❺。
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">TACKY 生成</samp>
- en: 'In this section, we’ll introduce one last TACKY instruction:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍最后一条 TACKY 指令：
- en: '[PRE53]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This instruction mirrors the <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    instruction we added back in [Chapter 15](chapter15.xhtml). The <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    identifier in <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    is the name of an aggregate variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>
    is the byte offset of a subobject within that variable, and <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    is the variable we’ll copy that subobject to. [Listing 18-31](chapter18.xhtml#list18-31)
    defines the complete TACKY IR, including the new <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    instruction.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 本指令与我们在[第15章](chapter15.xhtml)中添加的 <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    指令相似。<samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> 中的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">src</samp> 标识符是一个聚合变量的名称，<samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>
    是该变量内子对象的字节偏移量，<samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> 是我们将该子对象复制到的变量。[清单
    18-31](chapter18.xhtml#list18-31) 定义了完整的 TACKY IR，包括新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    指令。
- en: '[PRE54]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-31: Adding</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">CopyFromOffset</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    the TACKY IR</samp>'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-31: 将</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">CopyFromOffset</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">添加到 TACKY IR 中</samp>'
- en: Not only can you access subobjects in a structure with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> instructions,
    but you can also copy entire structures from one location to another using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> or pass them between
    functions with <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>, just like scalar
    variables. We’ll represent variables of structure type as ordinary TACKY <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>s.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> 指令访问结构中的子对象，还可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> 将整个结构从一个位置复制到另一个位置，或通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    在函数之间传递，就像标量变量一样。我们将结构类型的变量表示为普通的 TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>。
- en: Next, we’ll convert the member access operators to TACKY. Then, we’ll process
    compound structure initializers. We won’t change how we process most constructs
    that can use structures, like function calls, <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements, and conditional expressions. We also won’t need to do anything with
    the new top-level <samp class="SANS_TheSansMonoCd_W5Regular_11">StructDecl</samp>
    construct; we’ll discard structure declarations at this stage, just like we discard
    function declarations without bodies and variable declarations without initializers.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将成员访问操作符转换为 TACKY。然后，我们将处理复合结构初始化器。我们不会改变处理大多数可以使用结构的构造的方式，例如函数调用、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句和条件表达式。我们也不需要对新的顶层 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">StructDecl</samp> 构造做任何处理；在这个阶段，我们将丢弃结构声明，就像我们丢弃没有函数体的函数声明和没有初始化器的变量声明一样。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing the
    Member Access Operators</samp>
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">实现成员访问操作符</samp>
- en: 'In earlier chapters, you learned that you can use an object in one of three
    ways: you can lvalue convert it, assign to it, or take its address. Now there’s
    a fourth option: if the object is a structure, you can access one of its members.
    And because that structure member is itself an object, you can lvalue convert
    it, assign to it, take its address, or access one of *its* members. Let’s look
    at the TACKY we should generate in each of these cases. Then, building on the
    approach we used to handle dereferenced pointers in [Chapter 14](chapter14.xhtml),
    we’ll introduce a new kind of <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>
    to designate structure members.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学到了可以通过三种方式使用一个对象：你可以将其转换为左值、对其进行赋值，或获取它的地址。现在有了第四种选择：如果该对象是一个结构体，你可以访问它的某个成员。由于该结构体成员本身就是一个对象，你可以将其转换为左值、对其进行赋值、获取其地址，或访问它的*成员*。接下来，让我们看一下在这些情况下应该生成的TACKY。然后，基于我们在[第14章](chapter14.xhtml)中处理解引用指针的方法，我们将引入一种新的类型<samp
    class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>来表示结构体成员。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Accessing Structure Members
    in TACKY</samp>
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">在TACKY中访问结构体成员</samp>
- en: 'To implement any sort of operation on a structure member, we’ll start by looking
    up the member’s offset in the type table. First, let’s consider cases where the
    structure itself is a TACKY variable, rather than a dereferenced pointer or a
    subobject in some larger structure. To lvalue convert a structure member, we’ll
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> instruction.
    We’ll translate <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><struct></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp>
    to:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对结构体成员执行任何操作，我们将首先查找成员在类型表中的偏移量。首先，让我们考虑结构体本身是TACKY变量，而不是解引用的指针或某个更大结构体中的子对象的情况。要将结构体成员转换为左值，我们将使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>指令。我们将转换<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><struct></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp>为：
- en: '[PRE55]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We’ll assign to structure members with <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>,
    converting <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><struct></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><right></samp>
    to:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用<samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>对结构体成员进行赋值，将<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><struct></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><right></samp>转换为：
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To get a structure member’s address, we’ll first load the address of the object
    that contains it, then add the member’s offset. We’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><struct></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp> to:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取结构体成员的地址，我们首先加载包含它的对象的地址，然后加上该成员的偏移量。我们将转换<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><struct></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp>为：
- en: '[PRE57]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: To process a sequence of nested member accesses, we’ll add all their offsets
    together and then issue an instruction depending on how the final member in the
    sequence is used. Consider the structure declarations in [Listing 18-32](chapter18.xhtml#list18-32).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理一系列嵌套成员访问，我们将把它们的所有偏移量加在一起，然后根据序列中最后一个成员的使用方式发出指令。请考虑[清单18-32](chapter18.xhtml#list18-32)中的结构体声明。
- en: '[PRE58]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-32: Declaring a
    structure that contains a nested structure</samp>'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单18-32：声明一个包含嵌套结构的结构体</samp>
- en: 'If <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct</samp> is a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct outer</samp> and we need to lvalue
    convert <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct .member2.i</samp>,
    we’ll emit:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果<samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct</samp>是一个<samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    outer</samp>，并且我们需要将<samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct.member2.i</samp>转换为左值，我们将生成：
- en: '[PRE59]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> has an
    offset of 4 bytes in <samp class="SANS_TheSansMonoCd_W5Regular_11">struct outer</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> has an offset of 4
    bytes in <samp class="SANS_TheSansMonoCd_W5Regular_11">struct inner</samp>, the
    object designated by <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct.member2.i</samp>
    has a total offset of 8 bytes from the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct</samp>.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    outer</samp> 中的偏移量是 4 字节，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    在 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct inner</samp> 中的偏移量是 4 字节，因此通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct.member2.i</samp> 指定的对象从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct</samp> 开始的总偏移量是 8 字节。
- en: Finally, let’s consider how to access structure members through dereferenced
    pointers. The most idiomatic way to do this is with an arrow operator, of the
    form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">-></samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp>.
    This is equivalent to the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(*</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">).</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp>. To implement
    either of these expressions, you’ll add the member offset to the pointer and then
    dereference the result. As with any dereferenced pointer, whether you issue a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction or simply use the pointer’s value will depend on how it’s used. Suppose
    <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_struct_pointer</samp> has
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct inner *</samp>. We’ll
    convert the expression
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑通过解引用指针访问结构成员。最典型的做法是使用箭头操作符，形式为 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">-></samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp>。这等同于表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(*</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">).</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp>。为了实现这两种表达式，你需要将成员的偏移量加到指针上，然后解引用结果。与任何解引用指针一样，无论是发出
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> 还是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    指令，还是仅仅使用指针的值，都取决于指针的使用方式。假设 <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_struct_pointer</samp>
    的类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct inner *</samp>。我们将转换表达式
- en: '[PRE60]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'to:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 到：
- en: '[PRE61]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We can implement the equivalent expression
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用完全相同的指令实现等效表达式。
- en: '[PRE62]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: with exactly the same instructions. Now that we know what instructions we’d
    like to generate, we’ll update the TACKY generation pass accordingly.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了想要生成的指令，将相应地更新 TACKY 生成阶段。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Designating Structure Members
    with SubObject</samp>
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">使用 SubObject 指定结构成员</samp>
- en: Let’s extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>
    construct to designate a member of an aggregate object. [Listing 18-33](chapter18.xhtml#list18-33)
    gives the updated definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展 <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp> 构造体，以指定一个聚合对象的成员。[列表
    18-33](chapter18.xhtml#list18-33) 给出了更新后的 <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>
    定义。
- en: '[PRE63]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-33: Extending</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp_result</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    represent subobjects</samp>'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 18-33：扩展</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp_result</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">以表示子对象</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">base</samp> argument to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp> is an aggregate object,
    not a pointer. The second argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>,
    is a byte offset into that object. The object that <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>
    designates might be scalar, or it might be an aggregate itself. In [Listing 18-34](chapter18.xhtml#list18-34),
    we use this construct to represent the result of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp>
    operator.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">base</samp> 作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>
    的参数是一个聚合对象，而不是指针。第二个参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>
    是该对象的字节偏移量。<samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp> 所指定的对象可以是标量，也可以是聚合对象。在
    [清单 18-34](chapter18.xhtml#list18-34) 中，我们使用该构造表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp>
    运算符的结果。
- en: '[PRE64]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-34: Converting the</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">Dot</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operator
    to TACKY</samp>'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-34: 将</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">点</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">运算符转换为 TACKY</samp>'
- en: First, we look up <samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp>’s
    offset in the structure. Then, we process this expression’s first operand without
    lvalue converting it. The resulting object is either a plain TACKY variable, a
    subobject of a TACKY variable, or a dereferenced pointer. (We know the result
    isn’t a constant because TACKY doesn’t have constants of structure type.)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们查找 <samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp> 在结构中的偏移量。然后，我们处理该表达式的第一个操作数，而不进行左值转换。结果对象可以是一个普通的
    TACKY 变量，一个 TACKY 变量的子对象，或一个解引用的指针。（我们知道结果不是常量，因为 TACKY 没有结构类型的常量。）
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_object</samp> is just
    a variable, we return a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>
    designating the object at <samp class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp>
    within that variable ❶. If <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_object</samp>
    is itself a subobject in some larger variable, we add its offset to <samp class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp>
    ❷. This takes care of nested member operators, like the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct
    .member2.i</samp> that we considered earlier in this section.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_object</samp> 只是一个变量，我们返回一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>，指定该变量中 <samp class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp>
    位置的对象 ❶。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_object</samp> 本身是某个更大变量中的子对象，我们将其偏移量加到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp> 上 ❷。这处理了像本节前面提到的表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct .member2.i</samp> 这样的嵌套成员运算符。
- en: Finally, if the inner structure is a dereferenced pointer, we access the structure
    member with pointer arithmetic ❸. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(ptr)</samp>
    designates the whole structure, <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    must point to the start of the structure. We add <samp class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> to get a pointer to
    the specified structure member. Then, we dereference this pointer to designate
    the structure member itself.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果内部结构是解引用的指针，我们通过指针运算符访问结构成员 ❸。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(ptr)</samp>
    指定了整个结构，因此 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> 必须指向结构的起始位置。我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp> 加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    上，以获取指向指定结构成员的指针。然后，我们解引用此指针来指定结构成员本身。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Processing SubObject</samp>
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">处理 SubObject</samp>
- en: Next, we’ll process <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>
    constructs in lvalue conversions, assignment expressions, and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    expressions. To lvalue convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>,
    we copy it into a new variable with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    instruction, as [Listing 18-35](chapter18.xhtml#list18-35) demonstrates.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在左值转换、赋值表达式和 <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    表达式中处理 <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp> 构造。要进行左值转换一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    指令将其复制到一个新变量中，正如 [列表 18-35](chapter18.xhtml#list18-35) 所示。
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-35: Lvalue converting
    a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">SubObject</samp>'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 18-35：左值转换一个</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">SubObject</samp>
- en: Conversely, when a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>
    appears on the left-hand side of an assignment expression, we write to it with
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> instruction,
    as [Listing 18-36](chapter18.xhtml#list18-36) demonstrates.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp> 出现在赋值表达式的左侧时，我们通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> 指令向其写入数据，正如
    [列表 18-36](chapter18.xhtml#list18-36) 所示。
- en: '[PRE66]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-36: Assigning to
    a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">SubObject</samp>'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 18-36：赋值给一个</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">SubObject</samp>
- en: Finally, [Listing 18-37](chapter18.xhtml#list18-37) shows how to calculate the
    address of a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>. We
    load the address of the base object, then add the offset.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[列表 18-37](chapter18.xhtml#list18-37) 展示了如何计算一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>
    的地址。我们加载基对象的地址，然后加上偏移量。
- en: '[PRE67]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-37: Taking the address
    of a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">SubObject</samp>'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 18-37：获取 a 的地址</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">SubObject</samp>
- en: We reuse the same temporary variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>,
    to point to both the base of the structure and its member. We could also generate
    two different temporary variables, but we don’t need to. Because the offset in
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp> construct is
    in bytes, the scale of this <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> ❶.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重用相同的临时变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>，它同时指向结构体的基址和其成员。我们也可以生成两个不同的临时变量，但不需要这么做。因为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp> 构造中的偏移量是以字节为单位的，所以此
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> 指令的规模是 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    ❶。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing the Arrow Operator</samp>
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">实现箭头操作符</samp>
- en: Now that we’ve implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp>,
    we can easily implement <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>
    too. To calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr->member</samp>,
    we’ll first evaluate and lvalue convert <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>.
    Then, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> to
    add the offset of <samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp>.
    This will give us a pointer to the designated structure member. Finally, we’ll
    dereference this pointer with a <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>
    construct. I’ll omit the pseudocode for this; you’ve already seen how to convert
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(*ptr).member</samp> to TACKY, and
    converting <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr->member</samp> to
    TACKY is very similar.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了<samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp>，我们也可以轻松实现<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>。为了计算<samp class="SANS_TheSansMonoCd_W5Regular_11">ptr->member</samp>，我们首先会对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>进行求值并进行左值转换。然后，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>加上<samp
    class="SANS_TheSansMonoCd_W5Regular_11">member</samp>的偏移量。这将为我们提供指向指定结构成员的指针。最后，我们将使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>构造解引用此指针。我将省略该部分的伪代码；你已经看到如何将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">(*ptr).member</samp>转换为TACKY，转换<samp class="SANS_TheSansMonoCd_W5Regular_11">ptr->member</samp>为TACKY也非常相似。
- en: We don’t need any extra logic to handle the result of an <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>
    expression. This expression will always produce a <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>
    construct, which we already know how to handle.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要额外的逻辑来处理<samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>表达式的结果。该表达式将始终生成一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>构造，我们已经知道如何处理。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Omitting Useless AddPtr Instructions</samp>
  id: totrans-295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">省略无用的 AddPtr 指令</samp>
- en: The first member in a structure always has an offset of zero. As an optional
    optimization, you can skip the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction when calculating this member’s address. This affects [Listings 18-34](chapter18.xhtml#list18-34)
    and [18-37](chapter18.xhtml#list18-37), as well as the implementation of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>, which I didn’t give the
    pseudocode for. In all three cases, you don’t need to generate an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction if <samp class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 结构中的第一个成员的偏移量始终为零。作为一种可选的优化，在计算该成员的地址时，可以跳过<samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>指令。这影响了[清单18-34](chapter18.xhtml#list18-34)和[18-37](chapter18.xhtml#list18-37)，以及<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>的实现，我没有提供其伪代码。在这三种情况下，如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp>为<samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，则无需生成<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>指令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Compound
    Initializers to TACKY</samp>
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将复合初始化器转换为 TACKY</samp>
- en: 'To finish up this section, we’ll convert compound structure initializers to
    TACKY. The basic approach is the same as in previous chapters: we’ll evaluate
    each expression in the initializer list in turn, copying the result of each one
    to the correct offset in the destination with a <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    instruction. But now we’ll need to check the type table to find the correct offset
    for each expression. We’ll also need to calculate the offsets of subobjects deep
    within nested structures, arrays of structures, structures that contain arrays,
    and so on.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一部分，我们将复合结构初始化器转换为TACKY。基本方法与前几章相同：我们依次评估初始化器列表中的每个表达式，并使用<samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>指令将每个表达式的结果复制到目标的正确偏移量。但现在，我们需要检查类型表，以找到每个表达式的正确偏移量。我们还需要计算嵌套结构、结构数组、包含数组的结构等中的子对象的偏移量。
- en: '[Listing 18-38](chapter18.xhtml#list18-38) demonstrates how to track these
    offsets and emit <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    instructions as we traverse a compound initializer for a structure or array.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单18-38](chapter18.xhtml#list18-38)演示了如何跟踪这些偏移量，并在遍历结构或数组的复合初始化器时发出<samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>指令。'
- en: '[PRE68]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-38: Converting a
    compound initializer to TACKY</samp>'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表18-38：将复合初始化器转换为TACKY</samp>
- en: The parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">compound_initializer_to_tacky</samp>
    include <samp class="SANS_TheSansMonoCd_W5Regular_11">var_name</samp> (the name
    of the array or structure variable being initialized), <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>
    (the byte offset of the current subobject within that variable), and <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>
    (the initializer itself). In the top-level call to initialize an entire variable,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp> argument will
    be <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">compound_initializer_to_tacky</samp>的参数包括<samp
    class="SANS_TheSansMonoCd_W5Regular_11">var_name</samp>（正在初始化的数组或结构变量的名称）、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>（该变量中当前子对象的字节偏移量）和<samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>（初始化器本身）。在初始化整个变量的顶级调用中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>参数将是<samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。
- en: In the base case, we initialize a subobject with the value of a single expression.
    This expression may be a string literal that initializes an array; I’ve omitted
    the pseudocode for this case, which we covered back in [Chapter 16](chapter16.xhtml).
    Otherwise, we evaluate the expression and copy the result into place with a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> instruction ❶. Even
    if the result has structure type, we can copy it to its destination with a single
    instruction.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在基础情况下，我们使用单个表达式的值初始化一个子对象。这个表达式可能是一个字符串字面量，用于初始化一个数组；我省略了这个情况的伪代码，我们在[第16章](chapter16.xhtml)中已经讨论过了。如果不是这种情况，我们会计算该表达式并通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>指令❶将结果复制到目标位置。即使结果具有结构类型，我们也可以通过单条指令将其复制到目标位置。
- en: When we encounter a compound initializer for a structure, we look up the structure’s
    member list in the type table. We calculate the offset of each item in the initializer
    list by adding the corresponding member offset to the starting <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>
    argument ❷. Then, we process the item recursively. I won’t talk through the case
    of a compound initializer for an array, since you already know how to handle that.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到一个结构的复合初始化器时，我们会在类型表中查找该结构的成员列表。通过将每个初始化项的偏移量与对应成员的偏移量相加，我们计算出初始化器列表中每个项的偏移量。然后，我们递归处理这些项。我不会详细讲解数组的复合初始化器情况，因为你已经知道如何处理了。
- en: Our implementation deviates slightly from the C standard here. Under certain
    circumstances, the standard requires padding to be initialized to zero; [Listing
    18-38](chapter18.xhtml#list18-38) doesn’t initialize structure padding, and none
    of our tests check the value of padding in non-static structures.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现与C标准在这里略有偏差。在某些情况下，标准要求填充部分初始化为零；[列表18-38](chapter18.xhtml#list18-38)并未初始化结构体的填充部分，而且我们的测试也没有检查非静态结构中的填充部分的值。
- en: At this point, you know how to convert both member access operators and compound
    structure initializers to TACKY. Once you’ve implemented these conversions, you
    can test out this compiler pass.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经知道如何将成员访问运算符和复合结构初始化器转换为TACKY。实现这些转换后，你可以测试此编译器阶段。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Structures in the System V Calling Convention</samp>
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">System V调用约定中的结构</samp>
- en: The trickiest part of assembly generation in this chapter is dealing with function
    calls. As always, we need to pass parameters and return values according to the
    System V x64 calling convention. The rules for passing and returning structures
    are particularly gnarly, so we’ll take a look at them before we make any changes
    to the backend.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中生成汇编代码最棘手的部分是处理函数调用。像往常一样，我们需要根据System V x64调用约定传递参数和返回值。传递和返回结构的规则尤其复杂，因此在对后端做出任何更改之前，我们需要先了解这些规则。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Classifying Structures</samp>
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">结构分类</samp>
- en: In the System V x64 ABI, every parameter and return value has a *class*, which
    dictates how it’s transferred during function calls. We’ve already encountered
    two of the classes defined in the ABI, although I didn’t use the term *class*
    to describe them. Values with integer, character, and pointer types all belong
    to the INTEGER class; they’re transferred in general-purpose registers. Values
    with type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> all belong
    to the SSE class; they’re transferred in XMM registers.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在System V x64 ABI中，每个参数和返回值都有一个*类别*，决定了它在函数调用期间如何传输。我们已经遇到了ABI中定义的两个类别，虽然我没有用*类别*这个术语来描述它们。具有整数、字符和指针类型的值都属于INTEGER类别；它们通过通用寄存器传输。具有类型<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>的值都属于SSE类别；它们通过XMM寄存器传输。
- en: In this chapter we’ll encounter a third class, MEMORY, for large values that
    must be transferred in memory. We’ve passed function arguments in memory before,
    but passing return values in memory is a new concept; we’ll see exactly how that
    works in a moment.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将遇到第三个类别：MEMORY，用于必须通过内存传输的大型值。我们以前已经通过内存传递了函数参数，但通过内存传递返回值是一个新概念；稍后我们将详细介绍它是如何工作的。
- en: The ABI presents a somewhat complicated algorithm for classifying structures
    and unions. We can use a simplified version of this algorithm because there are
    a bunch of types that we don’t handle, like <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and unions. We’ll walk through the simplified rules for classifying structures
    in this section. For the complete algorithm, see the documentation listed in “Additional
    Resources” on [page 553](#pg_553).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ABI提供了一个相对复杂的算法，用于对结构体和联合体进行分类。由于有许多类型我们不处理，比如<samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>和联合体，我们可以使用这个算法的简化版本。在本节中，我们将讲解简化的结构体分类规则。有关完整的算法，请参阅“附加资源”中列出的文档，见[第553页](#pg_553)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Splitting a Structure into
    Eightbytes</samp>
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">将结构体拆分成八字节</samp>
- en: We’ll assign a separate class to each 8-byte chunk of a structure. The ABI calls
    these chunks *eightbytes*. If the structure’s size isn’t exactly divisible by
    8, the last eightbyte may be shorter than 8 bytes (which makes the term a little
    misleading). Consider [Listing 18-39](chapter18.xhtml#list18-39), which declares
    a 12-byte structure.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为结构体的每个8字节部分分配一个单独的类别。ABI称这些部分为*八字节*。如果结构体的大小不能被8整除，最后一个八字节可能会短于8字节（这使得这个术语有些误导）。请参考[清单18-39](chapter18.xhtml#list18-39)，它声明了一个12字节的结构体。
- en: '[PRE69]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-39: A structure
    with two eightbytes</samp>'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单18-39：一个包含两个八字节的结构体</samp>
- en: The first eightbyte of this structure contains <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    and the first four elements of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>.
    The second eightbyte is 4 bytes long and contains the last four elements of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>. [Figure 18-2](#fig18-2) shows
    this structure’s layout in memory.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构体的第一个八字节包含<samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>的前四个元素。第二个八字节长4字节，包含<samp
    class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>的最后四个元素。[图18-2](#fig18-2)展示了该结构体在内存中的布局。
- en: '![](../images/fig18-2.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig18-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-2: The layout of
    struct twelve_bytes in memory [Description](description-44.xhtml)</samp>'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图18-2：结构体十二字节在内存中的布局 [说明](description-44.xhtml)</samp>
- en: '[Figure 18-2](#fig18-2) illustrates that a nested array like <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>
    can span multiple eightbytes. A nested structure can too. Consider the structure
    declaration in [Listing 18-40](chapter18.xhtml#list18-40).'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[图18-2](#fig18-2)展示了一个像<samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>这样的嵌套数组可以跨越多个八字节。嵌套结构体也是如此。请参考[清单18-40](chapter18.xhtml#list18-40)中的结构声明。'
- en: '[PRE70]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-40: A structure
    type containing a nested structure that spans two eightbytes</samp>'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单18-40：包含一个跨越两个八字节的嵌套结构体的结构类型</samp>
- en: '[Figure 18-3](#fig18-3) shows how a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    nested_ints</samp> will be laid out in memory.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '[图18-3](#fig18-3)展示了<samp class="SANS_TheSansMonoCd_W5Regular_11">struct nested_ints</samp>在内存中的布局。'
- en: '![](../images/fig18-3.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig18-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-3: The layout of
    struct nested_ints in memory [Description](description-45.xhtml)</samp>'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-3：结构体nested_ints在内存中的布局
    [描述](description-45.xhtml)</samp>
- en: 'The first eightbyte of this structure holds two scalar values: <samp class="SANS_TheSansMonoCd_W5Regular_11">ch1</samp>
    and the nested member <samp class="SANS_TheSansMonoCd_W5Regular_11">nested.i</samp>.
    The second eightbyte holds <samp class="SANS_TheSansMonoCd_W5Regular_11">nested.ch2</samp>.
    When we classify a structure, we care about what scalar values each eightbyte
    contains, but we don’t care how those values are grouped into nested structures
    or arrays. As far as our classification algorithm is concerned, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    nested _ints</samp> is equivalent to the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    flattened_ints</samp> type defined in [Listing 18-41](chapter18.xhtml#list18-41).'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构体的第一个八字节包含两个标量值：<samp class="SANS_TheSansMonoCd_W5Regular_11">ch1</samp>和嵌套成员<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nested.i</samp>。第二个八字节包含<samp class="SANS_TheSansMonoCd_W5Regular_11">nested.ch2</samp>。在分类结构体时，我们关心的是每个八字节包含的标量值，而不关心这些值是如何在嵌套结构或数组中组织的。就我们的分类算法而言，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct nested_ints</samp>等同于[Listing 18-41](chapter18.xhtml#list18-41)中定义的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct flattened_ints</samp>类型。
- en: '[PRE71]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-41: A structure
    with the same layout as</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">struct
    nested_ints</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in memory</samp>'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-41：具有与</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">struct nested_ints</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">相同布局的结构体</samp>
- en: 'This structure looks identical to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    nested_ints</samp> in memory: its first eightbyte holds a <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    and an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, and its second
    eightbyte holds another <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构体在内存中的布局与<samp class="SANS_TheSansMonoCd_W5Regular_11">struct nested_ints</samp>完全相同：它的第一个八字节包含一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp>和一个<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，第二个八字节包含另一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Classifying Eightbytes</samp>
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">八字节分类</samp>
- en: 'If a structure is larger than 16 bytes—in other words, if it consists of three
    or more eightbytes—we’ll assign every eightbyte to the MEMORY class. For example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct large</samp> consists of
    four eightbytes, which are all classified as MEMORY:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个结构体大于16字节——换句话说，如果它由三个或更多的八字节组成——我们将把每个八字节分配到MEMORY类别。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    large</samp>由四个八字节组成，这些八字节都被归类为MEMORY：
- en: '[PRE72]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If a structure is 16 bytes or smaller, we’ll assign each eightbyte to either
    the INTEGER or the SSE class, according to its contents. An eightbyte belongs
    to the SSE class if it contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and the INTEGER class if it contains anything else. For example, both eightbytes
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct twelve_bytes</samp>, from
    [Listing 18-39](chapter18.xhtml#list18-39), belong to the INTEGER class. We’ll
    assign both eightbytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    nested_ints</samp> from [Listing 18-40](chapter18.xhtml#list18-40) and both eightbytes
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct flattened_ints</samp>
    from [Listing 18-41](chapter18.xhtml#list18-41) to the INTEGER class too, since
    none of them hold a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个结构体为16字节或更小，我们会根据其内容将每个八字节分配到INTEGER或SSE类别。如果一个八字节包含一个<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，它属于SSE类别；如果包含其他内容，则属于INTEGER类别。例如，[Listing
    18-39](chapter18.xhtml#list18-39)中的<samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    twelve_bytes</samp>的两个八字节都属于INTEGER类别。我们还将[Listing 18-40](chapter18.xhtml#list18-40)中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct nested_ints</samp>的两个八字节和[Listing
    18-41](chapter18.xhtml#list18-41)中的<samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    flattened_ints</samp>的两个八字节也都分配到INTEGER类别，因为它们都不包含<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。
- en: '[Listing 18-42](chapter18.xhtml#list18-42) defines a few more structure types.
    Let’s classify each of them.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 18-42](chapter18.xhtml#list18-42)定义了更多的结构体类型。让我们来分类其中的每一个。'
- en: '[PRE73]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-42: More structure
    types</samp>'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-42：更多结构体类型</samp>
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct two_ints</samp> consists
    of a single eightbyte, which belongs to the INTEGER class. A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    nested_double</samp> consists of a single eightbyte in the SSE class. A <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct two_eightbytes</samp> consists
    of two eightbytes: the first is in the SSE class because it contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    and the second is in the INTEGER class because it contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">struct two_ints</samp> 由一个八字节组成，它属于INTEGER类。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct nested_double</samp> 由一个八字节组成，它属于SSE类。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct two_eightbytes</samp> 由两个八字节组成：第一个属于SSE类，因为它包含一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，第二个属于INTEGER类，因为它包含一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Passing Parameters
    of Structure Type</samp>
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">传递结构体类型的参数</samp>
- en: Once we’ve classified a structure, we can figure out how to pass it as a parameter.
    If a structure consists of one or two eightbytes, we’ll pass each eightbyte of
    the structure in the next available register for its class. If a structure consists
    of a single eightbyte in the INTEGER class, we’ll pass it in the next general-purpose
    parameter passing register. If it consists of a single eightbyte in the SSE class,
    we’ll pass it in the next available parameter passing XMM register. If it consists
    of one INTEGER eightbyte and one SSE eightbyte, we’ll pass the first eightbyte
    in a general-purpose register and the next eightbyte in an XMM register, and so
    forth. If there aren’t enough registers available to pass the entire structure,
    we’ll push the whole thing onto the stack.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对结构体进行了分类，就可以确定如何将其作为参数传递。如果结构体由一个或两个八字节组成，我们会将结构体的每个八字节传递到该类别的下一个可用寄存器中。如果结构体由一个八字节组成，并且属于INTEGER类，我们将把它传递到下一个通用参数传递寄存器中。如果它由一个八字节组成，并且属于SSE类，我们将把它传递到下一个可用的参数传递XMM寄存器中。如果它由一个INTEGER八字节和一个SSE八字节组成，我们将把第一个八字节传递到通用寄存器中，第二个八字节传递到XMM寄存器中，依此类推。如果没有足够的寄存器来传递整个结构体，我们将把整个结构体压入栈中。
- en: Let’s look at a few examples. First, in [Listing 18-43](chapter18.xhtml#list18-43),
    we reproduce the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct two_eightbytes</samp>
    type that we defined in [Listing 18-42](chapter18.xhtml#list18-42) and declare
    a function that takes a parameter with that type.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看几个例子。首先，在 [清单18-43](chapter18.xhtml#list18-43) 中，我们重现了在 [清单18-42](chapter18.xhtml#list18-42)
    中定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct two_eightbytes</samp>
    类型，并声明了一个接收该类型参数的函数。
- en: '[PRE74]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-43: A function declaration
    with a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">struct two_eightbytes</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">parameter</samp>'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单18-43：带有 <samp class="SANS_Futura_Std_Book_Oblique_I_11">struct
    two_eightbytes</samp> 参数的函数声明</samp>
- en: Suppose <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a variable
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct two_eightbytes</samp>,
    which is stored on the stack at address <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>.
    We might convert the function call <samp class="SANS_TheSansMonoCd_W5Regular_11">pass
    _struct(x)</samp> to the assembly in [Listing 18-44](chapter18.xhtml#list18-44).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 是类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    two_eightbytes</samp> 的变量，且该变量存储在栈上，地址为 <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>。我们可能会将函数调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">pass _struct(x)</samp> 转换为 [清单18-44](chapter18.xhtml#list18-44)
    中的汇编代码。
- en: '[PRE75]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-44: Passing a structure
    parameter in two registers</samp>'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单18-44：在两个寄存器中传递结构体参数</samp>
- en: Because the first eightbyte of this structure belongs to the SSE class, we pass
    it in the first parameter passing XMM register, XMM0\. The second eightbyte of
    the structure belongs to the INTEGER class, so we pass it in the first general-purpose
    parameter passing register, RDI.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 因为该结构体的第一个八字节属于SSE类，我们将其传递到第一个参数传递XMM寄存器XMM0中。结构体的第二个八字节属于INTEGER类，因此我们将其传递到第一个通用参数传递寄存器RDI中。
- en: Next, let’s look at [Listing 18-45](chapter18.xhtml#list18-45). This listing
    declares a function with a structure parameter that we’ll need to push onto the
    stack.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下[列表 18-45](chapter18.xhtml#list18-45)。这个列表声明了一个带有结构体参数的函数，我们需要将该参数推送到堆栈上。
- en: '[PRE76]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-45: A function declaration
    with a structure parameter that must be passed in memory</samp>'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 18-45：带有必须通过内存传递的结构体参数的函数声明</samp>
- en: When we call <samp class="SANS_TheSansMonoCd_W5Regular_11">a_bunch_of_arguments</samp>,
    we’ll pass parameters <samp class="SANS_TheSansMonoCd_W5Regular_11">i0</samp>
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">i4</samp> in registers EDI,
    ESI, EDX, ECX, and R8D. This doesn’t leave enough registers open to pass the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">param</samp> parameter; both eightbytes
    belong to the INTEGER class, but only one general-purpose parameter passing register,
    R9, is available. Therefore, we’ll push the whole structure onto the stack. Then,
    since R9D is still open, we’ll use it to transfer <samp class="SANS_TheSansMonoCd_W5Regular_11">i5</samp>.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    two_longs</samp> with static storage duration, we could convert the function call
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用<samp class="SANS_TheSansMonoCd_W5Regular_11">a_bunch_of_arguments</samp>时，我们会通过寄存器
    EDI、ESI、EDX、ECX 和 R8D 传递参数<samp class="SANS_TheSansMonoCd_W5Regular_11">i0</samp>到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i4</samp>。这不会留下足够的寄存器来传递<samp class="SANS_TheSansMonoCd_W5Regular_11">param</samp>参数；这两个八字节属于整数类型，但只有一个通用的参数传递寄存器
    R9 可用。因此，我们将整个结构体推送到堆栈上。然后，由于 R9D 仍然可用，我们将使用它来传输<samp class="SANS_TheSansMonoCd_W5Regular_11">i5</samp>。如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>是一个具有静态存储持续时间的<samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    two_longs</samp>，我们可以将函数调用转换为
- en: '[PRE77]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: to the assembly in [Listing 18-46](chapter18.xhtml#list18-46).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 18-46](chapter18.xhtml#list18-46)中的汇编代码。'
- en: '[PRE78]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-46: Passing a structure
    on the stack</samp>'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 18-46：将结构体传递到堆栈上</samp>
- en: 'Because <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> lives in the
    data section, we access it with RIP-relative addressing. We’re using a bit of
    new assembly syntax here: <samp class="SANS_TheSansMonoCd_W5Regular_11">arg+8(%rip)</samp>
    indicates the address 8 bytes after the label <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>.
    Our first <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instruction
    will therefore push the second eightbyte of the structure, which contains member
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, onto the stack ❶. This
    preserves the structure’s layout in memory, as [Figure 18-4](#fig18-4) demonstrates.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 因为<samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>位于数据段中，我们通过 RIP 相对寻址来访问它。我们这里使用了一些新的汇编语法：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">arg+8(%rip)</samp>表示标签<samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>之后
    8 字节的地址。因此，我们的第一个<samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>指令将把结构体的第二个八字节推送到堆栈上，其中包含成员<samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，如图 ❶所示。这保留了结构体在内存中的布局，如[图 18-4](#fig18-4)所示。
- en: '![](../images/fig18-4.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig18-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-4: Pushing a structure
    onto the stack [Description](description-46.xhtml)</samp>'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-4：将结构体推送到堆栈上 [描述](description-46.xhtml)</samp>
- en: The two <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp> instructions
    in [Listing 18-46](chapter18.xhtml#list18-46) push a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>
    onto the stack with the correct layout. After the callee sets up its stack frame,
    it can access <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> at <samp
    class="SANS_TheSansMonoCd_W5Regular_11">16(%rbp)</samp>, which is where we always
    expect to find a function’s first stack parameter.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 18-46](chapter18.xhtml#list18-46)中的两条<samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp>指令将带有正确布局的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>副本推送到堆栈上。被调用者在设置堆栈帧后，可以在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">16(%rbp)</samp>处访问<samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>，这是我们总是期望找到函数第一个堆栈参数的位置。'
- en: If a structure belongs to the MEMORY class, we’ll always push it onto the stack.
    Consider the structure type declaration and function declaration in [Listing 18-47](chapter18.xhtml#list18-47).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个结构体属于内存类型，我们将始终将它推送到堆栈上。请参考[列表 18-47](chapter18.xhtml#list18-47)中的结构体类型声明和函数声明。
- en: '[PRE79]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-47: A function declaration
    with a structure parameter that belongs to the MEMORY class</samp>'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表18-47：带有属于MEMORY类结构参数的函数声明</samp>
- en: '[Listing 18-48](chapter18.xhtml#list18-48) demonstrates how to pass a structure
    stored at <samp class="SANS_TheSansMonoCd_W5Regular_11">-32(%rbp)</samp> as an
    argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">accept_struct</samp>.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表18-48](chapter18.xhtml#list18-48)演示了如何将存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">-32(%rbp)</samp>
    处的结构作为参数传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">accept_struct</samp>。'
- en: '[PRE80]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-48: Passing a structure
    that belongs to the MEMORY class on the stack</samp>'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表18-48：在栈上传递属于MEMORY类的结构</samp>
- en: In this case, like in [Listing 18-46](chapter18.xhtml#list18-46), we maintain
    the structure’s layout in memory by pushing it onto the stack from back to front.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，像在[列表18-46](chapter18.xhtml#list18-46)中一样，我们通过将结构从后到前压入栈中来保持结构在内存中的布局。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Returning Structures</samp>
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">返回结构</samp>
- en: 'If a structure fits into a single register, returning it is straightforward.
    We’ll return structures that belong to the INTEGER class in RAX and structures
    that belong to the SSE class in XMM0\. If a structure is between 8 and 16 bytes,
    we’ll return it in two registers. To accommodate these structures, we’ll designate
    two more registers to transfer return values: RDX and XMM1\. We’ll transfer each
    eightbyte of a structure in the next available return register of the appropriate
    class. For example, if the first part of a structure belongs to the SSE class
    and the second part belongs to the INTEGER class, we’ll transfer the first part
    in XMM0 and the second part in RAX. If both parts belong to the SSE class, we’ll
    transfer the structure in XMM0 and XMM1; if both parts belong to the INTEGER class,
    we’ll transfer it in RAX and RDX.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结构适合放入单个寄存器，返回它就非常直接。我们将把属于INTEGER类的结构返回在RAX中，把属于SSE类的结构返回在XMM0中。如果一个结构的大小在8到16字节之间，我们将用两个寄存器返回它。为了容纳这些结构，我们将指定另外两个寄存器来传输返回值：RDX和XMM1。我们将在适当类的下一个可用返回寄存器中传输结构的每个八字节部分。例如，如果一个结构的第一部分属于SSE类，第二部分属于INTEGER类，我们将把第一部分传输到XMM0，第二部分传输到RAX。如果两个部分都属于SSE类，我们将把结构传输到XMM0和XMM1；如果两个部分都属于INTEGER类，我们将把它传输到RAX和RDX。
- en: Things get even hairier if a structure is in the MEMORY class. In that case,
    the caller allocates space for the return value and passes the address of that
    space to the callee in the RDI register, as if it were the first integer parameter.
    This means the actual first integer parameter must be passed in RSI, the second
    in RDX, and so on. To return a value, the callee copies it into the space pointed
    to by RDI and copies the pointer itself into RAX. Let’s look at the example in
    [Listing 18-49](chapter18.xhtml#list18-49).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结构属于MEMORY类，事情会更加复杂。在这种情况下，调用者为返回值分配空间，并将该空间的地址通过RDI寄存器传递给被调用者，就像它是第一个整数参数一样。这意味着实际的第一个整数参数必须通过RSI传递，第二个通过RDX传递，以此类推。为了返回一个值，被调用者将其复制到RDI指向的空间中，并将指针本身复制到RAX中。让我们看一下[列表18-49](chapter18.xhtml#list18-49)中的例子。
- en: '[PRE81]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-49: Calling function
    that returns a structure in memory</samp>'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表18-49：调用返回内存中结构的函数</samp>
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">struct large_struct</samp>
    is 24 bytes, we’ll return the result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp>
    function in memory. In <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>,
    we call <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp> and
    assign the result to <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>
    ❶. Assuming <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> has reserved
    stack space for <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>
    at <samp class="SANS_TheSansMonoCd_W5Regular_11">-24(%rbp)</samp>, [Listing 18-50](chapter18.xhtml#list18-50)
    shows how to implement this function call.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct large_struct</samp>
    是 24 字节，所以我们将在内存中返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp>
    函数的结果。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 中，我们调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp> 并将结果赋值给 <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>
    ❶。假设 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 已经为 <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>
    在 <samp class="SANS_TheSansMonoCd_W5Regular_11">-24(%rbp)</samp> 预留了栈空间，[Listing
    18-50](chapter18.xhtml#list18-50) 展示了如何实现此函数调用。
- en: '[PRE82]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-50: Calling</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">return_a_struct</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    assembly</samp>'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-50：汇编中调用</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">return_a_struct</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数</samp>
- en: First, we pass the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>,
    which will hold the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp>,
    in RDI. We then pass the argument <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    in the next available parameter passing register, RSI. Finally, we issue a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction. [Figure 18-5](#fig18-5)
    illustrates the program’s state just before the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instruction.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp> 的地址传递给
    RDI，该地址将保存 <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp>
    的结果。然后，我们在下一个可用的参数传递寄存器 RSI 中传递参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>。最后，我们发出
    <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> 指令。[图 18-5](#fig18-5)
    说明了程序在发出 <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> 指令前的状态。
- en: '![](../images/fig18-5.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig18-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-5: The state of the
    stack and registers before calling return_a_struct [Description](description-47.xhtml)</samp>'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-5：调用 return_a_struct 前栈和寄存器的状态
    [描述](description-47.xhtml)</samp>
- en: RSP and RBP point to the top and bottom of the current stack frame, as usual.
    RDI points to <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>,
    which hasn’t been initialized yet. RSI holds the first argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，RSP 和 RBP 指向当前栈帧的顶部和底部。RDI 指向尚未初始化的 <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>。RSI
    保存着传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp> 的第一个参数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>。
- en: 'Note that [Listing 18-50](chapter18.xhtml#list18-50) doesn’t allocate additional
    stack space to hold the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp>;
    it just loads the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>
    variable. That’s typically fine, with one caveat: according to the ABI, the memory
    that will hold the return value “must not overlap any data visible to the callee
    through other names than this argument.” For example, if you needed to implement
    the function call <samp class="SANS_TheSansMonoCd_W5Regular_11">var = foo(1, 2,
    &var)</samp>, it would violate the ABI to pass the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    in RDI as the storage for the return value *and* in RCX as an ordinary argument.
    Instead, you’d need to allocate additional stack space to hold the result of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> and copy the result to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">var</samp> after the function returned.
    We don’t need to worry about this case, since we generate a new variable to hold
    the result of each function call during TACKY generation.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[清单 18-50](chapter18.xhtml#list18-50) 没有为存储 <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp>
    的结果分配额外的堆栈空间；它只是加载了 <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>
    变量的地址。通常这是可以的，但有一个前提：根据 ABI，存储返回值的内存“不能与被调用方通过除该参数外的其他名称可见的数据重叠。”例如，如果你需要实现如下函数调用：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">var = foo(1, 2, &var)</samp>，那么将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">var</samp> 的地址既传递给 RDI 作为返回值的存储位置，又传递给
    RCX 作为普通参数，会违反 ABI。相反，你需要为存储 <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    的结果分配额外的堆栈空间，并在函数返回后将结果复制到 <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>。我们不需要担心这种情况，因为我们在
    TACKY 生成过程中为每次函数调用生成一个新的变量来存储结果。
- en: Now let’s look at [Listing 18-51](chapter18.xhtml#list18-51), which implements
    <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp> in assembly.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下实现 <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp>
    的汇编代码 [清单 18-51](chapter18.xhtml#list18-51)。
- en: '[PRE83]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-51: Returning a
    structure in memory</samp>'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-51：在内存中返回结构体</samp>
- en: At the start of the function, we set up the stack frame, allocate stack space
    for the local <samp class="SANS_TheSansMonoCd_W5Regular_11">callee_result</samp>
    variable at <samp class="SANS_TheSansMonoCd_W5Regular_11">-24(%rbp)</samp>, and
    then initialize it. The assembly code to return <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    starts at ❶. First, we copy <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    into the memory location that RDI points to, 8 bytes at a time; we’ll copy the
    first 8 bytes to <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rdi)</samp>,
    the next 8 bytes to <samp class="SANS_TheSansMonoCd_W5Regular_11">8(%rdi)</samp>,
    and the last 8 bytes to <samp class="SANS_TheSansMonoCd_W5Regular_11">16(%rdi)</samp>.
    Then, we copy the pointer to the return value from RDI into RAX ❷. Finally, we
    execute the function epilogue, which is omitted from this listing. [Figure 18-6](#fig18-6)
    illustrates the state of the program just before the function epilogue.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数开始时，我们设置堆栈帧，为局部变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">callee_result</samp>
    分配堆栈空间，地址为 <samp class="SANS_TheSansMonoCd_W5Regular_11">-24(%rbp)</samp>，然后初始化它。返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> 的汇编代码从 ❶ 开始。首先，我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> 复制到 RDI 指向的内存位置，每次复制
    8 个字节；我们将前 8 个字节复制到 <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rdi)</samp>，接下来的
    8 个字节复制到 <samp class="SANS_TheSansMonoCd_W5Regular_11">8(%rdi)</samp>，最后 8 个字节复制到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">16(%rdi)</samp>。然后，我们将返回值的指针从 RDI
    复制到 RAX ❷。最后，我们执行函数的尾部操作，这部分代码在本清单中省略。[图 18-6](#fig18-6) 展示了函数尾部操作前程序的状态。
- en: '![](../images/fig18-6.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig18-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-6: The state of the
    stack and registers just before returning from return_a_struct [Description](description-48.xhtml)</samp>'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-6：从 return_a_struct 返回前堆栈和寄存器的状态
    [说明](description-48.xhtml)</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp> variable
    in the caller’s stack frame now holds the function’s return value, and RAX holds
    the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>.
    In this example, the RDI register holds that address too, but this isn’t required
    by the ABI.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者栈帧中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp> 变量现在保存着函数的返回值，而
    RAX 寄存器保存着 <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>
    的地址。在这个例子中，RDI 寄存器也保存着该地址，但这并不是 ABI 所要求的。
- en: We’ve covered everything we need to know about the calling convention for structures.
    Now we’re ready to work on the assembly generation pass!
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了与结构体调用约定相关的所有内容。现在我们准备开始处理汇编生成过程！
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">汇编生成</samp>
- en: This pass will change in a couple of ways. First, we’ll need to generate assembly
    to copy entire structures from one location to another. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> instructions
    can all transfer both scalar and aggregate values. So can the new <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    instruction, which we’ll need to implement. Second, we’ll implement the System
    V calling convention that we just learned about.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这个传递过程将会有几个变化。首先，我们需要生成汇编代码，以便将整个结构从一个位置复制到另一个位置。<samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> 指令都可以传输标量值和聚合值。新的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> 指令也可以实现这一点，我们需要实现它。其次，我们将实现刚刚学习过的
    System V 调用约定。
- en: We’ll start by making a few small changes to the assembly AST.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过对汇编 AST 做出一些小改动来开始。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extending the Assembly
    AST</samp>
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">扩展汇编 AST</samp>
- en: 'In [Listing 18-46](chapter18.xhtml#list18-46), we used the operand <samp class="SANS_TheSansMonoCd_W5Regular_11">arg+8(%rip)</samp>
    to access data at a constant offset from a RIP-relative label. We’ll often need
    these sorts of operands to access members of structures with static storage duration.
    The assembly AST can already specify constant offsets from most memory addresses,
    but not from RIP-relative addresses. We’ll remove this limitation by adding an
    offset to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operand:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 18-46](chapter18.xhtml#list18-46) 中，我们使用了操作数 <samp class="SANS_TheSansMonoCd_W5Regular_11">arg+8(%rip)</samp>
    来访问与 RIP 相对标签具有常量偏移的数据。我们通常需要这种类型的操作数来访问具有静态存储持续时间的结构成员。汇编 AST 已经可以指定从大多数内存地址的常量偏移量，但不能从
    RIP 相对地址指定。我们将通过向 <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> 操作数添加一个偏移量来移除这个限制：
- en: '[PRE84]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We’ll also introduce two new assembly instructions. First, we’ll add the left-shift
    instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>. This instruction
    takes an immediate value as its source operand and a memory address or register
    as its destination. It shifts its destination left by the number of bits specified
    by its source. For example, the instruction
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将引入两条新的汇编指令。首先，我们将添加左移指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>。该指令将一个立即数作为源操作数，一个内存地址或寄存器作为目标操作数。它将目标操作数向左移动指定的位数。例如，指令
- en: '[PRE85]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: shifts the value in RAX 1 byte to the left, setting its lowest byte to 0\. If
    the value in RAX were <samp class="SANS_TheSansMonoCd_W5Regular_11">0x8</samp>
    before this instruction, it would be <samp class="SANS_TheSansMonoCd_W5Regular_11">0x800</samp>
    afterward. The <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> instruction
    will help us copy irregularly sized structures into registers in order to pass
    them as arguments and return values. Because we can’t directly access every individual
    byte within a register, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>
    to shift each byte into place.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 将 RAX 中的值左移 1 字节，最低字节设为 0。如果 RAX 中的值在执行此指令前为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x8</samp>，则执行后将变为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x800</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>
    指令将帮助我们将不规则大小的结构复制到寄存器中，以便将它们作为参数和返回值传递。由于我们不能直接访问寄存器中的每个字节，我们将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>
    将每个字节移到正确的位置。
- en: Second, we’ll add the two-operand form of the logical right-shift instruction,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>. (We added the one-operand
    form, which shifts its operand 1 bit to the right, back in [Chapter 13](chapter13.xhtml).)
    Similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>, it shifts
    its destination right by the number of bits its source specifies. It will serve
    a similar purpose to <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>,
    helping us transfer irregularly sized structures *out* of registers and into memory.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们将添加逻辑右移指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp> 的双操作数形式。（我们在[第13章](chapter13.xhtml)中已经添加了单操作数形式，它将操作数向右移动1位。）与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> 类似，它将目标操作数按源操作数指定的位数向右移动。它将发挥与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> 类似的作用，帮助我们将不规则大小的结构从寄存器转移到内存中，*从*寄存器移出。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*The shl instruction also has a one-operand form, which we won’t use; it’s
    the counterpart to the one-operand form of shr that we’re already familiar with.
    Both instructions have yet another form we won’t use, which uses the CL register
    as the source operand.*'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '*shl 指令也有一个单操作数形式，但我们不会使用它；它是与我们已经熟悉的 shr 单操作数形式的对照形式。两条指令还有一种我们也不会使用的形式，它使用
    CL 寄存器作为源操作数。*'
- en: 'We’ll extend <samp class="SANS_TheSansMonoCd_W5Regular_11">binary_operator</samp>
    to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展 <samp class="SANS_TheSansMonoCd_W5Regular_11">binary_operator</samp> 来表示
    <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>：
- en: '[PRE86]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The new binary <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp> instruction
    gets the rather clunky name <samp class="SANS_TheSansMonoCd_W5Regular_11">ShrTwoOp</samp>
    to distinguish it from the existing unary <samp class="SANS_TheSansMonoCd_W5Regular_11">Shr</samp>
    instruction in the assembly AST.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 新的二元 <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp> 指令获得了一个较为笨重的名称
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ShrTwoOp</samp>，以便与现有的单元 <samp class="SANS_TheSansMonoCd_W5Regular_11">Shr</samp>
    指令在汇编 AST 中区分开来。
- en: '[Listing 18-52](chapter18.xhtml#list18-52) defines the updated assembly AST,
    with these changes bolded.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 18-52](chapter18.xhtml#list18-52) 定义了更新后的汇编 AST，变化部分已加粗显示。'
- en: '[PRE87]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-52: The assembly
    AST with offsets on static operands and bit shift instructions</samp>'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-52：带有静态操作数偏移量和位移指令的汇编
    AST</samp>
- en: Converting types and TACKY operands to assembly is pretty simple. Structure
    types, like array types, are converted to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>
    assembly type. To convert a structure type to assembly, you’ll need to look up
    its size and alignment in the type table. We’ll convert TACKY variables of structure
    type to <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> assembly
    operands, just like we do with arrays. We’ll always store arrays and structures
    in memory rather than registers, even once we implement register allocation in
    [Part III](part3.xhtml).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换和 TACKY 操作数转换为汇编相对简单。结构类型，如数组类型，转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>
    汇编类型。要将结构类型转换为汇编，你需要在类型表中查找它的大小和对齐方式。我们将结构类型的 TACKY 变量转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    汇编操作数，就像我们处理数组一样。我们始终将数组和结构存储在内存中，而不是寄存器中，即使我们在[第三部分](part3.xhtml)实现寄存器分配后也是如此。
- en: Some of the TACKY variables you encounter may have incomplete structure types.
    (Remember that it’s legal to declare an <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>
    variable with an incomplete type and take its address, but it’s illegal to define
    it or use it in any other way.) Convert these variables to <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operands, like other variables of structure type. You can give these variables
    a dummy assembly type when you add them to the backend symbol table; that dummy
    type will never be used.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 你遇到的一些 TACKY 变量可能具有不完整的结构类型。（记住，声明一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>
    变量并取其地址是合法的，但定义它或以其他方式使用它是非法的。）将这些变量转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    操作数，就像其他结构类型的变量一样。当你将它们添加到后端符号表时，可以为这些变量指定一个虚拟的汇编类型；该虚拟类型永远不会被使用。
- en: Next, let’s handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    instructions. Then, we’ll deal with function calls.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理 <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> 指令。然后，我们将处理函数调用。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copying Structures</samp>'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">复制结构体</samp>'
- en: To copy a structure to a new location, you don’t need to consider its members’
    types or offsets; you just need to copy the right number of bytes. To minimize
    the number of <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions
    required, copy 8 bytes at a time until there are fewer than 8 bytes left to move.
    Then, copy 4 bytes at a time. Finally, when there are fewer than 4 bytes left
    to move, copy 1 byte at a time. (There’s also a 2-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction in x64 assembly, but our assembly AST doesn’t support it.) For example,
    if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    are 20-byte structures, you should translate
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 要将结构体复制到新位置，你不需要考虑其成员的类型或偏移量；你只需要复制正确数量的字节。为了最小化所需的 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    指令数量，一次复制 8 个字节，直到剩下少于 8 个字节需要移动。然后，每次复制 4 个字节。最后，当剩下的字节数少于 4 个字节时，每次复制 1 个字节。（x64
    汇编中还有一个 2 字节的 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令，但我们的汇编
    AST 不支持它。）例如，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 是 20 字节的结构体，你应该翻译
- en: '[PRE88]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: to the assembly in [Listing 18-53](chapter18.xhtml#list18-53).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 到 [列表 18-53](chapter18.xhtml#list18-53) 中的汇编代码。
- en: '[PRE89]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-53: Implementing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">Copy</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for
    non-scalar values</samp>'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 18-53：实现</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">非标量值的
    Copy</samp>
- en: The first <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction
    copies the first 8 bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>; the second instruction
    copies the next 8 bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    to the corresponding offset in <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>,
    and the final instruction copies the remaining 4 bytes. These <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instructions are invalid, since their source and destination operands are both
    in memory, but they’ll be rewritten in the instruction fix-up pass.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> 指令将 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    的前 8 个字节复制到 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>；第二条指令将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 的下一个 8 个字节复制到 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    中相应的偏移位置，最后一条指令复制剩余的 4 个字节。这些 <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    指令无效，因为它们的源操作数和目标操作数都在内存中，但它们将在指令修复过程中被重写。
- en: You can use the same approach to translate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instructions. For
    example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is a 6-byte
    structure, you’ll translate
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用相同的方法来翻译 <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> 指令。例如，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    是一个 6 字节的结构体，你将翻译
- en: '[PRE90]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: to [Listing 18-54](chapter18.xhtml#list18-54).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 到 [列表 18-54](chapter18.xhtml#list18-54)。
- en: '[PRE91]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-54: Implementing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">Load</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for
    non-scalar values</samp>'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 18-54：实现</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">非标量值的
    Load</samp>
- en: The first instruction copies the pointer into the RAX register. Each subsequent
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction copies a
    chunk of data stored at some offset from the address in RAX to the corresponding
    offset in <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令将指针复制到RAX寄存器中。每条后续的<samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>指令将从RAX中的地址偏移处复制一块数据到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>中的相应偏移处。
- en: You can also implement <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    for non-scalar values with a sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instructions; the only difference is that you’ll add the specified offset to each
    instruction’s destination. To give another example with the 6-byte structure <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, you’ll translate
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用一系列<samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>指令实现非标量值的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>；唯一的不同之处在于，你需要将指定的偏移量添加到每条指令的目标地址中。再举个例子，假设有一个6字节的结构体<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>，你需要转换为：
- en: '[PRE92]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: to [Listing 18-55](chapter18.xhtml#list18-55).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 转到[清单 18-55](chapter18.xhtml#list18-55)。
- en: '[PRE93]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-55: Implementing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">CopyToOffset</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for
    non-scalar values</samp>'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-55：实现</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">CopyToOffset</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">用于非标量值</samp>
- en: Finally, you’ll need to implement the new <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    instruction. Like the other TACKY instructions that copy data, it accepts both
    scalar and non-scalar operands. I won’t talk through this instruction in detail;
    you should handle it basically the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要实现新的<samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>指令。像其他复制数据的TACKY指令一样，它接受标量和非标量操作数。我不会详细讲解这条指令；你应该以类似<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>的方式处理它。
- en: I recommend writing a helper function, which I’ll call <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes</samp>,
    that generates assembly instructions to copy an arbitrary number of bytes from
    one <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operand to another. You can use this helper function to implement all five of
    the TACKY copying instructions. It will come in handy again when you need to pass
    structures in memory as arguments and return values.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议编写一个辅助函数，我将其命名为<samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes</samp>，它生成汇编指令，用于将任意数量的字节从一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>操作数复制到另一个。你可以使用这个辅助函数来实现五条TACKY复制指令。当你需要将内存中的结构体作为参数传递或返回值时，它会再次派上用场。
- en: Once you’ve implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    and extended the other copy instructions to support non-scalar values, you’re
    ready to move on to function calls.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你实现了<samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>并扩展了其他复制指令以支持非标量值，你就可以继续进行函数调用的部分了。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Structures
    in Function Calls</samp>
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在函数调用中使用结构体</samp>
- en: 'Since the rules for passing and returning structures are complex, let’s talk
    about our overall strategy before diving into the pseudocode. First, we’ll write
    a function to classify each eightbyte of a structure type. Then, we’ll extend
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp> helper
    function, which we introduced back in [Chapter 13](chapter13.xhtml) to help with
    parameter passing on both the caller and callee sides. Remember that this function
    returns three lists: operands passed in general-purpose registers, operands passed
    in XMM registers, and operands passed on the stack. Once we update this function,
    these lists may include both scalar values and eightbytes of structure values.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 由于传递和返回结构体的规则比较复杂，在进入伪代码之前，我们先来讨论一下总体策略。首先，我们将编写一个函数来分类每个结构体类型的八字节。然后，我们会扩展之前在[第13章](chapter13.xhtml)中引入的辅助函数`classify_parameters`，帮助处理调用方和被调用方的参数传递。记住，这个函数会返回三个列表：通过通用寄存器传递的操作数，通过XMM寄存器传递的操作数，以及通过栈传递的操作数。一旦我们更新了这个函数，这些列表可能包含标量值和结构体的八字节值。
- en: Next, we’ll introduce another helper function, <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>,
    to split up return values in a similar way. It will return a list of operands
    returned in general-purpose registers, a list of operands returned in XMM registers,
    and a Boolean flag that indicates whether the return value is passed in memory.
    This flag will be <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> only
    when both lists are empty.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍另一个辅助函数<samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>，以类似的方式拆分返回值。它将返回一个包含在通用寄存器中返回的操作数的列表，一个包含在XMM寄存器中返回的操作数的列表，以及一个布尔标志，指示返回值是否通过内存传递。当这两个列表为空时，该标志将为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。
- en: When <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>
    processes a scalar value, it will return one empty list, one list with a single
    element, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> flag.
    When it processes a structure, it might produce a more interesting result. Its
    main purpose is to massage both scalar and structure return values into the same
    shape, so we can process them in a uniform way.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 当<samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>处理标量值时，它将返回一个空列表，一个包含单个元素的列表，以及一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>标志。当它处理结构时，可能会产生更有趣的结果。它的主要目的是将标量值和结构返回值转换成相同的形式，以便我们可以以统一的方式处理它们。
- en: Once these helpers are in place, we’ll update how we convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    TACKY instruction to assembly. For the most part, we can pass parameters the same
    way as in earlier chapters. We’ll copy each operand we get from <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>
    into the appropriate register or push it onto the stack, without worrying about
    whether it’s a scalar value or part of a structure. Only a few details will change.
    First, we’ll account for the fact that RDI may not be available if it holds the
    address of the space reserved for the return value. We’ll also need to pass irregularly
    sized eightbytes that can’t be transferred with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction. We’ll write a new helper function to move these eightbytes into registers.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些辅助函数到位，我们将更新如何将<samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    TACKY指令转换为汇编代码。大多数情况下，我们可以像前面章节一样处理参数。我们将把从<samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>获取的每个操作数复制到适当的寄存器中或推送到栈上，而不必担心它是标量值还是结构的一部分。只有少数几个细节会发生变化。首先，我们将考虑到如果RDI保存了为返回值预留的空间的地址，它可能不可用。我们还需要处理无法通过单个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>指令传送的不规则大小的八字节。我们将编写一个新的辅助函数，将这些八字节移动到寄存器中。
- en: Retrieving the function’s return value will require larger changes. We’ll use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp> to
    learn where we can find each part of the return value, then copy each part from
    the appropriate register or memory address to its final destination. This will
    require yet another helper function to copy irregularly sized eightbytes *out*
    of registers.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 获取函数的返回值将需要较大的改动。我们将使用<samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>来了解我们可以在哪里找到返回值的每个部分，然后将每个部分从相应的寄存器或内存地址复制到最终目的地。这将需要另一个辅助函数，将不规则大小的八字节从寄存器中“取出”。
- en: Finally, we’ll tackle things on the callee side. Here, like on the caller side,
    the way we process parameters will change only slightly, but the way we handle
    return values will change quite a bit. We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>
    again to figure out where to put each part of the return value.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将处理被调用方的事情。这里，与调用方类似，我们处理参数的方式只会有细微的变化，但处理返回值的方式将发生较大变化。我们将再次使用<samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>来确定每个返回值部分应该放在哪里。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Classifying Structure Types</samp>
  id: totrans-436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">分类结构类型</samp>
- en: We’ll start with a helper function to classify structure types. We’ll use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp> construct defined in
    [Listing 18-56](chapter18.xhtml#list18-56) to represent the three classes we discussed
    earlier.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写一个辅助函数来分类结构类型。我们将使用在[Listing 18-56](chapter18.xhtml#list18-56)中定义的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">class</samp>构造来表示我们之前讨论的三个类。
- en: '[PRE94]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-56: The</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">class</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">construct</samp>'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-56: 类</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">构造</samp>'
- en: The classification function will return a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp>
    elements, one for each eightbyte of the structure being classified. To classify
    a structure, we’ll first consider its size and then look at the types of its members.
    [Listing 18-57](chapter18.xhtml#list18-57) gives the pseudocode for this process.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 分类函数将返回一个包含<samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp> 元素的列表，每个元素对应于正在分类的结构体中的每个
    8 字节。为了分类一个结构体，我们首先考虑它的大小，然后查看其成员的类型。[清单 18-57](chapter18.xhtml#list18-57)给出了这个过程的伪代码。
- en: '[PRE95]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-57: Classifying
    structure types</samp>'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-57: 分类结构类型</samp>'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_structure</samp>
    function takes a structure definition from the type table. If the structure is
    larger than 16 bytes, it must be passed in memory, so we return a list of enough
    MEMORY elements to cover the whole structure. For example, if the structure’s
    size is 17 bytes, <samp class="SANS_TheSansMonoCd_W5Regular_11">classify _structure</samp>
    should return <samp class="SANS_TheSansMonoCd_W5Regular_11">[MEMORY, MEMORY, MEMORY]</samp>.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_structure</samp> 函数从类型表中获取结构体定义。如果结构体的大小超过
    16 字节，它必须通过内存传递，因此我们返回足够的 MEMORY 元素列表来覆盖整个结构体。例如，如果结构体的大小是 17 字节，<samp class="SANS_TheSansMonoCd_W5Regular_11">classify_structure</samp>
    应该返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">[MEMORY, MEMORY, MEMORY]</samp>。
- en: 'Otherwise, the structure’s classification depends on its member types. We construct
    a list of every scalar type the structure contains, including the types of nested
    values ❶. Suppose a structure contains two members: an <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp> and a <samp class="SANS_TheSansMonoCd_W5Regular_11">char[3]</samp>. The
    resulting <samp class="SANS_TheSansMonoCd_W5Regular_11">scalar_types</samp> list
    will be <samp class="SANS_TheSansMonoCd_W5Regular_11">[Pointer(Int), Char, Char,
    Char]</samp>.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，结构体的分类依赖于其成员的类型。我们会构建一个包含结构体中每个标量类型的列表，包括嵌套值的类型 ❶。假设一个结构体包含两个成员：一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int *</samp> 和一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">char[3]</samp>。结果的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">scalar_types</samp> 列表将是 <samp class="SANS_TheSansMonoCd_W5Regular_11">[Pointer(Int),
    Char, Char, Char]</samp>。
- en: If a structure is between 8 and 16 bytes, we return a list of two classes ❷.
    Because a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> has a size
    and alignment of 8 bytes, any <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    that appears in a structure of this size must completely occupy either the first
    or second eightbyte. Taking advantage of this fact, we examine only the first
    and last elements of <samp class="SANS_TheSansMonoCd_W5Regular_11">scalar_type</samp>.
    If the first element is <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>,
    the first eightbyte must be in the SSE class; otherwise, it must be in the INTEGER
    class. Likewise, the second eightbyte is in the SSE class only if the last element
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">scalar_type</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结构体的大小在 8 到 16 字节之间，我们将返回两个类别的列表 ❷。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    的大小和对齐方式是 8 字节，任何出现在此大小结构体中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    必须完全占据第一个或第二个 8 字节。利用这一点，我们只检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">scalar_type</samp>
    的第一个和最后一个元素。如果第一个元素是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>，那么第一个
    8 字节必须属于 SSE 类；否则，它必须属于 INTEGER 类。同样，只有当 <samp class="SANS_TheSansMonoCd_W5Regular_11">scalar_type</samp>
    的最后一个元素是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> 时，第二个 8 字节才属于
    SSE 类。
- en: Finally, we classify structures that are 8 bytes or smaller. A structure of
    this size belongs to the SSE class if the first (and only) scalar type it contains
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> ❸. Otherwise, it
    belongs to the INTEGER class ❹.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将结构体大小为 8 字节或更小的分类。如果结构体包含的第一个（也是唯一的）标量类型是<samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>
    ❸，则该结构体属于 SSE 类。否则，它属于 INTEGER 类 ❹。
- en: If you want, you can improve on the code in [Listing 18-57](chapter18.xhtml#list18-57)
    by caching the results. You’ll need to maintain a mapping from structure tags
    to their classifications. The first time you classify a particular structure type,
    add the result to this mapping. Then, if you need to classify that structure type
    again, you can just retrieve the result instead of recomputing it.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以通过缓存结果来改进 [列表 18-57](chapter18.xhtml#list18-57) 中的代码。你需要维护一个结构标签到其分类的映射。第一次分类某个特定结构类型时，将结果添加到该映射中。然后，如果需要再次分类该结构类型，你只需检索结果，而不必重新计算。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Classifying Parameters</samp>
  id: totrans-448
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">参数分类</samp>
- en: Next, we’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>
    function. This function partitions a list of parameters or arguments in three,
    based on whether each one is passed in a general-purpose register, in an XMM register,
    or on the stack. Now, when it processes a value of structure type, it will split
    up the value into eightbytes and add each one to the correct list. [Listing 18-58](chapter18.xhtml#list18-58)
    reproduces the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>
    from [Listing 13-29](chapter13.xhtml#list13-29), with changes bolded.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将扩展 <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>
    函数。这个函数将根据每个参数是通过通用寄存器、XMM寄存器，还是通过栈传递，将参数列表划分为三部分。现在，当它处理结构类型的值时，它会将该值拆分成八字节，并将每个八字节添加到正确的列表中。[列表
    18-58](chapter18.xhtml#list18-58) 复制了 [列表 13-29](chapter13.xhtml#list13-29) 中
    <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp> 的定义，并对更改部分进行了加粗标注。
- en: '[PRE96]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-58: Extending</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">classify_parameters</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">to support structures</samp>'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 18-58：扩展</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">classify_parameters</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">以支持结构体</samp>
- en: The first change to this function is the new Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">return_in_memory</samp>
    parameter. As the name suggests, this indicates whether the function’s return
    value is passed in memory. If it is, that memory address will be passed in the
    RDI register, leaving one fewer general-purpose register available for other parameters.
    We’ll set <samp class="SANS_TheSansMonoCd_W5Regular_11">int_regs_available</samp>
    accordingly. Then, when we process parameters of integer or pointer type, we’ll
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">int _regs_available</samp>,
    instead of the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>,
    as the number of usable general-purpose registers. (We’ll process parameters of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type exactly the same
    way we did in [Chapter 13](chapter13.xhtml), so I’ve snipped out that bit of the
    listing.)
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的第一个变化是新增的布尔类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">return_in_memory</samp>
    参数。顾名思义，该参数指示函数的返回值是否通过内存传递。如果是，内存地址将通过 RDI 寄存器传递，这样就会有一个较少的通用寄存器可用于其他参数。我们会相应地设置
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int_regs_available</samp>。然后，当我们处理整数或指针类型的参数时，我们将使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int_regs_available</samp>，而不是常量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>，作为可用的通用寄存器数量。（我们将以与 [第13章](chapter13.xhtml)
    中完全相同的方式处理 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 类型的参数，所以我已经将该部分从列表中剪除。）
- en: 'Now we’ve reached the interesting part: processing parameters of structure
    type. We’ll start with a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_structure</samp>
    ❶. Then, we’ll check whether the first eightbyte of the structure is in the MEMORY
    class ❷. If it is, the rest of the structure must be too. If not, we’ll try to
    assign each eightbyte to a register. We’ll convert each eightbyte to a <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operand ❸, then add it to one of two lists, <samp class="SANS_TheSansMonoCd_W5Regular_11">tentative_doubles</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">tentative_ints</samp>, based
    on its class. We know that <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>
    is a variable, rather than a constant, because there are no aggregate constants
    in TACKY; the name of that variable will be the base of the <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operand.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进入了有趣的部分：处理结构类型的参数。我们将从调用<samp class="SANS_TheSansMonoCd_W5Regular_11">classify_structure</samp>
    ❶开始。接下来，我们将检查结构的前一个八字节是否属于MEMORY类 ❷。如果是，那么结构的其余部分也必须属于MEMORY类。如果不是，我们将尝试将每个八字节分配到一个寄存器中。我们将把每个八字节转换为一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>操作数 ❸，然后根据其类型，将其添加到两个列表之一：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tentative_doubles</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">tentative_ints</samp>。我们知道<samp
    class="SANS_TheSansMonoCd_W5Regular_11">v</samp>是一个变量，而不是常量，因为TACKY中没有聚合常量；该变量的名称将成为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>操作数的基值。
- en: 'When we add an eightbyte to <samp class="SANS_TheSansMonoCd_W5Regular_11">tentative_ints</samp>,
    we need to figure out what assembly type to associate it with. Most eightbytes
    are exactly 8 bytes long, so we associate them with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    type. But the final eightbyte in a structure might be shorter. We’ll find each
    eightbyte’s assembly type using the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp>
    helper function ❹, which we’ll walk through in a moment. This function takes two
    arguments: the eightbyte’s offset and the total size of the structure. It will
    use these to figure out the eightbyte’s size, which dictates its assembly type.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个八字节添加到<samp class="SANS_TheSansMonoCd_W5Regular_11">tentative_ints</samp>时，我们需要确定将其与哪个汇编类型关联。大多数八字节正好是8字节长，因此我们将它们与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>类型关联。但是结构中的最后一个八字节可能更短。我们将通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp>辅助函数 ❹来查找每个八字节的汇编类型，我们稍后会逐步讲解这个函数。该函数接受两个参数：八字节的偏移量和结构的总大小。它将使用这些信息来确定八字节的大小，从而决定其汇编类型。
- en: Once we’ve partitioned the whole structure into two tentative lists, we check
    that we have enough free registers to accommodate both of them ❺. If we do, we
    append both lists to their non-tentative equivalents. If we don’t have enough
    registers available, or if the structure belongs to the MEMORY class, we add each
    eightbyte to <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp> instead
    ❻. We use <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">_type</samp> to determine the type of
    each eightbyte we pass on the stack.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将整个结构分割成两个临时列表，我们会检查是否有足够的空闲寄存器来容纳它们 ❺。如果有，我们将把这两个列表添加到它们各自的非临时列表中。如果没有足够的寄存器可用，或者结构属于MEMORY类，我们会将每个八字节添加到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp>中 ❻。我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_type</samp>来确定我们在堆栈上传递的每个八字节的类型。
- en: Now let’s walk through <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp>,
    defined in [Listing 18-59](chapter18.xhtml#list18-59).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们逐步解析<samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp>，它定义在[清单
    18-59](chapter18.xhtml#list18-59)中。
- en: '[PRE97]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-59: Associating
    an eightbyte with an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">assembly_type</samp>'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-59：将八字节与</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">assembly_type</samp> 关联
- en: The goal here is to figure out what operand size to use when moving this eightbyte
    into a register or onto the stack. First, we calculate the number of bytes between
    the start of this eightbyte and the end of the whole structure ❶. If there are
    more than 8 bytes left in the structure, this isn’t the last eightbyte, so we
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> type. If
    this eightbyte is exactly 8 bytes, 4 bytes, or 1 byte long, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>
    type, respectively.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标是确定在将此八字节移动到寄存器或栈上时，应该使用什么操作数大小。首先，我们计算此八字节的起始位置与整个结构末尾之间的字节数 ❶。如果结构中剩余的字节超过8个，那么这不是最后一个八字节，因此我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> 类型。如果此八字节正好是8字节、4字节或1字节长，我们分别使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp> 类型。
- en: Otherwise, the eightbyte’s size is irregular; it’s not a valid operand size
    for assembly instructions. In this case, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>
    type to record the eightbyte’s exact size in bytes ❷. (The alignment in this <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp> is a dummy value; we
    won’t need it later.) We can’t safely transfer an irregularly sized eightbyte
    with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction.
    As you learned in [Chapter 9](chapter9.xhtml), reading past the end of a value
    in memory—by pushing a 4-byte value with an 8-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp>
    instruction, for example—could trigger a memory access violation. By the same
    logic, it’s not safe to transfer a 5-, 6-, or 7-byte operand with an 8-byte <samp
    class="SANS_TheSansMonoCd_W5Regular_11">movq</samp> instruction or a 3-byte operand
    with a 4-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction.
    We’ll look at how to transfer irregularly sized eightbytes in a moment.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，八字节的大小是不规则的；它不是汇编指令的有效操作数大小。在这种情况下，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>
    类型来记录八字节的确切字节大小 ❷。（此 <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>
    中的对齐是一个虚拟值，稍后我们不需要它。）我们无法安全地通过单个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    指令传输一个大小不规则的八字节。正如你在[第9章](chapter9.xhtml)中学到的，越过内存中某个值的末尾进行读取——例如，使用8字节的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp> 指令推送一个4字节的值——可能会触发内存访问违规。根据同样的逻辑，使用8字节的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">movq</samp> 指令传输5字节、6字节或7字节的操作数，或使用4字节的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> 指令传输3字节的操作数都是不安全的。稍后我们将讨论如何传输大小不规则的八字节。
- en: Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp>
    doesn’t consider the eightbyte’s class; it will return <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    for any full-length eightbyte, even if it belongs to the SSE class. This is correct
    because we use <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp>
    only to find the types of values we’re going to transfer in general-purpose registers
    or on the stack. When we push 8 bytes of a structure onto the stack, we don’t
    care whether those bytes contain a floating-point value or an integer.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp>
    不考虑八字节的类别；它会返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> 对于任何完整长度的八字节，即使它属于SSE类别。这是正确的，因为我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp> 仅仅是为了找出我们将要在通用寄存器或栈上转移的值的类型。当我们将一个结构的8字节推入栈时，我们不关心这些字节是否包含浮点值或整数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Classifying Return Values</samp>
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">返回值分类</samp>
- en: Next, we’ll write a similar helper function to classify return values. This
    function is simpler than <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>.
    We have one value to deal with, instead of a whole list, so we don’t need to worry
    about running out of registers. We also don’t need to split up the value into
    eightbytes if it will be returned in memory, like we did in <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>.
    [Listing 18-60](chapter18.xhtml#list18-60) shows the pseudocode for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp> helper function.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个类似的辅助函数来分类返回值。这个函数比 <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>
    更简单。我们只需要处理一个值，而不是整个列表，因此不需要担心寄存器不够用。如果返回值需要存储在内存中，我们也不需要像在 <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>
    中那样将值拆分成八字节。[Listing 18-60](chapter18.xhtml#list18-60) 展示了 <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>
    辅助函数的伪代码。
- en: '[PRE98]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-60: Classifying
    return values</samp>'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-60：分类返回值</samp>
- en: If the return value is a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    the first of our two lists, which contains operands returned in general-purpose
    registers, will be empty. The second list, which holds operands returned in XMM
    registers, will contain the return value. The flag signaling that the value is
    returned in memory will be <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    ❶. If the return value is some other scalar type, we’ll add it to the list of
    operands returned in general-purpose registers, along with its type. The list
    of operands in XMM registers will be empty, and the flag will still be <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    ❷.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回值是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 类型，第一个列表（包含在通用寄存器中返回的操作数）将为空。第二个列表（包含在
    XMM 寄存器中返回的操作数）将包含返回值。表示值将在内存中返回的标志将是 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    ❶。如果返回值是其他标量类型，我们将把它添加到在通用寄存器中返回的操作数列表中，并附带其类型。XMM 寄存器中的操作数列表将为空，标志仍为 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    ❷。
- en: Otherwise, the return value must be a structure. We’ll look up its classes with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_structure</samp>, then
    check whether it belongs to the MEMORY class. If it does, we’ll return two empty
    lists, which indicate that nothing will be returned in registers, and a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp> flag, which indicates that
    the return value will be passed in memory ❸.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，返回值必须是一个结构体。我们将通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_structure</samp>
    查找它的类，然后检查它是否属于 MEMORY 类。如果属于，我们将返回两个空列表，表示寄存器中不会返回任何值，以及一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    标志，表示返回值将会传递到内存中 ❸。
- en: If the structure isn’t in the MEMORY class, it will be returned in registers.
    We’ll convert each eightbyte to a <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operand and add it to either <samp class="SANS_TheSansMonoCd_W5Regular_11">double_retvals</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">int_retvals</samp>, according
    to its class ❹. Here, as in <samp class="SANS_TheSansMonoCd_W5Regular_11">classify
    _parameters</samp>, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp>
    to find the assembly type of each operand in <samp class="SANS_TheSansMonoCd_W5Regular_11">int_retvals</samp>.
    Finally, we’ll return both lists, along with a <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    flag.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结构体不在 MEMORY 类中，它将通过寄存器返回。我们将把每个八字节值转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    操作数，并根据其类将其添加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">double_retvals</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">int_retvals</samp> 中 ❹。在这里，与 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp> 中一样，我们将使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp> 来查找每个操作数在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int_retvals</samp> 中的汇编类型。最后，我们将返回两个列表，并附带一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> 标志。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing FunCall</samp>
  id: totrans-469
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">实现 FunCall</samp>
- en: Next, let’s update how we implement function calls in assembly. [Listing 18-61](chapter18.xhtml#list18-61)
    reproduces the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_function_call</samp>
    from [Listing 13-31](chapter13.xhtml#list13-31), with changes bolded and some
    unchanged code omitted.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新如何在汇编中实现函数调用。[清单18-61](chapter18.xhtml#list18-61) 重现了 <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_function_call</samp>
    的定义，该定义来源于[清单13-31](chapter13.xhtml#list13-31)，修改部分用粗体显示，未修改的代码被省略。
- en: '[PRE99]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-61: Supporting structures
    in function calls</samp>'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单18-61：函数调用中的支持结构</samp>
- en: We start by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>
    (unless the function call doesn’t have a return value because its return type
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>) ❶. If we find that
    the return value will be passed in memory, we convert <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    into an assembly operand, then emit an instruction to load its address into RDI
    ❷. We also increment <samp class="SANS_TheSansMonoCd_W5Regular_11">reg_index</samp>
    so that we’ll pass the first integer argument in RSI instead of RDI.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>（除非函数调用没有返回值，因为其返回类型是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>）❶。如果我们发现返回值将通过内存传递，我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> 转换为汇编操作数，然后生成指令将其地址加载到RDI寄存器中❷。我们还会递增
    <samp class="SANS_TheSansMonoCd_W5Regular_11">reg_index</samp>，这样我们就可以通过RSI而不是RDI传递第一个整数参数。
- en: Next, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>,
    passing it the new <samp class="SANS_TheSansMonoCd_W5Regular_11">return_in_memory</samp>
    flag. Then, we adjust the stack pointer (I’ve omitted this step because it’s the
    same as in earlier chapters).
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>，并传递新的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">return_in_memory</samp> 标志。然后，我们调整栈指针（我已省略这一步，因为它与之前章节中的相同）。
- en: We then pass arguments in the general-purpose registers. If an argument has
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp> type, its size
    isn’t exactly 1, 4, or 8 bytes, so transferring it into the register will take
    multiple instructions. We emit those instructions with the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp>
    helper function ❸, which we’ll look at in a moment. If an argument has any other
    type, we transfer it with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instruction, as in earlier chapters. The way we pass arguments in XMM registers
    won’t change, so I’ve snipped out that step.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将参数传递到通用寄存器中。如果一个参数的类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>，它的大小不是1、4或8字节，所以将其传送到寄存器需要多个指令。我们通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp> 辅助函数❸来生成这些指令，稍后我们会详细了解。如果参数是其他类型，我们将通过单一的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> 指令进行传送，就像之前的章节中一样。我们在XMM寄存器中传递参数的方式不会改变，所以我已经省略了这一步。
- en: 'The next step is passing arguments on the stack. The way we pass operands with
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>
    won’t change. To pass an irregular operand with a <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>
    type, we first need to subtract 8 bytes from RSP to allocate the stack slot for
    that operand ❹. (Remember that the ABI reserves an entire 8-byte stack slot for
    each eightbyte of a structure parameter, even if the actual eightbyte is smaller
    than that.) To copy the operand into that stack slot, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes</samp>
    helper function we’ve already written. Suppose <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is a global variable and its size is 3 bytes. We’ll issue these instructions to
    pass it as an argument on the stack:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在栈上传递参数。我们传递 <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> 类型的操作数的方式不会改变。为了传递一个具有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp> 类型的不规则操作数，我们首先需要从
    RSP 减去 8 个字节，以为该操作数分配栈槽❹。（请记住，ABI 为结构体参数的每个八字节预留一个完整的 8 字节栈槽，即使实际的八字节小于这个大小。）为了将操作数复制到该栈槽中，我们使用已经编写的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes</samp> 辅助函数。假设 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 是一个全局变量，且它的大小是 3 字节。我们将发出以下指令，将它作为参数传递到栈上：
- en: '[PRE100]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: These <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp> instructions
    are invalid, since both operands are in memory; we’ll rewrite them in the instruction
    fix-up pass.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp> 指令是无效的，因为两个操作数都在内存中；我们将在指令修正阶段重写它们。
- en: Next, we issue the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instruction and restore the stack pointer to its original location. I’ve snipped
    out these steps because they’re unchanged from earlier chapters.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们发出 <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> 指令，并将栈指针恢复到原来的位置。我已经省略了这些步骤，因为它们与前几章相同。
- en: Finally, we copy the return value to the destination. If the return value is
    transferred in memory, we don’t do anything; the callee already copied it for
    us. Otherwise, we iterate over the two lists of destination operands returned
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>—first
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int_dests</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">double_dests</samp>—and
    retrieve each operand from the corresponding register. To retrieve an irregularly
    sized eightbyte from a general-purpose register, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_from_reg</samp>
    helper function ❺, which we’ll define in a moment. This is the counterpart to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp>, which
    we used to pass parameters. We emit a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instruction to retrieve a <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    value from a general-purpose register ❻ or to retrieve a <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>
    value from an XMM register ❼.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将返回值复制到目标位置。如果返回值是在内存中传递的，我们不需要做任何操作；被调用者已经为我们复制了它。否则，我们会遍历由 <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>
    返回的两个目标操作数列表——首先是 <samp class="SANS_TheSansMonoCd_W5Regular_11">int_dests</samp>，然后是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double_dests</samp>——并从相应的寄存器中获取每个操作数。为了从通用寄存器中检索不规则大小的八字节，我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_from_reg</samp> 辅助函数❺，我们稍后会定义这个函数。它是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp> 的对等函数，后者用于传递参数。我们发出一条
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> 指令，以从通用寄存器❻中检索一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> 值，或从 XMM 寄存器❼中检索一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> 值。
- en: The code to copy the return value to <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    works whether <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> is a structure
    or a scalar object. If it’s a structure, each item in <samp class="SANS_TheSansMonoCd_W5Regular_11">int_dests</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">double _dests</samp> is an eightbyte
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>, which we’ll populate
    from the corresponding return register. If <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    is scalar, either <samp class="SANS_TheSansMonoCd_W5Regular_11">int_dests</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">double_dests</samp> will have
    exactly one element, and the other list will be empty. In that case, this code
    will emit a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction
    to transfer the return value from RAX or XMM0 to its destination.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 复制返回值到 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> 的代码无论 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> 是结构体还是标量对象都能正常工作。如果它是一个结构体，那么
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int_dests</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">double
    _dests</samp> 中的每个项目都是 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    的一个八字节，我们将从相应的返回寄存器填充它。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    是标量，那么 <samp class="SANS_TheSansMonoCd_W5Regular_11">int_dests</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double_dests</samp> 将只有一个元素，另一个列表将为空。在这种情况下，代码将发出一个单一的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> 指令，将返回值从 RAX 或 XMM0 传输到目标位置。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Transferring Irregular Structures
    in Registers</samp>
  id: totrans-482
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">在寄存器中传输不规则结构体</samp>
- en: We still need to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_from_reg</samp>,
    which copy irregularly sized eightbytes to and from general-purpose registers.
    This is trickier than copying between two locations in memory, like we do in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes</samp>, because we can’t directly
    access every individual byte in a general-purpose register. We can access a general-purpose
    register’s lowest byte with the appropriate 1-byte alias, like AL or DIL, but
    we can’t access its other bytes individually. (Each register’s second-lowest byte
    also has its own alias—for instance, AH is the second-lowest byte of RAX—but our
    assembly AST doesn’t support these aliases. Even if it did, we still couldn’t
    access the other 6 bytes.)
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要实现 <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_from_reg</samp>，它们将不规则大小的八字节数据复制到通用寄存器中，反之亦然。这比在内存中两个位置之间进行复制要复杂，因为我们无法直接访问通用寄存器中的每个字节。在通用寄存器中，我们可以通过适当的1字节别名（如
    AL 或 DIL）访问其最低字节，但无法单独访问其他字节。（每个寄存器的第二低字节也有自己的别名——例如，AH是RAX的第二低字节——但是我们的汇编 AST
    不支持这些别名。即使它支持，我们仍然无法访问其他6个字节。）
- en: 'We’ll use our new bit-shifting instructions to work around this limitation.
    Let’s revisit the 3-byte global variable <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    from our last example. If we need to copy <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    into RDI, we’ll issue the following instructions:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用新的位移指令来绕过这个限制。让我们回顾一下上一个例子中的3字节全局变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>。如果我们需要将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 复制到 RDI 中，我们将发出以下指令：
- en: '[PRE101]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We start by copying the *last* byte of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    into the lowest byte of RDI, whose alias is DIL. Then, we issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>
    instruction to shift RDI 1 byte to the left. This moves the byte we just copied
    into the second-lowest byte of RDI and zeroes out DIL. Next, we copy the middle
    byte of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> into DIL and issue
    another <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> instruction.
    At this point, the last 2 bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    are in the correct place in the register, so we just move the first byte of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> into DIL, and we’re done. [Figure
    18-7](#fig18-7) shows the contents of RDI (in hexadecimal) after each instruction,
    if <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> contains the bytes <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x2</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">0x3</samp>, and RDI’s initial
    value is 0.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 的*最后一个*字节复制到RDI的最低字节中，RDI的别名是DIL。然后，我们发出一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> 指令，将RDI向左移动1字节。这将我们刚复制的字节移到RDI的第二低字节，并将DIL清零。接下来，我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 的中间字节复制到DIL，并发出另一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> 指令。此时，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    的最后2个字节已经在寄存器中的正确位置，因此我们只需将 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    的第一个字节复制到DIL，就完成了。[图18-7](#fig18-7) 显示了每条指令执行后RDI的内容（以十六进制表示），假设 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    包含字节 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">0x2</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x3</samp>，且RDI的初始值为0。
- en: '![](../images/fig18-7.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig18-7.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-7: Transferring a
    structure into a register a byte at a time [Description](description-49.xhtml)</samp>'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图18-7：将结构以每字节方式传输到寄存器 [描述](description-49.xhtml)</samp>
- en: 'Don’t let the byte ordering here throw you off: because our system is little-endian,
    the least significant (rightmost) byte in RDI corresponds to the lowest memory
    address when we copy the value from RDI into memory, or vice versa. This means—somewhat
    counterintuitively—that shifting a value to the *left* moves each byte to a location
    that corresponds to a *higher* memory address. If, after copying this structure
    into RDI, we issue the instruction'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被这里的字节顺序弄混：由于我们的系统是小端字节序，当我们将值从RDI复制到内存中，或者反之，RDI中的最小有效（最右侧）字节对应于最低的内存地址。这意味着——有些反直觉——将值向*左*移动会将每个字节移动到对应于*更高*内存地址的位置。如果在将这个结构复制到RDI之后，我们发出指令
- en: '[PRE102]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: then the contents of memory will look like [Figure 18-8](#fig18-8).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 然后内存的内容将如[图18-8](#fig18-8)所示。
- en: '![](../images/fig18-8.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig18-8.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-8: The contents of
    memory after copying a structure from a register [Description](description-50.xhtml)</samp>'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图18-8：从寄存器复制结构后内存的内容 [描述](description-50.xhtml)</samp>
- en: Now the structure is laid out in memory in the correct order. (This <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    instruction also writes 1 byte of memory past the end of the structure, which
    is fine if you aren’t using that byte for anything else. We’ll transfer irregularly
    sized structures in and out of registers 1 byte at a time, but code in other translation
    units that we interact with may transfer them in 4- and 8-byte chunks when it’s
    safe to do so.)
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 现在结构在内存中按照正确的顺序布局。（这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    指令还会在结构的末尾写入1个字节的内存，如果你不打算用这个字节，这样做是没问题的。我们将不规则大小的结构以每次1字节的方式在寄存器中传输，但我们交互的其他翻译单元中的代码可能会在安全的情况下以4字节或8字节的块进行传输。）
- en: That’s the basic idea of <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp>;
    now let’s implement it. [Listing 18-62](chapter18.xhtml#list18-62) gives the pseudocode.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp> 的基本思想；现在让我们实现它。[清单18-62](chapter18.xhtml#list18-62)
    给出了伪代码。
- en: '[PRE103]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-62: Generating instructions
    to copy bytes from memory into a register</samp>'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单18-62：生成将字节从内存复制到寄存器的指令</samp>
- en: 'This function copies <samp class="SANS_TheSansMonoCd_W5Regular_11">byte_count</samp>
    bytes from <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp> into <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst_reg</samp>. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp>
    is part of a structure, we can assume it’s a memory operand that accepts an offset,
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>.
    We iterate over the bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp>
    in reverse order: we start at its final byte, with offset <samp class="SANS_TheSansMonoCd_W5Regular_11">byte_count
    - 1</samp>, and end at byte zero. We use a simple helper function, <samp class="SANS_TheSansMonoCd_W5Regular_11">add_offset</samp>,
    to construct the assembly operand for each byte. I won’t give you the pseudocode
    for this function, since it just adds the specified offset to <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp>.
    For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">src _op</samp> is
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem("x", 2)</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">add_offset(src_op, 3)</samp> should return
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem("x", 5)</samp>.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将 <samp class="SANS_TheSansMonoCd_W5Regular_11">byte_count</samp> 字节从 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp> 复制到 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_reg</samp>。因为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp> 是一个结构的一部分，我们可以假设它是一个接受偏移量的内存操作数，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>。我们以反向顺序遍历
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp> 的字节：从它的最后一个字节开始，偏移量为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">byte_count - 1</samp>，直到字节零。我们使用一个简单的辅助函数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">add_offset</samp> 来构造每个字节的汇编操作数。我不会给出这个函数的伪代码，因为它只是将指定的偏移量添加到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp> 上。例如，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp>
    是 <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem("x", 2)</samp>，那么 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">add_offset(src_op, 3)</samp> 应该返回 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem("x", 5)</samp>。
- en: Once we have the assembly operand for the current byte, we emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instruction to copy that byte into the destination register. Next, on all but
    the last loop iteration, we emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Shl</samp>
    instruction to shift the whole register left by 8 bits. We then decrement the
    offset and move on to the next byte.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了当前字节的汇编操作数，我们就发出一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    指令，将该字节复制到目标寄存器。接下来，在除最后一次循环迭代外的所有循环中，我们发出一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Shl</samp>
    指令，将整个寄存器向左移动 8 位。然后，我们递减偏移量，继续处理下一个字节。
- en: 'To copy bytes out of a register, we do the whole thing in reverse. Here’s how
    we would copy 3 bytes from RDI onto the stack at <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 要从寄存器中复制字节，我们需要倒过来做。下面是我们如何将 3 个字节从 RDI 复制到栈上 <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>：
- en: '[PRE104]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: First, we copy the lowest byte of RDI into memory. Then, we shift RDI 1 byte
    to the right, so DIL now contains the second-lowest byte of the structure. We
    repeat this process until we’ve transferred every byte. [Listing 18-63](chapter18.xhtml#list18-63)
    gives the pseudocode to generate these instructions.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 RDI 的最低字节复制到内存中。然后，我们将 RDI 向右移动 1 字节，这样 DIL 就包含了结构的第二个最低字节。我们重复这个过程，直到所有字节都被传输。
    [清单 18-63](chapter18.xhtml#list18-63) 给出了生成这些指令的伪代码。
- en: '[PRE105]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-63: Generating instructions
    to copy bytes from a register into memory</samp>'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-63：生成将字节从寄存器复制到内存的指令</samp>
- en: As in [Listing 18-62](chapter18.xhtml#list18-62), we can assume that <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_op</samp>
    is a memory operand with an offset. We iterate through the bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_op</samp>
    in order, starting with byte zero. On each iteration, we copy the lowest byte
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">src_reg</samp> into the current
    byte of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_op</samp>. Then, on
    all but the last iteration, we shift <samp class="SANS_TheSansMonoCd_W5Regular_11">src_reg</samp>
    8 bits to the right.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在[Feynman学习方法](https://wiki.example.org/feynmans_learning_method)中所示，我们可以假设<samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst_op</samp>是带有偏移量的内存操作数。我们按顺序遍历<samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst_op</samp>的字节，从字节零开始。在每次迭代中，我们将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">src_reg</samp>的最低字节复制到当前字节位置的<samp class="SANS_TheSansMonoCd_W5Regular_11">dst_op</samp>。然后，在除了最后一次迭代之外的所有迭代中，我们将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">src_reg</samp>右移8位。
- en: With these two helper functions, we’ve finished our implementation of function
    calls. Next, we’ll handle the callee side.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个辅助函数，我们就完成了函数调用的实现。接下来，我们将处理被调用方的操作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Up Function Parameters</samp>
  id: totrans-507
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">设置函数参数</samp>
- en: At the start of a function, we copy every parameter into that function’s stack
    frame. Now we’ll copy parameters of structure type too. The main wrinkle is that
    RDI might hold a pointer to the return value’s destination, instead of an ordinary
    parameter. Let’s revisit <samp class="SANS_TheSansMonoCd_W5Regular_11">set_up_parameters</samp>,
    from [Listing 13-30](chapter13.xhtml#list13-30), and see what’s changed. [Listing
    18-64](chapter18.xhtml#list18-64) gives the new definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">set_up
    _parameters</samp>, with this chapter’s changes bolded.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数开始时，我们将每个参数复制到该函数的栈帧中。现在我们也将复制结构类型的参数。主要的难点是RDI可能保存指向返回值目的地的指针，而不是普通参数。让我们重新审视一下来自[Feynman学习方法](https://wiki.example.org/feynmans_learning_method)的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">set_up_parameters</samp>，看看发生了哪些变化。[Listing
    18-64](chapter18.xhtml#list18-64)给出了<samp class="SANS_TheSansMonoCd_W5Regular_11">set_up_parameters</samp>的新定义，改动部分已加粗。
- en: '[PRE106]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-64: Copying function
    parameters to the stack</samp>'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-64: 将函数参数复制到栈上</samp>'
- en: We’ve added a <samp class="SANS_TheSansMonoCd_W5Regular_11">return_in_memory</samp>
    flag, which we’ll pass through to <samp class="SANS_TheSansMonoCd_W5Regular_11">classify
    _parameters</samp>. This flag also dictates how we’ll handle the value in RDI.
    If RDI points to the return value’s destination, we’ll copy it to the first open
    slot on the stack, <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>;
    we’ll retrieve it from this slot when we need to return a value. (In the next
    section, we’ll update the pseudo-operand replacement pass so it doesn’t clobber
    this pointer by assigning a local variable to the same spot.) In this case, we’ll
    also increment <samp class="SANS_TheSansMonoCd_W5Regular_11">reg_index</samp>,
    just like we did when we passed arguments in [Listing 18-61](chapter18.xhtml#list18-61),
    so that we’ll look for ordinary parameters starting in RSI instead of RDI.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个<samp class="SANS_TheSansMonoCd_W5Regular_11">return_in_memory</samp>标志，并将其传递给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>。这个标志还决定了我们如何处理RDI中的值。如果RDI指向返回值的目的地，我们将其复制到栈上的第一个空槽，即<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>；当我们需要返回值时，会从这个槽中取出。 （在下一节中，我们将更新伪操作数替换过程，以确保它不会通过将局部变量分配到相同位置来覆盖这个指针。）在这种情况下，我们还将像在[Feynman学习方法](https://wiki.example.org/feynmans_learning_method)中传递参数时那样，增加<samp
    class="SANS_TheSansMonoCd_W5Regular_11">reg_index</samp>，这样我们将从RSI而不是RDI开始查找普通参数。
- en: To copy irregularly sized operands out of registers, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy
    _bytes_from_reg</samp> helper function from [Listing 18-63](chapter18.xhtml#list18-63).
    To copy irregularly sized operands that were passed on the stack, we’ll use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes</samp> helper function.
    If an operand has type <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>, we’ll copy it
    into place with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instruction, regardless of whether it represents a scalar value or a chunk of
    a structure.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将不规则大小的操作数从寄存器中复制出来，我们将使用来自[列表 18-63](chapter18.xhtml#list18-63)的<samp class="SANS_TheSansMonoCd_W5Regular_11">copy
    _bytes_from_reg</samp>辅助函数。为了复制通过栈传递的不规则大小的操作数，我们将使用<samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes</samp>辅助函数。如果操作数的类型是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>，我们将使用单一的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>指令将其复制到相应位置，不管它是标量值还是结构体的一部分。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing Return</samp>
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">实现 Return</samp>
- en: '[Listing 18-65](chapter18.xhtml#list18-65) illustrates how to convert the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction to assembly.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 18-65](chapter18.xhtml#list18-65)展示了如何将<samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>指令转换为汇编代码。'
- en: '[PRE107]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-65: Implementing
    the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Return</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">instruction</samp>'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 18-65：实现</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Return</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">指令</samp>
- en: Assuming the function returns a value, rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    we start by classifying that value. Then, we check whether we need to return it
    in memory or in registers. To return it in memory, we first retrieve the pointer
    to the destination from <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>.
    We copy that pointer into RAX, as the System V calling convention requires ❶.
    Then, we copy the return value into the block of memory that RAX points to. We
    perform this copy using the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy
    _bytes</samp> helper function ❷.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 假设该函数返回一个值，而不是<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>，我们首先对该值进行分类。然后，我们检查是否需要将其返回到内存或寄存器中。为了将其返回到内存中，我们首先从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>获取目标的指针。我们将该指针复制到RAX中，因为系统V调用约定要求这样做❶。然后，我们将返回值复制到RAX指针所指向的内存块中。我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">copy _bytes</samp>辅助函数进行这次复制❷。
- en: If the return value is passed in one or more registers, we iterate through the
    operands in <samp class="SANS_TheSansMonoCd_W5Regular_11">int_retvals</samp>,
    copying each one into the corresponding general-purpose register ❸. We then iterate
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">double_retvals</samp>, copying
    these values into XMM0 and XMM1 ❹. Once we’ve copied every part of the return
    value to the correct location, we emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp>
    instruction.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回值通过一个或多个寄存器传递，我们将遍历<samp class="SANS_TheSansMonoCd_W5Regular_11">int_retvals</samp>中的操作数，将每个操作数复制到相应的通用寄存器中❸。接着，我们遍历<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double_retvals</samp>，将这些值复制到XMM0和XMM1中❹。一旦我们将返回值的每一部分复制到正确的位置，我们就会发出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp>指令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Tracking Which Functions Pass
    Return Values in Memory</samp>
  id: totrans-519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">跟踪哪些函数将返回值通过内存传递</samp>
- en: Finally, we’ll extend the backend symbol table to track which functions return
    values in memory. [Listing 18-66](chapter18.xhtml#list18-66) shows how to update
    our definition of a backend symbol table entry.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将扩展后端符号表，以跟踪哪些函数通过内存返回值。[列表 18-66](chapter18.xhtml#list18-66)展示了如何更新我们的后端符号表条目的定义。
- en: '[PRE108]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-66: The updated
    definition of an entry in the backend symbol table</samp>'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 18-66：后端符号表中条目的更新定义</samp>
- en: As you’d expect, we’ll set <samp class="SANS_TheSansMonoCd_W5Regular_11">return_on_stack</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> if a function passes
    its return value on the stack and <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    if it passes its return value in registers or returns <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
    The pseudo-operand replacement pass will use this flag to figure out if the quadword
    starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp> is available
    or if it holds the pointer to the memory where the return value will be passed.
    If a function has an incomplete return type other than <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    (which can happen if it’s declared but never defined or called), the <samp class="SANS_TheSansMonoCd_W5Regular_11">return_on_stack</samp>
    flag will never be used, so we can just set it to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的，如果一个函数通过栈传递返回值，我们将把<samp class="SANS_TheSansMonoCd_W5Regular_11">return_on_stack</samp>设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，如果它通过寄存器传递返回值或返回<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>，则设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。伪操作数替换通道将使用此标志来判断从<samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>开始的四字节是否可用，或者它是否包含返回值将被传递的内存指针。如果一个函数有一个不完整的返回类型（除了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>，这可能发生在它被声明但从未定义或调用的情况下），则<samp
    class="SANS_TheSansMonoCd_W5Regular_11">return_on_stack</samp>标志将不会被使用，因此我们可以将其设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Putting It All Together</samp>
  id: totrans-524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将所有内容整合在一起</samp>
- en: We’ve now covered all the pieces of assembly generation! [Tables 18-1](chapter18.xhtml#tab18-1)
    through [18-4](chapter18.xhtml#tab18-4) summarize the latest updates to the conversion
    from TACKY to assembly; as usual, new constructs and changes to the conversions
    for existing constructs are bolded. [Appendix B](appendix-B.xhtml) includes the
    complete conversion from TACKY to assembly for this chapter, since this is the
    final chapter in [Part II](part2.xhtml).
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经覆盖了所有汇编生成的部分！[表18-1](chapter18.xhtml#tab18-1)到[18-4表](chapter18.xhtml#tab18-4)总结了从TACKY到汇编的最新转换更新；如同往常一样，新的构造和现有构造的转换更改都用**粗体**标注。[附录B](appendix-B.xhtml)包括了本章从TACKY到汇编的完整转换，因为这是[第二部分](part2.xhtml)的最后一章。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 18-1:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Top-Level TACKY Constructs to Assembly</samp>
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表18-1：</samp> <samp class="SANS_Futura_Std_Book_11">将顶层TACKY构造转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 顶层构造</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编顶层构造</samp>
    |'
- en: '| --- | --- |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE109]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '| <samp class="SANS_Futura_Std_Book_11">Return value in registers'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '| <samp class="SANS_Futura_Std_Book_11">寄存器中的返回值'
- en: or no return
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 或无返回
- en: value</samp> |
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: value</samp> |
- en: '[PRE110]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '|'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">Return value on stack</samp>
    |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">返回值在栈上</samp> |'
- en: '[PRE111]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '|'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 18-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表18-2：</samp> <samp class="SANS_Futura_Std_Book_11">将TACKY指令转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编指令</samp>
    |'
- en: '| --- | --- |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Return on stack</samp> |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">返回栈上</samp> |'
- en: '[PRE112]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '|'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">Return in registers</samp> |'
  id: totrans-545
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">寄存器中的返回</samp> |'
- en: '[PRE113]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '|'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  | <samp class="SANS_Futura_Std_Book_11">No return value</samp> |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Book_11">无返回值</samp> |'
- en: '[PRE114]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '|'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE115]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '|  |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE116]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '|'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE117]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '| <samp class="SANS_Futura_Std_Book_11">Scalar</samp> |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">标量</samp> |'
- en: '[PRE118]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '|'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Structure</samp> |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">结构</samp> |'
- en: '[PRE119]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '|'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE120]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '| <samp class="SANS_Futura_Std_Book_11">Scalar</samp> |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">标量</samp> |'
- en: '[PRE121]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '|'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Structure</samp> |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">结构</samp> |'
- en: '[PRE122]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '|'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE123]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '| <samp class="SANS_Futura_Std_Book_11">Scalar</samp> |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">标量</samp> |'
- en: '[PRE124]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '|'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Structure</samp> |'
  id: totrans-577
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">结构体</samp> |'
- en: '[PRE125]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '|'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE126]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '|'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE127]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '|'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE128]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '|'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">src</samp> <samp class="SANS_Futura_Std_Heavy_B_11">is
    a structure</samp> |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">src</samp> <samp class="SANS_Futura_Std_Heavy_B_11">是一个结构体</samp>
    |'
- en: '[PRE129]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '|'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE130]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst is scalar</samp> |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst 是标量</samp> |'
- en: '[PRE131]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '|'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst is a structure</samp> |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst 是一个结构体</samp> |'
- en: '[PRE132]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '|'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE133]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst will be'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst 将会是'
- en: returned
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: in
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在
- en: memory</samp> |
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 内存</samp> |
- en: '[PRE134]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '|'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst will be'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '|  | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst 将会是'
- en: returned
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: in
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 在
- en: registers</samp> |
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器</samp> |
- en: '[PRE135]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '|'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> <samp class="SANS_Futura_Std_Book_11">is
    absent</samp> |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> <samp class="SANS_Futura_Std_Book_11">不存在</samp>
    |'
- en: '[PRE136]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '|'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE137]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '|'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE138]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '|'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE139]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '|'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE140]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '|'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE141]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '|'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE142]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '|'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE143]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '|'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 18-3:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Operands to Assembly</samp>
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 18-3：</samp> <samp class="SANS_Futura_Std_Book_11">将
    TACKY 操作数转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operand</samp> |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 操作数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编操作数</samp>
    |'
- en: '| --- | --- |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE144]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '|'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE145]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '|'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 18-4:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Types to Assembly</samp>
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 18-4：</samp> <samp class="SANS_Futura_Std_Book_11">将类型转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp> |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">源类型</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编类型</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">对齐</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-642
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Structure(tag)</samp> |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">结构体(tag)</samp> |'
- en: '[PRE146]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Alignment from type table</samp>
    |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">来自类型表的对齐</samp> |'
- en: Note that we now include offsets on every <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operand we generate. The only <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operands at this point represent floating-point constants; these include the constants
    we use in the conversions for floating-point <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp> in [Table
    18-2](chapter18.xhtml#tab18-2) and ordinary floating-point TACKY constants in
    [Table 18-3](chapter18.xhtml#tab18-3). These operands all have an offset of zero.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们现在在每个生成的 <samp class="SANS_TheSansMonoCd_W5Regular_11">数据</samp> 操作数上包括偏移量。此时唯一的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">数据</samp> 操作数代表浮点常量；这些包括我们在浮点数转换中使用的常量，例如
    [表 18-2](chapter18.xhtml#tab18-2) 中的浮点数 <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp>，以及 [表 18-3](chapter18.xhtml#tab18-3)
    中的普通浮点 TACKY 常量。这些操作数的偏移量都为零。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudo-operands</samp>
  id: totrans-647
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">替换伪操作数</samp>
- en: We’ll make two small changes to this pass. First, we’ll supply offsets for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operands. For example, if
    <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp> is a static variable, we’ll
    convert
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对这个过程做两个小改动。首先，我们将为 <samp class="SANS_TheSansMonoCd_W5Regular_11">数据</samp>
    操作数提供偏移量。例如，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp> 是一个静态变量，我们将转换
- en: '[PRE147]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: to
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 到
- en: '[PRE148]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: and
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE149]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'to:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 到：
- en: '[PRE150]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Second, we need to avoid clobbering the return value pointer in <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>.
    Before we start allocating stack space, we’ll check the backend symbol table to
    see whether the function’s return value will be passed in memory. If it will,
    we’ll reserve the quadword starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>
    for the return value pointer and allocate space for pseudoregisters only at addresses
    lower than <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>. For
    example, if the first pseudoregister we encounter is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>,
    we’ll map it to <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要避免覆盖 <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp> 处的返回值指针。在开始分配栈空间之前，我们会检查后端符号表，以查看函数的返回值是否会通过内存传递。如果会传递，我们将保留从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp> 开始的四字长（quadword）作为返回值指针，并仅在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp> 以下的地址为伪寄存器分配空间。例如，如果我们遇到的第一个伪寄存器是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>，我们将它映射到 <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>。
- en: The instruction fix-up pass won’t change in this chapter. The <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp> instructions we emit
    during code generation are already valid and don’t need to be fixed up, since
    the destination operand is always a register and the source operand is always
    the immediate value <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的指令修复阶段不会发生变化。在代码生成过程中，我们输出的 <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp> 指令已经是有效的，不需要进一步修复，因为目标操作数始终是寄存器，而源操作数始终是立即数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  id: totrans-658
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">代码生成</samp>
- en: 'The code emission pass requires two small changes. First, we’ll include the
    offsets on <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operands.
    For example, we’ll emit <samp class="SANS_TheSansMonoCd_W5Regular_11">Data("x",
    4)</samp> as:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成阶段需要进行两个小的修改。首先，我们将包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    操作数的偏移量。例如，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Data("x", 4)</samp>
    输出为：
- en: '[PRE151]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: If the offset is zero, you can either include it or omit it.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 如果偏移量为零，可以选择包含或省略它。
- en: Second, we’ll emit the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Shl</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ShrTwoOp</samp> assembly instructions
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>,
    respectively. These take the usual operand size suffixes.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们将新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Shl</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">ShrTwoOp</samp>
    汇编指令分别输出为 <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>，并且它们会使用常规的操作数大小后缀。
- en: '[Tables 18-5](chapter18.xhtml#tab18-5) and [18-6](chapter18.xhtml#tab18-6)
    show these changes to the code emission pass. [Appendix B](appendix-B.xhtml) includes
    the complete code emission pass for this chapter, since this is the final chapter
    of [Part II](part2.xhtml).'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 18-5](chapter18.xhtml#tab18-5) 和 [18-6](chapter18.xhtml#tab18-6) 显示了代码生成阶段的这些变化。[附录
    B](appendix-B.xhtml) 包含了本章的完整代码生成过程，因为这是 [第二部分](part2.xhtml)的最后一章。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 18-5:</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    Names for Assembly Operators</samp>
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 18-5：</samp> <samp class="SANS_Futura_Std_Book_11">汇编操作符的指令名称</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operator</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Instruction name</samp> |'
  id: totrans-665
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编操作符</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">指令名称</samp>
    |'
- en: '| --- | --- |'
  id: totrans-666
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Shl</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">shl</samp>
    |'
  id: totrans-667
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Shl</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">shl</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ShrTwoOp</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">shr</samp>
    |'
  id: totrans-668
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ShrTwoOp</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">shr</samp>
    |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 18-6:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 18-6：</samp> <samp class="SANS_Futura_Std_Book_11">格式化汇编操作数</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编操作数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Data(identifier</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">, int</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><identifier></samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">+</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><int></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(%rip)</samp> |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Data(identifier</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">, int</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><identifier></samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">+</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><int></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(%rip)</samp> |'
- en: And with that, you’re done with the chapter; your compiler now supports structures!
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就完成了这一章；你的编译器现在已经支持结构体了！
- en: '<samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: Unions</samp>'
  id: totrans-674
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">额外加分：联合体</samp>
- en: Structure and union types have a lot in common. Their type declarations share
    the same syntax and declare tags in the same namespace. They follow the same typing
    rules and support the same operations, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> operators. The difference
    is that the members of a structure are laid out sequentially in memory, whereas
    the members of a union all start at the same address, such that writing to one
    overwrites the others. From the compiler’s perspective, a union is basically a
    structure where every member’s offset is zero. This makes it relatively straightforward
    to extend the work you did in this chapter to support unions too. Still, this
    is a bigger challenge than previous extra credit features. It’s an opportunity
    to add a new language feature on your own.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体和联合体类型有很多相似之处。它们的类型声明共享相同的语法，并在同一个命名空间中声明标签。它们遵循相同的类型规则，并支持相同的操作，包括<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-></samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>运算符。区别在于，结构体的成员在内存中是按顺序排列的，而联合体的所有成员都从相同的地址开始，因此对一个成员的写入会覆盖其他成员。从编译器的角度看，联合体基本上是一个结构体，其中每个成员的偏移量都是零。这使得你扩展本章中所做的工作以支持联合体变得相对简单。然而，这比之前的额外加分功能要更具挑战性。这是一个你可以自己添加新语言特性的机会。
- en: If you implement union types, there are a few points you should keep in mind.
    First, remember that we restricted where structures can be declared to make compilation
    easier. The test cases for unions also follow the same restrictions; that means
    you don’t need to support anonymous union declarations or union declarations that
    are part of declarations of some other type or variable.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实现了联合体类型，有几个要点需要记住。首先，记住我们曾限制过结构体的声明位置，以便简化编译过程。联合体的测试用例也遵循相同的限制；这意味着你不需要支持匿名联合体声明或作为其他类型或变量声明一部分的联合体声明。
- en: In the type checker, you’ll add union definitions to the type table. Structure
    and union tags share a namespace, so defining a structure and a union type with
    the same tag in the same scope is an error. You’ll need to track each union’s
    size and alignment (you can look up how to calculate these in the System V ABI).
    You’ll also need to type check compound initializers for unions. A union initializer
    should have a single element, which initializes the union’s first member. (C provides
    syntax to specify which union member to initialize, but you don’t have to implement
    it.)
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型检查器中，你将把联合体定义添加到类型表中。结构体和联合体标签共享同一个命名空间，因此在同一作用域内定义具有相同标签的结构体和联合体类型是错误的。你需要跟踪每个联合体的大小和对齐方式（你可以查阅如何计算这些内容，在
    System V ABI 中有说明）。你还需要对联合体的复合初始化器进行类型检查。联合体初始化器应该只有一个元素，用来初始化联合体的第一个成员。（C 提供了语法来指定初始化哪个联合体成员，但你不需要实现这一点。）
- en: On the backend, the System V calling convention treats unions similarly to structures;
    a union will be passed in memory, in two registers, or in one register, depending
    on its size and the types of its members. For all the gory details, see the links
    in “Additional Resources.” Good luck!
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 在后端，System V 调用约定将联合体视为类似于结构体；联合体会在内存中、两个寄存器中或一个寄存器中传递，这取决于它的大小以及成员的类型。有关详细信息，请参阅“附加资源”中的链接。祝你好运！
- en: 'You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--union</samp>
    flag to test your compiler’s support for union types:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">--union</samp>标志来测试编译器对联合体类型的支持：
- en: '[PRE152]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Or, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>
    flag to test every extra credit feature.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>标志来测试每个额外加分功能。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: You’ve finished [Part II](part2.xhtml)! In this chapter, you learned how to
    analyze structure type declarations, manipulate aggregate objects in TACKY, and
    transfer structures according to the System V calling convention. Your compiler
    now supports every language feature this book covers, including most of the statements,
    expressions, and types in the C language. You can officially tell people that
    you’ve written a C compiler.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了 [第二部分](part2.xhtml)！在这一章中，你学会了如何分析结构体类型声明、在 TACKY 中操作聚合对象，并根据 System
    V 调用约定传输结构体。你的编译器现在支持本书涵盖的每个语言特性，包括 C 语言中的大多数语句、表达式和类型。你可以正式告诉别人你已经写了一个 C 编译器。
- en: If you want, you can stop here. Or, you can move on to [Part III](part3.xhtml),
    where you’ll implement several compiler optimizations to generate more efficient
    assembly code. In [Chapter 19](chapter19.xhtml), you’ll optimize TACKY programs
    by eliminating useless instructions and evaluating constant expressions at compile
    time. In [Chapter 20](chapter20.xhtml), you’ll write a register allocator, which
    maps pseudoregisters to hardware registers instead of locations on the stack.
    These optimizations aren’t specific to C or x64 assembly; you’ll find them in
    compilers with lots of different source and target languages.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以在这里停止。或者，你可以继续阅读 [第三部分](part3.xhtml)，在这里你将实现几个编译器优化，生成更高效的汇编代码。在 [第
    19 章](chapter19.xhtml)，你将通过消除无用指令和在编译时评估常量表达式来优化 TACKY 程序。在 [第 20 章](chapter20.xhtml)，你将编写一个寄存器分配器，将伪寄存器映射到硬件寄存器，而不是堆栈上的位置。这些优化不仅仅适用于
    C 或 x64 汇编；你将在支持多种源语言和目标语言的编译器中找到它们。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>
  id: totrans-685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">附加资源</samp>
- en: 'If you want to learn about the complete System V x64 calling convention, including
    all the rules for passing structures and unions, you have a couple of options:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解完整的 System V x64 调用约定，包括所有传递结构体和联合体的规则，你有几个选择：
- en: The official System V x86-64 ABI is available at *[https://<wbr>gitlab<wbr>.com<wbr>/x86<wbr>-psABIs<wbr>/x86<wbr>-64<wbr>-ABI](https://gitlab.com/x86-psABIs/x86-64-ABI)*.
    (I’ve linked to this a couple of times already.) Section 3.2.3 discusses parameter
    passing.
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方的 System V x86-64 ABI 可在 *[https://<wbr>gitlab<wbr>.com<wbr>/x86<wbr>-psABIs<wbr>/x86<wbr>-64<wbr>-ABI](https://gitlab.com/x86-psABIs/x86-64-ABI)*
    查阅。（我已经链接过几次了。）第 3.2.3 节讨论了参数传递。
- en: Agner Fog has written a helpful manual describing the calling conventions of
    different C++ compilers (*[https://<wbr>www<wbr>.agner<wbr>.org<wbr>/optimize<wbr>/calling<wbr>_conventions<wbr>.pdf](https://www.agner.org/optimize/calling_conventions.pdf)*).
    Tables 6 and 7, in Section 7.1, cover how structures are passed and returned.
    The document covers C++, so parts of it aren’t relevant, but the description of
    how to pass plain structures and unions applies to C as well as C++.
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Agner Fog 编写了一个有用的手册，描述了不同 C++ 编译器的调用约定（* [https://<wbr>www<wbr>.agner<wbr>.org<wbr>/optimize<wbr>/calling<wbr>_conventions<wbr>.pdf](https://www.agner.org/optimize/calling_conventions.pdf)*）。第
    7.1 节的表 6 和表 7 讲述了结构体如何传递和返回。该文档涵盖了 C++，所以有些部分可能不相关，但如何传递普通结构体和联合体的描述适用于 C 和 C++。
- en: I found Fog’s summary of calling conventions easier to follow than the official
    ABI. If you decide to implement unions for extra credit, you’ll probably need
    to refer to both documents.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现 Fog 对调用约定的总结比官方 ABI 更容易理解。如果你决定为额外学分实现联合体，你可能需要参考这两份文档。
