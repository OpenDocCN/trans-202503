- en: '![](../images/pg484.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg484.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-42.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-42.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">18</samp> <samp class="SANS_Dogma_OT_Bold_B_11">STRUCTURES</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">18</samp> <samp class="SANS_Dogma_OT_Bold_B_11">结构体</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: 'In this chapter, you’ll add one final language feature: structures. You’ll
    also implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operators to access structure
    members. In a fitting end to [Part II](part2.xhtml), you’ll draw on many of the
    skills, concepts, and techniques you learned in earlier chapters. In the identifier
    resolution stage, you’ll resolve structure tags along with function and variable
    identifiers. In the type checker, you’ll record structure definitions in a type
    table, much like you already record function and variable declarations in the
    symbol table. During TACKY generation, you’ll build on the strategy you used in
    [Chapter 14](chapter14.xhtml) to handle operations on dereferenced pointers and
    other objects. And on the backend, you’ll implement the part of the System V calling
    convention that specifies how to pass structures as function parameters and return
    values. Since unions are a close cousin to structures, you might want to implement
    those too. We won’t cover them in detail, but you can add them as an extra credit
    feature.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将添加一个最终的语言特性：结构体。你还将实现 <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> 运算符来访问结构成员。在[第二部分](part2.xhtml)的恰当结尾，你将运用前几章学到的许多技能、概念和技术。在标识符解析阶段，你将解析结构标签以及函数和变量标识符。在类型检查器中，你将像记录函数和变量声明在符号表中一样，在类型表中记录结构定义。在TACKY生成过程中，你将基于[第14章](chapter14.xhtml)中处理解引用指针和其他对象操作的策略进行扩展。而在后端，你将实现System
    V调用约定中指定如何将结构体作为函数参数和返回值传递的部分。由于联合体与结构体关系密切，你可能也想实现它们。我们不会详细讨论，但你可以将它们作为额外功能添加进去。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Declaring Structure Types</samp>'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">声明结构类型</samp>'
- en: You have to declare a structure type before you can use it. There are two kinds
    of structure type declarations. The first, shown in [Listing 18-1](chapter18.xhtml#list18-1),
    specifies the structure’s members.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在使用结构类型之前先声明它。结构类型声明有两种形式。第一种，如[清单 18-1](chapter18.xhtml#list18-1)所示，指定了结构的成员。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-1: A complete structure
    type declaration</samp>'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-1：一个完整的结构类型声明</samp>
- en: 'This listing declares a complete structure type with two members: a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. The identifier
    <samp class="SANS_TheSansMonoCd_W5Regular_11">complete_struct</samp> is this type’s
    *tag*, which we can use to specify the type later in the program. A complete structure
    type must have at least one member, so it’s illegal to declare a structure type
    with an empty member list:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单声明了一个包含两个成员的完整结构类型：一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    类型和一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 类型。标识符 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">complete_struct</samp> 是这个类型的 *标签*，我们可以在程序中稍后使用它来指定类型。一个完整的结构类型必须至少有一个成员，因此声明一个没有成员的结构类型是非法的：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The second kind of structure type declaration, shown in [Listing 18-2](chapter18.xhtml#list18-2),
    specifies a structure’s tag but not its members.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种结构类型声明，如[清单 18-2](chapter18.xhtml#list18-2)所示，指定了结构的标签，但没有指定其成员。
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-2: An incomplete
    structure type declaration</samp>'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-2：一个不完整的结构类型声明</samp>
- en: '[Listing 18-2](chapter18.xhtml#list18-2) declares an incomplete structure type.
    As you learned in the previous chapter, you can use incomplete types only in certain
    limited circumstances. For example, you can’t define a variable of type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct incomplete_struct</samp>, but you
    can define a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    incomplete_struct</samp>. (That’s because we know how much memory a pointer requires,
    but not how much memory this structure requires.) We’ll say that a structure declaration
    with no member list *declares* a type, while a structure declaration with a member
    list both *declares* and *defines* a type. This differs from the terminology you’ll
    see in the C standard and elsewhere; in particular, when people talk about “type
    definitions,” they usually mean aliases introduced with the <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    keyword.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 18-2](chapter18.xhtml#list18-2) 声明了一个不完整的结构类型。正如你在上一章学到的，你只能在某些有限的情况下使用不完整类型。例如，你不能定义一个类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct incomplete_struct</samp>
    的变量，但你可以定义一个指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct incomplete_struct</samp>
    的指针。（这是因为我们知道指针需要多少内存，但不知道这个结构需要多少内存。）我们可以说，带有成员列表的结构声明同时*声明*和*定义*了一个类型，而没有成员列表的结构声明仅仅*声明*了一个类型。这与
    C 标准以及其他地方的术语不同；特别是，当人们谈到“类型定义”时，他们通常指的是使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    关键字引入的别名。'
- en: Structure tags are visible only in the scope in which they’re declared, just
    like function and variable names. If a structure tag is declared at file scope,
    it’s visible from the point where it’s declared until the end of the file. If
    it’s declared at block scope, it’s visible until the end of the block. If two
    structure type declarations with the same tag appear in the same scope, they always
    declare the same type; if they appear in different scopes, they declare distinct
    types. (Type declarations don’t have linkage, so you can’t apply the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> keywords to them.)
    You can declare the same structure type multiple times, but you can’t define it
    more than once.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 结构标签仅在声明它们的作用域内可见，就像函数和变量名称一样。如果一个结构标签在文件作用域中声明，它从声明点开始一直可见直到文件末尾。如果它在块作用域中声明，它会一直可见直到块的末尾。如果在同一作用域中出现两个相同标签的结构类型声明，它们总是声明相同的类型；如果它们出现在不同的作用域中，则声明的是不同的类型。（类型声明没有链接性，所以你不能对它们应用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>
    关键字。）你可以多次声明相同的结构类型，但不能多次定义它。
- en: A structure type is complete once its definition is in scope, as [Listing 18-3](chapter18.xhtml#list18-3)
    illustrates.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦结构的定义在作用域内，它的类型就变成完整的，正如 [列表 18-3](chapter18.xhtml#list18-3) 所示。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-3: Declaring an
    incomplete type and then completing it</samp>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 18-3：声明一个不完整的类型并将其完成</samp>
- en: Between ❶ and ❷, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>
    is an incomplete type. It wouldn’t be legal to define a variable with type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> between these two points
    in the program, but it’s legal to define <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>,
    which is a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>.
    After the end of the type declaration that specifies its member list ❷, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> is a complete type, so
    it’s legal to define a variable with that type ❸.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❶ 和 ❷ 之间，<samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> 是一个不完整类型。在程序的这两点之间，定义类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> 的变量是不合法的，但定义 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>（指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> 的指针）是合法的。在指定其成员列表的类型声明结束之后 ❷，<samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> 成为一个完整类型，因此可以合法地定义该类型的变量 ❸。
- en: When the same structure tag is declared in two different scopes, one can shadow
    the other, as [Listing 18-4](chapter18.xhtml#list18-4) illustrates.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当相同的结构标签在两个不同的作用域中声明时，一个可以遮蔽另一个，正如 [列表 18-4](chapter18.xhtml#list18-4) 所示。
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-4: One structure
    type shadowing another</samp>'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 18-4：一个结构类型遮蔽另一个结构类型</samp>
- en: 'First, we define a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>
    type at file scope ❶. Its size is 4 bytes because it contains a single <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    The first <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expression
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> refers to this type
    ❷. Then, we define another <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> type at block scope ❸, shadowing the first type. This type contains a
    single <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, so its size
    is 8 bytes. The two definitions of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> don’t conflict, because they appear in different scopes. In the second
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expression ❹, the
    specifier <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> refers
    to the 8-byte structure type defined in the inner scope. Running this program
    gives the following output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在文件作用域中定义一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>
    类型 ❶。它的大小为 4 字节，因为它只包含一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 中的第一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    表达式引用了这个类型 ❷。然后，我们在块作用域中定义另一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> 类型 ❸，遮蔽了第一个类型。这个类型只包含一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>，因此它的大小为
    8 字节。两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> 的定义不会冲突，因为它们出现在不同的作用域中。在第二个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 表达式 ❹ 中，指定符 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> 引用的是内部作用域中定义的 8 字节结构体类型。运行该程序会输出以下内容：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Even when a structure’s tag is shadowed, its members are still visible. Consider
    [Listing 18-5](chapter18.xhtml#list18-5).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 即使结构体的标签被遮蔽，它的成员仍然是可见的。请参见 [示例 18-5](chapter18.xhtml#list18-5)。
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-5: Using a variable
    with a shadowed structure type</samp>'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 18-5：使用一个带有遮蔽结构类型的变量</samp>
- en: In this listing, we first declare a structure type, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    shadow</samp> ❶. Then, we define a variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">outer</samp>,
    with that type. In the inner scope, we declare another structure type with the
    same tag ❷, which shadows the outer declaration. We then declare a variable with
    this new type, <samp class="SANS_TheSansMonoCd_W5Regular_11">inner</samp>. In
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement, we
    can still access the members of both variables ❸. Even in the inner scope, the
    compiler knows about the original <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    shadow</samp> type, and it still knows that <samp class="SANS_TheSansMonoCd_W5Regular_11">outer</samp>
    belongs to that type; we just can’t specify that type with the <samp class="SANS_TheSansMonoCd_W5Regular_11">shadow</samp>
    tag.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先声明一个结构体类型，<samp class="SANS_TheSansMonoCd_W5Regular_11">struct shadow</samp>
    ❶。然后，我们用该类型定义一个变量，<samp class="SANS_TheSansMonoCd_W5Regular_11">outer</samp>。在内部作用域中，我们声明另一个具有相同标签的结构体类型
    ❷，它会遮蔽外部的声明。接着，我们用这个新类型声明一个变量，<samp class="SANS_TheSansMonoCd_W5Regular_11">inner</samp>。在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句中，我们仍然可以访问两个变量的成员
    ❸。即使在内部作用域中，编译器仍然知道原始的 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct shadow</samp>
    类型，并且仍然知道 <samp class="SANS_TheSansMonoCd_W5Regular_11">outer</samp> 属于该类型；我们只是不可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">shadow</samp> 标签来指定该类型。
- en: 'To keep all our structure types straight, we’ll treat structure tags a lot
    like variable names: in the identifier resolution pass, we’ll replace each user-defined
    tag with a unique identifier.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持所有结构体类型的一致性，我们将像处理变量名一样处理结构体标签：在标识符解析阶段，我们将用一个唯一标识符替换每个用户定义的标签。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Structure Member
    Declarations</samp>
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">结构体成员声明</samp>
- en: The members of a structure can have any complete type, including primitive types
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and derived types
    like arrays, pointers, or other structures. It’s illegal to declare a structure
    member with an incomplete type, however, because that makes it impossible to determine
    the size of the whole structure. This implies, as section 6.7.2.1, paragraph 3,
    of the C standard puts it, that “a structure shall not contain an instance of
    itself.” That is, a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>
    can’t contain a member of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp>. On the other hand, a structure can contain a pointer to itself because
    pointer types are always complete. The canonical example, shown in [Listing 18-6](chapter18.xhtml#list18-6),
    is a node in a linked list, which holds a value and a pointer to the next list
    entry.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体的成员可以是任何完整类型，包括原始类型如<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，以及派生类型如数组、指针或其他结构体。然而，声明一个不完整类型的结构体成员是非法的，因为这样会导致无法确定整个结构体的大小。正如C标准第6.7.2.1节第3段所说：“结构体不能包含其自身的实例。”也就是说，一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>不能包含类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp>的成员。另一方面，结构体可以包含指向自身的指针，因为指针类型总是完整的。经典的示例，如[Listing 18-6](chapter18.xhtml#list18-6)所示，是一个链表节点，它包含一个值和指向下一个列表条目的指针。
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-6: A structure type
    definition that contains a pointer to itself</samp>'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-6：包含指向自身指针的结构体类型定义</samp>
- en: After ❶, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct linked_list_node</samp>
    is visible as an incomplete type, so we can declare the member <samp class="SANS_TheSansMonoCd_W5Regular_11">next</samp>
    as a pointer to this type. After ❷, the type is complete.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在❶之后，<samp class="SANS_TheSansMonoCd_W5Regular_11">struct linked_list_node</samp>作为不完整类型是可见的，因此我们可以将成员<samp
    class="SANS_TheSansMonoCd_W5Regular_11">next</samp>声明为指向该类型的指针。在❷之后，该类型是完整的。
- en: It’s also illegal to declare functions as structure members. A structure can
    hold function pointers—which are complete types, just like any other pointer—but
    we don’t support function pointers, so that doesn’t matter to us.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 声明函数作为结构体成员也是不合法的。结构体可以包含函数指针——它们是完整类型，就像任何其他指针一样——但我们不支持函数指针，因此这对我们来说并不重要。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tag and Member Namespaces</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">标签和成员命名空间</samp>
- en: Structure tags are in a different namespace from functions and variables. This
    means the same identifier can be used as both a tag and a function or variable
    name, and neither identifier will shadow or conflict with the other. It’s perfectly
    legal, for example, to declare the type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> and a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    in the same scope. It’s possible to maintain these separate namespaces because
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> keyword tells
    the compiler that a particular identifier is a structure tag.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体标签位于与函数和变量不同的命名空间中。这意味着相同的标识符可以同时用作标签和函数或变量名，并且这两个标识符不会相互遮蔽或冲突。例如，在同一作用域内声明类型<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>和变量<samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>是完全合法的。之所以能保持这些独立的命名空间，是因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>关键字告诉编译器，某个特定的标识符是结构体标签。
- en: 'Similarly, each structure member list is its own namespace. A structure member
    can share a name with any function, variable, or structure type, including the
    structure type that contains it, like in the following example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，每个结构体成员列表都有自己的命名空间。结构体成员可以与任何函数、变量或结构体类型共享名称，包括包含它的结构体类型，如以下示例所示：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It’s also legal for members in different structures to have the same name:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不同结构体中的成员也可以拥有相同的名称：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When the identifier <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> appears
    in an expression, like <samp class="SANS_TheSansMonoCd_W5Regular_11">var->x</samp>,
    the compiler can figure out from context whether it refers to the member in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">s1</samp>, the member in <samp class="SANS_TheSansMonoCd_W5Regular_11">s2</samp>,
    or a function or variable. Unsurprisingly, it’s illegal for two members of the
    same structure to share a name.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当标识符 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 出现在表达式中，比如 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">var->x</samp> 时，编译器可以从上下文中推断出它是指 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">s1</samp> 中的成员、<samp class="SANS_TheSansMonoCd_W5Regular_11">s2</samp>
    中的成员，还是一个函数或变量。毫不意外，同一结构体的两个成员不能共享相同的名称。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Structure Type Declarations
    We Aren’t Implementing</samp>
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">我们没有实现的结构体类型声明</samp>
- en: C syntax doesn’t distinguish between structure type specifiers and type declarations,
    so you can simultaneously declare a new structure type and use that structure
    type in some larger construct. In [Listing 18-7](chapter18.xhtml#list18-7), for
    example, a single declaration defines a new structure type, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp>, and a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: C 语法不会区分结构体类型说明符和类型声明，因此你可以同时声明一个新的结构体类型，并在某个更大的构造中使用该结构体类型。例如，在[清单 18-7](chapter18.xhtml#list18-7)中，一个声明定义了一个新的结构体类型，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>，以及一个类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> 的变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>。
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-7: Defining and
    specifying a structure type in the same declaration</samp>'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-7：在同一个声明中定义并指定结构体类型</samp>
- en: 'To simplify parsing and semantic analysis, we’ll require every declaration
    to declare exactly one function, variable, or type. We won’t support declarations
    like [Listing 18-7](chapter18.xhtml#list18-7) that declare a new type and some
    other entity at the same time. This goes for incomplete types as well. The C standard
    lets you implicitly declare an incomplete structure type, just by specifying it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化解析和语义分析，我们要求每个声明必须只声明一个函数、变量或类型。我们不支持像[清单 18-7](chapter18.xhtml#list18-7)中那样同时声明新类型和其他实体的声明。这也适用于不完整类型。C
    标准允许你仅通过指定它来隐式声明一个不完整的结构体类型：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Even if <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> hasn’t
    yet been declared, this declaration is legal: it simultaneously declares <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> as an incomplete type
    and declares a function that returns a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp>. However, our implementation won’t permit this. Instead, we’ll require
    a separate declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> first:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> 尚未声明，该声明仍然是合法的：它同时将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> 声明为一个不完整类型，并声明了一个返回指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> 的指针的函数。然而，我们的实现不允许这样做。相反，我们要求首先声明
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Requiring types to be declared before they’re used also implies that you can’t
    nest one structure declaration inside another, like in [Listing 18-8](chapter18.xhtml#list18-8).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要求类型在使用之前声明，也意味着你不能在另一个结构体声明内嵌套一个结构体声明，像[清单 18-8](chapter18.xhtml#list18-8)中那样。
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-8: Declaring an</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">inner</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">structure
    type and declaring member</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">i</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">with that type in the same declaration</samp>'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-8：在同一个声明中声明</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">内部</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">结构体类型并声明具有该类型的成员</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">i</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">的声明</samp>
- en: We’ll impose a few other restrictions too. We’ll reject structure declarations
    without tags and structure members without names, even though the C standard permits
    them. We also won’t support *bit-field members*, which make it possible to address
    individual bits within a structure.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会施加一些其他限制。我们将拒绝没有标签的结构体声明和没有名称的结构体成员，尽管 C 标准允许它们。我们也不支持 *位字段成员*，这使得可以在结构体内对单个比特进行寻址。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Operating on Structures</samp>
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">操作结构体</samp>
- en: 'You can access the members of a structure with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    operator:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> 运算符访问结构体的成员：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you have a pointer to a structure, you can access the structure’s members
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operator. Continuing
    with the same example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个指向结构体的指针，你可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    运算符访问结构体的成员。继续使用相同的例子：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can apply the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operators only to complete
    structure types. You can’t access the members of an incomplete structure type,
    since those members haven’t been defined yet.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能对完整的结构体类型使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-></samp> 运算符。你不能访问不完整结构体类型的成员，因为这些成员尚未定义。
- en: Structures are aggregate types, like arrays. But structures don’t decay to pointers
    like arrays do, so you can use them in several ways that you can’t use arrays.
    For example, you can pass them as function arguments and return values. You can
    also assign to them, like in [Listing 18-9](chapter18.xhtml#list18-9).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体是聚合类型，像数组一样。但结构体不像数组那样会退化为指针，因此你可以以几种不能用于数组的方式使用它们。例如，你可以将它们作为函数参数和返回值。你还可以像
    [示例 18-9](chapter18.xhtml#list18-9) 中那样进行赋值。
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-9: Assigning to
    a structure</samp>'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 18-9：赋值给结构体</samp>
- en: 'You can assign to individual members of a structure too, as long as they’re
    lvalues. A structure member specified with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    operator is always an lvalue:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将值赋给结构体的单个成员，只要它们是左值。通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    运算符指定的结构体成员始终是左值：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Recall that all dereferenced pointers are lvalues. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    operator produces a dereferenced pointer, much like the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp> operators do, so the
    same rules apply.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，所有解引用的指针都是左值。<samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> 运算符产生一个解引用指针，就像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>
    运算符一样，因此同样的规则适用。
- en: 'If a structure is an lvalue, any members you access with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    operator are lvalues too. If a structure isn’t an lvalue, neither are its members.
    Therefore, this assignment expression is legal:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结构体是左值，那么你通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> 运算符访问的任何成员也是左值。如果结构体不是左值，那么它的成员也不是左值。因此，以下赋值表达式是合法的：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'But, because the result of a function call isn’t an lvalue, this is illegal:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，由于函数调用的结果不是左值，因此这是非法的：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Structures can appear in a few other expressions, pretty much where you’d expect.
    They can appear in the branches of conditional expressions, as long as both branches
    have the same structure type. You can get their size with <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    and cast them to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, but
    you can’t otherwise cast to or from structure types. And if a structure or structure
    member is an lvalue, you can take its address.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体还可以出现在其他一些表达式中，基本上是你预期出现的地方。它们可以出现在条件表达式的分支中，只要两个分支有相同的结构体类型。你可以使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 获取它们的大小，并将它们转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>，但你不能将它们转换为或从结构体类型进行转换。如果一个结构体或结构体成员是左值，你可以获取它的地址。
- en: 'There are two ways to initialize a structure. You can initialize it with an
    expression of the same structure type:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化结构体有两种方式。你可以使用与结构体类型相同的表达式进行初始化：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Or, you can use a compound initializer to initialize each member individually,
    like in [Listing 18-10](chapter18.xhtml#list18-10).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用复合初始化器单独初始化每个成员，像 [示例 18-10](chapter18.xhtml#list18-10) 中那样。
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-10: Initializing
    a structure with a compound initializer</samp>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 18-10：使用复合初始化器初始化结构体</samp>
- en: A compound initializer initializes a structure’s members in order. The initializer
    in [Listing 18-10](chapter18.xhtml#list18-10) initializes <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp>
    with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">2.0</samp>.
    The inner compound initializer initializes the three array elements in <samp class="SANS_TheSansMonoCd_W5Regular_11">array_member</samp>
    ❶. Note that compound initializers for arrays and structures have identical syntax.
    (The syntax for *designated initializers*, which initialize specific subobjects
    in an aggregate object, is different for array elements and structure members,
    but we won’t implement designated initializers.) By nesting compound initializers,
    you can initialize arrays of structures, structures that contain other structures,
    and so on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 复合初始化器按顺序初始化结构的成员。[清单 18-10](chapter18.xhtml#list18-10)中的初始化器将<sup class="SANS_TheSansMonoCd_W5Regular_11">member1</samp>初始化为<sup
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，将<sup class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>初始化为<sup
    class="SANS_TheSansMonoCd_W5Regular_11">2.0</samp>。[清单 18-10](chapter18.xhtml#list18-10)中的内嵌复合初始化器初始化<sup
    class="SANS_TheSansMonoCd_W5Regular_11">array_member</sup>中的三个数组元素 ❶。请注意，数组和结构的复合初始化器具有相同的语法。（用于*指定初始化器*的语法，它用于初始化聚合对象中的特定子对象，数组元素和结构成员的语法不同，但我们不会实现指定初始化器。）通过嵌套复合初始化器，你可以初始化结构数组、包含其他结构的结构等。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Structure Layout in Memory</samp>
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">结构在内存中的布局</samp>
- en: At this point, we have a pretty good sense of how structure types work in source
    code. Now let’s look at how they’re laid out in memory at runtime. This is specified
    partly by the C standard and partly by the System V ABI. It’s important to lay
    out structures exactly as the ABI specifies so that the code we compile can interoperate
    with other code that uses structures.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经对结构类型在源代码中的工作方式有了相当清晰的理解。现在让我们来看一下它们在运行时内存中的布局。内存布局部分由 C 标准规定，部分由
    System V ABI 规定。按照 ABI 的规定精确布局结构非常重要，这样我们编译的代码才能与其他使用结构的代码进行互操作。
- en: A structure’s members appear in the same order in memory as in the original
    structure declaration. The first member must have the same address as the structure
    as a whole; you can always convert a pointer to a structure into a pointer to
    its first member, and vice versa. Each subsequent member will be stored at the
    earliest free address with the correct alignment. Let’s use the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    example</samp> type from [Listing 18-10](chapter18.xhtml#list18-10) as an example.
    [Listing 18-11](chapter18.xhtml#list18-11) reproduces the definition of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct example</samp>.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 结构的成员在内存中的顺序与原始结构声明中的顺序相同。第一个成员必须具有与整个结构相同的地址；你总是可以将结构的指针转换为指向其第一个成员的指针，反之亦然。每个后续成员将存储在正确对齐的最早可用地址处。我们以[清单
    18-10](chapter18.xhtml#list18-10)中的<samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    example</samp>类型为例。[清单 18-11](chapter18.xhtml#list18-11)重复了<samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    example</samp>的定义。
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-11: A structure
    type with several members with different alignments</samp>'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-11：一个具有不同对齐方式的多个成员的结构类型</samp>
- en: The first member must start at the very beginning of the structure. Because
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp> is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    it occupies the structure’s first 4 bytes. Bytes in a structure are typically
    zero-indexed, so we’ll say that <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp>
    occupies bytes 0 through 3\. The next unused space is therefore at byte 4\. But
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    which is 8-byte aligned; its starting address must be a multiple of 8\. Therefore,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> will be stored in
    bytes 8 through 15\. We say that <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>
    has an offset of 8 bytes from the start of the structure. Between <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>, in bytes 4 through
    7, we have 4 bytes of padding.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个成员必须从结构的最开始处开始。因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp>
    是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型，它占用了结构的前4个字节。结构中的字节通常是零索引的，因此我们可以说
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp> 占用了字节 0 到 3。接下来的空闲空间因此位于字节
    4。但是 <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> 是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    类型，它需要 8 字节对齐；它的起始地址必须是 8 的倍数。因此，<samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>
    会存储在字节 8 到 15 之间。我们说 <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>
    从结构的起始位置有 8 字节的偏移。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> 之间，即字节 4 到 7 之间，我们有
    4 字节的填充。
- en: The last member, <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>,
    takes up 3 bytes and has an alignment of 1 byte. Since we don’t need any padding
    to align it correctly, we’ll store it right after <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>,
    in bytes 16 through 18.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的成员 <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> 占用了 3 个字节，且对齐方式为
    1 字节。由于我们不需要任何填充来正确对齐它，因此我们将其直接存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>
    后面，即字节 16 到 18 之间。
- en: We’ll also need padding at the end of the structure, after <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>.
    According to the System V ABI, the size of a type must be a multiple of its alignment.
    The ABI also states that a structure takes on the same alignment as its most strictly
    aligned member. The most strictly aligned member of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    example</samp> is the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>. Therefore, the whole
    structure must be 8-byte aligned, and its size must be a multiple of 8\. The three
    members of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct example</samp>
    and the padding between them occupy 19 bytes. We’ll add 5 bytes of padding to
    the end of the structure, bringing its total size to 24 bytes. [Figure 18-1](#fig18-1)
    illustrates the layout of the whole structure.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构的末尾，即 <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> 后面，我们还需要填充。根据
    System V ABI，一个类型的大小必须是其对齐方式的倍数。ABI 还指出，结构体必须具有与其对齐最严格成员相同的对齐方式。<samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    example</samp> 的最严格对齐成员是 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    类型的 <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>。因此，整个结构体必须是 8
    字节对齐的，且其大小必须是 8 的倍数。<samp class="SANS_TheSansMonoCd_W5Regular_11">struct example</samp>
    的三个成员及它们之间的填充共占用 19 个字节。我们将在结构体的末尾添加 5 个字节的填充，将其总大小调整为 24 字节。[图 18-1](#fig18-1)
    展示了整个结构的布局。
- en: '![](../images/fig18-1.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig18-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-1: The structure
    layout in memory [Description](description-43.xhtml)</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图18-1：内存中的结构布局 [描述](description-43.xhtml)</samp>
- en: The padding between members guarantees that each member will end up at a correctly
    aligned memory address. If the starting address of the entire structure is a multiple
    of 8 and the offset of <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>
    from the start is also a multiple of 8, we know that <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>’s
    runtime memory address will be a multiple of 8 too. The padding at the end of
    the structure guarantees that each element in an array of structures will have
    the correct alignment; if the initial element in an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    example</samp> objects is 8-byte aligned and its total size is 24 bytes, each
    subsequent element will be 8-byte aligned as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 成员之间的填充保证了每个成员最终会出现在正确对齐的内存地址。如果整个结构体的起始地址是 8 的倍数，并且 <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>
    从起始位置的偏移量也是 8 的倍数，那么我们可以知道 <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>
    的运行时内存地址也将是 8 的倍数。结构体末尾的填充保证了结构体数组中的每个元素都将正确对齐；如果一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    example</samp> 对象数组的第一个元素是 8 字节对齐，并且其总大小为 24 字节，那么每个后续元素也将是 8 字节对齐的。
- en: Now that you understand how to work with structures in C and how they’re laid
    out in memory, let’s get to work on implementing them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了如何在 C 中使用结构体以及它们在内存中的布局，我们开始着手实现它们吧。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">词法分析器</samp>
- en: 'You’ll add three new tokens in this chapter:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你将添加三个新令牌：
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">struct</samp> | A keyword indicating
    a structure type specifier |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">struct</samp> | 一个关键字，表示结构体类型说明符
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">.</samp> | A period, the structure
    member access operator |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">.</samp> | 一个句点，表示结构体成员访问运算符
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-></samp> | An arrow, the operator
    to access a structure member through a pointer |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-></samp> | 一个箭头运算符，用于通过指针访问结构体成员
    |'
- en: Keep in mind that a period can be either a structure member access operator
    or part of a floating-point constant. We’ll recognize a period as a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    token only if it’s followed by a non-digit character. If a period is followed
    by a digit, either it’s the start of a floating-point constant or it’s invalid.
    For example, if the lexer sees the input <samp class="SANS_TheSansMonoCd_W5Regular_11">.100u</samp>,
    it should try to parse this as a constant. It will then raise an error, since
    this doesn’t match the regular expression for any kind of constant. It should
    *not* lex this as a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> token
    followed by the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">100u</samp>.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，句点可以是结构体成员访问运算符，也可以是浮动点常量的一部分。我们只有在句点后跟着一个非数字字符时，才会将它识别为 <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    令牌。如果句点后跟着数字，那么它要么是浮动点常量的开始，要么是无效的。例如，如果词法分析器看到输入 <samp class="SANS_TheSansMonoCd_W5Regular_11">.100u</samp>，它应尝试将其解析为常量。然后它会报错，因为这不符合任何常量的正则表达式。它**不**应该把这个解析为一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> 令牌后面跟着常量 <samp class="SANS_TheSansMonoCd_W5Regular_11">100u</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">语法分析器</samp>
- en: 'We’ll add several new constructs to the AST in this chapter: structure declarations,
    structure type specifiers, and the two new structure operators. [Listing 18-12](chapter18.xhtml#list18-12)
    gives the AST definition for structure declarations.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向 AST 添加几个新构造：结构体声明、结构类型说明符和两个新的结构体运算符。[清单 18-12](chapter18.xhtml#list18-12)
    给出了结构声明的 AST 定义。
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-12: Representing
    structure declarations in the AST</samp>'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-12：在 AST 中表示结构声明</samp>
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_declaration</samp> consists
    of a tag and a list of members. To represent an incomplete structure type declaration,
    we’ll leave the member list empty. (Remember that a complete structure type must
    have at least one member.) We’ll represent each member with a <samp class="SANS_TheSansMonoCd_W5Regular_11">member_declaration</samp>,
    which includes a member name and a type.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_declaration</samp> 包含一个标签和一系列成员。为了表示一个不完整的结构类型声明，我们将把成员列表留空。（记住，完整的结构类型必须至少有一个成员。）我们将用一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member_declaration</samp> 来表示每个成员，其中包括成员名称和类型。
- en: 'Next, we’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp>
    AST node to support structure type declarations as well as function and variable
    declarations:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将扩展 <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp> AST
    节点，以支持结构类型声明以及函数和变量声明：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We’ll also extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    AST node to include structure type specifiers like <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp>:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将扩展 <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> AST 节点，以包含像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> 这样的结构类型说明符：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we’ll add two new expressions: the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operators, sometimes
    called the *structure member operator* and *structure pointer operator*, respectively.
    We’ll use the more concise names <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加两个新表达式：<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-></samp> 运算符，有时分别称为 *结构成员运算符* 和 *结构指针运算符*。我们将使用更简洁的名称
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Each of these operators takes an expression as its first operand and the name
    of a structure member as its second operand. [Listing 18-13](chapter18.xhtml#list18-13)
    defines the complete AST, with this chapter’s changes bolded.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符中的每一个都将一个表达式作为第一个操作数，结构成员的名称作为第二个操作数。[清单 18-13](chapter18.xhtml#list18-13)
    定义了完整的 AST，并以粗体突出显示了本章的更改。
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-13: The abstract
    syntax tree with structure types and the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">-></samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">operators</samp>'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-13：带有结构类型的抽象语法树及</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">和</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">-></samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">运算符</samp>
- en: '[Listing 18-14](chapter18.xhtml#list18-14) shows the corresponding changes
    to the grammar.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 18-14](chapter18.xhtml#list18-14) 显示了语法的相应变化。'
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-14: The grammar
    with structure types and the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">-></samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">operators</samp>'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-14：带有结构类型的语法及</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">.</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">和</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">-></samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">运算符</samp>
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11"><struct-declaration></samp>
    may include a brace-enclosed list of structure members ❶. This member list is
    optional, but if the braces are present they must contain at least one member.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 <samp class="SANS_TheSansMonoCd_W5Regular_11"><struct-declaration></samp>
    可能包含一个由大括号括起来的结构成员列表 ❶。这个成员列表是可选的，但如果存在大括号，它们必须包含至少一个成员。
- en: 'A structure member declaration has the same form as a variable declaration;
    it includes a list of type specifiers and a declarator and ends with a semicolon.
    Unlike a variable declaration, however, a structure member can’t have an initializer
    or a storage class. We’ll impose one syntactic requirement that isn’t reflected
    in the grammar: the parser should reject function declarators in structure member
    declarations, even though the <samp class="SANS_TheSansMonoCd_W5Regular_11"><member
    -declaration></samp> grammar rule allows them. For example, the parser should
    reject this declaration:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 结构成员声明的形式与变量声明相同；它包括一个类型说明符列表和一个声明符，并以分号结束。然而，与变量声明不同，结构成员不能有初始化器或存储类。我们将施加一个语法要求，尽管语法中并未体现：解析器应拒绝结构成员声明中的函数声明符，尽管
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><member -declaration></samp> 语法规则允许它们。例如，解析器应拒绝以下声明：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A structure type specifier consists of two tokens: the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    keyword and an identifier token, which specifies the structure tag. This specifier
    can’t be combined with other type specifiers, but it can be modified by a pointer,
    array, or function declarator.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 结构类型说明符由两个标记组成：<samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> 关键字和一个标识符标记，指定结构标签。该说明符不能与其他类型说明符结合使用，但可以通过指针、数组或函数声明符进行修饰。
- en: The new <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    operators are postfix operators, like the subscript operator we added in [Chapter
    15](chapter15.xhtml). All three postfix operators have higher precedence than
    any prefix operator. The new <samp class="SANS_TheSansMonoCd_W5Regular_11"><postfix-op></samp>
    symbol includes all three operators, which ensures that they’re all parsed with
    the correct precedence.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    操作符是后缀操作符，类似于我们在[第15章](chapter15.xhtml)中添加的下标操作符。所有这三种后缀操作符的优先级都高于任何前缀操作符。新的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><postfix-op></samp> 符号包括了所有三个操作符，这确保了它们会以正确的优先级进行解析。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp>
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">语义分析</samp>
- en: We haven’t made any substantive changes to the identifier resolution pass in
    a while. Now we’ll have it resolve structure tags along with function and variable
    names. This pass will assign every structure type a unique ID, replacing its original
    user-defined tag. It will also throw an error if a program tries to specify a
    structure type before declaring it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一段时间没有对标识符解析过程做出实质性改动了。现在，我们将让它解析结构标签以及函数和变量名称。这个过程将为每个结构类型分配一个唯一的ID，替换掉它原来的用户定义标签。如果程序在声明结构之前尝试指定结构类型，系统也会抛出错误。
- en: In the type checker, we’ll introduce a new table to track structure definitions.
    We’ll refer to these definitions when we type check initializers, member access
    operators, and other operations on structures. We’ll also use them to generate
    TACKY and assembly in later stages.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型检查器中，我们将引入一个新的表格来跟踪结构定义。当我们对初始化器、成员访问操作符以及其他结构操作进行类型检查时，我们会参考这些定义。我们还将在后续阶段使用它们来生成TACKY和汇编代码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Resolving Structure
    Tags</samp>
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">解析结构标签</samp>
- en: Let’s walk through how to handle structure tags during identifier resolution.
    We’ll rename these tags in basically the same way that we rename local variables.
    We’ll maintain a map from user-defined tags to unique identifiers. When we find
    a declaration of a new structure type, we’ll generate a new identifier and add
    it to the map. And when we encounter a structure type specifier, we’ll replace
    it with the corresponding unique identifier from the map. Because structure tags
    exist in a separate namespace from functions and variables, we’ll track them in
    a separate map.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何在标识符解析过程中处理结构标签。我们将以基本相同的方式重命名这些标签，就像我们重命名局部变量一样。我们将保持一个从用户定义标签到唯一标识符的映射。当我们找到新的结构类型声明时，我们会生成一个新的标识符并将其添加到映射中。当我们遇到结构类型说明符时，我们将用映射中对应的唯一标识符替换它。由于结构标签存在于与函数和变量不同的命名空间中，我们将把它们跟踪在一个单独的映射中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Defining the Structure Tag
    Map</samp>
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">定义结构标签映射</samp>
- en: 'In our existing identifier map, we track three pieces of information about
    each user-defined function or variable name: the unique identifier we’ll replace
    it with, whether it has linkage, and whether it was defined in the current scope.
    In the structure tag map, we’ll track each tag’s unique identifier and whether
    it was defined in the current scope, but we won’t track linkage, because that
    concept doesn’t apply to types. Go ahead and define this data structure. Then,
    we’ll look at how to resolve tags in type specifiers and declarations.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们现有的标识符映射中，我们追踪每个用户定义的函数或变量名称的三项信息：我们将替换它的唯一标识符，它是否有链接性，以及它是否在当前作用域中定义。在结构标签映射中，我们将跟踪每个标签的唯一标识符以及它是否在当前作用域中定义，但我们不会追踪链接性，因为这个概念不适用于类型。请定义这个数据结构。然后，我们将看看如何解析类型说明符和声明中的标签。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Resolving Type Specifiers</samp>
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">解析类型说明符</samp>
- en: '[Listing 18-15](chapter18.xhtml#list18-15) illustrates how to resolve a type
    specifier.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 18-15](chapter18.xhtml#list18-15) 展示了如何解析类型说明符。'
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-15: Replacing structure
    tags in a type specifier</samp>'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 18-15：在类型说明符中替换结构标签</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp> function
    accepts a type specifier and returns a copy of that specifier in which any structure
    tags have been replaced with unique IDs. When <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp>
    encounters a structure type, it replaces the tag with the corresponding identifier
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">structure_map</samp> ❶. If
    the tag isn’t in <samp class="SANS_TheSansMonoCd_W5Regular_11">structure _map</samp>,
    the structure hasn’t been declared yet, so it throws an error ❷. To resolve a
    derived type, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Pointer</samp>,
    we resolve its constituent types recursively. I’ve omitted the pseudocode for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Array</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">FunType</samp>,
    which we’ll handle the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">Pointer</samp>.
    We return any other type unchanged. We’ll process every type specifier in the
    AST with <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp>, including
    specifiers in function and variable declarations, cast and <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    expressions, and structure member declarations.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp> 函数接受一个类型说明符，并返回该说明符的副本，其中任何结构标签已被唯一
    ID 替换。当 <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp> 遇到结构类型时，它会用来自
    <samp class="SANS_TheSansMonoCd_W5Regular_11">structure_map</samp> ❶ 的相应标识符替换标签。如果标签不在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">structure_map</samp> 中，则表示该结构尚未声明，因此会抛出错误
    ❷。要解决派生类型（例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">Pointer</samp>），我们递归地解析其组成类型。我已经省略了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Array</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">FunType</samp>
    的伪代码，它们的处理方式与 <samp class="SANS_TheSansMonoCd_W5Regular_11">Pointer</samp> 相同。我们返回任何其他未变更的类型。我们将使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp> 处理 AST 中的每个类型说明符，包括函数和变量声明中的说明符、强制转换和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 表达式，以及结构成员声明。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Resolving Structure Type Declarations</samp>
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">解析结构类型声明</samp>
- en: Next, let’s look at the pseudocode in [Listing 18-16](chapter18.xhtml#list18-16),
    which illustrates how to resolve a structure type declaration.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 [Listing 18-16](chapter18.xhtml#list18-16) 中的伪代码，它展示了如何解析结构类型声明。
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-16: Adding structure
    type declarations to the structure tag map</samp>'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-16: 将结构类型声明添加到结构标签映射中</samp>'
- en: First, we look up the declaration’s tag in the structure tag map ❶. If this
    tag hasn’t been declared yet, or if it was declared in an outer scope, this declaration
    introduces a new type. We therefore generate a new identifier and add it to the
    structure tag map ❷. If the structure’s tag was already declared in the current
    scope, the current declaration just redeclares the same type. In this case, we
    don’t generate a new unique ID; instead, we use the one that’s already in the
    map ❸.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在结构标签映射中查找声明的标签 ❶。如果该标签尚未声明，或者它是在外部作用域声明的，则该声明引入了一个新类型。因此，我们生成一个新的标识符并将其添加到结构标签映射中
    ❷。如果该结构的标签已经在当前作用域中声明，则当前声明只是重新声明了相同的类型。在这种情况下，我们不会生成新的唯一 ID；相反，我们使用映射中已有的 ID
    ❸。
- en: At this point, the structure tag map is up to date. Now we transform the structure
    type declaration itself. If this declaration specifies the structure’s members,
    we resolve its member types by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp>
    on each of them ❹. We replace the declaration’s user-defined tag with <samp class="SANS_TheSansMonoCd_W5Regular_11">unique_tag</samp>,
    the ID that we generated or looked up earlier in the function. Finally, we return
    the transformed declaration ❺.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，结构标签映射已是最新的。接下来，我们转变结构类型声明本身。如果该声明指定了结构的成员，我们通过对每个成员调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp>
    来解析其成员类型 ❹。我们用 <samp class="SANS_TheSansMonoCd_W5Regular_11">unique_tag</samp>（即我们在函数中之前生成或查找的
    ID）替换声明的用户定义标签。最后，我们返回转换后的声明 ❺。
- en: 'Note that we add the new tag to <samp class="SANS_TheSansMonoCd_W5Regular_11">structure_map</samp>
    before processing any structure members. This lets us accept self-referential
    structures, like the linked list node from [Listing 18-6](chapter18.xhtml#list18-6):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在处理任何结构成员之前，将新标签添加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">structure_map</samp>
    中。这使我们能够接受自引用结构，例如来自 [Listing 18-6](chapter18.xhtml#list18-6) 的链表节点：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Also note that we don’t generate unique names for structure members. Variables
    and functions need unique identifiers because they’re all stored in a single symbol
    table, and structure tags need to be unique because they’re all stored in a single
    type table, but structure members won’t all be stored in one table. Instead, we’ll
    maintain a separate member list for each structure type, so members in different
    structures with the same name won’t conflict with each other.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，我们不会为结构体成员生成唯一名称。变量和函数需要唯一标识符，因为它们都存储在同一个符号表中，结构体标签需要唯一，因为它们都存储在同一个类型表中，但结构体成员不会全部存储在一个表中。相反，我们会为每个结构体类型维护一个单独的成员列表，因此不同结构体中具有相同名称的成员不会互相冲突。
- en: 'We’ll make two more updates to the identifier resolution pass. First, at the
    start of each new scope, we’ll make a copy of the structure tag map with each
    entry’s <samp class="SANS_TheSansMonoCd_W5Regular_11">from_current_scope</samp>
    attribute set to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>, just
    like we do for the identifier map. The second change is purely mechanical: we’ll
    extend <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> to process
    the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>
    expressions the same way it processes all the other kinds of expressions. I’ll
    skip the pseudocode for these changes, since they’re both straightforward.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对标识符解析过程进行两个更新。首先，在每个新作用域的开始，我们将复制结构体标签映射，并将每个条目的 <samp class="SANS_TheSansMonoCd_W5Regular_11">from_current_scope</samp>
    属性设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，就像我们对标识符映射所做的那样。第二个变化是纯粹的机械操作：我们将扩展
    <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> 来处理新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp> 表达式，就像它处理其他所有类型的表达式一样。我会跳过这些变化的伪代码，因为它们都很直白。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Structures</samp>
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">类型检查结构体</samp>
- en: Much like the type checker records information about every function and variable
    in the symbol table, it will also record information about every complete structure
    type in the *type table*. Let’s start by defining the type table; then, we’ll
    look at how to convert structure type declarations to type table entries. Finally,
    we’ll use the information in the type table to type check declarations, expressions,
    and initializers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 就像类型检查器会在符号表中记录关于每个函数和变量的信息一样，它也会在*类型表*中记录每个完整结构体类型的信息。让我们先定义类型表；然后，我们将看看如何将结构体类型声明转换为类型表条目。最后，我们将使用类型表中的信息来对声明、表达式和初始化器进行类型检查。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Defining the Type Table</samp>
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">定义类型表</samp>
- en: The type table maps the structure tags we generated in the previous stage to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp> constructs.
    [Listing 18-17](chapter18.xhtml#list18-17) defines <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表将我们在前一阶段生成的结构体标签映射到 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>
    结构体。[清单 18-17](chapter18.xhtml#list18-17) 定义了 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>。
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-17: An entry in
    the type table</samp>'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-17：类型表中的一个条目</samp>
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp> describes
    a structure type’s alignment, size, and members. We describe each member with
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">member_entry</samp> construct,
    which specifies the member’s name, its type, and its offset in bytes from the
    start of the structure. A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>
    should support two different ways of accessing <samp class="SANS_TheSansMonoCd_W5Regular_11">members</samp>:
    looking up specific members by name and getting the whole list of members in order.
    You might want to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">members</samp>
    as an ordered dictionary if your implementation language supports it.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp> 描述了一个结构体类型的对齐方式、大小和成员。我们通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member_entry</samp> 结构来描述每个成员，该结构指定成员的名称、类型以及它在结构体起始位置的偏移量（以字节为单位）。一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp> 应该支持两种不同的方式来访问
    <samp class="SANS_TheSansMonoCd_W5Regular_11">成员</samp>：按名称查找特定成员和获取成员的整个列表。你可能想将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">成员</samp> 表示为一个有序字典，如果你的实现语言支持的话。
- en: Like the symbol table, the type table should be a global variable or singleton
    that you can easily access from any stage of the compiler. (We’ll pass it explicitly
    in this section’s pseudocode for the sake of clarity.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll see how to add structure definitions to the type table as we traverse
    the AST.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Populating the Type Table</samp>
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When the type checker encounters a definition of a complete structure type,
    it should validate the definition, then convert it into a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>
    and add it to the type table. The type checker can ignore any structure type declaration
    without a member list; a declaration with no member list either declares an incomplete
    type or redeclares a type that was already defined.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: To validate a structure type definition, we’ll start by checking whether this
    structure is in the type table already. If it is, that means there’s another definition
    of the same tag in the same scope, so we’ll throw an error. Then, we’ll make sure
    that no members of the structure share the same name, that no member has an incomplete
    type, and that no member type specifies an array with an incomplete element type.
    (Remember that arrays of incomplete type are illegal everywhere, not just in structure
    definitions.) You might also want to validate that no structure members have function
    type, but it isn’t strictly necessary since we already validated that during parsing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: After validating that a structure type satisfies all these requirements, we’ll
    calculate each member’s offset and the whole structure’s size and alignment. Earlier
    in the chapter, we saw how to perform these calculations and walked through an
    example. Now let’s look at [Listing 18-18](chapter18.xhtml#list18-18), which demonstrates
    the whole process in pseudocode.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-18: Calculating
    a structure definition</samp>'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: We start by checking whether this declaration includes a member list ❶. If it
    doesn’t, we return immediately, without making any changes to the type table.
    If it does have a member list, we validate that it meets the requirements described
    earlier in this section ❷. I won’t give you the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">validate_struct_definition</samp>,
    since it isn’t too complicated.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we get to the interesting part: figuring out each member’s layout in
    memory. Here, we’ll define a <samp class="SANS_TheSansMonoCd_W5Regular_11">member_entry</samp>
    for each structure member ❸. As we go, we’ll maintain a running total of the structure’s
    size in bytes, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp>.
    We’ll also track the strictest member alignment we’ve seen so far as <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_alignment</samp>.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: To calculate a structure member’s offset, we take the next available offset,
    which is given by <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp>,
    and round it up to that member’s alignment ❹. (We’ll walk through how to look
    up each type’s size and alignment in a moment.) We construct its <samp class="SANS_TheSansMonoCd_W5Regular_11">member_entry</samp>
    ❺, then update <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_alignment</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp>.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算结构成员的偏移量，我们采用下一个可用的偏移量，该偏移量由<samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp>给出，并将其四舍五入到该成员的对齐方式❹。（稍后我们将介绍如何查找每个类型的大小和对齐方式。）我们构建其<samp
    class="SANS_TheSansMonoCd_W5Regular_11">member_entry</samp>❺，然后更新<samp class="SANS_TheSansMonoCd_W5Regular_11">struct_alignment</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp>。
- en: Once we’ve processed every member, we calculate the structure’s total size by
    rounding <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp> up to
    the nearest multiple of its alignment ❻. This rounded-up size will account for
    any padding at the end of the structure. Finally, we add the whole <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>
    to the type table ❼.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦处理完每个成员，我们通过将<samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp>四舍五入到其对齐方式的最接近倍数来计算结构的总大小❻。这个四舍五入的大小将考虑到结构末尾的任何填充。最后，我们将整个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>添加到类型表❼。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Handling Structures in Helper
    Functions</samp>
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">在辅助函数中处理结构体</samp>
- en: We’ve centralized a lot of type checking logic into a handful of helper functions,
    including <samp class="SANS_TheSansMonoCd_W5Regular_11">is_scalar</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp>. You’ve probably also
    written a few helper functions to look up each type’s size, alignment, and other
    properties, although I haven’t provided pseudocode for those yet. Now we’ll extend
    these helpers to handle structure types too.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将大量的类型检查逻辑集中到了一些辅助函数中，包括<samp class="SANS_TheSansMonoCd_W5Regular_11">is_scalar</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp>。您可能也编写了几个辅助函数，用于查找每个类型的大小、对齐方式以及其他属性，尽管我还没有为这些提供伪代码。现在我们将扩展这些助手函数，以处理结构类型。
- en: We defined <samp class="SANS_TheSansMonoCd_W5Regular_11">is_scalar</samp> back
    in [Listing 17-12](chapter17.xhtml#list17-12). [Listing 18-19](chapter18.xhtml#list18-19)
    gives the updated definition, with this chapter’s addition bolded.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[清单 17-12](chapter17.xhtml#list17-12)中定义了<samp class="SANS_TheSansMonoCd_W5Regular_11">is_scalar</samp>。[清单
    18-19](chapter18.xhtml#list18-19)给出了更新后的定义，本章新增的部分已加粗。
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-19: Checking whether
    a type is scalar</samp>'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-19：检查一个类型是否是标量</samp>
- en: Structure types aren’t scalar, so this is pretty simple. I’m guessing you’ve
    written similar helper functions to test whether a type is arithmetic, whether
    it’s an integer type, and so on. These will require similarly straightforward
    updates, which we won’t get into here.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 结构类型不是标量类型，因此这部分非常简单。我猜您可能已经编写了类似的辅助函数，用于测试类型是否为算术类型，是否为整数类型等等。这些都需要类似直接的更新，不过我们在这里不再深入探讨。
- en: Updating <samp class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp> is
    slightly more involved; we’ll need to consult the type table. [Listing 18-20](chapter18.xhtml#list18-20)
    gives the new definition of this function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 更新<samp class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp>稍微复杂一些；我们需要查阅类型表。[清单
    18-20](chapter18.xhtml#list18-20)给出了该函数的新定义。
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-20: Checking whether
    a type is complete</samp>'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-20：检查一个类型是否是完整的</samp>
- en: If a structure type is in the type table, it’s complete; if not, it’s incomplete.
    As we saw earlier, a structure type may be incomplete at one point in the program
    but complete later on. During type checking, the type table tells us whether the
    structure type is complete at the current point in the AST. Consider the code
    fragment in [Listing 18-21](chapter18.xhtml#list18-21).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个结构类型在类型表中，则它是完整的；如果不在，则它是不完整的。正如我们之前看到的，结构类型在程序中的某些时刻可能是不完整的，但后来会变得完整。在类型检查期间，类型表告诉我们在当前的抽象语法树（AST）中，结构类型是否完整。请参阅[清单
    18-21](chapter18.xhtml#list18-21)中的代码片段。
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-21: Declaring a
    variable with an incomplete structure type</samp>'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-21：声明一个包含不完整结构类型的变量</samp>
- en: Because the first declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> ❶ doesn’t specify any members, we won’t add it to the type table. Then,
    when we validate the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    t</samp> ❷, we’ll look up <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> in the type table. (Strictly speaking, we’ll look up the unique identifier
    that replaced <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> during the
    identifier resolution stage.) When we don’t find it, we’ll correctly conclude
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> is incomplete
    and throw an error. If the declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    t</samp> appeared after the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> ❸, we’d add <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>
    to the type table before processing <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    t</samp>, so we wouldn’t throw an error.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: We also need helper functions to find a type’s size and alignment. [Listing
    18-22](chapter18.xhtml#list18-22) shows the pseudocode for the <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>
    function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-22: Calculating
    a type’s alignment</samp>'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: To find a structure’s alignment, we’ll look it up in the type table. To find
    an array’s alignment, we’ll recursively calculate the alignment of its element
    type. We’ll hardcode the alignments of other types, which are dictated by the
    ABI. I won’t provide pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>,
    which will look similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*We learned earlier that if a variable of array type is 16 bytes or larger,
    it must be 16-byte aligned. [Listing 18-22](chapter18.xhtml#list18-22) doesn’t
    reflect this requirement because it calculates the alignment of types, not variables.
    You’ll probably want to write a different helper function to calculate the alignment
    of variables, if you haven’t already.*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The other helper functions we defined in earlier chapters should handle structures
    correctly without any changes. Consider <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>,
    which we use to type check assignment expressions and other places where we convert
    a value to a specific type “as if by assignment.” [Listing 18-23](chapter18.xhtml#list18-23)
    reproduces the latest version of this code from [Listing 17-11](chapter17.xhtml#list17-11).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-23: Converting an
    expression to a target type</samp>'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: If we pass <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>
    an expression that already has the correct structure type, it will return the
    expression unchanged. In any other case with a source or target structure type,
    it will fail. That’s the correct behavior, since there’s no way to convert to
    or from a structure type.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>
    一个已经具有正确结构类型的表达式，它将返回原表达式而不做更改。在任何其他具有源或目标结构类型的情况下，它将失败。这是正确的行为，因为没有办法转换到或从结构类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Handling Incomplete Structure
    Types</samp>
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">处理不完整结构类型</samp>
- en: We need to enforce several restrictions on incomplete structure types. First,
    we’ll validate the use of these types in declarations; then, we’ll validate their
    use in expressions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对不完整结构类型施加若干限制。首先，我们将验证这些类型在声明中的使用；然后，我们将验证它们在表达式中的使用。
- en: 'It’s legal to declare, but not define, a function with parameters or a return
    value of incomplete structure type. (Remember that a function definition is a
    function declaration with a body.) If <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> is an incomplete type, the type checker should accept this declaration:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个带有不完整结构类型的参数或返回值的函数是合法的，但定义则不合法。（请记住，函数定义是带有函数体的函数声明。）如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> 是不完整类型，类型检查器应该接受以下声明：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'But it should reject this definition:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但是它应该拒绝这个定义：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Similarly, we’ll accept declarations of variables with incomplete structure
    type but reject any definitions of these variables, including tentative definitions.
    (This is more restrictive than the C standard, which permits tentative definitions
    of variables with incomplete types in certain limited circumstances.) Concretely,
    we’ll accept a variable declaration with an incomplete structure type only if
    it has the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> storage
    class and no initializer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将接受不完整结构类型的变量声明，但拒绝任何这些变量的定义，包括临时定义。（这比 C 标准更严格，C 标准在某些有限的情况下允许不完整类型的变量进行临时定义。）具体来说，只有在变量声明具有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> 存储类并且没有初始化器时，我们才接受不完整结构类型的变量声明。
- en: 'That takes care of declarations; now let’s consider expressions. There’s exactly
    one way to use a variable with incomplete type in an expression. You can take
    its address, as the following example demonstrates:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理了声明的问题；现在让我们考虑表达式。使用不完整类型的变量在表达式中只有一种合法方式。你可以获取它的地址，正如以下示例所演示的：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can then use <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> like
    any other pointer to an incomplete type.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以像使用任何其他不完整类型的指针一样使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>。
- en: 'Similarly, it’s legal (if not especially useful) to dereference a pointer to
    an incomplete structure and then take its address, resulting in the pointer you
    started with:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，解引用指向不完整结构的指针并再取其地址也是合法的（尽管不特别有用），结果是你开始时的指针：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Any other use of an expression with an incomplete structure type is invalid.
    You can’t even cast it to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    or use it as an expression statement, so the type checker should reject both of
    the following statements:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他对不完整结构类型的表达式使用都是无效的。你甚至不能将其转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    或将其作为表达式语句使用，因此类型检查器应该拒绝以下两条语句：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We’ll extend <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    to catch these invalid expressions. [Listing 18-24](chapter18.xhtml#list18-24)
    gives the updated definition of this function, with changes from the original
    definition in [Listing 15-19](chapter15.xhtml#list15-19) bolded.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展 <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    来捕获这些无效的表达式。[清单 18-24](chapter18.xhtml#list18-24) 给出了这个函数的更新定义，原定义中的变化部分在 [清单
    15-19](chapter15.xhtml#list15-19) 中已加粗。
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-24: Rejecting incomplete
    structure types in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">typecheck_and_convert</samp>'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 18-24：在</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">typecheck_and_convert</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">中拒绝不完整结构类型</samp>
- en: 'Remember that <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    processes every expression in the AST except for static initializers (which must
    be constants) and the operands of the <samp class="SANS_TheSansMonoCd_W5Regular_11">SizeOf</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions (which
    don’t undergo array decay). This makes <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    the most convenient place to put the new validation, even though it has nothing
    to do with the function’s original purpose, which is to implicitly convert arrays
    to pointers. With this new validation in place, we’ll handle incomplete types
    correctly in every kind of expression: we’ll permit incomplete structure types
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions, our
    existing validation will reject all incomplete types (including <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>)
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">SizeOf</samp> expressions, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp> will
    reject incomplete structure types everywhere else. Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    still accepts void expressions, which are legal in several places where expressions
    with incomplete structure types are not.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，<samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    处理 AST 中的每个表达式，除了静态初始化器（必须是常量）以及 <samp class="SANS_TheSansMonoCd_W5Regular_11">SizeOf</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> 表达式的操作数（这些表达式不进行数组衰减）。这使得
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp> 成为添加新验证的最便捷位置，尽管这与该函数的原始目的是隐式地将数组转换为指针无关。通过这项新验证，我们将在每种表达式中正确处理不完全类型：我们将允许在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> 表达式中使用不完全结构类型，我们现有的验证会拒绝在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SizeOf</samp> 表达式中使用所有不完全类型（包括 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>），而 <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    会在其他地方拒绝不完全结构类型。请注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    仍然接受 void 表达式，这在一些地方是合法的，而不完全结构类型的表达式则不合法。
- en: We’ve already implemented all the other validation we need for incomplete types.
    For example, we already require the pointer operands in pointer arithmetic expressions
    to point to complete types, and we already require the element types in array
    type specifiers to be complete.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了对不完全类型所需的所有其他验证。例如，我们已经要求指针运算表达式中的指针操作数指向完整类型，并且我们已经要求数组类型说明符中的元素类型必须是完整的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Type Checking the Member Access
    Operators</samp>
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">成员访问运算符的类型检查</samp>
- en: Next, let’s type check the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operators. In both
    cases, we’ll validate the expression, figure out the member type, and record that
    as the type of the whole expression. [Listing 18-25](chapter18.xhtml#list18-25)
    demonstrates how to type check a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    operator.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    运算符。在这两种情况下，我们会验证表达式，找出成员类型，并将其记录为整个表达式的类型。[示例 18-25](chapter18.xhtml#list18-25)
    展示了如何对 <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> 运算符进行类型检查。
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-25: Type checking
    the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operator</samp>'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 18-25：类型检查</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">运算符</samp>
- en: We start by type checking the first operand, <samp class="SANS_TheSansMonoCd_W5Regular_11">structure</samp>,
    with a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    (which throws an error if <samp class="SANS_TheSansMonoCd_W5Regular_11">structure</samp>
    has an incomplete type). Then, we validate that <samp class="SANS_TheSansMonoCd_W5Regular_11">structure</samp>
    really is a structure ❶. If it is, we look up its type in the type table ❷, then
    look up <samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp> in the resulting
    type table entry ❸. Finally, we annotate the expression with the member type ❹.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">structure</samp> isn’t a structure
    or doesn’t have a member with this name, we throw an error.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: I won’t provide pseudocode for type checking the <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    operator, since it’s nearly identical; the only difference is that we validate
    that the first operand is a pointer to a structure, rather than a structure itself.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Validating Lvalues</samp>
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> expression is always
    an lvalue. To determine whether a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    expression is an lvalue, the type checker must recursively check whether its first
    operand is an lvalue. For example, the type checker should reject the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">f().member = 3</samp>. Because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">f()</samp> isn’t an lvalue, <samp class="SANS_TheSansMonoCd_W5Regular_11">f().member</samp>
    isn’t either.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: This means we might encounter arrays that aren’t lvalues! It’s a type error
    to explicitly take the address of such an array, like in [Listing 18-26](chapter18.xhtml#list18-26).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-26: Illegally taking
    the address of a non-lvalue</samp>'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: However, these arrays still decay to pointers, so their addresses are still
    loaded implicitly. The program in [Listing 18-27](chapter18.xhtml#list18-27),
    for example, is entirely legal.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-27: Implicitly converting
    a non-lvalue array to a pointer</samp>'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: When we type check this program, we’ll insert <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    to take the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">f().arr</samp>,
    just like when we type check any other expression of array type.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Type Checking Structures in
    Conditional Expressions</samp>
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The type checker should accept conditional expressions where both branches have
    the same structure type. It should reject conditional expressions where only one
    branch has a structure type or where the branches have two different structure
    types. To determine whether two structure types are identical, compare their tags,
    not their contents.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Type Checking Structure
    Initializers</samp>'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll deal with structure initializers. As you learned earlier in this
    chapter, you can initialize a structure either with a single expression of that
    structure type or with a compound initializer. The first case shouldn’t require
    any changes to the type checker.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: To handle compound initializers, we’ll type check each item in the initializer
    list against the corresponding member type, as [Listing 18-28](chapter18.xhtml#list18-28)
    demonstrates.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-28: Type checking
    compound initializers for structures</samp>'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by looking up the structure in the type table ❶. We should have
    already validated that <samp class="SANS_TheSansMonoCd_W5Regular_11">target_type</samp>
    is complete before calling <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck
    _init</samp>, so at this point it’s safe to assume that the structure has been
    defined. Next, we’ll make sure the initializer list isn’t too long ❷. Just like
    when we process array initializers, we’ll reject an initializer list with too
    many elements but accept one with too few elements to initialize the whole object.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: After performing this check, we’ll iterate through the initializer list ❸. To
    type check each initializer, we’ll look up the corresponding member type in the
    structure’s member list, then call <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp>
    recursively to make sure the initializer is compatible with that type. Finally,
    we’ll pad out any uninitialized structure members with zeros ❹.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve updated <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp>,
    you’ll need to extend <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>
    to handle structure types. To initialize a structure to zero, <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>
    should call itself recursively for each member type and return the results in
    a compound initializer.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Initializing Static Structures</samp>
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If a structure has static storage duration, we’ll store its initial value as
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> list in the
    symbol table, just like we do for arrays. The key difference is that we’ll initialize
    any padding in the structure too. Let’s return to the example from [Listing 18-10](chapter18.xhtml#list18-10):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We figured out that this structure included 4 bytes of padding between <samp
    class="SANS_TheSansMonoCd_W5Regular_11">member1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>
    and 5 bytes of padding after <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> is a static variable,
    we’ll use the construct in [Listing 18-29](chapter18.xhtml#list18-29) to represent
    its initial value.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-29: Representing
    the initializer from [Listing 18-10](chapter18.xhtml#list18-10) as a</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">static_init</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">list</samp>'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: We initialize padding with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    construct ❶❷ because the C standard requires the padding in static structures
    to be initialized to zero. [Listing 18-30](chapter18.xhtml#list18-30) demonstrates
    how to generate static initializer lists like the one in [Listing 18-29](chapter18.xhtml#list18-29).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-30: Generating a
    static initializer for a structure</samp>'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: To process a compound initializer for a static structure, we first look up the
    structure in the type table ❶. We make sure the initializer list isn’t too long,
    just like we did for non-static initializers in <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp>.
    Then, we iterate over the initializer list, looking up the corresponding member
    definition for each element in the structure’s member list. As we go, we update
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">current_offset</samp> variable
    to track how many bytes we’ve initialized so far.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Each time we process the initializer for a structure member, we first check
    whether we’ve initialized enough bytes to bring us up to the expected offset.
    If we haven’t, we add the necessary padding with a <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    initializer ❷. We then create the initializer list for the structure member itself
    with a recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">create_static_init_list</samp>
    ❸. Next, we update <samp class="SANS_TheSansMonoCd_W5Regular_11">current _offset</samp>
    based on the offset and size of the member we just initialized.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve initialized every structure member, we add another <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>,
    if necessary, to pad out the structure to the correct size ❹. This last <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> zeroes out any structure
    members that weren’t explicitly initialized as well as any trailing padding after
    the last member.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Because there are no constants of structure type, initializing a static structure
    with a <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleInit</samp> expression
    is a type error ❺.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we’ll introduce one last TACKY instruction:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This instruction mirrors the <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    instruction we added back in [Chapter 15](chapter15.xhtml). The <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    identifier in <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    is the name of an aggregate variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>
    is the byte offset of a subobject within that variable, and <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    is the variable we’ll copy that subobject to. [Listing 18-31](chapter18.xhtml#list18-31)
    defines the complete TACKY IR, including the new <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    instruction.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-31: Adding</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">CopyFromOffset</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    the TACKY IR</samp>'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Not only can you access subobjects in a structure with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> instructions,
    but you can also copy entire structures from one location to another using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> or pass them between
    functions with <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>, just like scalar
    variables. We’ll represent variables of structure type as ordinary TACKY <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>s.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll convert the member access operators to TACKY. Then, we’ll process
    compound structure initializers. We won’t change how we process most constructs
    that can use structures, like function calls, <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements, and conditional expressions. We also won’t need to do anything with
    the new top-level <samp class="SANS_TheSansMonoCd_W5Regular_11">StructDecl</samp>
    construct; we’ll discard structure declarations at this stage, just like we discard
    function declarations without bodies and variable declarations without initializers.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing the
    Member Access Operators</samp>
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In earlier chapters, you learned that you can use an object in one of three
    ways: you can lvalue convert it, assign to it, or take its address. Now there’s
    a fourth option: if the object is a structure, you can access one of its members.
    And because that structure member is itself an object, you can lvalue convert
    it, assign to it, take its address, or access one of *its* members. Let’s look
    at the TACKY we should generate in each of these cases. Then, building on the
    approach we used to handle dereferenced pointers in [Chapter 14](chapter14.xhtml),
    we’ll introduce a new kind of <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>
    to designate structure members.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Accessing Structure Members
    in TACKY</samp>
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To implement any sort of operation on a structure member, we’ll start by looking
    up the member’s offset in the type table. First, let’s consider cases where the
    structure itself is a TACKY variable, rather than a dereferenced pointer or a
    subobject in some larger structure. To lvalue convert a structure member, we’ll
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> instruction.
    We’ll translate <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><struct></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp>
    to:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We’ll assign to structure members with <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>,
    converting <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><struct></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><right></samp>
    to:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To get a structure member’s address, we’ll first load the address of the object
    that contains it, then add the member’s offset. We’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><struct></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp> to:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: To process a sequence of nested member accesses, we’ll add all their offsets
    together and then issue an instruction depending on how the final member in the
    sequence is used. Consider the structure declarations in [Listing 18-32](chapter18.xhtml#list18-32).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-32: Declaring a
    structure that contains a nested structure</samp>'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'If <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct</samp> is a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct outer</samp> and we need to lvalue
    convert <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct .member2.i</samp>,
    we’ll emit:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> has an
    offset of 4 bytes in <samp class="SANS_TheSansMonoCd_W5Regular_11">struct outer</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> has an offset of 4
    bytes in <samp class="SANS_TheSansMonoCd_W5Regular_11">struct inner</samp>, the
    object designated by <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct.member2.i</samp>
    has a total offset of 8 bytes from the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct</samp>.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s consider how to access structure members through dereferenced
    pointers. The most idiomatic way to do this is with an arrow operator, of the
    form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">-></samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp>.
    This is equivalent to the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(*</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">).</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp>. To implement
    either of these expressions, you’ll add the member offset to the pointer and then
    dereference the result. As with any dereferenced pointer, whether you issue a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction or simply use the pointer’s value will depend on how it’s used. Suppose
    <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_struct_pointer</samp> has
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct inner *</samp>. We’ll
    convert the expression
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'to:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We can implement the equivalent expression
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: with exactly the same instructions. Now that we know what instructions we’d
    like to generate, we’ll update the TACKY generation pass accordingly.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Designating Structure Members
    with SubObject</samp>
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>
    construct to designate a member of an aggregate object. [Listing 18-33](chapter18.xhtml#list18-33)
    gives the updated definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-33: Extending</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp_result</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    represent subobjects</samp>'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">base</samp> argument to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp> is an aggregate object,
    not a pointer. The second argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>,
    is a byte offset into that object. The object that <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>
    designates might be scalar, or it might be an aggregate itself. In [Listing 18-34](chapter18.xhtml#list18-34),
    we use this construct to represent the result of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp>
    operator.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-34: Converting the</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">Dot</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operator
    to TACKY</samp>'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: First, we look up <samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp>’s
    offset in the structure. Then, we process this expression’s first operand without
    lvalue converting it. The resulting object is either a plain TACKY variable, a
    subobject of a TACKY variable, or a dereferenced pointer. (We know the result
    isn’t a constant because TACKY doesn’t have constants of structure type.)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_object</samp> is just
    a variable, we return a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>
    designating the object at <samp class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp>
    within that variable ❶. If <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_object</samp>
    is itself a subobject in some larger variable, we add its offset to <samp class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp>
    ❷. This takes care of nested member operators, like the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct
    .member2.i</samp> that we considered earlier in this section.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if the inner structure is a dereferenced pointer, we access the structure
    member with pointer arithmetic ❸. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(ptr)</samp>
    designates the whole structure, <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    must point to the start of the structure. We add <samp class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> to get a pointer to
    the specified structure member. Then, we dereference this pointer to designate
    the structure member itself.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Processing SubObject</samp>
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, we’ll process <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>
    constructs in lvalue conversions, assignment expressions, and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    expressions. To lvalue convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>,
    we copy it into a new variable with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    instruction, as [Listing 18-35](chapter18.xhtml#list18-35) demonstrates.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-35: Lvalue converting
    a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">SubObject</samp>'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, when a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>
    appears on the left-hand side of an assignment expression, we write to it with
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> instruction,
    as [Listing 18-36](chapter18.xhtml#list18-36) demonstrates.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-36: Assigning to
    a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">SubObject</samp>'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Finally, [Listing 18-37](chapter18.xhtml#list18-37) shows how to calculate the
    address of a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>. We
    load the address of the base object, then add the offset.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-37: Taking the address
    of a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">SubObject</samp>'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: We reuse the same temporary variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>,
    to point to both the base of the structure and its member. We could also generate
    two different temporary variables, but we don’t need to. Because the offset in
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp> construct is
    in bytes, the scale of this <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> ❶.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing the Arrow Operator</samp>
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that we’ve implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp>,
    we can easily implement <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>
    too. To calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr->member</samp>,
    we’ll first evaluate and lvalue convert <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>.
    Then, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> to
    add the offset of <samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp>.
    This will give us a pointer to the designated structure member. Finally, we’ll
    dereference this pointer with a <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>
    construct. I’ll omit the pseudocode for this; you’ve already seen how to convert
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(*ptr).member</samp> to TACKY, and
    converting <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr->member</samp> to
    TACKY is very similar.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need any extra logic to handle the result of an <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>
    expression. This expression will always produce a <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>
    construct, which we already know how to handle.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Omitting Useless AddPtr Instructions</samp>
  id: totrans-295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The first member in a structure always has an offset of zero. As an optional
    optimization, you can skip the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction when calculating this member’s address. This affects [Listings 18-34](chapter18.xhtml#list18-34)
    and [18-37](chapter18.xhtml#list18-37), as well as the implementation of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>, which I didn’t give the
    pseudocode for. In all three cases, you don’t need to generate an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction if <samp class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Compound
    Initializers to TACKY</samp>
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To finish up this section, we’ll convert compound structure initializers to
    TACKY. The basic approach is the same as in previous chapters: we’ll evaluate
    each expression in the initializer list in turn, copying the result of each one
    to the correct offset in the destination with a <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    instruction. But now we’ll need to check the type table to find the correct offset
    for each expression. We’ll also need to calculate the offsets of subobjects deep
    within nested structures, arrays of structures, structures that contain arrays,
    and so on.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 18-38](chapter18.xhtml#list18-38) demonstrates how to track these
    offsets and emit <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    instructions as we traverse a compound initializer for a structure or array.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-38: Converting a
    compound initializer to TACKY</samp>'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: The parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">compound_initializer_to_tacky</samp>
    include <samp class="SANS_TheSansMonoCd_W5Regular_11">var_name</samp> (the name
    of the array or structure variable being initialized), <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>
    (the byte offset of the current subobject within that variable), and <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>
    (the initializer itself). In the top-level call to initialize an entire variable,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp> argument will
    be <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: In the base case, we initialize a subobject with the value of a single expression.
    This expression may be a string literal that initializes an array; I’ve omitted
    the pseudocode for this case, which we covered back in [Chapter 16](chapter16.xhtml).
    Otherwise, we evaluate the expression and copy the result into place with a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> instruction ❶. Even
    if the result has structure type, we can copy it to its destination with a single
    instruction.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: When we encounter a compound initializer for a structure, we look up the structure’s
    member list in the type table. We calculate the offset of each item in the initializer
    list by adding the corresponding member offset to the starting <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>
    argument ❷. Then, we process the item recursively. I won’t talk through the case
    of a compound initializer for an array, since you already know how to handle that.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Our implementation deviates slightly from the C standard here. Under certain
    circumstances, the standard requires padding to be initialized to zero; [Listing
    18-38](chapter18.xhtml#list18-38) doesn’t initialize structure padding, and none
    of our tests check the value of padding in non-static structures.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you know how to convert both member access operators and compound
    structure initializers to TACKY. Once you’ve implemented these conversions, you
    can test out this compiler pass.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Structures in the System V Calling Convention</samp>
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The trickiest part of assembly generation in this chapter is dealing with function
    calls. As always, we need to pass parameters and return values according to the
    System V x64 calling convention. The rules for passing and returning structures
    are particularly gnarly, so we’ll take a look at them before we make any changes
    to the backend.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Classifying Structures</samp>
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the System V x64 ABI, every parameter and return value has a *class*, which
    dictates how it’s transferred during function calls. We’ve already encountered
    two of the classes defined in the ABI, although I didn’t use the term *class*
    to describe them. Values with integer, character, and pointer types all belong
    to the INTEGER class; they’re transferred in general-purpose registers. Values
    with type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> all belong
    to the SSE class; they’re transferred in XMM registers.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll encounter a third class, MEMORY, for large values that
    must be transferred in memory. We’ve passed function arguments in memory before,
    but passing return values in memory is a new concept; we’ll see exactly how that
    works in a moment.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: The ABI presents a somewhat complicated algorithm for classifying structures
    and unions. We can use a simplified version of this algorithm because there are
    a bunch of types that we don’t handle, like <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and unions. We’ll walk through the simplified rules for classifying structures
    in this section. For the complete algorithm, see the documentation listed in “Additional
    Resources” on [page 553](#pg_553).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Splitting a Structure into
    Eightbytes</samp>
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ll assign a separate class to each 8-byte chunk of a structure. The ABI calls
    these chunks *eightbytes*. If the structure’s size isn’t exactly divisible by
    8, the last eightbyte may be shorter than 8 bytes (which makes the term a little
    misleading). Consider [Listing 18-39](chapter18.xhtml#list18-39), which declares
    a 12-byte structure.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-39: A structure
    with two eightbytes</samp>'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: The first eightbyte of this structure contains <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    and the first four elements of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>.
    The second eightbyte is 4 bytes long and contains the last four elements of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>. [Figure 18-2](#fig18-2) shows
    this structure’s layout in memory.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig18-2.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-2: The layout of
    struct twelve_bytes in memory [Description](description-44.xhtml)</samp>'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-2](#fig18-2) illustrates that a nested array like <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>
    can span multiple eightbytes. A nested structure can too. Consider the structure
    declaration in [Listing 18-40](chapter18.xhtml#list18-40).'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-40: A structure
    type containing a nested structure that spans two eightbytes</samp>'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-3](#fig18-3) shows how a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    nested_ints</samp> will be laid out in memory.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig18-3.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-3: The layout of
    struct nested_ints in memory [Description](description-45.xhtml)</samp>'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'The first eightbyte of this structure holds two scalar values: <samp class="SANS_TheSansMonoCd_W5Regular_11">ch1</samp>
    and the nested member <samp class="SANS_TheSansMonoCd_W5Regular_11">nested.i</samp>.
    The second eightbyte holds <samp class="SANS_TheSansMonoCd_W5Regular_11">nested.ch2</samp>.
    When we classify a structure, we care about what scalar values each eightbyte
    contains, but we don’t care how those values are grouped into nested structures
    or arrays. As far as our classification algorithm is concerned, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    nested _ints</samp> is equivalent to the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    flattened_ints</samp> type defined in [Listing 18-41](chapter18.xhtml#list18-41).'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-41: A structure
    with the same layout as</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">struct
    nested_ints</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in memory</samp>'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'This structure looks identical to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    nested_ints</samp> in memory: its first eightbyte holds a <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    and an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, and its second
    eightbyte holds another <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Classifying Eightbytes</samp>
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If a structure is larger than 16 bytes—in other words, if it consists of three
    or more eightbytes—we’ll assign every eightbyte to the MEMORY class. For example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct large</samp> consists of
    four eightbytes, which are all classified as MEMORY:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If a structure is 16 bytes or smaller, we’ll assign each eightbyte to either
    the INTEGER or the SSE class, according to its contents. An eightbyte belongs
    to the SSE class if it contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and the INTEGER class if it contains anything else. For example, both eightbytes
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct twelve_bytes</samp>, from
    [Listing 18-39](chapter18.xhtml#list18-39), belong to the INTEGER class. We’ll
    assign both eightbytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    nested_ints</samp> from [Listing 18-40](chapter18.xhtml#list18-40) and both eightbytes
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct flattened_ints</samp>
    from [Listing 18-41](chapter18.xhtml#list18-41) to the INTEGER class too, since
    none of them hold a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 18-42](chapter18.xhtml#list18-42) defines a few more structure types.
    Let’s classify each of them.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-42: More structure
    types</samp>'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct two_ints</samp> consists
    of a single eightbyte, which belongs to the INTEGER class. A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    nested_double</samp> consists of a single eightbyte in the SSE class. A <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct two_eightbytes</samp> consists
    of two eightbytes: the first is in the SSE class because it contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    and the second is in the INTEGER class because it contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Passing Parameters
    of Structure Type</samp>
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once we’ve classified a structure, we can figure out how to pass it as a parameter.
    If a structure consists of one or two eightbytes, we’ll pass each eightbyte of
    the structure in the next available register for its class. If a structure consists
    of a single eightbyte in the INTEGER class, we’ll pass it in the next general-purpose
    parameter passing register. If it consists of a single eightbyte in the SSE class,
    we’ll pass it in the next available parameter passing XMM register. If it consists
    of one INTEGER eightbyte and one SSE eightbyte, we’ll pass the first eightbyte
    in a general-purpose register and the next eightbyte in an XMM register, and so
    forth. If there aren’t enough registers available to pass the entire structure,
    we’ll push the whole thing onto the stack.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a few examples. First, in [Listing 18-43](chapter18.xhtml#list18-43),
    we reproduce the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct two_eightbytes</samp>
    type that we defined in [Listing 18-42](chapter18.xhtml#list18-42) and declare
    a function that takes a parameter with that type.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-43: A function declaration
    with a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">struct two_eightbytes</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">parameter</samp>'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Suppose <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a variable
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct two_eightbytes</samp>,
    which is stored on the stack at address <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>.
    We might convert the function call <samp class="SANS_TheSansMonoCd_W5Regular_11">pass
    _struct(x)</samp> to the assembly in [Listing 18-44](chapter18.xhtml#list18-44).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-44: Passing a structure
    parameter in two registers</samp>'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Because the first eightbyte of this structure belongs to the SSE class, we pass
    it in the first parameter passing XMM register, XMM0\. The second eightbyte of
    the structure belongs to the INTEGER class, so we pass it in the first general-purpose
    parameter passing register, RDI.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at [Listing 18-45](chapter18.xhtml#list18-45). This listing
    declares a function with a structure parameter that we’ll need to push onto the
    stack.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-45: A function declaration
    with a structure parameter that must be passed in memory</samp>'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: When we call <samp class="SANS_TheSansMonoCd_W5Regular_11">a_bunch_of_arguments</samp>,
    we’ll pass parameters <samp class="SANS_TheSansMonoCd_W5Regular_11">i0</samp>
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">i4</samp> in registers EDI,
    ESI, EDX, ECX, and R8D. This doesn’t leave enough registers open to pass the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">param</samp> parameter; both eightbytes
    belong to the INTEGER class, but only one general-purpose parameter passing register,
    R9, is available. Therefore, we’ll push the whole structure onto the stack. Then,
    since R9D is still open, we’ll use it to transfer <samp class="SANS_TheSansMonoCd_W5Regular_11">i5</samp>.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    two_longs</samp> with static storage duration, we could convert the function call
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: to the assembly in [Listing 18-46](chapter18.xhtml#list18-46).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-46: Passing a structure
    on the stack</samp>'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'Because <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> lives in the
    data section, we access it with RIP-relative addressing. We’re using a bit of
    new assembly syntax here: <samp class="SANS_TheSansMonoCd_W5Regular_11">arg+8(%rip)</samp>
    indicates the address 8 bytes after the label <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>.
    Our first <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instruction
    will therefore push the second eightbyte of the structure, which contains member
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, onto the stack ❶. This
    preserves the structure’s layout in memory, as [Figure 18-4](#fig18-4) demonstrates.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig18-4.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-4: Pushing a structure
    onto the stack [Description](description-46.xhtml)</samp>'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: The two <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp> instructions
    in [Listing 18-46](chapter18.xhtml#list18-46) push a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>
    onto the stack with the correct layout. After the callee sets up its stack frame,
    it can access <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> at <samp
    class="SANS_TheSansMonoCd_W5Regular_11">16(%rbp)</samp>, which is where we always
    expect to find a function’s first stack parameter.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: If a structure belongs to the MEMORY class, we’ll always push it onto the stack.
    Consider the structure type declaration and function declaration in [Listing 18-47](chapter18.xhtml#list18-47).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-47: A function declaration
    with a structure parameter that belongs to the MEMORY class</samp>'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 18-48](chapter18.xhtml#list18-48) demonstrates how to pass a structure
    stored at <samp class="SANS_TheSansMonoCd_W5Regular_11">-32(%rbp)</samp> as an
    argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">accept_struct</samp>.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-48: Passing a structure
    that belongs to the MEMORY class on the stack</samp>'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: In this case, like in [Listing 18-46](chapter18.xhtml#list18-46), we maintain
    the structure’s layout in memory by pushing it onto the stack from back to front.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Returning Structures</samp>
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a structure fits into a single register, returning it is straightforward.
    We’ll return structures that belong to the INTEGER class in RAX and structures
    that belong to the SSE class in XMM0\. If a structure is between 8 and 16 bytes,
    we’ll return it in two registers. To accommodate these structures, we’ll designate
    two more registers to transfer return values: RDX and XMM1\. We’ll transfer each
    eightbyte of a structure in the next available return register of the appropriate
    class. For example, if the first part of a structure belongs to the SSE class
    and the second part belongs to the INTEGER class, we’ll transfer the first part
    in XMM0 and the second part in RAX. If both parts belong to the SSE class, we’ll
    transfer the structure in XMM0 and XMM1; if both parts belong to the INTEGER class,
    we’ll transfer it in RAX and RDX.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Things get even hairier if a structure is in the MEMORY class. In that case,
    the caller allocates space for the return value and passes the address of that
    space to the callee in the RDI register, as if it were the first integer parameter.
    This means the actual first integer parameter must be passed in RSI, the second
    in RDX, and so on. To return a value, the callee copies it into the space pointed
    to by RDI and copies the pointer itself into RAX. Let’s look at the example in
    [Listing 18-49](chapter18.xhtml#list18-49).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-49: Calling function
    that returns a structure in memory</samp>'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">struct large_struct</samp>
    is 24 bytes, we’ll return the result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp>
    function in memory. In <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>,
    we call <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp> and
    assign the result to <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>
    ❶. Assuming <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> has reserved
    stack space for <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>
    at <samp class="SANS_TheSansMonoCd_W5Regular_11">-24(%rbp)</samp>, [Listing 18-50](chapter18.xhtml#list18-50)
    shows how to implement this function call.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-50: Calling</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">return_a_struct</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    assembly</samp>'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: First, we pass the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>,
    which will hold the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp>,
    in RDI. We then pass the argument <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    in the next available parameter passing register, RSI. Finally, we issue a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction. [Figure 18-5](#fig18-5)
    illustrates the program’s state just before the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instruction.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig18-5.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-5: The state of the
    stack and registers before calling return_a_struct [Description](description-47.xhtml)</samp>'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: RSP and RBP point to the top and bottom of the current stack frame, as usual.
    RDI points to <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>,
    which hasn’t been initialized yet. RSI holds the first argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that [Listing 18-50](chapter18.xhtml#list18-50) doesn’t allocate additional
    stack space to hold the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp>;
    it just loads the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>
    variable. That’s typically fine, with one caveat: according to the ABI, the memory
    that will hold the return value “must not overlap any data visible to the callee
    through other names than this argument.” For example, if you needed to implement
    the function call <samp class="SANS_TheSansMonoCd_W5Regular_11">var = foo(1, 2,
    &var)</samp>, it would violate the ABI to pass the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    in RDI as the storage for the return value *and* in RCX as an ordinary argument.
    Instead, you’d need to allocate additional stack space to hold the result of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> and copy the result to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">var</samp> after the function returned.
    We don’t need to worry about this case, since we generate a new variable to hold
    the result of each function call during TACKY generation.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at [Listing 18-51](chapter18.xhtml#list18-51), which implements
    <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp> in assembly.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-51: Returning a
    structure in memory</samp>'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: At the start of the function, we set up the stack frame, allocate stack space
    for the local <samp class="SANS_TheSansMonoCd_W5Regular_11">callee_result</samp>
    variable at <samp class="SANS_TheSansMonoCd_W5Regular_11">-24(%rbp)</samp>, and
    then initialize it. The assembly code to return <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    starts at ❶. First, we copy <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    into the memory location that RDI points to, 8 bytes at a time; we’ll copy the
    first 8 bytes to <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rdi)</samp>,
    the next 8 bytes to <samp class="SANS_TheSansMonoCd_W5Regular_11">8(%rdi)</samp>,
    and the last 8 bytes to <samp class="SANS_TheSansMonoCd_W5Regular_11">16(%rdi)</samp>.
    Then, we copy the pointer to the return value from RDI into RAX ❷. Finally, we
    execute the function epilogue, which is omitted from this listing. [Figure 18-6](#fig18-6)
    illustrates the state of the program just before the function epilogue.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig18-6.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-6: The state of the
    stack and registers just before returning from return_a_struct [Description](description-48.xhtml)</samp>'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp> variable
    in the caller’s stack frame now holds the function’s return value, and RAX holds
    the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>.
    In this example, the RDI register holds that address too, but this isn’t required
    by the ABI.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: We’ve covered everything we need to know about the calling convention for structures.
    Now we’re ready to work on the assembly generation pass!
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This pass will change in a couple of ways. First, we’ll need to generate assembly
    to copy entire structures from one location to another. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> instructions
    can all transfer both scalar and aggregate values. So can the new <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    instruction, which we’ll need to implement. Second, we’ll implement the System
    V calling convention that we just learned about.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by making a few small changes to the assembly AST.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extending the Assembly
    AST</samp>
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Listing 18-46](chapter18.xhtml#list18-46), we used the operand <samp class="SANS_TheSansMonoCd_W5Regular_11">arg+8(%rip)</samp>
    to access data at a constant offset from a RIP-relative label. We’ll often need
    these sorts of operands to access members of structures with static storage duration.
    The assembly AST can already specify constant offsets from most memory addresses,
    but not from RIP-relative addresses. We’ll remove this limitation by adding an
    offset to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operand:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We’ll also introduce two new assembly instructions. First, we’ll add the left-shift
    instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>. This instruction
    takes an immediate value as its source operand and a memory address or register
    as its destination. It shifts its destination left by the number of bits specified
    by its source. For example, the instruction
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: shifts the value in RAX 1 byte to the left, setting its lowest byte to 0\. If
    the value in RAX were <samp class="SANS_TheSansMonoCd_W5Regular_11">0x8</samp>
    before this instruction, it would be <samp class="SANS_TheSansMonoCd_W5Regular_11">0x800</samp>
    afterward. The <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> instruction
    will help us copy irregularly sized structures into registers in order to pass
    them as arguments and return values. Because we can’t directly access every individual
    byte within a register, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>
    to shift each byte into place.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Second, we’ll add the two-operand form of the logical right-shift instruction,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>. (We added the one-operand
    form, which shifts its operand 1 bit to the right, back in [Chapter 13](chapter13.xhtml).)
    Similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>, it shifts
    its destination right by the number of bits its source specifies. It will serve
    a similar purpose to <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>,
    helping us transfer irregularly sized structures *out* of registers and into memory.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The shl instruction also has a one-operand form, which we won’t use; it’s
    the counterpart to the one-operand form of shr that we’re already familiar with.
    Both instructions have yet another form we won’t use, which uses the CL register
    as the source operand.*'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll extend <samp class="SANS_TheSansMonoCd_W5Regular_11">binary_operator</samp>
    to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The new binary <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp> instruction
    gets the rather clunky name <samp class="SANS_TheSansMonoCd_W5Regular_11">ShrTwoOp</samp>
    to distinguish it from the existing unary <samp class="SANS_TheSansMonoCd_W5Regular_11">Shr</samp>
    instruction in the assembly AST.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 18-52](chapter18.xhtml#list18-52) defines the updated assembly AST,
    with these changes bolded.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-52: The assembly
    AST with offsets on static operands and bit shift instructions</samp>'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Converting types and TACKY operands to assembly is pretty simple. Structure
    types, like array types, are converted to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>
    assembly type. To convert a structure type to assembly, you’ll need to look up
    its size and alignment in the type table. We’ll convert TACKY variables of structure
    type to <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> assembly
    operands, just like we do with arrays. We’ll always store arrays and structures
    in memory rather than registers, even once we implement register allocation in
    [Part III](part3.xhtml).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Some of the TACKY variables you encounter may have incomplete structure types.
    (Remember that it’s legal to declare an <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>
    variable with an incomplete type and take its address, but it’s illegal to define
    it or use it in any other way.) Convert these variables to <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operands, like other variables of structure type. You can give these variables
    a dummy assembly type when you add them to the backend symbol table; that dummy
    type will never be used.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    instructions. Then, we’ll deal with function calls.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copying Structures</samp>'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: To copy a structure to a new location, you don’t need to consider its members’
    types or offsets; you just need to copy the right number of bytes. To minimize
    the number of <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions
    required, copy 8 bytes at a time until there are fewer than 8 bytes left to move.
    Then, copy 4 bytes at a time. Finally, when there are fewer than 4 bytes left
    to move, copy 1 byte at a time. (There’s also a 2-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction in x64 assembly, but our assembly AST doesn’t support it.) For example,
    if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    are 20-byte structures, you should translate
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: to the assembly in [Listing 18-53](chapter18.xhtml#list18-53).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-53: Implementing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">Copy</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for
    non-scalar values</samp>'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: The first <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction
    copies the first 8 bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>; the second instruction
    copies the next 8 bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    to the corresponding offset in <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>,
    and the final instruction copies the remaining 4 bytes. These <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instructions are invalid, since their source and destination operands are both
    in memory, but they’ll be rewritten in the instruction fix-up pass.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: You can use the same approach to translate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instructions. For
    example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is a 6-byte
    structure, you’ll translate
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: to [Listing 18-54](chapter18.xhtml#list18-54).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-54: Implementing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">Load</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for
    non-scalar values</samp>'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: The first instruction copies the pointer into the RAX register. Each subsequent
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction copies a
    chunk of data stored at some offset from the address in RAX to the corresponding
    offset in <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: You can also implement <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    for non-scalar values with a sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instructions; the only difference is that you’ll add the specified offset to each
    instruction’s destination. To give another example with the 6-byte structure <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, you’ll translate
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: to [Listing 18-55](chapter18.xhtml#list18-55).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-55: Implementing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">CopyToOffset</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for
    non-scalar values</samp>'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you’ll need to implement the new <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    instruction. Like the other TACKY instructions that copy data, it accepts both
    scalar and non-scalar operands. I won’t talk through this instruction in detail;
    you should handle it basically the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: I recommend writing a helper function, which I’ll call <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes</samp>,
    that generates assembly instructions to copy an arbitrary number of bytes from
    one <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operand to another. You can use this helper function to implement all five of
    the TACKY copying instructions. It will come in handy again when you need to pass
    structures in memory as arguments and return values.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    and extended the other copy instructions to support non-scalar values, you’re
    ready to move on to function calls.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Structures
    in Function Calls</samp>
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since the rules for passing and returning structures are complex, let’s talk
    about our overall strategy before diving into the pseudocode. First, we’ll write
    a function to classify each eightbyte of a structure type. Then, we’ll extend
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp> helper
    function, which we introduced back in [Chapter 13](chapter13.xhtml) to help with
    parameter passing on both the caller and callee sides. Remember that this function
    returns three lists: operands passed in general-purpose registers, operands passed
    in XMM registers, and operands passed on the stack. Once we update this function,
    these lists may include both scalar values and eightbytes of structure values.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll introduce another helper function, <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>,
    to split up return values in a similar way. It will return a list of operands
    returned in general-purpose registers, a list of operands returned in XMM registers,
    and a Boolean flag that indicates whether the return value is passed in memory.
    This flag will be <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> only
    when both lists are empty.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: When <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>
    processes a scalar value, it will return one empty list, one list with a single
    element, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> flag.
    When it processes a structure, it might produce a more interesting result. Its
    main purpose is to massage both scalar and structure return values into the same
    shape, so we can process them in a uniform way.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Once these helpers are in place, we’ll update how we convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    TACKY instruction to assembly. For the most part, we can pass parameters the same
    way as in earlier chapters. We’ll copy each operand we get from <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>
    into the appropriate register or push it onto the stack, without worrying about
    whether it’s a scalar value or part of a structure. Only a few details will change.
    First, we’ll account for the fact that RDI may not be available if it holds the
    address of the space reserved for the return value. We’ll also need to pass irregularly
    sized eightbytes that can’t be transferred with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction. We’ll write a new helper function to move these eightbytes into registers.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the function’s return value will require larger changes. We’ll use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp> to
    learn where we can find each part of the return value, then copy each part from
    the appropriate register or memory address to its final destination. This will
    require yet another helper function to copy irregularly sized eightbytes *out*
    of registers.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll tackle things on the callee side. Here, like on the caller side,
    the way we process parameters will change only slightly, but the way we handle
    return values will change quite a bit. We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>
    again to figure out where to put each part of the return value.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Classifying Structure Types</samp>
  id: totrans-436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ll start with a helper function to classify structure types. We’ll use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp> construct defined in
    [Listing 18-56](chapter18.xhtml#list18-56) to represent the three classes we discussed
    earlier.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-56: The</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">class</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">construct</samp>'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: The classification function will return a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp>
    elements, one for each eightbyte of the structure being classified. To classify
    a structure, we’ll first consider its size and then look at the types of its members.
    [Listing 18-57](chapter18.xhtml#list18-57) gives the pseudocode for this process.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-57: Classifying
    structure types</samp>'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_structure</samp>
    function takes a structure definition from the type table. If the structure is
    larger than 16 bytes, it must be passed in memory, so we return a list of enough
    MEMORY elements to cover the whole structure. For example, if the structure’s
    size is 17 bytes, <samp class="SANS_TheSansMonoCd_W5Regular_11">classify _structure</samp>
    should return <samp class="SANS_TheSansMonoCd_W5Regular_11">[MEMORY, MEMORY, MEMORY]</samp>.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, the structure’s classification depends on its member types. We construct
    a list of every scalar type the structure contains, including the types of nested
    values ❶. Suppose a structure contains two members: an <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp> and a <samp class="SANS_TheSansMonoCd_W5Regular_11">char[3]</samp>. The
    resulting <samp class="SANS_TheSansMonoCd_W5Regular_11">scalar_types</samp> list
    will be <samp class="SANS_TheSansMonoCd_W5Regular_11">[Pointer(Int), Char, Char,
    Char]</samp>.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: If a structure is between 8 and 16 bytes, we return a list of two classes ❷.
    Because a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> has a size
    and alignment of 8 bytes, any <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    that appears in a structure of this size must completely occupy either the first
    or second eightbyte. Taking advantage of this fact, we examine only the first
    and last elements of <samp class="SANS_TheSansMonoCd_W5Regular_11">scalar_type</samp>.
    If the first element is <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>,
    the first eightbyte must be in the SSE class; otherwise, it must be in the INTEGER
    class. Likewise, the second eightbyte is in the SSE class only if the last element
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">scalar_type</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we classify structures that are 8 bytes or smaller. A structure of
    this size belongs to the SSE class if the first (and only) scalar type it contains
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> ❸. Otherwise, it
    belongs to the INTEGER class ❹.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can improve on the code in [Listing 18-57](chapter18.xhtml#list18-57)
    by caching the results. You’ll need to maintain a mapping from structure tags
    to their classifications. The first time you classify a particular structure type,
    add the result to this mapping. Then, if you need to classify that structure type
    again, you can just retrieve the result instead of recomputing it.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Classifying Parameters</samp>
  id: totrans-448
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, we’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>
    function. This function partitions a list of parameters or arguments in three,
    based on whether each one is passed in a general-purpose register, in an XMM register,
    or on the stack. Now, when it processes a value of structure type, it will split
    up the value into eightbytes and add each one to the correct list. [Listing 18-58](chapter18.xhtml#list18-58)
    reproduces the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>
    from [Listing 13-29](chapter13.xhtml#list13-29), with changes bolded.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-58: Extending</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">classify_parameters</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">to support structures</samp>'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: The first change to this function is the new Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">return_in_memory</samp>
    parameter. As the name suggests, this indicates whether the function’s return
    value is passed in memory. If it is, that memory address will be passed in the
    RDI register, leaving one fewer general-purpose register available for other parameters.
    We’ll set <samp class="SANS_TheSansMonoCd_W5Regular_11">int_regs_available</samp>
    accordingly. Then, when we process parameters of integer or pointer type, we’ll
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">int _regs_available</samp>,
    instead of the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>,
    as the number of usable general-purpose registers. (We’ll process parameters of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type exactly the same
    way we did in [Chapter 13](chapter13.xhtml), so I’ve snipped out that bit of the
    listing.)
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ve reached the interesting part: processing parameters of structure
    type. We’ll start with a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_structure</samp>
    ❶. Then, we’ll check whether the first eightbyte of the structure is in the MEMORY
    class ❷. If it is, the rest of the structure must be too. If not, we’ll try to
    assign each eightbyte to a register. We’ll convert each eightbyte to a <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operand ❸, then add it to one of two lists, <samp class="SANS_TheSansMonoCd_W5Regular_11">tentative_doubles</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">tentative_ints</samp>, based
    on its class. We know that <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>
    is a variable, rather than a constant, because there are no aggregate constants
    in TACKY; the name of that variable will be the base of the <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operand.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'When we add an eightbyte to <samp class="SANS_TheSansMonoCd_W5Regular_11">tentative_ints</samp>,
    we need to figure out what assembly type to associate it with. Most eightbytes
    are exactly 8 bytes long, so we associate them with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    type. But the final eightbyte in a structure might be shorter. We’ll find each
    eightbyte’s assembly type using the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp>
    helper function ❹, which we’ll walk through in a moment. This function takes two
    arguments: the eightbyte’s offset and the total size of the structure. It will
    use these to figure out the eightbyte’s size, which dictates its assembly type.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve partitioned the whole structure into two tentative lists, we check
    that we have enough free registers to accommodate both of them ❺. If we do, we
    append both lists to their non-tentative equivalents. If we don’t have enough
    registers available, or if the structure belongs to the MEMORY class, we add each
    eightbyte to <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp> instead
    ❻. We use <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">_type</samp> to determine the type of
    each eightbyte we pass on the stack.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s walk through <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp>,
    defined in [Listing 18-59](chapter18.xhtml#list18-59).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-59: Associating
    an eightbyte with an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">assembly_type</samp>'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: The goal here is to figure out what operand size to use when moving this eightbyte
    into a register or onto the stack. First, we calculate the number of bytes between
    the start of this eightbyte and the end of the whole structure ❶. If there are
    more than 8 bytes left in the structure, this isn’t the last eightbyte, so we
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> type. If
    this eightbyte is exactly 8 bytes, 4 bytes, or 1 byte long, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>
    type, respectively.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the eightbyte’s size is irregular; it’s not a valid operand size
    for assembly instructions. In this case, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>
    type to record the eightbyte’s exact size in bytes ❷. (The alignment in this <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp> is a dummy value; we
    won’t need it later.) We can’t safely transfer an irregularly sized eightbyte
    with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction.
    As you learned in [Chapter 9](chapter9.xhtml), reading past the end of a value
    in memory—by pushing a 4-byte value with an 8-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp>
    instruction, for example—could trigger a memory access violation. By the same
    logic, it’s not safe to transfer a 5-, 6-, or 7-byte operand with an 8-byte <samp
    class="SANS_TheSansMonoCd_W5Regular_11">movq</samp> instruction or a 3-byte operand
    with a 4-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction.
    We’ll look at how to transfer irregularly sized eightbytes in a moment.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp>
    doesn’t consider the eightbyte’s class; it will return <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    for any full-length eightbyte, even if it belongs to the SSE class. This is correct
    because we use <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp>
    only to find the types of values we’re going to transfer in general-purpose registers
    or on the stack. When we push 8 bytes of a structure onto the stack, we don’t
    care whether those bytes contain a floating-point value or an integer.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Classifying Return Values</samp>
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, we’ll write a similar helper function to classify return values. This
    function is simpler than <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>.
    We have one value to deal with, instead of a whole list, so we don’t need to worry
    about running out of registers. We also don’t need to split up the value into
    eightbytes if it will be returned in memory, like we did in <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>.
    [Listing 18-60](chapter18.xhtml#list18-60) shows the pseudocode for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp> helper function.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-60: Classifying
    return values</samp>'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: If the return value is a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    the first of our two lists, which contains operands returned in general-purpose
    registers, will be empty. The second list, which holds operands returned in XMM
    registers, will contain the return value. The flag signaling that the value is
    returned in memory will be <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    ❶. If the return value is some other scalar type, we’ll add it to the list of
    operands returned in general-purpose registers, along with its type. The list
    of operands in XMM registers will be empty, and the flag will still be <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    ❷.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the return value must be a structure. We’ll look up its classes with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_structure</samp>, then
    check whether it belongs to the MEMORY class. If it does, we’ll return two empty
    lists, which indicate that nothing will be returned in registers, and a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp> flag, which indicates that
    the return value will be passed in memory ❸.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: If the structure isn’t in the MEMORY class, it will be returned in registers.
    We’ll convert each eightbyte to a <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operand and add it to either <samp class="SANS_TheSansMonoCd_W5Regular_11">double_retvals</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">int_retvals</samp>, according
    to its class ❹. Here, as in <samp class="SANS_TheSansMonoCd_W5Regular_11">classify
    _parameters</samp>, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp>
    to find the assembly type of each operand in <samp class="SANS_TheSansMonoCd_W5Regular_11">int_retvals</samp>.
    Finally, we’ll return both lists, along with a <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    flag.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing FunCall</samp>
  id: totrans-469
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, let’s update how we implement function calls in assembly. [Listing 18-61](chapter18.xhtml#list18-61)
    reproduces the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_function_call</samp>
    from [Listing 13-31](chapter13.xhtml#list13-31), with changes bolded and some
    unchanged code omitted.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-61: Supporting structures
    in function calls</samp>'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: We start by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>
    (unless the function call doesn’t have a return value because its return type
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>) ❶. If we find that
    the return value will be passed in memory, we convert <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    into an assembly operand, then emit an instruction to load its address into RDI
    ❷. We also increment <samp class="SANS_TheSansMonoCd_W5Regular_11">reg_index</samp>
    so that we’ll pass the first integer argument in RSI instead of RDI.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>,
    passing it the new <samp class="SANS_TheSansMonoCd_W5Regular_11">return_in_memory</samp>
    flag. Then, we adjust the stack pointer (I’ve omitted this step because it’s the
    same as in earlier chapters).
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: We then pass arguments in the general-purpose registers. If an argument has
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp> type, its size
    isn’t exactly 1, 4, or 8 bytes, so transferring it into the register will take
    multiple instructions. We emit those instructions with the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp>
    helper function ❸, which we’ll look at in a moment. If an argument has any other
    type, we transfer it with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instruction, as in earlier chapters. The way we pass arguments in XMM registers
    won’t change, so I’ve snipped out that step.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is passing arguments on the stack. The way we pass operands with
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>
    won’t change. To pass an irregular operand with a <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>
    type, we first need to subtract 8 bytes from RSP to allocate the stack slot for
    that operand ❹. (Remember that the ABI reserves an entire 8-byte stack slot for
    each eightbyte of a structure parameter, even if the actual eightbyte is smaller
    than that.) To copy the operand into that stack slot, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes</samp>
    helper function we’ve already written. Suppose <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is a global variable and its size is 3 bytes. We’ll issue these instructions to
    pass it as an argument on the stack:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: These <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp> instructions
    are invalid, since both operands are in memory; we’ll rewrite them in the instruction
    fix-up pass.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Next, we issue the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instruction and restore the stack pointer to its original location. I’ve snipped
    out these steps because they’re unchanged from earlier chapters.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we copy the return value to the destination. If the return value is
    transferred in memory, we don’t do anything; the callee already copied it for
    us. Otherwise, we iterate over the two lists of destination operands returned
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>—first
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int_dests</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">double_dests</samp>—and
    retrieve each operand from the corresponding register. To retrieve an irregularly
    sized eightbyte from a general-purpose register, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_from_reg</samp>
    helper function ❺, which we’ll define in a moment. This is the counterpart to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp>, which
    we used to pass parameters. We emit a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instruction to retrieve a <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    value from a general-purpose register ❻ or to retrieve a <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>
    value from an XMM register ❼.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: The code to copy the return value to <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    works whether <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> is a structure
    or a scalar object. If it’s a structure, each item in <samp class="SANS_TheSansMonoCd_W5Regular_11">int_dests</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">double _dests</samp> is an eightbyte
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>, which we’ll populate
    from the corresponding return register. If <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    is scalar, either <samp class="SANS_TheSansMonoCd_W5Regular_11">int_dests</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">double_dests</samp> will have
    exactly one element, and the other list will be empty. In that case, this code
    will emit a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction
    to transfer the return value from RAX or XMM0 to its destination.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Transferring Irregular Structures
    in Registers</samp>
  id: totrans-482
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We still need to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_from_reg</samp>,
    which copy irregularly sized eightbytes to and from general-purpose registers.
    This is trickier than copying between two locations in memory, like we do in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes</samp>, because we can’t directly
    access every individual byte in a general-purpose register. We can access a general-purpose
    register’s lowest byte with the appropriate 1-byte alias, like AL or DIL, but
    we can’t access its other bytes individually. (Each register’s second-lowest byte
    also has its own alias—for instance, AH is the second-lowest byte of RAX—but our
    assembly AST doesn’t support these aliases. Even if it did, we still couldn’t
    access the other 6 bytes.)
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use our new bit-shifting instructions to work around this limitation.
    Let’s revisit the 3-byte global variable <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    from our last example. If we need to copy <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    into RDI, we’ll issue the following instructions:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We start by copying the *last* byte of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    into the lowest byte of RDI, whose alias is DIL. Then, we issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>
    instruction to shift RDI 1 byte to the left. This moves the byte we just copied
    into the second-lowest byte of RDI and zeroes out DIL. Next, we copy the middle
    byte of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> into DIL and issue
    another <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> instruction.
    At this point, the last 2 bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    are in the correct place in the register, so we just move the first byte of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> into DIL, and we’re done. [Figure
    18-7](#fig18-7) shows the contents of RDI (in hexadecimal) after each instruction,
    if <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> contains the bytes <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x2</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">0x3</samp>, and RDI’s initial
    value is 0.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig18-7.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-7: Transferring a
    structure into a register a byte at a time [Description](description-49.xhtml)</samp>'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t let the byte ordering here throw you off: because our system is little-endian,
    the least significant (rightmost) byte in RDI corresponds to the lowest memory
    address when we copy the value from RDI into memory, or vice versa. This means—somewhat
    counterintuitively—that shifting a value to the *left* moves each byte to a location
    that corresponds to a *higher* memory address. If, after copying this structure
    into RDI, we issue the instruction'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: then the contents of memory will look like [Figure 18-8](#fig18-8).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig18-8.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-8: The contents of
    memory after copying a structure from a register [Description](description-50.xhtml)</samp>'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: Now the structure is laid out in memory in the correct order. (This <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    instruction also writes 1 byte of memory past the end of the structure, which
    is fine if you aren’t using that byte for anything else. We’ll transfer irregularly
    sized structures in and out of registers 1 byte at a time, but code in other translation
    units that we interact with may transfer them in 4- and 8-byte chunks when it’s
    safe to do so.)
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: That’s the basic idea of <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp>;
    now let’s implement it. [Listing 18-62](chapter18.xhtml#list18-62) gives the pseudocode.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-62: Generating instructions
    to copy bytes from memory into a register</samp>'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'This function copies <samp class="SANS_TheSansMonoCd_W5Regular_11">byte_count</samp>
    bytes from <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp> into <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst_reg</samp>. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp>
    is part of a structure, we can assume it’s a memory operand that accepts an offset,
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>.
    We iterate over the bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp>
    in reverse order: we start at its final byte, with offset <samp class="SANS_TheSansMonoCd_W5Regular_11">byte_count
    - 1</samp>, and end at byte zero. We use a simple helper function, <samp class="SANS_TheSansMonoCd_W5Regular_11">add_offset</samp>,
    to construct the assembly operand for each byte. I won’t give you the pseudocode
    for this function, since it just adds the specified offset to <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp>.
    For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">src _op</samp> is
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem("x", 2)</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">add_offset(src_op, 3)</samp> should return
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem("x", 5)</samp>.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the assembly operand for the current byte, we emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instruction to copy that byte into the destination register. Next, on all but
    the last loop iteration, we emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Shl</samp>
    instruction to shift the whole register left by 8 bits. We then decrement the
    offset and move on to the next byte.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy bytes out of a register, we do the whole thing in reverse. Here’s how
    we would copy 3 bytes from RDI onto the stack at <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: First, we copy the lowest byte of RDI into memory. Then, we shift RDI 1 byte
    to the right, so DIL now contains the second-lowest byte of the structure. We
    repeat this process until we’ve transferred every byte. [Listing 18-63](chapter18.xhtml#list18-63)
    gives the pseudocode to generate these instructions.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-63: Generating instructions
    to copy bytes from a register into memory</samp>'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: As in [Listing 18-62](chapter18.xhtml#list18-62), we can assume that <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_op</samp>
    is a memory operand with an offset. We iterate through the bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_op</samp>
    in order, starting with byte zero. On each iteration, we copy the lowest byte
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">src_reg</samp> into the current
    byte of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_op</samp>. Then, on
    all but the last iteration, we shift <samp class="SANS_TheSansMonoCd_W5Regular_11">src_reg</samp>
    8 bits to the right.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: With these two helper functions, we’ve finished our implementation of function
    calls. Next, we’ll handle the callee side.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Up Function Parameters</samp>
  id: totrans-507
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At the start of a function, we copy every parameter into that function’s stack
    frame. Now we’ll copy parameters of structure type too. The main wrinkle is that
    RDI might hold a pointer to the return value’s destination, instead of an ordinary
    parameter. Let’s revisit <samp class="SANS_TheSansMonoCd_W5Regular_11">set_up_parameters</samp>,
    from [Listing 13-30](chapter13.xhtml#list13-30), and see what’s changed. [Listing
    18-64](chapter18.xhtml#list18-64) gives the new definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">set_up
    _parameters</samp>, with this chapter’s changes bolded.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-64: Copying function
    parameters to the stack</samp>'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: We’ve added a <samp class="SANS_TheSansMonoCd_W5Regular_11">return_in_memory</samp>
    flag, which we’ll pass through to <samp class="SANS_TheSansMonoCd_W5Regular_11">classify
    _parameters</samp>. This flag also dictates how we’ll handle the value in RDI.
    If RDI points to the return value’s destination, we’ll copy it to the first open
    slot on the stack, <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>;
    we’ll retrieve it from this slot when we need to return a value. (In the next
    section, we’ll update the pseudo-operand replacement pass so it doesn’t clobber
    this pointer by assigning a local variable to the same spot.) In this case, we’ll
    also increment <samp class="SANS_TheSansMonoCd_W5Regular_11">reg_index</samp>,
    just like we did when we passed arguments in [Listing 18-61](chapter18.xhtml#list18-61),
    so that we’ll look for ordinary parameters starting in RSI instead of RDI.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: To copy irregularly sized operands out of registers, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy
    _bytes_from_reg</samp> helper function from [Listing 18-63](chapter18.xhtml#list18-63).
    To copy irregularly sized operands that were passed on the stack, we’ll use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes</samp> helper function.
    If an operand has type <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>, we’ll copy it
    into place with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instruction, regardless of whether it represents a scalar value or a chunk of
    a structure.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing Return</samp>
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 18-65](chapter18.xhtml#list18-65) illustrates how to convert the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction to assembly.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-65: Implementing
    the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Return</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">instruction</samp>'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the function returns a value, rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    we start by classifying that value. Then, we check whether we need to return it
    in memory or in registers. To return it in memory, we first retrieve the pointer
    to the destination from <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>.
    We copy that pointer into RAX, as the System V calling convention requires ❶.
    Then, we copy the return value into the block of memory that RAX points to. We
    perform this copy using the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy
    _bytes</samp> helper function ❷.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: If the return value is passed in one or more registers, we iterate through the
    operands in <samp class="SANS_TheSansMonoCd_W5Regular_11">int_retvals</samp>,
    copying each one into the corresponding general-purpose register ❸. We then iterate
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">double_retvals</samp>, copying
    these values into XMM0 and XMM1 ❹. Once we’ve copied every part of the return
    value to the correct location, we emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp>
    instruction.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Tracking Which Functions Pass
    Return Values in Memory</samp>
  id: totrans-519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Finally, we’ll extend the backend symbol table to track which functions return
    values in memory. [Listing 18-66](chapter18.xhtml#list18-66) shows how to update
    our definition of a backend symbol table entry.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-66: The updated
    definition of an entry in the backend symbol table</samp>'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: As you’d expect, we’ll set <samp class="SANS_TheSansMonoCd_W5Regular_11">return_on_stack</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> if a function passes
    its return value on the stack and <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    if it passes its return value in registers or returns <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
    The pseudo-operand replacement pass will use this flag to figure out if the quadword
    starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp> is available
    or if it holds the pointer to the memory where the return value will be passed.
    If a function has an incomplete return type other than <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    (which can happen if it’s declared but never defined or called), the <samp class="SANS_TheSansMonoCd_W5Regular_11">return_on_stack</samp>
    flag will never be used, so we can just set it to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Putting It All Together</samp>
  id: totrans-524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve now covered all the pieces of assembly generation! [Tables 18-1](chapter18.xhtml#tab18-1)
    through [18-4](chapter18.xhtml#tab18-4) summarize the latest updates to the conversion
    from TACKY to assembly; as usual, new constructs and changes to the conversions
    for existing constructs are bolded. [Appendix B](appendix-B.xhtml) includes the
    complete conversion from TACKY to assembly for this chapter, since this is the
    final chapter in [Part II](part2.xhtml).
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 18-1:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Top-Level TACKY Constructs to Assembly</samp>
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '| <samp class="SANS_Futura_Std_Book_11">Return value in registers'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: or no return
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: value</samp> |
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '|'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">Return value on stack</samp>
    |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
- en: '[PRE111]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '|'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 18-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Return on stack</samp> |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
- en: '[PRE112]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '|'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">Return in registers</samp> |'
  id: totrans-545
  prefs: []
  type: TYPE_TB
- en: '[PRE113]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '|'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_Futura_Std_Book_11">No return value</samp> |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
- en: '[PRE114]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '|'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '|  |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
- en: '[PRE116]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '|'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '| <samp class="SANS_Futura_Std_Book_11">Scalar</samp> |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
- en: '[PRE118]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '|'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Structure</samp> |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
- en: '[PRE119]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '|'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '| <samp class="SANS_Futura_Std_Book_11">Scalar</samp> |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
- en: '[PRE121]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '|'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Structure</samp> |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
- en: '[PRE122]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '|'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '| <samp class="SANS_Futura_Std_Book_11">Scalar</samp> |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
- en: '[PRE124]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '|'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Structure</samp> |'
  id: totrans-577
  prefs: []
  type: TYPE_TB
- en: '[PRE125]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '|'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '|'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '|'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '|'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">src</samp> <samp class="SANS_Futura_Std_Heavy_B_11">is
    a structure</samp> |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
- en: '[PRE129]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '|'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst is scalar</samp> |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
- en: '[PRE131]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '|'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst is a structure</samp> |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
- en: '[PRE132]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '|'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst will be'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: returned
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: in
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: memory</samp> |
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '|'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst will be'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: returned
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: in
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: registers</samp> |
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '|'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> <samp class="SANS_Futura_Std_Book_11">is
    absent</samp> |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
- en: '[PRE136]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '|'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '|'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '|'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '|'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '|'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '|'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
- en: '[PRE142]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '|'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '|'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 18-3:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Operands to Assembly</samp>
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operand</samp> |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '|'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '|'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 18-4:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Types to Assembly</samp>
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp> |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-642
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Structure(tag)</samp> |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
- en: '[PRE146]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Alignment from type table</samp>
    |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
- en: Note that we now include offsets on every <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operand we generate. The only <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operands at this point represent floating-point constants; these include the constants
    we use in the conversions for floating-point <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp> in [Table
    18-2](chapter18.xhtml#tab18-2) and ordinary floating-point TACKY constants in
    [Table 18-3](chapter18.xhtml#tab18-3). These operands all have an offset of zero.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudo-operands</samp>
  id: totrans-647
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll make two small changes to this pass. First, we’ll supply offsets for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operands. For example, if
    <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp> is a static variable, we’ll
    convert
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: to
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: and
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'to:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Second, we need to avoid clobbering the return value pointer in <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>.
    Before we start allocating stack space, we’ll check the backend symbol table to
    see whether the function’s return value will be passed in memory. If it will,
    we’ll reserve the quadword starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>
    for the return value pointer and allocate space for pseudoregisters only at addresses
    lower than <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>. For
    example, if the first pseudoregister we encounter is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>,
    we’ll map it to <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: The instruction fix-up pass won’t change in this chapter. The <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp> instructions we emit
    during code generation are already valid and don’t need to be fixed up, since
    the destination operand is always a register and the source operand is always
    the immediate value <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  id: totrans-658
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code emission pass requires two small changes. First, we’ll include the
    offsets on <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operands.
    For example, we’ll emit <samp class="SANS_TheSansMonoCd_W5Regular_11">Data("x",
    4)</samp> as:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: If the offset is zero, you can either include it or omit it.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: Second, we’ll emit the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Shl</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ShrTwoOp</samp> assembly instructions
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>,
    respectively. These take the usual operand size suffixes.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '[Tables 18-5](chapter18.xhtml#tab18-5) and [18-6](chapter18.xhtml#tab18-6)
    show these changes to the code emission pass. [Appendix B](appendix-B.xhtml) includes
    the complete code emission pass for this chapter, since this is the final chapter
    of [Part II](part2.xhtml).'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 18-5:</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    Names for Assembly Operators</samp>
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operator</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Instruction name</samp> |'
  id: totrans-665
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-666
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Shl</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">shl</samp>
    |'
  id: totrans-667
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ShrTwoOp</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">shr</samp>
    |'
  id: totrans-668
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 18-6:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Data(identifier</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">, int</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><identifier></samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">+</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><int></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(%rip)</samp> |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
- en: And with that, you’re done with the chapter; your compiler now supports structures!
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: Unions</samp>'
  id: totrans-674
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Structure and union types have a lot in common. Their type declarations share
    the same syntax and declare tags in the same namespace. They follow the same typing
    rules and support the same operations, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> operators. The difference
    is that the members of a structure are laid out sequentially in memory, whereas
    the members of a union all start at the same address, such that writing to one
    overwrites the others. From the compiler’s perspective, a union is basically a
    structure where every member’s offset is zero. This makes it relatively straightforward
    to extend the work you did in this chapter to support unions too. Still, this
    is a bigger challenge than previous extra credit features. It’s an opportunity
    to add a new language feature on your own.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: If you implement union types, there are a few points you should keep in mind.
    First, remember that we restricted where structures can be declared to make compilation
    easier. The test cases for unions also follow the same restrictions; that means
    you don’t need to support anonymous union declarations or union declarations that
    are part of declarations of some other type or variable.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: In the type checker, you’ll add union definitions to the type table. Structure
    and union tags share a namespace, so defining a structure and a union type with
    the same tag in the same scope is an error. You’ll need to track each union’s
    size and alignment (you can look up how to calculate these in the System V ABI).
    You’ll also need to type check compound initializers for unions. A union initializer
    should have a single element, which initializes the union’s first member. (C provides
    syntax to specify which union member to initialize, but you don’t have to implement
    it.)
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: On the backend, the System V calling convention treats unions similarly to structures;
    a union will be passed in memory, in two registers, or in one register, depending
    on its size and the types of its members. For all the gory details, see the links
    in “Additional Resources.” Good luck!
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--union</samp>
    flag to test your compiler’s support for union types:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Or, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>
    flag to test every extra credit feature.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve finished [Part II](part2.xhtml)! In this chapter, you learned how to
    analyze structure type declarations, manipulate aggregate objects in TACKY, and
    transfer structures according to the System V calling convention. Your compiler
    now supports every language feature this book covers, including most of the statements,
    expressions, and types in the C language. You can officially tell people that
    you’ve written a C compiler.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can stop here. Or, you can move on to [Part III](part3.xhtml),
    where you’ll implement several compiler optimizations to generate more efficient
    assembly code. In [Chapter 19](chapter19.xhtml), you’ll optimize TACKY programs
    by eliminating useless instructions and evaluating constant expressions at compile
    time. In [Chapter 20](chapter20.xhtml), you’ll write a register allocator, which
    maps pseudoregisters to hardware registers instead of locations on the stack.
    These optimizations aren’t specific to C or x64 assembly; you’ll find them in
    compilers with lots of different source and target languages.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>
  id: totrans-685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to learn about the complete System V x64 calling convention, including
    all the rules for passing structures and unions, you have a couple of options:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: The official System V x86-64 ABI is available at *[https://<wbr>gitlab<wbr>.com<wbr>/x86<wbr>-psABIs<wbr>/x86<wbr>-64<wbr>-ABI](https://gitlab.com/x86-psABIs/x86-64-ABI)*.
    (I’ve linked to this a couple of times already.) Section 3.2.3 discusses parameter
    passing.
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agner Fog has written a helpful manual describing the calling conventions of
    different C++ compilers (*[https://<wbr>www<wbr>.agner<wbr>.org<wbr>/optimize<wbr>/calling<wbr>_conventions<wbr>.pdf](https://www.agner.org/optimize/calling_conventions.pdf)*).
    Tables 6 and 7, in Section 7.1, cover how structures are passed and returned.
    The document covers C++, so parts of it aren’t relevant, but the description of
    how to pass plain structures and unions applies to C as well as C++.
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I found Fog’s summary of calling conventions easier to follow than the official
    ABI. If you decide to implement unions for extra credit, you’ll probably need
    to refer to both documents.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
