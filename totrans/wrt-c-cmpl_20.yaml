- en: '![](../images/pg484.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-42.xhtml)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">18</samp> <samp class="SANS_Dogma_OT_Bold_B_11">STRUCTURES</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, you’ll add one final language feature: structures. You’ll
    also implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operators to access structure
    members. In a fitting end to [Part II](part2.xhtml), you’ll draw on many of the
    skills, concepts, and techniques you learned in earlier chapters. In the identifier
    resolution stage, you’ll resolve structure tags along with function and variable
    identifiers. In the type checker, you’ll record structure definitions in a type
    table, much like you already record function and variable declarations in the
    symbol table. During TACKY generation, you’ll build on the strategy you used in
    [Chapter 14](chapter14.xhtml) to handle operations on dereferenced pointers and
    other objects. And on the backend, you’ll implement the part of the System V calling
    convention that specifies how to pass structures as function parameters and return
    values. Since unions are a close cousin to structures, you might want to implement
    those too. We won’t cover them in detail, but you can add them as an extra credit
    feature.'
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Declaring Structure Types</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You have to declare a structure type before you can use it. There are two kinds
    of structure type declarations. The first, shown in [Listing 18-1](chapter18.xhtml#list18-1),
    specifies the structure’s members.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-1: A complete structure
    type declaration</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This listing declares a complete structure type with two members: a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. The identifier
    <samp class="SANS_TheSansMonoCd_W5Regular_11">complete_struct</samp> is this type’s
    *tag*, which we can use to specify the type later in the program. A complete structure
    type must have at least one member, so it’s illegal to declare a structure type
    with an empty member list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The second kind of structure type declaration, shown in [Listing 18-2](chapter18.xhtml#list18-2),
    specifies a structure’s tag but not its members.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-2: An incomplete
    structure type declaration</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 18-2](chapter18.xhtml#list18-2) declares an incomplete structure type.
    As you learned in the previous chapter, you can use incomplete types only in certain
    limited circumstances. For example, you can’t define a variable of type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct incomplete_struct</samp>, but you
    can define a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    incomplete_struct</samp>. (That’s because we know how much memory a pointer requires,
    but not how much memory this structure requires.) We’ll say that a structure declaration
    with no member list *declares* a type, while a structure declaration with a member
    list both *declares* and *defines* a type. This differs from the terminology you’ll
    see in the C standard and elsewhere; in particular, when people talk about “type
    definitions,” they usually mean aliases introduced with the <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: Structure tags are visible only in the scope in which they’re declared, just
    like function and variable names. If a structure tag is declared at file scope,
    it’s visible from the point where it’s declared until the end of the file. If
    it’s declared at block scope, it’s visible until the end of the block. If two
    structure type declarations with the same tag appear in the same scope, they always
    declare the same type; if they appear in different scopes, they declare distinct
    types. (Type declarations don’t have linkage, so you can’t apply the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> keywords to them.)
    You can declare the same structure type multiple times, but you can’t define it
    more than once.
  prefs: []
  type: TYPE_NORMAL
- en: A structure type is complete once its definition is in scope, as [Listing 18-3](chapter18.xhtml#list18-3)
    illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-3: Declaring an
    incomplete type and then completing it</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Between ❶ and ❷, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>
    is an incomplete type. It wouldn’t be legal to define a variable with type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> between these two points
    in the program, but it’s legal to define <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>,
    which is a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>.
    After the end of the type declaration that specifies its member list ❷, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> is a complete type, so
    it’s legal to define a variable with that type ❸.
  prefs: []
  type: TYPE_NORMAL
- en: When the same structure tag is declared in two different scopes, one can shadow
    the other, as [Listing 18-4](chapter18.xhtml#list18-4) illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-4: One structure
    type shadowing another</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>
    type at file scope ❶. Its size is 4 bytes because it contains a single <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    The first <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expression
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> refers to this type
    ❷. Then, we define another <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> type at block scope ❸, shadowing the first type. This type contains a
    single <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, so its size
    is 8 bytes. The two definitions of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> don’t conflict, because they appear in different scopes. In the second
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expression ❹, the
    specifier <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> refers
    to the 8-byte structure type defined in the inner scope. Running this program
    gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Even when a structure’s tag is shadowed, its members are still visible. Consider
    [Listing 18-5](chapter18.xhtml#list18-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-5: Using a variable
    with a shadowed structure type</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, we first declare a structure type, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    shadow</samp> ❶. Then, we define a variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">outer</samp>,
    with that type. In the inner scope, we declare another structure type with the
    same tag ❷, which shadows the outer declaration. We then declare a variable with
    this new type, <samp class="SANS_TheSansMonoCd_W5Regular_11">inner</samp>. In
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement, we
    can still access the members of both variables ❸. Even in the inner scope, the
    compiler knows about the original <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    shadow</samp> type, and it still knows that <samp class="SANS_TheSansMonoCd_W5Regular_11">outer</samp>
    belongs to that type; we just can’t specify that type with the <samp class="SANS_TheSansMonoCd_W5Regular_11">shadow</samp>
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep all our structure types straight, we’ll treat structure tags a lot
    like variable names: in the identifier resolution pass, we’ll replace each user-defined
    tag with a unique identifier.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Structure Member
    Declarations</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The members of a structure can have any complete type, including primitive types
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and derived types
    like arrays, pointers, or other structures. It’s illegal to declare a structure
    member with an incomplete type, however, because that makes it impossible to determine
    the size of the whole structure. This implies, as section 6.7.2.1, paragraph 3,
    of the C standard puts it, that “a structure shall not contain an instance of
    itself.” That is, a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>
    can’t contain a member of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp>. On the other hand, a structure can contain a pointer to itself because
    pointer types are always complete. The canonical example, shown in [Listing 18-6](chapter18.xhtml#list18-6),
    is a node in a linked list, which holds a value and a pointer to the next list
    entry.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-6: A structure type
    definition that contains a pointer to itself</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: After ❶, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct linked_list_node</samp>
    is visible as an incomplete type, so we can declare the member <samp class="SANS_TheSansMonoCd_W5Regular_11">next</samp>
    as a pointer to this type. After ❷, the type is complete.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also illegal to declare functions as structure members. A structure can
    hold function pointers—which are complete types, just like any other pointer—but
    we don’t support function pointers, so that doesn’t matter to us.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tag and Member Namespaces</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Structure tags are in a different namespace from functions and variables. This
    means the same identifier can be used as both a tag and a function or variable
    name, and neither identifier will shadow or conflict with the other. It’s perfectly
    legal, for example, to declare the type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> and a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    in the same scope. It’s possible to maintain these separate namespaces because
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> keyword tells
    the compiler that a particular identifier is a structure tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, each structure member list is its own namespace. A structure member
    can share a name with any function, variable, or structure type, including the
    structure type that contains it, like in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s also legal for members in different structures to have the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When the identifier <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> appears
    in an expression, like <samp class="SANS_TheSansMonoCd_W5Regular_11">var->x</samp>,
    the compiler can figure out from context whether it refers to the member in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">s1</samp>, the member in <samp class="SANS_TheSansMonoCd_W5Regular_11">s2</samp>,
    or a function or variable. Unsurprisingly, it’s illegal for two members of the
    same structure to share a name.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Structure Type Declarations
    We Aren’t Implementing</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: C syntax doesn’t distinguish between structure type specifiers and type declarations,
    so you can simultaneously declare a new structure type and use that structure
    type in some larger construct. In [Listing 18-7](chapter18.xhtml#list18-7), for
    example, a single declaration defines a new structure type, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp>, and a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-7: Defining and
    specifying a structure type in the same declaration</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify parsing and semantic analysis, we’ll require every declaration
    to declare exactly one function, variable, or type. We won’t support declarations
    like [Listing 18-7](chapter18.xhtml#list18-7) that declare a new type and some
    other entity at the same time. This goes for incomplete types as well. The C standard
    lets you implicitly declare an incomplete structure type, just by specifying it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> hasn’t
    yet been declared, this declaration is legal: it simultaneously declares <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> as an incomplete type
    and declares a function that returns a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp>. However, our implementation won’t permit this. Instead, we’ll require
    a separate declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Requiring types to be declared before they’re used also implies that you can’t
    nest one structure declaration inside another, like in [Listing 18-8](chapter18.xhtml#list18-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-8: Declaring an</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">inner</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">structure
    type and declaring member</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">i</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">with that type in the same declaration</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll impose a few other restrictions too. We’ll reject structure declarations
    without tags and structure members without names, even though the C standard permits
    them. We also won’t support *bit-field members*, which make it possible to address
    individual bits within a structure.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Operating on Structures</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can access the members of a structure with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a pointer to a structure, you can access the structure’s members
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operator. Continuing
    with the same example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can apply the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operators only to complete
    structure types. You can’t access the members of an incomplete structure type,
    since those members haven’t been defined yet.
  prefs: []
  type: TYPE_NORMAL
- en: Structures are aggregate types, like arrays. But structures don’t decay to pointers
    like arrays do, so you can use them in several ways that you can’t use arrays.
    For example, you can pass them as function arguments and return values. You can
    also assign to them, like in [Listing 18-9](chapter18.xhtml#list18-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-9: Assigning to
    a structure</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can assign to individual members of a structure too, as long as they’re
    lvalues. A structure member specified with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    operator is always an lvalue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Recall that all dereferenced pointers are lvalues. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    operator produces a dereferenced pointer, much like the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp> operators do, so the
    same rules apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a structure is an lvalue, any members you access with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    operator are lvalues too. If a structure isn’t an lvalue, neither are its members.
    Therefore, this assignment expression is legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'But, because the result of a function call isn’t an lvalue, this is illegal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Structures can appear in a few other expressions, pretty much where you’d expect.
    They can appear in the branches of conditional expressions, as long as both branches
    have the same structure type. You can get their size with <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    and cast them to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, but
    you can’t otherwise cast to or from structure types. And if a structure or structure
    member is an lvalue, you can take its address.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to initialize a structure. You can initialize it with an
    expression of the same structure type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Or, you can use a compound initializer to initialize each member individually,
    like in [Listing 18-10](chapter18.xhtml#list18-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-10: Initializing
    a structure with a compound initializer</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A compound initializer initializes a structure’s members in order. The initializer
    in [Listing 18-10](chapter18.xhtml#list18-10) initializes <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp>
    with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">2.0</samp>.
    The inner compound initializer initializes the three array elements in <samp class="SANS_TheSansMonoCd_W5Regular_11">array_member</samp>
    ❶. Note that compound initializers for arrays and structures have identical syntax.
    (The syntax for *designated initializers*, which initialize specific subobjects
    in an aggregate object, is different for array elements and structure members,
    but we won’t implement designated initializers.) By nesting compound initializers,
    you can initialize arrays of structures, structures that contain other structures,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Structure Layout in Memory</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, we have a pretty good sense of how structure types work in source
    code. Now let’s look at how they’re laid out in memory at runtime. This is specified
    partly by the C standard and partly by the System V ABI. It’s important to lay
    out structures exactly as the ABI specifies so that the code we compile can interoperate
    with other code that uses structures.
  prefs: []
  type: TYPE_NORMAL
- en: A structure’s members appear in the same order in memory as in the original
    structure declaration. The first member must have the same address as the structure
    as a whole; you can always convert a pointer to a structure into a pointer to
    its first member, and vice versa. Each subsequent member will be stored at the
    earliest free address with the correct alignment. Let’s use the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    example</samp> type from [Listing 18-10](chapter18.xhtml#list18-10) as an example.
    [Listing 18-11](chapter18.xhtml#list18-11) reproduces the definition of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct example</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-11: A structure
    type with several members with different alignments</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first member must start at the very beginning of the structure. Because
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp> is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    it occupies the structure’s first 4 bytes. Bytes in a structure are typically
    zero-indexed, so we’ll say that <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp>
    occupies bytes 0 through 3\. The next unused space is therefore at byte 4\. But
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    which is 8-byte aligned; its starting address must be a multiple of 8\. Therefore,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> will be stored in
    bytes 8 through 15\. We say that <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>
    has an offset of 8 bytes from the start of the structure. Between <samp class="SANS_TheSansMonoCd_W5Regular_11">member1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>, in bytes 4 through
    7, we have 4 bytes of padding.
  prefs: []
  type: TYPE_NORMAL
- en: The last member, <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>,
    takes up 3 bytes and has an alignment of 1 byte. Since we don’t need any padding
    to align it correctly, we’ll store it right after <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>,
    in bytes 16 through 18.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also need padding at the end of the structure, after <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>.
    According to the System V ABI, the size of a type must be a multiple of its alignment.
    The ABI also states that a structure takes on the same alignment as its most strictly
    aligned member. The most strictly aligned member of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    example</samp> is the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>. Therefore, the whole
    structure must be 8-byte aligned, and its size must be a multiple of 8\. The three
    members of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct example</samp>
    and the padding between them occupy 19 bytes. We’ll add 5 bytes of padding to
    the end of the structure, bringing its total size to 24 bytes. [Figure 18-1](#fig18-1)
    illustrates the layout of the whole structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig18-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-1: The structure
    layout in memory [Description](description-43.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The padding between members guarantees that each member will end up at a correctly
    aligned memory address. If the starting address of the entire structure is a multiple
    of 8 and the offset of <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>
    from the start is also a multiple of 8, we know that <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>’s
    runtime memory address will be a multiple of 8 too. The padding at the end of
    the structure guarantees that each element in an array of structures will have
    the correct alignment; if the initial element in an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    example</samp> objects is 8-byte aligned and its total size is 24 bytes, each
    subsequent element will be 8-byte aligned as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how to work with structures in C and how they’re laid
    out in memory, let’s get to work on implementing them.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll add three new tokens in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">struct</samp> | A keyword indicating
    a structure type specifier |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">.</samp> | A period, the structure
    member access operator |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-></samp> | An arrow, the operator
    to access a structure member through a pointer |'
  prefs: []
  type: TYPE_TB
- en: Keep in mind that a period can be either a structure member access operator
    or part of a floating-point constant. We’ll recognize a period as a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    token only if it’s followed by a non-digit character. If a period is followed
    by a digit, either it’s the start of a floating-point constant or it’s invalid.
    For example, if the lexer sees the input <samp class="SANS_TheSansMonoCd_W5Regular_11">.100u</samp>,
    it should try to parse this as a constant. It will then raise an error, since
    this doesn’t match the regular expression for any kind of constant. It should
    *not* lex this as a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> token
    followed by the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">100u</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll add several new constructs to the AST in this chapter: structure declarations,
    structure type specifiers, and the two new structure operators. [Listing 18-12](chapter18.xhtml#list18-12)
    gives the AST definition for structure declarations.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-12: Representing
    structure declarations in the AST</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_declaration</samp> consists
    of a tag and a list of members. To represent an incomplete structure type declaration,
    we’ll leave the member list empty. (Remember that a complete structure type must
    have at least one member.) We’ll represent each member with a <samp class="SANS_TheSansMonoCd_W5Regular_11">member_declaration</samp>,
    which includes a member name and a type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp>
    AST node to support structure type declarations as well as function and variable
    declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    AST node to include structure type specifiers like <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we’ll add two new expressions: the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operators, sometimes
    called the *structure member operator* and *structure pointer operator*, respectively.
    We’ll use the more concise names <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Each of these operators takes an expression as its first operand and the name
    of a structure member as its second operand. [Listing 18-13](chapter18.xhtml#list18-13)
    defines the complete AST, with this chapter’s changes bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-13: The abstract
    syntax tree with structure types and the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">-></samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">operators</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 18-14](chapter18.xhtml#list18-14) shows the corresponding changes
    to the grammar.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-14: The grammar
    with structure types and the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">-></samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">operators</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11"><struct-declaration></samp>
    may include a brace-enclosed list of structure members ❶. This member list is
    optional, but if the braces are present they must contain at least one member.
  prefs: []
  type: TYPE_NORMAL
- en: 'A structure member declaration has the same form as a variable declaration;
    it includes a list of type specifiers and a declarator and ends with a semicolon.
    Unlike a variable declaration, however, a structure member can’t have an initializer
    or a storage class. We’ll impose one syntactic requirement that isn’t reflected
    in the grammar: the parser should reject function declarators in structure member
    declarations, even though the <samp class="SANS_TheSansMonoCd_W5Regular_11"><member
    -declaration></samp> grammar rule allows them. For example, the parser should
    reject this declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A structure type specifier consists of two tokens: the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    keyword and an identifier token, which specifies the structure tag. This specifier
    can’t be combined with other type specifiers, but it can be modified by a pointer,
    array, or function declarator.'
  prefs: []
  type: TYPE_NORMAL
- en: The new <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    operators are postfix operators, like the subscript operator we added in [Chapter
    15](chapter15.xhtml). All three postfix operators have higher precedence than
    any prefix operator. The new <samp class="SANS_TheSansMonoCd_W5Regular_11"><postfix-op></samp>
    symbol includes all three operators, which ensures that they’re all parsed with
    the correct precedence.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We haven’t made any substantive changes to the identifier resolution pass in
    a while. Now we’ll have it resolve structure tags along with function and variable
    names. This pass will assign every structure type a unique ID, replacing its original
    user-defined tag. It will also throw an error if a program tries to specify a
    structure type before declaring it.
  prefs: []
  type: TYPE_NORMAL
- en: In the type checker, we’ll introduce a new table to track structure definitions.
    We’ll refer to these definitions when we type check initializers, member access
    operators, and other operations on structures. We’ll also use them to generate
    TACKY and assembly in later stages.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Resolving Structure
    Tags</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s walk through how to handle structure tags during identifier resolution.
    We’ll rename these tags in basically the same way that we rename local variables.
    We’ll maintain a map from user-defined tags to unique identifiers. When we find
    a declaration of a new structure type, we’ll generate a new identifier and add
    it to the map. And when we encounter a structure type specifier, we’ll replace
    it with the corresponding unique identifier from the map. Because structure tags
    exist in a separate namespace from functions and variables, we’ll track them in
    a separate map.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Defining the Structure Tag
    Map</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In our existing identifier map, we track three pieces of information about
    each user-defined function or variable name: the unique identifier we’ll replace
    it with, whether it has linkage, and whether it was defined in the current scope.
    In the structure tag map, we’ll track each tag’s unique identifier and whether
    it was defined in the current scope, but we won’t track linkage, because that
    concept doesn’t apply to types. Go ahead and define this data structure. Then,
    we’ll look at how to resolve tags in type specifiers and declarations.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Resolving Type Specifiers</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 18-15](chapter18.xhtml#list18-15) illustrates how to resolve a type
    specifier.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-15: Replacing structure
    tags in a type specifier</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp> function
    accepts a type specifier and returns a copy of that specifier in which any structure
    tags have been replaced with unique IDs. When <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp>
    encounters a structure type, it replaces the tag with the corresponding identifier
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">structure_map</samp> ❶. If
    the tag isn’t in <samp class="SANS_TheSansMonoCd_W5Regular_11">structure _map</samp>,
    the structure hasn’t been declared yet, so it throws an error ❷. To resolve a
    derived type, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Pointer</samp>,
    we resolve its constituent types recursively. I’ve omitted the pseudocode for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Array</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">FunType</samp>,
    which we’ll handle the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">Pointer</samp>.
    We return any other type unchanged. We’ll process every type specifier in the
    AST with <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp>, including
    specifiers in function and variable declarations, cast and <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    expressions, and structure member declarations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Resolving Structure Type Declarations</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, let’s look at the pseudocode in [Listing 18-16](chapter18.xhtml#list18-16),
    which illustrates how to resolve a structure type declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-16: Adding structure
    type declarations to the structure tag map</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we look up the declaration’s tag in the structure tag map ❶. If this
    tag hasn’t been declared yet, or if it was declared in an outer scope, this declaration
    introduces a new type. We therefore generate a new identifier and add it to the
    structure tag map ❷. If the structure’s tag was already declared in the current
    scope, the current declaration just redeclares the same type. In this case, we
    don’t generate a new unique ID; instead, we use the one that’s already in the
    map ❸.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the structure tag map is up to date. Now we transform the structure
    type declaration itself. If this declaration specifies the structure’s members,
    we resolve its member types by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_type</samp>
    on each of them ❹. We replace the declaration’s user-defined tag with <samp class="SANS_TheSansMonoCd_W5Regular_11">unique_tag</samp>,
    the ID that we generated or looked up earlier in the function. Finally, we return
    the transformed declaration ❺.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we add the new tag to <samp class="SANS_TheSansMonoCd_W5Regular_11">structure_map</samp>
    before processing any structure members. This lets us accept self-referential
    structures, like the linked list node from [Listing 18-6](chapter18.xhtml#list18-6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Also note that we don’t generate unique names for structure members. Variables
    and functions need unique identifiers because they’re all stored in a single symbol
    table, and structure tags need to be unique because they’re all stored in a single
    type table, but structure members won’t all be stored in one table. Instead, we’ll
    maintain a separate member list for each structure type, so members in different
    structures with the same name won’t conflict with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll make two more updates to the identifier resolution pass. First, at the
    start of each new scope, we’ll make a copy of the structure tag map with each
    entry’s <samp class="SANS_TheSansMonoCd_W5Regular_11">from_current_scope</samp>
    attribute set to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>, just
    like we do for the identifier map. The second change is purely mechanical: we’ll
    extend <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> to process
    the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>
    expressions the same way it processes all the other kinds of expressions. I’ll
    skip the pseudocode for these changes, since they’re both straightforward.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Structures</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Much like the type checker records information about every function and variable
    in the symbol table, it will also record information about every complete structure
    type in the *type table*. Let’s start by defining the type table; then, we’ll
    look at how to convert structure type declarations to type table entries. Finally,
    we’ll use the information in the type table to type check declarations, expressions,
    and initializers.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Defining the Type Table</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The type table maps the structure tags we generated in the previous stage to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp> constructs.
    [Listing 18-17](chapter18.xhtml#list18-17) defines <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-17: An entry in
    the type table</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp> describes
    a structure type’s alignment, size, and members. We describe each member with
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">member_entry</samp> construct,
    which specifies the member’s name, its type, and its offset in bytes from the
    start of the structure. A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>
    should support two different ways of accessing <samp class="SANS_TheSansMonoCd_W5Regular_11">members</samp>:
    looking up specific members by name and getting the whole list of members in order.
    You might want to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">members</samp>
    as an ordered dictionary if your implementation language supports it.'
  prefs: []
  type: TYPE_NORMAL
- en: Like the symbol table, the type table should be a global variable or singleton
    that you can easily access from any stage of the compiler. (We’ll pass it explicitly
    in this section’s pseudocode for the sake of clarity.)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll see how to add structure definitions to the type table as we traverse
    the AST.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Populating the Type Table</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When the type checker encounters a definition of a complete structure type,
    it should validate the definition, then convert it into a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>
    and add it to the type table. The type checker can ignore any structure type declaration
    without a member list; a declaration with no member list either declares an incomplete
    type or redeclares a type that was already defined.
  prefs: []
  type: TYPE_NORMAL
- en: To validate a structure type definition, we’ll start by checking whether this
    structure is in the type table already. If it is, that means there’s another definition
    of the same tag in the same scope, so we’ll throw an error. Then, we’ll make sure
    that no members of the structure share the same name, that no member has an incomplete
    type, and that no member type specifies an array with an incomplete element type.
    (Remember that arrays of incomplete type are illegal everywhere, not just in structure
    definitions.) You might also want to validate that no structure members have function
    type, but it isn’t strictly necessary since we already validated that during parsing.
  prefs: []
  type: TYPE_NORMAL
- en: After validating that a structure type satisfies all these requirements, we’ll
    calculate each member’s offset and the whole structure’s size and alignment. Earlier
    in the chapter, we saw how to perform these calculations and walked through an
    example. Now let’s look at [Listing 18-18](chapter18.xhtml#list18-18), which demonstrates
    the whole process in pseudocode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-18: Calculating
    a structure definition</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We start by checking whether this declaration includes a member list ❶. If it
    doesn’t, we return immediately, without making any changes to the type table.
    If it does have a member list, we validate that it meets the requirements described
    earlier in this section ❷. I won’t give you the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">validate_struct_definition</samp>,
    since it isn’t too complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we get to the interesting part: figuring out each member’s layout in
    memory. Here, we’ll define a <samp class="SANS_TheSansMonoCd_W5Regular_11">member_entry</samp>
    for each structure member ❸. As we go, we’ll maintain a running total of the structure’s
    size in bytes, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp>.
    We’ll also track the strictest member alignment we’ve seen so far as <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_alignment</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: To calculate a structure member’s offset, we take the next available offset,
    which is given by <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp>,
    and round it up to that member’s alignment ❹. (We’ll walk through how to look
    up each type’s size and alignment in a moment.) We construct its <samp class="SANS_TheSansMonoCd_W5Regular_11">member_entry</samp>
    ❺, then update <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_alignment</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve processed every member, we calculate the structure’s total size by
    rounding <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_size</samp> up to
    the nearest multiple of its alignment ❻. This rounded-up size will account for
    any padding at the end of the structure. Finally, we add the whole <samp class="SANS_TheSansMonoCd_W5Regular_11">struct_entry</samp>
    to the type table ❼.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Handling Structures in Helper
    Functions</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ve centralized a lot of type checking logic into a handful of helper functions,
    including <samp class="SANS_TheSansMonoCd_W5Regular_11">is_scalar</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp>. You’ve probably also
    written a few helper functions to look up each type’s size, alignment, and other
    properties, although I haven’t provided pseudocode for those yet. Now we’ll extend
    these helpers to handle structure types too.
  prefs: []
  type: TYPE_NORMAL
- en: We defined <samp class="SANS_TheSansMonoCd_W5Regular_11">is_scalar</samp> back
    in [Listing 17-12](chapter17.xhtml#list17-12). [Listing 18-19](chapter18.xhtml#list18-19)
    gives the updated definition, with this chapter’s addition bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-19: Checking whether
    a type is scalar</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Structure types aren’t scalar, so this is pretty simple. I’m guessing you’ve
    written similar helper functions to test whether a type is arithmetic, whether
    it’s an integer type, and so on. These will require similarly straightforward
    updates, which we won’t get into here.
  prefs: []
  type: TYPE_NORMAL
- en: Updating <samp class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp> is
    slightly more involved; we’ll need to consult the type table. [Listing 18-20](chapter18.xhtml#list18-20)
    gives the new definition of this function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-20: Checking whether
    a type is complete</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If a structure type is in the type table, it’s complete; if not, it’s incomplete.
    As we saw earlier, a structure type may be incomplete at one point in the program
    but complete later on. During type checking, the type table tells us whether the
    structure type is complete at the current point in the AST. Consider the code
    fragment in [Listing 18-21](chapter18.xhtml#list18-21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-21: Declaring a
    variable with an incomplete structure type</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Because the first declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> ❶ doesn’t specify any members, we won’t add it to the type table. Then,
    when we validate the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    t</samp> ❷, we’ll look up <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> in the type table. (Strictly speaking, we’ll look up the unique identifier
    that replaced <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> during the
    identifier resolution stage.) When we don’t find it, we’ll correctly conclude
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp> is incomplete
    and throw an error. If the declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    t</samp> appeared after the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> ❸, we’d add <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>
    to the type table before processing <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    t</samp>, so we wouldn’t throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: We also need helper functions to find a type’s size and alignment. [Listing
    18-22](chapter18.xhtml#list18-22) shows the pseudocode for the <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-22: Calculating
    a type’s alignment</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To find a structure’s alignment, we’ll look it up in the type table. To find
    an array’s alignment, we’ll recursively calculate the alignment of its element
    type. We’ll hardcode the alignments of other types, which are dictated by the
    ABI. I won’t provide pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>,
    which will look similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*We learned earlier that if a variable of array type is 16 bytes or larger,
    it must be 16-byte aligned. [Listing 18-22](chapter18.xhtml#list18-22) doesn’t
    reflect this requirement because it calculates the alignment of types, not variables.
    You’ll probably want to write a different helper function to calculate the alignment
    of variables, if you haven’t already.*'
  prefs: []
  type: TYPE_NORMAL
- en: The other helper functions we defined in earlier chapters should handle structures
    correctly without any changes. Consider <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>,
    which we use to type check assignment expressions and other places where we convert
    a value to a specific type “as if by assignment.” [Listing 18-23](chapter18.xhtml#list18-23)
    reproduces the latest version of this code from [Listing 17-11](chapter17.xhtml#list17-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-23: Converting an
    expression to a target type</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If we pass <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>
    an expression that already has the correct structure type, it will return the
    expression unchanged. In any other case with a source or target structure type,
    it will fail. That’s the correct behavior, since there’s no way to convert to
    or from a structure type.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Handling Incomplete Structure
    Types</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We need to enforce several restrictions on incomplete structure types. First,
    we’ll validate the use of these types in declarations; then, we’ll validate their
    use in expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s legal to declare, but not define, a function with parameters or a return
    value of incomplete structure type. (Remember that a function definition is a
    function declaration with a body.) If <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    s</samp> is an incomplete type, the type checker should accept this declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'But it should reject this definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we’ll accept declarations of variables with incomplete structure
    type but reject any definitions of these variables, including tentative definitions.
    (This is more restrictive than the C standard, which permits tentative definitions
    of variables with incomplete types in certain limited circumstances.) Concretely,
    we’ll accept a variable declaration with an incomplete structure type only if
    it has the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> storage
    class and no initializer.
  prefs: []
  type: TYPE_NORMAL
- en: 'That takes care of declarations; now let’s consider expressions. There’s exactly
    one way to use a variable with incomplete type in an expression. You can take
    its address, as the following example demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You can then use <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> like
    any other pointer to an incomplete type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, it’s legal (if not especially useful) to dereference a pointer to
    an incomplete structure and then take its address, resulting in the pointer you
    started with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Any other use of an expression with an incomplete structure type is invalid.
    You can’t even cast it to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    or use it as an expression statement, so the type checker should reject both of
    the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We’ll extend <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    to catch these invalid expressions. [Listing 18-24](chapter18.xhtml#list18-24)
    gives the updated definition of this function, with changes from the original
    definition in [Listing 15-19](chapter15.xhtml#list15-19) bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-24: Rejecting incomplete
    structure types in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">typecheck_and_convert</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    processes every expression in the AST except for static initializers (which must
    be constants) and the operands of the <samp class="SANS_TheSansMonoCd_W5Regular_11">SizeOf</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions (which
    don’t undergo array decay). This makes <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    the most convenient place to put the new validation, even though it has nothing
    to do with the function’s original purpose, which is to implicitly convert arrays
    to pointers. With this new validation in place, we’ll handle incomplete types
    correctly in every kind of expression: we’ll permit incomplete structure types
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp> expressions, our
    existing validation will reject all incomplete types (including <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>)
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">SizeOf</samp> expressions, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp> will
    reject incomplete structure types everywhere else. Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    still accepts void expressions, which are legal in several places where expressions
    with incomplete structure types are not.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already implemented all the other validation we need for incomplete types.
    For example, we already require the pointer operands in pointer arithmetic expressions
    to point to complete types, and we already require the element types in array
    type specifiers to be complete.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Type Checking the Member Access
    Operators</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, let’s type check the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operators. In both
    cases, we’ll validate the expression, figure out the member type, and record that
    as the type of the whole expression. [Listing 18-25](chapter18.xhtml#list18-25)
    demonstrates how to type check a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-25: Type checking
    the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operator</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We start by type checking the first operand, <samp class="SANS_TheSansMonoCd_W5Regular_11">structure</samp>,
    with a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    (which throws an error if <samp class="SANS_TheSansMonoCd_W5Regular_11">structure</samp>
    has an incomplete type). Then, we validate that <samp class="SANS_TheSansMonoCd_W5Regular_11">structure</samp>
    really is a structure ❶. If it is, we look up its type in the type table ❷, then
    look up <samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp> in the resulting
    type table entry ❸. Finally, we annotate the expression with the member type ❹.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">structure</samp> isn’t a structure
    or doesn’t have a member with this name, we throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: I won’t provide pseudocode for type checking the <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    operator, since it’s nearly identical; the only difference is that we validate
    that the first operand is a pointer to a structure, rather than a structure itself.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Validating Lvalues</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> expression is always
    an lvalue. To determine whether a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    expression is an lvalue, the type checker must recursively check whether its first
    operand is an lvalue. For example, the type checker should reject the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">f().member = 3</samp>. Because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">f()</samp> isn’t an lvalue, <samp class="SANS_TheSansMonoCd_W5Regular_11">f().member</samp>
    isn’t either.
  prefs: []
  type: TYPE_NORMAL
- en: This means we might encounter arrays that aren’t lvalues! It’s a type error
    to explicitly take the address of such an array, like in [Listing 18-26](chapter18.xhtml#list18-26).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-26: Illegally taking
    the address of a non-lvalue</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: However, these arrays still decay to pointers, so their addresses are still
    loaded implicitly. The program in [Listing 18-27](chapter18.xhtml#list18-27),
    for example, is entirely legal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-27: Implicitly converting
    a non-lvalue array to a pointer</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we type check this program, we’ll insert <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    to take the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">f().arr</samp>,
    just like when we type check any other expression of array type.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Type Checking Structures in
    Conditional Expressions</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The type checker should accept conditional expressions where both branches have
    the same structure type. It should reject conditional expressions where only one
    branch has a structure type or where the branches have two different structure
    types. To determine whether two structure types are identical, compare their tags,
    not their contents.
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Type Checking Structure
    Initializers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll deal with structure initializers. As you learned earlier in this
    chapter, you can initialize a structure either with a single expression of that
    structure type or with a compound initializer. The first case shouldn’t require
    any changes to the type checker.
  prefs: []
  type: TYPE_NORMAL
- en: To handle compound initializers, we’ll type check each item in the initializer
    list against the corresponding member type, as [Listing 18-28](chapter18.xhtml#list18-28)
    demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-28: Type checking
    compound initializers for structures</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by looking up the structure in the type table ❶. We should have
    already validated that <samp class="SANS_TheSansMonoCd_W5Regular_11">target_type</samp>
    is complete before calling <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck
    _init</samp>, so at this point it’s safe to assume that the structure has been
    defined. Next, we’ll make sure the initializer list isn’t too long ❷. Just like
    when we process array initializers, we’ll reject an initializer list with too
    many elements but accept one with too few elements to initialize the whole object.
  prefs: []
  type: TYPE_NORMAL
- en: After performing this check, we’ll iterate through the initializer list ❸. To
    type check each initializer, we’ll look up the corresponding member type in the
    structure’s member list, then call <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp>
    recursively to make sure the initializer is compatible with that type. Finally,
    we’ll pad out any uninitialized structure members with zeros ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve updated <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp>,
    you’ll need to extend <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>
    to handle structure types. To initialize a structure to zero, <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>
    should call itself recursively for each member type and return the results in
    a compound initializer.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Initializing Static Structures</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If a structure has static storage duration, we’ll store its initial value as
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> list in the
    symbol table, just like we do for arrays. The key difference is that we’ll initialize
    any padding in the structure too. Let’s return to the example from [Listing 18-10](chapter18.xhtml#list18-10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We figured out that this structure included 4 bytes of padding between <samp
    class="SANS_TheSansMonoCd_W5Regular_11">member1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp>
    and 5 bytes of padding after <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> is a static variable,
    we’ll use the construct in [Listing 18-29](chapter18.xhtml#list18-29) to represent
    its initial value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-29: Representing
    the initializer from [Listing 18-10](chapter18.xhtml#list18-10) as a</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">static_init</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">list</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We initialize padding with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    construct ❶❷ because the C standard requires the padding in static structures
    to be initialized to zero. [Listing 18-30](chapter18.xhtml#list18-30) demonstrates
    how to generate static initializer lists like the one in [Listing 18-29](chapter18.xhtml#list18-29).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-30: Generating a
    static initializer for a structure</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To process a compound initializer for a static structure, we first look up the
    structure in the type table ❶. We make sure the initializer list isn’t too long,
    just like we did for non-static initializers in <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp>.
    Then, we iterate over the initializer list, looking up the corresponding member
    definition for each element in the structure’s member list. As we go, we update
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">current_offset</samp> variable
    to track how many bytes we’ve initialized so far.
  prefs: []
  type: TYPE_NORMAL
- en: Each time we process the initializer for a structure member, we first check
    whether we’ve initialized enough bytes to bring us up to the expected offset.
    If we haven’t, we add the necessary padding with a <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    initializer ❷. We then create the initializer list for the structure member itself
    with a recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">create_static_init_list</samp>
    ❸. Next, we update <samp class="SANS_TheSansMonoCd_W5Regular_11">current _offset</samp>
    based on the offset and size of the member we just initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve initialized every structure member, we add another <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>,
    if necessary, to pad out the structure to the correct size ❹. This last <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> zeroes out any structure
    members that weren’t explicitly initialized as well as any trailing padding after
    the last member.
  prefs: []
  type: TYPE_NORMAL
- en: Because there are no constants of structure type, initializing a static structure
    with a <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleInit</samp> expression
    is a type error ❺.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we’ll introduce one last TACKY instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This instruction mirrors the <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    instruction we added back in [Chapter 15](chapter15.xhtml). The <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    identifier in <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    is the name of an aggregate variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>
    is the byte offset of a subobject within that variable, and <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    is the variable we’ll copy that subobject to. [Listing 18-31](chapter18.xhtml#list18-31)
    defines the complete TACKY IR, including the new <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-31: Adding</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">CopyFromOffset</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    the TACKY IR</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Not only can you access subobjects in a structure with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> instructions,
    but you can also copy entire structures from one location to another using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> or pass them between
    functions with <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>, just like scalar
    variables. We’ll represent variables of structure type as ordinary TACKY <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>s.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll convert the member access operators to TACKY. Then, we’ll process
    compound structure initializers. We won’t change how we process most constructs
    that can use structures, like function calls, <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements, and conditional expressions. We also won’t need to do anything with
    the new top-level <samp class="SANS_TheSansMonoCd_W5Regular_11">StructDecl</samp>
    construct; we’ll discard structure declarations at this stage, just like we discard
    function declarations without bodies and variable declarations without initializers.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing the
    Member Access Operators</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In earlier chapters, you learned that you can use an object in one of three
    ways: you can lvalue convert it, assign to it, or take its address. Now there’s
    a fourth option: if the object is a structure, you can access one of its members.
    And because that structure member is itself an object, you can lvalue convert
    it, assign to it, take its address, or access one of *its* members. Let’s look
    at the TACKY we should generate in each of these cases. Then, building on the
    approach we used to handle dereferenced pointers in [Chapter 14](chapter14.xhtml),
    we’ll introduce a new kind of <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>
    to designate structure members.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Accessing Structure Members
    in TACKY</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To implement any sort of operation on a structure member, we’ll start by looking
    up the member’s offset in the type table. First, let’s consider cases where the
    structure itself is a TACKY variable, rather than a dereferenced pointer or a
    subobject in some larger structure. To lvalue convert a structure member, we’ll
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> instruction.
    We’ll translate <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><struct></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp>
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll assign to structure members with <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>,
    converting <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><struct></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><right></samp>
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a structure member’s address, we’ll first load the address of the object
    that contains it, then add the member’s offset. We’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><struct></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp> to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: To process a sequence of nested member accesses, we’ll add all their offsets
    together and then issue an instruction depending on how the final member in the
    sequence is used. Consider the structure declarations in [Listing 18-32](chapter18.xhtml#list18-32).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-32: Declaring a
    structure that contains a nested structure</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'If <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct</samp> is a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct outer</samp> and we need to lvalue
    convert <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct .member2.i</samp>,
    we’ll emit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">member2</samp> has an
    offset of 4 bytes in <samp class="SANS_TheSansMonoCd_W5Regular_11">struct outer</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> has an offset of 4
    bytes in <samp class="SANS_TheSansMonoCd_W5Regular_11">struct inner</samp>, the
    object designated by <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct.member2.i</samp>
    has a total offset of 8 bytes from the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s consider how to access structure members through dereferenced
    pointers. The most idiomatic way to do this is with an arrow operator, of the
    form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">-></samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp>.
    This is equivalent to the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(*</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><exp></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">).</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><member></samp>. To implement
    either of these expressions, you’ll add the member offset to the pointer and then
    dereference the result. As with any dereferenced pointer, whether you issue a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction or simply use the pointer’s value will depend on how it’s used. Suppose
    <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_struct_pointer</samp> has
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct inner *</samp>. We’ll
    convert the expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We can implement the equivalent expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: with exactly the same instructions. Now that we know what instructions we’d
    like to generate, we’ll update the TACKY generation pass accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Designating Structure Members
    with SubObject</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>
    construct to designate a member of an aggregate object. [Listing 18-33](chapter18.xhtml#list18-33)
    gives the updated definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">exp_result</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-33: Extending</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp_result</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    represent subobjects</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">base</samp> argument to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp> is an aggregate object,
    not a pointer. The second argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>,
    is a byte offset into that object. The object that <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>
    designates might be scalar, or it might be an aggregate itself. In [Listing 18-34](chapter18.xhtml#list18-34),
    we use this construct to represent the result of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp>
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-34: Converting the</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">Dot</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">operator
    to TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we look up <samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp>’s
    offset in the structure. Then, we process this expression’s first operand without
    lvalue converting it. The resulting object is either a plain TACKY variable, a
    subobject of a TACKY variable, or a dereferenced pointer. (We know the result
    isn’t a constant because TACKY doesn’t have constants of structure type.)
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_object</samp> is just
    a variable, we return a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>
    designating the object at <samp class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp>
    within that variable ❶. If <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_object</samp>
    is itself a subobject in some larger variable, we add its offset to <samp class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp>
    ❷. This takes care of nested member operators, like the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">my_struct
    .member2.i</samp> that we considered earlier in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if the inner structure is a dereferenced pointer, we access the structure
    member with pointer arithmetic ❸. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer(ptr)</samp>
    designates the whole structure, <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    must point to the start of the structure. We add <samp class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> to get a pointer to
    the specified structure member. Then, we dereference this pointer to designate
    the structure member itself.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Processing SubObject</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, we’ll process <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>
    constructs in lvalue conversions, assignment expressions, and <samp class="SANS_TheSansMonoCd_W5Regular_11">AddrOf</samp>
    expressions. To lvalue convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>,
    we copy it into a new variable with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    instruction, as [Listing 18-35](chapter18.xhtml#list18-35) demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-35: Lvalue converting
    a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">SubObject</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, when a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>
    appears on the left-hand side of an assignment expression, we write to it with
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> instruction,
    as [Listing 18-36](chapter18.xhtml#list18-36) demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-36: Assigning to
    a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">SubObject</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, [Listing 18-37](chapter18.xhtml#list18-37) shows how to calculate the
    address of a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp>. We
    load the address of the base object, then add the offset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-37: Taking the address
    of a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">SubObject</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We reuse the same temporary variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>,
    to point to both the base of the structure and its member. We could also generate
    two different temporary variables, but we don’t need to. Because the offset in
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubObject</samp> construct is
    in bytes, the scale of this <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> ❶.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing the Arrow Operator</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that we’ve implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">Dot</samp>,
    we can easily implement <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>
    too. To calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr->member</samp>,
    we’ll first evaluate and lvalue convert <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>.
    Then, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> to
    add the offset of <samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp>.
    This will give us a pointer to the designated structure member. Finally, we’ll
    dereference this pointer with a <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>
    construct. I’ll omit the pseudocode for this; you’ve already seen how to convert
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(*ptr).member</samp> to TACKY, and
    converting <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr->member</samp> to
    TACKY is very similar.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need any extra logic to handle the result of an <samp class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>
    expression. This expression will always produce a <samp class="SANS_TheSansMonoCd_W5Regular_11">DereferencedPointer</samp>
    construct, which we already know how to handle.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Omitting Useless AddPtr Instructions</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The first member in a structure always has an offset of zero. As an optional
    optimization, you can skip the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction when calculating this member’s address. This affects [Listings 18-34](chapter18.xhtml#list18-34)
    and [18-37](chapter18.xhtml#list18-37), as well as the implementation of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Arrow</samp>, which I didn’t give the
    pseudocode for. In all three cases, you don’t need to generate an <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp>
    instruction if <samp class="SANS_TheSansMonoCd_W5Regular_11">member_offset</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Compound
    Initializers to TACKY</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To finish up this section, we’ll convert compound structure initializers to
    TACKY. The basic approach is the same as in previous chapters: we’ll evaluate
    each expression in the initializer list in turn, copying the result of each one
    to the correct offset in the destination with a <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    instruction. But now we’ll need to check the type table to find the correct offset
    for each expression. We’ll also need to calculate the offsets of subobjects deep
    within nested structures, arrays of structures, structures that contain arrays,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 18-38](chapter18.xhtml#list18-38) demonstrates how to track these
    offsets and emit <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    instructions as we traverse a compound initializer for a structure or array.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-38: Converting a
    compound initializer to TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">compound_initializer_to_tacky</samp>
    include <samp class="SANS_TheSansMonoCd_W5Regular_11">var_name</samp> (the name
    of the array or structure variable being initialized), <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>
    (the byte offset of the current subobject within that variable), and <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>
    (the initializer itself). In the top-level call to initialize an entire variable,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp> argument will
    be <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: In the base case, we initialize a subobject with the value of a single expression.
    This expression may be a string literal that initializes an array; I’ve omitted
    the pseudocode for this case, which we covered back in [Chapter 16](chapter16.xhtml).
    Otherwise, we evaluate the expression and copy the result into place with a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> instruction ❶. Even
    if the result has structure type, we can copy it to its destination with a single
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: When we encounter a compound initializer for a structure, we look up the structure’s
    member list in the type table. We calculate the offset of each item in the initializer
    list by adding the corresponding member offset to the starting <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp>
    argument ❷. Then, we process the item recursively. I won’t talk through the case
    of a compound initializer for an array, since you already know how to handle that.
  prefs: []
  type: TYPE_NORMAL
- en: Our implementation deviates slightly from the C standard here. Under certain
    circumstances, the standard requires padding to be initialized to zero; [Listing
    18-38](chapter18.xhtml#list18-38) doesn’t initialize structure padding, and none
    of our tests check the value of padding in non-static structures.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you know how to convert both member access operators and compound
    structure initializers to TACKY. Once you’ve implemented these conversions, you
    can test out this compiler pass.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Structures in the System V Calling Convention</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The trickiest part of assembly generation in this chapter is dealing with function
    calls. As always, we need to pass parameters and return values according to the
    System V x64 calling convention. The rules for passing and returning structures
    are particularly gnarly, so we’ll take a look at them before we make any changes
    to the backend.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Classifying Structures</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the System V x64 ABI, every parameter and return value has a *class*, which
    dictates how it’s transferred during function calls. We’ve already encountered
    two of the classes defined in the ABI, although I didn’t use the term *class*
    to describe them. Values with integer, character, and pointer types all belong
    to the INTEGER class; they’re transferred in general-purpose registers. Values
    with type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> all belong
    to the SSE class; they’re transferred in XMM registers.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll encounter a third class, MEMORY, for large values that
    must be transferred in memory. We’ve passed function arguments in memory before,
    but passing return values in memory is a new concept; we’ll see exactly how that
    works in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: The ABI presents a somewhat complicated algorithm for classifying structures
    and unions. We can use a simplified version of this algorithm because there are
    a bunch of types that we don’t handle, like <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and unions. We’ll walk through the simplified rules for classifying structures
    in this section. For the complete algorithm, see the documentation listed in “Additional
    Resources” on [page 553](#pg_553).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Splitting a Structure into
    Eightbytes</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ll assign a separate class to each 8-byte chunk of a structure. The ABI calls
    these chunks *eightbytes*. If the structure’s size isn’t exactly divisible by
    8, the last eightbyte may be shorter than 8 bytes (which makes the term a little
    misleading). Consider [Listing 18-39](chapter18.xhtml#list18-39), which declares
    a 12-byte structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-39: A structure
    with two eightbytes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first eightbyte of this structure contains <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    and the first four elements of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>.
    The second eightbyte is 4 bytes long and contains the last four elements of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>. [Figure 18-2](#fig18-2) shows
    this structure’s layout in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig18-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-2: The layout of
    struct twelve_bytes in memory [Description](description-44.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-2](#fig18-2) illustrates that a nested array like <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>
    can span multiple eightbytes. A nested structure can too. Consider the structure
    declaration in [Listing 18-40](chapter18.xhtml#list18-40).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-40: A structure
    type containing a nested structure that spans two eightbytes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-3](#fig18-3) shows how a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    nested_ints</samp> will be laid out in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig18-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-3: The layout of
    struct nested_ints in memory [Description](description-45.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first eightbyte of this structure holds two scalar values: <samp class="SANS_TheSansMonoCd_W5Regular_11">ch1</samp>
    and the nested member <samp class="SANS_TheSansMonoCd_W5Regular_11">nested.i</samp>.
    The second eightbyte holds <samp class="SANS_TheSansMonoCd_W5Regular_11">nested.ch2</samp>.
    When we classify a structure, we care about what scalar values each eightbyte
    contains, but we don’t care how those values are grouped into nested structures
    or arrays. As far as our classification algorithm is concerned, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    nested _ints</samp> is equivalent to the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    flattened_ints</samp> type defined in [Listing 18-41](chapter18.xhtml#list18-41).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-41: A structure
    with the same layout as</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">struct
    nested_ints</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in memory</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This structure looks identical to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    nested_ints</samp> in memory: its first eightbyte holds a <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    and an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, and its second
    eightbyte holds another <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Classifying Eightbytes</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If a structure is larger than 16 bytes—in other words, if it consists of three
    or more eightbytes—we’ll assign every eightbyte to the MEMORY class. For example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct large</samp> consists of
    four eightbytes, which are all classified as MEMORY:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: If a structure is 16 bytes or smaller, we’ll assign each eightbyte to either
    the INTEGER or the SSE class, according to its contents. An eightbyte belongs
    to the SSE class if it contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and the INTEGER class if it contains anything else. For example, both eightbytes
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct twelve_bytes</samp>, from
    [Listing 18-39](chapter18.xhtml#list18-39), belong to the INTEGER class. We’ll
    assign both eightbytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    nested_ints</samp> from [Listing 18-40](chapter18.xhtml#list18-40) and both eightbytes
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct flattened_ints</samp>
    from [Listing 18-41](chapter18.xhtml#list18-41) to the INTEGER class too, since
    none of them hold a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 18-42](chapter18.xhtml#list18-42) defines a few more structure types.
    Let’s classify each of them.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-42: More structure
    types</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct two_ints</samp> consists
    of a single eightbyte, which belongs to the INTEGER class. A <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    nested_double</samp> consists of a single eightbyte in the SSE class. A <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct two_eightbytes</samp> consists
    of two eightbytes: the first is in the SSE class because it contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    and the second is in the INTEGER class because it contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Passing Parameters
    of Structure Type</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once we’ve classified a structure, we can figure out how to pass it as a parameter.
    If a structure consists of one or two eightbytes, we’ll pass each eightbyte of
    the structure in the next available register for its class. If a structure consists
    of a single eightbyte in the INTEGER class, we’ll pass it in the next general-purpose
    parameter passing register. If it consists of a single eightbyte in the SSE class,
    we’ll pass it in the next available parameter passing XMM register. If it consists
    of one INTEGER eightbyte and one SSE eightbyte, we’ll pass the first eightbyte
    in a general-purpose register and the next eightbyte in an XMM register, and so
    forth. If there aren’t enough registers available to pass the entire structure,
    we’ll push the whole thing onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a few examples. First, in [Listing 18-43](chapter18.xhtml#list18-43),
    we reproduce the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct two_eightbytes</samp>
    type that we defined in [Listing 18-42](chapter18.xhtml#list18-42) and declare
    a function that takes a parameter with that type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-43: A function declaration
    with a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">struct two_eightbytes</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">parameter</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a variable
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct two_eightbytes</samp>,
    which is stored on the stack at address <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>.
    We might convert the function call <samp class="SANS_TheSansMonoCd_W5Regular_11">pass
    _struct(x)</samp> to the assembly in [Listing 18-44](chapter18.xhtml#list18-44).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-44: Passing a structure
    parameter in two registers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Because the first eightbyte of this structure belongs to the SSE class, we pass
    it in the first parameter passing XMM register, XMM0\. The second eightbyte of
    the structure belongs to the INTEGER class, so we pass it in the first general-purpose
    parameter passing register, RDI.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at [Listing 18-45](chapter18.xhtml#list18-45). This listing
    declares a function with a structure parameter that we’ll need to push onto the
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-45: A function declaration
    with a structure parameter that must be passed in memory</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we call <samp class="SANS_TheSansMonoCd_W5Regular_11">a_bunch_of_arguments</samp>,
    we’ll pass parameters <samp class="SANS_TheSansMonoCd_W5Regular_11">i0</samp>
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">i4</samp> in registers EDI,
    ESI, EDX, ECX, and R8D. This doesn’t leave enough registers open to pass the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">param</samp> parameter; both eightbytes
    belong to the INTEGER class, but only one general-purpose parameter passing register,
    R9, is available. Therefore, we’ll push the whole structure onto the stack. Then,
    since R9D is still open, we’ll use it to transfer <samp class="SANS_TheSansMonoCd_W5Regular_11">i5</samp>.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    two_longs</samp> with static storage duration, we could convert the function call
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: to the assembly in [Listing 18-46](chapter18.xhtml#list18-46).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-46: Passing a structure
    on the stack</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> lives in the
    data section, we access it with RIP-relative addressing. We’re using a bit of
    new assembly syntax here: <samp class="SANS_TheSansMonoCd_W5Regular_11">arg+8(%rip)</samp>
    indicates the address 8 bytes after the label <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>.
    Our first <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instruction
    will therefore push the second eightbyte of the structure, which contains member
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, onto the stack ❶. This
    preserves the structure’s layout in memory, as [Figure 18-4](#fig18-4) demonstrates.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig18-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-4: Pushing a structure
    onto the stack [Description](description-46.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The two <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp> instructions
    in [Listing 18-46](chapter18.xhtml#list18-46) push a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>
    onto the stack with the correct layout. After the callee sets up its stack frame,
    it can access <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> at <samp
    class="SANS_TheSansMonoCd_W5Regular_11">16(%rbp)</samp>, which is where we always
    expect to find a function’s first stack parameter.
  prefs: []
  type: TYPE_NORMAL
- en: If a structure belongs to the MEMORY class, we’ll always push it onto the stack.
    Consider the structure type declaration and function declaration in [Listing 18-47](chapter18.xhtml#list18-47).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-47: A function declaration
    with a structure parameter that belongs to the MEMORY class</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 18-48](chapter18.xhtml#list18-48) demonstrates how to pass a structure
    stored at <samp class="SANS_TheSansMonoCd_W5Regular_11">-32(%rbp)</samp> as an
    argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">accept_struct</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-48: Passing a structure
    that belongs to the MEMORY class on the stack</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, like in [Listing 18-46](chapter18.xhtml#list18-46), we maintain
    the structure’s layout in memory by pushing it onto the stack from back to front.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Returning Structures</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a structure fits into a single register, returning it is straightforward.
    We’ll return structures that belong to the INTEGER class in RAX and structures
    that belong to the SSE class in XMM0\. If a structure is between 8 and 16 bytes,
    we’ll return it in two registers. To accommodate these structures, we’ll designate
    two more registers to transfer return values: RDX and XMM1\. We’ll transfer each
    eightbyte of a structure in the next available return register of the appropriate
    class. For example, if the first part of a structure belongs to the SSE class
    and the second part belongs to the INTEGER class, we’ll transfer the first part
    in XMM0 and the second part in RAX. If both parts belong to the SSE class, we’ll
    transfer the structure in XMM0 and XMM1; if both parts belong to the INTEGER class,
    we’ll transfer it in RAX and RDX.'
  prefs: []
  type: TYPE_NORMAL
- en: Things get even hairier if a structure is in the MEMORY class. In that case,
    the caller allocates space for the return value and passes the address of that
    space to the callee in the RDI register, as if it were the first integer parameter.
    This means the actual first integer parameter must be passed in RSI, the second
    in RDX, and so on. To return a value, the callee copies it into the space pointed
    to by RDI and copies the pointer itself into RAX. Let’s look at the example in
    [Listing 18-49](chapter18.xhtml#list18-49).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-49: Calling function
    that returns a structure in memory</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">struct large_struct</samp>
    is 24 bytes, we’ll return the result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp>
    function in memory. In <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>,
    we call <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp> and
    assign the result to <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>
    ❶. Assuming <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> has reserved
    stack space for <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>
    at <samp class="SANS_TheSansMonoCd_W5Regular_11">-24(%rbp)</samp>, [Listing 18-50](chapter18.xhtml#list18-50)
    shows how to implement this function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-50: Calling</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">return_a_struct</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    assembly</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we pass the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>,
    which will hold the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp>,
    in RDI. We then pass the argument <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    in the next available parameter passing register, RSI. Finally, we issue a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction. [Figure 18-5](#fig18-5)
    illustrates the program’s state just before the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig18-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-5: The state of the
    stack and registers before calling return_a_struct [Description](description-47.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: RSP and RBP point to the top and bottom of the current stack frame, as usual.
    RDI points to <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>,
    which hasn’t been initialized yet. RSI holds the first argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that [Listing 18-50](chapter18.xhtml#list18-50) doesn’t allocate additional
    stack space to hold the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp>;
    it just loads the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>
    variable. That’s typically fine, with one caveat: according to the ABI, the memory
    that will hold the return value “must not overlap any data visible to the callee
    through other names than this argument.” For example, if you needed to implement
    the function call <samp class="SANS_TheSansMonoCd_W5Regular_11">var = foo(1, 2,
    &var)</samp>, it would violate the ABI to pass the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    in RDI as the storage for the return value *and* in RCX as an ordinary argument.
    Instead, you’d need to allocate additional stack space to hold the result of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> and copy the result to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">var</samp> after the function returned.
    We don’t need to worry about this case, since we generate a new variable to hold
    the result of each function call during TACKY generation.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at [Listing 18-51](chapter18.xhtml#list18-51), which implements
    <samp class="SANS_TheSansMonoCd_W5Regular_11">return_a_struct</samp> in assembly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-51: Returning a
    structure in memory</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: At the start of the function, we set up the stack frame, allocate stack space
    for the local <samp class="SANS_TheSansMonoCd_W5Regular_11">callee_result</samp>
    variable at <samp class="SANS_TheSansMonoCd_W5Regular_11">-24(%rbp)</samp>, and
    then initialize it. The assembly code to return <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    starts at ❶. First, we copy <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    into the memory location that RDI points to, 8 bytes at a time; we’ll copy the
    first 8 bytes to <samp class="SANS_TheSansMonoCd_W5Regular_11">(%rdi)</samp>,
    the next 8 bytes to <samp class="SANS_TheSansMonoCd_W5Regular_11">8(%rdi)</samp>,
    and the last 8 bytes to <samp class="SANS_TheSansMonoCd_W5Regular_11">16(%rdi)</samp>.
    Then, we copy the pointer to the return value from RDI into RAX ❷. Finally, we
    execute the function epilogue, which is omitted from this listing. [Figure 18-6](#fig18-6)
    illustrates the state of the program just before the function epilogue.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig18-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-6: The state of the
    stack and registers just before returning from return_a_struct [Description](description-48.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp> variable
    in the caller’s stack frame now holds the function’s return value, and RAX holds
    the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">caller_result</samp>.
    In this example, the RDI register holds that address too, but this isn’t required
    by the ABI.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve covered everything we need to know about the calling convention for structures.
    Now we’re ready to work on the assembly generation pass!
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This pass will change in a couple of ways. First, we’ll need to generate assembly
    to copy entire structures from one location to another. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp> instructions
    can all transfer both scalar and aggregate values. So can the new <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    instruction, which we’ll need to implement. Second, we’ll implement the System
    V calling convention that we just learned about.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by making a few small changes to the assembly AST.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extending the Assembly
    AST</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Listing 18-46](chapter18.xhtml#list18-46), we used the operand <samp class="SANS_TheSansMonoCd_W5Regular_11">arg+8(%rip)</samp>
    to access data at a constant offset from a RIP-relative label. We’ll often need
    these sorts of operands to access members of structures with static storage duration.
    The assembly AST can already specify constant offsets from most memory addresses,
    but not from RIP-relative addresses. We’ll remove this limitation by adding an
    offset to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: We’ll also introduce two new assembly instructions. First, we’ll add the left-shift
    instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>. This instruction
    takes an immediate value as its source operand and a memory address or register
    as its destination. It shifts its destination left by the number of bits specified
    by its source. For example, the instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: shifts the value in RAX 1 byte to the left, setting its lowest byte to 0\. If
    the value in RAX were <samp class="SANS_TheSansMonoCd_W5Regular_11">0x8</samp>
    before this instruction, it would be <samp class="SANS_TheSansMonoCd_W5Regular_11">0x800</samp>
    afterward. The <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> instruction
    will help us copy irregularly sized structures into registers in order to pass
    them as arguments and return values. Because we can’t directly access every individual
    byte within a register, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>
    to shift each byte into place.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we’ll add the two-operand form of the logical right-shift instruction,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>. (We added the one-operand
    form, which shifts its operand 1 bit to the right, back in [Chapter 13](chapter13.xhtml).)
    Similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>, it shifts
    its destination right by the number of bits its source specifies. It will serve
    a similar purpose to <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>,
    helping us transfer irregularly sized structures *out* of registers and into memory.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The shl instruction also has a one-operand form, which we won’t use; it’s
    the counterpart to the one-operand form of shr that we’re already familiar with.
    Both instructions have yet another form we won’t use, which uses the CL register
    as the source operand.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll extend <samp class="SANS_TheSansMonoCd_W5Regular_11">binary_operator</samp>
    to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The new binary <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp> instruction
    gets the rather clunky name <samp class="SANS_TheSansMonoCd_W5Regular_11">ShrTwoOp</samp>
    to distinguish it from the existing unary <samp class="SANS_TheSansMonoCd_W5Regular_11">Shr</samp>
    instruction in the assembly AST.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 18-52](chapter18.xhtml#list18-52) defines the updated assembly AST,
    with these changes bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-52: The assembly
    AST with offsets on static operands and bit shift instructions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Converting types and TACKY operands to assembly is pretty simple. Structure
    types, like array types, are converted to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>
    assembly type. To convert a structure type to assembly, you’ll need to look up
    its size and alignment in the type table. We’ll convert TACKY variables of structure
    type to <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> assembly
    operands, just like we do with arrays. We’ll always store arrays and structures
    in memory rather than registers, even once we implement register allocation in
    [Part III](part3.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Some of the TACKY variables you encounter may have incomplete structure types.
    (Remember that it’s legal to declare an <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>
    variable with an incomplete type and take its address, but it’s illegal to define
    it or use it in any other way.) Convert these variables to <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operands, like other variables of structure type. You can give these variables
    a dummy assembly type when you add them to the backend symbol table; that dummy
    type will never be used.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    instructions. Then, we’ll deal with function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copying Structures</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To copy a structure to a new location, you don’t need to consider its members’
    types or offsets; you just need to copy the right number of bytes. To minimize
    the number of <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions
    required, copy 8 bytes at a time until there are fewer than 8 bytes left to move.
    Then, copy 4 bytes at a time. Finally, when there are fewer than 4 bytes left
    to move, copy 1 byte at a time. (There’s also a 2-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction in x64 assembly, but our assembly AST doesn’t support it.) For example,
    if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    are 20-byte structures, you should translate
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: to the assembly in [Listing 18-53](chapter18.xhtml#list18-53).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-53: Implementing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">Copy</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for
    non-scalar values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction
    copies the first 8 bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>; the second instruction
    copies the next 8 bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    to the corresponding offset in <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>,
    and the final instruction copies the remaining 4 bytes. These <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instructions are invalid, since their source and destination operands are both
    in memory, but they’ll be rewritten in the instruction fix-up pass.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the same approach to translate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instructions. For
    example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is a 6-byte
    structure, you’ll translate
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: to [Listing 18-54](chapter18.xhtml#list18-54).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-54: Implementing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">Load</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for
    non-scalar values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first instruction copies the pointer into the RAX register. Each subsequent
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction copies a
    chunk of data stored at some offset from the address in RAX to the corresponding
    offset in <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: You can also implement <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    for non-scalar values with a sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instructions; the only difference is that you’ll add the specified offset to each
    instruction’s destination. To give another example with the 6-byte structure <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, you’ll translate
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: to [Listing 18-55](chapter18.xhtml#list18-55).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-55: Implementing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">CopyToOffset</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for
    non-scalar values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you’ll need to implement the new <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    instruction. Like the other TACKY instructions that copy data, it accepts both
    scalar and non-scalar operands. I won’t talk through this instruction in detail;
    you should handle it basically the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend writing a helper function, which I’ll call <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes</samp>,
    that generates assembly instructions to copy an arbitrary number of bytes from
    one <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operand to another. You can use this helper function to implement all five of
    the TACKY copying instructions. It will come in handy again when you need to pass
    structures in memory as arguments and return values.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>
    and extended the other copy instructions to support non-scalar values, you’re
    ready to move on to function calls.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Structures
    in Function Calls</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since the rules for passing and returning structures are complex, let’s talk
    about our overall strategy before diving into the pseudocode. First, we’ll write
    a function to classify each eightbyte of a structure type. Then, we’ll extend
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp> helper
    function, which we introduced back in [Chapter 13](chapter13.xhtml) to help with
    parameter passing on both the caller and callee sides. Remember that this function
    returns three lists: operands passed in general-purpose registers, operands passed
    in XMM registers, and operands passed on the stack. Once we update this function,
    these lists may include both scalar values and eightbytes of structure values.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll introduce another helper function, <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>,
    to split up return values in a similar way. It will return a list of operands
    returned in general-purpose registers, a list of operands returned in XMM registers,
    and a Boolean flag that indicates whether the return value is passed in memory.
    This flag will be <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> only
    when both lists are empty.
  prefs: []
  type: TYPE_NORMAL
- en: When <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>
    processes a scalar value, it will return one empty list, one list with a single
    element, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> flag.
    When it processes a structure, it might produce a more interesting result. Its
    main purpose is to massage both scalar and structure return values into the same
    shape, so we can process them in a uniform way.
  prefs: []
  type: TYPE_NORMAL
- en: Once these helpers are in place, we’ll update how we convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    TACKY instruction to assembly. For the most part, we can pass parameters the same
    way as in earlier chapters. We’ll copy each operand we get from <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>
    into the appropriate register or push it onto the stack, without worrying about
    whether it’s a scalar value or part of a structure. Only a few details will change.
    First, we’ll account for the fact that RDI may not be available if it holds the
    address of the space reserved for the return value. We’ll also need to pass irregularly
    sized eightbytes that can’t be transferred with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction. We’ll write a new helper function to move these eightbytes into registers.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the function’s return value will require larger changes. We’ll use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp> to
    learn where we can find each part of the return value, then copy each part from
    the appropriate register or memory address to its final destination. This will
    require yet another helper function to copy irregularly sized eightbytes *out*
    of registers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll tackle things on the callee side. Here, like on the caller side,
    the way we process parameters will change only slightly, but the way we handle
    return values will change quite a bit. We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>
    again to figure out where to put each part of the return value.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Classifying Structure Types</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ll start with a helper function to classify structure types. We’ll use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp> construct defined in
    [Listing 18-56](chapter18.xhtml#list18-56) to represent the three classes we discussed
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-56: The</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">class</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">construct</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The classification function will return a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp>
    elements, one for each eightbyte of the structure being classified. To classify
    a structure, we’ll first consider its size and then look at the types of its members.
    [Listing 18-57](chapter18.xhtml#list18-57) gives the pseudocode for this process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-57: Classifying
    structure types</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_structure</samp>
    function takes a structure definition from the type table. If the structure is
    larger than 16 bytes, it must be passed in memory, so we return a list of enough
    MEMORY elements to cover the whole structure. For example, if the structure’s
    size is 17 bytes, <samp class="SANS_TheSansMonoCd_W5Regular_11">classify _structure</samp>
    should return <samp class="SANS_TheSansMonoCd_W5Regular_11">[MEMORY, MEMORY, MEMORY]</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, the structure’s classification depends on its member types. We construct
    a list of every scalar type the structure contains, including the types of nested
    values ❶. Suppose a structure contains two members: an <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp> and a <samp class="SANS_TheSansMonoCd_W5Regular_11">char[3]</samp>. The
    resulting <samp class="SANS_TheSansMonoCd_W5Regular_11">scalar_types</samp> list
    will be <samp class="SANS_TheSansMonoCd_W5Regular_11">[Pointer(Int), Char, Char,
    Char]</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: If a structure is between 8 and 16 bytes, we return a list of two classes ❷.
    Because a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> has a size
    and alignment of 8 bytes, any <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    that appears in a structure of this size must completely occupy either the first
    or second eightbyte. Taking advantage of this fact, we examine only the first
    and last elements of <samp class="SANS_TheSansMonoCd_W5Regular_11">scalar_type</samp>.
    If the first element is <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>,
    the first eightbyte must be in the SSE class; otherwise, it must be in the INTEGER
    class. Likewise, the second eightbyte is in the SSE class only if the last element
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">scalar_type</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we classify structures that are 8 bytes or smaller. A structure of
    this size belongs to the SSE class if the first (and only) scalar type it contains
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> ❸. Otherwise, it
    belongs to the INTEGER class ❹.
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can improve on the code in [Listing 18-57](chapter18.xhtml#list18-57)
    by caching the results. You’ll need to maintain a mapping from structure tags
    to their classifications. The first time you classify a particular structure type,
    add the result to this mapping. Then, if you need to classify that structure type
    again, you can just retrieve the result instead of recomputing it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Classifying Parameters</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, we’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>
    function. This function partitions a list of parameters or arguments in three,
    based on whether each one is passed in a general-purpose register, in an XMM register,
    or on the stack. Now, when it processes a value of structure type, it will split
    up the value into eightbytes and add each one to the correct list. [Listing 18-58](chapter18.xhtml#list18-58)
    reproduces the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>
    from [Listing 13-29](chapter13.xhtml#list13-29), with changes bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-58: Extending</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">classify_parameters</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">to support structures</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first change to this function is the new Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">return_in_memory</samp>
    parameter. As the name suggests, this indicates whether the function’s return
    value is passed in memory. If it is, that memory address will be passed in the
    RDI register, leaving one fewer general-purpose register available for other parameters.
    We’ll set <samp class="SANS_TheSansMonoCd_W5Regular_11">int_regs_available</samp>
    accordingly. Then, when we process parameters of integer or pointer type, we’ll
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">int _regs_available</samp>,
    instead of the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>,
    as the number of usable general-purpose registers. (We’ll process parameters of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type exactly the same
    way we did in [Chapter 13](chapter13.xhtml), so I’ve snipped out that bit of the
    listing.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ve reached the interesting part: processing parameters of structure
    type. We’ll start with a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_structure</samp>
    ❶. Then, we’ll check whether the first eightbyte of the structure is in the MEMORY
    class ❷. If it is, the rest of the structure must be too. If not, we’ll try to
    assign each eightbyte to a register. We’ll convert each eightbyte to a <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operand ❸, then add it to one of two lists, <samp class="SANS_TheSansMonoCd_W5Regular_11">tentative_doubles</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">tentative_ints</samp>, based
    on its class. We know that <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>
    is a variable, rather than a constant, because there are no aggregate constants
    in TACKY; the name of that variable will be the base of the <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operand.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we add an eightbyte to <samp class="SANS_TheSansMonoCd_W5Regular_11">tentative_ints</samp>,
    we need to figure out what assembly type to associate it with. Most eightbytes
    are exactly 8 bytes long, so we associate them with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    type. But the final eightbyte in a structure might be shorter. We’ll find each
    eightbyte’s assembly type using the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp>
    helper function ❹, which we’ll walk through in a moment. This function takes two
    arguments: the eightbyte’s offset and the total size of the structure. It will
    use these to figure out the eightbyte’s size, which dictates its assembly type.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve partitioned the whole structure into two tentative lists, we check
    that we have enough free registers to accommodate both of them ❺. If we do, we
    append both lists to their non-tentative equivalents. If we don’t have enough
    registers available, or if the structure belongs to the MEMORY class, we add each
    eightbyte to <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp> instead
    ❻. We use <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">_type</samp> to determine the type of
    each eightbyte we pass on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s walk through <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp>,
    defined in [Listing 18-59](chapter18.xhtml#list18-59).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-59: Associating
    an eightbyte with an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">assembly_type</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The goal here is to figure out what operand size to use when moving this eightbyte
    into a register or onto the stack. First, we calculate the number of bytes between
    the start of this eightbyte and the end of the whole structure ❶. If there are
    more than 8 bytes left in the structure, this isn’t the last eightbyte, so we
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> type. If
    this eightbyte is exactly 8 bytes, 4 bytes, or 1 byte long, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>
    type, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the eightbyte’s size is irregular; it’s not a valid operand size
    for assembly instructions. In this case, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>
    type to record the eightbyte’s exact size in bytes ❷. (The alignment in this <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp> is a dummy value; we
    won’t need it later.) We can’t safely transfer an irregularly sized eightbyte
    with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction.
    As you learned in [Chapter 9](chapter9.xhtml), reading past the end of a value
    in memory—by pushing a 4-byte value with an 8-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp>
    instruction, for example—could trigger a memory access violation. By the same
    logic, it’s not safe to transfer a 5-, 6-, or 7-byte operand with an 8-byte <samp
    class="SANS_TheSansMonoCd_W5Regular_11">movq</samp> instruction or a 3-byte operand
    with a 4-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction.
    We’ll look at how to transfer irregularly sized eightbytes in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp>
    doesn’t consider the eightbyte’s class; it will return <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    for any full-length eightbyte, even if it belongs to the SSE class. This is correct
    because we use <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp>
    only to find the types of values we’re going to transfer in general-purpose registers
    or on the stack. When we push 8 bytes of a structure onto the stack, we don’t
    care whether those bytes contain a floating-point value or an integer.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Classifying Return Values</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, we’ll write a similar helper function to classify return values. This
    function is simpler than <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>.
    We have one value to deal with, instead of a whole list, so we don’t need to worry
    about running out of registers. We also don’t need to split up the value into
    eightbytes if it will be returned in memory, like we did in <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>.
    [Listing 18-60](chapter18.xhtml#list18-60) shows the pseudocode for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp> helper function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-60: Classifying
    return values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If the return value is a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    the first of our two lists, which contains operands returned in general-purpose
    registers, will be empty. The second list, which holds operands returned in XMM
    registers, will contain the return value. The flag signaling that the value is
    returned in memory will be <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    ❶. If the return value is some other scalar type, we’ll add it to the list of
    operands returned in general-purpose registers, along with its type. The list
    of operands in XMM registers will be empty, and the flag will still be <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the return value must be a structure. We’ll look up its classes with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_structure</samp>, then
    check whether it belongs to the MEMORY class. If it does, we’ll return two empty
    lists, which indicate that nothing will be returned in registers, and a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp> flag, which indicates that
    the return value will be passed in memory ❸.
  prefs: []
  type: TYPE_NORMAL
- en: If the structure isn’t in the MEMORY class, it will be returned in registers.
    We’ll convert each eightbyte to a <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp>
    operand and add it to either <samp class="SANS_TheSansMonoCd_W5Regular_11">double_retvals</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">int_retvals</samp>, according
    to its class ❹. Here, as in <samp class="SANS_TheSansMonoCd_W5Regular_11">classify
    _parameters</samp>, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">get_eightbyte_type</samp>
    to find the assembly type of each operand in <samp class="SANS_TheSansMonoCd_W5Regular_11">int_retvals</samp>.
    Finally, we’ll return both lists, along with a <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing FunCall</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, let’s update how we implement function calls in assembly. [Listing 18-61](chapter18.xhtml#list18-61)
    reproduces the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_function_call</samp>
    from [Listing 13-31](chapter13.xhtml#list13-31), with changes bolded and some
    unchanged code omitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-61: Supporting structures
    in function calls</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We start by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>
    (unless the function call doesn’t have a return value because its return type
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>) ❶. If we find that
    the return value will be passed in memory, we convert <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    into an assembly operand, then emit an instruction to load its address into RDI
    ❷. We also increment <samp class="SANS_TheSansMonoCd_W5Regular_11">reg_index</samp>
    so that we’ll pass the first integer argument in RSI instead of RDI.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>,
    passing it the new <samp class="SANS_TheSansMonoCd_W5Regular_11">return_in_memory</samp>
    flag. Then, we adjust the stack pointer (I’ve omitted this step because it’s the
    same as in earlier chapters).
  prefs: []
  type: TYPE_NORMAL
- en: We then pass arguments in the general-purpose registers. If an argument has
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp> type, its size
    isn’t exactly 1, 4, or 8 bytes, so transferring it into the register will take
    multiple instructions. We emit those instructions with the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp>
    helper function ❸, which we’ll look at in a moment. If an argument has any other
    type, we transfer it with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instruction, as in earlier chapters. The way we pass arguments in XMM registers
    won’t change, so I’ve snipped out that step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is passing arguments on the stack. The way we pass operands with
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>
    won’t change. To pass an irregular operand with a <samp class="SANS_TheSansMonoCd_W5Regular_11">ByteArray</samp>
    type, we first need to subtract 8 bytes from RSP to allocate the stack slot for
    that operand ❹. (Remember that the ABI reserves an entire 8-byte stack slot for
    each eightbyte of a structure parameter, even if the actual eightbyte is smaller
    than that.) To copy the operand into that stack slot, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes</samp>
    helper function we’ve already written. Suppose <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is a global variable and its size is 3 bytes. We’ll issue these instructions to
    pass it as an argument on the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: These <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp> instructions
    are invalid, since both operands are in memory; we’ll rewrite them in the instruction
    fix-up pass.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we issue the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instruction and restore the stack pointer to its original location. I’ve snipped
    out these steps because they’re unchanged from earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we copy the return value to the destination. If the return value is
    transferred in memory, we don’t do anything; the callee already copied it for
    us. Otherwise, we iterate over the two lists of destination operands returned
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp>—first
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int_dests</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">double_dests</samp>—and
    retrieve each operand from the corresponding register. To retrieve an irregularly
    sized eightbyte from a general-purpose register, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_from_reg</samp>
    helper function ❺, which we’ll define in a moment. This is the counterpart to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp>, which
    we used to pass parameters. We emit a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instruction to retrieve a <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    value from a general-purpose register ❻ or to retrieve a <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>
    value from an XMM register ❼.
  prefs: []
  type: TYPE_NORMAL
- en: The code to copy the return value to <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    works whether <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> is a structure
    or a scalar object. If it’s a structure, each item in <samp class="SANS_TheSansMonoCd_W5Regular_11">int_dests</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">double _dests</samp> is an eightbyte
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>, which we’ll populate
    from the corresponding return register. If <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    is scalar, either <samp class="SANS_TheSansMonoCd_W5Regular_11">int_dests</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">double_dests</samp> will have
    exactly one element, and the other list will be empty. In that case, this code
    will emit a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction
    to transfer the return value from RAX or XMM0 to its destination.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Transferring Irregular Structures
    in Registers</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We still need to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_from_reg</samp>,
    which copy irregularly sized eightbytes to and from general-purpose registers.
    This is trickier than copying between two locations in memory, like we do in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes</samp>, because we can’t directly
    access every individual byte in a general-purpose register. We can access a general-purpose
    register’s lowest byte with the appropriate 1-byte alias, like AL or DIL, but
    we can’t access its other bytes individually. (Each register’s second-lowest byte
    also has its own alias—for instance, AH is the second-lowest byte of RAX—but our
    assembly AST doesn’t support these aliases. Even if it did, we still couldn’t
    access the other 6 bytes.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use our new bit-shifting instructions to work around this limitation.
    Let’s revisit the 3-byte global variable <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    from our last example. If we need to copy <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    into RDI, we’ll issue the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: We start by copying the *last* byte of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    into the lowest byte of RDI, whose alias is DIL. Then, we issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>
    instruction to shift RDI 1 byte to the left. This moves the byte we just copied
    into the second-lowest byte of RDI and zeroes out DIL. Next, we copy the middle
    byte of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> into DIL and issue
    another <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> instruction.
    At this point, the last 2 bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    are in the correct place in the register, so we just move the first byte of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> into DIL, and we’re done. [Figure
    18-7](#fig18-7) shows the contents of RDI (in hexadecimal) after each instruction,
    if <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> contains the bytes <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x2</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">0x3</samp>, and RDI’s initial
    value is 0.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig18-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-7: Transferring a
    structure into a register a byte at a time [Description](description-49.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t let the byte ordering here throw you off: because our system is little-endian,
    the least significant (rightmost) byte in RDI corresponds to the lowest memory
    address when we copy the value from RDI into memory, or vice versa. This means—somewhat
    counterintuitively—that shifting a value to the *left* moves each byte to a location
    that corresponds to a *higher* memory address. If, after copying this structure
    into RDI, we issue the instruction'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: then the contents of memory will look like [Figure 18-8](#fig18-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig18-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-8: The contents of
    memory after copying a structure from a register [Description](description-50.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now the structure is laid out in memory in the correct order. (This <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    instruction also writes 1 byte of memory past the end of the structure, which
    is fine if you aren’t using that byte for anything else. We’ll transfer irregularly
    sized structures in and out of registers 1 byte at a time, but code in other translation
    units that we interact with may transfer them in 4- and 8-byte chunks when it’s
    safe to do so.)
  prefs: []
  type: TYPE_NORMAL
- en: That’s the basic idea of <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes_to_reg</samp>;
    now let’s implement it. [Listing 18-62](chapter18.xhtml#list18-62) gives the pseudocode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-62: Generating instructions
    to copy bytes from memory into a register</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function copies <samp class="SANS_TheSansMonoCd_W5Regular_11">byte_count</samp>
    bytes from <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp> into <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst_reg</samp>. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp>
    is part of a structure, we can assume it’s a memory operand that accepts an offset,
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp>.
    We iterate over the bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp>
    in reverse order: we start at its final byte, with offset <samp class="SANS_TheSansMonoCd_W5Regular_11">byte_count
    - 1</samp>, and end at byte zero. We use a simple helper function, <samp class="SANS_TheSansMonoCd_W5Regular_11">add_offset</samp>,
    to construct the assembly operand for each byte. I won’t give you the pseudocode
    for this function, since it just adds the specified offset to <samp class="SANS_TheSansMonoCd_W5Regular_11">src_op</samp>.
    For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">src _op</samp> is
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem("x", 2)</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">add_offset(src_op, 3)</samp> should return
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PseudoMem("x", 5)</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the assembly operand for the current byte, we emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instruction to copy that byte into the destination register. Next, on all but
    the last loop iteration, we emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Shl</samp>
    instruction to shift the whole register left by 8 bits. We then decrement the
    offset and move on to the next byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy bytes out of a register, we do the whole thing in reverse. Here’s how
    we would copy 3 bytes from RDI onto the stack at <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: First, we copy the lowest byte of RDI into memory. Then, we shift RDI 1 byte
    to the right, so DIL now contains the second-lowest byte of the structure. We
    repeat this process until we’ve transferred every byte. [Listing 18-63](chapter18.xhtml#list18-63)
    gives the pseudocode to generate these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-63: Generating instructions
    to copy bytes from a register into memory</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As in [Listing 18-62](chapter18.xhtml#list18-62), we can assume that <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_op</samp>
    is a memory operand with an offset. We iterate through the bytes of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_op</samp>
    in order, starting with byte zero. On each iteration, we copy the lowest byte
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">src_reg</samp> into the current
    byte of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_op</samp>. Then, on
    all but the last iteration, we shift <samp class="SANS_TheSansMonoCd_W5Regular_11">src_reg</samp>
    8 bits to the right.
  prefs: []
  type: TYPE_NORMAL
- en: With these two helper functions, we’ve finished our implementation of function
    calls. Next, we’ll handle the callee side.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Up Function Parameters</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At the start of a function, we copy every parameter into that function’s stack
    frame. Now we’ll copy parameters of structure type too. The main wrinkle is that
    RDI might hold a pointer to the return value’s destination, instead of an ordinary
    parameter. Let’s revisit <samp class="SANS_TheSansMonoCd_W5Regular_11">set_up_parameters</samp>,
    from [Listing 13-30](chapter13.xhtml#list13-30), and see what’s changed. [Listing
    18-64](chapter18.xhtml#list18-64) gives the new definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">set_up
    _parameters</samp>, with this chapter’s changes bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-64: Copying function
    parameters to the stack</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve added a <samp class="SANS_TheSansMonoCd_W5Regular_11">return_in_memory</samp>
    flag, which we’ll pass through to <samp class="SANS_TheSansMonoCd_W5Regular_11">classify
    _parameters</samp>. This flag also dictates how we’ll handle the value in RDI.
    If RDI points to the return value’s destination, we’ll copy it to the first open
    slot on the stack, <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>;
    we’ll retrieve it from this slot when we need to return a value. (In the next
    section, we’ll update the pseudo-operand replacement pass so it doesn’t clobber
    this pointer by assigning a local variable to the same spot.) In this case, we’ll
    also increment <samp class="SANS_TheSansMonoCd_W5Regular_11">reg_index</samp>,
    just like we did when we passed arguments in [Listing 18-61](chapter18.xhtml#list18-61),
    so that we’ll look for ordinary parameters starting in RSI instead of RDI.
  prefs: []
  type: TYPE_NORMAL
- en: To copy irregularly sized operands out of registers, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy
    _bytes_from_reg</samp> helper function from [Listing 18-63](chapter18.xhtml#list18-63).
    To copy irregularly sized operands that were passed on the stack, we’ll use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_bytes</samp> helper function.
    If an operand has type <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>, we’ll copy it
    into place with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instruction, regardless of whether it represents a scalar value or a chunk of
    a structure.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing Return</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 18-65](chapter18.xhtml#list18-65) illustrates how to convert the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction to assembly.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-65: Implementing
    the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Return</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">instruction</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the function returns a value, rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    we start by classifying that value. Then, we check whether we need to return it
    in memory or in registers. To return it in memory, we first retrieve the pointer
    to the destination from <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>.
    We copy that pointer into RAX, as the System V calling convention requires ❶.
    Then, we copy the return value into the block of memory that RAX points to. We
    perform this copy using the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy
    _bytes</samp> helper function ❷.
  prefs: []
  type: TYPE_NORMAL
- en: If the return value is passed in one or more registers, we iterate through the
    operands in <samp class="SANS_TheSansMonoCd_W5Regular_11">int_retvals</samp>,
    copying each one into the corresponding general-purpose register ❸. We then iterate
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">double_retvals</samp>, copying
    these values into XMM0 and XMM1 ❹. Once we’ve copied every part of the return
    value to the correct location, we emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp>
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Tracking Which Functions Pass
    Return Values in Memory</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Finally, we’ll extend the backend symbol table to track which functions return
    values in memory. [Listing 18-66](chapter18.xhtml#list18-66) shows how to update
    our definition of a backend symbol table entry.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-66: The updated
    definition of an entry in the backend symbol table</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As you’d expect, we’ll set <samp class="SANS_TheSansMonoCd_W5Regular_11">return_on_stack</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> if a function passes
    its return value on the stack and <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    if it passes its return value in registers or returns <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
    The pseudo-operand replacement pass will use this flag to figure out if the quadword
    starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp> is available
    or if it holds the pointer to the memory where the return value will be passed.
    If a function has an incomplete return type other than <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    (which can happen if it’s declared but never defined or called), the <samp class="SANS_TheSansMonoCd_W5Regular_11">return_on_stack</samp>
    flag will never be used, so we can just set it to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Putting It All Together</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve now covered all the pieces of assembly generation! [Tables 18-1](chapter18.xhtml#tab18-1)
    through [18-4](chapter18.xhtml#tab18-4) summarize the latest updates to the conversion
    from TACKY to assembly; as usual, new constructs and changes to the conversions
    for existing constructs are bolded. [Appendix B](appendix-B.xhtml) includes the
    complete conversion from TACKY to assembly for this chapter, since this is the
    final chapter in [Part II](part2.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 18-1:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Top-Level TACKY Constructs to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '| <samp class="SANS_Futura_Std_Book_11">Return value in registers'
  prefs: []
  type: TYPE_NORMAL
- en: or no return
  prefs: []
  type: TYPE_NORMAL
- en: value</samp> |
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">Return value on stack</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 18-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Return on stack</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">Return in registers</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_Futura_Std_Book_11">No return value</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '| <samp class="SANS_Futura_Std_Book_11">Scalar</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Structure</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '| <samp class="SANS_Futura_Std_Book_11">Scalar</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Structure</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '| <samp class="SANS_Futura_Std_Book_11">Scalar</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Structure</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">src</samp> <samp class="SANS_Futura_Std_Heavy_B_11">is
    a structure</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst is scalar</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst is a structure</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst will be'
  prefs: []
  type: TYPE_NORMAL
- en: returned
  prefs: []
  type: TYPE_NORMAL
- en: in
  prefs: []
  type: TYPE_NORMAL
- en: memory</samp> |
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst will be'
  prefs: []
  type: TYPE_NORMAL
- en: returned
  prefs: []
  type: TYPE_NORMAL
- en: in
  prefs: []
  type: TYPE_NORMAL
- en: registers</samp> |
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> <samp class="SANS_Futura_Std_Book_11">is
    absent</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 18-3:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Operands to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operand</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 18-4:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Types to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Structure(tag)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Alignment from type table</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Note that we now include offsets on every <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operand we generate. The only <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operands at this point represent floating-point constants; these include the constants
    we use in the conversions for floating-point <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp> in [Table
    18-2](chapter18.xhtml#tab18-2) and ordinary floating-point TACKY constants in
    [Table 18-3](chapter18.xhtml#tab18-3). These operands all have an offset of zero.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudo-operands</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll make two small changes to this pass. First, we’ll supply offsets for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operands. For example, if
    <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp> is a static variable, we’ll
    convert
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Second, we need to avoid clobbering the return value pointer in <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>.
    Before we start allocating stack space, we’ll check the backend symbol table to
    see whether the function’s return value will be passed in memory. If it will,
    we’ll reserve the quadword starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>
    for the return value pointer and allocate space for pseudoregisters only at addresses
    lower than <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>. For
    example, if the first pseudoregister we encounter is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>,
    we’ll map it to <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The instruction fix-up pass won’t change in this chapter. The <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp> instructions we emit
    during code generation are already valid and don’t need to be fixed up, since
    the destination operand is always a register and the source operand is always
    the immediate value <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code emission pass requires two small changes. First, we’ll include the
    offsets on <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operands.
    For example, we’ll emit <samp class="SANS_TheSansMonoCd_W5Regular_11">Data("x",
    4)</samp> as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: If the offset is zero, you can either include it or omit it.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we’ll emit the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Shl</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ShrTwoOp</samp> assembly instructions
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>,
    respectively. These take the usual operand size suffixes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Tables 18-5](chapter18.xhtml#tab18-5) and [18-6](chapter18.xhtml#tab18-6)
    show these changes to the code emission pass. [Appendix B](appendix-B.xhtml) includes
    the complete code emission pass for this chapter, since this is the final chapter
    of [Part II](part2.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 18-5:</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    Names for Assembly Operators</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operator</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Instruction name</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Shl</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">shl</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ShrTwoOp</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">shr</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 18-6:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Data(identifier</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">, int</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><identifier></samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">+</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><int></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(%rip)</samp> |'
  prefs: []
  type: TYPE_TB
- en: And with that, you’re done with the chapter; your compiler now supports structures!
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: Unions</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Structure and union types have a lot in common. Their type declarations share
    the same syntax and declare tags in the same namespace. They follow the same typing
    rules and support the same operations, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> operators. The difference
    is that the members of a structure are laid out sequentially in memory, whereas
    the members of a union all start at the same address, such that writing to one
    overwrites the others. From the compiler’s perspective, a union is basically a
    structure where every member’s offset is zero. This makes it relatively straightforward
    to extend the work you did in this chapter to support unions too. Still, this
    is a bigger challenge than previous extra credit features. It’s an opportunity
    to add a new language feature on your own.
  prefs: []
  type: TYPE_NORMAL
- en: If you implement union types, there are a few points you should keep in mind.
    First, remember that we restricted where structures can be declared to make compilation
    easier. The test cases for unions also follow the same restrictions; that means
    you don’t need to support anonymous union declarations or union declarations that
    are part of declarations of some other type or variable.
  prefs: []
  type: TYPE_NORMAL
- en: In the type checker, you’ll add union definitions to the type table. Structure
    and union tags share a namespace, so defining a structure and a union type with
    the same tag in the same scope is an error. You’ll need to track each union’s
    size and alignment (you can look up how to calculate these in the System V ABI).
    You’ll also need to type check compound initializers for unions. A union initializer
    should have a single element, which initializes the union’s first member. (C provides
    syntax to specify which union member to initialize, but you don’t have to implement
    it.)
  prefs: []
  type: TYPE_NORMAL
- en: On the backend, the System V calling convention treats unions similarly to structures;
    a union will be passed in memory, in two registers, or in one register, depending
    on its size and the types of its members. For all the gory details, see the links
    in “Additional Resources.” Good luck!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--union</samp>
    flag to test your compiler’s support for union types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Or, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>
    flag to test every extra credit feature.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve finished [Part II](part2.xhtml)! In this chapter, you learned how to
    analyze structure type declarations, manipulate aggregate objects in TACKY, and
    transfer structures according to the System V calling convention. Your compiler
    now supports every language feature this book covers, including most of the statements,
    expressions, and types in the C language. You can officially tell people that
    you’ve written a C compiler.
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can stop here. Or, you can move on to [Part III](part3.xhtml),
    where you’ll implement several compiler optimizations to generate more efficient
    assembly code. In [Chapter 19](chapter19.xhtml), you’ll optimize TACKY programs
    by eliminating useless instructions and evaluating constant expressions at compile
    time. In [Chapter 20](chapter20.xhtml), you’ll write a register allocator, which
    maps pseudoregisters to hardware registers instead of locations on the stack.
    These optimizations aren’t specific to C or x64 assembly; you’ll find them in
    compilers with lots of different source and target languages.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to learn about the complete System V x64 calling convention, including
    all the rules for passing structures and unions, you have a couple of options:'
  prefs: []
  type: TYPE_NORMAL
- en: The official System V x86-64 ABI is available at *[https://<wbr>gitlab<wbr>.com<wbr>/x86<wbr>-psABIs<wbr>/x86<wbr>-64<wbr>-ABI](https://gitlab.com/x86-psABIs/x86-64-ABI)*.
    (I’ve linked to this a couple of times already.) Section 3.2.3 discusses parameter
    passing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agner Fog has written a helpful manual describing the calling conventions of
    different C++ compilers (*[https://<wbr>www<wbr>.agner<wbr>.org<wbr>/optimize<wbr>/calling<wbr>_conventions<wbr>.pdf](https://www.agner.org/optimize/calling_conventions.pdf)*).
    Tables 6 and 7, in Section 7.1, cover how structures are passed and returned.
    The document covers C++, so parts of it aren’t relevant, but the description of
    how to pass plain structures and unions applies to C as well as C++.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I found Fog’s summary of calling conventions easier to follow than the official
    ABI. If you decide to implement unions for extra credit, you’ll probably need
    to refer to both documents.
  prefs: []
  type: TYPE_NORMAL
