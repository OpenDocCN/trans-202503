<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_279"/><span class="big">9.</span> hardware hacking</h2>&#13;
<p class="noindent">The biggest barrier to hacking is often the fear that you’ll break something while poking around. But you have to break eggs to make an omelet; likewise, you have to be willing to sacrifice devices to hack a system. Fortunately, acquiring multiple copies of a mass-produced piece of hardware is easy. I often do a bit of dumpster diving or check classified advertisements to get sample units for research purposes. I generally try to start with three copies: one to tear apart and never put back together, one to probe, and one to keep relatively pristine. I use the pristine copy to sanity-check whether a certain behavior is due to my probing or just how the hardware behaves.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_280"/>My typical approach to any hardware hack is first getting the device open and then getting a probe in just the right spot without affecting the device’s functionality. When you’re looking inside computer chips, that’s virtually the entire challenge. The first hack in this chapter is an example of silicon hacking, and you’ll see that once the package is off and you’re staring at naked silicon, an attacker has a profound advantage.</p>&#13;
<p class="indent">Some hardware hacks require more system engineering, particularly when you want to reverse engineer and repur-pose a device. In these situations, I tend to develop additional bespoke tools that allow me to tweak and observe a system in close to real time, or at least as fast as I can type commands, to minimize the time spent validating hypotheses. The goal is to make the primary limitation how fast you can think of ideas to test, not how long it takes to upload a change to test those ideas. The second hack in this chapter talks about reverse engineering a relatively simple System-on-Chip (SoC) device found inside common SD memory cards and some tools I developed to aid that process.</p>&#13;
<p class="indent">Finally, some hacks inevitably push the boundaries of the law. The third hack in this chapter talks about NeTV, a system I developed that takes a new look at the High-Definition Content Protection (HDCP) encryption standard, which secures most HDMI video links. NeTV is a hack on both a legal issue and a hardware system. It works around the thorny problems presented by the DMCA by reinterpreting the HDCP standard to enable a man-in-the-middle (MITM) attack to change video data without circumventing encryption. No circumvention, no DMCA problem. Hacks often push the boundary of what’s legal and what’s been tested in the courts. Just like any other system, the legal system can also be hacked, and one key takeaway from this chapter is how to think of laws as just another constraint to work with on the way to achieving a particular goal.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_281"/>The final hack in this chapter combines hardware penetration, tool creation, and legal considerations to reverse engineer a complex mobile phone SoC. That’s another project I worked on with xobs, and once again, building bespoke hacking tools was invaluable because it allowed us to experiment with the system as it ran.</p>&#13;
<h3 class="h3" id="ch00lev1sec160"><strong>HACKING THE PIC18F1320</strong></h3>&#13;
<p class="noindenta">Keeping a secret is a common challenge for any security system. To solve this challenge, security system designers frequently hide secrets inside silicon chips because the chips’ rugged epoxy packages and tiny geometries are difficult to penetrate and inspect.</p>&#13;
<p class="indent">This sounds good in theory but is problematic in practice. Chip designers make mistakes, and when a chip has a problem, the designers need a way to open it up and investigate. This situation is so common that there are commercial services that specialize in opening up chips expressly for that purpose. Called <em>failure analysis services</em>, they’ve mastered several techniques for removing tough epoxy from chips.</p>&#13;
<p class="indent">A couple of years before my crash course in setting up a Chinese supply chain with Chumby, I decided it would be fun to demonstrate how simple hacking a chip can be if you’re aware of failure analysis services. At the time, Microchip’s PIC series of microcontrollers was quite ubiquitous, so I decided to have a go at a popular PIC model. PICs typically have <em>configuration fuses</em>, which you can activate to prevent certain regions of memory from being read or written to. But there’s often a legitimate need to read the contents of a secured, programmed PIC. For instance, a company that loses either the documentation for a product or the personnel that originally created the codes for a secured PIC would be stuck without a way to read the chip. This is a problem when a company needs to revise or upgrade a legacy line of products.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_282"/>I wanted to figure out how to dump the memory from a secured PIC. Knowing I’d have to break a few eggs to make this omelet, I scored four PIC18F1320s from a friend and started stripping them down. Here’s what I found.</p>&#13;
<div class="image"><img alt="image" src="../images/f0282-01.jpg"/></div>&#13;
<p class="cap"><em>A PIC18F1320 in its native state</em></p>&#13;
<h4 class="h4" id="ch00lev1sec161"><strong>Decapping the IC</strong></h4>&#13;
<p class="noindenta">First, I had to take the top off so I could see the silicon under the hood. Many homebrew techniques for decapping a chip typically involve applying fuming nitric or sulfuric acid, but those aren’t compounds you’d want to keep at home, nor are they easy to obtain. Nitric acid, in particular, is an important compound for explosives fabrication. So, I’ve found the easiest and most reliable way to decap a chip is to just send it to a failure analysis lab. For about $50, you can have a decapped part in two days.</p>&#13;
<p class="indent">I decapped three parts for this project. Two were <em>functionally decapped</em> (silicon revealed with the device still in its lead frame, fully functional), and the last was <em>fully decapped</em> (just a bare silicon die with no package). I had one die fully decapped because my inspection microscope had a very short working distance at the highest magnifications, and the remaining epoxy from the package would have interfered with the lens.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_283"/><img alt="image" src="../images/f0283-01.jpg"/></div>&#13;
<p class="cap"><em>A functionally decapped PIC18F1320.<br/>The little raised square in the middle (it’s goldish in real life) is the silicon chip.</em></p>&#13;
<h4 class="h4" id="ch00lev1sec162"><strong>Taking a Closer Look</strong></h4>&#13;
<p class="noindenta">With my decapped ICs in hand, I did a sweep around one of the dies with the microscope and noticed several prominent features. Because physics is the same everywhere, most of the fine-grained structure in a silicon chip looks pretty much the same, no matter who makes the chip. These constraints propagate their way up to the system level, and with a bit of training, you can read a silicon chip like a book.</p>&#13;
<div class="image"><img alt="image" src="../images/f0283-02.jpg"/></div>&#13;
<p class="cap"><em>My best guess at what various structures in this chip do. I could be wrong.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_284"/>One set of structures grabbed my attention immediately: there were metal shields over some transistors, following a regular pattern that had about the right number of devices to account for all the security bits. Full-metal shields covering a device are very rare in silicon, so they’re like a big X marking the spot where something very important is kept.</p>&#13;
<div class="image"><img alt="image" src="../images/f0284-01.jpg"/></div>&#13;
<p class="cap"><em>Zooming in on the metal shields</em></p>&#13;
<h4 class="h4" id="ch00lev1sec163"><strong>Erasing the Flash Memory</strong></h4>&#13;
<p class="noindenta">The shields were significant because of some interesting facts about flash memory technology, which this PIC device used to store the security fuse information, as well as the internal program code. Flash technology uses a floating-gate transistor structure very similar to old <em>UV-erasable programmable read-only memory (UV-EPROM)</em> technologies like the ceramic-packaged 2716 chips from the 1970s, which had quartz windows so they could be erased.</p>&#13;
<p class="indent">In both flash and UV-EPROM devices, data is written when electrons tunnel into a floating gate, where the electrons remain for decades. The extra electrons in the floating gate <span epub:type="pagebreak" id="page_285"/>create a measurable offset in the characteristics of the storage transistor. The difference is that flash memory can withdraw the stored electrons (erase the device) using only electrical pulses, while a UV-EPROM requires energetic photons to knock the electrons out of the floating gate. The UV light required to accomplish this is typically on a wavelength of around 250 nm. You need expensive quartz optics to manipulate this wavelength of UV without excessive loss, making it a bit difficult to harness.</p>&#13;
<p class="indent">Here’s the important conclusion I drew from these facts: flash devices can usually <em>also</em> be erased using UV light since they have a similar transistor structure to UV-EPROM devices. The encapsulation around a flash device normally prevents any UV light from effectively reaching the die, but since the PIC devices had the plastic around them removed, I could attempt to apply UV light and see what happened.</p>&#13;
<p class="indent">I performed a simple experiment by programming the PIC device with a ramping pattern, where I stored the hexadecimal numbers from 0x00 to 0xFF over and over again. Then, I tossed the PIC into my UV-EPROM eraser to bake for ... oh, about the length of a good long shower and some email checking. When I took the device out of the eraser, the flash memory was indeed blanked to its normal all 1s state, and the security fuses were unaffected. After baking a few more PIC devices in the eraser, I found that if I didn’t bake a PIC long enough, I got odd readings out of the array I wrote to, such as all 0s, a phenomenon that I still don’t understand.</p>&#13;
<h4 class="h4" id="ch00lev1sec164"><strong>Erasing the Security Bits</strong></h4>&#13;
<p class="noindenta">Clearly, the metal shields over the security fuses were there to thwart attempts to selectively erase the security fuses while leaving the flash memory array unaffected.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_286"/><img alt="image" src="../images/f0286-01.jpg"/></div>&#13;
<p class="cap"><em>A diagram showing how the shields got in the way of the fuse bits, and how to work around them</em></p>&#13;
<p class="indent">My problem was that for the flash memory transistor to be erased, high-intensity UV light needed to strike the floating gate. The metal shield effectively reflected all incident light, so the light never reached the gate. But I knew there was a refraction index mismatch between the optically clear protective dielectric layer of silicon dioxide covering the chip and the silicon proper, meaning light at certain angles would reflect off of the smooth silicon surface. For an example of this reflective effect, jump in a swimming pool, go under water, and look up at where the water and air meet. The water should look highly reflective at an oblique angle because the refractive index mismatch between water and air causes total internal reflection of light.</p>&#13;
<p class="indent">I planned to use this reflection to bounce the UV light off the oxide to hit the metal shield and bounce back onto the floating gate. By angling the PIC inside the ROM eraser, I thought I could get enough light to bounce into the flash memory transistor region and erase the security bits. After a couple of attempts using bits and bobs of material to fix the angle of the chip, I developed a simple technique that worked surprisingly well: shoving the chip into the antistatic foam liner of the UV eraser at an angle.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_287"/><img alt="image" src="../images/f0287-01.jpg"/></div>&#13;
<p class="cap"><em>The chip in the UV eraser’s antistatic foam</em></p>&#13;
<h4 class="h4" id="ch00lev1sec165"><strong>Protecting the Other Data</strong></h4>&#13;
<p class="noindenta">That technique didn’t protect the flash data I wanted to keep, though. To avoid erasing this data, I made a hard mask out of a very carefully cut piece of electrical tape and stuck that mask to the surface of the die using a steady hand, two tweezers, and a microscope. The electrical tape blocked the UV light from directly hitting the flash code memory regions and somewhat absorbed light bounced back from the silicon substrate.</p>&#13;
<div class="image"><img alt="image" src="../images/f0287-02.jpg"/></div>&#13;
<p class="cap"><em>The die in its package, with electrical tape over the flash ROM array</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_288"/>This mask allowed me to reset only the security fuses without impacting the flash code array too much. The following screenshots show the array memory status according to the programming and readback tool I was using.</p>&#13;
<div class="image"><img alt="image" src="../images/f0288-01.jpg"/></div>&#13;
<p class="cap"><em>My PIC programmer workspace, showing the device settings before erasure The device settings after erasure</em></p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_289"/><img alt="image" src="../images/f0288-02.jpg"/></div>&#13;
<p class="cap"><em>The device settings after erasure</em></p>&#13;
<p class="indent">In the before shot, note the settings of the security fuses in the Configuration Bits window and the values programmed in the flash ROM, shown in the Program Memory window. In the after shot, the security fuses switch to being disabled, while the flash ROM contents in the Program Memory window read identically to what was programmed in previously. A different part of the code array was actually still erased, but I could probably have fixed that by cutting a bigger piece of electrical tape.</p>&#13;
<p class="indent">I’ve heard reports that since this hack was published, Microchip started putting metal shields over the code memory array as well as the fuses, making it a bit more difficult to pull off this trick. Still, this hack underscores the fact that quite often, the hardest part of silicon hacking is removing the outer package, and fortunately, there are cheap, if obscure, services available to assist with that problem.</p>&#13;
<h3 class="h3" id="ch00lev1sec166"><strong>HACKING SD CARDS</strong></h3>&#13;
<p class="noindenta">Years later, I found myself hacking into yet another interesting device with flash memory: an SD card. I’d already torn down SD cards when investigating a batch of potentially fake cards that found their way into Chumby production units, which I discuss in “<a href="ch05.xhtml#ch00lev1sec99">Fake MicroSD Cards</a>” on <a href="ch05.xhtml#page_156">page 156</a>. This time, my intent was to figure out how to get an SD card to do something it wasn’t made to do. This particular hack was another team effort with my friend xobs, and it was funded by DARPA’s Cyber Fast Track (CFT) initiative. The brainchild of uberhacker .mudge (one of the original crew of L0pht), CFT was a hack on the US government to make it smarter about innovation, particularly on matters related to internet security. We pulled it off around the same time we were working on Novena and I was collaborating with Jie Qi on Chibitronics.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_290"/>xobs and I discovered that some SD cards contain vulnerabilities that allow arbitrary code execution on the memory cards themselves. We also found that similar classes of vulnerabilities exist in related devices like USB flash drives and solid-state drives. On the dark side, code execution on a memory card enables MITM attacks where the card seems to behave one way but in fact does something else as an attacker intercepts and manipulates communications between the card and the device using it. On the light side, however, this vulnerability also gives hardware enthusiasts access to a very cheap and ubiquitous source of microcontrollers.</p>&#13;
<div class="image"><img alt="image" src="../images/f0290-01.jpg"/></div>&#13;
<p class="cap"><em>Some of the eggs—or rather, SD cards—we cracked open to find the vulnerability</em></p>&#13;
<h4 class="h4" id="ch00lev1sec167"><strong>How SD Cards Work</strong></h4>&#13;
<p class="noindenta">To understand the hack, you need to know how SD cards are structured. The information I’m about to explain applies to all <em>managed flash</em> devices, which includes microSD, SD, and MMC, as well as the eMMC and iNAND devices typically soldered onto the mainboards of smartphones to store the operating system and other private user data.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_291"/>Flash memory is billed as a contiguous, reliable storage medium, and it’s really cheap—so cheap that the premise is literally too good to be true. In reality, all flash memory is riddled with defects, without exception. It crafts the illusion of reliability through sophisticated error correction and badblock management functions. This system is the result of a constant arms race between the engineers and mother nature: every time the fabrication process shrinks transistors, memory becomes cheaper but more unreliable. Likewise, with every generation of chips, engineers create more sophisticated and complicated algorithms to compensate for nature’s propensity for entropy and randomness at the atomic scale.</p>&#13;
<p class="indent">These algorithms are too complicated and too device-specific to be run at the application or operating system level, so every flash memory disk ships with a reasonably powerful microcontroller to run a custom set of disk abstraction algorithms. Even tiny microSD cards contain not one, but <em>at least</em> two, chips: a controller and at least one flash chip. (High-density cards stack multiple flash dies.)</p>&#13;
<div class="image"><img alt="image" src="../images/f0291-01.jpg"/></div>&#13;
<p class="cap"><em>Inside a microSD card. The small square in the upper-right corner is a microcontroller SoC mounted on top of the larger flash memory chip that it manages.</em></p>&#13;
<p class="indent">In my experience, the quality of the flash chip(s) integrated into memory cards varies widely. The chip could be anything <span epub:type="pagebreak" id="page_292"/>from high-grade, factory-new silicon to material with more than 80 percent bad sectors. If you’re concerned about e-waste, you may (or may not) be pleased to know that memory card vendors commonly use recycled flash chips salvaged from discarded parts. Larger vendors tend to offer more consistent quality, but even the largest players staunchly reserve the right to mix and match flash memory chips with different controllers yet sell the assembly as the same part number. That’s a nightmare if you’re dealing with implementation-specific bugs.</p>&#13;
<p class="indent">A memory card’s embedded microcontroller is often a heavily modified Intel 8051 or ARM CPU that approaches 100 MHz performance levels and has several hardware accelerators on-die. Amazingly, adding these controllers to a memory card only costs about $0.15 to $0.30, particularly for companies that can fab both the flash memory and the controllers in the same business unit. Even more interestingly, due to the high cost of testing chips at the wafer level, it’s probably net cheaper to add a microcontroller that manages bad blocks, rather than thoroughly test and characterize each raw flash memory chip. And in fact, managed flash devices tend to be cheaper per bit than raw flash chips, despite the extra functionality.</p>&#13;
<p class="indent">Every flash implementation has unique algorithmic requirements, multiplying the number of hardware abstraction layers a microcontroller must handle. This complexity inevitably leads to bugs, meaning indelibly burning a static body of code into on-chip ROM just isn’t feasible, particularly for third-party controllers.</p>&#13;
<p class="indent">Thus, a firmware loading and update mechanism is virtually mandatory. End users are rarely exposed to this process since it all happens in the factory, but the mechanism exists. While exploring the electronics markets in China, I’ve seen shopkeepers burn firmware onto a card that “expands” the card’s capacity. In other words, they load firmware that reports the capacity of a card as much larger than the actual <span epub:type="pagebreak" id="page_293"/>available storage. The fact that this is possible at the point of sale indicates the update mechanism is likely not well secured.</p>&#13;
<h4 class="h4" id="ch00lev1sec168"><strong>Reverse Engineering the Card’s Microcontroller</strong></h4>&#13;
<p class="noindenta">xobs and I discovered an example of this vulnerability while exploring memory cards using AppoTech’s AX211 and AX215 microcontrollers. We discovered a simple “knock” sequence transmitted over manufacturer-reserved commands (a command named <span class="literal">CMD63</span> followed by the bytes <span class="literal">A</span>, <span class="literal">P</span>, <span class="literal">P</span>, <span class="literal">O</span>) that dropped the controller into a firmware loading mode. After receiving the knock sequence, the card accepted the next 512 bytes and ran the data as code.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong>NOTE</strong></p>&#13;
<p class="notep"><em>The AppoTech chips I describe here technically integrate sufficient functionality that in an academic sense, they’re not mere microcontrollers; they’re full SoCs. But it’s just</em> weird <em>to me to refer to the AppoTech as an SoC, so I won’t. It will always be a microcontroller to me!</em></p>&#13;
</div>&#13;
<p class="indent">The AppoTech system on this particular memory card also used an 8051 microcontroller. From the knock sequence beachhead, we used a combination of analyzing code with IDA, the interactive disassembler, and <em>fuzzing</em> (that is, giving the microcontroller invalid or random input to see how it responds) to reverse engineer most of the 8051’s function-specific registers. That allowed us to develop novel applications for the controller without the manufacturer’s proprietary documentation. We did most of this work with the Novena laptop hardware I described in <a href="ch07.xhtml#ch07">Chapter 7</a>.</p>&#13;
<p class="indent">As I alluded at the beginning of this chapter, we developed several bespoke tools to help us reverse engineer the SD card. One of the more interesting tools we (and by we, I mean primarily xobs) made is an interactive REPL (read-evaluate-print-loop) shell for executing arbitrary code on the SD card. The following listing shows what that environment looks like.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_294"/>root@bunnie-novena:~/ax211-code# <span class="codestrong">./ax211 -d debug.bin</span><br/>FPGA hardware v1.26<br/>Debug mode APPO response [6]: {0x3f 0x00 0xc1 0x04 0x17 0xab}<br/>Result of factory mode: 0<br/>00000000  0f 41 1f 0f 0f 0f ff ff                      |.A......|<br/>Expected 0x00 0x00, got 0x0f 0x41<br/>Loaded debugger<br/>Locating fixup hooks... Done<br/>AX211&gt; <span class="codestrong">help</span><br/>List of available commands:<br/>   hello Make sure the card is there<br/>    peek Read an area of memory<br/>    poke Write to an area of memory<br/>    jump Jump to an area of memory<br/> dumprom Dump all of ROM to a file<br/>  memset Set a range of memory to a single value<br/>    null Do nothing and return all zeroes<br/>  disasm Disassemble an area of memory<br/>     ram Manipulate internal RAM<br/>     sfr Manipulate special function registers<br/>    nand Operate on the NAND in some fashion<br/>   extop Execute an extended opcode on the chip<br/>   reset Reset the AX211 card<br/>    help Print this help<br/>For more information on a specific command, type 'help [command]'<br/>AX211&gt; <span class="codestrong">help disasm</span><br/>Help for disasm:<br/>Disassemble a number of bytes at the given offset.<br/>Usage: disasm [address] [bytes]<br/>AX211&gt; <span class="codestrong">disasm 0x200 16</span><br/>.org 0x0200<br/>        nop<br/>        nop<br/>        reti<br/><br/>        nop<br/>        mov R7, A<br/>        reti<br/><br/>        mov R7, A<br/>        nop<br/>        mov R7, A<br/>        nop<br/>        mov R7, A<br/>        nop</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_295"/>From inside this environment, we could run programs in a debugger, get a list of available commands and what they did by entering <span class="literal">help</span>, and disassemble sections of code by entering <span class="literal">disasm</span>. Although it took a lot of time to develop an interactive tool with such a rich feature set, the effort quickly paid off because we could test complex hypotheses using automated fuzzing frameworks.</p>&#13;
<p class="indent">The code upload size was limited to 512 bytes, which meant we had to partition the REPL environment between the host Novena computer and the target device.<a href="footnote.xhtml#fn26" id="fn_26">*</a> For example, disassembling a particular region of memory breaks down to a script executed on the host side that drives issue requests to the AX211 to dump the requested portion of memory, followed by the disassembly algorithm running on the host ARM CPU.</p>&#13;
<div class="image"><img alt="image" src="../images/f0295-01.jpg"/></div>&#13;
<p class="cap"><em>Partitioning the SD debugger functions between the host and the target</em></p>&#13;
<p class="indent">The tool we built started with an SD physical emulation layer, which I’ll refer to as <em>PHY</em>. We used the FPGA built into the Novena to present a GPIO-like register API for the SD <span epub:type="pagebreak" id="page_296"/>host PHY. There was one register for data output, one register for data input, and one register to bitwise set the data direction. The AX211 card was attached to the FPGA via a custom flex-circuit adapter.<a href="footnote.xhtml#fn27" id="fn_27">*</a></p>&#13;
<div class="image"><img alt="image" src="../images/f0296-01.jpg"/></div>&#13;
<p class="cap"><em>A flex-circuit adapter plugged into a Novena</em></p>&#13;
<p class="indent">The SD commands were received on the AX211 and processed by a hardware state machine attached to the embedded 8051 CPU. The state machine handled receiving the data, plus it computed and checked the cyclic redundancy code for error detection. Once a complete packet was received by the state machine, an interrupt notified the 8051 of the packet’s arrival.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_297"/>We hijacked the interrupt processing mechanism and remapped the default handler to our own 512-byte code stub. That allowed us to define a novel set of SD commands that we used to implement the callback functions our REPL environment needed, like <span class="literal">peek</span>, <span class="literal">poke</span>, <span class="literal">jump</span>, NAND register manipulation, and so on. These callbacks were also an ideal hook for implementing an MITM attack.</p>&#13;
<div class="image"><img alt="image" src="../images/f0297-01.jpg"/></div>&#13;
<p class="cap"><em>The callback functions for the REPL, displayed in IDA</em></p>&#13;
<p class="indent">I don’t know how many other manufacturers leave their firmware updating sequences unsecured. AppoTech is a relatively minor player in the SD controller world; a handful of companies that you’ve probably never heard of also produce SD controllers, including Alcor Micro, Skymedi, Phison, and SMI. Of course, there are also SanDisk and Samsung. Each has different mechanisms and methods for loading and updating firmware. But I know of at least one Samsung eMMC implementation using an ARM instruction set that had a bug requiring a firmware updater to be pushed to Android devices, indicating yet another potentially promising venue for further discovery.</p>&#13;
<h3 class="h3" id="ch00lev1sec169"><strong><span epub:type="pagebreak" id="page_298"/>Potential Security Issues</strong></h3>&#13;
<p class="noindenta">From a security perspective, our findings indicated that while memory cards look inert, they run code that could be modified to perform MITM attacks that are difficult to detect. There’s no standard protocol or method to inspect and attest to the contents of the code running on the memory card’s microcontroller. If you’re using an SD card in a high-risk, high-sensitivity situation, don’t assume that running a <span class="literal">security-erase</span> command (or some other secure erase tool) on a card will guarantee the complete erasure of sensitive data. If you really need data to disappear, I recommend disposing of your memory card through total physical destruction. Grind it up with a mortar and pestle if you have to.</p>&#13;
<h3 class="h3" id="ch00lev1sec170"><strong>A Resource for Hobbyists</strong></h3>&#13;
<p class="noindenta">From a DIY and hacker perspective, our findings suggested a potentially interesting source of cheap and powerful microcontrollers for use in simple projects. An Arduino clone—with an 8-bit, 16 MHz microcontroller—will set you back around $20. A microSD card with several gigabytes of memory and a microcontroller with several times the performance costs a fraction of the price. While SD cards are admittedly I/O-limited, some clever hacking of the microcontroller in an SD card could make for a very economical and compact data logging solution for I2C or SPI-based sensors.</p>&#13;
<h3 class="h3" id="ch00lev1sec171"><strong>HACKING HDCP-SECURED LINKS TO ALLOW CUSTOM OVERLAYS</strong></h3>&#13;
<p class="noindenta">“That’s neat, but is it legal?” is a frequently asked question I get when hacking. Just as engineered systems have hacks, legal systems have loopholes. Some legal loopholes exist by <span epub:type="pagebreak" id="page_299"/>design; others are unintentional. Either way, they can provide vital breathing room for innovation. When contemplating a hack, I consider legal issues as I do engineering constraints, similar to having to fit something within a case of a certain height or run for a certain length of time on a given battery.</p>&#13;
<p class="indent">Around 2011, when I was still at Chumby, we were puzzling about how to drive adoption in the face of the iPhone and Android phones consuming the market niche we hoped to occupy. Cost was an eternal barrier for user adoption, and the integral LCD in a chumby was by far the highest-cost item. Our then-CEO, Steve Tomlin, observed that the biggest screen in the house had yet to become connected to the internet in any meaningful way. And so this question was posed to me: could we find a way to kill two birds with one stone, removing the screen from our bill of materials while bringing TVs into the internet age? This was before products like the Google Chromecast or the Logitech Revue were introduced on the market.</p>&#13;
<p class="indent">It occurred to us that we could pack a cheap computer into a stick that plugs into an HDMI port. This solves the problem of getting chumby onto a TV screen, but then you’re not watching your favorite movies or TV shows when the chumby is selected. We figured what people really wanted was some way to watch TV and have, say, Twitter or Facebook notifications pop up onscreen, too.</p>&#13;
<p class="indent">The concept is simple enough. Take the existing output from a cable box, Blu-ray player, or AV receiver; feed it into a box that blends in chumby content; and pass the resulting video on to a TV. But due to the ubiquitous application of HDCP encryption over digital video feeds, it is legally perilous to remix content if you do it the wrong way. Figuring out the right way to do it is how NeTV was born.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_300"/><img alt="image" src="../images/f0300-01.jpg"/></div>&#13;
<p class="cap"><em>A NeTV sporting the Chumby logo</em></p>&#13;
<div class="image"><img alt="image" src="../images/f0300-02.jpg"/></div>&#13;
<p class="cap"><em>Inside the NeTV</em></p>&#13;
<h4 class="h4" id="ch00lev1sec172"><strong>Background and Context</strong></h4>&#13;
<p class="noindenta">NeTV was my response to the challenge of remixing existing video with internet content while staying within legal boundaries, aided by the public release of the master key to HDCP in September 2010. To help you understand this hack, let’s start with a little background on HDCP.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_301"/>High-bandwidth Digital Content Protection is a pixel-level encryption system used to encrypt video transmissions over HDMI. HDCP puts broadcasters and studios in control of the screens their content plays on, as those companies use the encryption as a copyright control mechanism. HDCP restricts legitimate content manipulation like picture-in-picture displays, content overlays, and third-party filtering and image modification. Combine HDCP with the DMCA, which criminalizes the circumvention of copyright control, and you’ll realize that when watching certain videos, it’s illegal to modify content on your own screen. That’s why there are few HDMI video mixing solutions that actually operate on broadcast or movie content.</p>&#13;
<p class="indent">To recap, I had four goals for NeTV: enable consumer-side content remixing, allow users to eliminate ads or replace them with ads relevant to themselves, create an interactive TV experience, and make something compatible with any TV. To accomplish those goals, I designed NeTV as a man in the middle to take data from, say, a Blu-ray player, and apply the master key to give users a custom overlay. There are many applications for video overlays, but the basic scenario is that while you’re enjoying content X, you’d also like to be aware of content Y. Combining the two content sources requires a video overlay mechanism.</p>&#13;
<p class="indent">With my MITM attack, NeTV overlaid a WebKit browser (the engine Safari and Chrome use) over any video feed. A concrete use case for this technology is overlaying Twitter feeds as news crawlers across a TV show to watch community commentary in real time on the same screen you’re watching the show on. Some TV programs attempt to incorporate Twitter feeds already, but they’ve only done so on the source side; users can only watch hashtags the show displays. With this hack, however, the same broadcast program (say, a political <span epub:type="pagebreak" id="page_302"/>debate) could have a very different viewing experience based on which hashtag is keyed into the viewer’s Twitter crawler.</p>&#13;
<p class="indent">The simple fact that a trivial video overlay is an interesting topic illustrates the distortion of traditional rights and freedoms brought about by the DMCA. Unlike the HDCP strippers people speculated would come out of the master key’s release, however, my hack never decrypted the original video data it operated on. Thus, it didn’t circumvent copyright, and the DMCA couldn’t apply to it. Loophole found!</p>&#13;
<h4 class="h4" id="ch00lev1sec173"><strong>How NeTV Worked</strong></h4>&#13;
<p class="noindenta">Of course, I released the exploit as an entirely open source project,<a href="footnote.xhtml#fn28" id="fn_28">*</a> including the hardware and the Verilog implementation of the Spartan-6 FPGA I used to create the TMDS-compatible source and sink. TMDS is the signaling standard used by HDMI and DVI. The basic pipeline within the FPGA deserializes incoming video and reserializes it to the output. In this trivial mode, NeTV is simply a signal amplifier for the video: encrypted pixels in, encrypted pixels out—no decryption and no video manipulation.</p>&#13;
<p class="indent">NeTV could mix a user-generated content stream over an encrypted video feed because HDCP encrypts without validation. In other words, if a man in the middle tampers with the encrypted feed, the receiver simply accepts the tampered pixels as valid data, decrypts them, and presents them to the user. The lack of link verification is intentional and necessary. The natural bit error rate of HD video links is atrocious, but the human eye won’t detect bit errors even on the level of 1 in every 10,000 bits. (At high error rates, users see a “sparkle” or “snow” on the screen, but the image is largely intact.) Allowing some pixel-level corruption keeps consumer costs low. Otherwise, much higher-quality cables would be required along with FEC techniques to achieve a bit error rate compatible with strict cryptographic verification techniques like full-frame hashing.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_303"/>Thus, NeTV’s prime challenge is to derive a keystream identical and synchronized to the transmitter’s keystream, encrypt the user-generated content with this keystream, and selectively swap the transmitter’s pixels on the fly for user-encrypted pixels. If everything lines up, the receiver will decrypt an image that appears to be a perfect overlay of user-generated content on top of the original video feed.</p>&#13;
<div class="image"><img alt="image" src="../images/f0303-01.jpg"/></div>&#13;
<p class="cap"><em>A high-level conceptual diagram of how NeTV worked</em></p>&#13;
<h5 class="h5" id="ch00lev1sec174">CREATING THE OVERLAY</h5>&#13;
<p class="noindenta">To generate the user overlay content, we connected a tiny embedded Linux computer to an FPGA. From the Linux computer’s standpoint, the FPGA emulates a parallel RGB LCD that you can access by using the frame buffer at <em>/dev/fb0</em> (the filepath for the first frame buffer in Linux). The Linux computer would automatically launch a WebKit browser full-screen at boot, thus filling <em>/dev/fb0</em> with the user’s content.</p>&#13;
<p class="indent">The system selected which pixel to swap by observing the color of the WebKit overlay’s video, a trick known as <em>chroma keying</em>. The overlay video wasn’t encrypted and was generated by the user, so looking at the color of the overlay video was perfectly legal. Other more expressive and aesthetically <span epub:type="pagebreak" id="page_304"/>appealing pixel-combining methods like alpha blending, however, would have required decrypting the original video, which would have been illegal.</p>&#13;
<p class="indent">If the overlay video matched a certain chroma key color (in this case, a specific shade of bright pink), the incoming video was displayed; otherwise, the overlay video was displayed. Following this system, users could create transparent “holes” in the custom UI to show the original video underneath. Since the UI was rendered by a WebKit browser, users could implement chroma keying by simply setting the background color in the CSS of the UI pages to that magic shade of pink. With those settings, the default state of a web page would be transparent, and all items rendered on top of it were opaque, so long as the UI elements avoided the chroma key color and turned off enhancements like anti-aliasing.</p>&#13;
<h5 class="h5" id="ch00lev1sec175">CRAFTING A KEYSTREAM</h5>&#13;
<p class="noindenta">Of course, the chroma keying happened in the encrypted domain. Thus, the FPGA’s second job was to snoop the HDMI link and craft a keystream identical to the transmitter’s. First, the FPGA observed an I2C link found on HDMI known as the <em>data display channel</em> (DDC). The DDC enables monitors to report their capability records (called <em>extended display identification data,</em> or EDID) and is also where the encryption keys are exchanged.</p>&#13;
<p class="indent">By observing the key exchange handshake between the transmitter and the receiver, NeTV could mathematically extract the transmitter’s and receiver’s private keys with the help of the HDCP master key. Once the private-key vectors were derived, they could be multiplied exactly as they’d be in the source or sink to derive the shared secret, called Km. When that shared secret was written into the FPGA’s HDCP engine, the cipher state was ready to go, allowing NeTV to encrypt overlays on the video transmitted between the video source and the video display device.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_305"/>By considering legal constraints as just another engineering constraint, I was able to create a completely new device that proves a point: it’s incorrect to automatically equate hacks that work around a DRM system with attempts to circumvent copyright. NeTV never decrypts previously encrypted video and can’t operate without an existing, valid HDCP link, making it a bona fide, non-infringing, commercially useful application of the HDCP master key.</p>&#13;
<div class="image"><img alt="image" src="../images/f0305-01.jpg"/></div>&#13;
<p class="cap"><em>A more detailed block diagram showing how NeTV’s FPGA worked</em></p>&#13;
<p class="indent">So far in this chapter, we’ve seen examples of different hardware hacking approaches and techniques, from physical penetration to system-level tool building and analysis <span epub:type="pagebreak" id="page_306"/>to treating legal constraints as engineering problems. In “<a href="ch04.xhtml#ch00lev1sec73">Who Are the Shanzhai?</a>” on <a href="ch04.xhtml#page_122">page 122</a>, I discussed the legal approach of a project, codenamed Fernvale, to reverse engineer a mobile phone chipset. In addition to thinking about law as engineers, xobs and I had to pull out all the stops and apply every technical skill at our disposal to reverse engineer such a complex system. The rest of this chapter dives into some of these techniques.</p>&#13;
<h3 class="h3" id="ch00lev1sec176"><strong>HACKING A SHANZHAI PHONE</strong></h3>&#13;
<p class="noindenta">When xobs and I worked on Fernvale, our goal was to make a new platform derived from the hardware in my $12 gongkai phone and repatriate technical information into the open source IP system. We had no documentation whatsoever for some parts of the chip we wanted to reverse, but that didn’t deter us. We navigated complex legal waters and created our own custom scripting language to program the chip’s firmware to avoid subconscious plagiarism.</p>&#13;
<p class="indent">Compared to the firmware, though, the hardware reverse-engineering task was fairly straightforward. The documents we scavenged gave us a notion of the chip’s pinout, and the pin naming scheme was sufficiently descriptive that I could apply common sense and experience to guess how to connect the chip. For ambiguous areas, I buzzed out some stripped-down phones with a multimeter or stared at them under a microscope to determine connectivity. In the worst cases, I’d probe a live phone with an oscilloscope to make sure I understood the connections correctly. The more difficult question was how to architect the hardware.</p>&#13;
<h4 class="h4" id="ch00lev1sec177"><strong>The System Architecture</strong></h4>&#13;
<p class="noindenta">We weren’t gunning to build a phone, but rather something closer to Particle’s Spark Core (since reborn as the Photon), a generic System-on-Module type of single-board computer <span epub:type="pagebreak" id="page_307"/>built for Internet of Things applications. In fact, our original renderings and pinouts were designed to be compatible with the Spark ecosystem of hardware extensions, until we realized the gongkai phone’s MT6260 microcontroller just had too many interesting peripherals to fit into such a small footprint.</p>&#13;
<div class="image"><img alt="image" src="../images/f0307-01.jpg"/></div>&#13;
<p class="cap"><em>Early sketches of the Fernvale PCB</em></p>&#13;
<p class="indent">We settled eventually on a single-sided core PCB that we called the Fernvale Frond, which embedded the microUSB, microSD, battery, camera, speaker, and Bluetooth functionality <span epub:type="pagebreak" id="page_308"/>(as well as the obligatory buttons and LED) on one board. The Frond turned out slim and small, at 3.5 mm thick, 57 mm long, and 35 mm wide. We included holes to mount a partial set of pin headers, spaced for Arduino compatibility, although the board could only be plugged into 3.3 V–compatible Arduino devices.</p>&#13;
<div class="image"><img alt="image" src="../images/f0308-01.jpg"/></div>&#13;
<p class="cap"><em>The actual implementation of the Fernvale Frond, pictured with an Arduino Uno for size reference</em></p>&#13;
<p class="indent">We broke the remaining peripherals out to a pair of connectors: one dedicated to GSM-related signals (GSM is the protocol for 2G cell phone networks) and the other to UI-related peripherals. We called the GSM board the Fernvale Spore and the UI board the Fernvale Blade. We split GSM into a module with many choices for the RF frontend to make GSM a bona fide user-installed feature, thus pushing the regulatory <span epub:type="pagebreak" id="page_309"/>and emissions issue down to the user level. Splitting the UI-related features out to another board also reduced the cost of the core module and let users try the Frond in numerous scenarios without being locked into a particular LCD or button arrangement.</p>&#13;
<div class="image"><img alt="image" src="../images/f0309-01.jpg"/></div>&#13;
<p class="cap"><span epub:type="pagebreak" id="page_310"/><em>A Fernvale system diagram, showing the features of each of the three boards</em></p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>Inside the MT6260</strong></p>&#13;
<p class="noindent">I had some X-rays taken of the MT6260 to help us identify fake components. We had to source our MT6260s on the gray market, and we wanted to guard against being sold empty epoxy blocks or remarked versions of other chips. The MT6260 has -DA and -A variants, where the difference is how much on-chip flash memory is included.</p>&#13;
<div class="image"><img alt="image" src="../images/f0310-01.jpg"/></div>&#13;
<p class="cap"><em>An X-ray of the MT6260 chip.<br/>Look carefully to spot outlines of multiple ICs among the wire bonds.</em></p>&#13;
<p class="indent">To our surprise, this $3 chip didn’t contain a single IC, but rather a set of at least four (possibly five) chips integrated into a single multichip module (MCM) containing hundreds of wire bonds. I remember back when the Pentium Pro’s dual-die package came out in the late 1990s. It sparked arguments over yield costs of MCMs versus using a single big die; generally, MCMs were considered exotic and expensive.</p>&#13;
<p class="indent">I also remember at the same time Krste Asanović, then a professor at the MIT Artificial Intelligence Lab and later at UC Berkeley, told me that the future of electronics wasn’t system-on-a-chip devices, but rather “system-mostly-on-a-chip” devices. The root of his claim was that the economics of adding in mask layers to merge DRAM, flash, <span epub:type="pagebreak" id="page_311"/>analog, RF, and digital into a single process wasn’t favorable; bonding multiple dies together into a single package was cheaper and easier.</p>&#13;
<p class="indent">It’s still a race between the cost impact (in terms of both the per-unit cost and nonrecurring engineering costs) of adding more process steps in the semiconductor fab, and the yield impact, relative reworkability, and lower nonrecurring engineering cost of assembling modules. Single-chip, System-on-Chip devices were the zeitgeist when Krste made that observation and they still kind of are, so it was interesting to see a significant data point validating his insight.</p>&#13;
<p class="indent">Understanding the internal structure of the chip was also helpful in reverse engineering the system. Knowing that MediaTek was simply combining several chips together in a single package shed much-needed light on the purpose and organization of their APIs. It also tipped us off that certain elements of the system would be reused across several product categories and generations, so we knew we could draw meaningful conclusions from documentation on older or related chips. When you’re piecing together a puzzle this complex, every clue helps, including those gained by just looking at the physical structure of the chip.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec178"><strong>Reverse Engineering the Boot Structure</strong></h4>&#13;
<p class="noindenta">Shanzhai engineers in China seem to have access to just enough documentation to assemble a phone and customize its UI, but not enough to do a full OS port. After looking at enough phones, I eventually realized that all phones based on a particular chipset will have the same backdoor codes, and their GUIs are often inconsistent with the implemented hardware. For example, the $12 phone I tore down in <a href="ch04.xhtml#ch04">Chapter 4</a> prompted me to plug headphones into the headphone jack for the FM radio to work, yet it has no headphone jack.</p>&#13;
<p class="indent">To make Fernvale accessible to engineers in the West through open source licensing, we had to reconstruct everything from scratch, including the toolchain, the firmware flashing tool, the OS, and the applications. But all the Chinese phone implementations simply relied on MediaTek’s proprietary toolchain, meaning we had to do some reverse engineering to figure out the boot process and firmware upload protocol.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_312"/>My first step in reversing a chip is always to dump the ROM, if possible. We found exactly one phone model with an external ROM that we could desolder (it used the -D ROMless variant of the chip), and we read its data using a conventional ROM reader. We saw very little ciphertext in the ROM, but there was a lot of compressed data. Here is a page from our notes after we did a static analysis on the ROM image:</p>&#13;
<p class="programs">0x0000_0000        media signature "SF_BOOT"<br/>0x0000_0200        bootloader signature "BRLYT", "BBBB"<br/>0x0000_0800        sector header 1 ("MMM.8")<br/>0x0000_09BC        reset vector table<br/>0x0000_0A10        start of ARM32 instructions<br/>                     – stage 1 bootloader?<br/>0x0000_3400        sector header 2 ("MMM.8")<br/>                     – stage 2 bootloader?<br/>0x0000_A518        thunk table of some type<br/>0x0000_B704        end of code (padding until next sector)<br/>0x0001_0000        sector header 3( "MMM.8") – kernel?<br/>0x0001_0368        jump table + runtime setup (stack, etc.)<br/>0x0001_0828        ARM thumb code start – possibly also<br/>                     baseband code<br/>0x0007_2F04        code end<br/>0x0007_2F05        begin padding "DFFF"<br/>0x0009_F005       end padding "DFFF"<br/>0x0009_F006        code section begin "Accelerated<br/>                     Technology / ATI / Nucleus PLUS"<br/>0x000A_2C1A        code section end; pad with zeros<br/>0x000A_328C        region of compressed/unknown data begin<br/>0x007E_E200        modified FAT partition #1<br/>0x007E_F400        modified FAT partition #2</p>&#13;
<p class="indent">The hexadecimal numbers on the left are memory addresses, and the text on the right describes what xobs and I thought was stored at each address. One concern about reverse engineering an SoC is it has an internal boot ROM that always runs before code is loaded from an external device. That internal ROM can also have signature and security checks that prevent tampering with the external code.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_313"/>To determine how hard reverse engineering this system would be, we wanted to quickly figure out how much code was running inside the CPU before jumping to external boot code. A Tek MDO4104B-6 oscilloscope let us accomplish that task in just a couple of hours.</p>&#13;
<div class="image"><img alt="image" src="../images/f0313-01.jpg"/></div>&#13;
<p class="cap"><em>Screenshot from the Tek MDO4104B-6.<br/>The top quarter shows a zoomed-out view of the entire capture.<br/>Notice how the SPI ROM accesses are punctuated with console output.</em></p>&#13;
<p class="indent">This particular oscilloscope has the uncanny ability to perform post-capture analysis on deep, high-resolution analog traces and output the result as digital data. For example, we could simply probe around the chip with a multimeter while cycling power until we saw something that looked like an RS-232 encoded signal, and then run a post-capture analysis to extract any ASCII text that was coded in the analog traces. Likewise, if we captured SPI traces, the oscilloscope could extract ROM access patterns through a similar method. By looking at the timing of text emissions versus SPI ROM <span epub:type="pagebreak" id="page_314"/>address patterns, we quickly determined that if the internal boot ROM did any verification, it was minimal and nothing approaching the computational complexity of RSA encryption.</p>&#13;
<p class="indent">From there, we needed to speed up our measure-modify-test loop. Desoldering the ROM, sticking it in a burner, and resoldering it to the board were going to get old really fast. Fortunately, we’d implemented a NAND flash ROM emulator (we lovingly shortened that to ROMulator) on Novena, which we previously used to reverse engineer the AX211 contained in certain SD cards. We just reused that codebase and made an SPI ROMulator. We hacked up a GPBB and its corresponding FPGA code to add the ability to swap between the original boot SPI ROM and a dual-ported 64kiB emulator region that was also memory-mapped into the Novena Linux host’s address space. Then, we plugged the phone into the laptop and put the ROMulator to work.</p>&#13;
<div class="image"><img alt="image" src="../images/f0314-01.jpg"/></div>&#13;
<p class="cap"><em>A block diagram of the SPI ROMulator FPGA</em></p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_315"/><img alt="image" src="../images/f0315-01.jpg"/></div>&#13;
<p class="cap"><em>There’s a phone in my Novena! What’s that doing there?</em></p>&#13;
<p class="indent">With the address stream determined by the Tek oscilloscope, some rapid ROM patching by the ROMulator, and hints of a SHA-1 function existing in the ROM via a static code analysis using IDA, we determined that the initial bootloader (which we called the 1bl), was hash-checked using a SHA-1 appendix.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong>NOTE</strong></p>&#13;
<p class="notep"><em>The assembly for a hash function tends to have a very distinctive shape, or set of instructions, and a given hash also has some amount of magic numbers unique to it. Given those facts, when trying to reverse an authentication method, one of the first things a hacker does is use IDA to search for such constants near a function with the shape of the hash function in question.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec179"><strong>Building a Beachhead</strong></h4>&#13;
<p class="noindenta">The next step was to create a small interactive shell we could use as a beachhead for running experiments on the target hardware. Just as he did for the SD card reverse engineering project, xobs created a compact REPL environment, called Fernly, that supported commands like peeking at memory, writing data, and dumping CPU registers.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_316"/>Designing the ROMulator to make the emulated ROM appear as a 64kiB memory-mapped window on a Linux host enabled useful POSIX abstractions like the <span class="literal">mmap()</span> function, the <span class="literal">open()</span> function (via <em>/dev/mem</em>), the <span class="literal">read()</span> function, and the <span class="literal">write()</span> function to access the emulated ROM. xobs used these abstractions to create an I/O target for radare2, a portable reverse engineering framework. The I/O target automatically updated the SHA-1 hash every time we made changes in the 1bl code space. With that system in place, we could do cute things like interactively patch and disassemble code within the emulated ROM space.</p>&#13;
<div class="image"><img alt="image" src="../images/f0316-01.jpg"/></div>&#13;
<p class="cap"><em>Patching some code in the ROM</em></p>&#13;
<p class="indent">We also wired up the power switch of the phone to an FPGA I/O. That allowed us to write automated scripts that toggled <span epub:type="pagebreak" id="page_317"/>the power on the phone while updating the ROM contents so we could automatically fuzz unknown hardware blocks.</p>&#13;
<h4 class="h4" id="ch00lev1sec180"><strong>Attaching a Debugger</strong></h4>&#13;
<p class="noindenta">We had to take an unconventional approach to attach a debugger to the code in the ROM, because locating critical blocks was difficult, and JTAG was multiplexed with critical functions on the target device. xobs emulated the ARM core and used his Fernly shell to reflect virtual loads and stores to the live target. We were able to attach a remote debugger to the emulated core that way, bypassing the need for JTAG entirely. That also let us use cross-platform tools like IDA on x86 for the reversing UI.</p>&#13;
<p class="indent">At the heart of this debugging technique was QEMU, a multiplatform system emulator. QEMU supports emulating ARM targets, specifically the ARMv5 chip our target device used. We made a new virtual machine type, called Fernvale, that implemented part of the observed hardware on the target and simply passed unknown memory accesses directly to the device.</p>&#13;
<p class="indent">The Fernly shell was stripped down to support only three commands: write, read, and zero-memory. The write command pokes a byte, word, or dword of data into RAM on the live target. A read command reads a byte, word, or dword from the live target. The zero-memory command is an optimization, as the operating system writes large quantities of zeros across a large memory area.</p>&#13;
<p class="indent">We also hooked and emulated the serial port registers, allowing a host system to display serial data as if it were printed on the target device. Finally, we emulated SPI, IRAM, and PSRAM as they’d appear on the real device. Other areas of memory were either trapped and funneled to the actual device or left unmapped and reported as errors by QEMU.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_318"/><img alt="image" src="../images/f0318-01.jpg"/></div>&#13;
<p class="cap"><em>The architecture of the debugger</em></p>&#13;
<p class="indent">Invoking the debugger was a multistage process. First, we primed the actual MT6260 target with the Fernly shell environment. Then, we booted the QEMU virtual ARM CPU with a version of the original vendor image primed with a known register state at a convenient point in the boot process. At this point, code execution proceeded on the virtual machine until a load or store was performed to an unknown address. On that load or store, virtual machine execution paused while a query was sent to the real MT6260 via the Fernly shell interface. The load or store was then executed on the real machine, which would relay the results of the load or store to the virtual machine so execution could resume.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_319"/>We couldn’t run Fernly directly from the SPI ROM because the vendor binary’s initialization routine modified SPI ROM timings. But of course Fernly would have crashed if a store happened to land somewhere inside its memory footprint. To avoid the possibility of a load or store overwriting the Fernly shell code, we hid the code in a region of IRAM that was trapped and emulated. Emulating the target CPU let us attach a remote debugger like IDA via GDB over TCP. The debugger had complete control over the emulated CPU and could access its emulated RAM. Here is an example of the output of the hybrid QEMU/live-target debug harness.</p>&#13;
<p class="programs">bunnie@bunnie-novena-laptop:~/code/fernvale-qemu$ ./run.sh<br/><br/>~~~ Welcome to MTK Bootloader V005 (since 2005) ~~~<br/>**===================================================**<br/><br/>READ WORD Fernvale Live 0xa0010328 = 0x0000... ok<br/>WRITE WORD Fernvale Live 0xa0010328 = 0x0800... ok<br/>READ WORD Fernvale Live 0xa0010230 = 0x0001... ok<br/>WRITE WORD Fernvale Live 0xa0010230 = 0x0001... ok<br/>READ DWORD Fernvale Live 0xa0020c80 = 0x11111011... ok<br/>WRITE DWORD Fernvale Live 0xa0020c80 = 0x11111011... ok<br/>READ DWORD Fernvale Live 0xa0020c90 = 0x11111111... ok<br/>WRITE DWORD Fernvale Live 0xa0020c90 = 0x11111111... ok<br/>READ WORD Fernvale Live 0xa0020b10 = 0x3f34... ok<br/>WRITE WORD Fernvale Live 0xa0020b10 = 0x3f34... ok</p>&#13;
<p class="indent">This output shows the trapped serial writes appearing on the console, plus a log of the writes and reads executed by the emulated ARM CPU as they were relayed to the live target running the reduced Fernly shell. This was our beachhead.</p>&#13;
<p class="indent">From there, xobs and I discovered the offsets of a few IP blocks that were reused from previous known MediaTek chips by searching for their “signature” in memory. A signature could be as simple as the power-on default register values, or something more complex, like changes in bit patterns due to the side effects of bit set or clear registers located at offsets <span epub:type="pagebreak" id="page_320"/>within the IP block’s address space. Following the signatures helped us find the register offsets of several peripherals and generate a memory map.</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td class="tableth" style="vertical-align: top;"><p class="table"><strong>Starting Address</strong></p></td>&#13;
<td class="tableth" style="vertical-align: top;"><p class="table"><strong>Ending Address</strong></p></td>&#13;
<td class="tableth" style="vertical-align: top;"><p class="table"><strong>Size of Region</strong></p></td>&#13;
<td class="tableth" style="vertical-align: top;"><p class="table"><strong>Description</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x00000000</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x0fffffff</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x0fffffff</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">PSRAM map, repeated and mirrored at 0x00800000 offsets</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x10000000</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x1fffffff</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x0fffffff</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">Memory-mapped SPI chip</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">????????????????????????????????</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x70000000</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x7000cfff</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0xcfff</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">On-chip SRAM (maybe cache?)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">????????????????????????????????</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x80000000</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x80000008</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x08</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">Config block (chip version, etc.)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x82200000</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x83000000</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"> </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0xa0000000</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0xa0000008</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x08</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">Config block (mirror?)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x10010000</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">(?SPI mode?) ????????????????????</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x10020000</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0xa0020e10</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x0e10</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">GPIO control block</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0xa0030000</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0xa0030040</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x40</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">WDT block</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"> </p></td>&#13;
<td style="vertical-align: top;"><p class="table"> </p></td>&#13;
<td style="vertical-align: top;"><p class="table"> </p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">   + 0x08 -&gt; WDT register (?)<br/>   + 0x18 -&gt; Boot src (?)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0xa0030800</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">????????????????????????????????</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0xa0040000</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">????????????????????????????????</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0xa0050000</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">????????????????????????????????</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0xa0060000</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">?? Possible IRQs at 0xa0060200 ??</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0xa0070000</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">==========</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">==========</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">== Empty (all zeroes) ===========</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0xa0080000</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0xa008005c</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x5c</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">UART1 block</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0xa0090000</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0xa009005c</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0x5c</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">UART2 block</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">0xa00a0000</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">??????????</span></p></td>&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">?????????????????????????????????</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">This memory map shows what content is stored at different address ranges on the chip. For instance, the second address range in the map (0x10000000 to 0x1FFFFFFF) consisted of 0x0FFFFFFF bytes corresponding to a memory-mapped SPI chip.</p>&#13;
<h4 class="h4" id="ch00lev1sec181"><span epub:type="pagebreak" id="page_321"/><strong>Booting an OS</strong></h4>&#13;
<p class="noindenta">After finding the register offsets, we progressed rapidly on many fronts, but our goal (to port NuttX, a BSD-based real-time operating system, to the device) remained elusive. There was no documentation on the interrupt controller within the canon of shanzhai datasheets. We found the routines that installed the interrupt handlers through static analysis of the binaries, but we couldn’t determine the address offsets of the interrupt controller itself.</p>&#13;
<p class="indent">All we could do was open the MediaTek codebase and refer to the header file that contained the register offsets and bit definitions of the interrupt controller. This fit within our self-imposed limitations to not breach copyright, because facts are not copyrightable. I describe the legal reasoning behind this idea in <a href="ch04.xhtml#ch04">Chapter 4</a>, under “<a href="ch04.xhtml#ch00lev1sec82">Dealing with Copyrights</a>” on <a href="ch04.xhtml#page_138">page 138</a>. After looking up those facts, we created our own custom scripting language, called Scriptic, to avoid unconsciously plagiarizing anything from the existing codebase.</p>&#13;
<h4 class="h4" id="ch00lev1sec182"><strong>Building a New Toolchain</strong></h4>&#13;
<p class="noindenta">Requiring users to own a Novena ROMulator to hack on Fernvale wasn’t a scalable solution, however. To round out the story, we created a complete developer toolchain. The compiler was fairly cut-and-dried; many standard compilers support ARM as a target, including clang and GCC. But making open tools for flashing the MT6260 was much trickier. All the existing tools we knew supported the protocol version required by the MT6260 were proprietary Windows programs. That meant we had to reverse engineer the MediaTek flashing protocol and write our own open source tool.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_322"/>Fortunately, a blank, unfused MT6260 shows up as <em>/dev/ttyUSB0</em> when you plug it into a Linux host. In other words, it shows up as an emulated serial device over USB. That took care of the lower-level details of sending and receiving bytes to the device, leaving us to reverse engineer the protocol layer.</p>&#13;
<p class="indent">xobs located the internal boot ROM of the MT6260 and performed static code analysis to learn more about the protocol. He also did some static analysis on MediaTek’s flashing tool and captured live traces using a USB protocol analyzer to clarify the remaining details. Here is a summary of the commands he extracted, as we used in our open version of the USB flashing tool.</p>&#13;
<p class="programs">enum mtk_commands {<br/>  mtk_cmd_old_write16 = 0xa1,<br/>  mtk_cmd_old_read16 = 0xa2,<br/>  mtk_checksum16 = 0xa4,<br/>  mtk_remap_before_jump_to_da = 0xa7,<br/>  mtk_jump_to_da = 0xa8,<br/>  mtk_send_da = 0xad,<br/>  mtk_jump_to_maui = 0xb7,<br/>  mtk_get_version = 0xb8,<br/>  mtk_close_usb_and_reset = 0xb9,<br/>  mtk_cmd_new_read16 = 0xd0,<br/>  mtk_cmd_new_read32 = 0xd1,<br/>  mtk_cmd_new_write16 = 0xd2,<br/>  mtk_cmd_new_write32 = 0xd4,<br/>  // mtk_jump_to_da = 0xd5,<br/>  mtk_jump_to_bl = 0xd6,<br/>  mtk_get_sec_conf = 0xd8,<br/>  mtk_send_cert = 0xe0,<br/>  mtk_get_me = 0xe1, /* Responds with 22 bytes */<br/>  mtk_send_auth = 0xe2,<br/>  mtk_sla_flow = 0xe3,<br/>  mtk_send_root_cert = 0xe5,<br/>  mtk_do_security = 0xfe,<br/>  mtk_firmware_version = 0xff,<br/>};</p>&#13;
<p class="indent">This is just a C <span class="literal">enum</span> structure, making it a very geeky way of specifying a mapping of numbers to command <span epub:type="pagebreak" id="page_323"/>meanings. For example, <span class="literal">mtk_cmd_old_write16</span> is command 0xA1, <span class="literal">mtk_command_old_read16</span> is command 0xA2, and so on.</p>&#13;
<h4 class="h4" id="ch00lev1sec183"><strong>Fernvale Results</strong></h4>&#13;
<p class="noindenta">After about a year of on-and-off effort between work on the Novena and Chibitronics campaigns, we were able to boot a port of NuttX on the MT6260, supporting a minimal set of hardware peripherals. It was enough for us to roughly reproduce the functionality of an AVR used in an Arduino-like context, but not much more.</p>&#13;
<p class="indent">xobs and I presented our results at the 31st Chaos Communication Congress (CCC), and events actually took an unexpected twist as we wrote our proposal. The week before submission, we learned that MediaTek released the LinkIT ONE development platform, based on the MT2502A, in conjunction with Seeed Studios. The LinkIT ONE is an Internet of Things platform made for entrepreneurs and hobbyists. It’s integrated into the Arduino framework and features an open API that enables the full functionality of the chip, including GSM functions. But the core OS that boots on the MT2502A in the LinkIT ONE is still proprietary, and you can’t access the hardware without going through the API calls provided by the Arduino shim.</p>&#13;
<p class="indent">Realistically, it’s still going to be a while before we can port a reasonable fraction of the MT6260’s features into the open source domain. It’s quite possible we’ll never be able to do a blob-free implementation of the GSM call functions, as those are controlled by a DSP unit that’s even more obscure and undocumented than the MT6260. Given the robust functionality of the LinkIT ONE compared to Fernvale, we decided to leave the question of whether there was value in continuing the effort to reverse engineer the MT6260 to the open source community. In the end, there was a lot of enthusiasm for the project, but not a lot of action. The LinkIT ONE’s introduction <span epub:type="pagebreak" id="page_324"/>took a lot of wind out of the sails of the Fernvale project, which has since been effectively retired.</p>&#13;
<p class="indent">This is, in fact, the fate of most open source projects. There are dozens, if not hundreds, of open source operating systems but only one Linux. The truth is that there are far more interesting ideas than capable developers to execute them. For an open source project to catch fire and become self-sustaining, it has to not only pass the minimum viable product (MVP) stage but also meet a receptive audience with a real need for the project. Sometimes your project strikes a chord, and a huge community pushes it forward. Other times, you get a lot of nice, helpful onlookers who nod appreciatively but are unwilling or too busy with day jobs to jump in. And still other times, you yell into a void or, worse, get torn to shreds on some internet forum about how flawed and pointless your project is.</p>&#13;
<h3 class="h3" id="ch00lev1sec184"><strong>CLOSING THOUGHTS</strong></h3>&#13;
<p class="noindenta">Given the nature of open source projects, I tend to take a page from my startup days and follow a “fail forward fast” philosophy. Try a bunch of different things, see what sticks, learn from your mistakes, and try again. It’s important not to get too wedded to any one idea, especially if the idea isn’t working out. Finally, you’ll find it helps to be more about the journey than the destination. Fernvale was most certainly an epic journey; xobs and I learned a lot, honed a set of tools and skills that we continue to use to this day for other projects, and most importantly, had a lot of fun.</p>&#13;
<p class="indent">In the next chapter, we’ll take a look at another kind of hacking that will become increasingly relevant to all of us over the coming decades—that of biological systems.</p>&#13;
</body></html>