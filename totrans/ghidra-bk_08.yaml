- en: '## **6'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **6'
- en: MAKING SENSE OF A GHIDRA DISASSEMBLY**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解Ghidra反汇编**'
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: In this chapter, we cover important basic skills that will help you to better
    understand the Ghidra disassembly. We start with basic navigational techniques
    that allow you to move through the assembly and examine the artifacts you encounter.
    As you navigate from function to function, you will find that you need to decode
    each function’s prototype by using only clues available in the disassembly. Accordingly,
    we’ll discuss techniques for understanding how many parameters a function receives
    and how we might decode the data types of each parameter we encounter. Since much
    of the work that a function performs is associated with local variables maintained
    by the function, we’ll also discuss how functions use the stack for local variable
    storage and how you can, with Ghidra’s help, understand exactly how a function
    makes use of any stack space it may reserve for itself. Whether you find yourself
    debugging code, analyzing malware, or developing exploits, understanding how to
    decode a function’s stack-allocated variables is an essential skill for understanding
    the behavior of any program. Finally, we will look at the options Ghidra provides
    for searching and how that can contribute to understanding the disassembly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些重要的基础技能，帮助你更好地理解Ghidra的反汇编内容。我们从基本的导航技巧开始，这些技巧可以让你在汇编代码中移动，并检查你遇到的各种文物。随着你从一个函数跳转到另一个函数，你会发现你需要通过仅使用反汇编中提供的线索来解码每个函数的原型。因此，我们将讨论如何理解一个函数接受多少个参数，并且如何解码我们遇到的每个参数的数据类型。由于一个函数执行的大部分工作都与函数维护的局部变量相关，我们还将讨论函数如何使用栈来存储局部变量，以及如何在Ghidra的帮助下准确理解一个函数如何使用它可能为自己保留的任何栈空间。无论你是在调试代码、分析恶意软件，还是开发漏洞，理解如何解码一个函数的栈分配变量是理解任何程序行为的基本技能。最后，我们将介绍Ghidra提供的搜索选项，以及这些选项如何帮助理解反汇编内容。
- en: '**Disassembly Navigation**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**反汇编导航**'
- en: In [Chapters 4](ch04.xhtml#ch04) and [5](ch05.xhtml#ch05), we demonstrated that
    at a basic level, Ghidra combines the features of many common reverse engineering
    tools into its integrated CodeBrowser display. Navigating around the display is
    one of the essential skills required to master Ghidra. Static disassembly listings,
    such as those provided by tools like `objdump`, offer no inherent navigational
    capability other than scrolling up and down the listing. Even with the best text
    editors offering an integrated, `grep`-style search, such *dead listings* are
    very difficult to navigate. Ghidra, on the other hand, provides exceptional navigational
    features. In addition to offering fairly standard search features that you are
    accustomed to from your use of text editors or word processors, Ghidra develops
    and displays a comprehensive list of cross-references that behave like web page
    hyperlinks. The end result is that, in most cases, navigating to locations of
    interest requires nothing more than a double-click.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.xhtml#ch04)和[第5章](ch05.xhtml#ch05)中，我们展示了在基本层面上，Ghidra将许多常见的逆向工程工具的功能集成到它的CodeBrowser显示中。浏览显示内容是掌握Ghidra所需的基本技能之一。静态反汇编清单，例如像`objdump`这样的工具提供的清单，除了上下滚动之外，并没有内建的导航功能。即使是提供集成的`grep`风格搜索的最佳文本编辑器，这种*死列表*也非常难以浏览。另一方面，Ghidra提供了出色的导航功能。除了提供你在使用文本编辑器或文字处理软件时习惯的标准搜索功能外，Ghidra还开发并显示了一个全面的交叉引用列表，这些交叉引用像网页的超链接一样起作用。最终的结果是，在大多数情况下，导航到感兴趣的位置只需要双击即可。
- en: '***Names and Labels***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***名称和标签***'
- en: When a program is disassembled, every location in the program is assigned a
    virtual address. As a result, we can navigate anywhere within a program by providing
    the virtual address of the location we are interested in visiting. Unfortunately
    for us, maintaining a catalog of addresses in our heads is not a trivial task.
    This fact motivated early programmers to assign symbolic names to program locations
    that they wished to reference, making things a whole lot easier on themselves.
    The assignment of symbolic names to program addresses was not unlike the assignment
    of mnemonic instruction names to program opcodes; programs became easier to read
    and write by making identifiers easier to remember. Ghidra continues this tradition
    by creating labels for virtual addresses and allowing the user to modify and expand
    the set of labels. We have already seen the use of names in relation to the Symbol
    Tree window. Recall that double-clicking a name caused the Listing view (and the
    Symbol References window) to jump to the referenced location. While there are
    usage differences between the terms *name* and *label* (for example, functions
    have names and appear in a separate branch of the Ghidra Symbol Tree from labels),
    in a navigational context the terms are largely interchangeable because both represent
    navigational targets.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序被反汇编时，程序中的每个位置都会分配一个虚拟地址。因此，我们可以通过提供我们感兴趣访问的位置的虚拟地址来在程序内导航。不幸的是，记住这些地址并将其整理成目录并非易事。正因为如此，早期的程序员便开始为他们想要引用的程序位置分配符号名称，这使得工作变得轻松得多。将符号名称分配给程序地址就像为程序操作码分配助记符指令名称一样；通过使标识符更容易记住，程序变得更加易于阅读和编写。Ghidra
    继承了这一传统，通过为虚拟地址创建标签并允许用户修改和扩展标签集来延续这一做法。我们已经在 Symbol Tree 窗口中看到过名称的使用。回想一下，双击名称会导致
    Listing 视图（以及 Symbol References 窗口）跳转到引用的位置。虽然在使用上，“名称”和“标签”这两个术语有所不同（例如，函数有名称，并且在
    Ghidra Symbol Tree 中与标签出现在不同的分支中），但在导航上下文中，这两个术语通常可以互换使用，因为它们都表示导航目标。
- en: Ghidra generates symbolic names during the auto analysis phase by using an existing
    name from the binary (if available) or by automatically generating a name based
    on how a location is referenced within the binary. In addition to its symbolic
    purpose, any label displayed in the disassembly window is a potential navigation
    target similar to a hyperlink on a web page. The two major differences between
    these labels and standard hyperlinks are that the labels are not highlighted in
    any way to indicate that they can be followed and that Ghidra generally requires
    a double-click to follow rather than the single-click required by a traditional
    hyperlink.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 在自动分析阶段通过使用二进制文件中现有的名称（如果有）或根据二进制文件中某个位置的引用方式自动生成名称，从而生成符号名称。除了符号用途外，任何在反汇编窗口中显示的标签都是潜在的导航目标，类似于网页上的超链接。这些标签与标准超链接的两大主要区别是：标签没有任何突出显示，无法指示它们可以被点击跟踪，而且
    Ghidra 通常需要双击才能跟踪，而传统的超链接只需单击。
- en: '**YOU ARE INVITED TO THE NAMING CONVENTION!**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**您已被邀请加入命名约定！**'
- en: 'Ghidra provides the user lots of flexibility when assigning labels, but certain
    patterns have a special meaning and are reserved for Ghidra. These include the
    following prefixes when they are followed by an underscore and an address: `EXT`,
    `FUN`, `SUB`, `LAB`, `DAT`, `OFF`, and `UNK`. When you create a label, avoid these
    patterns. In addition, spaces and nonprintable characters are not allowed in labels.
    On the plus side, labels can be up to 2000 characters. Count carefully if you
    think you are in danger of exceeding that limit!'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 在分配标签时为用户提供了很多灵活性，但某些模式有特殊含义，并且是 Ghidra 保留的。这些包括以下前缀，当它们后面跟着下划线和地址时：`EXT`、`FUN`、`SUB`、`LAB`、`DAT`、`OFF`
    和 `UNK`。创建标签时应避免使用这些模式。此外，标签中不允许使用空格和不可打印字符。幸运的是，标签最多可以包含 2000 个字符。如果你认为自己可能会超出这个限制，请仔细计算！
- en: '***Navigation in Ghidra***'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Ghidra 中的导航***'
- en: In the listing shown in [Figure 6-1](ch06.xhtml#fig6_1), each of the symbols
    indicated by a solid arrow represents a named navigational target. Double-clicking
    any of them in the Listing window will cause Ghidra to relocate the Listing display
    (and all connected windows) to the selected location.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 6-1](ch06.xhtml#fig6_1)中显示的列表中，每个由实心箭头指示的符号都代表一个命名的导航目标。在 Listing 窗口中双击它们中的任何一个，Ghidra
    将会将 Listing 显示（以及所有相关窗口）移动到选定的位置。
- en: '![image](Images/fig6-1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-1.jpg)'
- en: '*Figure 6-1: Listing showing navigational targets*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：列出显示导航目标*'
- en: For navigational purposes, Ghidra treats two additional display entities as
    navigational targets. First, cross-references (indicated by dashed arrows in [Figure
    6-1](ch06.xhtml#fig6_1)) are treated as navigational targets. Double-clicking
    the bottom cross-reference address will jump the display to the referencing location
    (`00401331` in this case). Cross-references are covered in more detail in [Chapter
    9](ch09.xhtml#ch09). Hovering over any of these navigable objects will display
    a pop-up that shows the destination code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Second, the other type of display entity afforded special treatment in a navigational
    sense is one that uses hexadecimal values. If a displayed sequence of hexadecimal
    values represents a valid virtual address within the binary, then the associated
    virtual address will be displayed to the right, as shown in [Figure 6-2](ch06.xhtml#fig6_2).
    Double-clicking the displayed value will reposition the disassembly window to
    the associated virtual address. In [Figure 6-2](ch06.xhtml#fig6_2), double-clicking
    any of the values indicated by a solid arrow will jump the display, because each
    is a valid virtual address within this particular binary. Double-clicking any
    of the other values will have no effect.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-2.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-2: Listing showing hexadecimal navigational targets*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '***Go To***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you know the address or name you want to navigate to (for example, navigating
    to *main* in an ELF binary to begin your analysis), you could scroll through the
    listing to look for the address, scroll through the Functions folder in the Symbol
    Tree window to find the desired name, or use Ghidra’s search features (which are
    discussed later in this chapter). Ultimately, the easiest way to get to a known
    address or name is to use the Go To dialog (shown in [Figure 6-3](ch06.xhtml#fig6_3)),
    accessed via Navigation ▸ Go To or by using the G hotkey while the disassembly
    window is active.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-3.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3: The Go To dialog*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Navigating to any location in the binary is as simple as specifying a valid
    address (a case-sensitive symbol name or hex value) and clicking OK, which will
    immediately jump the display to the desired location. Values entered into the
    dialog are made available on subsequent use via a drop-down history list, which
    simplifies returning to previously requested locations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '***Navigation History***'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As a final navigational feature, Ghidra supports forward and backward navigation
    based on the order in which you navigate the disassembly. Each time you navigate
    to a new location within a disassembly, your current location is appended to a
    history list. This list can be traversed from the Go To window or the left and
    right arrow icons in the CodeBrowser toolbar.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: In the Go To window, shown in [Figure 6-3](ch06.xhtml#fig6_3), the arrow on
    the right side of the text box opens a picklist that allows you to choose from
    previous locations you have entered in the Go To dialog. The CodeBrowser toolbar
    buttons, seen near the top left in [Figure 6-4](ch06.xhtml#fig6_4), provide familiar
    browser-style forward and backward behavior. Each button is associated with a
    detailed drop-down history list that provides instant access to any location in
    the navigation history without having to retrace your steps through the entire
    list. A sample drop-down list associated with the back arrow is displayed in [Figure
    6-4](ch06.xhtml#fig6_4).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go To 窗口中，如[图 6-3](ch06.xhtml#fig6_3)所示，文本框右侧的箭头打开一个选择列表，允许你从之前在 Go To 对话框中输入的位置信息中选择。CodeBrowser
    工具栏按钮，如[图 6-4](ch06.xhtml#fig6_4)中左上方所见，提供类似浏览器的前进和后退功能。每个按钮都关联着一个详细的下拉历史列表，允许你直接访问导航历史中的任何位置，而不需要重新回溯整个列表。[图
    6-4](ch06.xhtml#fig6_4)中显示了与返回箭头相关的下拉列表示例。
- en: '![image](Images/fig6-4.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-4.jpg)'
- en: '*Figure 6-4: Forward and backward navigation arrows with address list*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：带地址列表的前进和后退导航箭头*'
- en: ALT-left arrow (OPTION-left arrow on Mac), for backward navigation, is one of
    the most useful hotkeys you can commit to memory. Backward navigation is extremely
    handy when you have followed a chain of function calls several levels deep and
    you decide that you want to navigate back to your original position within the
    disassembly. ALT-right arrow (OPTION-right arrow on Mac) moves the disassembly
    window forward in the history list.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ALT-左箭头（Mac 上是 OPTION-左箭头）用于向后导航，是你可以牢记的最有用的快捷键之一。当你已经深入跟踪了一系列函数调用，并且决定返回到反汇编的原始位置时，向后导航非常方便。ALT-右箭头（Mac
    上是 OPTION-右箭头）将反汇编窗口在历史列表中向前移动。
- en: While we now have a much clearer picture regarding navigating a disassembly
    in Ghidra, we still have not attached meaning to the various destinations we have
    visited. The next section investigates what makes functions in general, and stack
    frames in particular, such important navigational targets for a reverse engineer.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在对如何在 Ghidra 中导航反汇编有了更清晰的认识，但我们仍然没有对我们访问过的各个目标赋予意义。下一节将探讨为什么函数（尤其是堆栈帧）对逆向工程师来说是如此重要的导航目标。
- en: '**Stack Frames**'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**堆栈帧**'
- en: Because Ghidra is a low-level analysis tool, many of its features and displays
    expect the user to be somewhat familiar with the low-level details of compiled
    languages, which focus on the specifics of generating machine language and managing
    the memory used by a high-level program. Ghidra pays particular attention to the
    manner in which compilers handle local variable declarations and accesses. You
    may have noticed that a significant number of lines are dedicated to local variables
    at the beginning of most function listings. These lines result from detailed stack
    analysis that Ghidra performs on each function, using its Stack analyzer. This
    analysis is necessary because compilers place a function’s local variables (and
    in some circumstances, the function’s incoming arguments) in blocks of memory
    allocated on the stack. In this section, we review how compilers treat local variable
    and function arguments to help you better understand the details of Ghidra’s Listing
    view.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Ghidra 是一个低级分析工具，它的许多功能和显示期望用户对编译语言的低级细节有一定了解，这些语言专注于生成机器语言和管理高级程序使用的内存。Ghidra
    特别关注编译器如何处理局部变量声明和访问。你可能已经注意到，在大多数函数列表的开头，有大量的行专门用于局部变量。这些行来自 Ghidra 对每个函数进行的详细堆栈分析，通过其堆栈分析器完成。进行此分析是必要的，因为编译器将函数的局部变量（在某些情况下，还包括函数的传入参数）放置在分配到堆栈上的内存块中。在本节中，我们将回顾编译器如何处理局部变量和函数参数，以帮助你更好地理解
    Ghidra 列表视图的细节。
- en: '***Function Call Mechanics***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***函数调用机制***'
- en: A function invocation may require memory for information passed into the function
    in the form of parameters (arguments) and for temporary storage space while executing
    the function. The parameter values, or their corresponding memory addresses, need
    to be stored somewhere the function can locate them. The temporary space is often
    allocated by a programmer through the declaration of local variables, which can
    be used within the function but cannot be accessed after the function has completed.
    *Stack frames* (also known as *activation records*) are blocks of memory allocated
    within a program’s runtime stack and dedicated to a specific invocation of a function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用可能需要为传递给函数的参数（实参）以及执行函数时的临时存储空间分配内存。参数值或其对应的内存地址需要存储在函数能够找到的地方。临时空间通常通过程序员声明局部变量来分配，这些变量可以在函数内使用，但在函数完成后无法访问。*栈帧*（也称为*激活记录*）是分配在程序运行时栈中的内存块，专门用于特定函数调用的内存空间。
- en: Compilers use stack frames to make the allocation and deallocation of function
    parameters and local variables transparent to the programmer. For calling conventions
    that pass parameters on the stack, the compiler inserts code to place a function’s
    parameters into the stack frame prior to transferring control to the function
    itself, at which point the compiler inserts code to allocate enough memory to
    hold the function’s local variables. In some cases, the address to which the function
    should return is also stored within the new stack frame. Stack frames also enable
    recursion,^([1](footnotes.xhtml#ch06fn1)) as each recursive call to a function
    is given its own stack frame, neatly segregating each call from its predecessor.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器使用栈帧使函数参数和局部变量的分配与释放对程序员透明。对于在栈上传递参数的调用约定，编译器会插入代码，在将控制权传递给函数之前，将函数的参数放入栈帧中，随后插入代码分配足够的内存来保存函数的局部变量。在某些情况下，函数应返回的地址也会存储在新的栈帧中。栈帧还支持递归，^([1](footnotes.xhtml#ch06fn1))因为每个递归调用都会得到自己的栈帧，确保每次调用都与前一次调用相互独立。
- en: 'The following operations take place when a function is called:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是函数调用时发生的操作：
- en: The caller places any parameters required by the function being called into
    locations dictated by the calling convention employed by the called function.
    The program stack pointer may change if parameters are passed on the runtime stack.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者将被调用函数所需的任何参数放入被调用函数采用的调用约定所要求的位置。如果参数通过运行时栈传递，则程序栈指针可能会发生变化。
- en: The caller transfers control to the function being called with an instruction
    such as the x86 `CALL`, ARM `BL`, or MIPS `JAL`. A return address is saved onto
    the program stack or in a processor register.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者通过类似 x86 的`CALL`、ARM 的`BL`或 MIPS 的`JAL`指令将控制权传递给被调用的函数。一个返回地址会被保存在程序栈中或处理器寄存器里。
- en: If necessary, the called function configures a frame pointer and saves any register
    values that the caller expects to remain unchanged.^([2](footnotes.xhtml#ch06fn2))
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，被调用的函数配置一个帧指针并保存调用者期望保持不变的寄存器值。^([2](footnotes.xhtml#ch06fn2))
- en: The called function allocates space for any local variables that it may require.
    This is often done by adjusting the program stack pointer to reserve space on
    the runtime stack.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被调用的函数为其可能需要的任何局部变量分配空间。这通常通过调整程序栈指针来预留运行时栈上的空间。
- en: The called function performs its operations, potentially accessing the parameters
    passed to it and generating a result. If the function returns a result, it is
    often placed into a specific register or registers that the caller can examine
    after the function returns.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被调用的函数执行其操作，可能会访问传递给它的参数并生成结果。如果函数返回结果，通常会将其放入一个特定的寄存器中，调用者可以在函数返回后检查该寄存器。
- en: When the function has completed its operations, any stack space reserved for
    local variables is released. This is often done by reversing the actions performed
    in step 4.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当函数完成其操作后，为局部变量保留的任何栈空间会被释放。通常通过逆转步骤 4 中执行的操作来完成这一过程。
- en: Registers whose values were saved (in step 3) on behalf of the caller are restored
    to their original values.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为调用者保存的寄存器值（在步骤 3 中）会被恢复为原始值。
- en: The called function returns control to the caller. Typical instructions for
    this include the x86 `RET`, ARM `POP`, and MIPS `JR`. Depending on the calling
    convention in use, this operation may also clear one or more parameters from the
    program stack.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被调用的函数将控制权返回给调用者。典型的指令包括x86的`RET`、ARM的`POP`和MIPS的`JR`。根据使用的调用约定，这个操作也可能会从程序栈中清除一个或多个参数。
- en: Once the caller regains control, it may need to remove parameters from the program
    stack by restoring the program stack pointer to the value that it held prior to
    step 1.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦调用者重新获得控制权，它可能需要通过恢复程序栈指针到步骤1之前的值，从程序栈中移除参数。
- en: Steps 3 and 4 are so commonly performed upon entry to a function that together
    they are called the function’s *prologue*. Similarly, steps 6 through 8 make up
    the function’s *epilogue*. All of these operations, except step 5, are part of
    the overhead associated with calling a function, which may not be obvious in a
    program’s high-level source code, but is quite observable in assembly language.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤3和步骤4是进入函数时常见的操作，合在一起被称为函数的*序言*。类似地，步骤6到步骤8构成了函数的*尾声*。除了步骤5，这些操作都是与调用函数相关的开销，可能在程序的高级源代码中并不明显，但在汇编语言中却十分可见。
- en: '**ARE THEY REALLY GONE?**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**它们真的被移除了么？**'
- en: When we talk about “removing” items from the stack, as well as the removal of
    entire stack frames, we mean that the stack pointer is adjusted so it points to
    data lower on the stack and the removed content is no longer accessible through
    the `POP` operation. Until that content is overwritten by a `PUSH` operation,
    it is still there. From a programming perspective, that qualifies as removal.
    From a digital forensics perspective, you just have to look a little harder to
    find the contents. From a variable initialization standpoint, it means that any
    uninitialized local variables within a stack frame may contain stale values that
    remain in memory from the last use of a particular range of stack bytes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论“移除”栈中的项目以及整个栈帧的移除时，我们指的是调整栈指针，使其指向栈中更低的位置，并且已移除的内容不再通过`POP`操作访问。直到这些内容被`PUSH`操作覆盖，它们仍然存在。从编程的角度来看，这算作移除。从数字取证的角度来看，你需要稍微费点劲才能找到这些内容。从变量初始化的角度来看，这意味着栈帧中的任何未初始化的局部变量可能包含来自上次使用特定栈字节范围的过期值。
- en: '#### ***Calling Conventions***'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***调用约定***'
- en: 'When passing arguments from caller to callee, the calling function must store
    parameters exactly as the function being called expects to find them; otherwise,
    serious problems can arise. A *calling convention* dictates exactly where a caller
    should place any parameters that a function requires: in specific registers, on
    the program stack, or in both registers and on the stack. When parameters are
    passed on the program stack, the calling convention also determines who is responsible
    for removing them from the stack after the called function has completed: the
    caller or the callee.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当从调用者传递参数到被调用者时，调用函数必须按照被调用函数预期的方式存储参数；否则，可能会出现严重问题。*调用约定*严格规定了调用者应该将任何函数所需的参数放置的位置：在特定的寄存器中、在程序栈上，或同时在寄存器和栈中。当参数通过程序栈传递时，调用约定还决定了在被调用函数完成后，谁负责从栈中移除这些参数：调用者还是被调用者。
- en: Regardless of what architecture you are reversing for, understanding the code
    surrounding a function call will be difficult if you don’t understand the calling
    conventions in use. In the sections that follow, we review some of the common
    calling conventions encountered in compiled C and C++ code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是在逆向哪种架构的程序，如果不理解所使用的调用约定，理解函数调用周围的代码将会非常困难。在接下来的章节中，我们将回顾一些在编译后的C和C++代码中常见的调用约定。
- en: '**Stack and Register Arguments**'
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**栈和寄存器参数**'
- en: Function arguments may be passed in processor registers, on the program stack,
    or in a combination of both. When arguments are placed on the stack, the caller
    performs a memory write (often a `PUSH`) to place the argument onto the stack,
    and the called function must then perform a memory read to access the argument.
    To speed up the function call process, some calling conventions pass arguments
    in processor registers. When an argument is passed in a register, there is no
    need to perform the memory write and read operations, as the argument is immediately
    available to the called function in a designated register. The one shortcoming
    with register-based calling conventions is that processors have a finite number
    of registers while function argument lists can be arbitrarily long, so the conventions
    must properly handle functions that require more arguments than available registers.
    Excess arguments that “spill” out of available registers are generally placed
    on the stack.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数可以通过处理器寄存器、程序栈或两者的组合传递。当参数被放置到栈上时，调用者执行内存写操作（通常是`PUSH`）将参数放到栈上，而被调用函数必须执行内存读取操作才能访问该参数。为了加快函数调用过程，一些调用约定通过处理器寄存器传递参数。当参数通过寄存器传递时，无需执行内存的写入和读取操作，因为参数可以直接通过指定的寄存器提供给被调用函数。寄存器传递调用约定的一个缺点是处理器的寄存器数量有限，而函数参数列表可以非常长，因此这些约定必须正确处理需要更多参数而寄存器不足的情况。多余的参数通常会“溢出”到栈上。
- en: '**The C Calling Convention**'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**C调用约定**'
- en: The *C calling convention* is the default calling convention used by most C
    compilers when generating function calls. The keyword `_cdecl` may be used in
    a function’s prototype to force the use of this calling convention in C/C++ programs.
    The `cdecl` calling convention specifies that the caller place any stack-allocated
    parameters to a function on the stack in right-to-left order and that the caller
    (as opposed to the callee) remove the parameters from the stack after the called
    function completes. For 32-bit x86 binaries, `cdecl` passes all arguments on the
    program stack. For 64-bit x86 binaries, `cdecl` varies by operating system; on
    Linux, up to six arguments are placed in registers `RDI`, `RSI`, `RDX`, `RCX`,
    `R8`, and `R9`, in that order, and any additional arguments spill onto the stack.
    For ARM binaries, `cdecl` passes the first four arguments in registers `R0` to
    `R3`, with arguments five and later spilling onto the stack.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*C调用约定*是大多数C编译器在生成函数调用时使用的默认调用约定。在C/C++程序中，可以使用关键字`_cdecl`强制使用此调用约定。`cdecl`调用约定规定调用者将任何栈分配的函数参数按从右到左的顺序放置到栈上，并且调用者（而不是被调用者）在被调用函数完成后从栈中移除参数。对于32位x86二进制文件，`cdecl`将所有参数放在程序栈上。对于64位x86二进制文件，`cdecl`根据操作系统有所不同；在Linux上，最多六个参数被放置在寄存器`RDI`、`RSI`、`RDX`、`RCX`、`R8`和`R9`中，顺序如下，任何额外的参数将溢出到栈上。对于ARM二进制文件，`cdecl`将前四个参数放在寄存器`R0`到`R3`中，第五个及以后的参数溢出到栈上。'
- en: When stack-allocated arguments are placed on the stack in right-to-left order,
    the leftmost argument will always be on the top of the stack when the function
    is called. This makes the first argument easy to locate regardless of the number
    of parameters the function expects, and it makes the `cdecl` calling convention
    ideally suited for use with functions that can take a variable number of arguments
    (such as `printf`).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当栈分配的参数按从右到左的顺序放置到栈上时，最左边的参数在函数调用时将始终位于栈顶。这使得第一个参数在不考虑函数期望的参数数量的情况下也能轻松找到，同时这也使得`cdecl`调用约定非常适合用于可以接受可变数量参数的函数（如`printf`）。
- en: Requiring the calling function to remove parameters from the stack means that
    you will often see instructions that make an adjustment to the program stack pointer
    immediately following the return from a called function. In the case of functions
    that can accept a variable number of arguments, the caller knows exactly how many
    arguments it passed to the function and can easily make the correct adjustment,
    whereas the called function does not know ahead of time how many parameters it
    will receive.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要求调用函数从栈中移除参数意味着你通常会看到在从被调用函数返回后，紧接着有指令调整程序栈指针。在可以接受可变数量参数的函数中，调用者确切知道它传递了多少参数，因此可以轻松地做出正确的调整，而被调用函数则无法事先知道它将接收到多少个参数。
- en: 'In the following examples, we consider calls to functions in a 32-bit, x86
    binary, each using a different calling convention. The first function has the
    following prototype:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们考虑对32位x86二进制文件中的函数的调用，每个函数使用不同的调用约定。第一个函数有如下原型：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'By default, this function will use the `cdecl` calling convention, expecting
    the four parameters to be pushed in right-to-left order and requiring the caller
    to clean the parameters off the stack. Given the following function call in C:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此函数将使用`cdecl`调用约定，期望四个参数按从右到左的顺序推送，并要求调用者在每次调用后清理堆栈上的参数。给定以下C语言中的函数调用：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'a compiler might generate the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器可能会生成如下代码：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The four `PUSH` operations ➊ change the program stack pointer `(ESP)` by 16
    bytes (`4 * sizeof(int)` on a 32-bit architecture), which is undone immediately
    following the return from `demo_cdecl` ➋. The following technique, which has been
    used in some versions of the GNU compilers (`gcc` and `g++`), also adheres to
    the `cdecl` calling convention while eliminating the need for the caller to explicitly
    clean parameters off the stack following each call to `demo_cdecl`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 四个`PUSH`操作➊会将程序堆栈指针`(ESP)`改变16个字节（在32位架构上为`4 * sizeof(int)`），在从`demo_cdecl`返回后会立即撤销这一操作➋。以下技术在某些版本的GNU编译器（`gcc`和`g++`）中使用，同时遵循`cdecl`调用约定，并消除了调用者在每次调用`demo_cdecl`后显式清理堆栈参数的需求：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, when the parameters for `demo_cdecl` are placed on the stack,
    there is no change to the program stack pointer. Note that either method results
    in the stack pointer pointing to the leftmost stack argument when the function
    is called.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当`demo_cdecl`的参数被放置到堆栈上时，程序堆栈指针没有发生变化。请注意，无论使用哪种方法，当函数被调用时，堆栈指针都会指向最左侧的堆栈参数。
- en: '##### **The Standard Calling Convention**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '##### **标准调用约定**'
- en: 'In 32-bit Windows DLLs, Microsoft makes heavy use of a calling convention it
    has named the *standard calling convention*. In source code, this may be mandated
    by the use of the `_stdcall` modifier in a function declaration, as shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在32位Windows DLL中，微软大量使用了一种它命名为*标准调用约定*的调用约定。在源代码中，这可以通过在函数声明中使用`_stdcall`修饰符来强制，如下所示：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To avoid any confusion surrounding the word *standard*, we refer to this calling
    convention as the `stdcall` calling convention for the remainder of the book.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免“标准”一词的混淆，我们在本书的其余部分将这种调用约定称为`stdcall`调用约定。
- en: The `stdcall` calling convention also requires that any stack-allocated function
    parameters be placed on the program stack in right-to-left order, but the called
    function is responsible for clearing any stack-allocated arguments from the stack
    when the function has finished. This is possible only for functions that accept
    a fixed number of parameters; variable argument functions such as `printf` cannot
    use the `stdcall` calling convention.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdcall`调用约定还要求任何堆栈分配的函数参数按照从右到左的顺序放置在程序堆栈上，但被调用的函数负责在函数执行完毕后清除堆栈上的参数。这只有在函数接受固定数量的参数时才可行；像`printf`这样的可变参数函数不能使用`stdcall`调用约定。'
- en: 'The `demo_stdcall` function expects three integer parameters, occupying a total
    of 12 bytes on the stack (`3 * sizeof(int)` on a 32-bit architecture). An x86
    compiler can use a special form of the `RET` instruction to simultaneously pop
    the return address from the top of the stack and add to the stack pointer to clear
    the stack-allocated function arguments. In the case of `demo_stdcall`, we might
    see the following instruction used to return to the caller:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`demo_stdcall`函数期望三个整数参数，总共占用12个字节的堆栈空间（在32位架构上为`3 * sizeof(int)`）。x86编译器可以使用一种特殊形式的`RET`指令，同时从堆栈顶部弹出返回地址，并通过堆栈指针的调整来清除堆栈分配的函数参数。以`demo_stdcall`为例，我们可能会看到以下指令用于返回给调用者：'
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using `stdcall` eliminates the need to clean parameters off the stack following
    every function call, which results in slightly smaller, slightly faster programs.
    By convention, Microsoft uses the `stdcall` convention for all fixed-argument
    functions exported from 32-bit shared library (DLL) files. This is an important
    point to remember if you are attempting to generate function prototypes or binary-compatible
    replacements for any shared library components.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`stdcall`可以消除每次函数调用后清理堆栈参数的需求，这会导致程序稍微更小、运行稍微更快。根据约定，微软对于所有从32位共享库（DLL）文件导出的固定参数函数使用`stdcall`约定。如果你打算为任何共享库组件生成函数原型或二进制兼容替代品，这一点非常重要。
- en: '**The fastcall Convention for x86**'
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The Microsoft C/C++ and GNU `gcc`/`g++` (version 3.4 and later) compilers recognize
    the `fastcall` convention, a variation on the `stdcall` convention where the first
    two parameters are placed in the `ECX` and `EDX` registers, respectively. Any
    remaining parameters are placed on the stack in right-to-left order, and called
    functions are responsible for removing parameters from the stack when they return
    to their caller. The following declaration demonstrates the use of the `fastcall`
    modifier:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Given the following function call in C:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'a compiler might generate the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: No stack adjustment is required upon return from `demo_fastcall`, as `demo_fastcall`
    is responsible for clearing parameters `y` and `z` from the stack as it returns
    to the caller. It is important to understand that because two arguments are passed
    in registers, the called function needs to clear only 8 bytes from the stack even
    though there are four arguments to the function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '**C++ Calling Conventions**'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Nonstatic member functions in C++ classes must make available a pointer to the
    object used to invoke the function (the `this` pointer).^([3](footnotes.xhtml#ch06fn3))
    The address of the object used to invoke the function must be provided by the
    caller as a parameter, but the C++ language standard does not specify how `this`
    should be passed, so it should come as no surprise that different compilers use
    different techniques.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: On x86, Microsoft’s C++ compiler utilizes the `thiscall` calling convention,
    which passes `this` in the `ECX/RCX` register and requires the non-static member
    function to clean parameters off the stack, as in `stdcall`. The GNU `g++` compiler
    treats `this` as the implied first parameter to any nonstatic member function
    and behaves in all other respects as if the `cdecl` convention is being used.
    Thus, for `g++`-compiled 32-bit code, `this` is placed on top of the stack prior
    to calling the nonstatic member function, and the caller is responsible for removing
    parameters (there will always be at least one) from the stack after the function
    returns. Additional characteristics of compiled C++ programs are discussed in
    [Chapters 8](ch08.xhtml#ch08) and [20](ch20.xhtml#ch20).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '**Other Calling Conventions**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Complete coverage of every calling convention would require a book in its own
    right. Calling conventions are often operating system, language, compiler, and/or
    processor specific, and some research on your part may be required if you encounter
    code generated by less-common compilers. A few additional situations deserve special
    mention, however: optimized code, custom assembly language code, and system calls.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: When functions are exported for use by other programmers (such as library functions),
    it is important that they adhere to well-known calling conventions so that programmers
    can easily interface to those functions. On the other hand, if a function is intended
    for internal program use only, then the calling convention used by that function
    need be known only within the program. In such cases, optimizing compilers may
    choose to use alternate calling conventions to generate faster code. For example,
    the use of the `/GL` option with Microsoft C/C++ instructs it to perform “whole
    program optimization,” which may result in optimized use of registers across function
    boundaries, and the use of the `regparm` keyword with GNU `gcc`/`g++` allows the
    programmer to dictate that up to three arguments be passed to registers.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被导出供其他程序员使用（例如库函数）时，重要的是它们需要遵循公认的调用约定，以便程序员能够轻松地与这些函数进行接口。另一方面，如果一个函数仅供程序内部使用，那么该函数使用的调用约定只需要在程序内部了解。在这种情况下，优化编译器可能会选择使用替代的调用约定来生成更快的代码。例如，使用
    Microsoft C/C++ 的 `/GL` 选项会指示它执行“整体程序优化”，这可能会导致在函数边界间优化寄存器的使用，而使用 GNU `gcc`/`g++`
    的 `regparm` 关键字允许程序员指定最多三个参数通过寄存器传递。
- en: When programmers go to the trouble of writing in assembly language, they gain
    complete control over how parameters will be passed to any functions that they
    create. Unless they wish to make their functions available to other programmers,
    assembly language programmers are free to pass parameters in any way they see
    fit. As a result, take extra care when analyzing custom assembly code, like obfuscation
    routines and shellcode.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员费心编写汇编语言时，他们将完全控制如何将参数传递给他们创建的任何函数。除非他们希望将其函数提供给其他程序员，否则汇编语言程序员可以自由地以任何他们认为合适的方式传递参数。因此，在分析自定义汇编代码（如混淆例程和shellcode）时需要特别小心。
- en: A *system call* is a special type of function call used to request an operating
    system service. System calls usually affect a state transition from user mode
    to kernel mode in order for the operating system kernel to service the user’s
    request. The manner in which system calls are initiated varies across operating
    systems and processors. For example, 32-bit Linux x86 system calls may be initiated
    using the `INT 0x80` instruction or the `sysenter` instruction, while other x86
    operating systems may use only the `sysenter` instruction or alternate interrupt
    numbers, and 64-bit x86 code uses the `syscall` instruction. On many x86 systems
    (Linux being an exception), parameters for system calls are placed on the runtime
    stack, and a system call number is placed in the `EAX` register immediately prior
    to initiating the system call. Linux system calls accept their parameters in specific
    registers and occasionally in memory when there are more parameters than available
    registers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统调用*是一种特殊类型的函数调用，用于请求操作系统服务。系统调用通常会引发从用户模式到内核模式的状态转换，以便操作系统内核处理用户的请求。系统调用的启动方式在不同的操作系统和处理器之间有所不同。例如，32位的Linux
    x86系统调用可能使用 `INT 0x80` 指令或 `sysenter` 指令来启动，而其他x86操作系统可能只使用 `sysenter` 指令或替代的中断号，64位x86代码则使用
    `syscall` 指令。在许多x86系统上（Linux为例外），系统调用的参数被放置在运行时栈上，且在启动系统调用之前，系统调用号被放入 `EAX` 寄存器。Linux系统调用在特定的寄存器中接受参数，当可用寄存器不足时，参数有时会放置在内存中。'
- en: '***Additional Stack Frame Considerations***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***附加栈帧考虑***'
- en: On any processor, registers are a finite resource that need to be shared, cooperativley,
    among all functions within a program. When a function (`func1`) is executing,
    its world view is that it has complete control over all processor registers. When
    `func1` calls another function (`func2`), `func2` may wish to adopt this same
    view and make use of all available processor registers according to its own needs,
    but if `func2` makes arbitrary changes to the registers, it may destroy values
    that `func1` depends on.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何处理器上，寄存器是有限的资源，需要在程序中的所有函数之间进行共享与合作。当一个函数（`func1`）正在执行时，它的视角是它完全控制所有处理器寄存器。当`func1`调用另一个函数（`func2`）时，`func2`可能希望采用相同的视角，并根据自己的需求使用所有可用的处理器寄存器，但如果`func2`随意更改寄存器，它可能会破坏`func1`所依赖的值。
- en: 'To address this problem, all compilers follow well-defined rules for register
    allocation and use. These rules are generally referred to as a platform’s *application
    binary interface (ABI)*. An ABI divides registers into two categories: caller-saved
    and callee-saved. When one function calls another, the caller needs to save only
    registers in the caller-saved category to prevent values from being lost. Any
    registers in the callee-saved category must be saved by the called function (the
    callee) before that function is allowed to use any of those registers for its
    own purposes. This typically takes place as part of the function’s prologue sequence,
    with the caller’s saved values being restored within the function’s epilogue immediately
    prior to returning. Caller-saved registers are referred to as *clobber* registers
    because a called function is free to modify their contents without first saving
    any of them. Conversely, callee-saved registers are referred to as *no-clobber*
    registers.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The System V ABI for Intel 32-bit processors states that the caller-saved registers
    include `EAX`, `ECX`, and `EDX`, while the callee-saved registers include `EBX`,
    `EDI`, `ESI`, `EBP`, and `ESP`.^([4](footnotes.xhtml#ch06fn4)) In compiled code,
    you may notice that compilers often prefer to use caller-saved registers within
    a function because they are relieved from the responsibility of saving and restoring
    their contents on entry and exit from the function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '***Local Variable Layout***'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unlike the calling conventions that dictate how parameters are passed into
    a function, no conventions dictate the memory layout of a function’s local variables.
    When compiling a function, a compiler must compute the amount of space required
    by a function’s local variables, along with space required to save any no-clobber
    registers, and determine whether those variables can be allocated in processor
    registers or whether they must be allocated on the program stack. The exact manner
    in which these allocations are made is irrelevant to both the caller of a function
    and to any functions that may, in turn, be called, and it is not generally possible
    to determine a function’s local variable layout based solely on examination of
    the function’s source code. One thing is certain with regard to stack frames:
    the compiler must dedicate at least one register to remember the location of a
    function’s newly allocated stack frame. The most obvious choice for this register
    is the stack pointer, which, by definition, points at the stack and thus the current
    function’s stack frame.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '***Stack Frame Examples***'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you perform any complex task, such as reverse engineering a binary, you
    should always strive to make efficient use of your time. When it comes to understanding
    the behavior of a disassembled function, the less time you spend examining common
    code sequences, the more time you will have to spend on difficult sequences. Function
    prologues and epilogues are excellent examples of common code sequences, and it
    is important that you’re able to recognize them, understand them, and rapidly
    move on to more interesting code that requires more thought.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Ghidra summarizes its understanding of function prologues in the local variable
    list at the head of each function listing, and while it may make the code more
    readable, it does nothing to reduce the amount of disassembled code that you need
    to read. In the following examples, we discuss two common types of stack frames
    and review the code necessary to create them so that when you encounter similar
    code in the wild, you can quickly move through it to get to the meat of a function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following function compiled on a 32-bit x86-based computer:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The local variables for `demo_stackframe` require 76 bytes (three 4-byte integers
    and a 64-byte buffer). This function could use either `stdcall` or `cdecl`, and
    the stack frame would look the same.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 1: Local Variable Access via the Stack Pointer**'
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Figure 6-5](ch06.xhtml#fig6_5) shows one possible stack frame for an invocation
    of `demo_stackframe`. In this example, the compiler has elected to utilize the
    stack pointer anytime it references a variable contained in the stack frame, leaving
    all other registers available for other purposes. If any instruction causes the
    value of the stack pointer to change, the compiler must ensure that it accounts
    for that change in all subsequent local variable accesses.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-5.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-5: Sample stack frame for a function compiled on a 32-bit x86 computer*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'The space for this frame is set up on entry to `demo_stackframe` with the one-line
    prologue:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The Offset column in [Figure 6-5](ch06.xhtml#fig6_5) indicates the x86 addressing
    mode (base + displacement in this case) required to reference each of the local
    variables and parameters in the stack frame. In this case, `ESP` is being used
    as the base register, and each displacement is the relative offset from `ESP`
    to the start of the variable within the stack frame. However, the displacements
    shown in [Figure 6-5](ch06.xhtml#fig6_5) are correct only as long as the value
    held in `ESP` doesn’t change. Unfortunately, the stack pointer changes frequently,
    and the compiler must constantly adapt to ensure that proper offsets are used
    when referencing any variables within the stack frame. Consider the call made
    to `helper` in the function `demo_stackframe`, the code for which is shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first `PUSH` ➊ correctly pushes local variable `y` per the offset in [Figure
    6-5](ch06.xhtml#fig6_5). At first glance, it might appear that the second `PUSH`
    ➋ incorrectly references local variable `y` a second time. However, because all
    variables in the stack frame are referenced relative to `ESP` and the first `PUSH`
    ➊ modifies `ESP`, all of the offsets in [Figure 6-5](ch06.xhtml#fig6_5) must be
    temporarily adjusted. Therefore, following the first `PUSH` ➊, the new offset
    for local variable `z` becomes `[ESP+4]`. When examining functions that reference
    stack frame variables using the stack pointer, you must be careful to note any
    changes to the stack pointer and adjust all future variable offsets accordingly.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `demo_stackframe` has completed, it needs to return to the caller. Ultimately,
    a `RET` instruction will pop the desired return address off the top of the stack
    into the instruction pointer register (`EIP` in this case). Before the return
    address can be popped, the local variables need to be removed from the top of
    the stack so that the stack pointer correctly points to the saved return address
    when the `RET` instruction is executed. For this particular function (assuming
    the `cdecl` calling convention is in use), the epilogue becomes the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Example 2: Give the Stack Pointer a Break**'
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At the expense of dedicating a second register to locating variables with a
    stack frame, the stack pointer may be allowed to freely change without the need
    to recompute offsets for each variable within the frame. Of course, the compiler
    needs to commit to not changing this second register; other­wise, it will need
    to contend with the same issues raised in the previous example. In this situation,
    the compiler needs to first select a register for this purpose and then it must
    generate code to initialize that register on entry to the function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Any register selected for this purpose is known as a *frame pointer*. In the
    preceding example, `ESP` was being used as a frame pointer, and we can say that
    it was an `ESP`-based stack frame. The ABI for most architectures suggests which
    register should be used as a frame pointer. The frame pointer is always considered
    a no-clobber register because the calling function may already be using it for
    the same purpose. In x86 programs, the `EBP`/`RBP` (extended base pointer) register
    is typically dedicated for use as a frame pointer. By default, most compilers
    generate code to use a register other than the stack pointer as a frame pointer,
    though options typically exist for specifying that the stack pointer should be
    used instead. (GNU `gcc`/`g++`, for example, offers the `-fomit-frame-pointer`
    compiler option, which generates functions that do not use a second register as
    a frame pointer.)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what the stack frame for `demo_stackframe` will look like using a dedicated
    frame pointer, we need to consider this new prologue code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `PUSH` instruction ➊ saves the value of `EBP` currently being used by the
    caller because `EBP` is a no-clobber register. The caller’s value of `EBP` must
    be restored before we return. If any other registers need to be saved on behalf
    of the caller (`ESI` or `EDI`, for example), compilers may save them at the same
    time `EBP` is saved, or they may defer saving them until local variables have
    been allocated. Thus, there is no standard location within a stack frame for the
    storage of saved registers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Once `EBP` has been saved, it can be changed to point to the current stack location
    with the `MOV` instruction ➋, which copies the current value of the stack pointer
    (the only register guaranteed to be pointing into the stack at this moment in
    time) into `EBP`. Finally, as in the `ESP`-based stack frame, space for local
    variables is allocated ➌. The resulting stack frame layout is shown in [Figure
    6-6](ch06.xhtml#fig6_6).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-6.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-6: An* EBP*-based stack frame*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'With a dedicated frame pointer, all variable offsets can now be computed relative
    to the frame pointer register, as seen in [Figure 6-6](ch06.xhtml#fig6_6). It
    is most often (though not necessarily) the case that positive offsets are used
    to access any stack-allocated function arguments, while negative offsets are used
    to access local variables. With a dedicated frame pointer in use, the stack pointer
    may be freely changed without affecting the offset to any variables within the
    frame. The call to the function `helper` can now be implemented as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The fact that the stack pointer has changed following the first `PUSH` ➍ has
    no effect on the access to local variable `z` in the subsequent `PUSH`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'In the epilogue of a function that uses a frame pointer, the caller’s frame
    pointer must be restored prior to returning. If the frame pointer is to be restored
    using a `POP` instruction, local variables must be cleared from the stack before
    the old value of the frame pointer can be popped, but this is made easy by the
    fact that the current frame pointer points to the location on the stack that holds
    the saved frame pointer value. In 32-bit x86 programs utilizing `EBP` as a frame
    pointer, the following code represents a typical epilogue:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This operation is so common that the x86 architecture offers the `LEAVE` instruction
    to accomplish the same task:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: While the names of registers and instructions used will certainly differ for
    other processor architectures, the basic process of building stack frames will
    remain the same. Regardless of the architecture, you will want to familiarize
    yourself with typical prologue and epilogue sequences so that you can quickly
    move on to analyzing more interesting code within functions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '**Ghidra Stack Views**'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Stack frames are a runtime concept; a stack frame can’t exist without a stack
    and without a running program. While this is true, it doesn’t mean that you should
    ignore the concept of a stack frame when you are performing static analysis with
    tools such as Ghidra. All of the code required to set up stack frames for each
    function is present within a binary. Through careful analysis of this code, we
    can gain a detailed understanding of the structure of any function’s stack frame,
    even though the function is not running. In fact, some of Ghidra’s most sophisticated
    analysis is performed specifically to determine the layout of stack frames for
    every function that it disassembles.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Ghidra Stack Frame Analysis***'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: During initial analysis, Ghidra goes to great lengths to track the behavior
    of the stack pointer over the course of a function by making note of every `PUSH`
    or `POP` operation along with any arithmetic operations that may change the stack
    pointer, such as adding or subtracting constant values. The goal of this analysis
    is to determine the exact size of the local variable area allocated to a function’s
    stack frame, determine whether a dedicated frame pointer is in use in a given
    function (by recognizing a `PUSH EBP/MOV EBP, ESP` sequence, for example), and
    recognize all memory references to variables within a function’s stack frame.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: For example, if Ghidra noted the instruction
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: in the body of `demo_stackframe`, it would understand that the first argument
    to the function (`a` in this case) is being loaded into the `EAX` register (refer
    to [Figure 6-6](ch06.xhtml#fig6_6)). Ghidra can distinguish between memory references
    that access function arguments (those that lie below the saved return address)
    and references that access local variables (those that lie above the saved return
    address).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Ghidra takes the additional step of determining which memory locations within
    a stack frame are directly referenced. For example, while the stack frame in [Figure
    6-6](ch06.xhtml#fig6_6) is 96 bytes in size, there are only seven variables that
    we are likely to see referenced (four locals and three parameters). As a result,
    you can focus your attention on the seven things that Ghidra has identified as
    important and spend less time thinking about all the bytes that Ghidra has left
    unnamed. In the process of identifying and naming individual items within a stack
    frame, Ghidra also recognizes the spatial relationship of variables with respect
    to one another. This can be tremendously helpful in some use cases, such as exploit
    development, when Ghidra makes it easy to determine exactly which variables may
    get overwritten as the result of a buffer overflow. Ghidra’s decompiler (discussed
    in [Chapter 19](ch19.xhtml#ch19)) also relies heavily on stack frame analysis,
    and it uses the results to infer how many arguments a function receives and what
    local variable declarations are necessary in the decompiled code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '***Stack Frames in Listing View***'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Understanding the behavior of a function often comes down to understanding
    the types of data that the function manipulates. When you’re reading a disassembly
    listing, one of the first opportunities you have to understand the data that a
    function manipulates is to view the breakdown of the function’s stack frame. Ghidra
    offers two views into any function’s stack frame: a summary view and a detailed
    view. To understand these two views, we will refer to the following version of
    `demo_stackframe`, which we have compiled using `gcc`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As local variables exist only while the function is running, any local variable
    that is not used in the function in a meaningful way is essentially useless. From
    a high-level view, the following code is a functionally equivalent (you might
    say optimized) version of `demo_stackframe`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: (So, while this function acts like it is doing a lot of work, it’s really just
    trying to look busy to impress the boss.)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: In the original version of `demo_stackframe`, local variables `x` and `y` are
    initialized from parameters `k` and `j`, respectively. Local variable `z` is initialized
    with the literal value 10, and the first character in the 64-byte local array,
    named `buffer`, is initialized to the character `'A'`. The corresponding Ghidra
    disassembly of this function, using the default auto analysis, is shown in [Figure
    6-7](ch06.xhtml#fig6_7).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-7.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-7: Disassembly of the* demo_stackframe *function*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: There are many points to cover in this listing as we begin to acquaint ourselves
    with Ghidra’s disassembly notation. In this discussion, we focus on two sections
    of the disassembly that provide us with particularly useful information. Let’s
    start by zooming in on the stack summary, as shown in the following listing. (You
    can always refer back to [Figure 6-7](ch06.xhtml#fig6_7) to see this summary stack
    frame in context.) To simplify the discussion, the terms *local variable* and
    *argument* are used to distinguish between the two types of variables. The term
    *variable* is used when discussing both collectively.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Ghidra provides a summary stack view that lists every variable directly referenced
    within the stack frame, along with important information about each. The meaningful
    names (in the third column) that Ghidra assigns to each variable provide information
    about the variables when you see them throughout the disassembly listing: the
    names of arguments passed to the function begin with a helpful prefix of `param_`,
    and local variable names begin with `local_`. As a result, it is easy to distinguish
    between the two types of variables.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable name prefixes are combined with information about the position
    or location of a variable. For arguments, like `param_3`, the number in the name
    corresponds to the argument’s position in the function’s parameter list. For local
    variables, like `local_10`, the number is a hexadecimal offset representing the
    variable’s location within the stack frame. The location can also be found in
    the center column of the listing, to the left of the names. This column has two
    components separated by a colon: Ghidra’s estimate of the size of the variable
    in bytes, and the location of the variable within the stack frame, represented
    as the offset of that variable from the initial stack pointer value on entry into
    the function.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: A tabular representation of this stack frame is shown in [Figure 6-8](ch06.xhtml#fig6_8).
    As discussed, parameters lie below the saved return address and thus have a positive
    offset from the return address. Local variables lie above the saved return address
    and thus have a negative offset. The order of the local variables in the stack
    do not match the order in which they were declared in the source code shown earlier
    in this chapter, because the compiler is free to arrange local variables on the
    stack based on a variety of internal factors, such as byte alignment and placement
    of arrays relative to other local variables.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-8.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-8: Sample stack frame image*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '***Decompiler-Assisted Stack Frame Analysis***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Remember the functional equivalent of the code that we identified?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The code that the decompiler generated for this function is shown in [Figure
    6-9](ch06.xhtml#fig6_9). Ghidra’s decompiler-generated code is very similar to
    our optimized code, as the decompiler includes only the executable equivalent
    of the original function. (The exception is the inclusion of `param_1`.)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-9.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-9: Decompiler window for* demo_stackframe *(with Decompiler Parameter
    ID analyzer)*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that the function `demo_stackframe` accepted three integer
    parameters, but only two of them (`param_1` and `param_2`) are accounted for in
    the decompiler listing. Which one is missing and why? It turns out that the Ghidra
    disassembler and the Ghidra decompiler approach the names a little differently.
    While both name all of the parameters up to the last one referenced, the decompiler
    names only the parameters up to the last one that is used in a meaningful way.
    One of the analyzers that Ghidra can run for you is called the *Decompiler Parameter
    ID* analyzer. In most cases, this analyzer is not enabled by default (it is enabled
    for only Windows PE files smaller than 2MB). When the Decompiler Parameter ID
    analyzer is enabled, Ghidra uses decompiler-derived parameter information to name
    a function’s parameters in the disassembly listing. The following listing shows
    the variables in the disassembly listing of `demo_stackframe` when the Decompiler
    Parameter ID analyzer is enabled:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that `param_3` no longer appears in the list of function arguments, as
    the decompiler has determined that it is not used in any meaningful way within
    the function. This particular stack frame is discussed further in [Chapter 8](ch08.xhtml#ch08).
    If you ever want Ghidra to perform Decompiler Parameter ID analysis after opening
    a binary with that analyzer disabled, you can always choose Analysis ▸ One Shot
    ▸ Decompiler Parameter ID to run the analyzer after the fact.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '***Local Variables as Operands***'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s shift our focus to the actual disassembly portion of the following listing:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The function uses a common function prologue ➊ for an `EBP`-based stack frame.
    The compiler allocates 88 bytes (`0x58` equals 88) of local variable space ➋ in
    the stack frame. This is slightly more than the estimated 76 bytes and demonstrates
    that compilers occasionally pad the local variable space with extra bytes in order
    to maintain a particular memory alignment within the stack frame.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: An important difference between Ghidra’s disassembly listing and the stack frame
    analysis that we performed earlier is that in the disassembly listing you don’t
    see memory references similar to `[EBP-12]` (which you might see with `objdump`,
    for example). Instead, Ghidra has replaced all constant offsets with symbolic
    names corresponding to the symbols in the stack view and their relative offsets
    from the function’s initial stack pointer location. This is in keeping with Ghidra’s
    goal of generating a higher-level disassembly. It is simply easier to deal with
    symbolic names than numeric constants. It also gives us a name that can be modified
    to match our understanding of the variable’s purpose once known. Ghidra does display
    the raw form of the current instruction, without any labels, in the extreme, lower-right
    corner of the CodeBrowser window for reference.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, since we have source code available for comparison, we can
    map the Ghidra-generated variable names back to the names used in the original
    source by using a variety of clues available in the disassembly:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: First, `demo_stackframe` accepts three parameters, `i`, `j`, and `k`, which
    correspond to variables `param_1`, `param _2`, and `param _3`, respectively.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Local variable `x` (`local_10`) is initialized from parameter `k` (`param_3`)
    ➌.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, local variable `y` (`local_14`) is initialized from parameter `j`
    (`param _2)` ➍.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Local variable `z` (`local_18`) is initialized with the value 10 ➎.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first character `buffer[0]` (`local_58`) in the 64-byte character array
    is initialized with *A* (ASCII `0x41`) ➏.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The two arguments for the call to `helper` are pushed onto the stack ➐. The
    8-byte stack adjustment that precedes these two pushes combines with the two pushes
    to yield a net stack change of 16 bytes. As a result, the stack maintains any
    16-byte alignment achieved earlier in the program.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***The Ghidra Stack Frame Editor***'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to the summary stack view, Ghidra offers a detailed stack frame
    editor in which every byte allocated to a stack frame is accounted for. The Stack
    Frame Editor window is accessed by right-clicking and selecting Function ▸ Edit
    Stack Frame from the context menu when you have selected a function or stack variable
    within Ghidra’s summary stack view for a function. The resulting window for the
    `demo_stackframe` function is shown in [Figure 6-10](ch06.xhtml#fig6_10).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-10.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-10: Sample summary stack view*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Because the detailed view accounts for every byte in the stack frame, it occupies
    significantly more space than the summary view. The portion of the stack frame
    shown in [Figure 6-10](ch06.xhtml#fig6_10) spans a total of 29 bytes, which is
    only a small portion of the entire stack frame. Also in the previous listing,
    `local_10` ➌, `local_14` ➍, and `local_18` ➎ are directly referenced in the disassembly
    listing where their contents were initialized using `dword` (4-byte) writes. Based
    on the fact that 32 bits of data were moved, Ghidra is able to infer that each
    of these variables is a 4-byte quantity and labels each as an `undefined4` (a
    4-byte variable of unknown type).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: As this is a Stack Frame Editor, we can use this window to edit fields, change
    display formats, and add supplemental information if it benefits our process.
    For example, we could add a name for the saved return address at `0x0`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '**REGISTER-BASED PARAMETERS**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: ARM calling conventions use up to four registers to pass parameters to functions
    without using the stack. Some x86-64 conventions use as many as six registers,
    and some MIPS conventions use up to eight. Register-based parameters are a little
    harder to identify than stack-based parameters.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following two assembly language fragments:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the first function, the region of the stack beneath the saved return address
    is being accessed ➊, and we conclude that the function expects at least one argument.
    Ghidra, like most high-end disassemblers, performs stack pointer and frame pointer
    analysis to identify instructions that access members of a function’s stack frame.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: In the second function, `RDI` is used ➋ before it has been initialized. The
    only logical conclusion is that `RDI` must have been initialized in the caller,
    in which case `RDI` is being used to pass information from the caller into the
    `regargs` function (that is, it is a parameter). In program analysis terms, `RDI`
    is *live* on entry to `regargs`. To determine the number of register-based parameters
    the function expects, identify all registers that appear to be live within a function
    by observing that their contents are read and utilized before the register has
    been written (initialized) within a function.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this data flow analysis is usually beyond the capabilities of
    most disassemblers, including Ghidra. Decompilers, on the other hand, must perform
    this type of analysis and are generally quite good at identifying the use of register-based
    parameters. Ghidra’s Decompiler Parameter ID analyzer (Edit ▸ Options for <prog>
    ▸ Properties ▸ Analyzers) can update the disassembly listing based on parameter
    analysis performed by the decompiler.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The stack editor view offers a detailed look at the inner workings of compilers.
    In [Figure 6-10](ch06.xhtml#fig6_10), it is clear that the compiler has inserted
    8 extra bytes between the saved frame pointer `-0x4` and the local variable `x`
    (`local_10`). These bytes occupy offsets `-0x5` through `-0xc` in the stack frame.
    Unless you happen to be a compiler writer yourself or are willing to dig deep
    into the source code for GNU `gcc`, all you can do is speculate as to why these
    extra bytes are allocated in this manner. In most cases, we can chalk up the extra
    bytes to padding for alignment, and usually the presence of these extra bytes
    has no impact on a program’s behavior. In [Chapter 8](ch08.xhtml#ch08), we return
    to the stack editor view and its uses in dealing with more complex data types
    such as arrays and structures.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '**Searching**'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As shown at the start of the chapter, Ghidra makes it easy to navigate through
    the disassembly to locate artifacts that you know about and to discover new artifacts.
    It also designs many of its data displays to summarize specific types of information
    (names, strings, imports, and so on), making them easy to find as well. However,
    effective analysis of a disassembly listing often requires the ability to search
    for new clues to inform the disassembly analysis. Fortunately for us, Ghidra has
    a Search menu that allows us to conduct searches to locate items of interest.
    The default search menu options are shown in [Figure 6-11](ch06.xhtml#fig6_11).
    In this section, we investigate methods to search the disassembly by using both
    text and byte search functionality provided in the CodeBrowser.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-11.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-11: Ghidra Search menu options*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Search Program Text***'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Ghidra text searches amount to substring searches through the disassembly listing
    view. Text searches are initiated via Search ▸ Program Text, which opens the dialog
    shown in [Figure 6-12](ch06.xhtml#fig6_12). Two search types are available: the
    entire program database, which extends beyond what you see in the CodeBrowser
    window, and the listing display within the CodeBrowser. Beyond the search type,
    several self-explanatory options let you select how and what to search.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: To navigate between matches, use the Next and Previous buttons at the bottom
    of the Search Program Text dialog, or select Search All to open the search results
    in a new window, allowing easy navigation to any match.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-12.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-12: Search Program Text dialog*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**I DUB THEE . . .**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Search windows are one of the window types within Ghidra that you can rename
    at will, which will help you keep track of search windows as you experiment. To
    rename a window, just right-click the title bar and provide a name that is meaningful
    to you. A handy trick is to include the search string along with a mnemonic to
    help you remember the settings you have chosen.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '***Search Memory***'
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you need to search for specific binary content, such as a known sequence
    of bytes, then text searches are not the answer. Instead, you need to use Ghidra’s
    memory search functionality. A memory search can be initiated using Search ▸ Memory,
    or the associated hotkey S. [Figure 6-13](ch06.xhtml#fig6_13) shows the Search
    Memory dialog. To search for a sequence of hex bytes, the search string should
    be specified as a space-separated list of two-digit, case-insensitive hex values,
    such as `c9 c3`, as shown in [Figure 6-13](ch06.xhtml#fig6_13). If you are not
    sure of the hex sequence, you can use wildcards (* or `?`).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-13.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-13: Search Memory dialog*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The Search Memory results for the bytes `c9 c3`, run with the Search All option,
    are shown in [Figure 6-14](ch06.xhtml#fig6_14). You can sort on any column, rename
    the window, or apply a filter. This window also offers some right-click options,
    including the ability to delete rows and manipulate selections.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-14.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-14: Search Memory results*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Search values can be input in string, decimal, binary, and regular expression
    formats as well. String, decimal, and binary each provide context-appropriate
    format options. Regular expressions let you search for a particular pattern, but
    only in the forward direction, because of restrictions on how they are processed.
    Ghidra uses Java’s built-in regular expressions grammar, which is described in
    significant detail in Ghidra Help.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The intent of this chapter was to provide you with the minimum essential skills
    for effectively interpreting Ghidra’s disassembly listings and navigating your
    way around them. The overwhelming majority of your interactions with Ghidra will
    involve the operations that we have discussed so far. However, the ability to
    perform basic navigation, understand important disassembly constructs like the
    stack, and search the disassembly are just the tip of the iceberg for a reverse
    engineer.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: With these skills safely under your belt, the logical next step is learning
    how to use Ghidra to suit your particular needs. In the next chapter, we begin
    to look at how to make the most basic changes to a disassembly listing as a means
    of adding new knowledge based on our understanding of a binary’s content and behavior.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
