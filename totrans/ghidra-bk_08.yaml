- en: '## **6'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **6'
- en: MAKING SENSE OF A GHIDRA DISASSEMBLY**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解Ghidra反汇编**'
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: In this chapter, we cover important basic skills that will help you to better
    understand the Ghidra disassembly. We start with basic navigational techniques
    that allow you to move through the assembly and examine the artifacts you encounter.
    As you navigate from function to function, you will find that you need to decode
    each function’s prototype by using only clues available in the disassembly. Accordingly,
    we’ll discuss techniques for understanding how many parameters a function receives
    and how we might decode the data types of each parameter we encounter. Since much
    of the work that a function performs is associated with local variables maintained
    by the function, we’ll also discuss how functions use the stack for local variable
    storage and how you can, with Ghidra’s help, understand exactly how a function
    makes use of any stack space it may reserve for itself. Whether you find yourself
    debugging code, analyzing malware, or developing exploits, understanding how to
    decode a function’s stack-allocated variables is an essential skill for understanding
    the behavior of any program. Finally, we will look at the options Ghidra provides
    for searching and how that can contribute to understanding the disassembly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些重要的基础技能，帮助你更好地理解Ghidra的反汇编内容。我们从基本的导航技巧开始，这些技巧可以让你在汇编代码中移动，并检查你遇到的各种文物。随着你从一个函数跳转到另一个函数，你会发现你需要通过仅使用反汇编中提供的线索来解码每个函数的原型。因此，我们将讨论如何理解一个函数接受多少个参数，并且如何解码我们遇到的每个参数的数据类型。由于一个函数执行的大部分工作都与函数维护的局部变量相关，我们还将讨论函数如何使用栈来存储局部变量，以及如何在Ghidra的帮助下准确理解一个函数如何使用它可能为自己保留的任何栈空间。无论你是在调试代码、分析恶意软件，还是开发漏洞，理解如何解码一个函数的栈分配变量是理解任何程序行为的基本技能。最后，我们将介绍Ghidra提供的搜索选项，以及这些选项如何帮助理解反汇编内容。
- en: '**Disassembly Navigation**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**反汇编导航**'
- en: In [Chapters 4](ch04.xhtml#ch04) and [5](ch05.xhtml#ch05), we demonstrated that
    at a basic level, Ghidra combines the features of many common reverse engineering
    tools into its integrated CodeBrowser display. Navigating around the display is
    one of the essential skills required to master Ghidra. Static disassembly listings,
    such as those provided by tools like `objdump`, offer no inherent navigational
    capability other than scrolling up and down the listing. Even with the best text
    editors offering an integrated, `grep`-style search, such *dead listings* are
    very difficult to navigate. Ghidra, on the other hand, provides exceptional navigational
    features. In addition to offering fairly standard search features that you are
    accustomed to from your use of text editors or word processors, Ghidra develops
    and displays a comprehensive list of cross-references that behave like web page
    hyperlinks. The end result is that, in most cases, navigating to locations of
    interest requires nothing more than a double-click.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.xhtml#ch04)和[第5章](ch05.xhtml#ch05)中，我们展示了在基本层面上，Ghidra将许多常见的逆向工程工具的功能集成到它的CodeBrowser显示中。浏览显示内容是掌握Ghidra所需的基本技能之一。静态反汇编清单，例如像`objdump`这样的工具提供的清单，除了上下滚动之外，并没有内建的导航功能。即使是提供集成的`grep`风格搜索的最佳文本编辑器，这种*死列表*也非常难以浏览。另一方面，Ghidra提供了出色的导航功能。除了提供你在使用文本编辑器或文字处理软件时习惯的标准搜索功能外，Ghidra还开发并显示了一个全面的交叉引用列表，这些交叉引用像网页的超链接一样起作用。最终的结果是，在大多数情况下，导航到感兴趣的位置只需要双击即可。
- en: '***Names and Labels***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***名称和标签***'
- en: When a program is disassembled, every location in the program is assigned a
    virtual address. As a result, we can navigate anywhere within a program by providing
    the virtual address of the location we are interested in visiting. Unfortunately
    for us, maintaining a catalog of addresses in our heads is not a trivial task.
    This fact motivated early programmers to assign symbolic names to program locations
    that they wished to reference, making things a whole lot easier on themselves.
    The assignment of symbolic names to program addresses was not unlike the assignment
    of mnemonic instruction names to program opcodes; programs became easier to read
    and write by making identifiers easier to remember. Ghidra continues this tradition
    by creating labels for virtual addresses and allowing the user to modify and expand
    the set of labels. We have already seen the use of names in relation to the Symbol
    Tree window. Recall that double-clicking a name caused the Listing view (and the
    Symbol References window) to jump to the referenced location. While there are
    usage differences between the terms *name* and *label* (for example, functions
    have names and appear in a separate branch of the Ghidra Symbol Tree from labels),
    in a navigational context the terms are largely interchangeable because both represent
    navigational targets.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序被反汇编时，程序中的每个位置都会分配一个虚拟地址。因此，我们可以通过提供我们感兴趣访问的位置的虚拟地址来在程序内导航。不幸的是，记住这些地址并将其整理成目录并非易事。正因为如此，早期的程序员便开始为他们想要引用的程序位置分配符号名称，这使得工作变得轻松得多。将符号名称分配给程序地址就像为程序操作码分配助记符指令名称一样；通过使标识符更容易记住，程序变得更加易于阅读和编写。Ghidra
    继承了这一传统，通过为虚拟地址创建标签并允许用户修改和扩展标签集来延续这一做法。我们已经在 Symbol Tree 窗口中看到过名称的使用。回想一下，双击名称会导致
    Listing 视图（以及 Symbol References 窗口）跳转到引用的位置。虽然在使用上，“名称”和“标签”这两个术语有所不同（例如，函数有名称，并且在
    Ghidra Symbol Tree 中与标签出现在不同的分支中），但在导航上下文中，这两个术语通常可以互换使用，因为它们都表示导航目标。
- en: Ghidra generates symbolic names during the auto analysis phase by using an existing
    name from the binary (if available) or by automatically generating a name based
    on how a location is referenced within the binary. In addition to its symbolic
    purpose, any label displayed in the disassembly window is a potential navigation
    target similar to a hyperlink on a web page. The two major differences between
    these labels and standard hyperlinks are that the labels are not highlighted in
    any way to indicate that they can be followed and that Ghidra generally requires
    a double-click to follow rather than the single-click required by a traditional
    hyperlink.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 在自动分析阶段通过使用二进制文件中现有的名称（如果有）或根据二进制文件中某个位置的引用方式自动生成名称，从而生成符号名称。除了符号用途外，任何在反汇编窗口中显示的标签都是潜在的导航目标，类似于网页上的超链接。这些标签与标准超链接的两大主要区别是：标签没有任何突出显示，无法指示它们可以被点击跟踪，而且
    Ghidra 通常需要双击才能跟踪，而传统的超链接只需单击。
- en: '**YOU ARE INVITED TO THE NAMING CONVENTION!**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**您已被邀请加入命名约定！**'
- en: 'Ghidra provides the user lots of flexibility when assigning labels, but certain
    patterns have a special meaning and are reserved for Ghidra. These include the
    following prefixes when they are followed by an underscore and an address: `EXT`,
    `FUN`, `SUB`, `LAB`, `DAT`, `OFF`, and `UNK`. When you create a label, avoid these
    patterns. In addition, spaces and nonprintable characters are not allowed in labels.
    On the plus side, labels can be up to 2000 characters. Count carefully if you
    think you are in danger of exceeding that limit!'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 在分配标签时为用户提供了很多灵活性，但某些模式有特殊含义，并且是 Ghidra 保留的。这些包括以下前缀，当它们后面跟着下划线和地址时：`EXT`、`FUN`、`SUB`、`LAB`、`DAT`、`OFF`
    和 `UNK`。创建标签时应避免使用这些模式。此外，标签中不允许使用空格和不可打印字符。幸运的是，标签最多可以包含 2000 个字符。如果你认为自己可能会超出这个限制，请仔细计算！
- en: '***Navigation in Ghidra***'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Ghidra 中的导航***'
- en: In the listing shown in [Figure 6-1](ch06.xhtml#fig6_1), each of the symbols
    indicated by a solid arrow represents a named navigational target. Double-clicking
    any of them in the Listing window will cause Ghidra to relocate the Listing display
    (and all connected windows) to the selected location.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 6-1](ch06.xhtml#fig6_1)中显示的列表中，每个由实心箭头指示的符号都代表一个命名的导航目标。在 Listing 窗口中双击它们中的任何一个，Ghidra
    将会将 Listing 显示（以及所有相关窗口）移动到选定的位置。
- en: '![image](Images/fig6-1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-1.jpg)'
- en: '*Figure 6-1: Listing showing navigational targets*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：列出显示导航目标*'
- en: For navigational purposes, Ghidra treats two additional display entities as
    navigational targets. First, cross-references (indicated by dashed arrows in [Figure
    6-1](ch06.xhtml#fig6_1)) are treated as navigational targets. Double-clicking
    the bottom cross-reference address will jump the display to the referencing location
    (`00401331` in this case). Cross-references are covered in more detail in [Chapter
    9](ch09.xhtml#ch09). Hovering over any of these navigable objects will display
    a pop-up that shows the destination code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航方面，Ghidra 将另外两种显示实体视为导航目标。首先，交叉引用（在[图6-1](ch06.xhtml#fig6_1)中由虚线箭头表示）被视为导航目标。双击底部的交叉引用地址将使显示跳转到引用位置（此例中为`00401331`）。交叉引用将在[第9章](ch09.xhtml#ch09)中详细介绍。将鼠标悬停在这些可导航对象上会显示一个弹出框，显示目标代码。
- en: Second, the other type of display entity afforded special treatment in a navigational
    sense is one that uses hexadecimal values. If a displayed sequence of hexadecimal
    values represents a valid virtual address within the binary, then the associated
    virtual address will be displayed to the right, as shown in [Figure 6-2](ch06.xhtml#fig6_2).
    Double-clicking the displayed value will reposition the disassembly window to
    the associated virtual address. In [Figure 6-2](ch06.xhtml#fig6_2), double-clicking
    any of the values indicated by a solid arrow will jump the display, because each
    is a valid virtual address within this particular binary. Double-clicking any
    of the other values will have no effect.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，另一种在导航方面受到特殊处理的显示实体是使用十六进制值的实体。如果显示的十六进制值序列表示二进制文件中的有效虚拟地址，那么关联的虚拟地址将在右侧显示，如[图6-2](ch06.xhtml#fig6_2)所示。双击显示的值将会将反汇编窗口重新定位到该虚拟地址。在[图6-2](ch06.xhtml#fig6_2)中，双击任何由实心箭头指示的值将会跳转显示，因为每个值都是该二进制文件中的有效虚拟地址。双击其他值则不会产生任何效果。
- en: '![image](Images/fig6-2.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-2.jpg)'
- en: '*Figure 6-2: Listing showing hexadecimal navigational targets*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：显示十六进制导航目标的列表*'
- en: '***Go To***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***转到***'
- en: When you know the address or name you want to navigate to (for example, navigating
    to *main* in an ELF binary to begin your analysis), you could scroll through the
    listing to look for the address, scroll through the Functions folder in the Symbol
    Tree window to find the desired name, or use Ghidra’s search features (which are
    discussed later in this chapter). Ultimately, the easiest way to get to a known
    address or name is to use the Go To dialog (shown in [Figure 6-3](ch06.xhtml#fig6_3)),
    accessed via Navigation ▸ Go To or by using the G hotkey while the disassembly
    window is active.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道想要导航到的地址或名称时（例如，在 ELF 二进制文件中导航到 *main* 以开始分析），你可以滚动列表寻找该地址，或者在符号树窗口的函数文件夹中查找所需的名称，或者使用
    Ghidra 的搜索功能（在本章后面会讨论）。最终，最简单的方式是使用“转到”对话框（如[图6-3](ch06.xhtml#fig6_3)所示），可以通过导航
    ▸ 转到，或者在反汇编窗口处于活动状态时使用 G 热键来访问。
- en: '![image](Images/fig6-3.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-3.jpg)'
- en: '*Figure 6-3: The Go To dialog*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：转到对话框*'
- en: Navigating to any location in the binary is as simple as specifying a valid
    address (a case-sensitive symbol name or hex value) and clicking OK, which will
    immediately jump the display to the desired location. Values entered into the
    dialog are made available on subsequent use via a drop-down history list, which
    simplifies returning to previously requested locations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到二进制文件中的任何位置非常简单，只需指定一个有效的地址（区分大小写的符号名称或十六进制值），然后点击确认，显示就会立即跳转到所需位置。输入到对话框中的值会通过下拉历史列表在后续使用中提供，简化了返回先前请求位置的操作。
- en: '***Navigation History***'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***导航历史***'
- en: As a final navigational feature, Ghidra supports forward and backward navigation
    based on the order in which you navigate the disassembly. Each time you navigate
    to a new location within a disassembly, your current location is appended to a
    history list. This list can be traversed from the Go To window or the left and
    right arrow icons in the CodeBrowser toolbar.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最终的导航功能，Ghidra 支持基于你浏览反汇编的顺序进行前后导航。每次你导航到反汇编中的新位置时，当前的位置都会被添加到历史列表中。这个列表可以通过“转到”窗口或者代码浏览器工具栏中的左右箭头图标进行浏览。
- en: In the Go To window, shown in [Figure 6-3](ch06.xhtml#fig6_3), the arrow on
    the right side of the text box opens a picklist that allows you to choose from
    previous locations you have entered in the Go To dialog. The CodeBrowser toolbar
    buttons, seen near the top left in [Figure 6-4](ch06.xhtml#fig6_4), provide familiar
    browser-style forward and backward behavior. Each button is associated with a
    detailed drop-down history list that provides instant access to any location in
    the navigation history without having to retrace your steps through the entire
    list. A sample drop-down list associated with the back arrow is displayed in [Figure
    6-4](ch06.xhtml#fig6_4).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go To 窗口中，如[图 6-3](ch06.xhtml#fig6_3)所示，文本框右侧的箭头打开一个选择列表，允许你从之前在 Go To 对话框中输入的位置信息中选择。CodeBrowser
    工具栏按钮，如[图 6-4](ch06.xhtml#fig6_4)中左上方所见，提供类似浏览器的前进和后退功能。每个按钮都关联着一个详细的下拉历史列表，允许你直接访问导航历史中的任何位置，而不需要重新回溯整个列表。[图
    6-4](ch06.xhtml#fig6_4)中显示了与返回箭头相关的下拉列表示例。
- en: '![image](Images/fig6-4.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-4.jpg)'
- en: '*Figure 6-4: Forward and backward navigation arrows with address list*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：带地址列表的前进和后退导航箭头*'
- en: ALT-left arrow (OPTION-left arrow on Mac), for backward navigation, is one of
    the most useful hotkeys you can commit to memory. Backward navigation is extremely
    handy when you have followed a chain of function calls several levels deep and
    you decide that you want to navigate back to your original position within the
    disassembly. ALT-right arrow (OPTION-right arrow on Mac) moves the disassembly
    window forward in the history list.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ALT-左箭头（Mac 上是 OPTION-左箭头）用于向后导航，是你可以牢记的最有用的快捷键之一。当你已经深入跟踪了一系列函数调用，并且决定返回到反汇编的原始位置时，向后导航非常方便。ALT-右箭头（Mac
    上是 OPTION-右箭头）将反汇编窗口在历史列表中向前移动。
- en: While we now have a much clearer picture regarding navigating a disassembly
    in Ghidra, we still have not attached meaning to the various destinations we have
    visited. The next section investigates what makes functions in general, and stack
    frames in particular, such important navigational targets for a reverse engineer.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在对如何在 Ghidra 中导航反汇编有了更清晰的认识，但我们仍然没有对我们访问过的各个目标赋予意义。下一节将探讨为什么函数（尤其是堆栈帧）对逆向工程师来说是如此重要的导航目标。
- en: '**Stack Frames**'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**堆栈帧**'
- en: Because Ghidra is a low-level analysis tool, many of its features and displays
    expect the user to be somewhat familiar with the low-level details of compiled
    languages, which focus on the specifics of generating machine language and managing
    the memory used by a high-level program. Ghidra pays particular attention to the
    manner in which compilers handle local variable declarations and accesses. You
    may have noticed that a significant number of lines are dedicated to local variables
    at the beginning of most function listings. These lines result from detailed stack
    analysis that Ghidra performs on each function, using its Stack analyzer. This
    analysis is necessary because compilers place a function’s local variables (and
    in some circumstances, the function’s incoming arguments) in blocks of memory
    allocated on the stack. In this section, we review how compilers treat local variable
    and function arguments to help you better understand the details of Ghidra’s Listing
    view.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Ghidra 是一个低级分析工具，它的许多功能和显示期望用户对编译语言的低级细节有一定了解，这些语言专注于生成机器语言和管理高级程序使用的内存。Ghidra
    特别关注编译器如何处理局部变量声明和访问。你可能已经注意到，在大多数函数列表的开头，有大量的行专门用于局部变量。这些行来自 Ghidra 对每个函数进行的详细堆栈分析，通过其堆栈分析器完成。进行此分析是必要的，因为编译器将函数的局部变量（在某些情况下，还包括函数的传入参数）放置在分配到堆栈上的内存块中。在本节中，我们将回顾编译器如何处理局部变量和函数参数，以帮助你更好地理解
    Ghidra 列表视图的细节。
- en: '***Function Call Mechanics***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***函数调用机制***'
- en: A function invocation may require memory for information passed into the function
    in the form of parameters (arguments) and for temporary storage space while executing
    the function. The parameter values, or their corresponding memory addresses, need
    to be stored somewhere the function can locate them. The temporary space is often
    allocated by a programmer through the declaration of local variables, which can
    be used within the function but cannot be accessed after the function has completed.
    *Stack frames* (also known as *activation records*) are blocks of memory allocated
    within a program’s runtime stack and dedicated to a specific invocation of a function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用可能需要为传递给函数的参数（实参）以及执行函数时的临时存储空间分配内存。参数值或其对应的内存地址需要存储在函数能够找到的地方。临时空间通常通过程序员声明局部变量来分配，这些变量可以在函数内使用，但在函数完成后无法访问。*栈帧*（也称为*激活记录*）是分配在程序运行时栈中的内存块，专门用于特定函数调用的内存空间。
- en: Compilers use stack frames to make the allocation and deallocation of function
    parameters and local variables transparent to the programmer. For calling conventions
    that pass parameters on the stack, the compiler inserts code to place a function’s
    parameters into the stack frame prior to transferring control to the function
    itself, at which point the compiler inserts code to allocate enough memory to
    hold the function’s local variables. In some cases, the address to which the function
    should return is also stored within the new stack frame. Stack frames also enable
    recursion,^([1](footnotes.xhtml#ch06fn1)) as each recursive call to a function
    is given its own stack frame, neatly segregating each call from its predecessor.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器使用栈帧使函数参数和局部变量的分配与释放对程序员透明。对于在栈上传递参数的调用约定，编译器会插入代码，在将控制权传递给函数之前，将函数的参数放入栈帧中，随后插入代码分配足够的内存来保存函数的局部变量。在某些情况下，函数应返回的地址也会存储在新的栈帧中。栈帧还支持递归，^([1](footnotes.xhtml#ch06fn1))因为每个递归调用都会得到自己的栈帧，确保每次调用都与前一次调用相互独立。
- en: 'The following operations take place when a function is called:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是函数调用时发生的操作：
- en: The caller places any parameters required by the function being called into
    locations dictated by the calling convention employed by the called function.
    The program stack pointer may change if parameters are passed on the runtime stack.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者将被调用函数所需的任何参数放入被调用函数采用的调用约定所要求的位置。如果参数通过运行时栈传递，则程序栈指针可能会发生变化。
- en: The caller transfers control to the function being called with an instruction
    such as the x86 `CALL`, ARM `BL`, or MIPS `JAL`. A return address is saved onto
    the program stack or in a processor register.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者通过类似 x86 的`CALL`、ARM 的`BL`或 MIPS 的`JAL`指令将控制权传递给被调用的函数。一个返回地址会被保存在程序栈中或处理器寄存器里。
- en: If necessary, the called function configures a frame pointer and saves any register
    values that the caller expects to remain unchanged.^([2](footnotes.xhtml#ch06fn2))
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，被调用的函数配置一个帧指针并保存调用者期望保持不变的寄存器值。^([2](footnotes.xhtml#ch06fn2))
- en: The called function allocates space for any local variables that it may require.
    This is often done by adjusting the program stack pointer to reserve space on
    the runtime stack.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被调用的函数为其可能需要的任何局部变量分配空间。这通常通过调整程序栈指针来预留运行时栈上的空间。
- en: The called function performs its operations, potentially accessing the parameters
    passed to it and generating a result. If the function returns a result, it is
    often placed into a specific register or registers that the caller can examine
    after the function returns.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被调用的函数执行其操作，可能会访问传递给它的参数并生成结果。如果函数返回结果，通常会将其放入一个特定的寄存器中，调用者可以在函数返回后检查该寄存器。
- en: When the function has completed its operations, any stack space reserved for
    local variables is released. This is often done by reversing the actions performed
    in step 4.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当函数完成其操作后，为局部变量保留的任何栈空间会被释放。通常通过逆转步骤 4 中执行的操作来完成这一过程。
- en: Registers whose values were saved (in step 3) on behalf of the caller are restored
    to their original values.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为调用者保存的寄存器值（在步骤 3 中）会被恢复为原始值。
- en: The called function returns control to the caller. Typical instructions for
    this include the x86 `RET`, ARM `POP`, and MIPS `JR`. Depending on the calling
    convention in use, this operation may also clear one or more parameters from the
    program stack.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被调用的函数将控制权返回给调用者。典型的指令包括x86的`RET`、ARM的`POP`和MIPS的`JR`。根据使用的调用约定，这个操作也可能会从程序栈中清除一个或多个参数。
- en: Once the caller regains control, it may need to remove parameters from the program
    stack by restoring the program stack pointer to the value that it held prior to
    step 1.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦调用者重新获得控制权，它可能需要通过恢复程序栈指针到步骤1之前的值，从程序栈中移除参数。
- en: Steps 3 and 4 are so commonly performed upon entry to a function that together
    they are called the function’s *prologue*. Similarly, steps 6 through 8 make up
    the function’s *epilogue*. All of these operations, except step 5, are part of
    the overhead associated with calling a function, which may not be obvious in a
    program’s high-level source code, but is quite observable in assembly language.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤3和步骤4是进入函数时常见的操作，合在一起被称为函数的*序言*。类似地，步骤6到步骤8构成了函数的*尾声*。除了步骤5，这些操作都是与调用函数相关的开销，可能在程序的高级源代码中并不明显，但在汇编语言中却十分可见。
- en: '**ARE THEY REALLY GONE?**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**它们真的被移除了么？**'
- en: When we talk about “removing” items from the stack, as well as the removal of
    entire stack frames, we mean that the stack pointer is adjusted so it points to
    data lower on the stack and the removed content is no longer accessible through
    the `POP` operation. Until that content is overwritten by a `PUSH` operation,
    it is still there. From a programming perspective, that qualifies as removal.
    From a digital forensics perspective, you just have to look a little harder to
    find the contents. From a variable initialization standpoint, it means that any
    uninitialized local variables within a stack frame may contain stale values that
    remain in memory from the last use of a particular range of stack bytes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论“移除”栈中的项目以及整个栈帧的移除时，我们指的是调整栈指针，使其指向栈中更低的位置，并且已移除的内容不再通过`POP`操作访问。直到这些内容被`PUSH`操作覆盖，它们仍然存在。从编程的角度来看，这算作移除。从数字取证的角度来看，你需要稍微费点劲才能找到这些内容。从变量初始化的角度来看，这意味着栈帧中的任何未初始化的局部变量可能包含来自上次使用特定栈字节范围的过期值。
- en: '#### ***Calling Conventions***'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***调用约定***'
- en: 'When passing arguments from caller to callee, the calling function must store
    parameters exactly as the function being called expects to find them; otherwise,
    serious problems can arise. A *calling convention* dictates exactly where a caller
    should place any parameters that a function requires: in specific registers, on
    the program stack, or in both registers and on the stack. When parameters are
    passed on the program stack, the calling convention also determines who is responsible
    for removing them from the stack after the called function has completed: the
    caller or the callee.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当从调用者传递参数到被调用者时，调用函数必须按照被调用函数预期的方式存储参数；否则，可能会出现严重问题。*调用约定*严格规定了调用者应该将任何函数所需的参数放置的位置：在特定的寄存器中、在程序栈上，或同时在寄存器和栈中。当参数通过程序栈传递时，调用约定还决定了在被调用函数完成后，谁负责从栈中移除这些参数：调用者还是被调用者。
- en: Regardless of what architecture you are reversing for, understanding the code
    surrounding a function call will be difficult if you don’t understand the calling
    conventions in use. In the sections that follow, we review some of the common
    calling conventions encountered in compiled C and C++ code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是在逆向哪种架构的程序，如果不理解所使用的调用约定，理解函数调用周围的代码将会非常困难。在接下来的章节中，我们将回顾一些在编译后的C和C++代码中常见的调用约定。
- en: '**Stack and Register Arguments**'
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**栈和寄存器参数**'
- en: Function arguments may be passed in processor registers, on the program stack,
    or in a combination of both. When arguments are placed on the stack, the caller
    performs a memory write (often a `PUSH`) to place the argument onto the stack,
    and the called function must then perform a memory read to access the argument.
    To speed up the function call process, some calling conventions pass arguments
    in processor registers. When an argument is passed in a register, there is no
    need to perform the memory write and read operations, as the argument is immediately
    available to the called function in a designated register. The one shortcoming
    with register-based calling conventions is that processors have a finite number
    of registers while function argument lists can be arbitrarily long, so the conventions
    must properly handle functions that require more arguments than available registers.
    Excess arguments that “spill” out of available registers are generally placed
    on the stack.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数可以通过处理器寄存器、程序栈或两者的组合传递。当参数被放置到栈上时，调用者执行内存写操作（通常是`PUSH`）将参数放到栈上，而被调用函数必须执行内存读取操作才能访问该参数。为了加快函数调用过程，一些调用约定通过处理器寄存器传递参数。当参数通过寄存器传递时，无需执行内存的写入和读取操作，因为参数可以直接通过指定的寄存器提供给被调用函数。寄存器传递调用约定的一个缺点是处理器的寄存器数量有限，而函数参数列表可以非常长，因此这些约定必须正确处理需要更多参数而寄存器不足的情况。多余的参数通常会“溢出”到栈上。
- en: '**The C Calling Convention**'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**C调用约定**'
- en: The *C calling convention* is the default calling convention used by most C
    compilers when generating function calls. The keyword `_cdecl` may be used in
    a function’s prototype to force the use of this calling convention in C/C++ programs.
    The `cdecl` calling convention specifies that the caller place any stack-allocated
    parameters to a function on the stack in right-to-left order and that the caller
    (as opposed to the callee) remove the parameters from the stack after the called
    function completes. For 32-bit x86 binaries, `cdecl` passes all arguments on the
    program stack. For 64-bit x86 binaries, `cdecl` varies by operating system; on
    Linux, up to six arguments are placed in registers `RDI`, `RSI`, `RDX`, `RCX`,
    `R8`, and `R9`, in that order, and any additional arguments spill onto the stack.
    For ARM binaries, `cdecl` passes the first four arguments in registers `R0` to
    `R3`, with arguments five and later spilling onto the stack.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*C调用约定*是大多数C编译器在生成函数调用时使用的默认调用约定。在C/C++程序中，可以使用关键字`_cdecl`强制使用此调用约定。`cdecl`调用约定规定调用者将任何栈分配的函数参数按从右到左的顺序放置到栈上，并且调用者（而不是被调用者）在被调用函数完成后从栈中移除参数。对于32位x86二进制文件，`cdecl`将所有参数放在程序栈上。对于64位x86二进制文件，`cdecl`根据操作系统有所不同；在Linux上，最多六个参数被放置在寄存器`RDI`、`RSI`、`RDX`、`RCX`、`R8`和`R9`中，顺序如下，任何额外的参数将溢出到栈上。对于ARM二进制文件，`cdecl`将前四个参数放在寄存器`R0`到`R3`中，第五个及以后的参数溢出到栈上。'
- en: When stack-allocated arguments are placed on the stack in right-to-left order,
    the leftmost argument will always be on the top of the stack when the function
    is called. This makes the first argument easy to locate regardless of the number
    of parameters the function expects, and it makes the `cdecl` calling convention
    ideally suited for use with functions that can take a variable number of arguments
    (such as `printf`).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当栈分配的参数按从右到左的顺序放置到栈上时，最左边的参数在函数调用时将始终位于栈顶。这使得第一个参数在不考虑函数期望的参数数量的情况下也能轻松找到，同时这也使得`cdecl`调用约定非常适合用于可以接受可变数量参数的函数（如`printf`）。
- en: Requiring the calling function to remove parameters from the stack means that
    you will often see instructions that make an adjustment to the program stack pointer
    immediately following the return from a called function. In the case of functions
    that can accept a variable number of arguments, the caller knows exactly how many
    arguments it passed to the function and can easily make the correct adjustment,
    whereas the called function does not know ahead of time how many parameters it
    will receive.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要求调用函数从栈中移除参数意味着你通常会看到在从被调用函数返回后，紧接着有指令调整程序栈指针。在可以接受可变数量参数的函数中，调用者确切知道它传递了多少参数，因此可以轻松地做出正确的调整，而被调用函数则无法事先知道它将接收到多少个参数。
- en: 'In the following examples, we consider calls to functions in a 32-bit, x86
    binary, each using a different calling convention. The first function has the
    following prototype:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们考虑对32位x86二进制文件中的函数的调用，每个函数使用不同的调用约定。第一个函数有如下原型：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'By default, this function will use the `cdecl` calling convention, expecting
    the four parameters to be pushed in right-to-left order and requiring the caller
    to clean the parameters off the stack. Given the following function call in C:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此函数将使用`cdecl`调用约定，期望四个参数按从右到左的顺序推送，并要求调用者在每次调用后清理堆栈上的参数。给定以下C语言中的函数调用：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'a compiler might generate the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器可能会生成如下代码：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The four `PUSH` operations ➊ change the program stack pointer `(ESP)` by 16
    bytes (`4 * sizeof(int)` on a 32-bit architecture), which is undone immediately
    following the return from `demo_cdecl` ➋. The following technique, which has been
    used in some versions of the GNU compilers (`gcc` and `g++`), also adheres to
    the `cdecl` calling convention while eliminating the need for the caller to explicitly
    clean parameters off the stack following each call to `demo_cdecl`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 四个`PUSH`操作➊会将程序堆栈指针`(ESP)`改变16个字节（在32位架构上为`4 * sizeof(int)`），在从`demo_cdecl`返回后会立即撤销这一操作➋。以下技术在某些版本的GNU编译器（`gcc`和`g++`）中使用，同时遵循`cdecl`调用约定，并消除了调用者在每次调用`demo_cdecl`后显式清理堆栈参数的需求：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, when the parameters for `demo_cdecl` are placed on the stack,
    there is no change to the program stack pointer. Note that either method results
    in the stack pointer pointing to the leftmost stack argument when the function
    is called.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当`demo_cdecl`的参数被放置到堆栈上时，程序堆栈指针没有发生变化。请注意，无论使用哪种方法，当函数被调用时，堆栈指针都会指向最左侧的堆栈参数。
- en: '##### **The Standard Calling Convention**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '##### **标准调用约定**'
- en: 'In 32-bit Windows DLLs, Microsoft makes heavy use of a calling convention it
    has named the *standard calling convention*. In source code, this may be mandated
    by the use of the `_stdcall` modifier in a function declaration, as shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在32位Windows DLL中，微软大量使用了一种它命名为*标准调用约定*的调用约定。在源代码中，这可以通过在函数声明中使用`_stdcall`修饰符来强制，如下所示：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To avoid any confusion surrounding the word *standard*, we refer to this calling
    convention as the `stdcall` calling convention for the remainder of the book.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免“标准”一词的混淆，我们在本书的其余部分将这种调用约定称为`stdcall`调用约定。
- en: The `stdcall` calling convention also requires that any stack-allocated function
    parameters be placed on the program stack in right-to-left order, but the called
    function is responsible for clearing any stack-allocated arguments from the stack
    when the function has finished. This is possible only for functions that accept
    a fixed number of parameters; variable argument functions such as `printf` cannot
    use the `stdcall` calling convention.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdcall`调用约定还要求任何堆栈分配的函数参数按照从右到左的顺序放置在程序堆栈上，但被调用的函数负责在函数执行完毕后清除堆栈上的参数。这只有在函数接受固定数量的参数时才可行；像`printf`这样的可变参数函数不能使用`stdcall`调用约定。'
- en: 'The `demo_stdcall` function expects three integer parameters, occupying a total
    of 12 bytes on the stack (`3 * sizeof(int)` on a 32-bit architecture). An x86
    compiler can use a special form of the `RET` instruction to simultaneously pop
    the return address from the top of the stack and add to the stack pointer to clear
    the stack-allocated function arguments. In the case of `demo_stdcall`, we might
    see the following instruction used to return to the caller:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`demo_stdcall`函数期望三个整数参数，总共占用12个字节的堆栈空间（在32位架构上为`3 * sizeof(int)`）。x86编译器可以使用一种特殊形式的`RET`指令，同时从堆栈顶部弹出返回地址，并通过堆栈指针的调整来清除堆栈分配的函数参数。以`demo_stdcall`为例，我们可能会看到以下指令用于返回给调用者：'
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using `stdcall` eliminates the need to clean parameters off the stack following
    every function call, which results in slightly smaller, slightly faster programs.
    By convention, Microsoft uses the `stdcall` convention for all fixed-argument
    functions exported from 32-bit shared library (DLL) files. This is an important
    point to remember if you are attempting to generate function prototypes or binary-compatible
    replacements for any shared library components.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`stdcall`可以消除每次函数调用后清理堆栈参数的需求，这会导致程序稍微更小、运行稍微更快。根据约定，微软对于所有从32位共享库（DLL）文件导出的固定参数函数使用`stdcall`约定。如果你打算为任何共享库组件生成函数原型或二进制兼容替代品，这一点非常重要。
- en: '**The fastcall Convention for x86**'
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**x86的fastcall约定**'
- en: 'The Microsoft C/C++ and GNU `gcc`/`g++` (version 3.4 and later) compilers recognize
    the `fastcall` convention, a variation on the `stdcall` convention where the first
    two parameters are placed in the `ECX` and `EDX` registers, respectively. Any
    remaining parameters are placed on the stack in right-to-left order, and called
    functions are responsible for removing parameters from the stack when they return
    to their caller. The following declaration demonstrates the use of the `fastcall`
    modifier:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的C/C++和GNU `gcc`/`g++`（版本3.4及以上）编译器识别`fastcall`约定，这是`stdcall`约定的一种变体，其中前两个参数分别放入`ECX`和`EDX`寄存器。其余的参数按从右到左的顺序放入栈中，调用的函数在返回时负责从栈中移除参数。以下声明演示了`fastcall`修饰符的使用：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Given the following function call in C:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下C语言函数调用：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'a compiler might generate the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器可能生成以下代码：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: No stack adjustment is required upon return from `demo_fastcall`, as `demo_fastcall`
    is responsible for clearing parameters `y` and `z` from the stack as it returns
    to the caller. It is important to understand that because two arguments are passed
    in registers, the called function needs to clear only 8 bytes from the stack even
    though there are four arguments to the function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从`demo_fastcall`返回时不需要进行栈调整，因为`demo_fastcall`负责在返回调用者时从栈中清除参数`y`和`z`。需要理解的是，虽然函数有四个参数，但由于两个参数是通过寄存器传递的，调用的函数只需要从栈中清除8个字节。
- en: '**C++ Calling Conventions**'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**C++调用约定**'
- en: Nonstatic member functions in C++ classes must make available a pointer to the
    object used to invoke the function (the `this` pointer).^([3](footnotes.xhtml#ch06fn3))
    The address of the object used to invoke the function must be provided by the
    caller as a parameter, but the C++ language standard does not specify how `this`
    should be passed, so it should come as no surprise that different compilers use
    different techniques.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: C++类中的非静态成员函数必须提供指向用于调用该函数的对象的指针（`this`指针）。^([3](footnotes.xhtml#ch06fn3)) 调用该函数的对象地址必须由调用者作为参数提供，但C++语言标准并未指定`this`应如何传递，因此不同编译器使用不同的技术并不奇怪。
- en: On x86, Microsoft’s C++ compiler utilizes the `thiscall` calling convention,
    which passes `this` in the `ECX/RCX` register and requires the non-static member
    function to clean parameters off the stack, as in `stdcall`. The GNU `g++` compiler
    treats `this` as the implied first parameter to any nonstatic member function
    and behaves in all other respects as if the `cdecl` convention is being used.
    Thus, for `g++`-compiled 32-bit code, `this` is placed on top of the stack prior
    to calling the nonstatic member function, and the caller is responsible for removing
    parameters (there will always be at least one) from the stack after the function
    returns. Additional characteristics of compiled C++ programs are discussed in
    [Chapters 8](ch08.xhtml#ch08) and [20](ch20.xhtml#ch20).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86架构上，微软的C++编译器使用`thiscall`调用约定，将`this`放入`ECX/RCX`寄存器，并要求非静态成员函数像`stdcall`一样清除栈上的参数。GNU的`g++`编译器将`this`视为任何非静态成员函数的隐含第一个参数，并在其他方面表现得像使用`cdecl`约定一样。因此，对于`g++`编译的32位代码，`this`在调用非静态成员函数之前会被放置在栈顶，调用者负责在函数返回后从栈中移除参数（至少会有一个）。C++程序的其他特点将在[第8章](ch08.xhtml#ch08)和[第20章](ch20.xhtml#ch20)中讨论。
- en: '**Other Calling Conventions**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**其他调用约定**'
- en: 'Complete coverage of every calling convention would require a book in its own
    right. Calling conventions are often operating system, language, compiler, and/or
    processor specific, and some research on your part may be required if you encounter
    code generated by less-common compilers. A few additional situations deserve special
    mention, however: optimized code, custom assembly language code, and system calls.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完全覆盖每种调用约定将需要一本书。调用约定通常是操作系统、语言、编译器和/或处理器特定的，如果你遇到由不常见的编译器生成的代码，可能需要进行一些研究。然而，有几种额外的情况值得特别提及：优化代码、自定义汇编语言代码和系统调用。
- en: When functions are exported for use by other programmers (such as library functions),
    it is important that they adhere to well-known calling conventions so that programmers
    can easily interface to those functions. On the other hand, if a function is intended
    for internal program use only, then the calling convention used by that function
    need be known only within the program. In such cases, optimizing compilers may
    choose to use alternate calling conventions to generate faster code. For example,
    the use of the `/GL` option with Microsoft C/C++ instructs it to perform “whole
    program optimization,” which may result in optimized use of registers across function
    boundaries, and the use of the `regparm` keyword with GNU `gcc`/`g++` allows the
    programmer to dictate that up to three arguments be passed to registers.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被导出供其他程序员使用（例如库函数）时，重要的是它们需要遵循公认的调用约定，以便程序员能够轻松地与这些函数进行接口。另一方面，如果一个函数仅供程序内部使用，那么该函数使用的调用约定只需要在程序内部了解。在这种情况下，优化编译器可能会选择使用替代的调用约定来生成更快的代码。例如，使用
    Microsoft C/C++ 的 `/GL` 选项会指示它执行“整体程序优化”，这可能会导致在函数边界间优化寄存器的使用，而使用 GNU `gcc`/`g++`
    的 `regparm` 关键字允许程序员指定最多三个参数通过寄存器传递。
- en: When programmers go to the trouble of writing in assembly language, they gain
    complete control over how parameters will be passed to any functions that they
    create. Unless they wish to make their functions available to other programmers,
    assembly language programmers are free to pass parameters in any way they see
    fit. As a result, take extra care when analyzing custom assembly code, like obfuscation
    routines and shellcode.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员费心编写汇编语言时，他们将完全控制如何将参数传递给他们创建的任何函数。除非他们希望将其函数提供给其他程序员，否则汇编语言程序员可以自由地以任何他们认为合适的方式传递参数。因此，在分析自定义汇编代码（如混淆例程和shellcode）时需要特别小心。
- en: A *system call* is a special type of function call used to request an operating
    system service. System calls usually affect a state transition from user mode
    to kernel mode in order for the operating system kernel to service the user’s
    request. The manner in which system calls are initiated varies across operating
    systems and processors. For example, 32-bit Linux x86 system calls may be initiated
    using the `INT 0x80` instruction or the `sysenter` instruction, while other x86
    operating systems may use only the `sysenter` instruction or alternate interrupt
    numbers, and 64-bit x86 code uses the `syscall` instruction. On many x86 systems
    (Linux being an exception), parameters for system calls are placed on the runtime
    stack, and a system call number is placed in the `EAX` register immediately prior
    to initiating the system call. Linux system calls accept their parameters in specific
    registers and occasionally in memory when there are more parameters than available
    registers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统调用*是一种特殊类型的函数调用，用于请求操作系统服务。系统调用通常会引发从用户模式到内核模式的状态转换，以便操作系统内核处理用户的请求。系统调用的启动方式在不同的操作系统和处理器之间有所不同。例如，32位的Linux
    x86系统调用可能使用 `INT 0x80` 指令或 `sysenter` 指令来启动，而其他x86操作系统可能只使用 `sysenter` 指令或替代的中断号，64位x86代码则使用
    `syscall` 指令。在许多x86系统上（Linux为例外），系统调用的参数被放置在运行时栈上，且在启动系统调用之前，系统调用号被放入 `EAX` 寄存器。Linux系统调用在特定的寄存器中接受参数，当可用寄存器不足时，参数有时会放置在内存中。'
- en: '***Additional Stack Frame Considerations***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***附加栈帧考虑***'
- en: On any processor, registers are a finite resource that need to be shared, cooperativley,
    among all functions within a program. When a function (`func1`) is executing,
    its world view is that it has complete control over all processor registers. When
    `func1` calls another function (`func2`), `func2` may wish to adopt this same
    view and make use of all available processor registers according to its own needs,
    but if `func2` makes arbitrary changes to the registers, it may destroy values
    that `func1` depends on.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何处理器上，寄存器是有限的资源，需要在程序中的所有函数之间进行共享与合作。当一个函数（`func1`）正在执行时，它的视角是它完全控制所有处理器寄存器。当`func1`调用另一个函数（`func2`）时，`func2`可能希望采用相同的视角，并根据自己的需求使用所有可用的处理器寄存器，但如果`func2`随意更改寄存器，它可能会破坏`func1`所依赖的值。
- en: 'To address this problem, all compilers follow well-defined rules for register
    allocation and use. These rules are generally referred to as a platform’s *application
    binary interface (ABI)*. An ABI divides registers into two categories: caller-saved
    and callee-saved. When one function calls another, the caller needs to save only
    registers in the caller-saved category to prevent values from being lost. Any
    registers in the callee-saved category must be saved by the called function (the
    callee) before that function is allowed to use any of those registers for its
    own purposes. This typically takes place as part of the function’s prologue sequence,
    with the caller’s saved values being restored within the function’s epilogue immediately
    prior to returning. Caller-saved registers are referred to as *clobber* registers
    because a called function is free to modify their contents without first saving
    any of them. Conversely, callee-saved registers are referred to as *no-clobber*
    registers.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，所有编译器都遵循明确定义的寄存器分配和使用规则。这些规则通常被称为平台的*应用程序二进制接口（ABI）*。ABI将寄存器分为两类：调用者保存寄存器和被调用者保存寄存器。当一个函数调用另一个函数时，调用者只需要保存调用者保存寄存器中的寄存器，以防止值丢失。任何被调用者保存寄存器中的寄存器必须由被调用函数（即被调用者）在使用这些寄存器之前保存。这通常发生在函数的序言序列中，而调用者保存的值会在函数的尾声部分，在返回之前恢复。调用者保存寄存器被称为*可覆盖*寄存器，因为被调用函数可以自由修改它们的内容，而无需先保存它们。相反，被调用者保存寄存器被称为*不可覆盖*寄存器。
- en: The System V ABI for Intel 32-bit processors states that the caller-saved registers
    include `EAX`, `ECX`, and `EDX`, while the callee-saved registers include `EBX`,
    `EDI`, `ESI`, `EBP`, and `ESP`.^([4](footnotes.xhtml#ch06fn4)) In compiled code,
    you may notice that compilers often prefer to use caller-saved registers within
    a function because they are relieved from the responsibility of saving and restoring
    their contents on entry and exit from the function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 针对Intel 32位处理器的System V ABI规定，调用者保存寄存器包括`EAX`、`ECX`和`EDX`，而被调用者保存寄存器包括`EBX`、`EDI`、`ESI`、`EBP`和`ESP`。^([4](footnotes.xhtml#ch06fn4))
    在编译代码中，你可能会注意到编译器通常倾向于在函数内部使用调用者保存寄存器，因为这样它们不需要在函数入口和退出时保存和恢复其内容。
- en: '***Local Variable Layout***'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***局部变量布局***'
- en: 'Unlike the calling conventions that dictate how parameters are passed into
    a function, no conventions dictate the memory layout of a function’s local variables.
    When compiling a function, a compiler must compute the amount of space required
    by a function’s local variables, along with space required to save any no-clobber
    registers, and determine whether those variables can be allocated in processor
    registers or whether they must be allocated on the program stack. The exact manner
    in which these allocations are made is irrelevant to both the caller of a function
    and to any functions that may, in turn, be called, and it is not generally possible
    to determine a function’s local variable layout based solely on examination of
    the function’s source code. One thing is certain with regard to stack frames:
    the compiler must dedicate at least one register to remember the location of a
    function’s newly allocated stack frame. The most obvious choice for this register
    is the stack pointer, which, by definition, points at the stack and thus the current
    function’s stack frame.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与决定如何将参数传递给函数的调用约定不同，没有约定决定函数局部变量的内存布局。在编译一个函数时，编译器必须计算该函数局部变量所需的空间大小，以及保存任何不应覆盖寄存器所需的空间，并确定这些变量是否可以分配到处理器寄存器中，或者是否必须分配到程序栈上。具体如何进行这些分配，对函数的调用者和任何可能被调用的函数都没有影响，并且通常无法仅通过检查函数的源代码来确定函数的局部变量布局。关于栈帧，有一点是肯定的：编译器必须至少分配一个寄存器来记住函数新分配的栈帧的位置。最明显的选择是栈指针寄存器，它的定义就是指向栈，因此也指向当前函数的栈帧。
- en: '***Stack Frame Examples***'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***栈帧示例***'
- en: When you perform any complex task, such as reverse engineering a binary, you
    should always strive to make efficient use of your time. When it comes to understanding
    the behavior of a disassembled function, the less time you spend examining common
    code sequences, the more time you will have to spend on difficult sequences. Function
    prologues and epilogues are excellent examples of common code sequences, and it
    is important that you’re able to recognize them, understand them, and rapidly
    move on to more interesting code that requires more thought.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行任何复杂的任务时，比如逆向工程二进制文件，你应始终尽量高效地利用时间。在理解反汇编函数的行为时，花费在常见代码序列上的时间越少，你就能花更多时间去处理困难的序列。函数的序言和尾声是常见代码序列的绝佳例子，了解它们、识别它们，并迅速跳到需要更多思考的有趣代码，是非常重要的。
- en: Ghidra summarizes its understanding of function prologues in the local variable
    list at the head of each function listing, and while it may make the code more
    readable, it does nothing to reduce the amount of disassembled code that you need
    to read. In the following examples, we discuss two common types of stack frames
    and review the code necessary to create them so that when you encounter similar
    code in the wild, you can quickly move through it to get to the meat of a function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra在每个函数列表的开头通过局部变量列表总结了它对函数序言的理解，虽然它使代码更具可读性，但并不会减少你需要阅读的反汇编代码量。在以下示例中，我们将讨论两种常见的栈帧类型，并回顾创建它们所需的代码，这样当你遇到类似的代码时，就可以迅速跳过它，进入函数的核心部分。
- en: 'Consider the following function compiled on a 32-bit x86-based computer:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下在32位x86计算机上编译的函数：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The local variables for `demo_stackframe` require 76 bytes (three 4-byte integers
    and a 64-byte buffer). This function could use either `stdcall` or `cdecl`, and
    the stack frame would look the same.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`demo_stackframe`的局部变量需要76个字节（三个4字节整数和一个64字节缓冲区）。此函数可以使用`stdcall`或`cdecl`，栈帧将保持相同。'
- en: '**Example 1: Local Variable Access via the Stack Pointer**'
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例1：通过栈指针访问局部变量**'
- en: '[Figure 6-5](ch06.xhtml#fig6_5) shows one possible stack frame for an invocation
    of `demo_stackframe`. In this example, the compiler has elected to utilize the
    stack pointer anytime it references a variable contained in the stack frame, leaving
    all other registers available for other purposes. If any instruction causes the
    value of the stack pointer to change, the compiler must ensure that it accounts
    for that change in all subsequent local variable accesses.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](ch06.xhtml#fig6_5)显示了调用`demo_stackframe`时可能的栈帧。在这个示例中，编译器选择在引用栈帧中的变量时使用栈指针，保留所有其他寄存器以供其他用途。如果任何指令导致栈指针的值发生变化，编译器必须确保在所有后续的局部变量访问中考虑到这一变化。'
- en: '![image](Images/fig6-5.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-5.jpg)'
- en: '*Figure 6-5: Sample stack frame for a function compiled on a 32-bit x86 computer*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：在32位x86计算机上编译的函数示例栈帧*'
- en: 'The space for this frame is set up on entry to `demo_stackframe` with the one-line
    prologue:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 该栈帧的空间在进入`demo_stackframe`时通过一行代码的序言进行设置：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The Offset column in [Figure 6-5](ch06.xhtml#fig6_5) indicates the x86 addressing
    mode (base + displacement in this case) required to reference each of the local
    variables and parameters in the stack frame. In this case, `ESP` is being used
    as the base register, and each displacement is the relative offset from `ESP`
    to the start of the variable within the stack frame. However, the displacements
    shown in [Figure 6-5](ch06.xhtml#fig6_5) are correct only as long as the value
    held in `ESP` doesn’t change. Unfortunately, the stack pointer changes frequently,
    and the compiler must constantly adapt to ensure that proper offsets are used
    when referencing any variables within the stack frame. Consider the call made
    to `helper` in the function `demo_stackframe`, the code for which is shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](ch06.xhtml#fig6_5)中的偏移列表示引用栈帧中每个局部变量和参数所需的x86寻址模式（在此情况下为基址+位移）。在此情况下，`ESP`被用作基址寄存器，每个位移是从`ESP`到变量在栈帧中的起始位置的相对偏移量。然而，[图6-5](ch06.xhtml#fig6_5)中显示的位移仅在`ESP`中的值没有改变时是正确的。不幸的是，栈指针经常变化，编译器必须不断适应，以确保在引用栈帧中的任何变量时使用正确的偏移量。考虑在函数`demo_stackframe`中对`helper`的调用，相关代码如下所示：'
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first `PUSH` ➊ correctly pushes local variable `y` per the offset in [Figure
    6-5](ch06.xhtml#fig6_5). At first glance, it might appear that the second `PUSH`
    ➋ incorrectly references local variable `y` a second time. However, because all
    variables in the stack frame are referenced relative to `ESP` and the first `PUSH`
    ➊ modifies `ESP`, all of the offsets in [Figure 6-5](ch06.xhtml#fig6_5) must be
    temporarily adjusted. Therefore, following the first `PUSH` ➊, the new offset
    for local variable `z` becomes `[ESP+4]`. When examining functions that reference
    stack frame variables using the stack pointer, you must be careful to note any
    changes to the stack pointer and adjust all future variable offsets accordingly.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`PUSH` ➊正确地根据[图6-5](ch06.xhtml#fig6_5)中的偏移量压入了局部变量`y`。乍一看，第二个`PUSH` ➋似乎错误地第二次引用了局部变量`y`。然而，由于堆栈帧中的所有变量都是相对于`ESP`进行引用的，并且第一个`PUSH`
    ➊修改了`ESP`，因此[图6-5](ch06.xhtml#fig6_5)中的所有偏移量必须暂时调整。因此，在第一次`PUSH` ➊之后，局部变量`z`的新偏移量变为`[ESP+4]`。在检查使用堆栈指针引用堆栈帧变量的函数时，必须小心注意堆栈指针的任何变化，并相应地调整所有未来的变量偏移量。
- en: 'Once `demo_stackframe` has completed, it needs to return to the caller. Ultimately,
    a `RET` instruction will pop the desired return address off the top of the stack
    into the instruction pointer register (`EIP` in this case). Before the return
    address can be popped, the local variables need to be removed from the top of
    the stack so that the stack pointer correctly points to the saved return address
    when the `RET` instruction is executed. For this particular function (assuming
    the `cdecl` calling convention is in use), the epilogue becomes the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`demo_stackframe`完成，它需要返回给调用者。最终，`RET`指令将把所需的返回地址从堆栈顶部弹出到指令指针寄存器（在这种情况下是`EIP`）。在返回地址被弹出之前，局部变量需要从堆栈顶部移除，以便堆栈指针在执行`RET`指令时正确指向保存的返回地址。对于这个特定函数（假设使用的是`cdecl`调用约定），尾声代码如下：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Example 2: Give the Stack Pointer a Break**'
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例 2：让堆栈指针休息一下**'
- en: At the expense of dedicating a second register to locating variables with a
    stack frame, the stack pointer may be allowed to freely change without the need
    to recompute offsets for each variable within the frame. Of course, the compiler
    needs to commit to not changing this second register; other­wise, it will need
    to contend with the same issues raised in the previous example. In this situation,
    the compiler needs to first select a register for this purpose and then it must
    generate code to initialize that register on entry to the function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将第二个寄存器用于在堆栈帧中定位变量，可以允许堆栈指针在不需要重新计算每个变量偏移量的情况下自由变化。当然，编译器需要承诺不更改这个第二个寄存器；否则，它将需要处理前面示例中提到的相同问题。在这种情况下，编译器首先需要为此目的选择一个寄存器，然后它必须生成代码，在进入函数时初始化该寄存器。
- en: Any register selected for this purpose is known as a *frame pointer*. In the
    preceding example, `ESP` was being used as a frame pointer, and we can say that
    it was an `ESP`-based stack frame. The ABI for most architectures suggests which
    register should be used as a frame pointer. The frame pointer is always considered
    a no-clobber register because the calling function may already be using it for
    the same purpose. In x86 programs, the `EBP`/`RBP` (extended base pointer) register
    is typically dedicated for use as a frame pointer. By default, most compilers
    generate code to use a register other than the stack pointer as a frame pointer,
    though options typically exist for specifying that the stack pointer should be
    used instead. (GNU `gcc`/`g++`, for example, offers the `-fomit-frame-pointer`
    compiler option, which generates functions that do not use a second register as
    a frame pointer.)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 任何为此目的选定的寄存器都称为*帧指针*。在前面的示例中，`ESP`被用作帧指针，我们可以说它是基于`ESP`的堆栈帧。大多数架构的ABI建议使用哪个寄存器作为帧指针。帧指针始终被视为不可破坏寄存器，因为调用函数可能已经将其用于相同的目的。在x86程序中，`EBP`/`RBP`（扩展基指针）寄存器通常专用于帧指针。默认情况下，大多数编译器生成的代码使用除堆栈指针外的寄存器作为帧指针，尽管通常有选项指定应使用堆栈指针。（例如，GNU的`gcc`/`g++`提供了`-fomit-frame-pointer`编译器选项，生成不使用第二个寄存器作为帧指针的函数。）
- en: 'To see what the stack frame for `demo_stackframe` will look like using a dedicated
    frame pointer, we need to consider this new prologue code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看使用专用帧指针时`demo_stackframe`的堆栈帧会是什么样子，我们需要考虑这段新的序言代码：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `PUSH` instruction ➊ saves the value of `EBP` currently being used by the
    caller because `EBP` is a no-clobber register. The caller’s value of `EBP` must
    be restored before we return. If any other registers need to be saved on behalf
    of the caller (`ESI` or `EDI`, for example), compilers may save them at the same
    time `EBP` is saved, or they may defer saving them until local variables have
    been allocated. Thus, there is no standard location within a stack frame for the
    storage of saved registers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUSH`指令➊保存当前调用者使用的`EBP`值，因为`EBP`是一个不会被覆盖的寄存器。在返回之前，必须恢复调用者的`EBP`值。如果需要保存其他寄存器（例如`ESI`或`EDI`）以代表调用者，编译器可以在保存`EBP`的同时保存它们，或者将保存它们的操作延迟到局部变量分配之后。因此，堆栈帧中没有标准的位置用于存储保存的寄存器。'
- en: Once `EBP` has been saved, it can be changed to point to the current stack location
    with the `MOV` instruction ➋, which copies the current value of the stack pointer
    (the only register guaranteed to be pointing into the stack at this moment in
    time) into `EBP`. Finally, as in the `ESP`-based stack frame, space for local
    variables is allocated ➌. The resulting stack frame layout is shown in [Figure
    6-6](ch06.xhtml#fig6_6).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`EBP`被保存，它可以通过`MOV`指令➋改变为指向当前堆栈位置，这将当前堆栈指针的值（此时唯一保证指向堆栈的寄存器）复制到`EBP`。最后，与基于`ESP`的堆栈帧一样，为局部变量分配空间➌。最终的堆栈帧布局如[图6-6](ch06.xhtml#fig6_6)所示。
- en: '![image](Images/fig6-6.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-6.jpg)'
- en: '*Figure 6-6: An* EBP*-based stack frame*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：基于EBP的堆栈帧*'
- en: 'With a dedicated frame pointer, all variable offsets can now be computed relative
    to the frame pointer register, as seen in [Figure 6-6](ch06.xhtml#fig6_6). It
    is most often (though not necessarily) the case that positive offsets are used
    to access any stack-allocated function arguments, while negative offsets are used
    to access local variables. With a dedicated frame pointer in use, the stack pointer
    may be freely changed without affecting the offset to any variables within the
    frame. The call to the function `helper` can now be implemented as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用专用的帧指针后，所有变量的偏移量现在都可以相对于帧指针寄存器进行计算，如[图6-6](ch06.xhtml#fig6_6)所见。通常（但不一定）使用正偏移来访问任何栈分配的函数参数，而使用负偏移来访问局部变量。在使用专用帧指针的情况下，堆栈指针可以自由更改，而不会影响帧内任何变量的偏移量。对函数`helper`的调用现在可以按如下方式实现：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The fact that the stack pointer has changed following the first `PUSH` ➍ has
    no effect on the access to local variable `z` in the subsequent `PUSH`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈指针在第一次`PUSH` ➍后发生变化，但这对后续`PUSH`中对局部变量`z`的访问没有影响。
- en: 'In the epilogue of a function that uses a frame pointer, the caller’s frame
    pointer must be restored prior to returning. If the frame pointer is to be restored
    using a `POP` instruction, local variables must be cleared from the stack before
    the old value of the frame pointer can be popped, but this is made easy by the
    fact that the current frame pointer points to the location on the stack that holds
    the saved frame pointer value. In 32-bit x86 programs utilizing `EBP` as a frame
    pointer, the following code represents a typical epilogue:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用帧指针的函数的尾声部分，必须在返回之前恢复调用者的帧指针。如果帧指针需要通过`POP`指令恢复，则必须在弹出旧帧指针值之前先清除栈中的局部变量，但由于当前帧指针指向堆栈中保存的帧指针值位置，因此这一过程变得简单。在使用`EBP`作为帧指针的32位x86程序中，以下代码表示一个典型的尾声：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This operation is so common that the x86 architecture offers the `LEAVE` instruction
    to accomplish the same task:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作如此常见，以至于x86架构提供了`LEAVE`指令来完成相同的任务：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: While the names of registers and instructions used will certainly differ for
    other processor architectures, the basic process of building stack frames will
    remain the same. Regardless of the architecture, you will want to familiarize
    yourself with typical prologue and epilogue sequences so that you can quickly
    move on to analyzing more interesting code within functions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不同处理器架构中使用的寄存器和指令的名称肯定会有所不同，但构建堆栈帧的基本过程将保持不变。无论架构如何，你都应当熟悉典型的序言和尾声序列，以便快速分析函数内更有趣的代码。
- en: '**Ghidra Stack Views**'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Ghidra堆栈视图**'
- en: Stack frames are a runtime concept; a stack frame can’t exist without a stack
    and without a running program. While this is true, it doesn’t mean that you should
    ignore the concept of a stack frame when you are performing static analysis with
    tools such as Ghidra. All of the code required to set up stack frames for each
    function is present within a binary. Through careful analysis of this code, we
    can gain a detailed understanding of the structure of any function’s stack frame,
    even though the function is not running. In fact, some of Ghidra’s most sophisticated
    analysis is performed specifically to determine the layout of stack frames for
    every function that it disassembles.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈框架是一个运行时概念；没有堆栈和正在运行的程序，就没有堆栈框架。虽然这是事实，但这并不意味着在使用 Ghidra 等工具进行静态分析时应该忽视堆栈框架的概念。每个函数设置堆栈框架所需的所有代码都存在于二进制文件中。通过仔细分析这些代码，我们可以详细了解任何函数的堆栈框架结构，即使该函数没有运行。事实上，Ghidra
    的一些最复杂的分析正是为了确定它反汇编的每个函数的堆栈框架布局。
- en: '#### ***Ghidra Stack Frame Analysis***'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***Ghidra 堆栈框架分析***'
- en: During initial analysis, Ghidra goes to great lengths to track the behavior
    of the stack pointer over the course of a function by making note of every `PUSH`
    or `POP` operation along with any arithmetic operations that may change the stack
    pointer, such as adding or subtracting constant values. The goal of this analysis
    is to determine the exact size of the local variable area allocated to a function’s
    stack frame, determine whether a dedicated frame pointer is in use in a given
    function (by recognizing a `PUSH EBP/MOV EBP, ESP` sequence, for example), and
    recognize all memory references to variables within a function’s stack frame.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在初步分析过程中，Ghidra 会非常详细地跟踪堆栈指针在函数执行过程中的行为，记录每一个 `PUSH` 或 `POP` 操作，以及可能更改堆栈指针的任何算术操作，例如加或减常量值。此分析的目标是确定分配给函数堆栈框架的局部变量区域的确切大小，确定是否在给定函数中使用了专用的帧指针（例如通过识别
    `PUSH EBP/MOV EBP, ESP` 序列），并识别函数堆栈框架中所有变量的内存引用。
- en: For example, if Ghidra noted the instruction
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 Ghidra 记录了指令
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: in the body of `demo_stackframe`, it would understand that the first argument
    to the function (`a` in this case) is being loaded into the `EAX` register (refer
    to [Figure 6-6](ch06.xhtml#fig6_6)). Ghidra can distinguish between memory references
    that access function arguments (those that lie below the saved return address)
    and references that access local variables (those that lie above the saved return
    address).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `demo_stackframe` 的代码中，它会理解函数的第一个参数（此例中为 `a`）被加载到 `EAX` 寄存器中（参见[图 6-6](ch06.xhtml#fig6_6)）。Ghidra
    能区分访问函数参数的内存引用（那些位于保存的返回地址以下的）和访问局部变量的引用（那些位于保存的返回地址以上的）。
- en: Ghidra takes the additional step of determining which memory locations within
    a stack frame are directly referenced. For example, while the stack frame in [Figure
    6-6](ch06.xhtml#fig6_6) is 96 bytes in size, there are only seven variables that
    we are likely to see referenced (four locals and three parameters). As a result,
    you can focus your attention on the seven things that Ghidra has identified as
    important and spend less time thinking about all the bytes that Ghidra has left
    unnamed. In the process of identifying and naming individual items within a stack
    frame, Ghidra also recognizes the spatial relationship of variables with respect
    to one another. This can be tremendously helpful in some use cases, such as exploit
    development, when Ghidra makes it easy to determine exactly which variables may
    get overwritten as the result of a buffer overflow. Ghidra’s decompiler (discussed
    in [Chapter 19](ch19.xhtml#ch19)) also relies heavily on stack frame analysis,
    and it uses the results to infer how many arguments a function receives and what
    local variable declarations are necessary in the decompiled code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 采取额外步骤来确定堆栈框架内哪些内存位置被直接引用。例如，虽然[图 6-6](ch06.xhtml#fig6_6)中的堆栈框架大小为 96
    字节，但只有七个变量可能会被引用（四个局部变量和三个参数）。因此，你可以将注意力集中在 Ghidra 确定为重要的七个元素上，而不用过多考虑 Ghidra
    未命名的所有字节。在识别和命名堆栈框架中的各个元素的过程中，Ghidra 还识别了变量之间的空间关系。这在某些使用场景中非常有帮助，例如漏洞开发，当 Ghidra
    可以轻松地确定哪些变量可能会在缓冲区溢出时被覆盖。Ghidra 的反编译器（在[第 19 章](ch19.xhtml#ch19)中讨论）也大量依赖堆栈框架分析，并利用这些结果推断函数接收的参数数量以及反编译代码中所需的局部变量声明。
- en: '***Stack Frames in Listing View***'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***列表视图中的堆栈框架***'
- en: 'Understanding the behavior of a function often comes down to understanding
    the types of data that the function manipulates. When you’re reading a disassembly
    listing, one of the first opportunities you have to understand the data that a
    function manipulates is to view the breakdown of the function’s stack frame. Ghidra
    offers two views into any function’s stack frame: a summary view and a detailed
    view. To understand these two views, we will refer to the following version of
    `demo_stackframe`, which we have compiled using `gcc`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 理解一个函数的行为通常归结于理解该函数操作的数据类型。当你阅读反汇编列表时，理解函数操作的数据的第一步通常是查看函数堆栈帧的分解。Ghidra 提供了两种查看任何函数堆栈帧的方式：摘要视图和详细视图。为了理解这两种视图，我们将参考以下版本的
    `demo_stackframe`，这是我们使用 `gcc` 编译的：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As local variables exist only while the function is running, any local variable
    that is not used in the function in a meaningful way is essentially useless. From
    a high-level view, the following code is a functionally equivalent (you might
    say optimized) version of `demo_stackframe`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本地变量仅在函数运行时存在，因此任何在函数中没有被有意义地使用的本地变量实际上是没有用的。从高层次来看，以下代码是 `demo_stackframe`
    的功能等效版本（你可以说是优化后的版本）：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: (So, while this function acts like it is doing a lot of work, it’s really just
    trying to look busy to impress the boss.)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: （因此，尽管这个函数看起来像是在做很多工作，实际上它只是试图装作忙碌，以给老板留下好印象。）
- en: In the original version of `demo_stackframe`, local variables `x` and `y` are
    initialized from parameters `k` and `j`, respectively. Local variable `z` is initialized
    with the literal value 10, and the first character in the 64-byte local array,
    named `buffer`, is initialized to the character `'A'`. The corresponding Ghidra
    disassembly of this function, using the default auto analysis, is shown in [Figure
    6-7](ch06.xhtml#fig6_7).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始版本的 `demo_stackframe` 中，本地变量 `x` 和 `y` 分别从参数 `k` 和 `j` 初始化。本地变量 `z` 被初始化为字面值
    10，并且 64 字节本地数组 `buffer` 中的第一个字符被初始化为字符 `'A'`。使用默认自动分析的 Ghidra 反汇编显示了该函数的内容，如
    [图 6-7](ch06.xhtml#fig6_7) 所示。
- en: '![image](Images/fig6-7.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-7.jpg)'
- en: '*Figure 6-7: Disassembly of the* demo_stackframe *function*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-7：* demo_stackframe *函数的反汇编*'
- en: There are many points to cover in this listing as we begin to acquaint ourselves
    with Ghidra’s disassembly notation. In this discussion, we focus on two sections
    of the disassembly that provide us with particularly useful information. Let’s
    start by zooming in on the stack summary, as shown in the following listing. (You
    can always refer back to [Figure 6-7](ch06.xhtml#fig6_7) to see this summary stack
    frame in context.) To simplify the discussion, the terms *local variable* and
    *argument* are used to distinguish between the two types of variables. The term
    *variable* is used when discussing both collectively.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始熟悉 Ghidra 的反汇编符号时，有许多要点需要讨论。在本讨论中，我们专注于反汇编中的两个部分，它们为我们提供了特别有用的信息。让我们首先关注堆栈摘要，如下所示的列表中所示。（你可以随时参考
    [图 6-7](ch06.xhtml#fig6_7) 来查看这个摘要堆栈帧的上下文。）为了简化讨论，术语 *本地变量* 和 *参数* 用来区分两种类型的变量。术语
    *变量* 用于讨论这两者时。
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Ghidra provides a summary stack view that lists every variable directly referenced
    within the stack frame, along with important information about each. The meaningful
    names (in the third column) that Ghidra assigns to each variable provide information
    about the variables when you see them throughout the disassembly listing: the
    names of arguments passed to the function begin with a helpful prefix of `param_`,
    and local variable names begin with `local_`. As a result, it is easy to distinguish
    between the two types of variables.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 提供了一个摘要堆栈视图，列出了堆栈帧中直接引用的每个变量，并附带有关每个变量的重要信息。Ghidra 为每个变量分配的有意义的名称（在第三列）在查看反汇编列表时提供有关变量的信息：传递给函数的参数名称以
    `param_` 为前缀，本地变量名称以 `local_` 为前缀。因此，很容易区分这两种类型的变量。
- en: 'The variable name prefixes are combined with information about the position
    or location of a variable. For arguments, like `param_3`, the number in the name
    corresponds to the argument’s position in the function’s parameter list. For local
    variables, like `local_10`, the number is a hexadecimal offset representing the
    variable’s location within the stack frame. The location can also be found in
    the center column of the listing, to the left of the names. This column has two
    components separated by a colon: Ghidra’s estimate of the size of the variable
    in bytes, and the location of the variable within the stack frame, represented
    as the offset of that variable from the initial stack pointer value on entry into
    the function.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名的前缀与关于变量位置或位置的信息结合在一起。对于参数，例如`param_3`，名称中的数字对应函数参数列表中该参数的位置。对于局部变量，例如`local_10`，数字是一个十六进制偏移量，表示变量在堆栈帧中的位置。位置也可以在列表的中间列中找到，位于名称的左侧。该列有两个组件，通过冒号分隔：Ghidra对变量大小的字节估计和变量在堆栈帧中的位置，表示为该变量相对于函数入口时初始堆栈指针值的偏移量。
- en: A tabular representation of this stack frame is shown in [Figure 6-8](ch06.xhtml#fig6_8).
    As discussed, parameters lie below the saved return address and thus have a positive
    offset from the return address. Local variables lie above the saved return address
    and thus have a negative offset. The order of the local variables in the stack
    do not match the order in which they were declared in the source code shown earlier
    in this chapter, because the compiler is free to arrange local variables on the
    stack based on a variety of internal factors, such as byte alignment and placement
    of arrays relative to other local variables.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 该堆栈帧的表格表示如[图 6-8](ch06.xhtml#fig6_8)所示。如前所述，参数位于保存的返回地址下方，因此它们相对于返回地址有一个正偏移。局部变量位于保存的返回地址上方，因此它们有一个负偏移。堆栈中局部变量的顺序与它们在本章前面展示的源代码中的声明顺序不匹配，因为编译器可以根据多种内部因素自由地安排局部变量在堆栈中的位置，例如字节对齐和数组相对于其他局部变量的放置。
- en: '![image](Images/fig6-8.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-8.jpg)'
- en: '*Figure 6-8: Sample stack frame image*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-8：示例堆栈帧图像*'
- en: '***Decompiler-Assisted Stack Frame Analysis***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***反编译器辅助堆栈帧分析***'
- en: Remember the functional equivalent of the code that we identified?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们识别的代码功能等价物吗？
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The code that the decompiler generated for this function is shown in [Figure
    6-9](ch06.xhtml#fig6_9). Ghidra’s decompiler-generated code is very similar to
    our optimized code, as the decompiler includes only the executable equivalent
    of the original function. (The exception is the inclusion of `param_1`.)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 反编译器为该函数生成的代码如[图 6-9](ch06.xhtml#fig6_9)所示。Ghidra的反编译器生成的代码与我们的优化代码非常相似，因为反编译器只包含了原始函数的可执行等价物。（例外是`param_1`的包含。）
- en: '![image](Images/fig6-9.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-9.jpg)'
- en: '*Figure 6-9: Decompiler window for* demo_stackframe *(with Decompiler Parameter
    ID analyzer)*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-9：反编译器窗口（使用反编译器参数ID分析器）*'
- en: 'You may have noticed that the function `demo_stackframe` accepted three integer
    parameters, but only two of them (`param_1` and `param_2`) are accounted for in
    the decompiler listing. Which one is missing and why? It turns out that the Ghidra
    disassembler and the Ghidra decompiler approach the names a little differently.
    While both name all of the parameters up to the last one referenced, the decompiler
    names only the parameters up to the last one that is used in a meaningful way.
    One of the analyzers that Ghidra can run for you is called the *Decompiler Parameter
    ID* analyzer. In most cases, this analyzer is not enabled by default (it is enabled
    for only Windows PE files smaller than 2MB). When the Decompiler Parameter ID
    analyzer is enabled, Ghidra uses decompiler-derived parameter information to name
    a function’s parameters in the disassembly listing. The following listing shows
    the variables in the disassembly listing of `demo_stackframe` when the Decompiler
    Parameter ID analyzer is enabled:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，函数`demo_stackframe`接受了三个整数参数，但在反编译器的列表中只有其中两个（`param_1`和`param_2`）被列出。缺少的那个是哪一个，为什么？原来，Ghidra反汇编器和Ghidra反编译器对参数命名的方式略有不同。虽然两者都命名了直到最后一个引用的所有参数，但反编译器只命名了直到最后一个有实际用途的参数。Ghidra可以为你运行的一种分析器叫做*反编译器参数ID分析器*。在大多数情况下，这个分析器默认是禁用的（它只对小于2MB的Windows
    PE文件启用）。当启用反编译器参数ID分析器时，Ghidra使用反编译器推导的参数信息来命名反汇编列表中的函数参数。以下列表展示了启用反编译器参数ID分析器时，`demo_stackframe`反汇编列表中的变量：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that `param_3` no longer appears in the list of function arguments, as
    the decompiler has determined that it is not used in any meaningful way within
    the function. This particular stack frame is discussed further in [Chapter 8](ch08.xhtml#ch08).
    If you ever want Ghidra to perform Decompiler Parameter ID analysis after opening
    a binary with that analyzer disabled, you can always choose Analysis ▸ One Shot
    ▸ Decompiler Parameter ID to run the analyzer after the fact.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`param_3` 不再出现在函数参数列表中，因为反编译器已确定它在函数内部没有以任何有意义的方式使用。这个特定的堆栈帧将在[第8章](ch08.xhtml#ch08)中进一步讨论。如果你希望在打开二进制文件后，Ghidra
    在禁用该分析器的情况下执行反编译器参数ID分析，你可以选择“分析 ▸ 一次性 ▸ 反编译器参数ID”来在事后运行该分析器。
- en: '***Local Variables as Operands***'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***作为操作数的局部变量***'
- en: 'Let’s shift our focus to the actual disassembly portion of the following listing:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将注意力转向以下列表中的实际反汇编部分：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The function uses a common function prologue ➊ for an `EBP`-based stack frame.
    The compiler allocates 88 bytes (`0x58` equals 88) of local variable space ➋ in
    the stack frame. This is slightly more than the estimated 76 bytes and demonstrates
    that compilers occasionally pad the local variable space with extra bytes in order
    to maintain a particular memory alignment within the stack frame.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用一个常见的函数序言➊，用于基于`EBP`的堆栈帧。编译器在堆栈帧中分配了88字节（`0x58`等于88）的局部变量空间➋。这略高于预估的76字节，表明编译器有时会通过填充额外的字节来保持堆栈帧内的特定内存对齐。
- en: An important difference between Ghidra’s disassembly listing and the stack frame
    analysis that we performed earlier is that in the disassembly listing you don’t
    see memory references similar to `[EBP-12]` (which you might see with `objdump`,
    for example). Instead, Ghidra has replaced all constant offsets with symbolic
    names corresponding to the symbols in the stack view and their relative offsets
    from the function’s initial stack pointer location. This is in keeping with Ghidra’s
    goal of generating a higher-level disassembly. It is simply easier to deal with
    symbolic names than numeric constants. It also gives us a name that can be modified
    to match our understanding of the variable’s purpose once known. Ghidra does display
    the raw form of the current instruction, without any labels, in the extreme, lower-right
    corner of the CodeBrowser window for reference.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra的反汇编列表和我们之前执行的堆栈帧分析之间的一个重要区别是，在反汇编列表中，你看不到类似`[EBP-12]`的内存引用（例如你可能会在`objdump`中看到）。相反，Ghidra已将所有常量偏移量替换为符号名称，这些符号名称对应堆栈视图中的符号及其相对于函数初始堆栈指针位置的偏移量。这与Ghidra生成更高级反汇编的目标一致。处理符号名称比处理数字常量更为简便。它还给我们提供了一个可以修改的名称，一旦我们了解变量的用途后，可以使其与我们的理解相匹配。Ghidra会在CodeBrowser窗口的极低右角显示当前指令的原始形式，没有任何标签，供参考。
- en: 'In this example, since we have source code available for comparison, we can
    map the Ghidra-generated variable names back to the names used in the original
    source by using a variety of clues available in the disassembly:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，由于我们有源代码可以进行对比，我们可以通过使用反汇编中可用的各种线索，将Ghidra生成的变量名映射回原始源代码中使用的名称：
- en: First, `demo_stackframe` accepts three parameters, `i`, `j`, and `k`, which
    correspond to variables `param_1`, `param _2`, and `param _3`, respectively.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`demo_stackframe`接受三个参数，`i`、`j`和`k`，它们分别对应变量`param_1`、`param_2`和`param_3`。
- en: Local variable `x` (`local_10`) is initialized from parameter `k` (`param_3`)
    ➌.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 局部变量`x`（`local_10`）由参数`k`（`param_3`）初始化➌。
- en: Similarly, local variable `y` (`local_14`) is initialized from parameter `j`
    (`param _2)` ➍.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，局部变量`y`（`local_14`）由参数`j`（`param_2`）初始化➍。
- en: Local variable `z` (`local_18`) is initialized with the value 10 ➎.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 局部变量`z`（`local_18`）被初始化为值10➎。
- en: The first character `buffer[0]` (`local_58`) in the 64-byte character array
    is initialized with *A* (ASCII `0x41`) ➏.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个字符`buffer[0]`（`local_58`）在64字节字符数组中被初始化为 *A*（ASCII `0x41`）➏。
- en: The two arguments for the call to `helper` are pushed onto the stack ➐. The
    8-byte stack adjustment that precedes these two pushes combines with the two pushes
    to yield a net stack change of 16 bytes. As a result, the stack maintains any
    16-byte alignment achieved earlier in the program.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`helper`的调用有两个参数被压入堆栈➐。在这两个压栈之前的8字节堆栈调整与这两个压栈结合在一起，产生了16字节的净堆栈变化。因此，堆栈保持了程序中先前所实现的任何16字节对齐。
- en: '***The Ghidra Stack Frame Editor***'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Ghidra堆栈帧编辑器***'
- en: In addition to the summary stack view, Ghidra offers a detailed stack frame
    editor in which every byte allocated to a stack frame is accounted for. The Stack
    Frame Editor window is accessed by right-clicking and selecting Function ▸ Edit
    Stack Frame from the context menu when you have selected a function or stack variable
    within Ghidra’s summary stack view for a function. The resulting window for the
    `demo_stackframe` function is shown in [Figure 6-10](ch06.xhtml#fig6_10).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了概览栈视图，Ghidra 还提供了一个详细的栈帧编辑器，其中对栈帧中分配的每一个字节都进行了详细记录。栈帧编辑器窗口可以通过右键点击并在 Ghidra
    的概览栈视图中选择函数 ▸ 编辑栈帧来访问。当你在 Ghidra 的概览栈视图中选择一个函数或栈变量时，弹出的窗口将显示 `demo_stackframe`
    函数的情况，具体请参见[图 6-10](ch06.xhtml#fig6_10)。
- en: '![image](Images/fig6-10.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-10.jpg)'
- en: '*Figure 6-10: Sample summary stack view*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-10：示例概览栈视图*'
- en: Because the detailed view accounts for every byte in the stack frame, it occupies
    significantly more space than the summary view. The portion of the stack frame
    shown in [Figure 6-10](ch06.xhtml#fig6_10) spans a total of 29 bytes, which is
    only a small portion of the entire stack frame. Also in the previous listing,
    `local_10` ➌, `local_14` ➍, and `local_18` ➎ are directly referenced in the disassembly
    listing where their contents were initialized using `dword` (4-byte) writes. Based
    on the fact that 32 bits of data were moved, Ghidra is able to infer that each
    of these variables is a 4-byte quantity and labels each as an `undefined4` (a
    4-byte variable of unknown type).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因为详细视图会考虑栈帧中的每一个字节，所以它占用的空间比概览视图要大得多。[图 6-10](ch06.xhtml#fig6_10)中显示的栈帧部分总共占用了
    29 字节，这只是整个栈帧的一小部分。在之前的列表中，`local_10` ➌，`local_14` ➍ 和 `local_18` ➎ 在反汇编列表中直接引用，其中它们的内容是通过
    `dword`（4 字节）写入进行初始化的。基于移动了 32 位数据的事实，Ghidra 能推断出这些变量都是 4 字节的，并将它们标记为 `undefined4`（未知类型的
    4 字节变量）。
- en: As this is a Stack Frame Editor, we can use this window to edit fields, change
    display formats, and add supplemental information if it benefits our process.
    For example, we could add a name for the saved return address at `0x0`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个栈帧编辑器，我们可以使用此窗口编辑字段、改变显示格式，并在对我们的分析有益时添加补充信息。例如，我们可以为 `0x0` 处的保存返回地址添加一个名称。
- en: '**REGISTER-BASED PARAMETERS**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于寄存器的参数**'
- en: ARM calling conventions use up to four registers to pass parameters to functions
    without using the stack. Some x86-64 conventions use as many as six registers,
    and some MIPS conventions use up to eight. Register-based parameters are a little
    harder to identify than stack-based parameters.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 调用约定使用最多四个寄存器将参数传递给函数，而不使用栈。一些 x86-64 调用约定使用多达六个寄存器，一些 MIPS 调用约定则使用最多八个寄存器。基于寄存器的参数比基于栈的参数稍微难以识别。
- en: 'Consider the following two assembly language fragments:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下两个汇编语言片段：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the first function, the region of the stack beneath the saved return address
    is being accessed ➊, and we conclude that the function expects at least one argument.
    Ghidra, like most high-end disassemblers, performs stack pointer and frame pointer
    analysis to identify instructions that access members of a function’s stack frame.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个函数中，保存的返回地址下方的栈区域被访问 ➊，我们可以推断出该函数至少需要一个参数。像大多数高级反汇编工具一样，Ghidra 通过执行栈指针和帧指针分析来识别访问函数栈帧成员的指令。
- en: In the second function, `RDI` is used ➋ before it has been initialized. The
    only logical conclusion is that `RDI` must have been initialized in the caller,
    in which case `RDI` is being used to pass information from the caller into the
    `regargs` function (that is, it is a parameter). In program analysis terms, `RDI`
    is *live* on entry to `regargs`. To determine the number of register-based parameters
    the function expects, identify all registers that appear to be live within a function
    by observing that their contents are read and utilized before the register has
    been written (initialized) within a function.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个函数中，`RDI` 在初始化之前被使用 ➋。唯一合理的推断是，`RDI` 必须在调用者中初始化，在这种情况下，`RDI` 被用来将信息从调用者传递给
    `regargs` 函数（也就是说，它是一个参数）。在程序分析术语中，`RDI` 在进入 `regargs` 时是*活跃的*。为了确定函数期望的基于寄存器的参数数量，可以通过观察函数内哪些寄存器的内容在写入（初始化）之前已经被读取和使用，从而识别出所有活跃的寄存器。
- en: Unfortunately, this data flow analysis is usually beyond the capabilities of
    most disassemblers, including Ghidra. Decompilers, on the other hand, must perform
    this type of analysis and are generally quite good at identifying the use of register-based
    parameters. Ghidra’s Decompiler Parameter ID analyzer (Edit ▸ Options for <prog>
    ▸ Properties ▸ Analyzers) can update the disassembly listing based on parameter
    analysis performed by the decompiler.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种数据流分析通常超出了大多数反汇编器的能力，包括Ghidra。另一方面，反编译器必须执行这种类型的分析，并且通常能够很好地识别基于寄存器的参数的使用。Ghidra的反编译器参数ID分析器（编辑
    ▸ <prog> 的选项 ▸ 属性 ▸ 分析器）可以根据反编译器执行的参数分析更新反汇编列表。
- en: The stack editor view offers a detailed look at the inner workings of compilers.
    In [Figure 6-10](ch06.xhtml#fig6_10), it is clear that the compiler has inserted
    8 extra bytes between the saved frame pointer `-0x4` and the local variable `x`
    (`local_10`). These bytes occupy offsets `-0x5` through `-0xc` in the stack frame.
    Unless you happen to be a compiler writer yourself or are willing to dig deep
    into the source code for GNU `gcc`, all you can do is speculate as to why these
    extra bytes are allocated in this manner. In most cases, we can chalk up the extra
    bytes to padding for alignment, and usually the presence of these extra bytes
    has no impact on a program’s behavior. In [Chapter 8](ch08.xhtml#ch08), we return
    to the stack editor view and its uses in dealing with more complex data types
    such as arrays and structures.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈编辑器视图提供了编译器内部工作原理的详细视图。在[图6-10](ch06.xhtml#fig6_10)中，可以清楚地看到编译器在保存的帧指针`-0x4`和局部变量`x`（`local_10`）之间插入了8个额外的字节。这些字节占据了堆栈帧中的偏移量`-0x5`到`-0xc`。除非你是编译器开发人员，或者愿意深入挖掘GNU
    `gcc`的源代码，否则你只能猜测为什么这些额外的字节是以这种方式分配的。在大多数情况下，我们可以将这些额外字节归因于对齐的填充，并且通常这些额外字节的存在对程序的行为没有影响。在[第8章](ch08.xhtml#ch08)中，我们将回到堆栈编辑器视图，并探讨它在处理数组和结构等复杂数据类型时的应用。
- en: '**Searching**'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**搜索**'
- en: As shown at the start of the chapter, Ghidra makes it easy to navigate through
    the disassembly to locate artifacts that you know about and to discover new artifacts.
    It also designs many of its data displays to summarize specific types of information
    (names, strings, imports, and so on), making them easy to find as well. However,
    effective analysis of a disassembly listing often requires the ability to search
    for new clues to inform the disassembly analysis. Fortunately for us, Ghidra has
    a Search menu that allows us to conduct searches to locate items of interest.
    The default search menu options are shown in [Figure 6-11](ch06.xhtml#fig6_11).
    In this section, we investigate methods to search the disassembly by using both
    text and byte search functionality provided in the CodeBrowser.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头所示，Ghidra使得通过反汇编导航变得容易，能够定位已知的工件，并发现新的工件。它还设计了许多数据显示，以总结特定类型的信息（如名称、字符串、导入等），使得这些信息也容易找到。然而，对反汇编列表的有效分析通常需要能够搜索新的线索来指导反汇编分析。幸运的是，Ghidra有一个搜索菜单，允许我们进行搜索以定位感兴趣的项。[图6-11](ch06.xhtml#fig6_11)中显示了默认的搜索菜单选项。在本节中，我们将探讨如何利用CodeBrowser提供的文本和字节搜索功能来搜索反汇编。
- en: '![image](Images/fig6-11.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-11.jpg)'
- en: '*Figure 6-11: Ghidra Search menu options*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-11：Ghidra搜索菜单选项*'
- en: '#### ***Search Program Text***'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***搜索程序文本***'
- en: 'Ghidra text searches amount to substring searches through the disassembly listing
    view. Text searches are initiated via Search ▸ Program Text, which opens the dialog
    shown in [Figure 6-12](ch06.xhtml#fig6_12). Two search types are available: the
    entire program database, which extends beyond what you see in the CodeBrowser
    window, and the listing display within the CodeBrowser. Beyond the search type,
    several self-explanatory options let you select how and what to search.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra的文本搜索实际上是通过反汇编列表视图进行的子字符串搜索。文本搜索通过“搜索 ▸ 程序文本”启动，这将打开[图6-12](ch06.xhtml#fig6_12)所示的对话框。提供两种搜索类型：整个程序数据库，超出您在CodeBrowser窗口中看到的内容，以及CodeBrowser中的列表显示。除了搜索类型外，还有几个自解释选项，允许您选择搜索方式和搜索内容。
- en: To navigate between matches, use the Next and Previous buttons at the bottom
    of the Search Program Text dialog, or select Search All to open the search results
    in a new window, allowing easy navigation to any match.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要在匹配项之间导航，可以使用“搜索程序文本”对话框底部的“下一项”和“上一项”按钮，或者选择“搜索全部”以在新窗口中打开搜索结果，方便地导航到任何匹配项。
- en: '![image](Images/fig6-12.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-12.jpg)'
- en: '*Figure 6-12: Search Program Text dialog*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-12：搜索程序文本对话框*'
- en: '**I DUB THEE . . .**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**我命令你...**'
- en: Search windows are one of the window types within Ghidra that you can rename
    at will, which will help you keep track of search windows as you experiment. To
    rename a window, just right-click the title bar and provide a name that is meaningful
    to you. A handy trick is to include the search string along with a mnemonic to
    help you remember the settings you have chosen.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索窗口是Ghidra中的一种窗口类型，你可以随意重命名它们，这将帮助你在实验过程中跟踪搜索窗口。要重命名窗口，只需右键点击标题栏并提供一个对你有意义的名称。一个实用的小技巧是将搜索字符串和助记符一起包含在名称中，以帮助你记住所选择的设置。
- en: '***Search Memory***'
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***搜索内存***'
- en: If you need to search for specific binary content, such as a known sequence
    of bytes, then text searches are not the answer. Instead, you need to use Ghidra’s
    memory search functionality. A memory search can be initiated using Search ▸ Memory,
    or the associated hotkey S. [Figure 6-13](ch06.xhtml#fig6_13) shows the Search
    Memory dialog. To search for a sequence of hex bytes, the search string should
    be specified as a space-separated list of two-digit, case-insensitive hex values,
    such as `c9 c3`, as shown in [Figure 6-13](ch06.xhtml#fig6_13). If you are not
    sure of the hex sequence, you can use wildcards (* or `?`).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要搜索特定的二进制内容，比如已知的字节序列，那么文本搜索就不是答案。相反，你需要使用Ghidra的内存搜索功能。可以通过“搜索 ▸ 内存”或快捷键S来启动内存搜索。[图6-13](ch06.xhtml#fig6_13)显示了搜索内存对话框。要搜索十六进制字节序列，搜索字符串应该指定为以空格分隔的两位数、不区分大小写的十六进制值列表，如`c9
    c3`，如[图6-13](ch06.xhtml#fig6_13)所示。如果你不确定十六进制序列，可以使用通配符（*或`?`）。
- en: '![image](Images/fig6-13.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-13.jpg)'
- en: '*Figure 6-13: Search Memory dialog*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-13：搜索内存对话框*'
- en: The Search Memory results for the bytes `c9 c3`, run with the Search All option,
    are shown in [Figure 6-14](ch06.xhtml#fig6_14). You can sort on any column, rename
    the window, or apply a filter. This window also offers some right-click options,
    including the ability to delete rows and manipulate selections.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索内存结果中的字节`c9 c3`，使用“搜索全部”选项运行，结果如[图6-14](ch06.xhtml#fig6_14)所示。你可以对任何列进行排序，重命名窗口，或应用过滤器。此窗口还提供了一些右键选项，包括删除行和操作选择的功能。
- en: '![image](Images/fig6-14.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-14.jpg)'
- en: '*Figure 6-14: Search Memory results*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-14：搜索内存结果*'
- en: Search values can be input in string, decimal, binary, and regular expression
    formats as well. String, decimal, and binary each provide context-appropriate
    format options. Regular expressions let you search for a particular pattern, but
    only in the forward direction, because of restrictions on how they are processed.
    Ghidra uses Java’s built-in regular expressions grammar, which is described in
    significant detail in Ghidra Help.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索值可以通过字符串、十进制、二进制和正则表达式格式输入。字符串、十进制和二进制各自提供了适合的格式选项。正则表达式让你能够搜索特定的模式，但由于处理方式的限制，它只能向前搜索。Ghidra使用Java内建的正则表达式语法，相关内容在Ghidra帮助文档中有详细说明。
- en: '**Summary**'
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: The intent of this chapter was to provide you with the minimum essential skills
    for effectively interpreting Ghidra’s disassembly listings and navigating your
    way around them. The overwhelming majority of your interactions with Ghidra will
    involve the operations that we have discussed so far. However, the ability to
    perform basic navigation, understand important disassembly constructs like the
    stack, and search the disassembly are just the tip of the iceberg for a reverse
    engineer.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是为你提供有效解读Ghidra反汇编列表并进行导航的基本技能。你与Ghidra的绝大多数交互都将涉及到我们到目前为止讨论的操作。然而，能够执行基本的导航，理解堆栈等重要的反汇编结构，以及搜索反汇编，仅仅是逆向工程师技能的冰山一角。
- en: With these skills safely under your belt, the logical next step is learning
    how to use Ghidra to suit your particular needs. In the next chapter, we begin
    to look at how to make the most basic changes to a disassembly listing as a means
    of adding new knowledge based on our understanding of a binary’s content and behavior.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握这些技能后，下一步的逻辑是学习如何根据自己的需求使用Ghidra。在下一章中，我们将开始研究如何根据对二进制内容和行为的理解，进行最基本的反汇编列表修改，从而添加新的知识。
