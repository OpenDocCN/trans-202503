["```\nstmtLbl:\n    .\n    .\n    .\n  mov rcx, offset stmtLbl2\n    .\n    .\n    .\n  lea rax, stmtLbl\n    .\n    .\n    .\nstmtLbl2:\n```", "```\n; Listing 7-1\n\n; Demonstration of local symbols.\n; Note that this program will not\n; compile; it fails with an\n; undefined symbol error.\n\n        option  casemap:none\n\n            .code\n\nhasLocalLbl proc\n\nlocalStmLbl:\n            ret\nhasLocalLbl endp\n\n; Here is the \"asmMain\" function.\n\nasmMain     proc\n\nasmLocal:   jmp     asmLocal        ; This is okay\n            jmp     localStmtLbl    ; Undefined in asmMain\nasmMain     endp\n            end\n```", "```\nC:\\>**ml64 /c listing7-1.asm**\nMicrosoft (R) Macro Assembler (x64) Version 14.15.26730.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\n Assembling: listing7-1.asm\nlisting7-1.asm(26) : error A2006:undefined symbol : localStmtLbl\n```", "```\noption noscoped\noption scoped\n```", "```\n; Listing 7-2\n\n; Demonstration of local symbols #2.\n; Note that this program will not\n; compile; it fails with two\n; undefined symbol errors.\n\n            option  casemap:none\n\n            .code\n\nhasLocalLbl proc\n\nlocalStmLbl:\n            option noscoped\nnotLocal:\n            option scoped\nisLocal:\n            ret\nhasLocalLbl endp\n\n; Here is the \"asmMain\" function.\n\nasmMain     proc\n\n            lea     rcx, localStmtLbl  ; Generates an error\n            lea     rcx, notLocal      ; Assembles fine\n            lea     rcx, isLocal       ; Generates an error\nasmMain     endp\n            end\n```", "```\nC:\\>**ml64 /c listing7-2.asm**\nMicrosoft (R) Macro Assembler (x64) Version 14.15.26730.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\n Assembling: listing7-2.asm\nlisting7-2.asm(29) : error A2006:undefined symbol : localStmtLbl\nlisting7-2.asm(31) : error A2006:undefined symbol : isLocal\n```", "```\n; Listing 7-3\n\n; Initializing qword values with the\n; addresses of statement labels.\n\n        option  casemap:none\n\n            .data\nlblsInProc  qword   globalLbl1, globalLbl2  ; From procWLabels\n\n            .code\n\n; procWLabels - Just a procedure containing private (lexically scoped)\n;               and global symbols. This really isn't an executable\n;               procedure.\n\nprocWLabels proc\nprivateLbl:\n            nop     ; \"No operation\" just to consume space\n            option  noscoped\nglobalLbl1: jmp     globalLbl2\nglobalLbl2: nop\n            option  scoped\nprivateLbl2:\n            ret\ndataInCode  qword   privateLbl, globalLbl1\n            qword   globalLbl2, privateLbl2\nprocWLabels endp\n\n            end\n```", "```\nml64 /c /Fl listing7-3.asm\n```", "```\n00000000                        .data\n00000000           lblsInProc   qword   globalLbl1, globalLbl2\n       0000000000000001 R\n       0000000000000003 R\n          .\n          .\n          .\n 00000005           dataInCode  qword   privateLbl, globalLbl1\n       0000000000000000 R\n       0000000000000001 R\n 00000015  0000000000000003 R   qword   globalLbl2, privateLbl2\n       0000000000000004 R\n```", "```\njmp `label`\njmp `reg`[64]\njmp `mem`[64] \n```", "```\n `Statements`\n          jmp laterInPgm\n               .\n               .\n               .\nlaterInPgm:\n `Statements`\n```", "```\n; Listing 7-4\n\n; Demonstration of register-indirect jumps.\n\n        option  casemap:none\n\nnl          =       10\nmaxLen      =       256\nEINVAL      =       22      ; \"Magic\" C stdlib constant, invalid argument\nERANGE      =       34      ; Value out of range\n\n            .const\nttlStr      byte    \"Listing 7-4\", 0\nfmtStr1     byte    \"Enter an integer value between \"\n            byte    \"1 and 10 (0 to quit): \", 0\n\nbadInpStr   byte    \"There was an error in readLine \"\n            byte    \"(ctrl-Z pressed?)\", nl, 0\n\ninvalidStr  byte    \"The input string was not a proper number\"\n            byte    nl, 0\n\nrangeStr    byte    \"The input value was outside the \"\n            byte    \"range 1-10\", nl, 0\n\nunknownStr  byte    \"There was a problem with strToInt \"\n            byte    \"(unknown error)\", nl, 0\n\ngoodStr     byte    \"The input value was %d\", nl, 0\n\nfmtStr      byte    \"result:%d, errno:%d\", nl, 0\n\n            .data\n            externdef _errno:dword  ; Error return by C code\nendStr      qword   ?\ninputValue  dword   ?\nbuffer      byte    maxLen dup (?)\n\n            .code\n            externdef readLine:proc\n            externdef strtol:proc\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n```", "```\n; strToInt - Converts a string to an integer, checking for errors.\n\n; Argument:\n;    RCX -   Pointer to string containing (only) decimal\n;            digits to convert to an integer.\n\n; Returns:\n;    RAX -   Integer value if conversion was successful.\n;    RCX -   Conversion state. One of the following:\n;            0 - Conversion successful.\n;            1 - Illegal characters at the beginning of the\n;                string (or empty string).\n;            2 - Illegal characters at the end of the string.\n;            3 - Value too large for 32-bit signed integer.\n\nstrToInt    proc\nstrToConv   equ     [rbp+16]        ; Flush RCX here\nendPtr      equ     [rbp-8]         ; Save ptr to end of str\n            push    rbp\n mov     rbp, rsp\n            sub     rsp, 32h       ; Shadow + 16-byte alignment\n\n            mov     strToConv, rcx ; Save, so we can test later\n\n            ; RCX already contains string parameter for strtol:\n\n            lea     rdx, endPtr    ; Ptr to end of string goes here\n            mov     r8d, 10        ; Decimal conversion\n            call    strtol\n\n; On return:\n\n;    RAX    - Contains converted value, if successful.\n;    endPtr - Pointer to 1 position beyond last char in string.\n\n; If strtol returns with endPtr == strToConv, then there were no\n; legal digits at the beginning of the string.\n\n            mov     ecx, 1         ; Assume bad conversion\n            mov     rdx, endPtr\n            cmp     rdx, strToConv\n            je      returnValue\n\n; If endPtr is not pointing at a zero byte, then we've got\n; junk at the end of the string.\n\n            mov     ecx, 2         ; Assume junk at end\n            mov     rdx, endPtr\n            cmp     byte ptr [rdx], 0\n            jne     returnValue\n\n; If the return result is 7FFF_FFFFh or 8000_0000h (max long and\n; min long, respectively), and the C global _errno variable \n; contains ERANGE, then we've got a range error.\n\n            mov     ecx, 0         ; Assume good input\n            cmp     _errno, ERANGE\n            jne     returnValue\n            mov     ecx, 3         ; Assume out of range\n            cmp     eax, 7fffffffh\n            je      returnValue\n            cmp     eax, 80000000h\n            je      returnValue\n\n; If we get to this point, it's a good number.\n\n            mov     ecx, 0\n\nreturnValue:\n            leave\n            ret\nstrToInt    endp\n```", "```\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\nsaveRBX     equ     qword ptr [rbp-8]      ; Must preserve RBX\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 48                ; Shadow storage\n\n            mov     saveRBX, rbx           ; Must preserve RBX\n\n            ; Prompt the user to enter a value\n            ; between 1 and 10:\n\nrepeatPgm:  lea     rcx, fmtStr1\n            call    printf\n\n            ; Get user input:\n\n            lea     rcx, buffer\n            mov     edx, maxLen     ; Zero-extends!\n            call    readLine\n            lea     rbx, badInput   ; Initialize state machine\n            test    rax, rax        ; RAX is -1 on bad input\n            js      hadError        ; (only neg value readLine returns)\n\n            ; Call strToInt to convert string to an integer and\n            ; check for errors:\n\n            lea     rcx, buffer     ; Ptr to string to convert\n            call    strToInt\n            lea     rbx, invalid\n            cmp     ecx, 1\n            je      hadError\n            cmp     ecx, 2\n            je      hadError\n\n lea     rbx, range\n            cmp     ecx, 3\n            je      hadError\n\n            lea     rbx, unknown\n            cmp     ecx, 0\n            jne     hadError\n\n; At this point, input is valid and is sitting in EAX.\n\n; First, check to see if the user entered 0 (to quit\n; the program).\n\n            test    eax, eax        ; Test for zero\n            je      allDone\n\n; However, we need to verify that the number is in the\n; range 1-10.\n\n            lea     rbx, range\n            cmp     eax, 1\n            jl      hadError\n            cmp     eax, 10\n            jg      hadError\n\n; Pretend a bunch of work happens here dealing with the\n; input number.\n\n            lea     rbx, goodInput\n            mov     inputValue, eax\n\n; The different code streams all merge together here to\n; execute some common code (we'll pretend that happens;\n; for brevity, no such code exists here).\n\nhadError:\n\n; At the end of the common code (which doesn't mess with\n; RBX), separate into five different code streams based\n; on the pointer value in RBX:\n\n            jmp     rbx\n\n; Transfer here if readLine returned an error:\n\nbadInput:   lea     rcx, badInpStr\n            call    printf\n            jmp     repeatPgm\n\n; Transfer here if there was a non-digit character\n; in the string:\n\ninvalid:    lea     rcx, invalidStr\n call    printf\n            jmp     repeatPgm\n\n; Transfer here if the input value was out of range:\n\nrange:      lea     rcx, rangeStr\n            call    printf\n            jmp     repeatPgm\n\n; Shouldn't ever get here. Happens if strToInt returns\n; a value outside the range 0-3.\n\nunknown:    lea     rcx, unknownStr\n            call    printf\n            jmp     repeatPgm\n\n; Transfer down here on a good user input.\n\ngoodInput:  lea     rcx, goodStr\n            mov     edx, inputValue ; Zero-extends!\n            call    printf\n            jmp     repeatPgm\n\n; Branch here when the user selects \"quit program\" by\n; entering the value zero:\n\nallDone:    mov     rbx, saveRBX    ; Must restore before returning\n            leave\n            ret                     ; Returns to caller\n\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing7-4**\n\nC:\\>**echo off**\n Assembling: listing7-4.asm\nc.cpp\n\nC:\\>**listing7-4**\nCalling Listing 7-4:\nEnter an integer value between 1 and 10 (0 to quit): ^Z\nThere was an error in readLine (ctrl-Z pressed?)\nEnter an integer value between 1 and 10 (0 to quit): a123\nThe input string was not a proper number\nEnter an integer value between 1 and 10 (0 to quit): 123a\nThe input string was not a proper number\nEnter an integer value between 1 and 10 (0 to quit): 1234567890123\nThe input value was outside the range 1-10\nEnter an integer value between 1 and 10 (0 to quit): -1\nThe input value was outside the range 1-10\nEnter an integer value between 1 and 10 (0 to quit): 11\nThe input value was outside the range 1-10\nEnter an integer value between 1 and 10 (0 to quit): 5\nThe input value was 5\nEnter an integer value between 1 and 10 (0 to quit): 0\nListing 7-4 terminated\n```", "```\n; Listing 7-5\n\n; Demonstration of memory-indirect jumps.\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 7-5\", 0\nfmtStr1     byte    \"Before indirect jump\", nl, 0\nfmtStr2     byte    \"After indirect jump\", nl, 0\n\n            .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbp\n mov     rbp, rsp\n            sub     rsp, 48                 ; Shadow storage\n\n            lea     rcx, fmtStr1\n            call    printf\n            jmp     memPtr\n\nmemPtr      qword   ExitPoint\n\nExitPoint:  lea     rcx, fmtStr2\n            call    printf\n\n            leave\n            ret     ; Returns to caller\n\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing7-5**\n\nC:\\>**echo off**\n Assembling: listing7-5.asm\nc.cpp\n\nC:\\>**listing7-5**\nCalling Listing 7-5:\nBefore indirect jump\nAfter indirect jump\nListing 7-5 terminated\n```", "```\n cmp bx, cx\n          jne SkipStmts;\n          inc ax\nSkipStmts:\n```", "```\n mov edi, 0\nRdLnLoop:\n      call getchar         ; Some function that reads a character\n                           ; into the AL register\n      mov Input[rdi], al   ; Store away the character\n      inc rdi              ; Move on to the next character\n      cmp al, nl           ; See if the user pressed ENTER\n      jne RdLnLoop\n```", "```\n jn`cc`  skipJmp  ; Opposite jump of the one you want to use\n        jmp   destPtr  ; JMP PC-relative is also limited to ±2GB\ndestPtr qword destLbl  ; so code must use indirect jump\nskipJmp:\n```", "```\ncmov*cc* `reg`[16], `reg`[16]\ncmov*cc* `reg`[16], `mem`[16]\ncmov*cc* `reg`[32], `reg`[32]\ncmov*cc* `reg`[32], `mem`[32]\ncmov*cc* `reg`[64], `reg`[64]\ncmov*cc* `reg`[64], `mem`[64]\n```", "```\nif(`expression`) then\n    `Statements`\nendif;\n```", "```\nif(a == b)\n{\n    printf(\"a is equal to b \\ n\");\n} \n```", "```\n mov  eax, a           ; Assume a and b are 32-bit integers\n      cmp  eax, b\n      jne  aNEb\n      lea  rcx, aIsEqlBstr  ; \"a is equal to b \\ n\"\n      call printf\naNEb:\n```", "```\n `Sequence of statements to test a condition`\n          j`cc` ElseCode;\n\n `Sequence of statements corresponding to the THEN block`\n          jmp EndOfIf\n\nElseCode: \n `Sequence of statements corresponding to the ELSE block`\n\nEndOfIf:\n```", "```\nif(a == b)\n    c = d;\nelse \n    b = b + 1;\n```", "```\n mov eax, a\n          cmp eax, b\n          jne ElseBlk\n          mov eax, d\n          mov c, eax\n          jmp EndOfIf;\n\nElseBlk:\n          inc b\n\nEndOfIf: \n```", "```\nif(((x > y) && (z < t)) || (a != b))\n    c = d;\n```", "```\nif(a != b) c = d;\nelse if(x > y)\n     if(z < t)\n           c = d;\n```", "```\nif(`expr1` && `expr2`) `Stmt`;\n```", "```\nif(`expr1`) if(`expr2`) `Stmt`;\n```", "```\nif(`expr1` || `expr2`) `Stmt`;\n```", "```\nif(`expr1`) `Stmt`;\nelse if(`expr2`) `Stmt`;\n```", "```\n; if(((x > y) && (z < t)) || (a != b))c = d;\n\n          mov eax, a\n          cmp eax, b\n          jne DoIf;\n          mov eax, x\n          cmp eax, y\n          jng EndOfIf;\n          mov eax, z\n          cmp eax, t\n          jnl EndOfIf;\nDoIf:\n          mov eax, d\n          mov c, eax\nEndOfIf:\n```", "```\n; if ((x > y) && (z < t)) or (a != b)  c = d;\n; Implemented as: \n; if (a != b) then goto DoIf: \n\n          mov eax, a\n          cmp eax, b\n          jne DoIf\n\n; if not (x > y) then goto EndOfIf:\n\n          mov eax, x\n          cmp eax, y\n          jng EndOfIf\n\n; if not (z < t) then goto EndOfIf:\n\n          mov eax, z\n          cmp eax, t\n          jnl EndOfIf\n\n; THEN block:\n\nDoIf:     \n          mov eax, d\n          mov c, eax\n\n; End of IF statement.\n\nEndOfIf:\n```", "```\n; if (((x > y) && (z < t)) || (a != b))  c = d;\n; Test the Boolean expression:\n\n          mov eax, a\n          cmp eax, b\n          jne DoIf\n          mov eax, x\n          cmp eax, y\n          jng EndOfIf\n          mov eax, z\n          cmp eax, t\n          jnl EndOfIf\n\n; THEN block:\n\nDoIf:\n          mov eax, d\n          mov c, eax\n\n; End of IF statement.\n\nEndOfIf: \n```", "```\n;     if(((x < y) && (z > t)) || (a != b))\n;          `Stmt1` \n\n          mov  eax, x\n cmp   eax, y\n          setl  bl        ; Store x < y in BL\n          mov   eax, z\n          cmp   eax, t\n          setg  bh        ; Store z > t in BH\n          and   bl, bh    ; Put (x < y) && (z > t) into BL\n          mov   eax, a\n          cmp   eax, b\n          setne bh        ; Store a != b into BH\n          or    bl, bh    ; Put (x < y) && (z > t) || (a != b) into BL\n          je    SkipStmt1 ; Branch if result is false\n\n `Code for Stmt1 goes here`\n\nSkipStmt1:\n```", "```\n; if((x < y) && (z > t)) then ...\n\n          mov eax, x\n          cmp eax, y\n          jnl TestFails\n          mov eax, z\n          cmp eax, t\n          jng TestFails\n\n `Code for THEN clause of IF statement`\n\nTestFails:\n```", "```\n; if(ch < 'A' || ch > 'Z')\n;     then printf(\"Not an uppercase char\");\n; endif;\n\n          cmp ch, 'A'\n          jb ItsNotUC\n          cmp ch, 'Z'\n          jna ItWasUC\n\nItsNotUC:\n `Code to process ch if it's not an uppercase character`\n\nItWasUC:\n```", "```\n; if(((x < y) && (z > t)) || (a != b)) `Stmt1` ;\n\n          mov eax, a\n          cmp eax, b\n          jne DoStmt1\n          mov eax, x\n          cmp eax, y\n          jnl SkipStmt1\n          mov eax, z\n          cmp eax, t\n          jng SkipStmt1\n\nDoStmt1:\n `Code for Stmt1 goes here`\n\nSkipStmt1:\n```", "```\nif((x == y) && (++z != 0)) `Stmt` ;\n```", "```\n mov   eax, x      ; See if x == y\n          cmp   eax, y\n          sete  bl \n          inc   z           ; ++z\n          cmp   z, 0        ; See if incremented z is 0\n          setne bh\n          and   bl, bh      ; Test x == y && ++z != 0\n          jz    SkipStmt\n\n `Code for Stmt goes here`\n\nSkipStmt:\n```", "```\n mov eax, x      ; See if x == y\n          cmp eax, y\n          jne SkipStmt\n          inc z           ; ++z - sets ZF if z becomes zero\n          je  SkipStmt    ; See if incremented z is 0\n\n `Code for Stmt goes here`\n\nSkipStmt:\n```", "```\nif(pntr != NULL && *pntr == 'a')  `Stmt` ;\n```", "```\n; Complete Boolean evaluation:\n\n          mov   rax, pntr\n          test  rax, rax   ; Check to see if RAX is 0 (NULL is 0)\n          setne bl\n          mov   al, [rax]  ; Get *pntr into AL\n          cmp   al, 'a'\n          sete  bh\n          and   bl, bh\n          jz    SkipStmt\n\n `Code for Stmt goes here`\n\nSkipStmt:\n```", "```\n; Short-circuit Boolean evaluation:\n\n      mov  rax, pntr   ; See if pntr contains NULL (0) and\n      test rax, rax    ; immediately skip past Stmt if this\n      jz   SkipStmt    ; is the case\n\n mov  al, [rax]   ; If we get to this point, pntr contains\n      cmp  al, 'a'     ; a non-NULL value, so see if it points\n      jne  SkipStmt    ; at the character \"a\"\n\n `Code for Stmt goes here`\n\nSkipStmt:\n```", "```\nif((a == b) && (c < d)) ++i;\n```", "```\n mov eax, a\n          cmp eax, b\n          jne DontIncI\n\n          mov eax, c\n          cmp eax, d\n          jnl DontIncI\n\n          inc i\n\nDontIncI:\n```", "```\n mov eax, c\n          cmp eax, d\n          jnl DontIncI\n\n          mov eax, a\n          cmp eax, b\n          jne DontIncI\n\n          inc i\n\nDontIncI:\n```", "```\nif((x % 10 = 0) && (x != y) ++x;\n```", "```\n mov  eax, x        ; Compute X % 10\n          cdq                ; Must sign-extend EAX -> EDX:EAX\n          idiv ten           ; \"ten dword 10\" in .const section\n          test edx, edx      ; Remainder is in EDX, test for 0\n          jnz  SkipIf\n\n          mov  eax, x\n          cmp  eax, y\n          je   SkipIf\n\n          inc  x\n\nSkipIf:\n```", "```\n mov  eax, x\n          cmp  eax, y\n          je   SkipIf\n\n          mov  eax, x     ; Compute X % 10\n          cdq             ; Must sign-extend EAX -> EDX:EAX\n          idiv ten        ; \"ten dword 10\" in .const section\n          test edx, edx   ; See if remainder (EDX) is 0\n          jnz  SkipIf\n\n          inc  x\n\nSkipIf:\n```", "```\nif(`see_if_an_error_has_occurred`)\n{\n `Statements to execute if no error`\n}\nelse\n{\n `Error-handling statements`\n}\n```", "```\n cmp `see_if_an_error_has_occurred`, true\n     je HandleTheError\n\n `Statements to execute if no error`\n\n     jmp EndOfIf;\n\nHandleTheError:\n `Error-handling statements`\nEndOfIf:\n```", "```\n cmp `see_if_an_error_has_occurred`, true\n     je HandleTheError\n\n `Statements to execute if no error`\n\nEndOfIf:\n```", "```\nHandleTheError:\n `Error-handling statements`\n     jmp EndOfIf;\n```", "```\n test eax, eax\n          jns ItsPositive;\n\n          neg eax\n\nItsPositive:\n```", "```\n; Set EDX to 0FFFF_FFFFh if EAX is negative, 0000_0000 if EAX is\n; 0 or positive:\n\n          cdq\n\n; If EAX was negative, the following code inverts all the bits in\n; EAX; otherwise, it has no effect on EAX.\n\n          xor eax, edx\n\n; If EAX was negative, the following code adds 1 to EAX;\n; otherwise, it doesn't modify EAX's value.\n\n and edx, 1   ; EDX = 0 or 1 (1 if EAX was negative)\n          add eax, edx\n```", "```\nmov    edx, eax\nneg    edx\ncmovns eax, edx \n```", "```\n switch(`expression`)\n      {\n          case `const1`:\n `Stmts1: Code to execute if`\n `expression equals const1`\n\n          case `const2`:\n `Stmts2: Code to execute if`\n `expression equals const2`\n            .\n            .\n            .\n          case `constn`:\n `Stmtsn: Code to execute if`\n `expression equals constn`\n\n          default:  ; Note that the default section is optional\n `Stmts_default: Code to execute if expression`\n                           `does not equal`\n                           `any of the case values`\n      }\n```", "```\nswitch(`expression`)\n{\n    case 0: printf(\"i=0\"); break;\n    case 1: printf(\"i=1\"); break;\n    case 2: printf(\"i=2\"); break;\n}\n\nif(eax == 0)\n    printf(\"i=0\");\nelse if(eax == 1)\n    printf(\"i=1\");\nelse if(eax == 2)\n    printf(\"i=2\");\n```", "```\n; if/then/else/endif form:\n\n          mov eax, i\n          test eax, eax   ; Check for 0\n          jnz Not0\n\n `Code to print \"i = 0\"`\n          jmp EndCase\n\nNot0:\n          cmp eax, 1\n          jne Not1\n\n `Code to print \"i = 1\"`\n          jmp EndCase\n\nNot1:\n          cmp eax, 2\n          jne EndCase;\n\n `Code to print \"i = 2\"`\nEndCase: \n```", "```\n; Indirect Jump Version.\n\n        mov eax, i\n        lea rcx, JmpTbl\n        jmp qword ptr [rcx][rax * 8]\n\nJmpTbl  qword Stmt0, Stmt1, Stmt2\n\nStmt0:\n `Code to print \"i = 0\"`\n        jmp EndCase;\n\nStmt1:\n `Code to print \"i = 1\"`\n        jmp EndCase;\n\nStmt2:\n `Code to print \"i = 2\"`\n\nEndCase: \n```", "```\n mov eax, i\n        cmp eax, 2\n        ja  EndCase\n        lea rcx, JmpTbl\n        jmp qword ptr [rcx][rax * 8]\n\nJmpTbl  qword Stmt0, Stmt1, Stmt2\n\nStmt0:\n `Code to print \"i = 0\"`\n        jmp EndCase;\n\nStmt1:\n `Code to print \"i = 1\"`\n        jmp EndCase;\n\nStmt2:\n `Code to print \"i = 2\"`\n\nEndCase:\n```", "```\n; SWITCH statement specifying cases 5, 6, and 7:\n; WARNING: This code does *NOT* work.\n; Keep reading to find out why.\n\n     mov eax, i\n     cmp eax, 5\n     jb  EndCase\n     cmp eax, 7              ; Verify that i is in the range\n     ja  EndCase             ; 5 to 7 before the indirect jmp\n     lea rcx, JmpTbl\n     jmp qword ptr [rcx][rax * 8]\n\nJmpTbl  qword Stmt5, Stmt6, Stmt7\n\nStmt5:\n `Code to print \"i = 5\"`\n        jmp EndCase;\n\nStmt6:\n `Code to print \"i = 6\"`\n        jmp EndCase;\n\nStmt7:\n `Code to print \"i = 7\"`\n\nEndCase:\n```", "```\n; SWITCH statement specifying cases 5, 6, and 7.\n; WARNING: There is a better way to do this; keep reading.\n\n     mov eax, i\n     cmp eax, 5\n     jb  EndCase\n     cmp eax, 7              ; Verify that i is in the range\n     ja  EndCase             ; 5 to 7 before the indirect jmp\n     sub eax, 5              ; 5 to 7 -> 0 to 2\n     lea rcx, JmpTbl\n     jmp qword ptr [rcx][rax * 8]\n\nJmpTbl  qword Stmt5, Stmt6, Stmt7\n\nStmt5:\n `Code to print \"i = 5\"`\n        jmp EndCase;\n\nStmt6:\n `Code to print \"i = 6\"`\n        jmp EndCase;\n\nStmt7:\n `Code to print \"i = 7\"`\n\nEndCase: \n```", "```\n; SWITCH statement specifying cases 5, 6, and 7:\n\n     mov eax, i\n     cmp eax, 5\n     jb  EndCase\n     cmp eax, 7                           ; Verify that i is in the range\n     ja  EndCase                          ; 5 to 7 before the indirect jmp\n     lea rcx, JmpTbl\n     jmp qword ptr [rcx][rax * 8 – 5 * 8] ; 5 * 8 compensates for zero index\n\nJmpTbl  qword Stmt5, Stmt6, Stmt7\n\nStmt5:\n `Code to print \"i = 5\"`\n        jmp EndCase;\n\nStmt6:\n `Code to print \"i = 6\"`\n jmp EndCase;\n\nStmt7:\n `Code to print \"i = 7\"`\n\nEndCase:\n```", "```\nswitch(`expression`)\n{\n\n    case 5:  printf(\"ebx = 5\"); break;\n    case 6:  printf(\"ebx = 6\"); break;\n    case 7:  printf(\"ebx = 7\"); break;\n    default\n        printf(\"ebx does not equal 5, 6, or 7\");\n}\n```", "```\n; SWITCH statement specifying cases 5, 6, and 7\n; with a DEFAULT clause:\n\n     mov eax, i\n     cmp eax, 5 \n     jb  DefaultCase\n     cmp eax, 7                           ; Verify that i is in the range\n     ja  DefaultCase                      ; 5 to 7 before the indirect jmp\n     lea rcx, JmpTbl\n     jmp qword ptr [rcx][rax * 8 – 5 * 8] ; 5 * 8 compensates for zero index\n\nJmpTbl  qword Stmt5, Stmt6, Stmt7\n\nStmt5:\n `Code to print \"i = 5\"`\n        jmp EndCase\n\nStmt6:\n `Code to print \"i = 6\"`\n        jmp EndCase\n\nStmt7:\n `Code to print \"i = 7\"`\n        jmp EndCase\n\nDefaultCase:\n `Code to print \"EBX does not equal 5, 6, or 7\"`\n\nEndCase:\n```", "```\nswitch(i)\n{\n    case 1  printf(\"i = 1\"); break;\n    case 2  printf(\"i = 2\"); break;\n    case 4  printf(\"i = 4\"); break;\n    case 8  printf(\"i = 8\"); break;\n    default:\n        printf(\"i is not 1, 2, 4, or 8\");\n}\n```", "```\n; SWITCH statement specifying cases 1, 2, 4, and 8\n; with a DEFAULT clause:\n\n     mov eax, i\n     cmp eax, 1\n     jb  DefaultCase\n     cmp eax, 8                           ; Verify that i is in the range\n     ja  DefaultCase                      ; 1 to 8 before the indirect jmp\n     lea rcx, JmpTbl\n     jmp qword ptr [rcx][rax * 8 – 1 * 8] ; 1 * 8 compensates for zero index\n\nJmpTbl  qword Stmt1, Stmt2, DefaultCase, Stmt4\n        qword DefaultCase, DefaultCase, DefaultCase, Stmt8\n\nStmt1:\n `Code to print \"i = 1\"`\n        jmp EndCase\n\nStmt2:\n `Code to print \"i = 2\"`\n        jmp EndCase\n\nStmt4:\n `Code to print \"i = 4\"`\n        jmp EndCase\n\nStmt8:\n `Code to print \"i = 8\"`\n        jmp EndCase\n\nDefaultCase:\n `Code to print \"i does not equal 1, 2, 4, or 8\"`\n\nEndCase: \n```", "```\nswitch(i)\n{\n    case 1:       `Stmt1` ;\n    case 100:     `Stmt2` ;\n    case 1000:    `Stmt3` ;\n    case 10000:   `Stmt4` ;\n    default:      `Stmt5` ;\n\n}\n```", "```\nswitch(i)\n{\n    case 0:   `Stmt0` ;\n    case 1:   `Stmt1` ;\n    case 2:   `Stmt2` ;\n    case 100: `Stmt3` ;\n    default:  `Stmt4` ;\n\n}\n```", "```\nmov eax, i\ncmp eax, 100\nje  DoStmt3;\ncmp eax, 2\nja  TheDefaultCase\nlea rcx, JmpTbl\njmp qword ptr [rcx][rax * 8]\n .\n .\n .\n```", "```\n; SWITCH statement specifying cases 5, 6, and 7\n; with a DEFAULT clause:\n\n     mov eax, i\n     cmp eax, 5\n     jb  DefaultCase\n     cmp eax, 7                  ; Verify that i is in the range\n     ja  DefaultCase             ; 5 to 7 before the indirect jmp\n     jmp JmpTbl[rax * 8 – 5 * 8] ; 5 * 8 compensates for zero index\n\nJmpTbl  qword Stmt5, Stmt6, Stmt7\n\nStmt5:\n `Code to print \"i = 5\"`\n        jmp EndCase\n\nStmt6:\n `Code to print \"i = 6\"`\n        jmp EndCase\n\nStmt7:\n `Code to print \"i = 7\"`\n        jmp EndCase\n\nDefaultCase:\n `Code to print \"EBX does not equal 5, 6, or 7\"`\n\nEndCase:\n```", "```\nswitch(`expression`)\n{\n    case 0:\n `Code for case 0`\n        break;\n\n    case 1:\n `Code for case 1`\n        break;\n\n    case 2:\n `Code for case 2`\n        break;\n\n    case 10:\n `Code for case 10`\n        break;\n\n    case 11:\n `Code for case 11`\n        break;\n\n    case 100:\n `Code for case 100`\n        break;\n\n    case 101:\n `Code for case 101`\n        break;\n\n    case 103:\n `Code for case 101`\n        break;\n\n    case 1000:\n `Code for case 1000`\n        break;\n\n    case 1001:\n `Code for case 1001`\n        break;\n\n    case 1003:\n `Code for case 1001`\n        break;\n\n    default:\n `Code for default case`\n        break;\n} // end switch\n```", "```\n; Assume expression has been computed and is sitting in EAX/RAX\n; at this point...\n\n         cmp   eax, 100\n         jb    try0_11\n         cmp   eax, 103\n         ja    try1000_1003\n         cmp   eax, 100\n         jb    default\n         lea   rcx, jt100\n         jmp   qword ptr [rcx][rax * 8 – 100 * 8]\njt100    qword case100, case101, default, case103\n\ntry0_11: cmp   ecx, 11 ; Handle cases 0-11 here\n         ja    defaultCase\n         lea   rcx, jt0_11\n         jmp   qword ptr [rcx][rax * 8]\njt0_11   qword case0, case1, case2, defaultCase \n         qword defaultCase, defaultCase, defaultCase\n         qword defaultCase, defaultCase, defaultCase\n         qword case10, case11\n\ntry1000_1003:\n         cmp   eax, 1000\n         jb    defaultCase\n         cmp   eax, 1003\n         ja    defaultCase\n         lea   rcx, jt1000\n         jmp   qword ptr [rcx][rax * 8 – 1000 * 8]\njt1000   qword case1000, case1001, defaultCase, case1003\n           .\n           .\n           .\n `Code for the actual cases here`\n```", "```\nif(unsignedExpression <= 11)\n{\n `Switch for 0 to 11`\n}\nelse if(unsignedExpression >= 100 && unsignedExpression <= 101)\n{\n `Switch for 100 to 101`\n}\nelse if(unsignedExpression >= 1000 && unsignedExpression <= 1001)\n{\n `Switch for 1000 to 1001`\n}\nelse\n{\n `Code for default case`\n}\n```", "```\n; Assume expression has been calculated into EAX.\n\n        cmp eax, 100\n        jb  try1_10\n ja  try1000_10000\n\n `Code to handle case 100 goes here`\n        jmp AllDone\n\ntry1_10:\n        cmp eax,1\n        je  case1\n        cmp eax, 10\n        jne defaultCase\n\n `Code to handle case 10 goes here`\n        jmp AllDone\ncase1:\n `Code to handle case 1 goes here`\n        jmp AllDone\n\ntry1000_10000:\n        cmp eax, 1000\n        je  case1000\n        cmp eax, 10000\n        jne defaultCase\n\n `Code to handle case 10000 goes here`\n        jmp AllDone\n\ncase1000:\n `Code to handle case 1000 goes here`\n        jmp AllDone\n\ndefaultCase:\n `Code to handle defaultCase goes here`\n\nAllDone:\n```", "```\n; Assume expression has been computed and is sitting in EAX/RAX\n; at this point...\n\n         cmp   eax, 100\n         jb    try0_13\n         cmp   eax, 103\n         ja    try1000_1003\n         lea   rcx, jt100\n         jmp   qword ptr [rcx][rax * 8 – 100 * 8]\n\ntry0_13: cmp   ecx, 13      ; Handle cases 0 to 13 here\n         ja    defaultCase\n         lea   rcx, jt0_13\n         jmp   qword ptr [rcx][rax * 8]\n\ntry1000_1003:\n         cmp   eax, 1000    ; Handle cases 1000 to 1003 here\n         jb    defaultCase\n         cmp   eax, 1003\n         ja    defaultCase\n         lea   rcx, jt1000\n         jmp   qword ptr [rcx][rax * 8 – 1000 * 8]\n\ndefaultCase:\n `Put defaultCase here to keep it near all the`\n `conditional jumps to defaultCase` \n\n         jmp   AllDone\n\njt0_13   qword case0, case1, case2, case3\n         qword defaultCase, defaultCase, defaultCase\n         qword defaultCase, defaultCase, defaultCase\n         qword case10, case11, case12, case13\njt100    qword case100, case101, case102, case103\njt1000   qword case1000, case1001, case1002, case1003\n           .\n           .\n           .\n `Code for the actual cases here`\n```", "```\n; Listing 7-6\n\n; A simple state machine example.\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 7-6\", 0\nfmtStr0     byte    \"Calling StateMachine, \"\n            byte    \"state=%d, EAX=5, ECX=6\", nl, 0\n\nfmtStr0b    byte    \"Calling StateMachine, \"\n            byte    \"state=%d, EAX=1, ECX=2\", nl, 0\n\nfmtStrx     byte    \"Back from StateMachine, \"\n            byte    \"state=%d, EAX=%d\", nl, 0\n\nfmtStr1     byte    \"Calling StateMachine, \"\n            byte    \"state=%d, EAX=50, ECX=60\", nl, 0\n\nfmtStr2     byte    \"Calling StateMachine, \"\n            byte    \"state=%d, EAX=10, ECX=20\", nl, 0\n\nfmtStr3     byte    \"Calling StateMachine, \"\n            byte    \"state=%d, EAX=50, ECX=5\", nl, 0\n\n            .data\nstate       byte    0\n\n .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\nStateMachine proc\n             cmp    state, 0\n             jne    TryState1\n\n; State 0: Add ECX to EAX and switch to state 1:\n\n             add    eax, ecx\n             inc    state           ; State 0 becomes state 1\n             jmp    exit\n\nTryState1:\n             cmp    state, 1\n             jne    TryState2\n\n; State 1: Subtract ECX from EAX and switch to state 2:\n\n             sub    eax, ecx\n             inc    state           ; State 1 becomes state 2\n             jmp    exit\n\nTryState2:   cmp    state, 2\n             jne    MustBeState3\n\n; If this is state 2, multiply ECX by EAX and switch to state 3:\n\n             imul   eax, ecx\n             inc    state           ; State 2 becomes state 3\n             jmp    exit\n\n; If it isn't one of the preceding states, we must be in state 3,\n; so divide EAX by ECX and switch back to state 0.\n\nMustBeState3:\n             push   rdx          ; Preserve this 'cause it\n                                 ; gets whacked by div\n             xor    edx, edx     ; Zero-extend EAX into EDX\n             div    ecx\n             pop    rdx          ; Restore EDX's value preserved above\n             mov    state, 0     ; Reset the state back to 0\n\nexit:        ret\n\nStateMachine endp\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 48         ; Shadow storage\n\n            mov     state, 0        ; Just to be safe\n\n; Demonstrate state 0:\n\n            lea     rcx, fmtStr0\n            movzx   rdx, state\n            call    printf\n\n            mov     eax, 5\n            mov     ecx, 6\n            call    StateMachine\n\n            lea     rcx, fmtStrx\n            mov     r8, rax\n            movzx   edx, state\n            call    printf\n\n; Demonstrate state 1:\n\n            lea     rcx, fmtStr1\n            movzx   rdx, state\n            call    printf\n\n            mov     eax, 50\n            mov     ecx, 60\n            call    StateMachine\n\n            lea     rcx, fmtStrx\n            mov     r8, rax\n            movzx   edx, state\n            call    printf\n\n; Demonstrate state 2:\n\n            lea     rcx, fmtStr2\n            movzx   rdx, state\n            call    printf\n\n            mov     eax, 10\n            mov     ecx, 20\n            call    StateMachine\n\n            lea     rcx, fmtStrx\n            mov     r8, rax\n            movzx   edx, state\n            call    printf\n\n; Demonstrate state 3:\n\n            lea     rcx, fmtStr3\n            movzx   rdx, state\n            call    printf\n\n            mov     eax, 50\n            mov     ecx, 5\n            call    StateMachine\n\n            lea     rcx, fmtStrx\n            mov     r8, rax\n            movzx   edx, state\n            call    printf\n\n; Demonstrate back in state 0:\n\n            lea     rcx, fmtStr0b\n            movzx   rdx, state\n            call    printf\n\n            mov     eax, 1\n            mov     ecx, 2\n            call    StateMachine\n\n            lea     rcx, fmtStrx\n            mov     r8, rax\n            movzx   edx, state\n            call    printf\n\n            leave\n            ret     ; Returns to caller\n\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing7-6**\n\nC:\\>**echo off**\n Assembling: listing7-6.asm\nc.cpp\n\nC:\\>**listing7-6**\nCalling Listing 7-6:\nCalling StateMachine, state=0, EAX=5, ECX=6\nBack from StateMachine, state=1, EAX=11\nCalling StateMachine, state=1, EAX=50, ECX=60\nBack from StateMachine, state=2, EAX=-10\nCalling StateMachine, state=2, EAX=10, ECX=20\nBack from StateMachine, state=3, EAX=200\nCalling StateMachine, state=3, EAX=50, ECX=5\nBack from StateMachine, state=0, EAX=10\nCalling StateMachine, state=0, EAX=1, ECX=2\nBack from StateMachine, state=1, EAX=3\nListing 7-6 terminated\n```", "```\n; Listing 7-7\n\n; An indirect jump state machine example.\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 7-7\", 0\nfmtStr0     byte    \"Calling StateMachine, \"\n            byte    \"state=0, EAX=5, ECX=6\", nl, 0\n\nfmtStr0b    byte    \"Calling StateMachine, \"\n            byte    \"state=0, EAX=1, ECX=2\", nl, 0\n\nfmtStrx     byte    \"Back from StateMachine, \"\n            byte    \"EAX=%d\", nl, 0\n\nfmtStr1     byte    \"Calling StateMachine, \"\n            byte    \"state=1, EAX=50, ECX=60\", nl, 0\n\nfmtStr2     byte    \"Calling StateMachine, \"\n            byte    \"state=2, EAX=10, ECX=20\", nl, 0\n\nfmtStr3     byte    \"Calling StateMachine, \"\n            byte    \"state=3, EAX=50, ECX=5\", nl, 0\n\n             .data\nstate        qword  state0\n\n            .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\n; StateMachine version 2.0 - using an indirect jump.\n\n             option noscoped     ; state`x` labels must be global\nStateMachine proc\n\n             jmp    state\n\n; State 0: Add ECX to EAX and switch to state 1:\n\nstate0:      add    eax, ecx\n             lea    rcx, state1\n             mov    state, rcx\n             ret\n\n; State 1: Subtract ECX from EAX and switch to state 2:\n\nstate1:      sub    eax, ecx\n             lea    rcx, state2\n             mov    state, rcx\n             ret\n\n; If this is state 2, multiply ECX by EAX and switch to state 3:\n\nstate2:      imul   eax, ecx\n             lea    rcx, state3\n             mov    state, rcx\n             ret\n\nstate3:      push   rdx          ; Preserve this 'cause it \n                                 ; gets whacked by div\n             xor    edx, edx     ; Zero-extend EAX into EDX\n             div    ecx\n             pop    rdx          ; Restore EDX's value preserved above\n             lea    rcx, state0\n             mov    state, rcx\n             ret\n\nStateMachine endp\n             option scoped\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 48         ; Shadow storage\n\n            lea     rcx, state0\n            mov     state, rcx      ; Just to be safe\n\n; Demonstrate state 0:\n\n            lea     rcx, fmtStr0\n            call    printf\n\n            mov     eax, 5\n            mov     ecx, 6\n            call    StateMachine\n\n            lea     rcx, fmtStrx\n            mov     rdx, rax\n            call    printf\n\n; Demonstrate state 1:\n\n            lea     rcx, fmtStr1\n            call    printf\n\n            mov     eax, 50\n            mov     ecx, 60\n            call    StateMachine\n\n            lea     rcx, fmtStrx\n            mov     rdx, rax\n            call    printf\n\n; Demonstrate state 2:\n\n            lea     rcx, fmtStr2\n            call    printf\n\n            mov     eax, 10\n            mov     ecx, 20\n            call    StateMachine\n\n            lea     rcx, fmtStrx\n            mov     rdx, rax\n            call    printf\n\n; Demonstrate state 3:\n\n            lea     rcx, fmtStr3\n            call    printf\n\n            mov     eax, 50\n            mov     ecx, 5\n            call    StateMachine\n\n            lea     rcx, fmtStrx\n            mov     rdx, rax\n            call    printf\n\n; Demonstrate back in state 0:\n\n            lea     rcx, fmtStr0b\n            call    printf\n\n            mov     eax, 1\n            mov     ecx, 2\n            call    StateMachine\n\n            lea     rcx, fmtStrx\n            mov     rdx, rax\n            call    printf\n\n            leave\n            ret     ; Returns to caller\n\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing7-7**\n\nC:\\>**echo off**\n Assembling: listing7-7.asm\nc.cpp\n\nC:\\>**listing7-7**\nCalling Listing 7-7:\nCalling StateMachine, state=0, EAX=5, ECX=6\nBack from StateMachine, EAX=11\nCalling StateMachine, state=1, EAX=50, ECX=60\nBack from StateMachine, EAX=-10\nCalling StateMachine, state=2, EAX=10, ECX=20\nBack from StateMachine, EAX=200\nCalling StateMachine, state=3, EAX=50, ECX=5\nBack from StateMachine, EAX=10\nCalling StateMachine, state=0, EAX=1, ECX=2\nBack from StateMachine, EAX=3\nListing 7-7 terminated\n```", "```\nwhile(`expression`) `statement(s)`;\n```", "```\ni = 0;\nwhile(i < 100)\n{\n    ++i;\n}\n```", "```\ni = 0;\nWhileLp:\nif(i < 100)\n{\n\n    ++i;\n      goto WhileLp;\n\n}\n```", "```\n`Optional initialization code`\n\nUniqueLabel:\nif(`not_termination_condition`)\n{\n `Loop body`\n    goto UniqueLabel;\n\n}\n```", "```\n mov i, 0\nWhileLp:\n          cmp i, 100\n          jnl WhileDone\n          inc i\n          jmp WhileLp;\n\nWhileDone:\n```", "```\n`Optional initialization code`\nrepeat\n\n `Loop body`\n\nuntil(`termination_condition`);\n```", "```\n`Optional initialization code`\ndo\n{\n `Loop body`\n\n}while(`not_termination_condition`);\n```", "```\n`Initialization code`\nSomeUniqueLabel:\n\n `Loop body`\n\nif(`not_termination_condition`) goto SomeUniqueLabel;\n```", "```\n repeat (`Pascal code`)\n\n          write('Enter a number greater than 100:');\n          readln(i);\n\n     until(i > 100);\n\n// This translates to the following if/jmp code:\n\n     RepeatLabel:\n\n          write('Enter a number greater than 100:');\n          readln(`i`);\n\n     if(`i` <= 100) then goto RepeatLabel;\n\n// It also translates into the following assembly code:\n\nRepeatLabel:\n\n call print\n          byte \"Enter a number greater than 100: \", 0\n          call readInt  ; Function to read integer from user\n\n          cmp  eax, 100 ; Assume readInt returns integer in EAX\n          jng  RepeatLabel\n```", "```\nfor(;;)\n{\n `Loop body`\n\n}\n```", "```\nfor(;;)\n{\n     cin >> `character`;\n     if(`character` == '.') break;\n     cout `<< character`;\n\n}\n```", "```\nforeverLabel:\n\n          call getchar    ; Assume it returns char in AL\n          cmp  al, '.'\n          je   ForIsDone\n\n          mov  cl, al     ; Pass char read from getchar to putchar\n          call putcchar   ; Assume this prints the char in CL\n          jmp  foreverLabel\n\nForIsDone:\n```", "```\nfor(`initialization_Stmt`; `termination_expression`; `inc_Stmt`)\n{\n `Statements`\n\n}\n```", "```\n`initialization_Stmt`;\nwhile(`termination_expression`)\n{\n `Statements` \n\n    inc_Stmt;\n\n}\n```", "```\nfor(i = 0; i < 7; ++i)\n{\n     printf(\"Array Element = %d \\ n\", SomeArray[i]);\n\n}\n```", "```\ni = 0;\nwhile(i < 7)\n{\n    printf(\"Array Element = %d \\ n\", SomeArray[i]);\n    ++i;\n}\n```", "```\n xor  rbx, rbx      ; Use RBX to hold loop index\nWhileLp:  cmp  ebx, 7\n          jnl  EndWhileLp\n\n          lea  rcx, fmtStr   ; fmtStr = \"Array Element = %d\", nl, 0\n          lea  rdx, SomeArray\n mov  rdx, [rdx][rbx * 4] ; Assume SomeArray is 4-byte ints\n          call printf\n\n          inc  rbx\n          jmp  WhileLp;\n\nEndWhileLp:\n```", "```\n// Breaking out of a FOR(;;) loop:\n\nfor(;;)\n{\n `Stmts`\n          // break;\n          goto BreakFromForever;\n `Stmts`\n}\nBreakFromForever:\n\n// Breaking out of a FOR loop:\n\nfor(initStmt; expr; incStmt)\n{\n `Stmts`\n          // break;\n          goto BrkFromFor;\n `Stmts`\n}\nBrkFromFor:\n\n// Breaking out of a WHILE loop:\n\nwhile(expr)\n{\n `Stmts`\n          // break;\n          goto BrkFromWhile;\n `Stmts`\n}\nBrkFromWhile:\n\n// Breaking out of a REPEAT/UNTIL loop (DO/WHILE is similar):\n\nrepeat\n `Stmts`\n          // break;\n          goto BrkFromRpt;\n `Stmts`\nuntil(expr);\nBrkFromRpt:\n```", "```\n; Conversion of FOREVER loop with continue\n; to pure assembly:\n for(;;)\n {\n `Stmts`\n      continue;\n `Stmts`\n }\n\n; Converted code:\n\nforeverLbl:\n `Stmts`\n          ; continue;\n          jmp foreverLbl\n `Stmts`\n     jmp foreverLbl\n```", "```\n; Conversion of WHILE loop with continue\n; into pure assembly:\n\n while(expr)\n {\n `Stmts`\n      continue;\n `Stmts`\n }\n\n; Converted code:\n\nwhlLabel:\n `Code to evaluate expr`\n     jcc EndOfWhile    ; Skip loop on expr failure\n `Stmts`\n          ; continue;\n          jmp whlLabel ; Jump to start of loop on continue\n `Stmts`\n     jmp whlLabel      ; Repeat the code\nEndOfWhile:\n```", "```\n; Conversion for a FOR loop with continue\n; into pure assembly:\n\n for(initStmt; expr; incStmt)\n {\n `Stmts`\n     continue;\n `Stmts`\n }\n\n; Converted code:\n\n `initStmt`\nForLpLbl:\n `Code to evaluate expr`\n          jcc EndOfFor     ; Branch if expression fails\n `Stmts`\n\n          ; continue;\n          jmp ContFor      ; Branch to incStmt on continue\n\n `Stmts`\n\nContFor:\n `incStmt`\n          jmp ForLpLbl\n\nEndOfFor:\n```", "```\n repeat\n      ` Stmts`\n      continue;\n      ` Stmts`\n until(expr);\n\n do\n {\n      ` Stmts`\n      continue;\n      ` Stmts`\n\n }while(!expr);\n\n; Converted code:\n\nRptLpLbl:\n     ` Stmts`\n          ; continue;\n          jmp ContRpt  ; Continue branches to termination test\n          ` Stmts`\nContRpt:\n     ` Code to test expr`\n     j`cc` RptLpLbl      ; Jumps if expression evaluates false\n```", "```\n mov cx, 8\nloop1:    \n          mov cx, 4\nloop2:\n `Stmts`\n          dec cx\n          jnz loop2\n\n          dec cx\n          jnz loop1\n```", "```\n mov cx, 8\nloop1:\n          push rcx\n          mov  cx, 4\nloop2:\n `Stmts`\n          dec cx\n          jnz loop2;\n\n          pop rcx\n          dec cx\n          jnz loop1\nor\n          mov dx,8\nloop1:\n          mov cx, 4\nloop2:\n `Stmts`\n          dec cx\n          jnz loop2\n\n          dec dx\n          jnz loop1\n```", "```\nREPEAT/UNTIL loop:\n     Initialization code\n          Loop body\n     Test for termination\n     Code following the loop\n\nWHILE loop:\n     Initialization code\n     Loop-termination test\n          Loop body\n          Jump back to test\n     Code following the loop\n\nFOREVER/ENDFOR loop:\n     Initialization code\n          Loop body part one\n          Loop-termination test\n          Loop body part two\n          Jump back to Loop body part one\n     Code following the loop\n```", "```\n; Example involving a WHILE loop:\n\n         mov  esi, edi\n         sub  esi, 20\n\n; while(ESI <= EDI)\n\nwhileLp: cmp  esi, edi\n         jnle endwhile\n\n `Stmts`\n\n         inc  esi\n         jmp  whileLp\nendwhile:\n\n; Example involving a REPEAT/UNTIL loop:\n\n         mov esi, edi\n         sub esi, 20\nrepeatLp:\n\n `Stmts`\n\n         inc  esi\n         cmp  esi, edi\n         jng  repeatLp\n```", "```\nwhile(esi <= edi)\n{\n `Stmts`\n    ++esi;\n}\n```", "```\n jmp WhlTest\nTopOfLoop:\n `Stmts`\n          inc  esi \nWhlTest:  cmp  esi, edi\n          jle TopOfLoop\n```", "```\nfor(j = 1; j <= 8; ++j)\n{\n `Stmts`\n}\n\n; Conversion to pure assembly (as well as using a\n; REPEAT/UNTIL form):\n\nmov j, 1\nForLp:\n `Stmts`\n     inc j\n     cmp j, 8\n     jle ForLp\n```", "```\n mov j, 8\nLoopLbl:\n `Stmts`\n     dec j\n     jnz LoopLbl\n```", "```\n mov j, 7\nLoopLbl:\n `Stmts`\n     dec j\n     jns LoopLbl\n```", "```\nfor(i = 0; i < n; ++i)\n{\n    k = (j - 2) + i\n}\n```", "```\njm2 = j - 2;\nfor(i = 0; i < n; ++i)\n{\n    k = jm2 + i;\n}\n```", "```\nk = (j - 2) * n;\nfor(i = 0; i < n; ++i)\n{\n    k = k + i;\n}\n```", "```\n mov  eax, j\n      sub  eax, 2\n      imul eax, n\n      mov  ecx, 0\nlp:   cmp  ecx, n\n      jnl  loopDone\n      add  eax, ecx   ; Single instruction implements loop body!\n      inc  ecx\n      jmp  lp\nloopDone:\n      mov  k, eax\n```", "```\n for i := 3 downto 0 do A[i] := 0;\n\n          mov i, 3\n          lea rcx, A\nLoopLbl:\n          mov ebx, i\n          mov [rcx][rbx * 4], 0\n          dec i\n          jns LoopLbl\n```", "```` While we could make many improvements to this loop based on the information presented thus far, consider carefully exactly what this loop is doing—it’s storing four 0s into `A[0]` through `A[3]`. A more efficient approach is to use four `mov` instructions to accomplish the same task. For example, if `A` is an array of double words, the following code initializes `A` much faster than the preceding code:    ``` mov  A[0], 0 mov  A[4], 0 mov  A[8], 0 mov  A[12], 0 ```    Although this is a simple example, it shows the benefit of *loop unraveling* (also known as *loop* *unrolling*). If this simple loop appeared buried inside a set of nested loops, the 4:1 instruction reduction could possibly double the performance of that section of your program.    Of course, you cannot unravel all loops. Loops that execute a variable number of times are difficult to unravel because there is rarely a way to determine at assembly time the number of loop iterations. Therefore, unraveling a loop is a process best applied to loops that execute a known number of times, with the number of times known at assembly time.    Even if you repeat a loop a fixed number of iterations, it may not be a good candidate for loop unraveling. Loop unraveling produces impressive performance improvements when the number of instructions controlling the loop (and handling other overhead operations) represents a significant percentage of the total number of instructions in the loop. Had the previous loop contained 36 instructions in the body (exclusive of the four overhead instructions), the performance improvement would be, at best, only 10 percent (compared with the 300 to 400 percent it now enjoys).    Therefore, the costs of unraveling a loop—all the extra code that must be inserted into your program—quickly reach a point of diminishing returns as the body of the loop grows larger or as the number of iterations increases. Furthermore, entering that code into your program can become quite a chore. Therefore, loop unraveling is a technique best applied to small loops.    Note that the superscalar 80x86 chips (Pentium and later) have *branch-prediction hardware* and use other techniques to improve performance. Loop unrolling on such systems may actually *slow* the code because these processors are optimized to execute short loops. Whenever applying “improvements” to speed up your code, you should always measure the performance before and after to ensure there was sufficient gain to justify the change.    ### 7.9.5 Using Induction Variables    Consider the following Pascal loop:    ``` for i := 0 to 255 do csetVar[i] := []; ```    Here the program is initializing each element of an array of character sets to the empty set. The straightforward code to achieve this is the following:    ```  mov  i, 0      lea  rcx, csetVar FLp:       ; Compute the index into the array (assume that each      ; element of a csetVar array contains 16 bytes).       mov  ebx, i  ; Zero-extends into RBX!      shl  ebx, 4       ; Set this element to the empty set (all 0 bits).       xor  rax, rax      mov  qword ptr [rcx][rbx], rax      mov  qword ptr [rcx][rbx + 8], rax       inc  i      cmp  i, 256      jb   FLp; ```    Although unraveling this code will still improve performance, it will take 1024 instructions to accomplish this task, too many for all but the most time-critical applications. However, you can reduce the execution time of the body of the loop by using induction variables. An *induction variable* is one whose value depends entirely on the value of another variable.    In the preceding example, the index into the array `csetVar` tracks the loop-control variable (it’s always equal to the value of the loop-control variable times 16). Because `i` doesn’t appear anywhere else in the loop, there is no sense in performing the computations on `i`. Why not operate directly on the array index value? The following code demonstrates this technique:    ```  xor  rbx, rbx     ; i * 16 in RBX      xor  rax, rax     ; Loop invariant      lea  rcx, csetVar ; Base address of csetVar array FLp:      mov  qword ptr [rcx][rbx], rax      mov  qword ptr [rcx][rbx + 8], rax       add  ebx, 16      cmp  ebx, 256 * 16      jb   FLp ;    mov  ebx, 256    ; If you care to maintain same semantics as C code ```    The induction that takes place in this example occurs when the code increments the loop-control variable (moved into EBX for efficiency) by 16 on each iteration of the loop rather than by 1\\. Multiplying the loop-control variable by 16 (and the final loop-termination constant value) allows the code to eliminate multiplying the loop-control variable by 16 on each iteration of the loop (that is, this allows us to remove the `shl` instruction from the previous code). Further, because this code no longer refers to the original loop-control variable (`i`), the code can maintain the loop-control variable strictly in the EBX register.    ## 7.10 For More Information    *Write Great Code*, Volume 2, by this author (Second Edition, No Starch Press, 2020) provides a good discussion of the implementation of various HLL control structures in low-level assembly language. It also discusses optimizations such as induction, unrolling, strength reduction, and so on, that apply to optimizing loops.    ## 7.11 Test Yourself    1.  What are the two typical mechanisms for obtaining the address of a label appearing in a program? 2.  What statement can you use to make all symbols global that appear within a procedure? 3.  What statement can you use to make all symbols local that appear within a procedure? 4.  What are the two forms of the indirect `jmp` instruction? 5.  What is a state machine? 6.  What is the general rule for converting a branch to its opposite branch? 7.  What are the two exceptions to the rule for converting a branch to its opposite branch? 8.  What is a trampoline? 9.  What is the general syntax of the conditional move instruction? 10.  What is the advantage of a conditional move instruction over a conditional jump? 11.  What are some disadvantages of conditional moves? 12.  Explain the difference between short-circuit and complete Boolean evaluation. 13.  Convert the following `if` statements to assembly language sequences by using complete Boolean evaluation (assume all variables are unsigned 32-bit integer values):          ```     if(x == y || z > t)     {      `Do something`     }          if(x != y && z < t)     {      `THEN statements`     }     else     {      `ELSE statements`     }     ```           14.  Convert the preceding statements to assembly language by using short-circuit Boolean evaluation (assume all variables are signed 16-bit integer values). 15.  Convert the following `switch` statements to assembly language (assume all variables are unsigned 32-bit integers):          ```     switch(s)     {        case 0:  ` case 0 code ` break;        case 1:  ` case 1 code ` break;        case 2:  ` case 2 code ` break;        case 3:  ` case 3 code ` break;     }          switch(t)     {        case 2:  ` case 0 code ` break;        case 4:  ` case 4 code ` break;        case 5:  ` case 5 code ` break;        case 6:  ` case 6 code ` break;        default:  `Default code`     }          switch(u)     {        case 10:  ` case 10 code ` break;        case 11:  ` case 11 code ` break;        case 12:  ` case 12 code ` break;        case 25:  ` case 25 code ` break;        case 26:  ` case 26 code ` break;        case 27:  ` case 27 code ` break;        default:   `Default code`     }     ```           16.  Convert the following `while` loops to assembly code (assume all variables are signed 32-bit integers):          ```     while(i < j)     {         `Code for loop body`     }          while(i < j && k != 0)     {         ` Code for loop body, part a`         if(m == 5) continue;         ` Code for loop body, part b`         if(n < 6) break;         ` Code for loop body, part c`     }          do     {        `Code for loop body`     } while(i != j);          do     {         ` Code for loop body, part a`         if(m != 5) continue;         ` Code for loop body, part b`         if(n == 6) break;      `Code for loop body, part c`     } while(i < j && k > j);          for(int i = 0; i < 10; ++i)     {        `Code for loop body`     }     ``` ````"]