<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch5">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_63" aria-label="63"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch5">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">5</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">DESIGNING ALGORITHMS</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">This chapter covers several techniques for designing algorithms. We’ll start with recursion, which solves a problem by breaking it up into one or more simpler cases of the same problem. We’ll also look at <i>dynamic programming</i>, which solves a complex problem by solving simpler cases first and storing those solutions to avoid needless recalculations, as well as the <i>brute-force</i> (or <i>exhaustive</i>) <i>search</i> strategy, where you find a solution to a problem by systematically trying all possible solutions. Finally, we’ll explore <i>greedy algorithms</i> that apply a heuristic of choosing the best local option at each junction of a problem, with the hope that the given methodology will lead to the</p>&#13;
<p class="TNI1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_64" aria-label="64"/>solution. Unlike the other strategies mentioned in this list, greedy algorithms may not always arrive at the best solution.</p>&#13;
<p class="TX">The strategies explored here are successfully applied to develop algorithms used along with data structures for the implementation of specific abstract data types (ADTs), so focusing on how to design a new solution for any given problem is worthwhile. The techniques covered in this chapter aren’t exhaustive, but they lie below the surface in many of the algorithms that we’ll explore later.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-19"/><span class="SANS_Futura_Std_Bold_B_11">Recursion</span></h3>&#13;
<p class="TNI1">The simplest definition of recursion goes something like this: “A function calls itself over and over, again and again, until it doesn’t<i>.</i>” In other words, when facing a problem, if it’s small enough, it can be solved without any further recursive calls, but if it isn’t, the function calls itself to solve smaller problems, and out of those solutions, it finds the solution for the original, larger problem.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>For a bit of computer humor, here’s a dictionary definition: “recursion: (n) see recursion.” A common saying is also “In order to understand recursion, you must first understand recursion.”</i></p>&#13;
<p class="TX">As discussed in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, recursion is a key technique in functional programming. Some languages, like Haskell, for instance, don’t even provide common “loops” and instead work exclusively with recursion. In computer science, recursion is all-sufficient for any algorithm, and anything you can do with loops you can also do with recursion. In fact, using recursion is much easier for many algorithms and definitions.</p>&#13;
<p class="TX">Recursion appears naturally in several areas:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><b>Mathematics </b>Definitions such as the factorial of a number or the Fibonacci series are naturally recursive. We’ll explore both later in this chapter.</p>&#13;
<p class="RunInPara"><b>Data structures </b>Many structures are defined in a recursive fashion. For example, as you’ll see in <span class="runinpara_Xref"><a href="chapter10.xhtml">Chapter 10</a></span>, a <i>list</i> may either be empty or consist of a special node, the head of the list, followed by another list; another example from <span class="runinpara_Xref"><a href="chapter13.xhtml">Chapter 13</a></span> may be a <i>tree</i>, consisting of a parent node called the <i>root</i>, connected to any number of trees as its children.</p>&#13;
<p class="RunInPara"><b>Procedures </b>Several algorithms can be expressed logically in a recursive fashion. An example from everyday life is searching your house for an object. You first look in one room, and if you find the object, you’re done; if you don’t find it, you search the rest of the place, applying the same logic. If you have nowhere left to search, you failed.</p>&#13;
</div>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_65" aria-label="65"/>A recursive function always has two kinds of cases: simple ones that can be solved directly without any recursion and complex ones that need to use the function itself as an aid. The key to solving something recursively is to assume that the problem has already been solved and then code it using the (supposedly) available function. It’s a four-step procedure—which may seem to be circular:</p>&#13;
<p class="ListNumberF">	1.	Assume you already have a function that solves your problem.</p>&#13;
<p class="ListNumber">	2.	Find some simple base cases that you can solve directly without any complications.</p>&#13;
<p class="ListNumber">	3.	Figure out how you can solve the original problem by first solving one or more smaller versions of it.</p>&#13;
<p class="ListNumberL">	4.	Apply your assumed function from step 1 to solve the minor problems of step 3, or if they are small enough, solve them as in step 2.</p>&#13;
<p class="TX">Let’s look at a couple of recursion techniques to show how to design clear, simple-to-understand algorithms.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-30"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">The Divide-and-Conquer Strategy</span></h4>&#13;
<p class="TNI1">As mentioned, the basic idea in recursion is to base the solution of complex cases on the solution of simpler ones. You <i>divide</i> the problem into smaller versions of itself, and <i>conquer</i> it using the solutions to all of them. Often you’ll solve a problem by recursively solving an “only one smaller” version, and that strategy gets its own name, <i>decrease-and-conquer,</i> but it’s still the same idea: reduce the original problem to smaller versions of itself. The only difference is that you solve the big problem by just solving <i>one</i> (smaller) version first. We’ll start with a look at some simpler decrease-and-conquer examples and then move on to the divide-and-conquer strategy.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h5 class="H3" id="sec3"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Calculating Factorials</span></h5>&#13;
<p class="TNI1">The most often quoted example of a recursive calculation is likely the factorial of a number, <i>n</i>!, which is an example of the decrease-and-conquer strategy. The factorial of a non-negative integer number <i>n</i> is defined as follows: for <i>n</i> = 0, 0! = 1, and for <i>n</i> &gt; 0, <i>n</i>! = <i>n</i> × (<i>n</i> – 1)!, which is the recursive definition.</p>&#13;
<p class="TX">This formula comes from a recursive problem; namely, how many ways can you order <i>n</i> books in a row on a shelf? The answer is simple: if no books are on the shelf, there’s only one way—an empty shelf. However, if you have <i>n</i> &gt; 0 books, you can choose any one of them (there are <i>n</i> options), place it at the leftmost empty space on the shelf, and then place the (<i>n</i> – 1) other books in all possible permutations to the right of the book you just placed, which is <i>n</i>! = <i>n</i> × (<i>n</i> – 1)! as just described: <i>n</i> ways of choosing the first book multiplied by (<i>n</i> – 1)! ways of ordering the rest.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_66" aria-label="66"/>A quick implementation of the factorial (see also question 5.1) is as follows:</p>&#13;
<pre id="pre-58"><code>const factorial = (n) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (n === 0) {&#13;
   return 1;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else {&#13;
   return n * factorial(n - 1);&#13;
 }&#13;
};</code></pre>&#13;
<p class="TX">This code closely follows the definition, with two clear cases: if <i>n</i> is 0 <span class="CodeAnnotation" aria-label="annotation1">❶</span>, return 1, and for greater values of <i>n</i> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, use recursion. It’s hard to go wrong with a recursive implementation, because the logic matches the definition closely.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h5 class="H3" id="sec4"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Searching and Traversing</span></h5>&#13;
<p class="TNI1">Let’s look at a few other decrease-and-conquer examples using searching and traversing. In <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a>,</span> we mentioned binary search, which is a way of searching an ordered array. If the array is empty, you’re out of luck; the value you want isn’t there. If the array isn’t empty, check its middle element, and if it’s what you want, you succeed. If the element doesn’t match and is higher than the value you want, search recursively in the left half of the array; otherwise, search its right half.</p>&#13;
<p class="TX">As another example, think about sorting a deck of cards. If the deck is empty, you’re done. Otherwise, you go through the deck looking for the lowest card and remove it from the deck. Then, you sort the rest of the deck and put it on top of the card you put aside.</p>&#13;
<p class="TX">Finally, let’s consider going through a list of pending tasks. (This is called a <i>traversal</i> of the list.) If the list is empty, you’ve got nothing to do; you’re finished. Otherwise, you take the top task from the list, do it, and then recursively go through the remaining tasks.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h5 class="H3" id="sec5"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Considering the Fibonacci Series</span></h5>&#13;
<p class="TNI1">For a mathematical divide-and-conquer example, consider the Fibonacci series. This series starts with 0 and 1, and after that, each item is the sum of the two previous ones, so the series goes 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, and so on. (You’ll meet a Fibonacci-based structure in <span class="Xref"><a href="chapter15.xhtml">Chapter 15</a></span>, and the usage of the series even applies to estimating the complexity of tasks in agile methodologies, so it’s certainly pervasive.)</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>For curious readers, this series was named after an Italian mathematician, Leonardo of Pisa, also known as Fibonacci (“filius Bonacci,” or “son of Bonacci”), who is also famous for having introduced Arabic numbers to the Western world. Fibonacci posed (and solved) a question involving the growth of an idealized population of rabbits, but the sequence had already appeared in many other contexts, such as counting patterns of verse.</i></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_67" aria-label="67"/>In order to implement the series recursively, you need to give a proper definition, and that’s not hard: you can say that F<sub>0</sub> = 0, F<sub>1</sub> = 1, and for <i>n</i> &gt; 1, F<sub><i>n</i></sub> = F<sub><i>n</i></sub><sub>–1</sub> + F<sub><i>n</i></sub><sub>–2</sub>. Given this definition, here’s the code:</p>&#13;
<pre id="pre-59"><code>const fibo = (n) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (n === 0) {&#13;
   return 0;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else if (n === 1) {&#13;
   return 1;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else {&#13;
   return fibo(n - 1) + fibo(n - 2);&#13;
 }&#13;
};</code></pre>&#13;
<p class="Continued">You have two base cases for 0 <span class="CodeAnnotation" aria-label="annotation1">❶</span> and 1 <span class="CodeAnnotation" aria-label="annotation2">❷</span> and a recursive case <span class="CodeAnnotation" aria-label="annotation3">❸</span> for other values. The code is so simple, it can’t go wrong, and testing verifies it. However, it does have a performance defect, which we’ll consider when we discuss dynamic programming later in this chapter.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h5 class="H3" id="sec6"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Sorting and Puzzles</span></h5>&#13;
<p class="TNI1">Many sorting methods that we’ll explore later in this book, such as merge sort or quick sort, are expressed succinctly in a recursive fashion, but let’s look at another classic example: the Towers of Hanoi puzzle.</p>&#13;
<p class="TX">This puzzle, invented by French mathematician <span class="accent">É</span>douard Lucas in the 19th century, has three posts: the first has a stack of disks of decreasing size (largest at the bottom, smallest at the top), and the other two posts are empty. To solve the puzzle, you need to move all the disks from the first post to the last one, following two rules: you can move only the top disk from any post at a time (you can’t move two or more disks at once, and you can’t move any disks from the middle of a post), and you can move a disk to another post only if the top disk on that post is larger than the one you’re moving (a larger disk can never go on top of a smaller one). <a href="chapter5.xhtml#fig5-1">Figure 5-1</a> shows the initial setup; all disks are on the leftmost post, and the goal is to move all the disks to the rightmost post.</p>&#13;
<figure class="IMG"><img class="img7" id="fig5-1" src="../images/Figure5-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-1: Towers of Hanoi</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">How do you solve this with the divide-and-conquer strategy? You start by thinking you already have the required function, which might be <span class="SANS_TheSansMonoCd_W5Regular_11">towers(disks, origin, extra, destination)</span>, to move a certain number of <span class="SANS_TheSansMonoCd_W5Regular_11">disks</span> from the <span class="SANS_TheSansMonoCd_W5Regular_11">origin</span> post to the <span class="SANS_TheSansMonoCd_W5Regular_11">destination</span> post using the <span class="SANS_TheSansMonoCd_W5Regular_11">extra</span> post as an <span role="doc-pagebreak" epub:type="pagebreak" id="pg_68" aria-label="68"/>auxiliary, and you may use that function to implement the function itself. The base case is simple: if there are no disks to move, nothing needs to be done; otherwise, you make the moves described previously. The code could be as follows:</p>&#13;
<pre id="pre-60"><code>const towers = (disks, origin, extra, destination) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (disks &gt; 0) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> towers(disks - 1, origin, destination, extra);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> console.log(`Move disk ${disks} from ${origin} to ${destination}`);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> towers(disks - 1, extra, origin, destination);&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">You first test for the base case <span class="CodeAnnotation" aria-label="annotation1">❶</span>, because if there are no disks to move, you’re clearly done. Otherwise, recursively move all disks but the bottom one to the extra pole <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Having cleared the large disk, move it to the destination pole <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and finish by bringing the other disks on top of it <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">A call like <span class="SANS_TheSansMonoCd_W5Regular_11">towers(4, "A", "B", "C")</span> to move four disks from pole A to pole C will produce the following output:</p>&#13;
<pre id="pre-61"><code>Move disk 1 from A to B&#13;
Move disk 2 from A to C&#13;
Move disk 1 from B to C&#13;
Move disk 3 from A to B&#13;
Move disk 1 from C to A&#13;
Move disk 2 from C to B&#13;
Move disk 1 from A to B&#13;
Move disk 4 from A to C&#13;
Move disk 1 from B to C&#13;
Move disk 2 from B to A&#13;
Move disk 1 from C to A&#13;
Move disk 3 from B to C&#13;
Move disk 1 from A to B&#13;
Move disk 2 from A to C&#13;
Move disk 1 from B to C</code></pre>&#13;
<p class="TX">Using recursion to solve the simpler steps of a puzzle is a clear example of the divide-and-conquer strategy. (See question 5.2 if you ever need to do this puzzle with no computer.)</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>There’s a coda to this puzzle. In the original version, monks had to move 64 golden disks from one post to another, and the world would end as soon as they accomplished the task. (In the original puzzle, the temple was in India; who knows how it moved abroad and got to Hanoi?) For n disks, M(n) = 2</i><sup>n</sup> <i>– 1 moves are required to solve the puzzle, so it’s an algorithm of exponential order; the formula can be verified by noting that M(n) = 2M(n – 1) + 1 and M(0) = 0. At one movement per second, the achievement would require 2</i><i><sup>64</sup></i> <i>– 1 seconds, more than 584 billion years, so we’re safe!</i></p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_69" aria-label="69"/>&#13;
<h4 class="H2" id="sec7"><span id="h2-31"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">The Backtracking Technique</span></h4>&#13;
<p class="TNI1"><i>Backtracking</i> is another problem-solving technique that’s usually best implemented in a recursive way. When facing multiple options, choose one and try finding a solution with it. If you succeed, you’re done. If you fail, backtrack to the point where you made the selection and choose a different option. If at some point you run out of options, there definitely is no solution.</p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h5 class="H3" id="sec8"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Finding a Path in a</span> <span class="SANS_Futura_Std_Bold_Condensed_B_11">Maze</span></h5>&#13;
<p class="TNI1">Finding the way out of a maze (such as the one shown in <a href="chapter5.xhtml#fig5-2">Figure 5-2</a>) is a classic, ancient problem, and you’ll see it again in <span class="Xref"><a href="chapter17.xhtml">Chapter 17</a></span>, when working with graphs. It’s also the archetypical example for backtracking, so you’ll use it here. we’ll explore the full algorithms later; this is just the pseudocode.</p>&#13;
<figure class="IMG"><img class="img7" id="fig5-2" src="../images/Figure5-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-2: A maze to be solved using backtracking</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Whenever you get to a junction in the maze with two or more options available, you have to choose one, but obviously, you might end up choosing the wrong way. The idea is to follow the choice: if you get out of the maze, you succeeded, but if not, you backtrack to the last junction and select a different option. If no options are left, you’ll need to backtrack again, and again, until you either find a solution or decide there isn’t one. Here’s the pseudocode for such a recursive algorithm:</p>&#13;
<pre id="pre-62"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> solveMaze(fromCell, toCell, maze, path=[])&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if(fromCell === toCell) {&#13;
    return path // success!&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> mark fromCell as visited&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> for all nextCell cells adjacent to fromCell {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> updatedPath = solveMaze(nextCell, toCell, maze, path + fromCell)&#13;
    if updatedPath is not null {&#13;
      return path&#13;
    }&#13;
  }&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_70" aria-label="70"/>  // All adjacent cells were tried, and failed...&#13;
<span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> return null   // failure&#13;
}</code></pre>&#13;
<p class="TX">The parameters for this function <span class="CodeAnnotation" aria-label="annotation1">❶</span> are the starting point of the path, the final goal, the maze, and the path you’ll with your journey. If you reach the goal <span class="CodeAnnotation" aria-label="annotation2">❷</span>, you have succeeded; otherwise <span class="CodeAnnotation" aria-label="annotation3">❸</span>, mark the cell as visited so you don’t choose it again in the future and start trying all the available options <span class="CodeAnnotation" aria-label="annotation4">❹</span>. If a path is shown again <span class="CodeAnnotation" aria-label="annotation5">❺</span>, you’ve succeeded. When all options have been discarded <span class="CodeAnnotation" aria-label="annotation6">❻</span>, you know you have to backtrack because you’ve failed. <a href="chapter5.xhtml#fig5-3">Figure 5-3</a> shows an intermediate position in the search.</p>&#13;
<figure class="IMG"><img class="img7" id="fig5-3" src="../images/Figure5-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-3: An intermediate step when solving the</span> <span class="SANS_Futura_Std_Book_Oblique_11">maze</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">At position 1, the algorithm had two possible options; it chose the left one and failed, and then it backtracked to choose the other one. (All the cells reached from that incorrect option were left marked.) At position 2, another selection was made; in this case, it chose the option on the right, and the left wasn’t (yet) considered, so the cells in that path remain unmarked. The algorithm currently stands at 3. If it doesn’t find a way out from here, it will backtrack to 2 to try the pending option. Whether it gets from position 3 to the exit quickly depends on the algorithm’s “luck” at choosing the correct option at each junction, but in any case, the algorithm is guaranteed to find a path eventually, if there is one, by recursively backtracking.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h5 class="H3" id="sec9"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Solving the Squarest Game on the Beach Puzzle</span></h5>&#13;
<p class="TNI1">Let’s apply this technique to the Squarest Game on the Beach puzzle developed by American puzzler Sam Loyd, shown in <a href="chapter5.xhtml#fig5-4">Figure 5-4</a>. In this puzzle, the players throw balls at dolls, and if they manage to knock over dolls whose numbers add up to 50, they win a cigar. (See question 5.3 for a similar puzzle you can also solve with backtracking.)</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_71" aria-label="71"/>&#13;
<figure class="IMG"><img class="img5" id="fig5-4" src="../images/Figure5-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-4: Sam Lloyd’s</span> <span class="SANS_Futura_Std_Book_11">Squarest Game on the Beach</span> <span class="SANS_Futura_Std_Book_Oblique_11">puzzle (public domain)</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You can implement a recursive backtracking algorithm as follows:</p>&#13;
<pre id="pre-63"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const solve = (goal, standing, score = 0, dropped = []) =&gt; {&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation2">❷</span> if (score === goal) {&#13;
    return dropped;&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation3">❸</span>} else if (score &gt; goal || standing.length === 0) {&#13;
    return null;&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation4">❹</span> const chosen = standing[0];&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation5">❺</span> const others = standing.slice(1);&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation6">❻</span> return (&#13;
      solve(goal, others, score + chosen, [...dropped, chosen]) ||&#13;
      solve(goal, others, score, dropped)&#13;
    );&#13;
  }&#13;
};&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation7">❼</span> console.log(solve(50, [15, 9, 30, 21, 19, 3, 12, 6, 25, 27]));</code></pre>&#13;
<p class="TX">In the function <span class="CodeAnnotation" aria-label="annotation1">❶</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">goal</span> is the number of points you try to make, and <span class="SANS_TheSansMonoCd_W5Regular_11">standing</span> represents the available options, an array with the still-standing dolls. The points you have gotten so far will be held in <span class="SANS_TheSansMonoCd_W5Regular_11">score</span>, and the dolls you knock over go in the <span class="SANS_TheSansMonoCd_W5Regular_11">dropped</span> array. If you reach the goal exactly, you are finished <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">dropped</span> has the list of dolls to drop. If you exceed our goal, or if there are no more dolls to drop <span class="CodeAnnotation" aria-label="annotation3">❸</span>, you fail. Otherwise, you pick a doll <span class="CodeAnnotation" aria-label="annotation4">❹</span> (taking the first is simplest in terms of coding), remove it from future consideration <span class="CodeAnnotation" aria-label="annotation5">❺</span>, and then attempt to solve the puzzle, including the recently chosen doll. If that fails, you backtrack and try again without <span role="doc-pagebreak" epub:type="pagebreak" id="pg_72" aria-label="72"/>including that doll <span class="CodeAnnotation" aria-label="annotation6">❻</span>. To find the solution to the puzzle <span class="CodeAnnotation" aria-label="annotation7">❼</span>, call <span class="SANS_TheSansMonoCd_W5Regular_11">solve()</span> providing the goal (50) and list of doll points.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h1-20"/><span class="SANS_Futura_Std_Bold_B_11">Dynamic Programming</span></h3>&#13;
<p class="TNI1"><i>Dynamic programming (DP)</i> is a technique for solving a problem by first solving other (smaller) problems and storing those results, so they don’t need to be recalculated if they’re needed again. Dynamic programming comes in two flavors: top down, which solves the problem logically by checking whether it’s already been solved before dealing with a subproblem, and <i>bottom up</i>, which requires first looking at the smaller subproblems and then solving the original problem. In other words, with top-down DP, you try to solve the original problem directly and then recursively solve smaller problems first, and in bottom-up DP, you start with the simplest problems and move upward, solving harder problems step by step.</p>&#13;
<p class="TX">This description begs a question: What’s the best way to save previous results? We’ll look at two methods: <i>memoization</i>, based on a higher-order function in functional programming and probably best suited for top-down DP, and <i>tabulation</i>, based on arrays or matrices, which is typically best for bottom-up DP. Memoization is usually linked to recursive implementations, while tabulation is more useful for straightforward, nonrecursive solutions. The trade-off is that tabulation is probably quicker (not needing recursion) but may solve subproblems that aren’t actually needed, while memoization is slower (because of recursion) but will calculate strictly what’s needed.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-32"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Calculating Fibonacci Series with Top-Down DP</span></h4>&#13;
<p class="TNI1">Let’s return to the Fibonacci numbers discussed earlier in the chapter. Here’s the code:</p>&#13;
<pre id="pre-64"><code>const fibo = (n) =&gt; {&#13;
  if (n === 0) {&#13;
    return 0;&#13;
  } else if (n === 1) {&#13;
    return 1;&#13;
  } else {&#13;
    return fibo(n - 1) + fibo(n - 2);&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">This is a divide-and-conquer case, but as noted, that implementation has a problem, and we’ll solve it with dynamic programming. The code is clear, simple, and correct, but it can be quite slow. When experimenting with increasingly higher values of <i>n</i>, the required time to calculate the <i>n</i>th Fibonacci number grows exponentially as shown in <a href="chapter5.xhtml#fig5-5">Figure 5-5</a>. What’s happening?</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_73" aria-label="73"/>&#13;
<figure class="IMG"><img class="img7" id="fig5-5" src="../images/Figure5-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-5: The number of additions needed to calculate Fibonacci numbers recursively grows exponentially.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To understand the problem, consider the calculations involved for <span class="SANS_TheSansMonoCd_W5Regular_11">fibo(7)</span>. <a href="chapter5.xhtml#fig5-6">Figure 5-6</a> shows all the required calls.</p>&#13;
<figure class="IMG"><img class="img1" id="fig5-6" src="../images/Figure5-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-6: Required calls to calculate</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">fibo(7)</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Clearly too many calls are repeated. Calculating <span class="SANS_TheSansMonoCd_W5Regular_11">fibo(7)</span> implies summing <span class="SANS_TheSansMonoCd_W5Regular_11">fibo(6)</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">fibo(5)</span>, but the former is calculated as <span class="SANS_TheSansMonoCd_W5Regular_11">fibo(5)</span> plus <span class="SANS_TheSansMonoCd_W5Regular_11">fibo(4)</span>, so you are repeating <span class="SANS_TheSansMonoCd_W5Regular_11">fibo(5)</span>. The diagram shows that the calculation of other Fibonacci numbers implies even more repetitions; how many times are <span class="SANS_TheSansMonoCd_W5Regular_11">fibo(3)</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">fibo(2)</span> called? (See also question 5.4.) This implementation is exponential in order, so how do you solve it?</p>&#13;
<p class="TX"><i>Memoizing</i> is a functional programming technique that may be applied to any pure function (those with no side effects that always return the same results for the same arguments, as discussed in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>). The idea is that when a memoized function is called, it first checks an internal cache to see whether the calculation was already made. If so, it returns the cached value instead of redoing the calculation. If the requested value hasn’t <span role="doc-pagebreak" epub:type="pagebreak" id="pg_74" aria-label="74"/>been calculated before, the memoized function does its work, but before returning the result to the caller, it stores it in the internal cache for future reference.</p>&#13;
<p class="TX">Higher-order functions, such as <span class="SANS_TheSansMonoCd_W5Regular_11">fast-memoize</span> (from <i><a href="https://www.npmjs.com/package/fast-memoize">https://www.npmjs.com/package/fast-memoize</a></i>), are publicly available, but it’s not hard to whip up one yourself:</p>&#13;
<pre id="pre-65"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const memoize = (fn) =&gt; {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const cache = {};&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> return (...args) =&gt; {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> const strX = JSON.stringify(args);&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> return strX in cache&#13;
        <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> ? cache[strX]&#13;
        <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> : (cache[strX] = fn(...args));&#13;
    };&#13;
};</code></pre>&#13;
<p class="TX">This higher-order function <span class="CodeAnnotation" aria-label="annotation1">❶</span> receives a function as an argument and returns a new one. It uses a closure to maintain a <span class="SANS_TheSansMonoCd_W5Regular_11">cache</span> of previous calls and calculated values; you use a simple object here <span class="CodeAnnotation" aria-label="annotation2">❷</span>, but you could also use a set (see <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span> for other possible structures). The returned function <span class="CodeAnnotation" aria-label="annotation3">❸</span> first creates a string out of the arguments to the original <span class="SANS_TheSansMonoCd_W5Regular_11">fn</span> function <span class="CodeAnnotation" aria-label="annotation4">❹</span>. If that string is already used as a key in the cache <span class="CodeAnnotation" aria-label="annotation5">❺</span>, directly return the previously calculated value from it <span class="CodeAnnotation" aria-label="annotation6">❻</span>; otherwise, call the original function, store the returned value in the cache, and return it <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<p class="TX">Given <span class="SANS_TheSansMonoCd_W5Regular_11">memoize()</span>, you can speed up the calculations straightaway with a minor change, wrapping the original function:</p>&#13;
<pre id="pre-66"><code>const fibo = <b>memoize(</b>(n) =&gt; {&#13;
  ...&#13;
}<b>);</b></code></pre>&#13;
<p class="TX">If you now try something like <span class="SANS_TheSansMonoCd_W5Regular_11">fibo(100)</span>, the results will be immediate. To understand why, you’ll need <span class="SANS_TheSansMonoCd_W5Regular_11">fibo(99)</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">fibo(98)</span>, but after calculating <span class="SANS_TheSansMonoCd_W5Regular_11">fibo(99)</span>, the value of <span class="SANS_TheSansMonoCd_W5Regular_11">fibo(98)</span> will have been calculated, so it won’t be evaluated again. Each possible Fibonacci number between 0 and 100 will be calculated, but only once. The algorithm has become linear instead of exponential just by applying the dynamic programming technique of storing previously calculated values.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-33"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Line Breaking with Top-Down DP</span></h4>&#13;
<p class="TNI1">Let’s look at a practical problem you can solve by applying top-down DP: building a nice-looking web form. Say you want a web page to be able to generate multiple forms onscreen, each with different sets of fields. If you had a fixed number of forms with predetermined, fixed sets of fields, it wouldn’t be a problem. However, in this case, the number of forms grows <span role="doc-pagebreak" epub:type="pagebreak" id="pg_75" aria-label="75"/>unpredictably, and fields need to be added or removed, as well as moved around, so you need a more flexible solution. What you need is a “form creator” that takes in a list of fields in a given order and produces a suitable form as output. For instance, a part of the form to be generated might look like the one shown in <a href="chapter5.xhtml#fig5-7">Figure 5-7</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig5-7" src="../images/Figure5-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-7: An example web form</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The problem is you want a justified right margin, but the widths of the fields are inconsistent, so you’ll need to break rows and stretch some fields to make everything even. You need to be careful when deciding where to break rows and what fields to put in each row.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The TeX typesetting system implements the Knuth-Plass algorithm to determine line breaks for paragraphs so they look nice. The problem here is essentially the same, but we’ll use DP to solve it instead.</i></p>&#13;
<p class="TX">Consider five fields of widths 7, 2, 5, 3, and 6 (see <a href="chapter5.xhtml#fig5-8">Figure 5-8</a>). You need to arrange them in rows of width 10.</p>&#13;
<figure class="IMG"><img class="img5" id="fig5-8" src="../images/Figure5-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-8: Example fields with various widths</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You can’t manage with fewer than three rows, and having four or more rows results in too much wasted space (although we’ll need to quantify this concept later). You won’t add white space between fields (as TeX does between words); instead, you’ll expand the fields themselves. First decide how much empty space to leave in each row before expanding blocks or separating words. You have three possible layouts of three rows (see <a href="chapter5.xhtml#fig5-9">Figures 5-9</a>, <a href="chapter5.xhtml#fig5-10">5-10</a>, and <a href="chapter5.xhtml#fig5-11">5-11</a>; blocks in gray represent extra added white space at the end of rows; you’ll have to share that space among all blocks in the same row).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_76" aria-label="76"/>&#13;
<figure class="IMG"><img class="img5" id="fig5-9" src="../images/Figure5-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-9: Field layout 1</span></p></figcaption>&#13;
</figure>&#13;
<figure class="IMG"><img class="img5" id="fig5-10" src="../images/Figure5-10.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-10: Field layout 2</span></p></figcaption>&#13;
</figure>&#13;
<figure class="IMG"><img class="img5" id="fig5-11" src="../images/Figure5-11.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-11: Field layout 3</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">What solution is best? Assuming that adding smaller spaces in many rows is better than adding larger spaces in fewer rows, consider the “row cost” to be the square of the added white space for that row, and the total cost will be the sum of all the row costs. (To better understand why squaring is used, imagine you need to add two spaces; putting all of them on the same line would cost 2<sup>2</sup> = 4, but placing one space in each of two lines would cost 1<sup>2</sup> + 1<sup>2</sup> = 2, so squaring the costs before adding them implements a policy that favors smaller spaces.) Given this definition, the cost of the layouts would be 1<sup>2</sup> + 2<sup>2</sup> + 4<sup>2</sup> = 21, 3<sup>2</sup> + 0<sup>2</sup> + 4<sup>2</sup> = 25, and 3<sup>2</sup> + 3<sup>2</sup> + 1<sup>2</sup> = 19, so the third diagram represents the design the algorithm should produce. Let’s program it.</p>&#13;
<p class="TX">Consider a list of block widths (which in this case would be 7, 2, 5, 3, and 6) and a maximum width (MW) to achieve. The following logic would work: calculate the sum <i>s</i> of all widths, and if <i>s</i> is not greater than MW, the cost is (MW – <i>s</i>)<sup>2</sup>. You can’t make it better by splitting the list into two or more rows. Otherwise, if you have more fields than you can fit in a single row, you can try splitting the list into two fragments in all possible ways and then choose the split that produces the lowest cost.</p>&#13;
<p class="TX">The following logic does that, but it leaves out the code to distribute white space among the fields in a row, since that’s only needed later. This code finds the cost of the best set of line breaks and where those breaks should be made:</p>&#13;
<pre id="pre-67"><code>const costOfFragment = (p, q) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const s = totalWidth(p, q);&#13;
  if (s &lt;= MW) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> return [(MW - s) ** 2, [q]];&#13;
  }&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_77" aria-label="77"/><span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> let optimum = Infinity;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> let split = [];&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> for (let r = p; r &lt; q; r++) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> const left = costOfFragment(p, r);&#13;
    const right = costOfFragment(r + 1, q);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> const newTry = left[0] + right[0];&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> if (newTry &lt; optimum) {&#13;
      optimum = newTry;&#13;
      split = [r, . . .right[1]];&#13;
    }&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation9">❾</span> return [optimum, split];&#13;
};</code></pre>&#13;
<p class="TX">The function finds the best split for a set of blocks from <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> through <span class="SANS_TheSansMonoCd_W5Regular_11">q</span>, inclusive, and also returns the list of splits to be made. Assume we have a <span class="SANS_TheSansMonoCd_W5Regular_11">totalWidth(x,y)</span> function that calculates the width of blocks <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> through <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> (you’ll see how to best implement it later). First calculate the width of the whole list of blocks <span class="CodeAnnotation" aria-label="annotation1">❶</span>; if it’s less than the available space, you won’t need any splits and you are done. Calculate the cost per the definition and return that a split is done after the <span class="SANS_TheSansMonoCd_W5Regular_11">q</span> position <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If you need a split, set up a search; <span class="SANS_TheSansMonoCd_W5Regular_11">optimum</span> will be the best possible cost <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">split</span> will be the place to split the list <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Loop through all possible breaks <span class="CodeAnnotation" aria-label="annotation5">❺</span> and find the costs of fragments <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> through <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> and fragments <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> through <span class="SANS_TheSansMonoCd_W5Regular_11">q</span> <span class="CodeAnnotation" aria-label="annotation6">❻</span>. The cost of each split is stored <span class="CodeAnnotation" aria-label="annotation7">❼</span>, and if it’s better than the previous <span class="SANS_TheSansMonoCd_W5Regular_11">optimum</span> <span class="CodeAnnotation" aria-label="annotation8">❽</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> is preferred as the new split. The end result <span class="CodeAnnotation" aria-label="annotation9">❾</span> is the best cost found, together with the list of split points.</p>&#13;
<p class="TX"><a href="chapter5.xhtml#fig5-12">Figure 5-12</a> shows how this algorithm would deal with your list of blocks.</p>&#13;
<figure class="IMG"><img class="img1" id="fig5-12" src="../images/Figure5-12.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-12: All the possible splits evaluated by the algorithm</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Calculating costs, <a href="chapter5.xhtml#fig5-13">Figure 5-13</a> shows the optimum solution.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_78" aria-label="78"/>&#13;
<figure class="IMG"><img class="img1" id="fig5-13" src="../images/Figure5-13.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-13: The optimum solution</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The cost is shown underneath each block. If a block is split into several blocks, its cost is the sum of the costs of its parts. The highlighted path shows how to achieve the optimum solution: leave 7 on its own in the first row, place 2 and 5 in the second row, and place 3 and 6 in the last row, for a total cost of 19. Running the algorithm produces the following result:</p>&#13;
<pre id="pre-68"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const blocks = [7, 2, 5, 3, 6];&#13;
const costOfFragment = ...&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const result = costOfFragment(0, blocks.length - 1);&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> console.log(result[0], result[1]);&#13;
// 19 [0, 2, 4]</code></pre>&#13;
<p class="TX">You can define the list of block widths <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and using <span class="SANS_TheSansMonoCd_W5Regular_11">costOfFragment(...)</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span> produces the result: the best total cost is 19, and you split lines at positions 0 (just the 7), 2 (the 2 and the 5), and 4 (the 3 and the 6) as expected <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">You are done, but if you look closely at <a href="chapter5.xhtml#fig5-13">Figure 5-13</a>, you will notice the same problem as with the Fibonacci calculations: the cost of some blocks is calculated multiple times, for example, (5, 3, 6), (2, 5, 3), and (7, 2). You can apply memoization to avoid this problem, and that produces the needed algorithm:</p>&#13;
<pre id="pre-69"><code>const costOfFragment = <b>memoize(</b>(p, q) =&gt; {&#13;
  ...&#13;
}<b>);</b></code></pre>&#13;
<p class="TX">How would the optimized algorithm deal with this example? <a href="chapter5.xhtml#fig5-14">Figure 5-14</a> shows how little would actually be calculated.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_79" aria-label="79"/>&#13;
<figure class="IMG"><img class="img1" id="fig5-14" src="../images/Figure5-14.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-14: The optimized calculation reduces work in a significant way.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The grayed-out blocks don’t need recalculation; due to memoization, you just reuse the previously calculated costs. At several places (marked with arrows) no recursion was needed. All in all, the algorithm worked faster, but see question 5.5 for a further optimization.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h2-34"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Calculating Fibonacci Series with Bottom-Up DP</span></h4>&#13;
<p class="TNI1">Let’s consider DP the other way round, from the bottom up. When working in a top-down fashion, you have to hold off on calculating values until some calculations for lower values are finished. For example, in the section <span class="Xref">“Calculating Fibonacci Series with Top-Down DP”</span> on page <span class="Xref">72</span>, you couldn’t calculate <span class="SANS_TheSansMonoCd_W5Regular_11">fibo(7)</span> until the calculations for <span class="SANS_TheSansMonoCd_W5Regular_11">fibo(6)</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">fibo(5)</span> were done. Using the bottom-up method, you start at the lowest cases and work your way up. To find a Fibonacci number from the bottom up, make the calculations the same way that the series is defined, starting with 0 and 1, and always adding the last two numbers to create the next number in the sequence:</p>&#13;
<pre id="pre-70"><code>const fibo = (n) =&gt; {&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation1">❶</span> if (n &lt; 2) {&#13;
    return n;&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation2">❷</span>} else {&#13;
    let a = 0;&#13;
    let b = 1;&#13;
 <span class="Code_CodeAnnotation1" aria-label="annotation3">❸</span> while (n &gt; 1) {&#13;
      [a, b] = [b, a + b];&#13;
      n--;&#13;
    }&#13;
 <span class="Code_CodeAnnotation1" aria-label="annotation4">❹</span> return b;&#13;
 }&#13;
};</code></pre>&#13;
<p class="TX">It’s simple code: for 0 or 1 <span class="CodeAnnotation" aria-label="annotation1">❶</span> you need no calculations. For other values <span class="CodeAnnotation" aria-label="annotation2">❷</span>, set up a loop starting with <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> <span class="SANS_TheSansMonoCd_W5Regular_11">=</span> <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> <span class="SANS_TheSansMonoCd_W5Regular_11">=</span> <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">a</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> represent the two latest numbers in the sequence), and loop enough times <span class="CodeAnnotation" aria-label="annotation3">❸</span> until <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> becomes the number you are seeking <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_80" aria-label="80"/>You might notice that all the previously calculated numbers aren’t saved, and it’s true, but that’s because you don’t need them for this particular case. The algorithm works in a bottom-up fashion, calculating later numbers by using previous ones; it so happens that to do this, you always need only the two latest numbers, so there’s no need to store all the others.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h2-35"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Summing Ranges Recursively with Bottom-Up DP</span></h4>&#13;
<p class="TNI1">In the line-breaking algorithm (see <span class="Xref">“Line Breaking with Top-Down DP” on <a href="chapter5.xhtml#pg_74">page 74</a></span>), you needed the <span class="SANS_TheSansMonoCd_W5Regular_11">totalWidth(x,y)</span> function that would add together the widths of values in positions <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> through <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> (both inclusive) of an array of block widths. This function needs to be as fast as possible so as not to impact an algorithm’s performance negatively. The trivial version (looping through the array, summing as it goes) has linear <i>O</i>(<i>n</i>) performance, if <i>n</i> is the number of blocks. However, you can improve upon this, as you’ll see in a couple of alternative implementations, which will focus not only on DP but also on other techniques that you’ve seen in this chapter.</p>&#13;
<p class="TX">The first algorithm, using a loop to get the sum, is straightforward. Now include another parameter to the function, <span class="SANS_TheSansMonoCd_W5Regular_11">arr</span>, with the block widths, to make it more general and independent of its caller:</p>&#13;
<pre id="pre-71"><code>const totalWidth1 = (arr, from, to) =&gt; {&#13;
  let sum = 0;&#13;
  for (let i = from; i &lt;= to; i++) {&#13;
    sum += arr[i];&#13;
  }&#13;
  return sum;&#13;
};</code></pre>&#13;
<p class="TX">To optimize it using memoization requires only a small change:</p>&#13;
<pre id="pre-72"><code>const totalWidth1 = <b>memoize(</b>(arr, from, to) =&gt; {&#13;
  ...&#13;
}<b>);</b></code></pre>&#13;
<p class="TX">This version will be faster if (and this is a big if) you call the function two or more times, with the same arguments. Calling it with different arguments every time will slow it down instead of speeding it up, because of the extra caching work. Suppose you had already calculated the sum of the range from 10 to 20, and now you wanted the sum of the range from 10 to 21. You could add the 21st value to the sum of the range from 10 to 20, with no more work.</p>&#13;
<p class="TX">This concept is the key to DP: base a problem’s solution on the solution of previous, smaller problems. To implement it, you need to define the sum of a range of values in terms of sums of previous ranges. If you want to calculate the sum of a range of values of array <span class="SANS_TheSansMonoCd_W5Regular_11">arr</span> consisting of a single element (from <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">p</span>), the result is just <span class="SANS_TheSansMonoCd_W5Regular_11">arr[p]</span>. If you want the sum of values from position <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> to position <span class="SANS_TheSansMonoCd_W5Regular_11">q</span> (greater than zero), first sum the range from <span role="doc-pagebreak" epub:type="pagebreak" id="pg_81" aria-label="81"/><span class="SANS_TheSansMonoCd_W5Regular_11">0</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">q-1</span> and then add <span class="SANS_TheSansMonoCd_W5Regular_11">arr[q]</span> to that result. Finally, to find the sum of values from position <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> (greater than zero) to position <span class="SANS_TheSansMonoCd_W5Regular_11">q</span> (greater than <span class="SANS_TheSansMonoCd_W5Regular_11">p</span>), find the sum of range <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">q</span> and subtract the sum of range <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">p</span>-<span class="SANS_TheSansMonoCd_W5Regular_11">1</span>.</p>&#13;
<p class="TX">You can also use memoization to keep track of previously calculated values; the logic is as follows:</p>&#13;
<pre id="pre-73"><code>const totalWidth2 = memoize((arr, from, to) =&gt; {&#13;
  if (from === to) {&#13;
    return arr[from];&#13;
  } else if (from === 0) {&#13;
    return totalWidth2(arr, 0, to - 1) + arr[to];&#13;
  } else {&#13;
    return totalWidth2(arr, 0, to) - totalWidth2(arr, 0, from - 1);&#13;
  }&#13;
});</code></pre>&#13;
<p class="TX">This function works better and does less work. For instance, if you had asked for the sum of range 10 through 20, all sums from 0 to 0, 0 to 1, 0 to 2, and so on, up to 0 to 20 would need to be cached. If you then asked for the range 10 through 21, it would try to calculate the sum of range 0 to 21, which would be done immediately (as the sum of range 0 to 20, plus element 21), and subtract the sum of range 0 to 9 (which was already available). You still have an <i>O</i>(<i>n</i>) algorithm, but over time, it becomes an <i>O</i>(1) process; initial delays become amortized. But you can do even better.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h2-36"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Summing Ranges by Precomputing with Bottom-Up DP</span></h4>&#13;
<p class="TNI1">Seeing how <span class="SANS_TheSansMonoCd_W5Regular_11">totalWidth2(...)</span> in the previous section needs the sums of ranges from 0 to all possible other positions, you could use tabulation to precompute all those values, and then all queries would be <i>O</i>(1). You can use an internal cache (<span class="SANS_TheSansMonoCd_W5Regular_11">partial</span>) for those values:</p>&#13;
<pre id="pre-74"><code>const totalWidth3 = ((tab) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const partial = [0];&#13;
  tab.forEach((v, i) =&gt; {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> partial[i + 1] = partial[i] + v;&#13;
  });&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> return (from, to) =&gt; partial[to + 1] – partial[from];&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span>})(arr);</code></pre>&#13;
<p class="TX">This is a bit trickier, because you are using a closure for the <span class="SANS_TheSansMonoCd_W5Regular_11">partial</span> array, initialized in an immediately invoked function expression (IIFE). The precalculation sets up <span class="SANS_TheSansMonoCd_W5Regular_11">partial[k]</span> to be the sum of the first <i>k</i> elements in the original array, which correctly implies that <span class="SANS_TheSansMonoCd_W5Regular_11">partial[0]</span> should equal 0 <span class="CodeAnnotation" aria-label="annotation1">❶</span>. (You are wasting an extra array place, but that’s irrelevant in comparison with the speedy algorithm that you’ll get.) You also use DP to calculate these partial sums: <span class="SANS_TheSansMonoCd_W5Regular_11">partial[i+1]</span> is calculated based on the previous calculation of <span class="SANS_TheSansMonoCd_W5Regular_11">partial[i]</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The function you want will calculate the total between two elements <span class="CodeAnnotation" aria-label="annotation3">❸</span> by taking the sum up to the rightmost one (<span class="SANS_TheSansMonoCd_W5Regular_11">partial[to+1]</span>) and subtracting the sum of elements up to, but not including, the leftmost <span role="doc-pagebreak" epub:type="pagebreak" id="pg_82" aria-label="82"/>one (<span class="SANS_TheSansMonoCd_W5Regular_11">partial[from]</span>), which produces the desired <i>O</i>(1) algorithm. The IIFE trickery is done by providing the original array of widths as a parameter <span class="CodeAnnotation" aria-label="annotation4">❹</span>. (See question 5.6 for yet another way of doing this work.)</p>&#13;
<p class="TX">You’ve seen two different ways to use DP in a bottom-up fashion to optimize an algorithm, eventually reaching <i>O</i>(1) performance. Given that width calculations are frequently used to calculate line breaks, this is a game-changer for your code’s performance and usability.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h3 class="H1" id="sec16"><span id="h1-21"/><span class="SANS_Futura_Std_Bold_B_11">Brute-Force Search</span></h3>&#13;
<p class="TNI1">Brute-force algorithms attempt to find a solution to a problem by systematically trying all possible combinations of values. The main issue with this kind of logic is the combinatorial explosion of the number of cases to try. The order of the resulting algorithms usually goes into exponential or factorial classes (as discussed in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>) that makes them potentially impossible to use for even modest-sized input.</p>&#13;
<p class="TX">We’ll look at a problem in each category, going from worse to worst. Given the resulting order of algorithms in this category, there’s no surprise that we’ll avoid this kind of code in the rest of the book.</p>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h2-37"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Detecting</span> <span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Tautologies</span></h4>&#13;
<p class="TNI1">In terms of logic, a tautology is a boolean expression that is always true. For instance, if <span class="SANS_TheSansMonoCd_W5Regular_11">X</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">Y</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">Z</span> are boolean variables, two of the following JavaScript expressions are tautologies:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet"><span class="SANS_TheSansMonoCd_W5Regular_11">X OR Y OR (NOT X AND NOT Y)</span></li>&#13;
<li class="ListBullet"><span class="SANS_TheSansMonoCd_W5Regular_11">X OR (NOT X AND Y)</span> <span class="SANS_TheSansMonoCd_W5Regular_11">===</span> <span class="SANS_TheSansMonoCd_W5Regular_11">X OR Y</span></li>&#13;
<li class="ListBullet"><span class="SANS_TheSansMonoCd_W5Regular_11">(NOT X) OR (X AND Z) OR (NOT Y) OR (Y AND Z) OR Z</span></li>&#13;
</ul>&#13;
<p class="TX">Even for readers well versed in logic and expressions, it may not be immediately obvious which of these expressions are always true.</p>&#13;
<p class="TX">Recognizing whether a function of <i>n</i> boolean parameters is a tautology potentially requires 2<i><sup>n</sup></i> tests for each possible combination of true/false values, verifying for each one whether the function produces true as its result. Alternatively, you could try to find some combination of arguments that would make it false, and upon finding such a case, you’d know that the function isn’t a tautology. That kind of search would require a logic similar to what you used to solve the Squarest Game on the Beach puzzle.</p>&#13;
<p class="TX">Using recursion comes in handy: if a function of <i>n</i> variables is a tautology, setting the first variable to false should also be a tautology, and the same would happen if the first variable were set to true. To see whether the original function is a tautology, you need to test a couple of functions with one fewer argument, which leads to a simple implementation:</p>&#13;
<pre id="pre-75"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const isTautology = (fn, args = []) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (fn.length === args.length) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const result = !!fn(...args);&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_83" aria-label="83"/>  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if (!result) {&#13;
      console.log("Failed at", . . .args);&#13;
    }&#13;
    return result;&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> return (&#13;
      isTautology(fn, [...args, false]) &amp;&amp; isTautology(fn, [...args, true])&#13;
    );&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">isTautology()</span> function receives the original function to test, <span class="SANS_TheSansMonoCd_W5Regular_11">fn</span>, and a list of arguments <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The latter will be the combination of values with which you’ll test whether the function is true. If you have the right number of arguments <span class="CodeAnnotation" aria-label="annotation2">❷</span>, you evaluate the function <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and if it produces a false value <span class="CodeAnnotation" aria-label="annotation4">❹</span>, you’ll log the fact and return false, which will short-circuit all future and pending evaluations. If the function returns true, the search will continue. If not enough arguments were provided <span class="CodeAnnotation" aria-label="annotation5">❺</span>, you’ll test the function twice: adding a true and adding a false to the list of arguments, so all combinations will be tested eventually.</p>&#13;
<p class="TX">The following tests the three boolean expressions mentioned earlier:</p>&#13;
<pre id="pre-76"><code>const f = (x, y) =&gt; x || y || (!x &amp;&amp; !y);&#13;
console.log(isTautology(f)); // true&#13;
&#13;
const g = (x, y) =&gt; (x || (!x &amp;&amp; y)) === (x || y);&#13;
console.log(isTautology(g)); // true&#13;
&#13;
const h = (x, y, z) =&gt; !x || (x &amp;&amp; z) || !y || (y &amp;&amp; z) || z;&#13;
console.log(isTautology(h)); // false: Failed at true true false</code></pre>&#13;
<p class="TX">The first two functions actually were tautologies, but the last one wasn’t. The search listed at least one case where the failed function evaluates to false.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h4 class="H2" id="sec18"><span id="h2-38"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Solving Cryptarithmetic Puzzles</span></h4>&#13;
<p class="TNI1"><i>Cryptarithmetic puzzles</i> (also known as <i>cryptarithms</i>) are puzzles that provide a mathematical equation where the digits have been replaced by letters of the alphabet. The goal for the solver is to find which letter stands for which digit. Usually no numbers may start with zero, all letters should have different values, and the equation should translate to a phrase that makes sense. <a href="chapter5.xhtml#fig5-15">Figure 5-15</a> shows an early example of this, which was invented by British writer, puzzlist and mathematician Henry Ernest Dudeney in 1924.</p>&#13;
<figure class="IMG"><img class="img4" id="fig5-15" src="../images/Figure5-15.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-15: A classic cryptarithmetic puzzle</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_84" aria-label="84"/>You could solve this sort of puzzle with careful analysis (see question 5.7 for another example), but here you will write a solver that goes through all possible combinations of digits, checking whether any work. In this example, given that there are 10 digits, you need to check 10! (3,628,800) combinations, but some puzzles have numeric bases other than 10, so in general, this is an <i>O</i>(<i>n</i>!) algorithm. A similar example (in terms of its solution) is the traveling salesman problem that provides a list of <i>n</i> cities and the distances between each pair of cities; you need to find the shortest possible route that visits each city only once, returning to the starting city. The solution to this is likewise <i>O</i>(<i>n</i>!), and the algorithm is similar to the one you’ll see next. (You’ll also see a different type of solution using a greedy algorithm for this problem, later in this chapter.)</p>&#13;
<p class="TX">What algorithm do we need? The idea is simple: try all combinations of digits from 0123456789 to 9876543210, and check for each one whether the puzzle is solved. (In this case, you’ll use only the first eight digits, but that really doesn’t change anything.) You could design the main logic as follows, assuming that <span class="SANS_TheSansMonoCd_W5Regular_11">puzzle()</span> is a function to test whether a combination is valid:</p>&#13;
<pre id="pre-77"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const solve = (puzzle, digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const d = [...digits].sort();&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> for (;;) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if (puzzle(...d)) {&#13;
      console.log("SOLUTION: ", . . .d);&#13;
      return true;&#13;
    }&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> // Try generating the next combination of d.&#13;
    // If there are no more combinations left, return false.&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">digits</span> parameter <span class="CodeAnnotation" aria-label="annotation1">❶</span> will have the set of digits that you’ll use for the problem; although in this case, 0 to 9 are the possible values, you may as well write code that could be used for cryptarithmetic puzzles in other bases. Make a local copy of the set of digits <span class="CodeAnnotation" aria-label="annotation2">❷</span> to avoid modifying the original argument and to avoid a side effect (as discussed in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>), and sort it to go through the combinations in ascending order. Then set a loop <span class="CodeAnnotation" aria-label="annotation3">❸</span> that will exit when you either find a solution or decide none exists. If the current combination of digits works out <span class="CodeAnnotation" aria-label="annotation4">❹</span>, log it and exit; otherwise, generate the next combination of digits <span class="CodeAnnotation" aria-label="annotation5">❺</span> and keep looping, unless you reach the last combination, and then you’ll know that the problem has no solution.</p>&#13;
<p class="TX">Generating the next permutation of a given set is a well-known algorithm, likely discovered by Indian mathematician Narayana Pandita in the 14th century. Assuming that the current permutation is stored in array <span class="SANS_TheSansMonoCd_W5Regular_11">d</span>, it requires four steps, in order:</p>&#13;
<p class="ListNumberF">	1.	Find the rightmost index <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> such that <span class="SANS_TheSansMonoCd_W5Regular_11">d[p] &lt; d[p</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> <span class="SANS_TheSansMonoCd_W5Regular_11">1]</span>; if no such <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> exists, you were already at the last permutation, and the algorithm finishes.</p>&#13;
<p class="ListNumber"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_85" aria-label="85"/>	2.	Find the rightmost index <span class="SANS_TheSansMonoCd_W5Regular_11">q</span> such that <span class="SANS_TheSansMonoCd_W5Regular_11">d[p] &lt; d[q]</span>; <span class="SANS_TheSansMonoCd_W5Regular_11">d[q]</span> is the least value to the right of <span class="SANS_TheSansMonoCd_W5Regular_11">d[p]</span>greater than it.</p>&#13;
<p class="ListNumber">	3.	Swap the values of <span class="SANS_TheSansMonoCd_W5Regular_11">d[p]</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">d[q]</span>; now the values from <span class="SANS_TheSansMonoCd_W5Regular_11">d[p</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> <span class="SANS_TheSansMonoCd_W5Regular_11">1]</span> to the end of <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> will be in descending order.</p>&#13;
<p class="ListNumberL">	4.	Reverse the list of values from <span class="SANS_TheSansMonoCd_W5Regular_11">d[p</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> <span class="SANS_TheSansMonoCd_W5Regular_11">1]</span> to the end of <span class="SANS_TheSansMonoCd_W5Regular_11">d</span>.</p>&#13;
<p class="TX"><a href="chapter5.xhtml#fig5-16">Figure 5-16</a> shows a working example, starting with permutation <span class="SANS_TheSansMonoCd_W5Regular_11">8403976521</span>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig5-16" src="../images/Figure5-16.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-16: Generating the next permutation</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Step 1 sets <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> to point at 3, because 3 &lt; 9; all other elements from the right (<span class="SANS_TheSansMonoCd_W5Regular_11">976521</span>) are in descending order. Step 2 sets <span class="SANS_TheSansMonoCd_W5Regular_11">q</span> to point at 5, the least value to the right of 3 that is greater than it. Step 3 swaps the values pointed by <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">q</span>; values to the right of <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> are again in descending order (<span class="SANS_TheSansMonoCd_W5Regular_11">976321</span>). Step 4 ends by reversing the values to the right of p, which end in ascending order (<span class="SANS_TheSansMonoCd_W5Regular_11">123679</span>), and you get the next permutation: <span class="SANS_TheSansMonoCd_W5Regular_11">8405123679</span>.</p>&#13;
<p class="TX">With this logic, you can see the complete version of the cryptarithmetic puzzle solver by adding the code to generate permutations:</p>&#13;
<pre id="pre-78"><code>const solve = (puzzle, digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) =&gt; {&#13;
  const d = [...digits].sort();&#13;
&#13;
  for (;;) {&#13;
    if (puzzle(...d)) {&#13;
      console.log("SOLUTION: ", . . .d);&#13;
      return true;&#13;
    }&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_86" aria-label="86"/>    <b>let p = d.length - 2;</b>&#13;
    while (p &gt;= 0 &amp;&amp; d[p] &gt; d[p + 1]) {&#13;
      p--;&#13;
    }&#13;
&#13;
    if (p === -1) {&#13;
      console.log("No solution found");&#13;
      return false;&#13;
    }&#13;
&#13;
    <b>let q = d.length - 1;</b>&#13;
    while (d[p] &gt; d[q]) {&#13;
      q--;&#13;
    }&#13;
&#13;
    <b>[d[p], d[q]] = [d[q], d[p]];</b>&#13;
&#13;
    <b>let l = p + 1;</b>&#13;
    let r = d.length - 1;&#13;
    while (l &lt; r) {&#13;
      [d[l], d[r]] = [d[r], d[l]];&#13;
      l++;&#13;
      r--;&#13;
    }&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">This code is the same as earlier, with steps 1 through 4 of the permutation algorithm highlighted.</p>&#13;
<p class="TX">You can now write a function to test whether a given combination of values is actually a solution:</p>&#13;
<pre id="pre-79"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const sendMoreMoney = (s, e, n, d, m, o, r, y) =&gt; {&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation2">❷</span> if (s === 0 || m === 0) {&#13;
    return false;&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation3">❸</span>} else {&#13;
    const SEND = Number(`${s}${e}${n}${d}`);&#13;
    const MORE = Number(`${m}${o}${r}${e}`);&#13;
    const MONEY = Number(`${m}${o}${n}${e}${y}`);&#13;
    return SEND + MORE === MONEY;&#13;
  }&#13;
};&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> solve(sendMoreMoney);&#13;
// SOLUTION:  9 5 6 7 1 0 8 2 3 4&#13;
// 9567 + 1085=10652</code></pre>&#13;
<p class="TX">The function is called with all 10 digits <span class="CodeAnnotation" aria-label="annotation1">❶</span>, but you use only the first 8, ignoring the last 2. If a leading digit is 0 <span class="CodeAnnotation" aria-label="annotation2">❷</span>, the solution isn’t valid, so reject that out of hand. If there are no leading zeros <span class="CodeAnnotation" aria-label="annotation3">❸</span>, compute the values of the three words (<span class="SANS_TheSansMonoCd_W5Regular_11">SEND</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">MORE</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">MONEY</span>) and we check whether they fulfill the original equation. Given this function, all you need to do is pass it to the <span class="SANS_TheSansMonoCd_W5Regular_11">solve()</span> function <span class="CodeAnnotation" aria-label="annotation4">❹</span> and wait (very little) for the solution to appear.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_87" aria-label="87"/>&#13;
<h3 class="H1" id="sec19"><span id="h1-22"/><span class="SANS_Futura_Std_Bold_B_11">Greedy Algorithms</span></h3>&#13;
<p class="TNI1">Let’s conclude with a set of algorithms that have a rather curious characteristic: they may not always work. The basic definition of an algorithm implies that it’s a well-defined procedure to solve a problem or accomplish some task. <i>Greedy algorithms</i> may (or may not) achieve that.</p>&#13;
<p class="TX">Sometimes a heuristic is used to describe a way to get a (hopefully not too bad) solution in a faster way by applying some arbitrary choices instead of doing a thorough search. For instance, a chess algorithm could, in principle, always find the best move by considering all possible moves and all possible opponent responses, and all possible responses to those responses, and so on, but that approach grows exponentially and isn’t feasible. The alternative is a heuristic. Reconsidering the chess example, instead of going to the maximum depth, you would stop the search short after a few moves, do a ballpark evaluation of the resulting board positions, and choose the move that leads to the best evaluated move. This method doesn’t <i>guarantee</i> making the best move, but it at least provides some solution.</p>&#13;
<p class="TX">Greedy algorithms are usually applied to optimization problems. You’ve seen algorithms that use brute force to try all possibilities; greedy algorithms don’t do that. At each step where a decision needs to be made, these algorithms make the best possible choice at the time. On one hand, this approach ensures that the algorithm proceeds quickly without needing to backtrack. On the other hand, the algorithm doesn’t necessarily make the best choice, because it doesn’t look far enough ahead. However, under certain conditions, which you’ll explore in the following sections, these algorithms perform well and are successful.</p>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h4 class="H2" id="sec20"><span id="h2-39"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">How to Make Change</span></h4>&#13;
<p class="TNI1">How do you make change using the fewest bills and coins? In other words, suppose you have to pay out some amount using today’s US currency: $100, $50, $20, $10, $5, and $1 bills and $0.25 (quarter), $0.10 (dime), $0.05 (nickel), and $0.01 (penny) coins. How would you pay $229.60? You could use so many combinations to reach that amount, but with a greedy algorithm, you would follow this simple rule: at each step, choose as many as possible units of the largest possible denomination, and keep going until you’re done.</p>&#13;
<p class="TX">The method starts by using two $100 bills, then one $20, a $5, four $1s, two quarters, and a dime. No other solution involves fewer bills and coins. This greedy algorithm is guaranteed to succeed, but it depends on the available denominations. Paying out $16 (the greedy way) in a country that had $9, $8, and $1 bills would end up with one $9 and seven $1 bills, instead of using just two $8 bills. Greedy algorithms may (or may not) succeed depending on the case.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h4 class="H2" id="sec21"><span id="h2-40"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">The Traveling Salesman Problem</span></h4>&#13;
<p class="TNI1">Let’s consider a problem that requires a brute-force search but that a greedy algorithm usually solves quite well. The traveling salesman problem works like this: imagine a salesman has to do a tour, visiting each city on a list once <span role="doc-pagebreak" epub:type="pagebreak" id="pg_88" aria-label="88"/>and then returning to the starting point. (In graph terms, this is called a <i>Hamiltonian cycle</i>.) Distances (or costs) for traveling between cities is known. What’s the shortest (or cheapest) way to achieve the task?</p>&#13;
<p class="TX">As is, an algorithm for this problem would require testing all possible permutations of cities (as you did previously for the SEND + MORE = MONEY cryptarithmetic puzzle). If the number of cities grows, the problem becomes intractable because the required time to run the algorithm takes too long.</p>&#13;
<p class="TX">A greedy algorithm for this problem (which may not find the best solution but performs quickly) would proceed as follows: at each step visit the nearest not-yet-visited city. This method won’t necessarily find the best possible path, and several heuristics may discover an even better one, but under some conditions, the algorithm finds the optimal solution.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h4 class="H2" id="sec22"><span id="h2-41"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Minimum Spanning Tree</span></h4>&#13;
<p class="TNI1">Let’s wrap up our discussion of greedy algorithms by considering a problem you’ll explore in <span class="Xref"><a href="chapter17.xhtml">Chapter 17</a></span>. Imagine a cable TV company must provide service to several houses. The company cannot place cables just anywhere and must follow existing roads. Where should it put cables to minimize the total cost?</p>&#13;
<p class="TX">The solution for this is technically called a <i>minimum spanning tree</i>, and Kruskal’s algorithm (which you’ll implement in <span class="Xref"><a href="chapter17.xhtml">Chapter 17</a></span>) is a greedy algorithm that solves it and is guaranteed to find the optimal solution. Start by choosing the cheapest segment of road until all houses are connected, and always add the cheapest possible segment that won’t generate a loop; after all, what good would having a closed cable loop be?</p>&#13;
<p class="TX">You can solve other graph-related problems using greedy algorithms, so this technique may also be a valid one to consider when trying to write code for a specific problem.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h3 class="H1" id="sec23"><span id="h1-23"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>&#13;
<p class="TNI1">In this chapter we considered several techniques (recursion, DP, and brute-force and greedy algorithms) that will help you develop algorithms on your own, and they’ll appear again several times in the rest of the book.</p>&#13;
<p class="TX">In the next chapter, we’ll explore several common problems, such as sorting, selecting, shuffling, sampling, and searching—that’s a lot of alliteration but also a lot of interesting code and plenty of opportunities to study how to write algorithms.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h3 class="H1" id="sec24"><span id="h1-24"/><span class="SANS_Futura_Std_Bold_B_11">Questions</span></h3>&#13;
<p class="ListHead"><b>5.1  Factorial in One</b></p>&#13;
<p class="ListPlainFirst">The code for <span class="SANS_TheSansMonoCd_W5Regular_11">factorial()</span> is totally correct, but it’s seven lines long! Not that it matters (having a long correct function is better than a short incorrect one), but can you write it in a more compact way?</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_89" aria-label="89"/><b>5.2  Hanoi by Hand</b></p>&#13;
<p class="ListPlainFirst">The recursive algorithm for the Towers of Hanoi is good for computers, but not so much for normal human beings. Can you design a simple algorithm to solve the puzzle that doesn’t involve recursion?</p>&#13;
<p class="ListHead"><b>5.3  Archery Backtracking</b></p>&#13;
<p class="ListPlainFirst">Sam Loyd devised another puzzle (see <a href="chapter5.xhtml#fig5-17">Figure 5-17</a>) similar to the Squarest Game on the Beach that you solved earlier in this chapter. In this puzzle, you need to get 100 points by aiming arrows at the target. The important difference is that in this puzzle, you can hit a ring two or more times, while in the other problem you could drop a doll only once.</p>&#13;
<figure class="IMG"><img class="img1" id="fig5-17" src="../images/Figure5-17.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-17: Another classic puzzle by Sam Loyd, where players must get exactly 100 points with their arrows (public domain)</span></p></figcaption>&#13;
</figure>&#13;
<p class="ListBody">Can you modify the backtracking algorithm to deal with this variation? And, even with the differences, can you still use the <span class="SANS_TheSansMonoCd_W5Regular_11">solve()</span> function that you used for the other puzzle to find the solution?</p>&#13;
<p class="ListHead"><b>5.4  Counting Calls</b></p>&#13;
<p class="ListPlainFirst">If you call <i>C</i>(<i>n</i>), the total number of calls needed to calculate the <i>n</i>th Fibonacci number with your recursive implementation, you will see, for example, that <i>C</i>(7) = 41. Can you give a recurrence for <i>C</i>(<i>n</i>) and find an explicit solution for it? Hint: the answer will again involve Fibonacci numbers.</p>&#13;
<p class="ListHead"><b>5.5  Avoid More Work</b></p>&#13;
<p class="ListPlainFirst">When considering how to arrange blocks in rows (in <span class="listplain_Xref">“Line Breaking with Top-Down DP” on <a href="chapter5.xhtml#pg_74">page 74</a></span>) and when considering splits, you analyzed them as (7, 2, 5) and (3, 6) or (7, 2, 5, 3) and (6). However, this wasn’t really needed because blocks 7 + 2 + 5 or 7 + 2 + 5 + 3 couldn’t fit <span role="doc-pagebreak" epub:type="pagebreak" id="pg_90" aria-label="90"/>in a line. <a href="chapter5.xhtml#fig5-18">Figure 5-18</a> shows crossed-out options that an enhanced algorithm wouldn’t have considered.</p>&#13;
<figure class="IMG"><img class="img1" id="fig5-18" src="../images/Figure5-18.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-18: An even more efficient way to find row breaks</span></p></figcaption>&#13;
</figure>&#13;
<p class="ListBody">Can you add this optimization to the code?</p>&#13;
<p class="ListHead"><b>5.6  Reduce for Clarity</b></p>&#13;
<p class="ListPlainFirst">The <span class="SANS_TheSansMonoCd_W5Regular_11">totalWidth3(...)</span> function (in the section <span class="listplain_Xref">“Summing Ranges by Precomputing with Bottom-Up DP” on <a href="chapter5.xhtml#pg_81">page 81</a></span>) used a common loop to generate the <span class="SANS_TheSansMonoCd_W5Regular_11">partial</span> array. Can you do the same using <span class="SANS_TheSansMonoCd_W5Regular_11">.reduce(...)</span> instead?</p>&#13;
<p class="ListHead"><b>5.7  Got GOUT?</b></p>&#13;
<p class="ListPlainFirst"><a href="chapter5.xhtml#fig5-19">Figure 5-19</a> shows another well-known cryptarithmetic puzzle; find what each letter stands for, and then the value of GOUT is your answer. You can solve this with the techniques shown earlier in the chapter, or you could try your hand at directly working it out.</p>&#13;
<figure class="IMG"><img class="img4" id="fig5-19" src="../images/Figure5-19.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-19: A simple cryptarithmetic puzzle with only four letters to find</span></p></figcaption>&#13;
</figure>&#13;
</section>&#13;
</section>&#13;
</body></html>