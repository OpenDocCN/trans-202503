- en: '**F  More Test Modes**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**F.1 8051 External Memory**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: McCormac (1996) and other Nineties sources describe a vulnerability for dumping
    Intel’s 8051\. This chip has an !EA pin that maps external memory into the boot
    region.
  prefs: []
  type: TYPE_NORMAL
- en: The pin is not *latched* by sampling it only at reset; you can flip it back
    and forth as the software is running! The chip’s memory can be dumped by booting
    to an external EEPROM that jumps from the boot region to the EEPROM region and
    then re-enables the ROM to be read as data.
  prefs: []
  type: TYPE_NORMAL
- en: Some 8051 derivatives such as the Signetics SCN8051H remain vulnerable. Others
    latch the !EA pin at reset to prevent the attack.
  prefs: []
  type: TYPE_NORMAL
- en: Blair (2020) is a standalone dumper for 8051 chips with this unlatched pin,
    including both a PCB design and an EEPROM image to perform the attack. His exploit
    runs within the target 8051, so the PCB does not require an additional microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: '**F.2 TMS320C15, BSMT2000 !MP Pin**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like many chips from the Eighties, the TMS320 series can operate either as a
    microcontroller executing code from an internal ROM or as a microprocessor executing
    code from external memory. Surply (2015) is primarily concerned with the Sega
    Whitestar pinball machine and programmable array logic (PAL) reverse engineering,
    but it contains a nifty abuse of the !MP pin that switches between these modes.
    This is orchestrated by an FPGA, presenting a small memory filled with shellcode
    while switching the victim chip between microprocessor and microcontroller modes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0362-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure F.1: TMS320C15 Dump Waveform from Surply (2015)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0363-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure F.2: External Shellcode from Surply (2015)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0363-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure F.3: BSMT2000 / TMS320C15'
  prefs: []
  type: TYPE_NORMAL
- en: The !MP pin is not latched at reset, so you can freely change it within an instruction
    to cause the instruction to be fetched from external memory while the first data
    argument is fetched from internal memory.
  prefs: []
  type: TYPE_NORMAL
- en: Once you know that the !MP pin is not latched, it is clear that this can be
    exploited by toggling it while having an FPGA emulate an external memory. Toggling
    causes the chip to stop executing the internal ROM and switch over to executing
    the FPGA’s memory. The pin can be low to fetch most instructions from the external
    memory, jumping high only for the brief fetch from the internal ROM.
  prefs: []
  type: TYPE_NORMAL
- en: His shellcode in [Figure F.2](app06.xhtml#chFfig2) is quite simple. After initializing
    variables, an infinite `while()` loop at address 5 keeps dumping the accumulator’s
    value and the program memory value at the accumulator’s address to the first two
    I/O ports. There’s nothing within the code to switch between internal and external
    memories; that logic is handled by an FPGA that presents this memory to the TMS320.
  prefs: []
  type: TYPE_NORMAL
- en: Surply’s timing diagram in [Figure F.1](app06.xhtml#chFfig1) shows that the
    !MP pin should jump high after the `TBLR 0` instruction is fetched from address
    5\. The pin drops low before the following instruction is fetched from address
    6\. He notes that this timing is very tight, and that violations of it will cause
    the exploit to fail.
  prefs: []
  type: TYPE_NORMAL
- en: '**F.3 6500/1 Ten Volts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shortly after Commodore acquired MOS Technology for its 6502 technology, they
    released the 6500/1 chip, a mask-programmed variant of the 6502\. The 6500/1 includes
    two kilobytes of ROM, 64 bytes of RAM, and some handy peripherals. It also has
    a test mode, an exploit for which is available in Brain (2014).
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the datasheet, Commodore (1986) describes the test mode like so:'
  prefs: []
  type: TYPE_NORMAL
- en: Special test logic provides a method for thoroughly testing the 6500/1\. Applying
    a +10V signal to the !RES line places the 6500/1 in the test mode. While in this
    mode, all memory fetches are made from Port PC. External test equipment can use
    this feature to test internal CPU logic and I/O. A program can be loaded into
    RAM, allowing the contents of the instruction ROM to be dumped to any port for
    external verification.
  prefs: []
  type: TYPE_NORMAL
- en: Brain’s source code contains two exploits for dumping the ROM. His first method,
    built upon suggestions by Gerrit Heitsch and Greg King, pulls data directly from
    the ROM without forcing it to execute shellcode. He observes the instruction fetches
    until he knows which phase of the clock is the opcode fetch, then instructs the
    CPU to load a memory location into the accumulator register. He finally drops
    out of the test mode during the cycle when the load from ROM would occur so the
    fetch occurs from the real ROM and not from port `PC`.
  prefs: []
  type: TYPE_NORMAL
- en: His second exploit is closer to the intent of the datasheet, loading this shellcode
    into SRAM at `0x0000` and then executing it outside of test mode to dump the contents
    of ROM to `PA` at `0x80` while strobing `PC` at `0x82` to indicate that data is
    ready.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0366-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure F.4: 6500/1 Dumper from Brain (2014)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0367-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure F.5: Commodore 6500/1'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0367-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure F.6: 6500/1 ROM Bits'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0368-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In both cases, an AVR reads each sampled byte and forwards it out the serial
    port for a waiting desktop to receive. This successfully extracted the firmware
    and fonts of the Commodore 1520 plotter.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the test modes, the ROM of this chip is easily photographed.
    The sample bits in [Figure F.6](app06.xhtml#chFfig6) were seen after decapsulation
    with HNO[3] and delayering with dilute HF.
  prefs: []
  type: TYPE_NORMAL
- en: '**F.4 TMP90 External Memory**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Galiano (2023) is a fully functional exploit for the TLCS-90 series of Z80 microcontrollers
    from Toshiba. Examples include the TMP90C840AN and TMP90CM40AN, as well as chips
    such as the TMP91C640N from the related TLCS-900 series. The exploit depends upon
    a non-maskable interrupt (NMI) pin, so it is not compatible with the entire series;
    the TMP90C844AN, TMP91-C642AN and TMP90CH44N are not vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: Galiano begins with the EA pin, which controls whether the chip boots from internal
    ROM or from external memory. It’s not quite as easy as booting externally and
    dumping the ROM, however. The EA pin is only sampled at reset and it disables
    internal ROM at the same time it selects booting from external memory.
  prefs: []
  type: TYPE_NORMAL
- en: His exploit boots from an external EEPROM. He then uses a trick in how Z80 chips
    set up the call stack to execute from this EEPROM again while internal ROM is
    still enabled and the default boot target.
  prefs: []
  type: TYPE_NORMAL
- en: Z80 chips such as the TLCS-90 series do not reset their stack pointers in hardware
    at reset. Rather, the first instruction usually sets the stack pointer. By triggering
    an NMI before that instruction begins to execute, Galiano redirects execution
    to the NMI interrupt handler *before* the stack pointer is valid!
  prefs: []
  type: TYPE_NORMAL
- en: When the stack pointer was previously set to EEPROM rather than SRAM, the target
    chip will save the `AF` and `PC` registers to the poorly located stack. `AF`’s
    value doesn’t matter and `PC` will probably be `0x9000` at this moment. Neither
    value is written to the EEPROM, because EEPROMs don’t accept random writes, so
    on return from the interrupt handler the program counter is forced to the value
    in the read-only stack.
  prefs: []
  type: TYPE_NORMAL
- en: That code can then initialize the stack pointer to an address in SRAM and proceed
    to freely read all internal ROM or PROM, dumping it out a serial port or copying
    it to a new memory chip.
  prefs: []
  type: TYPE_NORMAL
- en: '**F.5 Mostek 3870 (Fairchild F8)**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boris Diplomat, Chess Traveler, and a number of other chess computers from the
    late Seventies use a variant of Fairchild’s F8 architecture called the Mostek
    MK3870\. Riddle (2013) and Rock (2013) describe electrical dumps using a test
    mode of this chip.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0370-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure F.7: Mostek MK3870'
  prefs: []
  type: TYPE_NORMAL
- en: '[Page 16](ch02.xhtml#ch2fig1) of Mostek (1978) describes the behavior of the
    TEST pin, which activates different testing modes depending upon the voltage:'
  prefs: []
  type: TYPE_NORMAL
- en: In normal operation the TEST pin is unconnected or is connected to GND. When
    TEST is placed at TTL level (2.0V to 2.6V) port 4 becomes an output of the internal
    data bus and port 5 becomes a wired-OR input to the internal data bus. The data
    appearing on the port 4 pins is logically true whereas input data forced on port
    5 must be logically false.
  prefs: []
  type: TYPE_NORMAL
- en: When TEST is placed at a high level (6.0V to 7.OV), the ports act as above and
    additionally the 2K *×* 8 program ROM is prevented from driving the data bus.
    In this mode operands and instructions may be forced externally through port 5
    instead of being accessed from the program ROM. When TEST is in either the TTL
    state or the high state, STROBE ceases its normal function and becomes a machine
    cycle clock (identical to the F8 multi-chip system WRITE clock except inverted).
  prefs: []
  type: TYPE_NORMAL
- en: 'In shorter terms, the TEST pin can put the chip into three possible states:
    1) normal execution when the TEST pin floats, 2) ROM enabled when the TEST pin
    is at 3.5V (TTL voltage) and 3) ROM disabled when the TEST pin is at 7V (high
    voltage). These latter two modes are both for testing, and the difference is in
    whether the internal ROM is or is not allowed to drive the data bus.'
  prefs: []
  type: TYPE_NORMAL
- en: To dump the ROM, Riddle first moved the pin to high voltage, disabling the ROM
    so he can inject a load instruction. As the instruction executes, he then drops
    the pin to TTL voltage, re-enabling the ROM so the load instruction receives its
    data.
  prefs: []
  type: TYPE_NORMAL
- en: While Riddle’s original exploit used a PIC 18F4620 for voltage compatibility,
    Rock preferred a Raspberry Pi Pico and level translators.
  prefs: []
  type: TYPE_NORMAL
- en: A direct port of Riddle’s exploit from PIC BASIC Pro was not functional, so
    significant structural changes were made to more generically inject code and read
    back the results. Between that and a little error correction, it successfully
    dumped the firmware from an HP82143 printer with no damage.
  prefs: []
  type: TYPE_NORMAL
- en: '**F.6 MC6801 Test Mode**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MC6801 microcontroller is capable of running from either internal or external
    ROM. Lind (2019) is an open source project for electrically dumping ROMs from
    Motorola MC6801.
  prefs: []
  type: TYPE_NORMAL
- en: 'Motorola (1984) describes Test Mode Zero, whose memory map is shown in [Figure
    F.8](app06.xhtml#chFfig8). From Section 2.3, the mode selection is a little tricky
    but taken care of by pins at reset:'
  prefs: []
  type: TYPE_NORMAL
- en: The MC6801 operating mode is controlled by the levels present at pins 8, 9,
    and 10 during the rising edge of RESET. These same three pins, however, also function
    as the least three significant bits of Port 2\. The operating mode is latched
    into the MCU Program Control Register on the rising edge of RESET after which
    time the levels can be removed and the·pins used for other purposes. The operating
    mode can be read from the Port 2 data register where the values PCO (Pin 8), PC1
    (Pin 9), and PC2 (Pin 10) appear as data bits D5 through D7, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: By selecting Test Mode 0, Lind’s exploit forces the reset vector to be read
    from the external EEPROM rather than from the internal ROM. At this point, code
    is executing from external memory and capable of freely reading internal memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0373-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure F.8: Test Mode Memory Map from Motorola (1984)'
  prefs: []
  type: TYPE_NORMAL
- en: Lind’s shellcode is a fork of Daniel Tufvesson’s MC3 monitor in a normal EEPROM,
    with a GAL16V8 PLD to manage the reset sequencing and memory bus. After the victim
    chip boots the monitor, standard monitor commands can be sent to dump the contents
    of internal ROM over the chip’s serial port.
  prefs: []
  type: TYPE_NORMAL
- en: '**F.7 NEC uCOM4 Test Mode**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NEC’s uCOM4 series consists of 4-bit microcontrollers with mask ROM, such as
    the D552 and D553\. Kevin Horton and Sean Riddle investigated these as a way to
    recover ROMs from antique checkers and chess games.
  prefs: []
  type: TYPE_NORMAL
- en: Riddle’s extraction technique involves mask ROM photography, which is very portable
    but can be labor intensive in the decoding. His decoder is shown in [Figure F.9](app06.xhtml#chFfig9),
    revealing that sixteen pages exist in each of the 128 rows, with each pair of
    pages being in the opposite order. Riddle (2023) shows the ROM after delayering.
  prefs: []
  type: TYPE_NORMAL
- en: A non-destructive method in Horton (2023) is electrical rather than photographic.
    The chip has a test pin that causes it to stop the CPU and dump bits to the GPIO
    pins, but it only does this within a 256-byte page of memory. It does this in
    a loop, so you do get all the bytes, but you don’t necessarily know how they are
    aligned.
  prefs: []
  type: TYPE_NORMAL
- en: To electrically extract other pages, you must single-step the CPU until it performs
    a jump into another memory page, then use the test pin to dump that page. Within
    that page it will begin dumping at the program counter value, so the bytes of
    the page will have some offset that must be corrected. By identifying jump points
    within known pages and arranging for jumps to be taken, any page with reachable
    code can be dumped.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0375-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure F.9: Fabulous Fred Decoder by Sean Riddle'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0376-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure F.10: Fabulous Fred uCOM4 ROM'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0377-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure F.11: EMZ1001E Diffusion ROM'
  prefs: []
  type: TYPE_NORMAL
- en: '**F.8 AMI S2000 and Iskra EMZ1001**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yugoslavia’s only microcontroller, the Iskra EMZ1001, is a variant of AMI’s
    S2000 series, right down to an AMI logo on the die. Unlike the Soviet clones,
    this one seems to have been licensed by AMI as a cooperative venture. Zoltan Pekic
    implemented an EMZ1001 clone in VHDL as Pekic (2022), and he graciously pointed
    me to a test mode in the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The trick, found on page 4.9 of AMI (1979), is in the interaction of the ROMS
    and SYNC pins. The explanation is short, and easy to skip over if you aren’t looking
    so closely as to clone the chip. The ROMS pin is described like so:'
  prefs: []
  type: TYPE_NORMAL
- en: ROM source control. Tied to a logic 1 or 0 to indicate internal ROM only, or
    internal plus external. Tied to SYNC to override Bank 0 with an external program,
    and to inverted SYNC to verify internal ROM contents.
  prefs: []
  type: TYPE_NORMAL
- en: So by inverting the SYNC signal into ROMS, we can force the chip into verification
    mode. The instruction decoder will be fed dummy instructions while the program
    counter counts forward and the data pins output the internal ROM contents.
  prefs: []
  type: TYPE_NORMAL
- en: If you are impatient, the ROM bits are also visible. [Figure F.11](app06.xhtml#chFfig11)
    shows the bits of an EMZ1001E microcontroller after delayering with HF.
  prefs: []
  type: TYPE_NORMAL
- en: '**F.9 TMS1000 Test Mode**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s often hard to know for sure that a given patent matches a given chip, and
    this isn’t made any easier when multiple patents likely refer to the same chip.
    Caudel and Raymond (1974) is the patent for Texas Instruments’ TMS1000 chip, describing
    many of its internal signals and a test mode for dumping the internal ROM contents.
    This test mode does not appear in the datasheet, programmer’s reference manual,
    or other official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Another filing, Boone and Cochran (1977) is frequently cited as the TMS1000
    patent. Both chips have 28 pins. Both chips are intended for ROM-programmed calculators.
    The TMS1000 clearly has a ROM width of eight bits. Boone and Cochran’s chip, however,
    has 11-bit instructions like the TMS0801\. See Ilmer (2024) for an excellent tutorial
    on dumping that chip’s ROM, including detailed notes on determining the ROM bit
    ordering.
  prefs: []
  type: TYPE_NORMAL
- en: Caudel and Raymond’s patent also has a black and white die photograph that is
    quite close to the TMS1000, along with a set of opcodes that match. Column 28
    of their patent describes four test mode operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operation 1: The ROM word address is loaded into the program counter serially
    from keyboard pin K1 under the control keyboard pin KC. Setting KC to Vss causes
    the bit to be sampled on *ϕ*1 time, when the program counter is not otherwise
    in use. (The chip’s clock is divided into five signals, of which *ϕ*1 is the first.
    See Figure 24 in the patent for details.)'
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you are following along with the patent and datasheet, you might note
    that there is no KC pin on the datasheet. This can be explained by documentation
    change between the patent and the datasheet. The patent groups KC along with four
    keyboard input pins as signal 75 on the die photograph in [Figure F.12](app06.xhtml#chFfig12),
    while the datasheet places an INIT pin at that same location.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0380-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure F.12: Prototype from Caudel and Raymond (1974)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0380-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure F.13: TMS1000'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0381-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure F.14: TMS1000 Pinouts'
  prefs: []
  type: TYPE_NORMAL
- en: Input and output pins also have different labels, so expect a little confusion
    as you go along.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operation 2: The ROM page address is loaded in parallel on the K1, K2, K4,
    and K8 keyboard pins. If the KC pin is at -Vdd on clock phase *ϕ*2, four bits
    will be sampled. Note that this parallel load of the page address happens at a
    different clock phase than the word address; the patent suggests a speed hack
    here of quickly iterating the page address while rarely adjusting the word address.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operation 3: The eight-bit word at the chosen ROM address can be loaded into
    the program counter by the internal !BRNCAL signal, which is produced by a combination
    of the KC and K2 pins.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operation 4: The result of the fetch from the third operation can be read serially
    out of an output pin under the control of the KC pin. Helpfully, this serial transfer
    can happen at the same time but one phase ahead of loading a new address with
    the first operation.'
  prefs: []
  type: TYPE_NORMAL
- en: My description sadly lacks a few details, and I doubt I’ll ever really understand
    this test mode before using it to dump a chip. If you implement it before I do,
    kindly send along an email with a copy of your paper and a list of any errata
    that I ought to correct in this appendix entry.
  prefs: []
  type: TYPE_NORMAL
- en: '**F.10 Z8 Test ROM**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I can’t cite any modern use of this test mode, but many of the Zilog Z8 chips
    such as the Z8601 and Z8611 hold a test ROM in addition to the main program ROM.
    This is explained in Zilog (1982), where the purpose of the test ROM is to test
    those few features which cannot be directly exercised from the external EEPROM
    code that performs the majority of testing.
  prefs: []
  type: TYPE_NORMAL
- en: The first clue comes from die photography, where the ROM is larger than expected.
    The internal ROM of the Z0860008PSC, for example, contains 256 columns by 66 rows,
    rather than the expected 64 rows. This is 64 bytes more than the two kilobytes
    advertised in the datasheet.
  prefs: []
  type: TYPE_NORMAL
- en: From Zilog (1982), we find that these bytes contain something like the test
    ROM in [Figure F.16](app06.xhtml#chFfig16). The test ROM replaces the application
    ROM if the !RST pin is held 2.5 volts higher than VCC for at least eight clock
    cycles, after which it can be relaxed to the normal voltage. That’s 7.5 volts
    for a 5-volt chip.
  prefs: []
  type: TYPE_NORMAL
- en: The test ROM is too small to test very much, so it first maps external memory
    through the IO ports and calls into that external memory. It then branches to
    `0x0812` (or `0x1012`) in the external memory, where the EEPROM example disables
    interrupts and runs a testing loop, often calling back into the test ROM. Callbacks
    seem to be used to test the I/O ports that are used for external memory access;
    they aren’t used for convenient like a PC BIOS call.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0383-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure F.15: Zilog Z8611'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0384-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure F.16: Z8601 Test ROM'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0384-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure F.17: Entry to a Z8601 Test EEPROM'
  prefs: []
  type: TYPE_NORMAL
- en: When running in the test mode, the `lde` instruction can fetch bytes from the
    test ROM while the `ldc` instruction fetches words from the application ROM. That
    and a simple loop ought to be enough to dump the ROM, without bothering to call
    back into the test ROM.
  prefs: []
  type: TYPE_NORMAL
- en: The ROM variants of these chips can also be dumped photographically. They use
    a diffusion ROM whose bits become visible after delayering with HF.
  prefs: []
  type: TYPE_NORMAL
