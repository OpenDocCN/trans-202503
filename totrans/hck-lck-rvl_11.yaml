- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">WORKING
    WITH DATA IN PYTHON</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: The basics of Python are behind you, but there’s still a lot to learn. In this
    chapter, you’ll expand your programming skills and start to directly investigate
    datasets, including BlueLeaks and chat logs leaked from a pro-Putin ransomware
    gang after Russia invaded Ukraine in 2022.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll go over some more advanced Python topics, like how to use modules, how
    to traverse the filesystem, and how to create your own command line programs in
    Python. You’ll write programs that look through all of the files in a folder,
    including the hundreds of thousands of files in the BlueLeaks dataset, and learn
    to add arguments to your programs. You’ll also start working with a new type of
    variable in Python, the dictionary, which will prove handy for working with data
    that’s too complex to store in simple lists. As with the previous chapter, future
    chapters rely on your understanding of the topics covered here.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Modules</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you learned in [Chapter 7](chapter7.xhtml), functions are reusable blocks
    of code that you can run as many times as you want without having to rewrite any
    code. Python *modules* are similar, but instead of making a single block of code
    reusable, they make an entire Python file (or multiple files) reusable. You can
    think of a module as a separate Python file that you can load into the file you’re
    currently working on.
  prefs: []
  type: TYPE_NORMAL
- en: Python includes a wealth of features, but most of them aren’t available to every
    Python script by default. Instead, they’re stored in *built-in* modules, those
    that come with Python. Once you import a module into your script using an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">import</samp> statement, you can access
    all of the functions, variables, and other Python objects defined in that module
    using the syntax <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">module_name</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">item_name</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp>
    module includes the function <samp class="SANS_TheSansMonoCd_W5Regular_11">time.sleep()</samp>
    (pronounced “time dot sleep”), which makes your program wait a given number of
    seconds before continuing to the next line of code. Run the following commands
    to import the <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp> module
    and then have it tell Python to wait five seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Your Python interpreter should wait five seconds before the prompt appears again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few of the built-in modules I use the most:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">os</samp> Includes useful functions
    for browsing the filesystem, like <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>. It also includes
    the submodule <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path</samp>, which
    is full of functions to inspect files. For example, it includes <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isfile()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isdir()</samp>, which
    help determine whether a specific path is a file or a folder.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">csv</samp> Lets you work with CSV
    spreadsheet data.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">json</samp> Lets you work with
    JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">datetime</samp> Includes useful
    Python features for working with dates and times. For example, it allows you to
    convert strings like <samp class="SANS_TheSansMonoCd_W5Regular_11">February 24,
    2022 5:07:20 UTC+3</samp> (the exact time that Russia invaded Ukraine) into a
    timestamp that Python can understand and compare with other timestamps, then convert
    it back into strings of any format you choose.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp> module
    extensively later in this chapter, the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp>
    module in [Chapter 9](chapter9.xhtml), and the <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp>
    module in [Chapter 11](chapter11.xhtml). You’ll briefly see how <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp>
    works later in this chapter when you take a look at chat logs from a ransomware
    gang, as well as in the [Chapter 14](chapter14.xhtml) case study, where you’ll
    analyze leaked neo-Nazi chat logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'As your programs get more complex, you might find it useful to split them up
    into multiple files, with each file containing a different part of your code.
    When you do this, you’re creating your own modules. The name of the module is
    the same as its filename. For example, if you define some functions in a file
    called *helpers.py*, another Python file can access those functions by importing
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers</samp> module. The *helpers.py*
    file could contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This module contains two functions for calculating sales tax, <samp class="SANS_TheSansMonoCd_W5Regular_11">get_tax()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">get_net_price()</samp>. The
    following Python script, *price.py*, imports it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first line, <samp class="SANS_TheSansMonoCd_W5Regular_11">import helpers</samp>,
    makes the functions defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers</samp>
    module accessible to this script. The second line calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers.get_net
    _price()</samp> function from that module and stores the return value in the variable
    <samp class="SANS_TheSansMonoCd_W5Regular_11">total_price</samp>. The third line
    displays the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">total_price</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what it looks like when I run this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Running the *price.py* script executes the code defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers</samp>
    module. Inside that module, the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_net_price()</samp>
    function calls <samp class="SANS_TheSansMonoCd_W5Regular_11">get_tax()</samp>
    and uses its return value to calculate the net price, then returns *that* value
    back into the *price.py* script.
  prefs: []
  type: TYPE_NORMAL
- en: Before you write your first advanced Python script in Exercise 8-1, let’s look
    at the best way to start new Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Python Script Template</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I use the same basic template for all my Python scripts, putting my code into
    a function called <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>,
    then calling that function at the bottom of the file. This isn’t required (you
    didn’t do this for any of the scripts you wrote in [Chapter 7](chapter7.xhtml),
    after all), but it’s a good way to organize your code. Here’s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The template defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function with a <samp class="SANS_TheSansMonoCd_W5Regular_11">pass</samp> statement
    that tells Python, “Skip this line.” I later replace <samp class="SANS_TheSansMonoCd_W5Regular_11">pass</samp>
    with the real body of the script.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    tells Python under which conditions it should run <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>.
    Python automatically defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp>
    variable, and the definition differs depending on what Python file is being run.
    If you’re running the currently executing Python file directly, then Python sets
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp> to
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">__main__</samp> string. But
    if you imported the currently executing Python file from another script, Python
    sets the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp>
    to the name of the imported module. Using the example from the previous section,
    if you run the *helpers.py* script directly, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp>
    inside that script will be <samp class="SANS_TheSansMonoCd_W5Regular_11">__main__</samp>,
    but if you run the *price.py* script, then the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp>
    will be <samp class="SANS_TheSansMonoCd_W5Regular_11">__main__</samp> inside *price.py*
    and the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">__name__</samp>
    will be <samp class="SANS_TheSansMonoCd_W5Regular_11">helpers</samp> inside *helpers.py*.
  prefs: []
  type: TYPE_NORMAL
- en: In short, if you run your script directly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function will run. But if you import your script as a module into another script
    or into the Python interpreter, the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function won’t run unless you call it yourself. This way, if you have multiple
    Python scripts in the same folder, you can have one script import another script
    to call the functions defined within it without worrying about calling the latter
    script’s <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function.
  prefs: []
  type: TYPE_NORMAL
- en: After I create this template script, I start filling in the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function with whatever I want the script to do. Putting the main logic of your
    script inside a function allows you to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement to end <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> early,
    which will quit the script early. You can’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    when you’re not in a function.
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, you’ll put this into practice by writing a script
    to start investigating BlueLeaks.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8-1: Traverse the Files in
    BlueLeaks</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To efficiently investigate datasets, you need to be able to write code that
    looks through large collections—sometimes thousands or millions—of files for you.
    In this exercise, you’ll learn various ways to traverse the filesystem in Python
    using functions in the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>
    module, working with the BlueLeaks dataset. You’ll also rely on the foundational
    skills you learned in [Chapter 7](chapter7.xhtml), like using variables, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops, and <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: As you read along and run the scripts, feel free to modify the code however
    you’d like and try running those versions too. You might discover revelations
    I didn’t think to look for.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">List the Filenames
    in a Folder</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Start by using <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>
    to list the files in the *BlueLeaks-extracted* folder. In your text editor, create
    a file called *list-files1.py* and enter this short script (or copy and paste
    it from [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/list<wbr>-files1<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/list-files1.py)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, the script imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>
    module. It then defines the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    with the path of the *BlueLeaks-extracted* folder (update the script to include
    the path of this folder on your own computer). The <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>
    function takes the path to the folder as an argument and returns a list of filenames
    in that folder. The code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to loop through the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir(blueleaks_path)</samp>,
    displaying each filename.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Windows paths include the backslash character (<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">\</samp>),
    which Python strings consider an escape character. For example, if your* BlueLeaks-extracted
    *folder is located at* D:\BlueLeaks-extracted*, Python will misinterpret the string
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">"D:\BlueLeaks-extracted"</samp>,
    assuming that <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">\B</samp>
    is a special character. To escape your backslashes for any Windows path you store
    as a string, use <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">\\</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">\</samp>. In
    this case, set the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">blueleaks_path</samp>
    string to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">"D:\\BlueLeaks-extracted"</samp>.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run this script. Here’s what the output looks like on my computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Next, you’ll try something slightly more advanced. Instead of just listing the
    filenames in BlueLeaks, you’ll check each filename to see whether it’s a folder,
    and if so, you’ll open each of those folders and count how many files and subfolders
    they contain.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Count the Files and
    Folders in a Folder</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Create a file called *list-files2.py* and enter the following code (or copy
    and paste it from [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/list<wbr>-files2<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/list-files2.py)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This script counts the number of files and folders it finds within each BlueLeaks
    folder. It starts like *list-files1.py* does, importing <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>
    and defining the <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    variable (remember to update the variable’s value to match the correct path on
    your computer).
  prefs: []
  type: TYPE_NORMAL
- en: The first <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop cycles
    through the filenames in your *BlueLeaks-extracted* folder, this time saving each
    filename in the <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder</samp>
    variable, so its value will be something like <samp class="SANS_TheSansMonoCd_W5Regular_11">miacx</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ncric</samp> ❶. The script then
    sets the value of the new <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder_path</samp>
    variable accordingly. The <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.join()</samp>
    function connects filenames together to make complete paths. Its first argument
    is the starting path, and it adds all other arguments to the end of that path.
    For example, if the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">miacx</samp>, then this function
    will return the string <samp class="SANS_TheSansMonoCd_W5Regular_11">/Volumes/datasets/BlueLeaks-extracted/miacx</samp>
    on my computer (the output will be different if your <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    is different or if you’re using Windows and your filenames use backslashes instead
    of slashes).
  prefs: []
  type: TYPE_NORMAL
- en: Since you want to look inside <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder_path</samp>
    and count the number of files and folders it contains, the script needs to check
    that it’s actually a folder and not a file, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isdir()</samp>
    function ❷. If <samp class="SANS_TheSansMonoCd_W5Regular_11">bl_folder_path</samp>
    isn’t a folder, the script runs the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement. This statement, which can run only inside of loops, tells Python to
    immediately continue on to the next iteration of the loop. In short, if the script
    comes across a file instead of a folder, it ignores it and moves on.
  prefs: []
  type: TYPE_NORMAL
- en: The script then prepares to count the number of files and folders within each
    individual BlueLeaks folder as the code loops by defining the variables <samp
    class="SANS_TheSansMonoCd_W5Regular_11">files_count</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">folders_count</samp>
    with a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> ❸.
  prefs: []
  type: TYPE_NORMAL
- en: A second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop loops
    through the files in the BlueLeaks folder from the first <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, saving each filename in the <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    variable ❹. Inside this loop, the script defines <samp class="SANS_TheSansMonoCd_W5Regular_11">filename_path</samp>
    as the absolute path for the filename under consideration. For instance, if the
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> is a string
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory.csv</samp>, then
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">filename_path</samp>
    would be a string like <samp class="SANS_TheSansMonoCd_W5Regular_11">/Volumes/datasets/BlueLeaks-extracted/211sfbay/Directory.csv</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The script then checks to see if this absolute path is a file or a folder, using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isfile()</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isdir()</samp> functions
    ❺. If the path is a file, the script increments the <samp class="SANS_TheSansMonoCd_W5Regular_11">files_count</samp>
    variable by 1; if it’s a folder, the script increments <samp class="SANS_TheSansMonoCd_W5Regular_11">folders_count</samp>
    by 1\. When the second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop finishes running, these two variables should contain the total count of files
    and folders for the BlueLeaks folder you’re currently looping through in the first
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop. Finally, the script
    displays an f-string that shows these numbers ❻.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try running the script. The output should show how many files and folders are
    contained in each BlueLeaks folder, potentially with the list of folders in a
    different order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So far, you’ve combined various functions in the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>
    module to make a list of filenames in your BlueLeaks folder and check whether
    each name actually refers to a file or to another folder. Now it’s time to learn
    to write code that can also traverse the BlueLeaks folder’s nested folders.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Traverse Folders with os.walk()</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s say you want to write a program that displays all of the files in a folder
    and its subfolders, and its subsubfolders, and so on. When you have nested folders
    but don’t actually know how deep the folder structure goes, listing all of the
    filenames just by using <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.isfile()</samp>, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">os.path .isdir()</samp> isn’t so simple.
    Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> function
    solves this problem.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> function
    takes a path to a folder as an argument and returns a list of *tuples*, or multiple
    values contained in a single value. To define a tuple, you place all of the values,
    separated by commas, within parentheses. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">(3,
    4)</samp> is a tuple, as is <samp class="SANS_TheSansMonoCd_W5Regular_11">("cinco",
    "seis", "siete")</samp>. Tuples can also contain mixed types like <samp class="SANS_TheSansMonoCd_W5Regular_11">(1,
    "dos")</samp> and can contain any number of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> function
    returns a list of tuples where each tuple contains three values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'where <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp> is a string,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp> is a list of
    strings, and <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp> is
    a list of strings. For example, the following code loops through the return value
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk(path)</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops
    to loop through lists, you normally assign just a single variable to each item
    in the list. However, since each item is a tuple, you can assign three variables
    to it: <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>. In each loop,
    the values for this set of variables will be different: the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>
    is the path to a folder, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp>
    is a list of subfolders inside that folder, and the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>
    is a list of files inside that folder.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you have a folder called *example* that contains these
    subfolders and files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This folder has two subfolders: *downloads* (containing *screenshot.png* and
    *paper.pdf*) and *documents*. The *documents* folder has its own subfolders: *work*
    (containing *finances.xlsx*) and *personal*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands loop through the return value of <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk
    ("./example")</samp>, where *./example* is the path to this *example* folder,
    to find the values of <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>
    for each loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this command returns the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code loops once for each folder, including all subfolders, with the path
    to that folder stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>.
    The list of subfolders in that folder is stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp>,
    and the list of files is stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>.
    Once you’ve looped through the folder and all of its subfolders, the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: Any time you need to traverse all of the files in a dataset that contains lots
    of nested folders, you’ll want to use <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>.
    With a single <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, you’ll
    be able to write code that inspects each file in the entire dataset. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp> function has many uses,
    including figuring out which files are the largest or smallest, as you’ll see
    next.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8-2: Find the Largest Files
    in BlueLeaks</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, you’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>
    to write a script that looks through all the files, folders, and subfolders in
    BlueLeaks; measures the size of each file; and displays the filenames for files
    over 100MB. This code allows you to loop through all of the files in a folder,
    no matter how deep the folder structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called *find-big-files.py* and enter the following code (or copy
    and paste it from [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/find<wbr>-big<wbr>-files<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/find-big-files.py)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function,
    the script first defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    variable as the path of the *BlueLeaks-extracted* folder and loops through all
    of the files in the entire BlueLeaks dataset using the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>
    function. Inside each loop in the first <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop are the <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">subdirnames</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>
    variables. Each item in the list that <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>
    returns represents a different folder or subfolder in the BlueLeaks dataset, so
    by the time this loop finishes, the code will have traversed the entire dataset.
  prefs: []
  type: TYPE_NORMAL
- en: To find the biggest files, the next step is to look at each file with another
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, this time looping
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">filenames</samp>. Inside
    this second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, the
    script defines <samp class="SANS_TheSansMonoCd_W5Regular_11">absolute_filename</samp>
    to be the absolute path to the filename. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">dirname</samp>
    tells the script which folder it’s looking in, and <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    tells the script which file it’s looking at, the script passes these values into
    <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.join()</samp> to combine
    them, creating the absolute path to the filename.
  prefs: []
  type: TYPE_NORMAL
- en: A new function, <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.getsize()</samp>,
    returns the size, in bytes, of the file under consideration and stores it in the
    variable <samp class="SANS_TheSansMonoCd_W5Regular_11">size_in_bytes</samp>. The
    script then converts this value from bytes to megabytes (storing that in the variable
    <samp class="SANS_TheSansMonoCd_W5Regular_11">size_in_mb</samp>) and checks if
    it’s greater than or equal to 100MB. If it is, the output displays its filename
    and file size in megabytes with the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try running the script. It will take longer than the previous scripts in this
    chapter, because this time, you’re measuring the size of every single file in
    BlueLeaks. Here’s what the output looks like when I run it (your output may be
    displayed in a different order):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The script should display the absolute paths of the 101 files in BlueLeaks that
    are at least 100MB, along with each file’s size.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Third-Party Modules</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to built-in modules, Python also supports third-party modules that
    you can easily incorporate into your own code. Most Python scripts that I write,
    even simple ones, rely on at least one third-party module (when a Python program
    depends on third-party modules, they’re called *dependencies*). In this section,
    you’ll learn how to install third-party modules and use them in your own scripts.
  prefs: []
  type: TYPE_NORMAL
- en: The Python Package Index (PyPI) contains hundreds of thousands of third-party
    Python *packages*, or bundles of Python modules, and subpackages. Pip, which stands
    for Package Installer for Python, is a package manager similar to Ubuntu’s apt
    or macOS’s Homebrew used to install packages hosted on PyPI. You can search for
    packages on PyPI’s website ([*https://<wbr>pypi<wbr>.org*](https://pypi.org)),
    then install a package by running the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">python3
    -m pip install</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">package_name</samp>
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I frequently use a package called Click, which stands for Command
    Line Interface Creation Kit. The <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    Python module makes it simple to add command line arguments to your scripts. To
    see what happens when you try importing this module before you’ve installed it,
    open a Python interpreter and run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">import
    click</samp>. Assuming you don’t already have the package installed, you should
    see a <samp class="SANS_TheSansMonoCd_W5Regular_11">ModuleNotFoundError</samp>
    error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now exit the Python interpreter and install <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    with pip by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the Python interpreter again and try importing <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If no error messages pop up, you’ve successfully imported the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    module, and its additional features are now available for you to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to uninstall a package is <samp class="SANS_TheSansMonoCd_W5Regular_11">python3
    -m pip uninstall</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">package_name</samp>.
    Try uninstalling <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when I ran this command, the output listed the files that pip
    would need to delete to uninstall the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    module, then asked if I wanted to proceed. I entered <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    and pressed ENTER, and the files were deleted and the module uninstalled.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install multiple Python packages at once like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The same is true of uninstalling.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common to define the Python packages that your script requires inside
    a file called *requirements.txt*, then install all of them at once with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">python3 -m pip install -r requirements.txt</samp>
    command. For example, suppose in addition to using <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>,
    you want to use the HTTP client <samp class="SANS_TheSansMonoCd_W5Regular_11">httpx</samp>
    to load web pages inside Python and the <samp class="SANS_TheSansMonoCd_W5Regular_11">sqlalchemy</samp>
    module to work with SQL databases. To include all three in your Python script,
    first create a *requirements .txt* file with each package name on its own line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the following command to install them simultaneously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this command installs more than just those three Python packages:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">rfc3986</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">certifi</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sniffio</samp>, and so on are also
    included. That’s because <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">httpx</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sqlachemy</samp>
    have dependencies of their own. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">httpcore</samp>
    is a dependency of the <samp class="SANS_TheSansMonoCd_W5Regular_11">httpx</samp>
    package, so it installs that as well. To summarize, the *requirements.txt* file
    defines your project’s dependencies, each of which might depend on its own list
    of packages.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*To learn more about how to use* *httpx* *and other Python modules to automate
    interacting with websites, check out [Appendix B](appendixB.xhtml). I recommend
    waiting until you complete [Chapters 7](chapter7.xhtml), [8](chapter8.xhtml),
    [9](chapter9.xhtml), and [11](chapter11.xhtml), however, since the instructions
    covered in [Appendix B](appendixB.xhtml) rely on the skills you’ll pick up in
    those chapters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to install third-party modules, you’ll practice using
    Click.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8-3: Practice Command Line
    Arguments with Click</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you learned in the previous section, the Click package makes it simple to
    add command line arguments to your scripts. You can use it to define variables
    to pass into your <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function from the terminal, without having to define those variables in your code.
    In this exercise, you’ll learn how to use Click by writing a sample script in
    preparation for using this module in later exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the Click package with pip again by running <samp class="SANS_TheSansMonoCd_W7Bold_B_11">python3
    -m pip install click</samp>. Next, open your text editor and enter the following
    Python script, *exercise-8-3.py* (or copy and paste it from [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/exercise<wbr>-8<wbr>-3<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/exercise-8-3.py)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: First, the script imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    module. It then runs a few *decorators*, function calls that begin with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">@</samp> and add functionality to another
    function you’re about to define—the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function, in this case. The <samp class="SANS_TheSansMonoCd_W5Regular_11">@click.command()</samp>
    decorator tells Click that <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    is a command, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">@click .argument("name")</samp>
    decorator tells Click that this command has an argument called <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the script defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function, which takes <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    as an argument. This function has a docstring, <samp class="SANS_TheSansMonoCd_W5Regular_11">Simple
    program that greets NAME</samp>. Click uses this docstring for its commands when
    it builds the output for <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp>,
    as you’ll see shortly. The <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function simply displays a string with the name you passed in as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the script calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function. Notice that even though <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    requires an argument (<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>),
    the script doesn’t explicitly pass that argument in when calling the function.
    This is where the magic of the Click decorators comes in. When the script calls
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>, Click will figure
    out what arguments it needs to pass in, find their values from the CLI arguments,
    and pass them in for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When you run the program, if you don’t pass in the correct CLI arguments, Click
    tells you what you did wrong. As you can see, you’re missing the required <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NAME</samp> argument. Click also tells
    you that you can get help by running the script again with the <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp>
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try running the <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp>
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This time, the output shows a description of the program based on the docstring.
    Any CLI program that uses Click will display the docstring for the command when
    you run it with <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try running the command again, this time passing in a name. For example, here’s
    what happens when I pass in <samp class="SANS_TheSansMonoCd_W5Regular_11">Eve</samp>
    as the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can read more about using Click at* [https://click.palletsprojects.com](https://click.palletsprojects.com)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Avoiding Hardcoding with Command Line
    Arguments</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you’ve seen in previous chapters, CLI arguments let you run the same program
    in many different ways, targeting different data. For example, in [Chapter 4](chapter4.xhtml),
    you used the <samp class="SANS_TheSansMonoCd_W5Regular_11">du</samp> command to
    estimate the disk space of a folder by adding the folder’s path as an argument.
    In <samp class="SANS_TheSansMonoCd_W5Regular_11">du -sh --apparent-size</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">path</samp>, the arguments
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">-sh</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">--apparent-size</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">path</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">du</samp> command would be
    much less useful if it could measure disk space for only a single hardcoded folder.
    *Hardcoding* means embedding information, like a path, directly into source code.
    You can avoid hardcoding anything in your CLI programs by having the user provide
    this information as arguments when running them.
  prefs: []
  type: TYPE_NORMAL
- en: Passing paths into scripts, rather than hardcoding them, makes for a better
    user experience. In previous exercises in this chapter, you hardcoded the path
    to your copy of the BlueLeaks dataset into your Python scripts. If you were to
    pass the appropriate path in as an argument, however, other people could use your
    script without editing it—they could just pass in *their* path when they ran it.
  prefs: []
  type: TYPE_NORMAL
- en: Using arguments rather than hardcoding can also make your scripts more universally
    useful. For example, in Exercise 8-2, you wrote a script to find all of the files
    that are at least 100MB in the BlueLeaks dataset. Using CLI arguments, you could
    make this script work for any dataset you get your hands on, not just BlueLeaks,
    and for any minimum file size, allowing you to run it in a variety of situations.
    You’d just need to pass in the dataset path and the minimum file size as CLI arguments.
    You’ll try this out in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8-4: Find the Largest Files
    in Any Dataset</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, you’ll modify the script you wrote in Exercise 8-2 to make
    it work for any dataset, and for any minimum file size, using CLI arguments. In
    the following chapters, you’ll write simple Python scripts that use Click for
    CLI arguments, so you can provide the paths to the datasets you’ll be working
    with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called *exercise-8-4.py*, and copy and paste the *exercise-8-2
    .py* code into it. Next, make the following modifications to the code, highlighted
    in bold (or find the full modified script at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/exercise<wbr>-8<wbr>-4<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/exercise-8-4.py)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This code imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    module at the top of the file. Next, it adds Click decorators before the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function: <samp class="SANS_TheSansMonoCd_W5Regular_11">@click.command()</samp>
    makes the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function
    a Click command, and <samp class="SANS_TheSansMonoCd_W5Regular_11">@click.argument()</samp>
    adds <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">min_file_size</samp>
    as arguments. The script specifies with <samp class="SANS_TheSansMonoCd_W5Regular_11">type=click.INT</samp>
    that the <samp class="SANS_TheSansMonoCd_W5Regular_11">min_file_size</samp> argument
    should be an *integer*, or a whole number, as opposed to a string. Then it adds
    <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">min_file_size</samp>
    as arguments to the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function and adds a docstring that describes what this command does.'
  prefs: []
  type: TYPE_NORMAL
- en: The new script uses arguments instead of hardcoded values. It deletes the line
    that defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    variable, and in the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>
    function call, it changes <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    to just <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp>, which is the
    argument. Finally, it changes <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">size_in_mb</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">min_file_size</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now use this program to find big files in any folder in the BlueLeaks
    dataset or elsewhere. For example, here’s what it looks like when I search for
    all files that are at least 500MB in */Applications* on my Mac:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, I have only two apps installed that include files this big:
    Dangerzone and Docker Desktop.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how to add CLI arguments to your Python scripts using Click,
    you should be able to avoid hardcoding information like dataset paths in your
    future programs.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll switch gears and explore a new powerful type of Python variable
    called dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Dictionaries</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the course of your investigations, sometimes you’ll need to keep track of
    data with more structure than a simple list. To do so, you can use Python dictionaries.
    Instead of a collection of items, a *dictionary* (*dict* for short) is a collection
    of keys that map to values. *Keys* are labels that you use to save or retrieve
    information in a dictionary, and *values* are the actual information being saved
    or retrieved. Nearly every Python script I write that deals with data uses dictionaries.
    In this section, you’ll learn how to define dictionaries, get values from them,
    add values to them, and update existing values in them.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Dictionaries</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Dictionaries are defined using braces (<samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>and}),
    sometimes referred to as curly brackets. Inside the braces is a list of key-value
    pairs in the format <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">key</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">value</samp>,
    where each pair is separated from the next by commas—for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">{"country":
    "Italy", "drinking_age": 18}</samp>. For longer dictionaries, you can make your
    code more readable by putting each key-value pair on its own line.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-1](#list8-1) shows an example dictionary stored in the variable
    <samp class="SANS_TheSansMonoCd_W5Regular_11">capitals</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1: A dictionary stored
    in the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">capitals</samp>
    variable</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the keys are country names and the values are the capitals of
    those countries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each key in a dictionary can have only one value. If you try to set the same
    key more than once, Python will save the version you last set. For example, if
    you define a dictionary and use the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    key more than once, the dictionary will overwrite the previous value with the
    most recent one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you can also use lists, or other dictionaries, as values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the value for the key <samp class="SANS_TheSansMonoCd_W5Regular_11">names</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">['Alice', 'Bob']</samp>, which
    itself is a list. You can use a combination of lists and dictionaries to organize
    pretty much any type of data, no matter how complicated, allowing you to more
    easily work with it in Python.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Getting and Setting
    Values</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To retrieve an item you’ve stored inside a dictionary, add square brackets
    containing the item’s key to the end of the dictionary name. If you try to use
    a key you haven’t defined, your script will crash with a <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyError</samp>.
    For example, here’s how to look up the capitals of certain countries in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">capitals</samp> dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run <samp class="SANS_TheSansMonoCd_W5Regular_11">capitals["Kenya"]</samp>,
    Python throws the error message <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyError:
    ''Kenya''</samp>. This means that <samp class="SANS_TheSansMonoCd_W5Regular_11">Kenya</samp>
    isn’t a valid key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">capitals</samp>
    dictionary. You can see that the only keys defined in [Listing 8-1](#list8-1)
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">United States</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">India</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">South
    Africa</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Brazil</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Germany</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Russia</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">China</samp>. Because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Kenya</samp> isn’t a key in this dictionary,
    you can’t retrieve its value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add new key-value pairs to a dictionary, or update an existing one,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This code defines a new key, <samp class="SANS_TheSansMonoCd_W5Regular_11">Kenya</samp>,
    with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">Nairobi</samp>. It
    also updates an existing key, <samp class="SANS_TheSansMonoCd_W5Regular_11">United
    States</samp>, to have the value <samp class="SANS_TheSansMonoCd_W5Regular_11">Mar-a-Lago</samp>,
    overwriting its old value, which used to be <samp class="SANS_TheSansMonoCd_W5Regular_11">Washington,
    DC</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Navigating Dictionaries and Lists in
    the Conti Chat Logs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can combine dictionaries and lists in a single flexible data structure that
    allows you to represent a wide variety of information. If you’re writing Python
    code to work with datasets, chances are you’re going to need both. You might directly
    load the data in this format, or you might create your own dictionaries and lists
    to store aspects of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To describe how to use data structures that include a combination of dictionaries
    and lists, I’ll use an example from a real dataset. The day after Russia invaded
    Ukraine on February 24, 2022, the notorious Russian ransomware gang Conti, known
    for hacking companies around the world and extorting millions of dollars from
    them, published a statement on its website throwing its full support behind the
    Russian government. It threatened any “enemy” who launched cyberattacks against
    Russia with retaliation against their “critical infrastructure.” Three days later,
    a Ukrainian security researcher anonymously leaked 30GB of internal data from
    Conti: hacking tools, training documentation, source code, and chat logs. The
    Conti chat logs originally came in the form of JSON files, which is structured
    data. When you load JSON files into Python, they’ll automatically be loaded as
    a combination of dictionaries and lists.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll look through some of these chat logs in order to practice
    working with real leaked data stored in dictionaries and lists. Using Python code,
    you’ll learn how to navigate these structures to access specific pieces of data
    as well as how to quickly loop through the chat logs and select just the parts
    you’re interested in.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring Dictionaries
    and Lists Full of Data in Python</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can download the complete Conti dataset from [*https://<wbr>ddosecrets<wbr>.com<wbr>/wiki<wbr>/Conti<wbr>_ransomware<wbr>_chats*](https://ddosecrets.com/wiki/Conti_ransomware_chats).
    However, for this section, you’ll use just one file from the dataset, *2022-02-24-general.json*,
    which the Ukranian security researcher extracted from a chat system called RocketChat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download *2022-02-24-general.json* from [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/2022<wbr>-02<wbr>-24<wbr>-general<wbr>.json*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/2022-02-24-general.json).
    Open a terminal, change to the folder where you stored this file, and open a Python
    interpreter. Load this file into a dictionary with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp>
    module and loads the data from *2022-02-24-general.json* into the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    variable. The chat logs from this file are too long to display in their entirety,
    but [Listing 8-2](#list8-2) shows a snippet of the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    dictionary that demonstrates its structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: Conti chat logs
    from RocketChat</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> variable is a
    dictionary with two keys, <samp class="SANS_TheSansMonoCd_W5Regular_11">messages</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">success</samp>. You access the
    value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">messages</samp> key,
    which is a list of dictionaries, using the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp>
    ❶. You can tell that the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp>
    is a list because it’s enclosed in square brackets ([and]), and you can tell that
    the items inside it are dictionaries because they’re enclosed in braces (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">{</samp>and}). Almost all of the data
    in this file is stored in this list.
  prefs: []
  type: TYPE_NORMAL
- en: Each dictionary in the <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp>
    list describes a chat message. This snippet of code includes only one of the dictionaries,
    the ninth chat message in the list (I snipped out the first eight messages, so
    you can’t tell that it’s the ninth without looking at the original file). You
    can access the dictionary that contains that specific chat message using the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"][8]</samp>. (Remember,
    in programming we start counting at 0, not 1, so the first item is at index 0,
    the second item is at index 1, and so on.) If you run the command <samp class="SANS_TheSansMonoCd_W5Regular_11">print(data["messages"][8])</samp>
    to display the dictionary for the ninth message, the output should match the message
    in the listing. Notice that just as you place index numbers within brackets to
    select from lists, you place keys within brackets to select from dictionaries,
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">["messages"]</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">["success"]</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: You can also access the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">success</samp>
    key with <samp class="SANS_TheSansMonoCd_W5Regular_11">data["success"]</samp>.
    Its value is the Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    ❷. I’m not entirely sure what this means, but I suspect that the <samp class="SANS_TheSansMonoCd_W5Regular_11">success</samp>
    key was left over from whatever system the Ukrainian researcher used to export
    these chat messages from RocketChat, confirming that exporting the data was successful
    and that there were no errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file from which I loaded this code contained 604 different chat messages,
    each in its own dictionary, that were sent in Conti’s #general RocketChat channel
    on February 24, 2022\. I discovered that this list has 604 items by measuring
    its length with the <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp>
    function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The dictionary for each chat message has many keys: <samp class="SANS_TheSansMonoCd_W5Regular_11">_id</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">rid</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">msg</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">urls</samp>,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find out what types of data these keys contain using the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">key_variable</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dictionary</samp>
    syntax, and you can determine a variable’s data type using the <samp class="SANS_TheSansMonoCd_W5Regular_11">type()</samp>
    function. Try this out using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This command loops through the <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"][8]</samp>
    dictionary and stores each key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>
    variable. Then, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    function and an f-string, it displays the key (<samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>)
    and the type of data stored in that key, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the output, the values at the <samp class="SANS_TheSansMonoCd_W5Regular_11">_id</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">rid</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">msg</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ts</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">_updatedAt</samp>
    keys are all strings. The value at the <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp>
    key is a dictionary. The value at the <samp class="SANS_TheSansMonoCd_W5Regular_11">urls</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mentions</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">channels</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">md</samp> keys are lists.
  prefs: []
  type: TYPE_NORMAL
- en: You can get the value of the data at the key using <samp class="SANS_TheSansMonoCd_W5Regular_11">data['messages'][8][key]</samp>.
    Remember that to retrieve the value of a key in a dictionary, you put the key
    in square brackets. In this case, the key itself is stored in the variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">key</samp>, so you can get its value by
    putting <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp> inside the square
    brackets. To find out what type of data that is, then, just pass the value into
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">type()</samp> function.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Selecting Values
    in Dictionaries and Lists</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When working with datasets, you often end up with structures like this: a mess
    of dictionaries and lists that you need to make sense of. Being able to select
    the exact values you’re looking for is an important skill. To practice navigating
    through dictionaries and lists, take a closer look at the value of just one of
    these keys, the <samp class="SANS_TheSansMonoCd_W5Regular_11">md</samp> key, by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output, you can tell that this value is a list because it’s surrounded
    by square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The list’s single item is a dictionary, which is surrounded by braces. The dictionary
    has a <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> key whose value
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">PARAGRAPH</samp>, as well as
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> key. The value of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> is another list with
    one item containing another dictionary; that dictionary itself contains <samp
    class="SANS_TheSansMonoCd_W5Regular_11">type</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    keys, where the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">PLAIN_TEXT</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'These data structures can have as many sublists and subdictionaries as you’d
    like. To select specific values, after the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    variable keep adding square brackets containing an index (if it’s a list) or a
    key (if it’s a dictionary) until you get to the value you’re looking for. For
    example, use the following command to access the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    key in the inner dictionary within the inner list, which is in another <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    key in the outer dictionary in the outer list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You already know that <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"][8]</samp>
    is a dictionary that represents a chat message. To find the value of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">md</samp> key in that dictionary, you
    include<samp class="SANS_TheSansMonoCd_W5Regular_11">["md"]</samp> in the command.
    As you can tell from inspecting the structure in [Listing 8-2](#list8-2), this
    is a list with one item, so adding <samp class="SANS_TheSansMonoCd_W5Regular_11">[0]</samp>
    selects that item. This item is a dictionary, and you select the value of its
    <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> key by adding <samp
    class="SANS_TheSansMonoCd_W5Regular_11">["value"]</samp>. This item is another
    list with one item, so you again add <samp class="SANS_TheSansMonoCd_W5Regular_11">[0]</samp>
    to select that one item. This is yet another dictionary, so you can select the
    value of the final inner <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    key by adding another <samp class="SANS_TheSansMonoCd_W5Regular_11">["value"]</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In English, the message that you just displayed says, “Some American Senators
    suggest blocking PornHub in Russia in addition to social networks!” It was posted
    right after Russia started its invasion of Ukraine, and US and European leaders
    immediately began imposing economic sanctions on Russia. After invading Ukraine,
    the Russian government censored access to Twitter and Facebook from the Russian
    internet. Rumors spread that PornHub, a popular American porn website, would block
    access to Russian users (though this didn’t happen). This same user followed up
    their first post with “That’s it, we’re done,” and then “They will take away our
    last joys!”
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Analyzing Data Stored
    in Dictionaries and Lists</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Whenever I work with any sort of structured data, I find myself looping through
    a list of dictionaries and selecting specific pieces of data. As long as you understand
    its structure, you can write your own similar code to quickly pull out the relevant
    information, no matter what dataset you’re working with. For example, you might
    want to view the chat logs in the format <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">timestamp
    username</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">message</samp>
    in order to hide the unimportant sections of data so that you can directly copy
    and paste the relevant parts into machine translation systems like DeepL or Google
    Translate. Run the following commands to display all of the messages in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp> in that format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Since <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp>
    is a list, each time the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop in this command runs, it updates the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>
    variable to a different item in that list. In this case, each item is a different
    dictionary. Inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function
    displays three values: the timestamp (<samp class="SANS_TheSansMonoCd_W5Regular_11">message[''ts'']</samp>),
    the username (<samp class="SANS_TheSansMonoCd_W5Regular_11">message[''u''][''username'']</samp>),
    and the message itself (<samp class="SANS_TheSansMonoCd_W5Regular_11">message[''msg'']</samp>).'
  prefs: []
  type: TYPE_NORMAL
- en: You can change this command to display whatever information you’d like from
    each message. Maybe you’re interested is the user’s ID rather than their username.
    In that case, you could display <samp class="SANS_TheSansMonoCd_W5Regular_11">message['u']['_id']</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous output shows the same messages about PornHub just discussed, as
    well as a message posted just before that from another user, <samp class="SANS_TheSansMonoCd_W5Regular_11">rags</samp>.
    If you’re interested in seeing only the messages posted by <samp class="SANS_TheSansMonoCd_W5Regular_11">rags</samp>,
    view those by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is similar to the previous example. A <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop loops through each message in <samp class="SANS_TheSansMonoCd_W5Regular_11">data["messages"]</samp>,
    and then a <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> statement
    displays specific pieces of information from that message. This time, though,
    each loop also contains an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. Each time the code finds another message, it checks to see if the username
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">rags</samp> and, if so, displays
    the message. Otherwise, it moves on to the next message. You should get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, suppose you want to figure out how many messages each person posted,
    perhaps to find the most active poster in the #general chatroom on this day. The
    simplest way to do this is to create a new empty dictionary yourself and then
    write code to fill it up. Run the following command to create an empty dictionary
    called <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The keys in this dictionary will be usernames, and the values will be the number
    of posts from that user. Fill up the <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp>
    dictionary with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Again, this code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to loop through the messages. Next, it defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">username</samp>
    variable as <samp class="SANS_TheSansMonoCd_W5Regular_11">message["u"]["username"]</samp>,
    the username of the person who posted the message the code is currently looping
    through. Next, using an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement, the code checks to see if this username is already a key in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp> dictionary. (It’s not
    checking to see if the string <samp class="SANS_TheSansMonoCd_W5Regular_11">username</samp>
    is a key, but rather if the *value* of the <samp class="SANS_TheSansMonoCd_W5Regular_11">username</samp>
    variable, like <samp class="SANS_TheSansMonoCd_W5Regular_11">thomas</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">rags</samp>, is a key.)
  prefs: []
  type: TYPE_NORMAL
- en: If this user doesn’t exist in the <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp>
    dictionary, the program adds a key to this dictionary and sets the value at that
    key to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, with the line <samp
    class="SANS_TheSansMonoCd_W5Regular_11">user_posts[username]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. Otherwise, it increases
    the value by 1, with <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts[username]</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    By the time the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    finishes running, the <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp>
    dictionary should be complete. The keys should be all of the usernames found in
    the messages, and the values should be the total number of messages for that user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to display the information inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">user_posts</samp>
    dictionary, viewing the data you just collected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the users who posted in Conti’s #general chatroom, in their RocketChat
    server, on the day Russia invaded Ukraine in 2022\. The user *kermit* posted 151
    times, more than any other user.'
  prefs: []
  type: TYPE_NORMAL
- en: In these examples, you looped through hundreds of chat messages, but the same
    concepts would work with millions or billions of messages or with data representing
    any sort of information.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to work with flexible data structures that
    combine dictionaries and lists, including how to pick out specific elements that
    you’re interested in and how to quickly traverse them by looping through them.
    These skills will often prove useful when you’re writing Python scripts to help
    you analyze data.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’re familiar with data structures that combine dictionaries and
    lists, it’s time to create your own to map out the CSV files in BlueLeaks.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8-5: Map Out the CSVs in
    BlueLeaks</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each folder in BlueLeaks includes data from a single hacked law enforcement
    website in the form of hundreds of CSV files. These files contain some of the
    most interesting information in all of BlueLeaks, such as the contents of bulk
    email that fusion centers sent to local cops, or “suspicious activity reports.”
    In this exercise, you’ll construct a map of the contents of the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: By manually looking in different BlueLeaks folders, I noticed that each folder
    seems to have a file called *Company.csv* (each containing different content),
    but only one folder, *ncric*, has a file called *911Centers.csv*. Clearly, not
    all of the BlueLeaks sites have the same data. Which CSV files are in every folder
    in BlueLeaks, which are in some folders, and which are unique to a single folder?
    Let’s write a Python script to find out.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with most programming problems, there are multiple ways you could write
    a script that answers this question. If you feel comfortable enough with Python
    by now that you’d like a challenge, try writing one on your own. Otherwise, follow
    along with this exercise. Either way, the program must meet the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the script accept an argument called <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    using Click.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an empty dictionary called <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>.
    Your script should fill this dictionary with data. The keys should be CSV filenames,
    and the values should be lists of BlueLeaks folders that contain this CSV.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loop through all of the files and folders in <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>.
    For each folder, loop through all of the files it contains. For each CSV file,
    add data to the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>
    dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the contents of the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>
    dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In each step that follows, I’ll quote a snippet of code, explain how it works,
    and give you a chance to run it as is. You’ll then add more features to that code
    and run it again. It’s good practice to write code in small batches, pausing frequently
    to test that it works as you expect. This will help you catch bugs early, making
    the process of debugging much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accept a Command
    Line Argument</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Create an *exercise-8-5.py* file and enter the Python template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, instead of hardcoding the path to the BlueLeaks data like you did in
    Exercise 8-2, let’s use Click to pass in the path as a command line argument,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>. To do so,
    make the following modifications to your code (the added syntax is highlighted
    in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This code modifies the template to import the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    module, adds the correct decorators before the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function, adds the <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function,
    and adds a simple docstring to the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function so that running this script with <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp>
    will be more useful. Finally, it includes a line to display the value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>, so that you can
    confirm the code is working when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try running your script with <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp>
    to see if the help text works, and with a value for <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    to see if the argument is successfully sent to the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If your output looks like this, everything is working correctly so far.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Loop Through the
    BlueLeaks Folders</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    CLI argument, make the following modifications to your code to have it loop through
    all of the folders it finds in that path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: First, you import the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>
    module in order to be able to list all of the files in the *BlueLeaks-extracted*
    folder using the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>
    function. Inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function, a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop loops
    through the return value of <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir
    (blueleaks_path)</samp>, the list of filenames inside the folder at <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the loop, the code defines <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp>
    as the path of the specific BlueLeaks folder for the current loop. For example,
    if the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    is */Volumes/datasets/BlueLeaks-extracted*, and at this point in the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp>
    is *icefishx*, then the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp>
    will be */Volumes/datasets/BlueLeaks-extracted/icefishx*.
  prefs: []
  type: TYPE_NORMAL
- en: You want to look inside subfolders in the *BlueLeaks-extracted* folder, not
    inside files. If there are any files in that folder, you want to skip them. To
    meet these requirements, the code includes an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement that checks whether <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp>
    is actually a folder. Finally, the code displays the current value of <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run your script again. This time, pass in the real path to your *BlueLeaks
    -extracted* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The output should show that the <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp>
    variable holds just the name of the folder, like *bostonbric*, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_folder_path</samp>
    variable includes the full path to that folder, like */Volumes/datasets/BlueLeaks-extracted/bostonbric*.
    When you run this on your own computer, you may see these values in a different
    order than what’s shown here.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fill Up the Dictionary</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You now have a script that accepts <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    as an argument and then loops through every folder in that path. Adding the code
    in bold creates the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>
    dictionary and starts to fill it up with data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Your goal with this script is to map out which CSV files are in which BlueLeaks
    folders. To store this data, the code creates the empty dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>
    at the top of the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function. The next step is to fill up that dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: The code loops through all of the filenames in <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>,
    checking each to see if it’s a folder. Removing the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    statement in the previous iteration of the code, this code instead adds a second
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop that loops through
    all of the files in that specific BlueLeaks folder.
  prefs: []
  type: TYPE_NORMAL
- en: In this second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop,
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement checks whether
    the filename ends in *.csv*. This <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">lower()</samp>
    method on the <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> string,
    which returns a lowercase-only version of the string. The code then calls the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">endswith()</samp> method on that
    lowercase string, which returns a Boolean describing whether the string ends with
    the string that was passed in. If the string <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    ends with *.csv*, *.CSV*, or *.cSv*, the <samp class="SANS_TheSansMonoCd_W5Regular_11">lower()</samp>
    method will convert the file extension to *.csv*, and <samp class="SANS_TheSansMonoCd_W5Regular_11">endswith()</samp>
    will return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. If <samp
    class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> ends with anything else,
    like *.docx*, then <samp class="SANS_TheSansMonoCd_W5Regular_11">endswith()</samp>
    will return <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Each time the code following this <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement runs, it means the program has found a CSV (called <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>)
    in the current BlueLeaks folder (called <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp>).
    You want <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp> to
    be a dictionary where the keys are CSV filenames and the values are lists of folders.
    This code checks to see if the key <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    has been created in <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>,
    and if it hasn’t, creates it and set its value to an empty list (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>).
    Finally, after the code has confirmed that the <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    key has been created and is a list, it appends the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp>
    to that list.
  prefs: []
  type: TYPE_NORMAL
- en: These last lines are tricky, so let’s dig in a little more. The first time the
    script comes across a CSV filename (like *CatalogRelated.csv*), the script sets
    the value of that key in <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>
    to an empty list. If the same filename exists in another BlueLeaks folder later
    on, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">filename not
    in csv_to_folders</samp> will evaluate to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    (meaning <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders["CatalogRelated
    .csv"]</samp> already exists), so the code following the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement won’t run. Finally, the code appends <samp class="SANS_TheSansMonoCd_W5Regular_11">folder</samp>,
    the name of the BlueLeaks folder it’s currently looking in, to the list of folders
    that include that filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pause and try running the script so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This should take a moment to run but displays nothing, since you’re not yet
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function
    anywhere. The code is simply creating the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>
    dictionary and filling it up with data.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Display the Output</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'By the time the previous version of the script runs, the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>
    dictionary should contain a complete set of CSV filenames, mapped to the BlueLeaks
    sites where they were found. The following code should show you what the program
    found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The added code in bold loops through all of the keys (each a CSV filename) in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_to_folders</samp>, then displays
    the number of BlueLeaks folders that contain that file (<samp class="SANS_TheSansMonoCd_W5Regular_11">len(csv_to_folders[filename])</samp>)
    along with the filename itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find this final script at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/exercise<wbr>-8<wbr>-5<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/exercise-8-5.py).
    When you run it, the output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this script displays the number of folders at the beginning of each line
    of output, you can pipe the output into <samp class="SANS_TheSansMonoCd_W5Regular_11">sort
    -n</samp> to sort it numerically in ascending order, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the CSV files are in either a single folder or all 161 folders. However,
    there are a few exceptions: *Donations.csv* should be in 10 folders, *SARs.csv*
    should be in 25, and so on. This information would have taken you many hours of
    busywork to find manually.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you’ve learned the basics of navigating the filesystem in Python.
    You’ve seen how to loop through folders using <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>,
    loop through entire folder structures using <samp class="SANS_TheSansMonoCd_W5Regular_11">os.walk()</samp>,
    and look up information about the files and folders you find. In the next section,
    you’ll learn how to actually read the contents of a file you find and create new
    files yourself.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Reading and Writing Files</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To follow the rest of this book, you’ll need to know one more major Python
    concept: how to read and write files. During a data investigation, you’ll almost
    certainly need to read the contents of files, especially CSV and JSON files. You’ll
    also probably want to be able to create new files, by calculating some data of
    your own and saving it to a spreadsheet, for example. In this section you’ll learn
    how to open files and write or read content to them.'
  prefs: []
  type: TYPE_NORMAL
- en: In programming, to work with a file, you first need to open it and specify the
    *mode*—that is, whether you’re planning on *reading* from or *writing* to this
    file. To open an existing file and access its contents, open it for reading using
    mode <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>. To create a new file
    and put data in it, open it for writing using mode <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Opening Files</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To prepare to work with a file, whether for writing or reading, you use the
    built-in Python function <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp>.
    To open it for reading, you use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> statement,
    which tells Python that after the <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp>
    function is done running, it should set the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    to that function’s return value. The <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    variable is a *file object*, a type of variable that allows you to read or write
    data to a file. The first argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp>
    function is a path, and the second argument is the mode, which in this example
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">"r"</samp> for reading.
  prefs: []
  type: TYPE_NORMAL
- en: In the code block after the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp>
    statement, you can call methods on <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    to interact with the file. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">f.read()</samp>
    will read all of the data in the file and return it—in this case, storing it in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp> variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To open a file for writing, you set the mode to <samp class="SANS_TheSansMonoCd_W5Regular_11">"w"</samp>
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp> function returns
    the file object <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>. To write
    data into the file, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">f.write()</samp>
    method. Here, this code is opening a file called *output.txt* and writing the
    string <samp class="SANS_TheSansMonoCd_W5Regular_11">hello world</samp> to it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two sections, you’ll learn more about using <samp class="SANS_TheSansMonoCd_W5Regular_11">f.write()</samp>
    to write to files and <samp class="SANS_TheSansMonoCd_W5Regular_11">f.read()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">f.readlines()</samp> to read
    from files.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing Lines to
    a File</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Text files are made up of a series of individual characters. Consider a text
    file with these contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also represent the entire contents of this file as a Python string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The first character of the string is <samp class="SANS_TheSansMonoCd_W5Regular_11">H</samp>,
    then <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>,
    and so on. The 12th character (counting the space), <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>,
    is a special character known as a *newline* that represents a break between lines.
    As with shell scripting, the backslash is the escape character in Python, so a
    backslash followed by another character represents a single special character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Newlines are used to write lines to a file. Try running these commands in your
    Python interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>
    in the output represent the number of bytes written. The first <samp class="SANS_TheSansMonoCd_W5Regular_11">f.write()</samp>
    call wrote 12 bytes, because the string <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello
    World</samp> takes 11 bytes of memory: it has 11 characters, plus 1 for the newline
    character. The second call wrote 11 bytes, since <samp class="SANS_TheSansMonoCd_W5Regular_11">Hola
    Mundo</samp> takes 10 bytes of memory, plus 1 for the newline character.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your terminal, use the following command to view the file you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: If you had written the same code but without the newlines, the output would
    have been <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello WorldHola Mundo</samp>,
    with no line breaks.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reading Lines from
    a File</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Run the following command to read the file you just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This code reads all of the data from the file and saves it in the string <samp
    class="SANS_TheSansMonoCd_W5Regular_11">text</samp>. In fact, this might look
    familiar: earlier in this chapter, in the “Exploring Dictionaries and Lists Full
    of Data in Python” section, we used similar code to load the leaked Conti chat
    logs into a Python dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since splitting text files into multiple lines is so common, file objects also
    have a convenient method called <samp class="SANS_TheSansMonoCd_W5Regular_11">readlines()</samp>.
    Instead of reading all of the data into a file, it reads only one line at a time,
    and you can loop over the lines in a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop. Try this out by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This code opens the file for reading, then loops through each line in the file.
    Each line is stored in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">line</samp>,
    then displayed with the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    function. Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">line</samp>
    variable in each loop ends in <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>
    (for example, the first line is <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello
    World\n</samp>, not <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World</samp>),
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function
    automatically adds an extra <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>,
    the output shows an extra hard return after each line.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t want to display these extra newlines, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">strip()</samp>
    method to get rid of any whitespace (spaces, tabs, or newlines) from the beginning
    and end of the string. Run the same code, but this time strip out the newline
    characters on each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: You’ll practice the basics of how to read and write files in Python in the following
    exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8-6: Practice Reading and
    Writing Files</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Exercise 7-5, you wrote a function that converts a string to an alternating
    caps version, like <samp class="SANS_TheSansMonoCd_W5Regular_11">This book is
    amazing</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">ThIs bOoK Is aMaZiNg</samp>.
    To practice your newfound reading and writing files, in this exercise, you’ll
    write a script to create an alternating caps version of all of the text in an
    entire text file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’d like a challenge, you can try programming your own script to meet
    the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Accepts two arguments, <samp class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp>, using
    Click
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opens the file <samp class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp>
    for reading and loads its contents into the string <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opens the file <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp>
    for writing and saves the alternating caps version of <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>
    to that new file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, follow along with my explanation of the following code, which implements
    this iNcReDiBlY uSeFuL command line program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by copying the <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps()</samp>
    function that you wrote in Exercise 7-5 into a new Python script called *exercise-8-6.py*.
    Next, make the modifications highlighted in bold here (or copy the final script
    at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/exercise<wbr>-8<wbr>-6<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/exercise-8-6.py)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This code first imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    module, used for the arguments, and then defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps()</samp>
    function. Again, the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function is a Click command, but this time it takes two arguments, <samp class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Once the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function
    runs, the section for reading and writing files runs. The code opens <samp class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp>
    for reading and loads all of the contents of that file into the string <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>.
    It then opens <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp>
    for writing and saves the alternating caps version of that string into the new
    file. It does so by running <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps(text)</samp>,
    which takes <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp> as an argument
    and returns its alternating caps version, and then passes that return value directly
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">f.write()</samp>, writing it
    to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how this script works, try running it on the famous “To be,
    or not to be” soliloquy from *Hamlet*. First, save a copy of the soliloquy found
    at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-8<wbr>/shakespeare<wbr>.txt*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-8/shakespeare.txt)
    to a file called *shakespeare.txt*. Here are the original contents of *shakespeare.txt*,
    displayed using the <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp> command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, pass that filename into your script to create an alternating caps version
    of that file. Here’s what happens when I do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: First, I ran the script, passing in *shakespeare.txt* as <samp class="SANS_TheSansMonoCd_W5Regular_11">input_filename</samp>
    and *shakespeare-mocking.txt* as <samp class="SANS_TheSansMonoCd_W5Regular_11">output_filename</samp>.
    The script itself displayed no output (it doesn’t include any <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    statements), but it did create a new file. I then used <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp>
    to display the contents of that new file, which is indeed an alternating caps
    version of Hamlet’s soliloquy.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Congratulations on making it through a crash course in the fundamentals of Python
    programming! You’ve learned how to bring extra functionality to your scripts with
    built-in and third-party Python modules. You’ve also learned how to make your
    own CLI programs using Click, how to write code that traverses the filesystem,
    how to work with structured data using dictionaries and lists, and how to read
    and write files.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use these skills throughout the following chapters as you dig through
    various datasets, uncovering revelations you’d never discover otherwise. In the
    next chapter, you’ll write Python programs that loop through rows in the BlueLeaks
    CSV spreadsheets, transforming the data into a more workable format. You’ll get
    practice writing the content of law enforcement bulk email messages to files,
    and you’ll use Python to create your own CSV spreadsheets.
  prefs: []
  type: TYPE_NORMAL
