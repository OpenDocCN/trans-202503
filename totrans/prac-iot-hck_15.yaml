- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bluetooth Low Energy
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: '*Bluetooth Low Energy (BLE)* is a version of the Bluetooth wireless technology
    IoT devices often use because of its low-energy consumption and because the pairing
    process is simpler than in previous Bluetooth versions. But BLE can also maintain
    similar, and sometimes greater, communication ranges. You can find it in all sorts
    of devices, from common health gadgets like smart watches or smart water bottles
    to critical medical equipment like insulin pumps and pacemakers. In industrial
    environments, you’ll see it in sensors, nodes, and gateways of all types. It’s
    even used in the military, where weapon components such as rifle scopes operate
    remotely via Bluetooth. Of course, these have already been hacked.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: These devices use Bluetooth to take advantage of the simplicity and robustness
    of this radio communication protocol, but doing so increases a device’s attack
    surface. In this chapter, you’ll learn how BLE communications work, explore common
    hardware and software that communicates with BLE devices, and master techniques
    to effectively identify and exploit security vulnerabilities. You’ll set up a
    lab using the ESP32 development board and then walk through levels of an advanced
    Capture the Flag (CTF) exercise designed specifically for BLE. After reading this
    chapter, you should be ready to tackle some of the remaining unsolved challenges
    from this CTF laboratory.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: How BLE Works
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BLE consumes significantly less power than traditional Bluetooth, but it can
    transmit small amounts of data very efficiently. Available since the Bluetooth
    4.0 specification, BLE uses only 40 channels, covering the range of 2400 to 2483.5
    MHz. In contrast, traditional Bluetooth uses 79 channels in that same range.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Although every application uses this technology differently, the most common
    way BLE devices communicate is by sending advertising packets. Also known as *beacons*,
    these packets broadcast the BLE device’s existence to other nearby devices ([Figure
    11-1](#figure11-1)). These beacons sometimes send data, too.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![f11001](Images/f11001.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-1: BLE devices send advertising packets to elicit a SCAN request.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: To reduce power consumption, BLE devices only send advertising packets when
    they need to connect and exchange data; they sleep the rest of the time. The listening
    device, also called a *central device*, can respond to an advertising packet with
    a *SCAN request* sent specifically to the advertising device. The response to
    that scan uses the same structure as the advertising packet. It contains additional
    information that couldn’t fit on the initial advertising request, such as the
    full device name or any additional information the vendor needs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-2](#figure11-2) shows BLE’s packet structure.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![f11002](Images/f11002.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-2: BLE’s packet structure'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The preamble byte synchronizes the frequency, whereas the four-byte access address
    is a connection identifier, which is used in scenarios where multiple devices
    are trying to establish connections on the same channels. Next, the Protocol Data
    Unit (PDU) contains the advertising data. There are several types of PDU; the
    most commonly used are ADV_NONCONN_IND and ADV_IND. Devices use the ADV_NONCONN_IND
    PDU type if they don’t accept connections, transmitting data only in the advertising
    packet. Devices use ADV_IND if they allow connections and stop sending advertising
    packets once a connection has been established. [Figure 11-3](#figure11-3) shows
    an ADV_IND packet in a Wireshark capture.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 前导字节用于同步频率，而四字节的访问地址是连接标识符，用于多个设备尝试在相同频道上建立连接的场景。接下来，协议数据单元（PDU）包含广告数据。PDU 有几种类型；最常用的是
    ADV_NONCONN_IND 和 ADV_IND。如果设备不接受连接，它们使用 ADV_NONCONN_IND 类型的 PDU，只在广告数据包中传输数据。如果设备允许连接并且连接已建立，它们将停止发送广告数据包并使用
    ADV_IND 类型。图 [11-3](#figure11-3) 展示了 Wireshark 捕获中的 ADV_IND 数据包。
- en: '![f11003](Images/f11003.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![f11003](Images/f11003.png)'
- en: 'Figure 11-3: A Wireshark display tree showing a BLE advertising packet of type
    ADV_IND'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-3：Wireshark 显示树，展示了类型为 ADV_IND 的 BLE 广告数据包
- en: The type of packet used depends on the BLE implementation and project requirements.
    For example, you’ll find ADV_IND packets in smart IoT devices, such as smart water
    bottles or watches, because these seek to connect to a central device before performing
    further operations. On the other hand, you might find ADV_NONCONN_IND packets
    in beacons to detect an object’s proximity to sensors placed in various devices.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的数据包类型取决于 BLE 实现和项目要求。例如，你会在智能物联网设备中找到 ADV_IND 数据包，比如智能水瓶或手表，因为这些设备在执行进一步操作之前会先寻求与中央设备的连接。另一方面，你可能会在信标中找到
    ADV_NONCONN_IND 数据包，用于检测物体与安装在各种设备中的传感器的接近程度。
- en: Generic Access Profile and Generic Attribute Profile
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用访问配置文件与通用属性配置文件
- en: All BLE devices have a *Generic Access Profile (GAP)* that defines how they
    can connect to other devices, communicate with them, and make themselves available
    for discovery through broadcasting. A peripheral device can be connected to only
    one central device, whereas a central device can connect to as many peripherals
    as the central device can support. After establishing a connection, peripherals
    don’t accept any more connections. For each connection, the peripheral sends advertising
    probes at intervals, using three different frequencies, until the central device
    responds and the peripheral acknowledges the response indicating it’s ready to
    begin the connection.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 BLE 设备都有一个*通用访问配置文件 (GAP)*，它定义了设备如何连接到其他设备、与之通信并通过广播使自己可供发现。外设设备只能连接一个中央设备，而中央设备则可以连接到中央设备能够支持的多个外设设备。建立连接后，外设不再接受任何其他连接。对于每个连接，外设会间隔一定时间发送广告探测包，使用三种不同的频率，直到中央设备响应并且外设确认响应，表明它准备好开始连接。
- en: The *Generic Attribute Profile (GATT)* defines how the device should format
    and transfer data. When you’re analyzing a BLE device’s attack surface, you’ll
    often concentrate your attention on the GATT (or GATTs), because it’s how device
    functionality gets triggered and how data gets stored, grouped, and modified.
    The GATT lists a device’s characteristics, descriptors, and services in a table
    as either 16- or 32-bits values. A *characteristic* is a data value sent between
    the central device and peripheral. These characteristics can have *descriptors*
    that provide additional information about them. Characteristics are often grouped
    in services if they’re related to performing a particular action. *Services* can
    have several characteristics, as illustrated in [Figure 11-4](#figure11-4).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*通用属性配置文件 (GATT)* 定义了设备应如何格式化和传输数据。当你分析一个 BLE 设备的攻击面时，通常会集中关注 GATT（或多个 GATT），因为这是设备功能被触发的方式，以及数据是如何存储、分组和修改的。GATT
    列出了设备的特性、描述符和服务，以 16 位或 32 位值的形式展示在表格中。*特性*是中央设备与外设之间传输的数据值。这些特性可以有*描述符*，提供有关它们的附加信息。当特性与执行特定操作相关时，它们通常会被分组在服务中。*服务*可以包含多个特性，如图
    [11-4](#figure11-4) 所示。'
- en: '![f11004](Images/f11004.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![f11004](Images/f11004.png)'
- en: 'Figure 11-4: The GATT server structure is composed of services, characteristics,
    and descriptors.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-4：GATT 服务器结构由服务、特性和描述符组成。
- en: Working with BLE
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 BLE
- en: In this section, we’ll walk through the hardware and software you’ll need to
    communicate with BLE devices. We’ll introduce you to hardware you can use to establish
    BLE connections, as well as software for interacting with other devices.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: BLE Hardware
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can choose from a variety of hardware to interact with BLE. For simply sending
    and receiving data, integrated interfaces or cheap BLE USB dongles might be enough.
    But for sniffing and performing low-level protocol hacking, you’ll need something
    more robust. Prices for these devices vary widely; you’ll find a list of hardware
    for interacting with BLE in “Tools for IoT Hacking.”
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll use the ESP32 WROOM development board from Espressif
    Systems ([https://www.espressif.com/](https://www.espressif.com/)), which supports
    2.4 GHz Wi-Fi and BLE ([Figure 11-5](#figure11-5)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![f11005](Images/f11005.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-5: ESP32 WROOM development board'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: It has an embedded flash memory, and conveniently, you can program and power
    it with a micro-USB cable. It’s very compact and affordable, and the antenna range
    is quite good for its size. You can program it for other attacks, too—for instance,
    attacks against Wi-Fi.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: BlueZ
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on the device you’re using, you might need to install the required
    firmware or drivers for your software to be recognized and work correctly. In
    Linux, you’ll most likely be using *BlueZ*, the official Bluetooth stack, although
    proprietary drivers exist for adapters from vendors such as Broadcom or Realtek.
    The tools we’ll cover in this section all work out of the box with BlueZ.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: If you’re having a problem with BlueZ, be sure to install the latest version
    available at [http://www.bluez.org/download/](http://www.bluez.org/download/)
    because you could be using an earlier version pre-included in your Linux distribution’s
    package manager.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Configuring BLE Interfaces
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Hciconfig* is a Linux tool that you can use to configure and test your BLE
    connections. If you run Hciconfig with no arguments, you should see your Bluetooth
    interface. You should also see the state `UP` or `DOWN`, which indicates whether
    or not the Bluetooth adapter interface is enabled:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you don’t see your interface, make sure the drivers are loaded. The kernel
    module name in Linux systems should be `bluetooth`. Use `modprobe` to show the
    module configuration with the `-c` option:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can also try bringing down the interface and then bringing it back up again
    with the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If that doesn’t work, try resetting it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also list additional information with the `-a` option:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Discovering Devices and Listing Characteristics
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a BLE-enabled IoT device isn’t protected properly, you can intercept, analyze,
    modify, and retransmit its communications to manipulate the device’s operations.
    Overall, when assessing the security of an IoT device with BLE, you should follow
    this process:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Discover the BLE device address
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enumerate the GATT servers
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify their functionality through the listed characteristics, services, and
    attributes
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过列出的特征、服务和属性识别它们的功能。
- en: Manipulate the device functionality through read and write operations
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过读写操作来操控设备功能。
- en: 'Let’s walk through these steps now using two tools: GATTTool and Bettercap.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用两个工具：GATTTool 和 Bettercap，来逐步演示这些步骤。
- en: GATTTool
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GATTTool
- en: '*GATTTool* is part of BlueZ. You’ll mainly use it for operations like establishing
    a connection with another device, listing that device’s characteristics, and reading
    and writing its attributes. Run GATTTool with no arguments to see the list of
    supported actions.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*GATTTool* 是 BlueZ 的一部分。你将主要使用它进行一些操作，例如与另一设备建立连接、列出该设备的特征以及读取和写入其属性。运行 GATTTool
    不带任何参数，可以查看支持的操作列表。'
- en: 'GATTTool can launch an interactive shell with the `-I` option. The following
    command sets the BLE adapter interface so you can connect to a device and list
    its characteristics:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: GATTTool 可以通过 `-I` 选项启动交互式 shell。以下命令设置 BLE 适配器接口，以便你可以连接到设备并列出其特征：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside the interactive shell, issue the `connect` `<mac address>` command to
    establish a connection; then list the characteristics with the `characteristics`
    subcommand:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式 shell 中，使用 `connect` `<mac 地址>` 命令建立连接；然后通过 `characteristics` 子命令列出特征：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we have the handles, values, and services that describe the data and operations
    the BLE device supports.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经获取到描述 BLE 设备支持的数据和操作的句柄、值和服务。
- en: Let’s analyze this information with Bettercap, a more powerful tool that will
    help us see the information in a human-readable format.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Bettercap 来分析这些信息，这是一个更强大的工具，能够以人类可读的格式展示信息。
- en: Bettercap
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bettercap
- en: '*Bettercap* ([https://www.bettercap.org/](https://www.bettercap.org/)) is a
    tool for scanning and attacking devices that operate on the 2.4 GHz frequency.
    It provides a friendly interface (even a GUI) and extensible modules to perform
    the most common tasks for BLE scanning and attacking, such as listening to advertising
    packets and performing read/write operations. Additionally, you can use it to
    attack Wi-Fi, HID, and other technologies with man-in-the-middle attacks or other
    tactics.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*Bettercap* ([https://www.bettercap.org/](https://www.bettercap.org/)) 是一款扫描和攻击
    2.4 GHz 频率设备的工具。它提供了一个友好的界面（甚至是 GUI）和可扩展的模块，用于执行 BLE 扫描和攻击的最常见任务，如监听广播包和执行读/写操作。此外，你还可以使用它进行
    Wi-Fi、HID 和其他技术的攻击，例如中间人攻击或其他战术。'
- en: 'Bettercap is installed on Kali by default, and it’s available in most Linux
    package managers. You can install and run it from Docker using the following commands:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Bettercap 默认安装在 Kali 中，并且可以通过大多数 Linux 包管理器获得。你可以通过以下命令从 Docker 安装并运行它：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To discover BLE-enabled devices, enable the BLE module and start capturing
    beacons with the `ble.recon` option. Invoking it with the `--eval` option when
    loading Bettercap takes Bettercap commands and executes them automatically when
    Bettercap runs:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要发现 BLE 启用的设备，启用 BLE 模块并使用 `ble.recon` 选项开始捕获信标。在加载 Bettercap 时，使用 `--eval`
    选项调用它会自动执行 Bettercap 命令：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You should see a line for each BLE advertising packet received. This information
    should include the device name and MAC address, which you’ll need to establish
    communication with the devices.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到每个接收到的 BLE 广播包的一行。这些信息应该包括设备名称和 MAC 地址，你将需要这些信息来与设备建立通信。
- en: If you launched Bettercap with the `eval` option, you can record all discovered
    devices automatically. Then you can conveniently issue the `ble.show` command
    to list the discovered devices and related information, such as their MAC addresses,
    vendors, and flags ([Figure 11-6](#figure11-6)).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `eval` 选项启动了 Bettercap，你可以自动记录所有已发现的设备。然后，你可以方便地使用 `ble.show` 命令列出已发现的设备及其相关信息，如
    MAC 地址、厂商和标志（[图 11-6](#figure11-6)）。
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that `ble.show` command output contains the signal strength (RSSI), the
    advertising MAC address we’ll use to connect to the device, and the vendor, which
    can give us a hint about the type of device we’re looking at. It also displays
    the combination of supported protocols, the connection status, and the last received
    beacon’s timestamp.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ble.show` 命令的输出包含信号强度（RSSI）、我们将用于连接设备的广播 MAC 地址以及厂商信息，这些可以帮助我们猜测设备类型。它还显示了支持的协议组合、连接状态以及最后接收到的信标时间戳。
- en: '![f11006](Images/f11006.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![f11006](Images/f11006.png)'
- en: 'Figure 11-6: Bettercap shows discovered devices'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-6：Bettercap 显示已发现的设备
- en: Enumerating Characteristics, Services, and Descriptors
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举特征、服务和描述符
- en: 'Once we’ve identified our target device’s MAC address, we can run the following
    Bettercap command. This command obtains a nice, formatted table with the characteristics
    grouped by services, their properties, and the data available through the GATT:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们识别出目标设备的 MAC 地址，就可以运行以下 Bettercap 命令。该命令会获得一个格式良好的表格，按服务将特性分组，显示其属性及可通过
    GATT 访问的数据：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Figure 11-7](#figure11-7) shows the resulting table.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-7](#figure11-7) 显示了结果表格。'
- en: '![f11007](Images/f11007.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![f11007](Images/f11007.png)'
- en: 'Figure 11-7: Enumerating GATT servers with Bettercap'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-7：使用 Bettercap 枚举 GATT 服务器
- en: In the data column, we can see that this GATT server is the dashboard of a CTF
    describing the different challenges, as well as instructions for submitting your
    answers and checking your score.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据列中，我们可以看到这个 GATT 服务器是一个 CTF 仪表板，描述了不同的挑战，以及提交答案和检查分数的说明。
- en: This is a fun way to learn about practical attacks. But before we jump into
    solving one, let’s make sure you know how to perform classic read and write operations.
    You’ll use these for reconnaissance and to write data that alters a device’s state.
    The WRITE property is highlighted when handles allow the operations; pay close
    attention to the handles that support this, because they’re often misconfigured.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是学习实际攻击的有趣方式。但在我们跳入解决一个挑战之前，确保你知道如何执行经典的读写操作。你将用这些操作进行侦察，并写入数据来改变设备的状态。当句柄允许这些操作时，WRITE
    属性会被高亮显示；请密切注意支持这些操作的句柄，因为它们经常被配置错误。
- en: Reading and Writing Characteristics
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取和写入特性
- en: 'In BLE, UUIDs uniquely identify characteristics, services, and attributes.
    Once you know a characteristic’s UUID, you can write data to it with the `ble.write`
    Bettercap command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BLE 中，UUID 唯一标识特性、服务和属性。一旦你知道某个特性的 UUID，就可以使用 `ble.write` Bettercap 命令向其写入数据：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**You must format all the data you send in hexadecimal format. For example,
    to write the word “hello” to characteristic UUID ff06, you would send this command
    inside Bettercap’s interactive shell:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**你必须以十六进制格式发送所有数据。例如，要将单词“hello”写入特性 UUID ff06，你可以在 Bettercap 的交互式 shell 中发送以下命令：**'
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also use GATTTool to read and write data. GATTTool supports additional
    input formats for specifying handlers or UUIDs. For example, to issue a `write`
    command with GATTTool instead of Bettercap, use the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 GATTTool 来读写数据。GATTTool 支持额外的输入格式来指定处理程序或 UUID。例如，要使用 GATTTool 发出 `write`
    命令，而不是使用 Bettercap，可以使用以下命令：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, let’s practice reading some data using GATTTool. Grab the device name from
    the handler 0x16\. (This is reserved by the protocol to be the name of the device.)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用 GATTTool 来练习读取数据。从处理程序 0x16 获取设备名称。（这是协议预留的字段，用来表示设备名称。）
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can now discover devices, list characteristics, and read and write data
    to attempt to manipulate the device’s functionality. You’re ready to start doing
    some BLE hacking.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以发现设备，列出特性，并读写数据，尝试操控设备的功能。你已经准备好开始进行 BLE 黑客攻击了。
- en: BLE Hacking
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BLE 黑客攻击
- en: 'In this section, we’ll walk through a CTF designed to help you practice hacking
    BLE: the BLE CTF Infinity project ([https://github.com/hackgnar/ble_ctf_infinity/](https://github.com/hackgnar/ble_ctf_infinity/)).
    Solving the CTF challenges requires using basic and advanced concepts. This CTF
    runs on the ESP32 WROOM board.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一个 CTF 来帮助你练习 BLE 黑客攻击：BLE CTF Infinity 项目（[https://github.com/hackgnar/ble_ctf_infinity/](https://github.com/hackgnar/ble_ctf_infinity/)）。解决
    CTF 挑战需要使用基础和高级概念。这个 CTF 运行在 ESP32 WROOM 板上。
- en: We’ll use Bettercap and GATTTool, because one often works better than the other
    for certain tasks. Solving these practical challenges from this CTF will teach
    you how to explore unknown devices to discover functionality and manipulate the
    states of these devices. Before moving on, make sure you set up your development
    environment and toolchain for ESP32, as described at [https://docs.espressif.com/projects/esp-idf/en/latest/get-started/](https://docs.espressif.com/projects/esp-idf/en/latest/get-started/).
    Most of the steps will work as documented with a few considerations that we’ll
    mention next.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Bettercap 和 GATTTool，因为在某些任务中，一种工具往往比另一种工具更有效。通过解决这个 CTF 的实际挑战，你将学习如何探索未知设备，发现其功能并操控这些设备的状态。在继续之前，确保你已经按照
    [https://docs.espressif.com/projects/esp-idf/en/latest/get-started/](https://docs.espressif.com/projects/esp-idf/en/latest/get-started/)
    上的说明设置好你的开发环境和工具链。绝大多数步骤将按文档所述进行，但有一些我们稍后会提到的考虑事项。
- en: Setting Up BLE CTF Infinity
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 BLE CTF Infinity
- en: 'To build BLE CTF Infinity, we recommend using a Linux box, because the *make*
    file performs some additional copy operations on the source code (feel free to
    write a *CMakeLists.txt* file if you prefer building it on Windows). The file
    you need for this build is included with this book’s resources at [https://nostarch.com/practical-iot-hacking/](https://nostarch.com/practical-iot-hacking/).
    To build it successfully, you need to do the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty folder named *main* in the project’s *root* folder.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `make menuconfig`. Make sure your serial device is configured and has
    Bluetooth enabled, and that compiler warnings are not treated as errors. Again,
    we include the *sdkconfig* file for this build with this book’s resources.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `make codegen` to run the Python script that copies the source files into
    the *main* folder among other things.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the file *main/flag_scoreboard.c* and change the variable `string_total_flags[]`
    from `0` to `00`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `make` to build the CTF and `make flash` to flash the board. When the process
    is complete, the CTF program will automatically start.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have CTF running, you should see the beacons when scanning. Another
    option is to communicate with the assigned serial port (default baud rate 115200)
    and check the debug output.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Getting Started
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Locate the scoreboard, which shows the handle for submitting flags, the handle
    for navigating the challenges, and another handle to reset the CTF. Then enumerate
    the characteristics with your favorite tool ([Figure 11-8](#figure11-8)).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The 0030 handle lets you navigate through the challenges. Using Bettercap,
    write the value `0001` to that handle to go to flag #1:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To do the same with GATTTool, use the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![f11008](Images/f11008.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-8: Bettercap enumerating BLE CTF Infinity'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve written the characteristic, the beacon name will indicate that
    you’re looking at the GATT server for flag #1\. For example, Bettercap will show
    something like the following output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This displays a new GATT table, one for each challenge. Now that you’re familiar
    with the basic navigation, let’s go back to the scoreboard:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s begin with flag #0\. Navigate to it by writing the value `0000` to the
    0x0030 handle:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Interestingly, challenge 0 seems to be nothing more than the initial GATT server
    displaying the scoreboard ([Figure 11-9](#figure11-9)). Did we miss anything?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'After taking a closer look, the device name 04dc54d9053b4307680a looks a lot
    like a flag, right? Let’s test it by submitting the device name as an answer to
    the handle 002e. Note that if you use GATTTool, you need to format it in hex:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When we examine the scoreboard, we see that it worked as flag 0 is shown as
    complete. We’ve solved the first challenge. Congratulations!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![f11009](Images/f11009.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-9: Characteristics of the BLE CTF INFINITY scoreboard'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Flag 1: Examining Characteristics and Descriptors'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now navigate to FLAG_01 using this command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For this flag, we once again begin by examining the GATT table. Let’s try using
    GATTTool to list the characteristics and descriptors:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After examining each of the descriptors, we find a value in handle 0x002c that
    looks like a flag. To read a handle’s descriptor value, we can use the `char-read-hnd`
    `<handle>` command, like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Remember that the output is hex formatted, so this corresponds to the ASCII
    text 873c6495e4e738c94e1c.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve found the flag! Navigate back to the scoreboard and submit the new flag,
    as we did previously with flag 0:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We could have also used bash to automate the discovery of this flag. In that
    case, we’d iterate through the handlers to read the value of each handler. We
    could easily rewrite the following script into a simple fuzzer that writes values
    instead of performing the `--char-read` operation:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When we run the script, we should obtain the information from the handles:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Flag 2: Authentication'
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you view the FLAG_02 GATT table, you should see the message “Insufficient
    authentication” on handle 0x002c. You should also see the message “Connect with
    pin 0000” on handle 0x002a ([Figure 11-10](#figure11-10)). This challenge emulates
    a device with a weak pin code used for authentication.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![f11010](Images/f11010.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-10: We need to authenticate before reading the 002c handle.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'The hint implies we need to establish a secure connection to read the protected
    0x002c handle. To do this, we use GATTTool with the `--sec-level=high` option,
    which sets the security level of the connection to high and makes an authenticated,
    encrypted connection (AES-CMAC or ECDHE) before reading the value:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Nice! This time, after converting from hex to ASCII, we get the flag 5d696cdf53a916c0a98d
    instead of the “Insufficient authentication” message. Go back to the scoreboard
    and submit it, as shown previously:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The flag is correct, as shown on the scoreboard! We’ve solved challenge #2.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Flag 3: Spoofing Your MAC Address'
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Navigate to FLAG_03 and enumerate the services and characteristics in its GATT
    server. On handle 0x002a is the message “Connect with mac 11:22:33:44:55:66” ([Figure
    11-11](#figure11-11)). This challenge requires us to learn how to spoof the origin
    of the MAC address of a connection to read the handle.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![f11011](Images/f11011.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-11: FLAG_3 characteristics using Bettercap'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'This means we must spoof our real Bluetooth MAC address to get the flag. Although
    you can use Hciconfig to issue commands that will change your MAC, the `spooftooph`Linux
    utility is a lot easier to use, because it doesn’t require you to send raw commands.
    Install it from your favorite package manager and run the following command to
    set your MAC to the address stated in the message:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Verify your new spoofed MAC address using `hciconfig`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Using Bettercap’s `ble.enum` command, take another look at the GATT server for
    this challenge. This time, you should see a new flag on the 0x002c handle ([Figure
    11-12](#figure11-12)).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![f11012](Images/f11012.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-12: FLAG_3 is shown after connecting with the desired MAC address.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-12：连接到目标 MAC 地址后显示的 FLAG_3。
- en: 'Return to the scoreboard and submit your new flag:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到记分板并提交你的新旗帜：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Then check the scoreboard to see your updated score ([Figure 11-13](#figure11-13)).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后检查记分板，查看你更新后的得分（[图 11-13](#figure11-13)）。
- en: '![f11013](Images/f11013.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![f11013](Images/f11013.png)'
- en: 'Figure 11-13: The scoreboard after completing the first challenges'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-13：完成第一个挑战后的记分板
- en: Conclusion
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: After this brief introduction to BLE hacking, we hope we’ve inspired you to
    continue solving the CTF challenges. They’ll demonstrate real-life tasks that
    you’ll need daily when assessing BLE-enabled devices. We showed core concepts
    and some of the most popular attacks, but keep in mind that you can perform other
    attacks, too, such as man-in-the-middle attacks, if the device isn’t using a secure
    connection.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要介绍完 BLE 黑客攻击后，我们希望能够激励你继续解决 CTF 挑战。它们将展示你在评估 BLE 启用设备时每天都需要处理的实际任务。我们展示了核心概念和一些最常见的攻击，但请记住，你也可以执行其他攻击，例如中间人攻击，特别是当设备未使用安全连接时。
- en: Many specific protocol implementation vulnerabilities currently exist. For every
    new application or protocol that uses BLE, there’s a chance the programmer made
    an error that introduced a security bug in their implementation. Although the
    new version of Bluetooth (5.0) is available now, the adoption phase is moving
    slowly, so you’ll see plenty of BLE devices in the years to come.**
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 目前存在许多特定协议实现的漏洞。对于每一个使用 BLE 的新应用程序或协议，程序员都有可能犯错，从而在其实现中引入安全漏洞。尽管新的蓝牙版本（5.0）现在已经推出，但采用过程仍然缓慢，因此在未来几年你仍会看到大量的
    BLE 设备。**
