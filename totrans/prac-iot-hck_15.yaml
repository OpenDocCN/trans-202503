- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Bluetooth Low Energy
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 低功耗蓝牙
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: '*Bluetooth Low Energy (BLE)* is a version of the Bluetooth wireless technology
    IoT devices often use because of its low-energy consumption and because the pairing
    process is simpler than in previous Bluetooth versions. But BLE can also maintain
    similar, and sometimes greater, communication ranges. You can find it in all sorts
    of devices, from common health gadgets like smart watches or smart water bottles
    to critical medical equipment like insulin pumps and pacemakers. In industrial
    environments, you’ll see it in sensors, nodes, and gateways of all types. It’s
    even used in the military, where weapon components such as rifle scopes operate
    remotely via Bluetooth. Of course, these have already been hacked.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*低功耗蓝牙（BLE）* 是蓝牙无线技术的一种版本，物联网设备经常使用它，因为其低功耗消耗和比之前版本更简单的配对过程。但 BLE 也能保持相似，甚至更大的通信范围。你可以在各种设备中找到它，从常见的健康小工具，如智能手表或智能水瓶，到关键的医疗设备，如胰岛素泵和心脏起搏器。在工业环境中，你会看到它被应用在各种传感器、节点和网关中。它甚至被用于军事中，其中武器组件，如步枪瞄准镜，通过蓝牙远程操作。当然，这些设备已经被黑客攻击过。'
- en: These devices use Bluetooth to take advantage of the simplicity and robustness
    of this radio communication protocol, but doing so increases a device’s attack
    surface. In this chapter, you’ll learn how BLE communications work, explore common
    hardware and software that communicates with BLE devices, and master techniques
    to effectively identify and exploit security vulnerabilities. You’ll set up a
    lab using the ESP32 development board and then walk through levels of an advanced
    Capture the Flag (CTF) exercise designed specifically for BLE. After reading this
    chapter, you should be ready to tackle some of the remaining unsolved challenges
    from this CTF laboratory.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备使用蓝牙技术，利用该无线通信协议的简单性和稳健性，但这样做会增加设备的攻击面。在本章中，你将学习 BLE 通信的工作原理，探索与 BLE 设备通信的常见硬件和软件，并掌握有效识别和利用安全漏洞的技巧。你将使用
    ESP32 开发板搭建实验室，并逐步完成为 BLE 专门设计的高级抓旗（CTF）练习的各个关卡。阅读完本章后，你应该能够应对该 CTF 实验室中的一些未解难题。
- en: How BLE Works
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BLE 工作原理
- en: BLE consumes significantly less power than traditional Bluetooth, but it can
    transmit small amounts of data very efficiently. Available since the Bluetooth
    4.0 specification, BLE uses only 40 channels, covering the range of 2400 to 2483.5
    MHz. In contrast, traditional Bluetooth uses 79 channels in that same range.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: BLE 的功耗远低于传统蓝牙，但它能非常高效地传输少量数据。自蓝牙 4.0 规范发布以来，BLE 只使用 40 个频道，覆盖 2400 到 2483.5
    MHz 的范围。相比之下，传统蓝牙使用该范围内的 79 个频道。
- en: Although every application uses this technology differently, the most common
    way BLE devices communicate is by sending advertising packets. Also known as *beacons*,
    these packets broadcast the BLE device’s existence to other nearby devices ([Figure
    11-1](#figure11-1)). These beacons sometimes send data, too.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个应用都以不同的方式使用这项技术，但 BLE 设备最常见的通信方式是通过发送广告数据包。这些数据包，也被称为*信标*，将 BLE 设备的存在广播给其他附近的设备（[图
    11-1](#figure11-1)）。这些信标有时也会发送数据。
- en: '![f11001](Images/f11001.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![f11001](Images/f11001.png)'
- en: 'Figure 11-1: BLE devices send advertising packets to elicit a SCAN request.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-1：BLE 设备发送广告数据包以发起 SCAN 请求。
- en: To reduce power consumption, BLE devices only send advertising packets when
    they need to connect and exchange data; they sleep the rest of the time. The listening
    device, also called a *central device*, can respond to an advertising packet with
    a *SCAN request* sent specifically to the advertising device. The response to
    that scan uses the same structure as the advertising packet. It contains additional
    information that couldn’t fit on the initial advertising request, such as the
    full device name or any additional information the vendor needs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少功耗，BLE 设备只在需要连接和交换数据时发送广告数据包；其他时间它们会进入休眠状态。监听设备，也叫做*中央设备*，可以对广告数据包做出响应，发送特定给广告设备的*SCAN
    请求*。该扫描响应使用与广告数据包相同的结构，包含初始广告请求中未能包含的附加信息，例如完整的设备名称或厂商需要的其他信息。
- en: '[Figure 11-2](#figure11-2) shows BLE’s packet structure.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-2](#figure11-2) 展示了 BLE 的数据包结构。'
- en: '![f11002](Images/f11002.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![f11002](Images/f11002.png)'
- en: 'Figure 11-2: BLE’s packet structure'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-2：BLE 的数据包结构
- en: The preamble byte synchronizes the frequency, whereas the four-byte access address
    is a connection identifier, which is used in scenarios where multiple devices
    are trying to establish connections on the same channels. Next, the Protocol Data
    Unit (PDU) contains the advertising data. There are several types of PDU; the
    most commonly used are ADV_NONCONN_IND and ADV_IND. Devices use the ADV_NONCONN_IND
    PDU type if they don’t accept connections, transmitting data only in the advertising
    packet. Devices use ADV_IND if they allow connections and stop sending advertising
    packets once a connection has been established. [Figure 11-3](#figure11-3) shows
    an ADV_IND packet in a Wireshark capture.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 前导字节用于同步频率，而四字节的访问地址是连接标识符，用于多个设备尝试在相同频道上建立连接的场景。接下来，协议数据单元（PDU）包含广告数据。PDU 有几种类型；最常用的是
    ADV_NONCONN_IND 和 ADV_IND。如果设备不接受连接，它们使用 ADV_NONCONN_IND 类型的 PDU，只在广告数据包中传输数据。如果设备允许连接并且连接已建立，它们将停止发送广告数据包并使用
    ADV_IND 类型。图 [11-3](#figure11-3) 展示了 Wireshark 捕获中的 ADV_IND 数据包。
- en: '![f11003](Images/f11003.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![f11003](Images/f11003.png)'
- en: 'Figure 11-3: A Wireshark display tree showing a BLE advertising packet of type
    ADV_IND'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-3：Wireshark 显示树，展示了类型为 ADV_IND 的 BLE 广告数据包
- en: The type of packet used depends on the BLE implementation and project requirements.
    For example, you’ll find ADV_IND packets in smart IoT devices, such as smart water
    bottles or watches, because these seek to connect to a central device before performing
    further operations. On the other hand, you might find ADV_NONCONN_IND packets
    in beacons to detect an object’s proximity to sensors placed in various devices.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的数据包类型取决于 BLE 实现和项目要求。例如，你会在智能物联网设备中找到 ADV_IND 数据包，比如智能水瓶或手表，因为这些设备在执行进一步操作之前会先寻求与中央设备的连接。另一方面，你可能会在信标中找到
    ADV_NONCONN_IND 数据包，用于检测物体与安装在各种设备中的传感器的接近程度。
- en: Generic Access Profile and Generic Attribute Profile
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用访问配置文件与通用属性配置文件
- en: All BLE devices have a *Generic Access Profile (GAP)* that defines how they
    can connect to other devices, communicate with them, and make themselves available
    for discovery through broadcasting. A peripheral device can be connected to only
    one central device, whereas a central device can connect to as many peripherals
    as the central device can support. After establishing a connection, peripherals
    don’t accept any more connections. For each connection, the peripheral sends advertising
    probes at intervals, using three different frequencies, until the central device
    responds and the peripheral acknowledges the response indicating it’s ready to
    begin the connection.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 BLE 设备都有一个*通用访问配置文件 (GAP)*，它定义了设备如何连接到其他设备、与之通信并通过广播使自己可供发现。外设设备只能连接一个中央设备，而中央设备则可以连接到中央设备能够支持的多个外设设备。建立连接后，外设不再接受任何其他连接。对于每个连接，外设会间隔一定时间发送广告探测包，使用三种不同的频率，直到中央设备响应并且外设确认响应，表明它准备好开始连接。
- en: The *Generic Attribute Profile (GATT)* defines how the device should format
    and transfer data. When you’re analyzing a BLE device’s attack surface, you’ll
    often concentrate your attention on the GATT (or GATTs), because it’s how device
    functionality gets triggered and how data gets stored, grouped, and modified.
    The GATT lists a device’s characteristics, descriptors, and services in a table
    as either 16- or 32-bits values. A *characteristic* is a data value sent between
    the central device and peripheral. These characteristics can have *descriptors*
    that provide additional information about them. Characteristics are often grouped
    in services if they’re related to performing a particular action. *Services* can
    have several characteristics, as illustrated in [Figure 11-4](#figure11-4).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*通用属性配置文件 (GATT)* 定义了设备应如何格式化和传输数据。当你分析一个 BLE 设备的攻击面时，通常会集中关注 GATT（或多个 GATT），因为这是设备功能被触发的方式，以及数据是如何存储、分组和修改的。GATT
    列出了设备的特性、描述符和服务，以 16 位或 32 位值的形式展示在表格中。*特性*是中央设备与外设之间传输的数据值。这些特性可以有*描述符*，提供有关它们的附加信息。当特性与执行特定操作相关时，它们通常会被分组在服务中。*服务*可以包含多个特性，如图
    [11-4](#figure11-4) 所示。'
- en: '![f11004](Images/f11004.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![f11004](Images/f11004.png)'
- en: 'Figure 11-4: The GATT server structure is composed of services, characteristics,
    and descriptors.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-4：GATT 服务器结构由服务、特性和描述符组成。
- en: Working with BLE
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 BLE
- en: In this section, we’ll walk through the hardware and software you’ll need to
    communicate with BLE devices. We’ll introduce you to hardware you can use to establish
    BLE connections, as well as software for interacting with other devices.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍与 BLE 设备通信所需的硬件和软件。我们将向你介绍可以用来建立 BLE 连接的硬件，以及与其他设备交互的软件。
- en: BLE Hardware
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BLE 硬件
- en: You can choose from a variety of hardware to interact with BLE. For simply sending
    and receiving data, integrated interfaces or cheap BLE USB dongles might be enough.
    But for sniffing and performing low-level protocol hacking, you’ll need something
    more robust. Prices for these devices vary widely; you’ll find a list of hardware
    for interacting with BLE in “Tools for IoT Hacking.”
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择各种硬件来与 BLE 交互。如果只是简单地发送和接收数据，集成接口或便宜的 BLE USB 加密狗可能就足够了。但如果要嗅探并进行低级协议破解，你需要更强大的设备。这些设备的价格差异很大；你可以在“物联网黑客工具”一节中找到与
    BLE 交互的硬件清单。
- en: In this chapter, we’ll use the ESP32 WROOM development board from Espressif
    Systems ([https://www.espressif.com/](https://www.espressif.com/)), which supports
    2.4 GHz Wi-Fi and BLE ([Figure 11-5](#figure11-5)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Espressif Systems 的 ESP32 WROOM 开发板（[https://www.espressif.com/](https://www.espressif.com/)），该开发板支持
    2.4 GHz Wi-Fi 和 BLE（[图 11-5](#figure11-5)）。
- en: '![f11005](Images/f11005.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![f11005](Images/f11005.png)'
- en: 'Figure 11-5: ESP32 WROOM development board'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-5：ESP32 WROOM 开发板
- en: It has an embedded flash memory, and conveniently, you can program and power
    it with a micro-USB cable. It’s very compact and affordable, and the antenna range
    is quite good for its size. You can program it for other attacks, too—for instance,
    attacks against Wi-Fi.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有嵌入式闪存，并且可以通过微型 USB 电缆进行编程和供电。它非常紧凑且价格实惠，天线范围对于其尺寸来说相当不错。你还可以为其他攻击编程它，比如对
    Wi-Fi 的攻击。
- en: BlueZ
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BlueZ
- en: Depending on the device you’re using, you might need to install the required
    firmware or drivers for your software to be recognized and work correctly. In
    Linux, you’ll most likely be using *BlueZ*, the official Bluetooth stack, although
    proprietary drivers exist for adapters from vendors such as Broadcom or Realtek.
    The tools we’ll cover in this section all work out of the box with BlueZ.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的设备，你可能需要安装所需的固件或驱动程序，以便软件能够被识别并正常工作。在 Linux 中，你很可能会使用*BlueZ*，官方的蓝牙协议栈，尽管一些适配器如
    Broadcom 或 Realtek 也有专有驱动程序。我们将在本节中介绍的工具都能与 BlueZ 即插即用。
- en: If you’re having a problem with BlueZ, be sure to install the latest version
    available at [http://www.bluez.org/download/](http://www.bluez.org/download/)
    because you could be using an earlier version pre-included in your Linux distribution’s
    package manager.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到 BlueZ 问题，请确保安装最新版本，访问[http://www.bluez.org/download/](http://www.bluez.org/download/)，因为你可能在使用
    Linux 发行版的软件包管理器中预装的早期版本。
- en: Configuring BLE Interfaces
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 BLE 接口
- en: '*Hciconfig* is a Linux tool that you can use to configure and test your BLE
    connections. If you run Hciconfig with no arguments, you should see your Bluetooth
    interface. You should also see the state `UP` or `DOWN`, which indicates whether
    or not the Bluetooth adapter interface is enabled:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*Hciconfig* 是一个 Linux 工具，可以用来配置和测试你的 BLE 连接。如果你在没有任何参数的情况下运行 Hciconfig，你应该能够看到你的蓝牙接口。你还应该看到状态
    `UP` 或 `DOWN`，表示蓝牙适配器接口是否启用：'
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you don’t see your interface, make sure the drivers are loaded. The kernel
    module name in Linux systems should be `bluetooth`. Use `modprobe` to show the
    module configuration with the `-c` option:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到你的接口，确保驱动程序已加载。在 Linux 系统中，内核模块名应该是 `bluetooth`。使用 `modprobe` 命令并加上 `-c`
    选项查看模块配置：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can also try bringing down the interface and then bringing it back up again
    with the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以尝试通过以下命令关闭接口再重新启动：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If that doesn’t work, try resetting it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这样不行，尝试重置它：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also list additional information with the `-a` option:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `-a` 选项列出更多信息：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Discovering Devices and Listing Characteristics
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现设备并列出特征
- en: 'If a BLE-enabled IoT device isn’t protected properly, you can intercept, analyze,
    modify, and retransmit its communications to manipulate the device’s operations.
    Overall, when assessing the security of an IoT device with BLE, you should follow
    this process:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个支持 BLE 的物联网设备没有得到适当保护，你可以拦截、分析、修改并重新传输其通信数据，以操控该设备的操作。总体而言，评估具有 BLE 的物联网设备的安全性时，你应该遵循以下过程：
- en: Discover the BLE device address
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发现 BLE 设备地址
- en: Enumerate the GATT servers
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枚举 GATT 服务器
- en: Identify their functionality through the listed characteristics, services, and
    attributes
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过列出的特征、服务和属性识别它们的功能。
- en: Manipulate the device functionality through read and write operations
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过读写操作来操控设备功能。
- en: 'Let’s walk through these steps now using two tools: GATTTool and Bettercap.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用两个工具：GATTTool 和 Bettercap，来逐步演示这些步骤。
- en: GATTTool
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GATTTool
- en: '*GATTTool* is part of BlueZ. You’ll mainly use it for operations like establishing
    a connection with another device, listing that device’s characteristics, and reading
    and writing its attributes. Run GATTTool with no arguments to see the list of
    supported actions.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*GATTTool* 是 BlueZ 的一部分。你将主要使用它进行一些操作，例如与另一设备建立连接、列出该设备的特征以及读取和写入其属性。运行 GATTTool
    不带任何参数，可以查看支持的操作列表。'
- en: 'GATTTool can launch an interactive shell with the `-I` option. The following
    command sets the BLE adapter interface so you can connect to a device and list
    its characteristics:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: GATTTool 可以通过 `-I` 选项启动交互式 shell。以下命令设置 BLE 适配器接口，以便你可以连接到设备并列出其特征：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside the interactive shell, issue the `connect` `<mac address>` command to
    establish a connection; then list the characteristics with the `characteristics`
    subcommand:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式 shell 中，使用 `connect` `<mac 地址>` 命令建立连接；然后通过 `characteristics` 子命令列出特征：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we have the handles, values, and services that describe the data and operations
    the BLE device supports.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经获取到描述 BLE 设备支持的数据和操作的句柄、值和服务。
- en: Let’s analyze this information with Bettercap, a more powerful tool that will
    help us see the information in a human-readable format.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Bettercap 来分析这些信息，这是一个更强大的工具，能够以人类可读的格式展示信息。
- en: Bettercap
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bettercap
- en: '*Bettercap* ([https://www.bettercap.org/](https://www.bettercap.org/)) is a
    tool for scanning and attacking devices that operate on the 2.4 GHz frequency.
    It provides a friendly interface (even a GUI) and extensible modules to perform
    the most common tasks for BLE scanning and attacking, such as listening to advertising
    packets and performing read/write operations. Additionally, you can use it to
    attack Wi-Fi, HID, and other technologies with man-in-the-middle attacks or other
    tactics.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*Bettercap* ([https://www.bettercap.org/](https://www.bettercap.org/)) 是一款扫描和攻击
    2.4 GHz 频率设备的工具。它提供了一个友好的界面（甚至是 GUI）和可扩展的模块，用于执行 BLE 扫描和攻击的最常见任务，如监听广播包和执行读/写操作。此外，你还可以使用它进行
    Wi-Fi、HID 和其他技术的攻击，例如中间人攻击或其他战术。'
- en: 'Bettercap is installed on Kali by default, and it’s available in most Linux
    package managers. You can install and run it from Docker using the following commands:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Bettercap 默认安装在 Kali 中，并且可以通过大多数 Linux 包管理器获得。你可以通过以下命令从 Docker 安装并运行它：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To discover BLE-enabled devices, enable the BLE module and start capturing
    beacons with the `ble.recon` option. Invoking it with the `--eval` option when
    loading Bettercap takes Bettercap commands and executes them automatically when
    Bettercap runs:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要发现 BLE 启用的设备，启用 BLE 模块并使用 `ble.recon` 选项开始捕获信标。在加载 Bettercap 时，使用 `--eval`
    选项调用它会自动执行 Bettercap 命令：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You should see a line for each BLE advertising packet received. This information
    should include the device name and MAC address, which you’ll need to establish
    communication with the devices.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到每个接收到的 BLE 广播包的一行。这些信息应该包括设备名称和 MAC 地址，你将需要这些信息来与设备建立通信。
- en: If you launched Bettercap with the `eval` option, you can record all discovered
    devices automatically. Then you can conveniently issue the `ble.show` command
    to list the discovered devices and related information, such as their MAC addresses,
    vendors, and flags ([Figure 11-6](#figure11-6)).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `eval` 选项启动了 Bettercap，你可以自动记录所有已发现的设备。然后，你可以方便地使用 `ble.show` 命令列出已发现的设备及其相关信息，如
    MAC 地址、厂商和标志（[图 11-6](#figure11-6)）。
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that `ble.show` command output contains the signal strength (RSSI), the
    advertising MAC address we’ll use to connect to the device, and the vendor, which
    can give us a hint about the type of device we’re looking at. It also displays
    the combination of supported protocols, the connection status, and the last received
    beacon’s timestamp.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ble.show` 命令的输出包含信号强度（RSSI）、我们将用于连接设备的广播 MAC 地址以及厂商信息，这些可以帮助我们猜测设备类型。它还显示了支持的协议组合、连接状态以及最后接收到的信标时间戳。
- en: '![f11006](Images/f11006.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![f11006](Images/f11006.png)'
- en: 'Figure 11-6: Bettercap shows discovered devices'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-6：Bettercap 显示已发现的设备
- en: Enumerating Characteristics, Services, and Descriptors
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举特征、服务和描述符
- en: 'Once we’ve identified our target device’s MAC address, we can run the following
    Bettercap command. This command obtains a nice, formatted table with the characteristics
    grouped by services, their properties, and the data available through the GATT:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们识别出目标设备的 MAC 地址，就可以运行以下 Bettercap 命令。该命令会获得一个格式良好的表格，按服务将特性分组，显示其属性及可通过
    GATT 访问的数据：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Figure 11-7](#figure11-7) shows the resulting table.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-7](#figure11-7) 显示了结果表格。'
- en: '![f11007](Images/f11007.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![f11007](Images/f11007.png)'
- en: 'Figure 11-7: Enumerating GATT servers with Bettercap'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-7：使用 Bettercap 枚举 GATT 服务器
- en: In the data column, we can see that this GATT server is the dashboard of a CTF
    describing the different challenges, as well as instructions for submitting your
    answers and checking your score.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据列中，我们可以看到这个 GATT 服务器是一个 CTF 仪表板，描述了不同的挑战，以及提交答案和检查分数的说明。
- en: This is a fun way to learn about practical attacks. But before we jump into
    solving one, let’s make sure you know how to perform classic read and write operations.
    You’ll use these for reconnaissance and to write data that alters a device’s state.
    The WRITE property is highlighted when handles allow the operations; pay close
    attention to the handles that support this, because they’re often misconfigured.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是学习实际攻击的有趣方式。但在我们跳入解决一个挑战之前，确保你知道如何执行经典的读写操作。你将用这些操作进行侦察，并写入数据来改变设备的状态。当句柄允许这些操作时，WRITE
    属性会被高亮显示；请密切注意支持这些操作的句柄，因为它们经常被配置错误。
- en: Reading and Writing Characteristics
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取和写入特性
- en: 'In BLE, UUIDs uniquely identify characteristics, services, and attributes.
    Once you know a characteristic’s UUID, you can write data to it with the `ble.write`
    Bettercap command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BLE 中，UUID 唯一标识特性、服务和属性。一旦你知道某个特性的 UUID，就可以使用 `ble.write` Bettercap 命令向其写入数据：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**You must format all the data you send in hexadecimal format. For example,
    to write the word “hello” to characteristic UUID ff06, you would send this command
    inside Bettercap’s interactive shell:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**你必须以十六进制格式发送所有数据。例如，要将单词“hello”写入特性 UUID ff06，你可以在 Bettercap 的交互式 shell 中发送以下命令：**'
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also use GATTTool to read and write data. GATTTool supports additional
    input formats for specifying handlers or UUIDs. For example, to issue a `write`
    command with GATTTool instead of Bettercap, use the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 GATTTool 来读写数据。GATTTool 支持额外的输入格式来指定处理程序或 UUID。例如，要使用 GATTTool 发出 `write`
    命令，而不是使用 Bettercap，可以使用以下命令：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, let’s practice reading some data using GATTTool. Grab the device name from
    the handler 0x16\. (This is reserved by the protocol to be the name of the device.)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用 GATTTool 来练习读取数据。从处理程序 0x16 获取设备名称。（这是协议预留的字段，用来表示设备名称。）
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can now discover devices, list characteristics, and read and write data
    to attempt to manipulate the device’s functionality. You’re ready to start doing
    some BLE hacking.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以发现设备，列出特性，并读写数据，尝试操控设备的功能。你已经准备好开始进行 BLE 黑客攻击了。
- en: BLE Hacking
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BLE 黑客攻击
- en: 'In this section, we’ll walk through a CTF designed to help you practice hacking
    BLE: the BLE CTF Infinity project ([https://github.com/hackgnar/ble_ctf_infinity/](https://github.com/hackgnar/ble_ctf_infinity/)).
    Solving the CTF challenges requires using basic and advanced concepts. This CTF
    runs on the ESP32 WROOM board.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一个 CTF 来帮助你练习 BLE 黑客攻击：BLE CTF Infinity 项目（[https://github.com/hackgnar/ble_ctf_infinity/](https://github.com/hackgnar/ble_ctf_infinity/)）。解决
    CTF 挑战需要使用基础和高级概念。这个 CTF 运行在 ESP32 WROOM 板上。
- en: We’ll use Bettercap and GATTTool, because one often works better than the other
    for certain tasks. Solving these practical challenges from this CTF will teach
    you how to explore unknown devices to discover functionality and manipulate the
    states of these devices. Before moving on, make sure you set up your development
    environment and toolchain for ESP32, as described at [https://docs.espressif.com/projects/esp-idf/en/latest/get-started/](https://docs.espressif.com/projects/esp-idf/en/latest/get-started/).
    Most of the steps will work as documented with a few considerations that we’ll
    mention next.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Bettercap 和 GATTTool，因为在某些任务中，一种工具往往比另一种工具更有效。通过解决这个 CTF 的实际挑战，你将学习如何探索未知设备，发现其功能并操控这些设备的状态。在继续之前，确保你已经按照
    [https://docs.espressif.com/projects/esp-idf/en/latest/get-started/](https://docs.espressif.com/projects/esp-idf/en/latest/get-started/)
    上的说明设置好你的开发环境和工具链。绝大多数步骤将按文档所述进行，但有一些我们稍后会提到的考虑事项。
- en: Setting Up BLE CTF Infinity
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 BLE CTF Infinity
- en: 'To build BLE CTF Infinity, we recommend using a Linux box, because the *make*
    file performs some additional copy operations on the source code (feel free to
    write a *CMakeLists.txt* file if you prefer building it on Windows). The file
    you need for this build is included with this book’s resources at [https://nostarch.com/practical-iot-hacking/](https://nostarch.com/practical-iot-hacking/).
    To build it successfully, you need to do the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建 BLE CTF Infinity，我们建议使用 Linux 主机，因为 *make* 文件会对源代码执行一些额外的复制操作（如果你更喜欢在 Windows
    上构建，可以自由编写 *CMakeLists.txt* 文件）。你需要的构建文件已包含在本书的资源中，地址为 [https://nostarch.com/practical-iot-hacking/](https://nostarch.com/practical-iot-hacking/)。要成功构建，你需要执行以下操作：
- en: Create an empty folder named *main* in the project’s *root* folder.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的 *root* 文件夹中创建一个名为 *main* 的空文件夹。
- en: Execute `make menuconfig`. Make sure your serial device is configured and has
    Bluetooth enabled, and that compiler warnings are not treated as errors. Again,
    we include the *sdkconfig* file for this build with this book’s resources.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `make menuconfig`。确保你的串口设备已配置并启用蓝牙，并且编译器警告不会被视为错误。再次提醒，我们将为本书的构建提供 *sdkconfig*
    文件。
- en: Run `make codegen` to run the Python script that copies the source files into
    the *main* folder among other things.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `make codegen` 来运行 Python 脚本，该脚本将源文件复制到 *main* 文件夹中等操作。
- en: Edit the file *main/flag_scoreboard.c* and change the variable `string_total_flags[]`
    from `0` to `00`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑文件 *main/flag_scoreboard.c*，并将变量 `string_total_flags[]` 从 `0` 更改为 `00`。
- en: Run `make` to build the CTF and `make flash` to flash the board. When the process
    is complete, the CTF program will automatically start.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `make` 来构建 CTF，运行 `make flash` 来烧录板子。过程完成后，CTF 程序将自动启动。
- en: Once you have CTF running, you should see the beacons when scanning. Another
    option is to communicate with the assigned serial port (default baud rate 115200)
    and check the debug output.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 CTF 启动，你应该能够在扫描时看到信标。另一种选择是通过与指定的串口（默认波特率为 115200）通信，并检查调试输出。
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Getting Started
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入门
- en: Locate the scoreboard, which shows the handle for submitting flags, the handle
    for navigating the challenges, and another handle to reset the CTF. Then enumerate
    the characteristics with your favorite tool ([Figure 11-8](#figure11-8)).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 找到记分板，显示提交标志的句柄、导航挑战的句柄以及重置 CTF 的另一个句柄。然后使用你喜欢的工具列出特性（[图 11-8](#figure11-8)）。
- en: 'The 0030 handle lets you navigate through the challenges. Using Bettercap,
    write the value `0001` to that handle to go to flag #1:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '0030 句柄让你能够在挑战中进行导航。使用 Bettercap，将值 `0001` 写入该句柄以进入标志 #1：'
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To do the same with GATTTool, use the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 GATTTool 做同样的事情，请使用以下命令：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![f11008](Images/f11008.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![f11008](Images/f11008.png)'
- en: 'Figure 11-8: Bettercap enumerating BLE CTF Infinity'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-8：Bettercap 枚举 BLE CTF Infinity
- en: 'Once you’ve written the characteristic, the beacon name will indicate that
    you’re looking at the GATT server for flag #1\. For example, Bettercap will show
    something like the following output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦你写入了特性，信标名称将指示你正在查看 GATT 服务器上的标志 #1。例如，Bettercap 会显示类似以下的输出：'
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This displays a new GATT table, one for each challenge. Now that you’re familiar
    with the basic navigation, let’s go back to the scoreboard:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示一个新的 GATT 表格，每个挑战一个。现在你已经熟悉了基本的导航，让我们回到记分板：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s begin with flag #0\. Navigate to it by writing the value `0000` to the
    0x0030 handle:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们从标志 #0 开始。通过将值 `0000` 写入 0x0030 句柄来导航到它：'
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Interestingly, challenge 0 seems to be nothing more than the initial GATT server
    displaying the scoreboard ([Figure 11-9](#figure11-9)). Did we miss anything?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，挑战 0 似乎仅仅是初始的 GATT 服务器显示记分板（[图 11-9](#figure11-9)）。我们是不是错过了什么？
- en: 'After taking a closer look, the device name 04dc54d9053b4307680a looks a lot
    like a flag, right? Let’s test it by submitting the device name as an answer to
    the handle 002e. Note that if you use GATTTool, you need to format it in hex:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 经过仔细观察，设备名称 04dc54d9053b4307680a 看起来像一个标志，对吧？让我们通过将设备名称作为答案提交到句柄 002e 来测试一下。请注意，如果使用
    GATTTool，你需要以十六进制格式化它：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When we examine the scoreboard, we see that it worked as flag 0 is shown as
    complete. We’ve solved the first challenge. Congratulations!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查记分板时，我们看到它成功了，因为标志 0 显示为已完成。我们已经解决了第一个挑战。恭喜！
- en: '![f11009](Images/f11009.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![f11009](Images/f11009.png)'
- en: 'Figure 11-9: Characteristics of the BLE CTF INFINITY scoreboard'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-9：BLE CTF INFINITY 记分板的特性
- en: 'Flag 1: Examining Characteristics and Descriptors'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标志 1：检查特性和描述符
- en: 'Now navigate to FLAG_01 using this command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用以下命令导航到 FLAG_01：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For this flag, we once again begin by examining the GATT table. Let’s try using
    GATTTool to list the characteristics and descriptors:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个标志，我们再次从检查 GATT 表开始。让我们尝试使用 GATTTool 列出特征和描述符：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After examining each of the descriptors, we find a value in handle 0x002c that
    looks like a flag. To read a handle’s descriptor value, we can use the `char-read-hnd`
    `<handle>` command, like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查每个描述符后，我们在句柄 0x002c 中发现一个类似标志的值。要读取句柄的描述符值，我们可以使用 `char-read-hnd` `<handle>`
    命令，像这样：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Remember that the output is hex formatted, so this corresponds to the ASCII
    text 873c6495e4e738c94e1c.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，输出是十六进制格式的，因此它对应的 ASCII 文本是 873c6495e4e738c94e1c。
- en: 'We’ve found the flag! Navigate back to the scoreboard and submit the new flag,
    as we did previously with flag 0:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了标志！返回到积分榜并提交新的标志，就像我们之前提交标志 0 一样：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We could have also used bash to automate the discovery of this flag. In that
    case, we’d iterate through the handlers to read the value of each handler. We
    could easily rewrite the following script into a simple fuzzer that writes values
    instead of performing the `--char-read` operation:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 bash 自动化发现这个标志。在这种情况下，我们将遍历各个处理程序以读取每个处理程序的值。我们可以轻松地将以下脚本重写为一个简单的模糊测试工具，它写入值而不是执行
    `--char-read` 操作：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When we run the script, we should obtain the information from the handles:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行脚本时，我们应该从句柄中获取信息：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Flag 2: Authentication'
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标志 2：身份验证
- en: When you view the FLAG_02 GATT table, you should see the message “Insufficient
    authentication” on handle 0x002c. You should also see the message “Connect with
    pin 0000” on handle 0x002a ([Figure 11-10](#figure11-10)). This challenge emulates
    a device with a weak pin code used for authentication.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看 FLAG_02 GATT 表时，你应该会在句柄 0x002c 上看到“身份验证不足”消息。你还应该在句柄 0x002a 上看到“使用 PIN
    0000 连接”消息（[图 11-10](#figure11-10)）。此挑战模拟了一种使用弱 PIN 码进行身份验证的设备。
- en: '![f11010](Images/f11010.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![f11010](Images/f11010.png)'
- en: 'Figure 11-10: We need to authenticate before reading the 002c handle.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-10：我们需要进行身份验证才能读取 002c 句柄。
- en: 'The hint implies we need to establish a secure connection to read the protected
    0x002c handle. To do this, we use GATTTool with the `--sec-level=high` option,
    which sets the security level of the connection to high and makes an authenticated,
    encrypted connection (AES-CMAC or ECDHE) before reading the value:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 提示表明我们需要建立一个安全连接才能读取受保护的 0x002c 句柄。为此，我们使用带有 `--sec-level=high` 选项的 GATTTool，该选项将连接的安全级别设置为高，并在读取值之前建立经过身份验证的加密连接（AES-CMAC
    或 ECDHE）：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Nice! This time, after converting from hex to ASCII, we get the flag 5d696cdf53a916c0a98d
    instead of the “Insufficient authentication” message. Go back to the scoreboard
    and submit it, as shown previously:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！这次，在将十六进制转换为 ASCII 后，我们得到标志 5d696cdf53a916c0a98d，而不是“身份验证不足”消息。回到积分榜并提交它，如之前所示：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The flag is correct, as shown on the scoreboard! We’ve solved challenge #2.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '标志是正确的，如积分榜所示！我们已经解决了挑战 #2。'
- en: 'Flag 3: Spoofing Your MAC Address'
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标志 3：伪造你的 MAC 地址
- en: Navigate to FLAG_03 and enumerate the services and characteristics in its GATT
    server. On handle 0x002a is the message “Connect with mac 11:22:33:44:55:66” ([Figure
    11-11](#figure11-11)). This challenge requires us to learn how to spoof the origin
    of the MAC address of a connection to read the handle.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到 FLAG_03 并枚举其 GATT 服务器中的服务和特征。在句柄 0x002a 上会看到“使用 MAC 11:22:33:44:55:66 连接”消息（[图
    11-11](#figure11-11)）。这个挑战要求我们学习如何伪造连接的 MAC 地址来源来读取该句柄。
- en: '![f11011](Images/f11011.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![f11011](Images/f11011.png)'
- en: 'Figure 11-11: FLAG_3 characteristics using Bettercap'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-11：使用 Bettercap 查看 FLAG_3 特征
- en: 'This means we must spoof our real Bluetooth MAC address to get the flag. Although
    you can use Hciconfig to issue commands that will change your MAC, the `spooftooph`Linux
    utility is a lot easier to use, because it doesn’t require you to send raw commands.
    Install it from your favorite package manager and run the following command to
    set your MAC to the address stated in the message:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们必须伪造真实的蓝牙 MAC 地址以获取标志。虽然你可以使用 Hciconfig 来发出改变 MAC 地址的命令，但`spooftooph`
    Linux 工具更易于使用，因为它不需要你发送原始命令。可以通过你喜欢的软件包管理器安装它，并运行以下命令将你的 MAC 地址设置为消息中提到的地址：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Verify your new spoofed MAC address using `hciconfig`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `hciconfig` 验证你的新伪造 MAC 地址：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Using Bettercap’s `ble.enum` command, take another look at the GATT server for
    this challenge. This time, you should see a new flag on the 0x002c handle ([Figure
    11-12](#figure11-12)).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Bettercap 的 `ble.enum` 命令，再次查看此挑战的 GATT 服务器。这次，你应该在 0x002c 句柄上看到一个新的标志（[图
    11-12](#figure11-12)）。
- en: '![f11012](Images/f11012.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![f11012](Images/f11012.png)'
- en: 'Figure 11-12: FLAG_3 is shown after connecting with the desired MAC address.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-12：连接到目标 MAC 地址后显示的 FLAG_3。
- en: 'Return to the scoreboard and submit your new flag:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到记分板并提交你的新旗帜：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Then check the scoreboard to see your updated score ([Figure 11-13](#figure11-13)).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后检查记分板，查看你更新后的得分（[图 11-13](#figure11-13)）。
- en: '![f11013](Images/f11013.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![f11013](Images/f11013.png)'
- en: 'Figure 11-13: The scoreboard after completing the first challenges'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-13：完成第一个挑战后的记分板
- en: Conclusion
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: After this brief introduction to BLE hacking, we hope we’ve inspired you to
    continue solving the CTF challenges. They’ll demonstrate real-life tasks that
    you’ll need daily when assessing BLE-enabled devices. We showed core concepts
    and some of the most popular attacks, but keep in mind that you can perform other
    attacks, too, such as man-in-the-middle attacks, if the device isn’t using a secure
    connection.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要介绍完 BLE 黑客攻击后，我们希望能够激励你继续解决 CTF 挑战。它们将展示你在评估 BLE 启用设备时每天都需要处理的实际任务。我们展示了核心概念和一些最常见的攻击，但请记住，你也可以执行其他攻击，例如中间人攻击，特别是当设备未使用安全连接时。
- en: Many specific protocol implementation vulnerabilities currently exist. For every
    new application or protocol that uses BLE, there’s a chance the programmer made
    an error that introduced a security bug in their implementation. Although the
    new version of Bluetooth (5.0) is available now, the adoption phase is moving
    slowly, so you’ll see plenty of BLE devices in the years to come.**
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 目前存在许多特定协议实现的漏洞。对于每一个使用 BLE 的新应用程序或协议，程序员都有可能犯错，从而在其实现中引入安全漏洞。尽管新的蓝牙版本（5.0）现在已经推出，但采用过程仍然缓慢，因此在未来几年你仍会看到大量的
    BLE 设备。**
