- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bluetooth Low Energy
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Bluetooth Low Energy (BLE)* is a version of the Bluetooth wireless technology
    IoT devices often use because of its low-energy consumption and because the pairing
    process is simpler than in previous Bluetooth versions. But BLE can also maintain
    similar, and sometimes greater, communication ranges. You can find it in all sorts
    of devices, from common health gadgets like smart watches or smart water bottles
    to critical medical equipment like insulin pumps and pacemakers. In industrial
    environments, you’ll see it in sensors, nodes, and gateways of all types. It’s
    even used in the military, where weapon components such as rifle scopes operate
    remotely via Bluetooth. Of course, these have already been hacked.'
  prefs: []
  type: TYPE_NORMAL
- en: These devices use Bluetooth to take advantage of the simplicity and robustness
    of this radio communication protocol, but doing so increases a device’s attack
    surface. In this chapter, you’ll learn how BLE communications work, explore common
    hardware and software that communicates with BLE devices, and master techniques
    to effectively identify and exploit security vulnerabilities. You’ll set up a
    lab using the ESP32 development board and then walk through levels of an advanced
    Capture the Flag (CTF) exercise designed specifically for BLE. After reading this
    chapter, you should be ready to tackle some of the remaining unsolved challenges
    from this CTF laboratory.
  prefs: []
  type: TYPE_NORMAL
- en: How BLE Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BLE consumes significantly less power than traditional Bluetooth, but it can
    transmit small amounts of data very efficiently. Available since the Bluetooth
    4.0 specification, BLE uses only 40 channels, covering the range of 2400 to 2483.5
    MHz. In contrast, traditional Bluetooth uses 79 channels in that same range.
  prefs: []
  type: TYPE_NORMAL
- en: Although every application uses this technology differently, the most common
    way BLE devices communicate is by sending advertising packets. Also known as *beacons*,
    these packets broadcast the BLE device’s existence to other nearby devices ([Figure
    11-1](#figure11-1)). These beacons sometimes send data, too.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11001](Images/f11001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-1: BLE devices send advertising packets to elicit a SCAN request.'
  prefs: []
  type: TYPE_NORMAL
- en: To reduce power consumption, BLE devices only send advertising packets when
    they need to connect and exchange data; they sleep the rest of the time. The listening
    device, also called a *central device*, can respond to an advertising packet with
    a *SCAN request* sent specifically to the advertising device. The response to
    that scan uses the same structure as the advertising packet. It contains additional
    information that couldn’t fit on the initial advertising request, such as the
    full device name or any additional information the vendor needs.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-2](#figure11-2) shows BLE’s packet structure.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f11002](Images/f11002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-2: BLE’s packet structure'
  prefs: []
  type: TYPE_NORMAL
- en: The preamble byte synchronizes the frequency, whereas the four-byte access address
    is a connection identifier, which is used in scenarios where multiple devices
    are trying to establish connections on the same channels. Next, the Protocol Data
    Unit (PDU) contains the advertising data. There are several types of PDU; the
    most commonly used are ADV_NONCONN_IND and ADV_IND. Devices use the ADV_NONCONN_IND
    PDU type if they don’t accept connections, transmitting data only in the advertising
    packet. Devices use ADV_IND if they allow connections and stop sending advertising
    packets once a connection has been established. [Figure 11-3](#figure11-3) shows
    an ADV_IND packet in a Wireshark capture.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11003](Images/f11003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-3: A Wireshark display tree showing a BLE advertising packet of type
    ADV_IND'
  prefs: []
  type: TYPE_NORMAL
- en: The type of packet used depends on the BLE implementation and project requirements.
    For example, you’ll find ADV_IND packets in smart IoT devices, such as smart water
    bottles or watches, because these seek to connect to a central device before performing
    further operations. On the other hand, you might find ADV_NONCONN_IND packets
    in beacons to detect an object’s proximity to sensors placed in various devices.
  prefs: []
  type: TYPE_NORMAL
- en: Generic Access Profile and Generic Attribute Profile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All BLE devices have a *Generic Access Profile (GAP)* that defines how they
    can connect to other devices, communicate with them, and make themselves available
    for discovery through broadcasting. A peripheral device can be connected to only
    one central device, whereas a central device can connect to as many peripherals
    as the central device can support. After establishing a connection, peripherals
    don’t accept any more connections. For each connection, the peripheral sends advertising
    probes at intervals, using three different frequencies, until the central device
    responds and the peripheral acknowledges the response indicating it’s ready to
    begin the connection.
  prefs: []
  type: TYPE_NORMAL
- en: The *Generic Attribute Profile (GATT)* defines how the device should format
    and transfer data. When you’re analyzing a BLE device’s attack surface, you’ll
    often concentrate your attention on the GATT (or GATTs), because it’s how device
    functionality gets triggered and how data gets stored, grouped, and modified.
    The GATT lists a device’s characteristics, descriptors, and services in a table
    as either 16- or 32-bits values. A *characteristic* is a data value sent between
    the central device and peripheral. These characteristics can have *descriptors*
    that provide additional information about them. Characteristics are often grouped
    in services if they’re related to performing a particular action. *Services* can
    have several characteristics, as illustrated in [Figure 11-4](#figure11-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11004](Images/f11004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-4: The GATT server structure is composed of services, characteristics,
    and descriptors.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with BLE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll walk through the hardware and software you’ll need to
    communicate with BLE devices. We’ll introduce you to hardware you can use to establish
    BLE connections, as well as software for interacting with other devices.
  prefs: []
  type: TYPE_NORMAL
- en: BLE Hardware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can choose from a variety of hardware to interact with BLE. For simply sending
    and receiving data, integrated interfaces or cheap BLE USB dongles might be enough.
    But for sniffing and performing low-level protocol hacking, you’ll need something
    more robust. Prices for these devices vary widely; you’ll find a list of hardware
    for interacting with BLE in “Tools for IoT Hacking.”
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll use the ESP32 WROOM development board from Espressif
    Systems ([https://www.espressif.com/](https://www.espressif.com/)), which supports
    2.4 GHz Wi-Fi and BLE ([Figure 11-5](#figure11-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11005](Images/f11005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-5: ESP32 WROOM development board'
  prefs: []
  type: TYPE_NORMAL
- en: It has an embedded flash memory, and conveniently, you can program and power
    it with a micro-USB cable. It’s very compact and affordable, and the antenna range
    is quite good for its size. You can program it for other attacks, too—for instance,
    attacks against Wi-Fi.
  prefs: []
  type: TYPE_NORMAL
- en: BlueZ
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on the device you’re using, you might need to install the required
    firmware or drivers for your software to be recognized and work correctly. In
    Linux, you’ll most likely be using *BlueZ*, the official Bluetooth stack, although
    proprietary drivers exist for adapters from vendors such as Broadcom or Realtek.
    The tools we’ll cover in this section all work out of the box with BlueZ.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re having a problem with BlueZ, be sure to install the latest version
    available at [http://www.bluez.org/download/](http://www.bluez.org/download/)
    because you could be using an earlier version pre-included in your Linux distribution’s
    package manager.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring BLE Interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Hciconfig* is a Linux tool that you can use to configure and test your BLE
    connections. If you run Hciconfig with no arguments, you should see your Bluetooth
    interface. You should also see the state `UP` or `DOWN`, which indicates whether
    or not the Bluetooth adapter interface is enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t see your interface, make sure the drivers are loaded. The kernel
    module name in Linux systems should be `bluetooth`. Use `modprobe` to show the
    module configuration with the `-c` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also try bringing down the interface and then bringing it back up again
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If that doesn’t work, try resetting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also list additional information with the `-a` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Discovering Devices and Listing Characteristics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a BLE-enabled IoT device isn’t protected properly, you can intercept, analyze,
    modify, and retransmit its communications to manipulate the device’s operations.
    Overall, when assessing the security of an IoT device with BLE, you should follow
    this process:'
  prefs: []
  type: TYPE_NORMAL
- en: Discover the BLE device address
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enumerate the GATT servers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify their functionality through the listed characteristics, services, and
    attributes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Manipulate the device functionality through read and write operations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s walk through these steps now using two tools: GATTTool and Bettercap.'
  prefs: []
  type: TYPE_NORMAL
- en: GATTTool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*GATTTool* is part of BlueZ. You’ll mainly use it for operations like establishing
    a connection with another device, listing that device’s characteristics, and reading
    and writing its attributes. Run GATTTool with no arguments to see the list of
    supported actions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'GATTTool can launch an interactive shell with the `-I` option. The following
    command sets the BLE adapter interface so you can connect to a device and list
    its characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the interactive shell, issue the `connect` `<mac address>` command to
    establish a connection; then list the characteristics with the `characteristics`
    subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have the handles, values, and services that describe the data and operations
    the BLE device supports.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s analyze this information with Bettercap, a more powerful tool that will
    help us see the information in a human-readable format.
  prefs: []
  type: TYPE_NORMAL
- en: Bettercap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Bettercap* ([https://www.bettercap.org/](https://www.bettercap.org/)) is a
    tool for scanning and attacking devices that operate on the 2.4 GHz frequency.
    It provides a friendly interface (even a GUI) and extensible modules to perform
    the most common tasks for BLE scanning and attacking, such as listening to advertising
    packets and performing read/write operations. Additionally, you can use it to
    attack Wi-Fi, HID, and other technologies with man-in-the-middle attacks or other
    tactics.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bettercap is installed on Kali by default, and it’s available in most Linux
    package managers. You can install and run it from Docker using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To discover BLE-enabled devices, enable the BLE module and start capturing
    beacons with the `ble.recon` option. Invoking it with the `--eval` option when
    loading Bettercap takes Bettercap commands and executes them automatically when
    Bettercap runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You should see a line for each BLE advertising packet received. This information
    should include the device name and MAC address, which you’ll need to establish
    communication with the devices.
  prefs: []
  type: TYPE_NORMAL
- en: If you launched Bettercap with the `eval` option, you can record all discovered
    devices automatically. Then you can conveniently issue the `ble.show` command
    to list the discovered devices and related information, such as their MAC addresses,
    vendors, and flags ([Figure 11-6](#figure11-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `ble.show` command output contains the signal strength (RSSI), the
    advertising MAC address we’ll use to connect to the device, and the vendor, which
    can give us a hint about the type of device we’re looking at. It also displays
    the combination of supported protocols, the connection status, and the last received
    beacon’s timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11006](Images/f11006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-6: Bettercap shows discovered devices'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating Characteristics, Services, and Descriptors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we’ve identified our target device’s MAC address, we can run the following
    Bettercap command. This command obtains a nice, formatted table with the characteristics
    grouped by services, their properties, and the data available through the GATT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 11-7](#figure11-7) shows the resulting table.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f11007](Images/f11007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-7: Enumerating GATT servers with Bettercap'
  prefs: []
  type: TYPE_NORMAL
- en: In the data column, we can see that this GATT server is the dashboard of a CTF
    describing the different challenges, as well as instructions for submitting your
    answers and checking your score.
  prefs: []
  type: TYPE_NORMAL
- en: This is a fun way to learn about practical attacks. But before we jump into
    solving one, let’s make sure you know how to perform classic read and write operations.
    You’ll use these for reconnaissance and to write data that alters a device’s state.
    The WRITE property is highlighted when handles allow the operations; pay close
    attention to the handles that support this, because they’re often misconfigured.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and Writing Characteristics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In BLE, UUIDs uniquely identify characteristics, services, and attributes.
    Once you know a characteristic’s UUID, you can write data to it with the `ble.write`
    Bettercap command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**You must format all the data you send in hexadecimal format. For example,
    to write the word “hello” to characteristic UUID ff06, you would send this command
    inside Bettercap’s interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use GATTTool to read and write data. GATTTool supports additional
    input formats for specifying handlers or UUIDs. For example, to issue a `write`
    command with GATTTool instead of Bettercap, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s practice reading some data using GATTTool. Grab the device name from
    the handler 0x16\. (This is reserved by the protocol to be the name of the device.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can now discover devices, list characteristics, and read and write data
    to attempt to manipulate the device’s functionality. You’re ready to start doing
    some BLE hacking.
  prefs: []
  type: TYPE_NORMAL
- en: BLE Hacking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we’ll walk through a CTF designed to help you practice hacking
    BLE: the BLE CTF Infinity project ([https://github.com/hackgnar/ble_ctf_infinity/](https://github.com/hackgnar/ble_ctf_infinity/)).
    Solving the CTF challenges requires using basic and advanced concepts. This CTF
    runs on the ESP32 WROOM board.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use Bettercap and GATTTool, because one often works better than the other
    for certain tasks. Solving these practical challenges from this CTF will teach
    you how to explore unknown devices to discover functionality and manipulate the
    states of these devices. Before moving on, make sure you set up your development
    environment and toolchain for ESP32, as described at [https://docs.espressif.com/projects/esp-idf/en/latest/get-started/](https://docs.espressif.com/projects/esp-idf/en/latest/get-started/).
    Most of the steps will work as documented with a few considerations that we’ll
    mention next.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up BLE CTF Infinity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build BLE CTF Infinity, we recommend using a Linux box, because the *make*
    file performs some additional copy operations on the source code (feel free to
    write a *CMakeLists.txt* file if you prefer building it on Windows). The file
    you need for this build is included with this book’s resources at [https://nostarch.com/practical-iot-hacking/](https://nostarch.com/practical-iot-hacking/).
    To build it successfully, you need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty folder named *main* in the project’s *root* folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `make menuconfig`. Make sure your serial device is configured and has
    Bluetooth enabled, and that compiler warnings are not treated as errors. Again,
    we include the *sdkconfig* file for this build with this book’s resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `make codegen` to run the Python script that copies the source files into
    the *main* folder among other things.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the file *main/flag_scoreboard.c* and change the variable `string_total_flags[]`
    from `0` to `00`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `make` to build the CTF and `make flash` to flash the board. When the process
    is complete, the CTF program will automatically start.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have CTF running, you should see the beacons when scanning. Another
    option is to communicate with the assigned serial port (default baud rate 115200)
    and check the debug output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Getting Started
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Locate the scoreboard, which shows the handle for submitting flags, the handle
    for navigating the challenges, and another handle to reset the CTF. Then enumerate
    the characteristics with your favorite tool ([Figure 11-8](#figure11-8)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The 0030 handle lets you navigate through the challenges. Using Bettercap,
    write the value `0001` to that handle to go to flag #1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To do the same with GATTTool, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![f11008](Images/f11008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-8: Bettercap enumerating BLE CTF Infinity'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve written the characteristic, the beacon name will indicate that
    you’re looking at the GATT server for flag #1\. For example, Bettercap will show
    something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This displays a new GATT table, one for each challenge. Now that you’re familiar
    with the basic navigation, let’s go back to the scoreboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s begin with flag #0\. Navigate to it by writing the value `0000` to the
    0x0030 handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, challenge 0 seems to be nothing more than the initial GATT server
    displaying the scoreboard ([Figure 11-9](#figure11-9)). Did we miss anything?
  prefs: []
  type: TYPE_NORMAL
- en: 'After taking a closer look, the device name 04dc54d9053b4307680a looks a lot
    like a flag, right? Let’s test it by submitting the device name as an answer to
    the handle 002e. Note that if you use GATTTool, you need to format it in hex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When we examine the scoreboard, we see that it worked as flag 0 is shown as
    complete. We’ve solved the first challenge. Congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: '![f11009](Images/f11009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-9: Characteristics of the BLE CTF INFINITY scoreboard'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flag 1: Examining Characteristics and Descriptors'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now navigate to FLAG_01 using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For this flag, we once again begin by examining the GATT table. Let’s try using
    GATTTool to list the characteristics and descriptors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After examining each of the descriptors, we find a value in handle 0x002c that
    looks like a flag. To read a handle’s descriptor value, we can use the `char-read-hnd`
    `<handle>` command, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the output is hex formatted, so this corresponds to the ASCII
    text 873c6495e4e738c94e1c.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve found the flag! Navigate back to the scoreboard and submit the new flag,
    as we did previously with flag 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We could have also used bash to automate the discovery of this flag. In that
    case, we’d iterate through the handlers to read the value of each handler. We
    could easily rewrite the following script into a simple fuzzer that writes values
    instead of performing the `--char-read` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the script, we should obtain the information from the handles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Flag 2: Authentication'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you view the FLAG_02 GATT table, you should see the message “Insufficient
    authentication” on handle 0x002c. You should also see the message “Connect with
    pin 0000” on handle 0x002a ([Figure 11-10](#figure11-10)). This challenge emulates
    a device with a weak pin code used for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11010](Images/f11010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-10: We need to authenticate before reading the 002c handle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The hint implies we need to establish a secure connection to read the protected
    0x002c handle. To do this, we use GATTTool with the `--sec-level=high` option,
    which sets the security level of the connection to high and makes an authenticated,
    encrypted connection (AES-CMAC or ECDHE) before reading the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice! This time, after converting from hex to ASCII, we get the flag 5d696cdf53a916c0a98d
    instead of the “Insufficient authentication” message. Go back to the scoreboard
    and submit it, as shown previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The flag is correct, as shown on the scoreboard! We’ve solved challenge #2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flag 3: Spoofing Your MAC Address'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Navigate to FLAG_03 and enumerate the services and characteristics in its GATT
    server. On handle 0x002a is the message “Connect with mac 11:22:33:44:55:66” ([Figure
    11-11](#figure11-11)). This challenge requires us to learn how to spoof the origin
    of the MAC address of a connection to read the handle.
  prefs: []
  type: TYPE_NORMAL
- en: '![f11011](Images/f11011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-11: FLAG_3 characteristics using Bettercap'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means we must spoof our real Bluetooth MAC address to get the flag. Although
    you can use Hciconfig to issue commands that will change your MAC, the `spooftooph`Linux
    utility is a lot easier to use, because it doesn’t require you to send raw commands.
    Install it from your favorite package manager and run the following command to
    set your MAC to the address stated in the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify your new spoofed MAC address using `hciconfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Using Bettercap’s `ble.enum` command, take another look at the GATT server for
    this challenge. This time, you should see a new flag on the 0x002c handle ([Figure
    11-12](#figure11-12)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11012](Images/f11012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-12: FLAG_3 is shown after connecting with the desired MAC address.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to the scoreboard and submit your new flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Then check the scoreboard to see your updated score ([Figure 11-13](#figure11-13)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f11013](Images/f11013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-13: The scoreboard after completing the first challenges'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After this brief introduction to BLE hacking, we hope we’ve inspired you to
    continue solving the CTF challenges. They’ll demonstrate real-life tasks that
    you’ll need daily when assessing BLE-enabled devices. We showed core concepts
    and some of the most popular attacks, but keep in mind that you can perform other
    attacks, too, such as man-in-the-middle attacks, if the device isn’t using a secure
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: Many specific protocol implementation vulnerabilities currently exist. For every
    new application or protocol that uses BLE, there’s a chance the programmer made
    an error that introduced a security bug in their implementation. Although the
    new version of Bluetooth (5.0) is available now, the adoption phase is moving
    slowly, so you’ll see plenty of BLE devices in the years to come.**
  prefs: []
  type: TYPE_NORMAL
