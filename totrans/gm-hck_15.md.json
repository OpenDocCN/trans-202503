["```\nclass StateDefinition {\npublic:\n    StateDefinition(){}\n    ~StateDefinition(){}\n    bool condition();\n    void reach();\n};\n```", "```\nstd::vector<StateDefinition> stateMachine;\n```", "```\nclass StateDefinition {\npublic:\n    StateDefinition(){}\n    ~StateDefinition(){}\n    bool condition(GameSensors* sensors);\n    void reach(GameSensors* sensors, GameActuators* actuators);\n};\n```", "```\nclass StateDefinition {\npublic:\n    StateDefinition(){}\n    ~StateDefinition(){}\n    std::function<bool(GameSensors*)> condition;\n    std::function<void(GameSensors*, GameActuators*)> reach;\n};\n```", "```\nstd::vector<StateDefinition> stateMachine(2);\n```", "```\n   auto curDef = stateMachine.begin();\n   curDef->condition = [](GameSensors* sensors) {\n➊     return sensors->getHealthPercent() > 50;\n   };\n   curDef->reach = [](GameSensors* sensors, GameActuators* actuators) {\n➋     actuators->strongHeal();\n   };\n```", "```\n   curDef++;\n   curDef->condition = [](GameSensors* sensors) {\n➊     return sensors->getHealthPercent() > 70;\n   };\n   curDef->reach = [](GameSensors* sensors, GameActuators* actuators) {\n➋     actuators->weakHeal();\n   };\n```", "```\nfor (auto state = stateMachine.begin(); state != stateMachine.end(); state++) {\n    if (➊!state->condition(&sensors)) {\n        state->reach(&sensors, &actuators);\n        break;\n    }\n}\n```", "```\nwhile (true) {\n    for (auto state = stateMachine.begin();\n         state != stateMachine.end();\n         state++) {\n        if (!state->condition(&sensors)) {\n            state->reach(&sensors, &actuators);\n            break;\n    }\n    Sleep(FEEDBACK_LOOP_TIMEOUT);\n}\n```", "```\ncurDef->condition = [](GameSensors* sensors) -> bool {\n    static float healAt = 70;\n    static bool hasLearned = false;\n    if (!hasLearned && sensors->detectedWeakHeal()) {\n        hasLearned = true;\n        healAt = 100 - sensors->getWeakHealIncrease();\n    }\n    return sensors->getHealthPercent() > healAt;\n};\n```", "```\n   curDef->condition = [](GameSensors* sensors) -> bool {\n       static float healAt = 50;\n➊     if (sensors->detectedStrongHeal()) {\n          auto newHealAt = 100 - sensors->getStrongHealIncrease();\n➋         healAt = (healAt + newHealAt) / 2.00f;\n➌         sensors->clearStrongHealInfo();\n       }\n       return sensors->getHealthPercent() > healAt;\n   };\n```", "```\nhealAt = (healAt + newHealAt * 2) / 3.00f;\n```", "```\n   curDef->condition = [](GameSensors* sensors) -> bool {\n       static float healAt = 50;\n       if (sensors->detectedStrongHeal()) {\n➊         if (sensors->getStrongHealMaxed()) {\n               healAt--;\n           } else {\n               auto newHealAt = 100 - sensors->getStrongHealIncrease();\n               healAt = (healAt + newHealAt) / 2.00f;\n           }\n           sensors->clearStrongHealInfo();\n       }\n       return sensors->getHealthPercent() > healAt;\n   };\n```", "```\ntypedef std::shared_ptr<class AStarNode> AStarNodePtr;\nclass AStarNode\n{\npublic:\n};\n```", "```\nint x, y;\nint g, score;\n```", "```\nAStarNodePtr parent;\n```", "```\nAStarNode(int x, int y, int cost, AStarNodePtr p, int score = 0)\n    : x(x), y(y), g(cost), score(score), parent(p)\n{}\n```", "```\nstatic AStarNodePtr makePtr(\n    int x, int y, int cost,\n    AStarNodePtr p,\n    int score = 0)\n{\n    return AStarNodePtr(new AStarNode(x, y, cost, p, score));\n}\n```", "```\n   int heuristic(const int destx, int desty) const\n   {\n       int xd = destx - x;\n       int yd = desty - y;\n➊     return abs(xd) + abs(yd);\n   }\n```", "```\n#define TILE_COST 1\nvoid updateScore(int endx, int endy)\n{\n    auto h = this->heuristic(endx, endy) * TILE_COST;\n    this->score = g + h;\n}\n```", "```\n   AStarNodePtr getCopy()\n   {\n       return AStarNode::makePtr(x, y, g, parent, score);\n   }\n   std::vector<AStarNodePtr> getChildren(int width, int height)\n   {\n       std::vector<AStarNodePtr> ret;\n       auto copy = getCopy();\n       if (x > 0)\n➊         ret.push_back(AStarNode::makePtr(x - 1, y, g + TILE_COST, copy));\n       if (y > 0)\n➋         ret.push_back(AStarNode::makePtr(x, y - 1, g + TILE_COST, copy));\n       if (x < width - 1)\n➌         ret.push_back(AStarNode::makePtr(x + 1, y, g + TILE_COST, copy));\n       if (y < height - 1)\n➍         ret.push_back(AStarNode::makePtr(x, y + 1, g + TILE_COST, copy));\n       return ret;\n   }\n```", "```\n➊ bool operator<(const AStarNodePtr &a, const AStarNodePtr &b)\n   {\n       return a.score > b.score;\n   }\n➋ bool operator==(const AStarNodePtr &a, const AStarNodePtr &b)\n   {\n       return a.x == b.x && a.y == b.y;\n   }\n```", "```\ntemplate<int WIDTH, int HEIGHT, int BLOCKING>\nbool doAStarSearch(\n    int map[WIDTH][HEIGHT],\n    int startx, int starty,\n    int endx, int endy,\n    int path[WIDTH][HEIGHT])\n{ }\n```", "```\nstd::vector<AStarNodePtr> allNodes;\nstd::priority_queue<AStarNodePtr> frontier;\n```", "```\nauto node = AStarNode::makePtr(startx, starty, 0, nullptr);\nnode->updateScore(endx, endy);\nallNodes.push_back(node);\n```", "```\nwhile (true) {\n}\n```", "```\nif (node->x == endx && node->y == endy) {\n    makeList<WIDTH, HEIGHT>(node, allNodes, path);\n    return true;\n}\n```", "```\n   auto children = node->getChildren(WIDTH, HEIGHT);\n   for (auto c = children.begin(); c != children.end(); c++) {\n➊     if (map[(*c)->x][(*c)->y] == BLOCKING) continue;\n       auto found = std::find(allNodes.rbegin(), allNodes.rend(), *c);\n➋     if (found != allNodes.rend()) {\n➌         if (*found > *c) {\n               (*found)->g = (*c)->g;\n               (*found)->parent = (*c)->parent;\n               (*found)->updateScore(endx, endy);\n           }\n       } else {\n           (*c)->updateScore(endx, endy);\n➍         frontier.push(*c);\n➎         allNodes.push_back(*c);\n       }\n   }\n```", "```\n   if (frontier.size() == 0) return false;\n➊ node = frontier.top();\n➋ frontier.pop();\n```", "```\n   template<int WIDTH, int HEIGHT>\n   void makeList(\n       AStarNodePtr end,\n       std::vector<AStarNodePtr> nodes,\n       int path[WIDTH][HEIGHT])\n   {\n       for (auto n = nodes.begin(); n != nodes.end(); n++)\n➊         path[(*n)->x][(*n)->y] = 2;\n       auto node = end;\n       while (node.get() != nullptr) {\n➋         path[node->x][node->y] = 1;\n           node = node->parent;\n       }\n   }\n```"]