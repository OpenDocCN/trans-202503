<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch15"><span epub:type="pagebreak" id="page_243"/><span class="big">15</span><br/>MECHANICS IN ONE DIMENSION</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">In this chapter, we’ll complete the story of mechanics in one dimension by developing tools for situations in which the forces on an object can depend on position as well as on time and velocity. This will require thinking about second-order differential equations, which we’ll convert into systems of first-order differential equations.</p>&#13;
<p class="indent">As before, we’ll transform information about the physical situation through several different forms, beginning with the object’s mass and the forces that act on it, and ending with functions that give the position and velocity of the object with time. A functional language like Haskell helps organize our thoughts about what it means to solve a mechanics problem by giving names and types to each form of information and by allowing that information to exist naturally in the form of a function when appropriate.</p>&#13;
<p class="indent">To apply the tools we’re developing, we’ll look at an example situation: the motion of a Ping-Pong ball attached to the end of a Slinky in the presence of air resistance—in other words, a damped harmonic oscillator. We’ll show how to apply the Euler method for a second-order differential equation, and we’ll see how either a list of states or position and velocity functions for an object can be regarded as a solution to a mechanics problem. We’ll then introduce the Euler-Cromer method, an improvement on the <span epub:type="pagebreak" id="page_244"/>Euler method for second-order differential equations. Since we’ll continue to modify the state variables and the data type used for state as we introduce vectors and multiple particles in upcoming chapters, at the end of this chapter, we’ll generalize our differential equation solving methods to allow arbitrary data types for state and allow a choice of numerical methods.</p>&#13;
<h3 class="h3" id="ch15lev1">Introductory Code</h3>&#13;
<p class="noindent">Let’s begin with the code that needs to appear at the beginning of our source code file. I always like to start by turning on warnings. I also include two language settings that we will use in “Solving Differential Equations” later in this chapter.</p>&#13;
<pre>{-# OPTIONS_GHC -Wall #-}&#13;
{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses #-}</pre>&#13;
<p class="indent">Let’s make the code in this chapter into a module named <span class="literal">Mechanics1D</span>.</p>&#13;
<pre>module Mechanics1D where</pre>&#13;
<p class="indent">We’ll also want to make a plot later, so let’s import the necessary module.</p>&#13;
<pre>import Graphics.Gnuplot.Simple</pre>&#13;
<p class="indent">For our example of a Ping-Pong ball on the end of a Slinky, we’ll use the air resistance function <span class="literal">fAir</span> from the previous chapter. To access this function, we import the module called <span class="literal">Newton2</span> we wrote in <a href="ch14.xhtml">Chapter 14</a>.</p>&#13;
<pre>import Newton2 ( fAir )</pre>&#13;
<p class="indent">The Haskell compiler will look for a file called <em>Newton2.hs</em> in the current working directory (the same directory that contains the <em>Mechanics1D.hs</em> file we are writing in this chapter). The file <em>Newton2.hs</em> contains the code we wrote in the previous chapter and is available at <a href="https://lpfp.io">https://lpfp.io</a>.</p>&#13;
<p class="indent">If we include a comma-separated list of types and functions in parentheses after the module name, we’ll import only those types and functions. If we omit such a list, as we did when importing the <span class="literal">Graphics.Gnuplot.Simple</span> module, we’ll import all types and functions provided by the module.</p>&#13;
<p class="indent">As usual, we’ll use the type synonym <span class="literal">R</span> instead of <span class="literal">Double</span>. We made this type synonym in the <span class="literal">SimpleVec</span> module of <a href="ch10.xhtml">Chapter 10</a>, and we import it from there.</p>&#13;
<pre>import SimpleVec ( R )</pre>&#13;
<p class="indent">The warnings option, the language setting, the module name, and the import statements need to be at the beginning of the source code file. Type synonyms can appear anywhere.</p>&#13;
<p class="indent">When we do mechanics in one dimension, time, a time step, mass, position, velocity, and force are each represented by a real number.</p>&#13;
<span epub:type="pagebreak" id="page_245"/>&#13;
<pre>type Time     = R&#13;
type TimeStep = R&#13;
type Mass     = R&#13;
type Position = R&#13;
type Velocity = R&#13;
type Force    = R</pre>&#13;
<h3 class="h3" id="ch15lev2">Forces That Depend on Time, Position, and Velocity</h3>&#13;
<p class="noindent">When the forces on an object depend on time, position, and velocity, the force functions depend on three variables. We’ll use <img class="inline" src="Images/e0245-01.jpg" alt="Image" width="34" height="26"/> to denote the <em>j</em>th function of three variables that gives a force when supplied with time, position, and velocity; we’ll use <img class="inline" src="Images/e0245-02.jpg" alt="Image" width="40" height="21"/> to denote the function of three variables that gives net force. <a href="ch15.xhtml#ch15fig1">Figure 15-1</a> shows a schematic diagram for Newton’s second law with forces that depend on time, position, and velocity.</p>&#13;
<div class="imagel" id="ch15fig1"><img src="Images/f0245-01.jpg" alt="Image" width="647" height="486"/></div>&#13;
<p class="figcap"><em>Figure 15-1: Newton’s second law in one dimension. The forces depend on time, position, and velocity.</em></p>&#13;
<p class="indent">The rectangular boxes in the diagram are pure functions whose output depends only on the input. The integrators are contained in circles to remind us that each integrator contains some state. The integrator whose output is <em>x</em>(<em>t</em>), for example, must contain the current position value. The schematic diagram in <a href="ch15.xhtml#ch15fig1">Figure 15-1</a> is continuous and stateful.</p>&#13;
<p class="indent">Newton’s second law appears as the following differential equation:</p>&#13;
<div class="imagec"><img src="Images/e0245-03.jpg" alt="Image" width="467" height="25"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_246"/>We’ve come to the full generality of Newton’s second law in one dimension, as given in the previous chapter by Equation 14.2. Position is the unknown function we want to find in this differential equation. This is a second-order differential equation because a second derivative of position appears in the equation. To solve a second-order differential equation using a state-based approach, we’ll choose some state variables and write first-order differential equations for each of the state variables.</p>&#13;
<p class="indent">What should our state variables be? <a href="ch15.xhtml#ch15fig1">Figure 15-1</a> has two integrators contained in loops. These integrators hold position and velocity as state, so position and velocity are required to be state variables. While it is possible to solve Equation 15.1 using only position and velocity as state variables, it is easier if we also allow time to serve as a state variable because the forces could also depend on time. Our data type describing state for the mechanics of a single object moving in one dimension is a time-position-velocity triple.</p>&#13;
<pre>type State1D = (Time,Position,Velocity)</pre>&#13;
<p class="indent">We use the name <em>state space</em> for data types like <span class="literal">State1D</span> that describe state. The types <span class="literal">Velocity</span> and <span class="literal">(Time,Velocity)</span> from the previous chapter are other examples of state spaces.</p>&#13;
<p class="indent">Equations 15.2, 15.3, and 15.4 show the three first-order differential equations obtained by writing expressions for the time derivatives of each state variable. What appears on the right side of these equations can involve the state variables but may not have any derivatives. Because the derivative of the position function depends on the velocity function, and vice versa, we refer to this as a set of <em>coupled</em> differential equations.</p>&#13;
<div class="imagec"><img src="Images/246equ01.jpg" alt="Image" width="486" height="161"/></div>&#13;
<p class="indent">The function <span class="literal">newtonSecond1D</span> gives expressions for the time derivatives of the state variables in terms of the state variables themselves. Note that the state variables in this function are real numbers rather than functions of time. By expressing the differential Equations 15.2, 15.3, and 15.4, the function <span class="literal">newtonSecond1D</span> expresses Newton’s second law in one dimension. The schematic diagram in <a href="ch15.xhtml#ch15fig1">Figure 15-1</a>, the differential equations, and the Haskell function <span class="literal">newtonSecond1D</span> each contain the essential information for understanding and solving Newton’s second law in one dimension.</p>&#13;
<span epub:type="pagebreak" id="page_247"/>&#13;
<pre>newtonSecond1D :: Mass&#13;
               -&gt; [State1D -&gt; Force]  -- force funcs&#13;
               -&gt; State1D             -- current state&#13;
               -&gt; (R,R,R)             -- deriv of state&#13;
newtonSecond1D m fs (t,x0,v0)&#13;
    = let fNet = sum [f (t,x0,v0) | f &lt;- fs]&#13;
          acc = fNet / m&#13;
      in (1,v0,acc)</pre>&#13;
<h4 class="h4" id="ch15lev3">A General Strategy for Solving Mechanics Problems</h4>&#13;
<p class="noindent">Our strategy for constructing and solving Newton’s second law consists of transforming information about the physical situation through a sequence of five different forms:</p>&#13;
<ol>&#13;
<li class="noindent">Mass and force functions</li>&#13;
<li class="noindent">Differential equation</li>&#13;
<li class="noindent">State-update function</li>&#13;
<li class="noindent">List of states</li>&#13;
<li class="noindent">Position and velocity functions</li>&#13;
</ol>&#13;
<p class="indent">The information begins with the mass of the object under consideration and the forces that act on it, expressed as functions of the state variables. The function <span class="literal">newtonSecond1D</span> transforms this mass and force information into a differential equation. A differential equation is a function <span class="literal">State1D -&gt; (R,R,R)</span> that gives the derivatives of the state variables time, position, and velocity in terms of the state variables themselves. The Euler method transforms a differential equation into a state-update function, a function <span class="literal">State1D -&gt; State1D</span> that computes the state variables at a later time from the state variables at an earlier time. From a state-update function and an initial state, we can then compute an infinite list of states, the fourth representation of the data describing our physical situation. Finally, we can extract position as a function of time and velocity as a function of time from the list of states. Predicting the position and velocity of the object as a function of time is the final data representation, which we regard as a solution to the problem of understanding the motion of an object.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15fig2">Figure 15-2</a> is a functional diagram showing the five data representations above and the functions that transform the data from one representation to another.</p>&#13;
<div class="imagel" id="ch15fig2"><img src="Images/248fig01.jpg" alt="Image" width="708" height="647"/></div>&#13;
<p class="figcap"><em>Figure 15-2: Data flow for solving a mechanics problem in one dimension. Functions transform the data through a sequence of five representations.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_248"/>We have already discussed how <span class="literal">newtonSecond1D</span> transforms mass and force data into a differential equation. We’ll discuss the other transformations in detail later. <a href="ch15.xhtml#ch15fig2">Figure 15-2</a> is the first of several figures in this chapter and the next few chapters that serve to give an overview of the process of solving a mechanics problem. As we expand and generalize the ideas of state and numerical method, these figures will become more general, more streamlined, and a bit more abstract. Their purpose, central to a deep understanding of Newtonian mechanics, is to suggest a high-level way of thinking about the meanings and solution techniques of Newton’s laws. The figures organize the many functions we’ve written into a coherent, operational description of how to make predictions with Newtonian mechanics. Understanding what it takes to solve Newton’s second law is a prerequisite to a more profound insight into what the law means.</p>&#13;
<p class="indent">Note that there are two places in <a href="ch15.xhtml#ch15fig2">Figure 15-2</a> where additional information comes in. A time step is required for the Euler method that transforms a differential equation into a state-update function, and an initial state is required to transform a state-update function into a list of states. In this figure, <span epub:type="pagebreak" id="page_249"/>I regard the object’s mass, along with the forces, to be part of the initial information that specifies the problem.</p>&#13;
<h4 class="h4" id="ch15lev4">Solving with Euler’s Method</h4>&#13;
<p class="noindent">To solve differential Equations 15.2, 15.3, and 15.4, we will discretize time, choosing a time step <em>Δt</em> that is smaller than any important time scales in the problem we are solving. We’ll use the Euler method, which approximates the time-slope of each state variable over the course of one time step by the time derivative of that variable at the beginning of the time step. <a href="ch15.xhtml#ch15fig3">Figure 15-3</a> shows the Euler method for solving Newton’s second law in one dimension.</p>&#13;
<div class="imagel" id="ch15fig3"><img src="Images/249fig01.jpg" alt="Image" width="628" height="542"/></div>&#13;
<p class="figcap"><em>Figure 15-3: Euler method for Newton’s second law in one dimension</em></p>&#13;
<p class="indent">Unlike the schematic diagram of <a href="ch15.xhtml#ch15fig1">Figure 15-1</a>, with values that continuously change with time, the functional diagram in <a href="ch15.xhtml#ch15fig3">Figure 15-3</a> has values that do not change. Change in a quantity, such as position, over time is represented by a sequence of values on different wires.</p>&#13;
<p class="indent">The function <span class="literal">euler1D</span>, shown below, transforms a differential equation into a state-update function, as shown in <a href="ch15.xhtml#ch15fig2">Figure 15-2</a>. To do this, it takes a time step in addition to the differential equation as input. Each state variable is updated by changing its value by its derivative (calculated from the differential equation) multiplied by the time step.</p>&#13;
<span epub:type="pagebreak" id="page_250"/>&#13;
<pre>euler1D :: R                     -- time step dt&#13;
        -&gt; (State1D -&gt; (R,R,R))  -- differential equation&#13;
        -&gt; State1D -&gt; State1D    -- state-update function&#13;
euler1D dt deriv (t0,x0,v0)&#13;
    = let (_, _, dvdt) = deriv (t0,x0,v0)&#13;
          t1 = t0 + dt&#13;
          x1 = x0 + v0 * dt&#13;
          v1 = v0 + dvdt * dt&#13;
      in (t1,x1,v1)</pre>&#13;
<p class="indent"><a href="ch15.xhtml#ch15fig3">Figure 15-3</a> composes a state-update function over and over again. We call the state-update function <span class="literal">updateTXV</span> because it updates time, position, and velocity. As before, let’s go through three expressions of this state-update function. <a href="ch15.xhtml#ch15fig4">Figure 15-4</a> shows the state-update function as a functional diagram, indicating how a new time-position-velocity triple is formed from an old triple.</p>&#13;
<div class="imagel" id="ch15fig4"><img src="Images/250fig01.jpg" alt="Image" width="311" height="542"/></div>&#13;
<p class="figcap"><em>Figure 15-4: How to update the state variables time, position, and velocity when a small time interval</em> Δ<em>t has elapsed</em></p>&#13;
<p class="indent">Now we’ll give state-update equations in mathematical notation. The state-update equations tell us how the state variables time, position, and velocity must be updated to advance to the next time step.</p>&#13;
<div class="imagec"><img src="Images/251equ01.jpg" alt="Image" width="498" height="108"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_251"/>Finally, we define the Haskell function <span class="literal">updateTXV</span>, which produces a new state triple from an old state triple.</p>&#13;
<pre>updateTXV :: R                   -- time interval dt&#13;
          -&gt; Mass&#13;
          -&gt; [State1D -&gt; Force]  -- list of force funcs&#13;
          -&gt; State1D -&gt; State1D  -- state-update function&#13;
updateTXV dt m fs = euler1D dt (newtonSecond1D m fs)</pre>&#13;
<p class="indent">Note that <span class="literal">updateTXV</span> is essentially the composition of <span class="literal">newtonSecond1D</span> and <span class="literal">euler1D</span>, so it transforms the mass and force data (the first of our five data representations) into a state-update function (the third of the five).</p>&#13;
<h4 class="h4" id="ch15lev5">Producing a List of States</h4>&#13;
<p class="noindent">The next step in the data flow of <a href="ch15.xhtml#ch15fig2">Figure 15-2</a> is to produce an infinite list of states from the state-update function and an initial state. The Haskell Prelude function <span class="literal">iterate</span> can do this, essentially transforming <a href="ch15.xhtml#ch15fig4">Figure 15-4</a> into <a href="ch15.xhtml#ch15fig3">Figure 15-3</a>. A list of time-position-velocity triples can be regarded as a solution to a Newton’s second law problem. The list of states contains a time-position-velocity triple for every time that has been probed by the Euler method of <a href="ch15.xhtml#ch15fig3">Figure 15-3</a>. The function <span class="literal">statesTXV</span> produces a list of states when given a time step, a mass, an initial state, and a list of force functions.</p>&#13;
<pre>statesTXV :: R                   -- time step&#13;
          -&gt; Mass&#13;
          -&gt; State1D             -- initial state&#13;
          -&gt; [State1D -&gt; Force]  -- list of force funcs&#13;
          -&gt; [State1D]           -- infinite list of states&#13;
statesTXV dt m txv0 fs = iterate (updateTXV dt m fs) txv0</pre>&#13;
<p class="indent">All we are doing here is iterating the update function to produce an infinite list of states. Note that we need to pass the time step, mass, and list of forces as parameters to <span class="literal">updateTXV</span> before it can serve as an iterable function passable to <span class="literal">iterate</span>. Iterate requires a function with type <span class="literal">a -&gt; a</span> that can be applied again and again.</p>&#13;
<p class="indent">The function <span class="literal">statesTXV</span> transforms the mass and force data (the first of our five data representations), along with a time step and an initial state, into an infinite list of states (the fourth of our five representations). With this function, we have a general-purpose way of solving any Newton’s second law type problem in one spatial dimension. By a solution, we mean an infinite list of states (time-position-velocity triples) of the object, spaced one <span epub:type="pagebreak" id="page_252"/>time step apart from each other. From this infinite list of states, we can extract whatever data we are most interested in and graph it or animate it.</p>&#13;
<h4 class="h4" id="ch15lev6">Position and Velocity Functions</h4>&#13;
<p class="noindent">For our fifth and last data representation, we wish to write a function <span class="literal">velocity</span> <span class="literal">Ftxv</span>, similar to <span class="literal">velocityCF</span>, <span class="literal">velocityFt</span>, <span class="literal">velocityFv</span>, and <span class="literal">velocityFtv</span>, but for the case of forces that depend on time, position, and velocity. This function will transform the mass and force data (the first of our five data representations), along with a time step and an initial state, into a velocity function (part of the fifth of our five representations).</p>&#13;
<p class="indent">To help us do this, we want to write a function <span class="literal">velocity1D</span> that transforms from an infinite list of states (the fourth of our five data representations) into a velocity function.</p>&#13;
<pre>-- assume that dt is the same between adjacent pairs&#13;
velocity1D :: [State1D]         -- infinite list&#13;
           -&gt; Time -&gt; Velocity  -- velocity function&#13;
velocity1D sts t&#13;
    = let (t0,_,_) = sts !! 0&#13;
          (t1,_,_) = sts !! 1&#13;
          dt = t1 - t0&#13;
          numSteps = abs $ round (t / dt)&#13;
          (_,_,v0) = sts !! numSteps&#13;
      in v0</pre>&#13;
<p class="indent">We name the infinite list of states <span class="literal">sts</span> and the desired time <span class="literal">t</span>. We assume that the time step stays the same throughout the infinite list of states, and we calculate the time step from the time values in the first two states of the list. In the first two lines of the <span class="literal">let</span> clause, we use the list index operator (<span class="literal">!!</span>) to pick out the first and second states of the list. Since <span class="literal">State1D</span> is a type synonym for <span class="literal">(R,R,R)</span>, we use pattern matching to pick out the time from the state. The local variables <span class="literal">t0</span> and <span class="literal">t1</span> are the times for the first two states in the list.</p>&#13;
<p class="indent">The third line in the <span class="literal">let</span> clause defines a local variable <span class="literal">dt</span> for the time step, calculated as the difference between the times of the first and second states. The fourth line in the <span class="literal">let</span> clause computes the number of time steps required to reach the state that is closest to the desired time, and it names this number of steps with the local variable <span class="literal">numSteps</span>. The fifth line in the <span class="literal">let</span> clause uses the list index operator to pick out the state closest to the desired time and then names the velocity of that state <span class="literal">v0</span> using pattern matching.</p>&#13;
<p class="indent">All of the real work in this function is done in the <span class="literal">let</span> clause. The function returns <span class="literal">v0</span>, which is the velocity that occurs closest to the desired time <span class="literal">t</span>.</p>&#13;
<p class="indent">For the function <span class="literal">velocityFtxv</span>, which does the full transformation, we’ll use the infinite list produced by <span class="literal">statesTXV</span>, in conjunction with <span class="literal">velocity1D</span>.</p>&#13;
<pre>velocityFtxv :: R                   -- time step&#13;
             -&gt; Mass&#13;
             -&gt; State1D             -- initial state&#13;
             -&gt; [State1D -&gt; Force]  -- list of force funcs&#13;
             -&gt; Time -&gt; Velocity    -- velocity function&#13;
velocityFtxv dt m txv0 fs = velocity1D (statesTXV dt m txv0 fs)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_253"/>Once we have a velocity function, we could integrate to get a position function, but all of this position information is contained in our list of states, so we might as well extract the position function from that using <span class="literal">position1D</span>, which is very similar to <span class="literal">velocity1D</span>.</p>&#13;
<pre>-- assume that dt is the same between adjacent pairs&#13;
position1D :: [State1D]           -- infinite list&#13;
           -&gt; Time -&gt; Position    -- position function&#13;
position1D sts t&#13;
    = let (t0,_,_) = sts !! 0&#13;
          (t1,_,_) = sts !! 1&#13;
          dt = t1 - t0&#13;
          numSteps = abs $ round (t / dt)&#13;
          (_,x0,_) = sts !! numSteps&#13;
      in x0</pre>&#13;
<p class="indent">Here is the function <span class="literal">positionFtxv</span>, which makes the full transition from our initial data representation in terms of mass and forces, along with a time step and an initial state, into our final representation giving the position of our object as a function of time.</p>&#13;
<pre>positionFtxv :: R                   -- time step&#13;
             -&gt; Mass&#13;
             -&gt; State1D             -- initial state&#13;
             -&gt; [State1D -&gt; Force]  -- list of force funcs&#13;
             -&gt; Time -&gt; Position    -- position function&#13;
positionFtxv dt m txv0 fs = position1D (statesTXV dt m txv0 fs)</pre>&#13;
<p class="indent">With the functions <span class="literal">velocityFtxv</span> and <span class="literal">positionFtxv</span>, we have a general purpose way of solving any Newton’s second law problem in one spatial dimension.</p>&#13;
<p class="indent">Next let’s look at an example of where to use this technology: a Ping-Pong ball oscillating at the end of a Slinky. The restoring force of the Slinky on the ball depends on the position of the Ping-Pong ball, and air resistance depends on the velocity of the ball.</p>&#13;
<h3 class="h3" id="ch15lev7">A Damped Harmonic Oscillator</h3>&#13;
<p class="noindent">As an example of a situation with forces that depend on position and velocity, let’s consider a damped harmonic oscillator. In particular, let’s consider a Ping-Pong ball oscillating at the end of a vertically hanging Slinky. A Slinky is a spring, made of metal or plastic, that is sold as a child’s toy. We’ll choose a coordinate system where up is positive and choose the zero of position to <span epub:type="pagebreak" id="page_254"/>be the place where the lower end of the Slinky hangs without the Ping-Pong ball attached. The Ping-Pong ball has a mass of 2.7 g and a radius of 2 cm.</p>&#13;
<p class="indent">We’ll include three forces on the ball, all acting vertically. The first force is produced by the spring and acts to restore the mass toward the equilibrium position. The spring force is given by <em>Hooke’s law</em>,</p>&#13;
<div class="imagec"><img src="Images/254equ01.jpg" alt="Image" width="420" height="23"/></div>&#13;
<p class="noindent">which claims that the force produced by the spring is proportional to the displacement <em>x</em><sub>0</sub> of the mass from its equilibrium position. The constant <em>k</em> is called the <em>spring constant</em> of the spring. A spring with a large spring constant is stiff and takes lots of force to extend or compress. The minus sign makes the spring force a <em>restoring force</em>, which acts in a direction to restore the object to its equilibrium position.</p>&#13;
<p class="indent">The equilibrium position is <em>x</em><sub>0</sub> = 0. If <em>x</em><sub>0</sub> is positive, then <em>F</em><sub>spring</sub>(<em>x</em><sub>0</sub>) is negative, and the force acts toward the equilibrium position. If <em>x</em><sub>0</sub> is negative, then <em>F</em><sub>spring</sub>(<em>x</em><sub>0</sub>) is positive, and again the force acts toward the equilibrium position.</p>&#13;
<p class="indent">The spring force depends only on the ball’s position and not on its velocity or on the time. But knowing that we want to use a function like <span class="literal">statesTXV</span> or <span class="literal">positionFtxv</span>, which requires a list of forces <span class="literal">State1D -&gt; Force</span> given as functions of the state, we’ll write Hooke’s law so that it has this type.</p>&#13;
<pre>springForce :: R -&gt; State1D -&gt; Force&#13;
springForce k (_,x0,_) = -k * x0</pre>&#13;
<p class="indent">The second force is the force of air resistance, a force that damps the natural oscillation of the ball on the spring. We’ll use Equation 14.9 for air resistance, repeated here.</p>&#13;
<div class="imagec"><img src="Images/254equ02.jpg" alt="Image" width="181" height="44"/></div>&#13;
<p class="indent">We use a drag coefficient of 2.</p>&#13;
<p class="indent">The third force is the force of gravity acting on the ball. Near Earth’s surface, the force of gravity on an object with mass <em>m</em> is</p>&#13;
<div class="imagec"><em>F<sub>g</sub></em> = –<em>mg</em></div>&#13;
<p class="noindent">where <em>g</em> = 9.80665 m/s<sup>2</sup> is the acceleration of gravity, and where we employ a coordinate system in which “away from Earth’s center” is the positive direction.</p>&#13;
<p class="indent">We take the Slinky to have a spring constant of 0.8 kg/s<sup>2</sup>. We’ll release the ball at a position 10 cm above the equilibrium position so that <em>x</em>(0 s) = 0.1 m and <em>v</em>(0 s) = 0 m/s.</p>&#13;
<p class="indent">Before we use our Haskell functions to investigate the motion of the ball, let’s investigate it using Euler’s method by hand.</p>&#13;
<h4 class="h4" id="ch15lev8">Euler Method by Hand</h4>&#13;
<p class="noindent">We want to have a clear mental picture of what the computer is doing when it applies the Euler method. To this end, we will calculate a few steps of the <span epub:type="pagebreak" id="page_255"/>Euler method by hand (meaning with a calculator) to see in detail what is happening.</p>&#13;
<p class="indent">We’ll use the state-update Equations 15.6 and 15.7 with a time step of Δ<em>t</em> = 0.1 s. A time step of 0.1 seconds is too large to get accurate results for this problem, but it serves to show the essence of the Euler method.</p>&#13;
<p class="indent">Our mission is to complete the following table. We can fill in all of the time values because they are simply spaced at 0.1 s intervals. We’ll also fill in the initial values of position and velocity.</p>&#13;
<table class="all5">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>t (s)</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>x(t) (m)</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>v(t) (m/s)</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">0.0</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">0.1000</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">0.0000</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">0.1</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">0.2</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">0.3</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"/></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"/></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The net force on the Ping-Pong ball is given by the following expression:</p>&#13;
<div class="imagec"><img src="Images/255equ01.jpg" alt="Image" width="353" height="45"/></div>&#13;
<p class="indent">Using <em>t</em> = 0.0 s, <em>x</em>(0.0 s) = 0.1000 m and <em>v</em>(0.0 s) = 0.0000 m/s (in other words, the information in the first row of our table) in the state-update Equations 15.6 and 15.7, we can find <em>x</em>(0.1 s) and <em>v</em>(0.1 s) (the information in the second row of our table). The state-update equations are exactly what we need to produce a new row of our table from an existing row.</p>&#13;
<div class="imagec"><img src="Images/255equ02.jpg" alt="Image" width="396" height="227"/></div>&#13;
<p class="indent">Using <em>t</em> = 0.1 s, <em>x</em>(0.1 s) = 0.1000 m, and <em>v</em>(0.1 s) = –3.9436 m/s (the information in the second row of our table) in the state-update equations, we can find <em>x</em>(0.2 s) and <em>v</em>(0.2 s) (the information in the third row).</p>&#13;
<div class="imagec"><img src="Images/255equ03.jpg" alt="Image" width="436" height="226"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_256"/>Using <em>t</em> = 0.2 s, <em>x</em>(0.2 s) = –0.2944 m, and <em>v</em>(0.2 s) = –7.0005 m/s (the information in the third row of our table), we can find <em>x</em>(0.3 s) and <em>v</em>(0.3 s). (the information in the fourth row).</p>&#13;
<div class="imagec"><img src="Images/256equ01.jpg" alt="Image" width="436" height="226"/></div>&#13;
<p class="indent">The completed table looks as follows:</p>&#13;
<table class="all5">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>t (s)</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>x(t) (m)</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>v(t) (m/s)</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">0.0</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">0.1000</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">0.0000</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">0.1</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">0.1000</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">–3.9436</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">0.2</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">–0.2944</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">–7.0005</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">0.3</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">–0.9945</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">3.5359</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Since states are time-position-velocity triples, this completed table contains the first four states of the Ping-Pong ball for the Euler method with a time step of 0.1 s. If we ask the computer to produce an infinite list of states using our function <span class="literal">statesTXV</span>, the first four states should look like this. We can imagine that the process we used to complete this table is what the computer is doing over and over again to produce a list of states for us.</p>&#13;
<p class="indent">Let’s now turn to the technology we developed earlier in the chapter to find the position of the Ping-Pong ball as a function of time.</p>&#13;
<h4 class="h4" id="ch15lev9">Method 1: Producing a List of States</h4>&#13;
<p class="noindent">Here we’ll use the <span class="literal">statesTXV</span> function to produce a list of states and then extract position versus time information to make a graph.</p>&#13;
<p class="indent">We’re not required to give a name to the list of forces that act on the Ping-Pong ball. We could insert the list as the appropriate input to <span class="literal">statesTXV</span>, but I think it may organize and help our thinking to give the list of forces a name. Let’s call it <span class="literal">dampedHOForces</span>.</p>&#13;
<pre>dampedHOForces :: [State1D -&gt; Force]&#13;
dampedHOForces = [springForce 0.8&#13;
                 ,\(_,_,v0) -&gt; fAir 2 1.225 (pi * 0.02**2) v0&#13;
                 ,\_ -&gt; -0.0027 * 9.80665&#13;
                 ]</pre>&#13;
<p class="indent">We see that this is a list of the three forces we discussed earlier. First we have the spring force, then the force of air resistance, and then the force <span epub:type="pagebreak" id="page_257"/>of gravity. We use anonymous-function notation to express the latter two forces because they need to be expressed as functions of the state. In the case of the force of gravity, we don’t care at all about the state, so we don’t need to name the state or name the time, position, and/or velocity variables that make up the state. For the force of air resistance, underscores in the time and position entries for the state are reminders that the air resistance function does not need their values.</p>&#13;
<p class="indent">To produce an infinite list of states, we use the <span class="literal">statesTXV</span> function with a time step of 1 ms, or 0.001 s, which is on the threshold of acceptability in the sense that smaller time steps would produce a graph that is only a little bit different in its results.</p>&#13;
<pre>dampedHOStates :: [State1D]&#13;
dampedHOStates = statesTXV 0.001 0.0027 (0.0,0.1,0.0) dampedHOForces</pre>&#13;
<p class="indent">We need to send <span class="literal">dampedHOStates</span> all of the information about our problem. In addition to the time step of 0.001 s, we send the Ping-Pong ball mass of 0.0027 kg, the initial state consisting of time 0 s, position 0.1 m, and velocity 0 m/s, and the list of forces, which we named <span class="literal">dampedHOForces</span>.</p>&#13;
<p class="indent">If you want to look at the raw time-position-velocity data, you can use the list element operator (<span class="literal">!!</span>) to select particular states from the list, or you can <span class="literal">take</span> the first several elements of this infinite list.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:l Mechanics1D</span>&#13;
[1 of 2] Compiling Newton2         ( Newton2.hs, interpreted )&#13;
[2 of 2] Compiling Mechanics1D     ( Mechanics1D.hs, interpreted )&#13;
Ok, two modules loaded.&#13;
*Mechanics1D&gt; <span class="codestrong1">dampedHOStates !! 0</span>&#13;
(0.0,0.1,0.0)&#13;
*Mechanics1D&gt; <span class="codestrong1">dampedHOStates !! 5</span>&#13;
(5.0e-3,9.960571335911717e-2,-0.1970379672671094)&#13;
*Mechanics1D&gt; <span class="codestrong1">take 2 dampedHOStates</span>&#13;
[(0.0,0.1,0.0),(1.0e-3,0.1,-3.943627962962963e-2)]</pre>&#13;
<p class="indent">A list of pairs is something we can plot with the <span class="literal">plotPath</span> function from the <span class="literal">gnuplot</span> package, but we need to truncate the list to a finite list before plotting; otherwise, <span class="literal">plotPath</span> will hang while trying to finish calculating an infinite list. In the code that follows, we use the <span class="literal">take</span> function to extract the first 3,000 states, corresponding to the first three seconds of motion.</p>&#13;
<pre>dampedHOGraph :: IO ()&#13;
dampedHOGraph&#13;
    = plotPath [Title "Ping Pong Ball on a Slinky"&#13;
               ,XLabel "Time (s)"&#13;
               ,YLabel "Position (m)"&#13;
               ,PNG "dho.png"&#13;
               ,Key Nothing&#13;
               ] [(t,x) | (t,x,_) &lt;- take 3000 dampedHOStates]</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_258"/><a href="ch15.xhtml#ch15fig5">Figure 15-5</a> shows the oscillation of the ball as a function of time. Notice the oscillation is not centered at position zero. This is because zero is the equilibrium position of the spring with no ball attached. When we attach the Ping-Pong ball, its weight will extend the spring downward, forming a new equilibrium position at the place where – <em>k</em><sub><em>x</em>0</sub> – <em>mg</em> = 0. The upward force of the spring cancels the downward force of gravity; air resistance plays no role in the new equilibrium position because the ball is not moving at equilibrium. The new equilibrium position is <em>x</em><sub>0</sub> = <em>–mg</em>/<em>k</em> = –0.033 m, so this is the position about which the oscillation is centered, as you can see in <a href="ch15.xhtml#ch15fig5">Figure 15-5</a>.</p>&#13;
<div class="imagel" id="ch15fig5"><img src="Images/258fig01.jpg" alt="Image" width="527" height="394"/></div>&#13;
<p class="figcap"><em>Figure 15-5: Oscillation of a Ping-Pong ball on the end of a Slinky</em></p>&#13;
<p class="indent">Having explored one data representation for a solution to Newton’s second law, namely a list of states, let’s take a look at another representation, that of position and velocity functions.</p>&#13;
<h4 class="h4" id="ch15lev10">Method 2: Producing Position and Velocity Functions</h4>&#13;
<p class="noindent">We can use the function <span class="literal">positionFtxv</span> to produce a position function for the Ping-Pong ball on the Slinky.</p>&#13;
<pre>pingpongPosition :: Time -&gt; Velocity&#13;
pingpongPosition = positionFtxv 0.001 0.0027 (0,0.1,0) dampedHOForces</pre>&#13;
<p class="indent">All of the information necessary to describe the situation is included in the one line that makes up the body of this function: the 0.0027-kg mass; the initial state consisting of time 0 s, position 0.1 m, and velocity 0 m/s; and the list <span class="literal">dampedHOForces</span> of three forces defined earlier.</p>&#13;
<p class="indent">The following code will produce a graph very much like that shown in <a href="ch15.xhtml#ch15fig5">Figure 15-5</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_259"/>dampedHOGraph2 :: IO ()&#13;
dampedHOGraph2&#13;
    = plotFunc [Title "Ping Pong Ball on a Slinky"&#13;
               ,XLabel "Time (s)"&#13;
               ,YLabel "Position (m)"&#13;
               ,Key Nothing&#13;
               ] [0,0.01..3] pingpongPosition</pre>&#13;
<p class="indent">We can use the function <span class="literal">velocityFtxv</span> to produce a velocity function for the Ping-Pong ball on the Slinky.</p>&#13;
<pre>pingpongVelocity :: Time -&gt; Velocity&#13;
pingpongVelocity = velocityFtxv 0.001 0.0027 (0,0.1,0) dampedHOForces</pre>&#13;
<p class="indent">As before, we can graph our function:</p>&#13;
<pre>dampedHOGraph3 :: IO ()&#13;
dampedHOGraph3&#13;
    = plotFunc [Title "Ping Pong Ball on a Slinky"&#13;
               ,XLabel "Time (s)"&#13;
               ,YLabel "Velocity (m/s)"&#13;
               ,PNG "dho2.png"&#13;
               ,Key Nothing&#13;
               ] [0,0.01..3] pingpongVelocity</pre>&#13;
<p class="indent">This code produces <a href="ch15.xhtml#ch15fig6">Figure 15-6</a>, which shows a graph of velocity versus time for the Ping-Pong ball. Velocity starts at zero since we release the ball from rest and then becomes negative as the ball moves downward. The velocity oscillates and experiences the same sort of damping that the position does.</p>&#13;
<div class="imagel" id="ch15fig6"><img src="Images/259fig01.jpg" alt="Image" width="527" height="393"/></div>&#13;
<p class="figcap"><em>Figure 15-6: Velocity of a Ping-Pong ball on the end of a Slinky</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_260"/>The Euler method is a general-purpose state-based way of solving a system of first-order differential equations (which is more or less equivalent to a single higher-order differential equation). However, the Euler method does not usually get very much bang out of the computational buck, in that the time step often must be very small to get acceptable results. There are many other methods to choose from, and a small modification to the Euler method, which we explore in the next section, typically allows one to get acceptable results with a larger step size, decreasing the computational cost of a calculation.</p>&#13;
<h3 class="h3" id="ch15lev11">Euler-Cromer Method</h3>&#13;
<p class="noindent">We can make a slight modification to the Euler method that improves the results of Newton’s second law calculations in many cases. Instead of the functional diagram that describes the Euler method in <a href="ch15.xhtml#ch15fig3">Figure 15-3</a>, let’s look at a functional diagram for the Euler-Cromer method, shown in <a href="ch15.xhtml#ch15fig7">Figure 15-7</a>.</p>&#13;
<div class="imagel" id="ch15fig7"><img src="Images/260fig01.jpg" alt="Image" width="628" height="541"/></div>&#13;
<p class="figcap"><em>Figure 15-7: The Euler-Cromer method for Newton’s second law in one dimension</em></p>&#13;
<p class="indent">The difference lies in the value of velocity used to update position. The Euler method used the old velocity to update the position. The Euler-Cromer method calculates a new velocity using the same velocity-update equation as in the Euler method but then uses this new velocity to update the position.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_261"/>Instead of the state-update Equations 15.6 and 15.7 for the Euler method, the Euler-Cromer method uses the following slightly modified equations:</p>&#13;
<div class="imagec"><img src="Images/261equ01.jpg" alt="Image" width="498" height="76"/></div>&#13;
<p class="indent">The velocity-update equation for Euler-Cromer is the same as the velocity-update equation for Euler. The difference is the replacement of <em>v</em>(<em>t</em>) with <em>v</em>(<em>t</em> + Δ<em>t</em>) in the position-update equation. While the order in which the Euler update equations 15.6 and 15.7 are evaluated is irrelevant, the Euler-Cromer velocity-update equation must be evaluated before the position-update equation because the updated velocity is used in the latter equation.</p>&#13;
<p class="indent">However, one of the benefits of a functional language with names that refer to objects that don’t change is that we don’t need to worry about telling the computer to update the velocity first. We can put the equations in whatever order we want, and the compiler will figure out an appropriate order of evaluation. The following function plays the role for Euler-Cromer that <span class="literal">euler1D</span> played for Euler:</p>&#13;
<pre>eulerCromer1D :: R                     -- time step dt&#13;
              -&gt; (State1D -&gt; (R,R,R))  -- differential equation&#13;
              -&gt; State1D -&gt; State1D    -- state-update function&#13;
eulerCromer1D dt deriv (t0,x0,v0)&#13;
    = let (_, _, dvdt) = deriv (t0,x0,v0)&#13;
          t1 = t0 + dt&#13;
          x1 = x0 + v1 * dt&#13;
          v1 = v0 + dvdt * dt&#13;
      in (t1,x1,v1)</pre>&#13;
<p class="indent">In this code, I use the local variable <span class="literal">v1</span>, which is the updated value of velocity, before I give the equation for how to find it. The compiler will know to order the evaluations so that <span class="literal">v1</span> is computed before it is used.</p>&#13;
<p class="indent">The function <span class="literal">updateTXVEC</span> is the Euler-Cromer version of the state-update function corresponding to Euler’s <span class="literal">updateTXV</span>.</p>&#13;
<pre>updateTXVEC :: R                   -- time interval dt&#13;
            -&gt; Mass&#13;
            -&gt; [State1D -&gt; Force]  -- list of force funcs&#13;
            -&gt; State1D -&gt; State1D  -- state-update function&#13;
updateTXVEC dt m fs = eulerCromer1D dt (newtonSecond1D m fs)</pre>&#13;
<p class="indent">The Euler-Cromer method comes closer to conserving energy in cases where it should be conserved, and it’s generally better for situations with oscillatory behavior. Both the Euler and Euler-Cromer methods converge to the correct result as the time step is decreased, but Euler-Cromer can often achieve acceptable results with a larger time step than Euler would require.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_262"/><a href="ch15.xhtml#ch15fig7">Figure 15-7</a> shows an alternative uncoiling of <a href="ch15.xhtml#ch15fig1">Figure 15-1</a> corresponding to the Euler-Cromer method. Comparing <a href="ch15.xhtml#ch15fig3">Figure 15-3</a> (which describes the Euler method) and <a href="ch15.xhtml#ch15fig7">Figure 15-7</a>, we see that the only difference is that the updated velocity is used to update the position.</p>&#13;
<p class="indent">The functions <span class="literal">statesTXV</span>, <span class="literal">velocityFtxv</span>, and <span class="literal">positionFtxv</span> use the function <span class="literal">updateTXV</span>, which means they use the Euler method. In Exercise 15.13, you are asked to write analogous functions for the Euler-Cromer method.</p>&#13;
<p class="indent">Note that the Euler-Cromer method is specific to second-order differential equations because there must be a state variable playing the role of velocity that can be updated first and then used to update the main unknown function (position for Newton’s second law).</p>&#13;
<p class="indent">As we expand our study of mechanics in the next several chapters, we’ll continue to solve differential equations. The final section of this chapter prepares the way for future chapters by treating the process of differential equation solving in greater generality.</p>&#13;
<h3 class="h3" id="ch15lev12">Solving Differential Equations</h3>&#13;
<p class="noindent">A typical mechanics problem starts as a physics problem as we use physical information to construct a differential equation, then becomes a mathematics problem as we solve the differential equation, and finally becomes a physics problem again as we interpret the results. This section focuses on the mathematical activity, beginning with a differential equation and ending with knowledge of how the state variables change with the independent variable (which in mechanics represents time).</p>&#13;
<p class="indent">In <a href="ch15.xhtml#ch15fig2">Figure 15-2</a>, we showed how information was transformed in the process of solving a mechanics problem. Starting with mass and force information, Newton’s second law produces a differential equation. The Euler method then transforms this differential equation into a state-update function. By iterating the state-update function, given some initial state, we arrive at a list of states. This list of states can be regarded as a solution to the problem, or we can proceed to an additional step and produce position and velocity functions for the object.</p>&#13;
<p class="indent">In the next several chapters, in which we use vectors to describe quantities like velocity and treat multiple interacting particles, we will continue to view the process of solving a mechanics problem as one of information transformation, like that in <a href="ch15.xhtml#ch15fig2">Figure 15-2</a>. For this purpose we need to generalize <a href="ch15.xhtml#ch15fig2">Figure 15-2</a> in two ways. The function <span class="literal">euler1D</span> will work with any differential equation that uses the state space <span class="literal">State1D</span>. In the previous chapter, we used <span class="literal">Velocity</span> and <span class="literal">(Time,Velocity)</span> as state spaces, and in the coming chapters, we will continue to expand the state spaces we use to include vectors and multiple particles. We want to be able to use the Euler method with the new state spaces we design, and it would be really great if we could write the Euler method once and for all in a way that would work with any state space. Later in this section, we’ll identify the commonality among these state spaces that allows us to do this. So, the first generalization is from the state space <span class="literal">State1D</span> to a broader class of state spaces.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_263"/><a href="ch15.xhtml#ch15fig2">Figure 15-2</a> uses the Euler method to transform a differential equation into a state-update function. Now that we have introduced the Euler-Cromer method, we have two numerical methods, each of which can perform this transformation. The second generalization is from the Euler method to other numerical methods. We want our information transformation process to allow whatever numerical method we might wish to use.</p>&#13;
<p class="indent">Let’s turn to the question of how to generalize the state space.</p>&#13;
<h4 class="h4" id="ch15lev13">Generalizing the State Space</h4>&#13;
<p class="noindent">To generalize the state space from <span class="literal">State1D</span> to other possibilities, we will use a type variable <span class="literal">s</span> for the data type of the state. If we can write functions with types expressed in terms of <span class="literal">s</span>, rather than <span class="literal">State1D</span>, we can use these functions with any state space. When we generalize <span class="literal">Velocity</span>, <span class="literal">(Time,Velocity)</span>, and <span class="literal">State1D</span>, type <span class="literal">s</span> will contain whatever state variables are necessary for the physical system in question.</p>&#13;
<p class="indent">Where <a href="ch15.xhtml#ch15fig2">Figure 15-2</a> has a differential equation based on state space <span class="literal">State1D</span>, we want differential equations based on state space <span class="literal">s</span>. Where <a href="ch15.xhtml#ch15fig2">Figure 15-2</a> has a state-update function based on state space <span class="literal">State1D</span>, we want a state-update function based on state space <span class="literal">s</span>. Where <span class="literal">euler1D</span> is a numerical method that transforms a differential equation based on <span class="literal">State1D</span> into a state-update function based on <span class="literal">State1D</span>, we want to be able to talk and write about numerical methods that transform a differential equation based on state space <span class="literal">s</span> into a state-update function based on <span class="literal">s</span>.</p>&#13;
<p class="indent">To be precise, we’re going to give formal definitions for the differential equation, state-update function, and numerical method for state space <span class="literal">s</span> by writing type synonyms. We’ll start with the state-update function because that is the simplest of the three.</p>&#13;
<p class="indent">Since a state-update function, such as <span class="literal">updateTXV dt m fs</span>, produces a new state with the same type as the input state, a state-update function for state space <span class="literal">s</span> is a function <span class="literal">s -&gt; s</span>. This definition can be encoded as a type synonym.</p>&#13;
<pre>type UpdateFunction s = s -&gt; s</pre>&#13;
<p class="indent">The type <span class="literal">UpdateFunction s</span> is the type for state-update functions that work with state space <span class="literal">s</span>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab1">Table 15-1</a> shows the state-update functions we have used so far in the last chapter and the current chapter.</p>&#13;
<p class="tabcap" id="ch15tab1"><strong>Table 15-1:</strong> State-Update Functions That Work with Different State Spaces</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>State-update function</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">updateVelocity dt m fs</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">UpdateFunction Velocity</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">updateTV dt m fs</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">UpdateFunction (Time,Velocity)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">updateTXV dt m fs</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">UpdateFunction State1D</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_264"/>Note that for each function we must supply a time step, a mass, and a list of force functions before the resulting expression has the type shown on the right side of the table.</p>&#13;
<p class="indent">A differential equation takes a state as input and produces derivatives of each state variable as output. With the state space <span class="literal">State1D</span>, the input consists of time, position, and velocity, while the output is numbers, velocity, and acceleration.</p>&#13;
<p class="indent">Time is not the same thing as a dimensionless number, position is not the same thing as velocity, and velocity is not the same as acceleration. However, these are all real numbers for <span class="literal">State1D</span>, so the state space can also be written as <span class="literal">(R,R,R)</span>. In the function <span class="literal">euler1D</span> from earlier, I used the type <span class="literal">State1D -&gt; (R,R,R)</span> for the differential equation and the type <span class="literal">State1D -&gt;</span> <span class="literal">State1D</span> for the state-update function. To the compiler, these are the same type. I wrote them differently because numbers, velocity, and acceleration aren’t the quantities that belong in a <span class="literal">State1D</span>.</p>&#13;
<p class="indent">To treat the difference between state variables and their time derivatives, we will use a type variable <span class="literal">ds</span> for a quantity that represents the time derivatives of the state variables. Just as the type variable <span class="literal">s</span> is for state, the type variable <span class="literal">ds</span> is for the time derivative of state.</p>&#13;
<p class="indent">A differential equation, as represented in Haskell, is a function that returns a set of derivatives of state variables when given a set of state variables. If <span class="literal">s</span> is the data type for state, and <span class="literal">ds</span> is the data type for time derivative of state, then the definition of a differential equation can be given as a type synonym.</p>&#13;
<pre>type DifferentialEquation s ds = s -&gt; ds</pre>&#13;
<p class="indent">The type <span class="literal">DifferentialEquation s ds</span> is the type for differential equations that work with state space <span class="literal">s</span> and time derivative of state space <span class="literal">ds</span>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab2">Table 15-2</a> shows the differential equations we have used so far in the last chapter and the current chapter.</p>&#13;
<p class="tabcap" id="ch15tab2"><strong>Table 15-2:</strong> Differential Equations That Work with Different State Spaces</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Differential equation</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">newtonSecondV m fs</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">DifferentialEquation Velocity R</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">newtonSecondTV m fs</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">DifferentialEquation (Time,Velocity) (R,R)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">newtonSecond1D m fs</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">DifferentialEquation State1D (R,R,R)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Note that for each function we must supply a mass and a list of force functions before the resulting expression has the type shown on the right side of the table.</p>&#13;
<p class="indent">A numerical method transforms a differential equation into a state-update function. The definition of numerical method for state space <span class="literal">s</span> and derivative space <span class="literal">ds</span> can be given as a type synonym.</p>&#13;
<pre>type NumericalMethod s ds = DifferentialEquation s ds -&gt; UpdateFunction s</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_265"/>The type <span class="literal">NumericalMethod s ds</span> is the type for numerical methods that work with the state space <span class="literal">s</span> and time derivative space <span class="literal">ds</span>.</p>&#13;
<p class="indent">While the differential equation itself is a mathematically exact expression, applying a numerical method to solve it necessarily involves approximation. We have seen two numerical methods so far: the Euler method and the Euler-Cromer method. However, there are many numerical methods to choose from in solving a differential equation.</p>&#13;
<p class="indent">Since there are many numerical methods, which all lead to different approximations, it makes little sense to bake one particular numerical method into the foundational ideas and code that constitute both the structure of how we think about solving mechanics problems and the computational tools to solve them. We should be able to choose a numerical method freely, independently of the differential equation we are solving. We want to separate the numerical method from the differential equation.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab3">Table 15-3</a> shows the numerical methods we have used so far in this chapter. In the previous chapter, we never wrote an explicit numerical method, instead placing the Euler method code inside the state-update function.</p>&#13;
<p class="tabcap" id="ch15tab3"><strong>Table 15-3:</strong> Numerical Methods That Work with the State1D State Space</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Numerical method</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">euler1D dt</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">NumericalMethod State1D (R,R,R)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">eulerCromer1D dt</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">NumericalMethod State1D (R,R,R)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Note that for each function we must supply a time step before the resulting expression has the type shown on the right side of the table.</p>&#13;
<p class="indent">Given a differential equation and a numerical method, we can solve the differential equation by applying the numerical method, which results in a state-update function, and then iterate the state-update function to produce a list of states. The following function takes a numerical method, a differential equation, and an initial state as input and produces a list of states as output. We can think of this function as a general-purpose differential equation solver.</p>&#13;
<pre>solver :: NumericalMethod s ds -&gt; DifferentialEquation s ds -&gt; s -&gt; [s]&#13;
solver method = iterate . method</pre>&#13;
<p class="indent">We said earlier that solving a differential equation is the mathematical part of solving a mechanics problem, in which we transform a differential equation through a state-update function and ultimately to a list of states. The function <span class="literal">solver</span> carries out the entire mathematical process of solving a differential equation. In other words, it handles the mathematical part of solving a mechanics problem.</p>&#13;
<p class="indent">We’ve given definitions for differential equation, state-update function, and numerical method, each of which works with a state space <span class="literal">s</span> and time derivative space <span class="literal">ds</span>. We now turn to writing a general-purpose function <span class="literal">euler</span> that can act as a numerical method for an almost-arbitrary state space <span class="literal">s</span>.</p>&#13;
<h4 class="h4" id="ch15lev14"><span epub:type="pagebreak" id="page_266"/>Type Classes for State Spaces</h4>&#13;
<p class="noindent">The state space type <span class="literal">s</span> and time derivative space <span class="literal">ds</span> cannot be just any data types. To carry out the Euler method and other numerical methods, we need to be able to add elements of the time derivative space <span class="literal">ds</span>, and we want to be able to scale elements by a time step. A space that supports addition of states and scalar multiplication of states by real numbers is called a <em>real vector space</em>.</p>&#13;
<p class="indent">To express the constraint that our time derivative space be a real vector space, we define a type class.</p>&#13;
<pre>class RealVectorSpace ds where&#13;
      (+++) :: ds -&gt; ds -&gt; ds&#13;
      scale :: R -&gt; ds -&gt; ds</pre>&#13;
<p class="indent">This code defines a new type class <span class="literal">RealVectorSpace</span> that owns two functions: <span class="literal">(+++)</span> for addition and <span class="literal">scale</span> for scalar multiplication. You can see from the type signatures that the addition function takes two state derivatives as input and produces one as output, while the scalar multiplication function takes a real number and a state derivative as input and produces a state derivative as output.</p>&#13;
<p class="indent">For each derivative space we wish to use, we’ll write an instance declaration saying exactly how addition and scalar multiplication are to be defined for that data type. For the type <span class="literal">(R,R,R)</span>, which is the derivative space associated with state space <span class="literal">State1D</span>, here is the instance declaration:</p>&#13;
<pre>instance RealVectorSpace (R,R,R) where&#13;
    (dtdt0, dxdt0, dvdt0) +++ (dtdt1, dxdt1, dvdt1)&#13;
        = (dtdt0 + dtdt1, dxdt0 + dxdt1, dvdt0 + dvdt1)&#13;
    scale w (dtdt0, dxdt0, dvdt0) = (w * dtdt0, w * dxdt0, w * dvdt0)</pre>&#13;
<p class="indent">We use the local variable <span class="literal">dxdt0</span> to remind us that this name stands for a quantity that represents the derivative of a position with respect to time. The instance declaration defines adding two triples to mean adding each corresponding pair; it defines scaling a triple by a real number to mean scaling each item in the triple by the real number.</p>&#13;
<p class="indent">We will also use a type class to claim a relationship that must hold between a state space <span class="literal">s</span> and its derivative space <span class="literal">ds</span>. The relationship describes how a state variable in <span class="literal">s</span> can be advanced in time using knowledge of the state variable’s time derivative in <span class="literal">ds</span>. We name the type class <span class="literal">Diff</span> to remind us of the differentiation (the taking of a time derivative) that relates a state space <span class="literal">s</span> to its derivative space <span class="literal">ds</span>.</p>&#13;
<pre>class RealVectorSpace ds =&gt; Diff s ds where&#13;
    shift :: R -&gt; ds -&gt; s -&gt; s</pre>&#13;
<p class="indent">This type class definition contains a type class constraint saying that <span class="literal">ds</span> must be a <span class="literal">RealVectorSpace</span>. The type class <span class="literal">Diff</span> owns the function <span class="literal">shift</span>. For each pair of types we wish to use as state space and derivative space, we will provide an instance declaration that defines what the function <span class="literal">shift</span> does <span epub:type="pagebreak" id="page_267"/>with values of the two spaces. The function <span class="literal">shift</span> describes how a state can be advanced in time using knowledge of the derivative state. The function <span class="literal">shift</span> takes a time step, a state derivative, and a state as input and gives a new state as output.</p>&#13;
<p class="indent">A type class used to relate two types rather than to claim membership of a single type is called a <em>multi-parameter type class</em>. The second line of the introductory code for the module we are writing in this chapter turns on a <span class="literal">LANGUAGE</span> feature called <span class="literal">MultiParamTypeClasses</span> to allow the use of multiparameter type classes. Their use is disabled by default.</p>&#13;
<p class="indent">The following instance declaration claims a differentiation relationship between the types <span class="literal">State1D</span> and <span class="literal">(R,R,R)</span> by defining the function <span class="literal">shift</span> for them:</p>&#13;
<pre>instance Diff State1D (R,R,R) where&#13;
    shift dt (dtdt,dxdt,dvdt) (t,x,v)&#13;
        = (t + dtdt * dt, x + dxdt * dt, v + dvdt * dt)</pre>&#13;
<p class="indent">The function <span class="literal">shift</span> says that to update time, we should multiply a time step <span class="literal">dt</span> by the rate <span class="literal">dtdt</span> at which time changes (which is 1). It says that to update position, we should multiply a time step <span class="literal">dt</span> by the rate <span class="literal">dxdt</span> at which position changes and act similarly to update velocity. Time, position, and velocity come from the state, while the rates of change come from the state derivative.</p>&#13;
<p class="indent">We see that <span class="literal">shift</span> looks a lot like the Euler method. In fact, it is more basic than that. The <span class="literal">shift</span> function will be used by the Euler method but also by other numerical methods.</p>&#13;
<p class="indent">Here is the generic version of the Euler method, which is suitable for any differential equation based on any state space.</p>&#13;
<pre>euler :: Diff s ds =&gt; R -&gt; (s -&gt; ds) -&gt; s -&gt; s&#13;
euler dt deriv st0 = shift dt (deriv st0) st0</pre>&#13;
<p class="indent">As long as data types <span class="literal">s</span> and <span class="literal">ds</span> are appropriately related by the <span class="literal">Diff</span> type class, which is to say that <span class="literal">s</span> is a state space and <span class="literal">ds</span> is a derivative space that goes along with <span class="literal">s</span>, the function <span class="literal">euler</span> will carry out the Euler method with state variables from <span class="literal">s</span>, using the differential equation passed in as <span class="literal">deriv</span>. The Euler method is carried out by a single use of the <span class="literal">shift</span> function, where the derivatives are evaluated at the current state.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab4">Table 15-4</a> compares the types of <span class="literal">euler1D</span> and <span class="literal">euler</span>.</p>&#13;
<p class="tabcap" id="ch15tab4"><strong>Table 15-4:</strong> Comparison of the Function euler1D with the More General Function euler</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Function</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"> </p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">euler1D</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><span class="literal">R -&gt; NumericalMethod State1D (R,R,R)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">euler</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">::</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">Diff s ds =&gt; R -&gt; NumericalMethod s ds</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_268"/>The function <span class="literal">euler</span> can be used anywhere that <span class="literal">euler1D</span> can be used, and in other places as well. Because it is written with a type variable, we’ll be able to use <span class="literal">euler</span> for the state spaces we make in future chapters.</p>&#13;
<p class="indent">Can we do the same thing with the Euler-Cromer method? That is, can we write, once and for all, a numerical method that works with any state space and any differential equation? Sadly, the answer is no. The Euler method is a general-purpose technique for solving any system of first-order differential equations. The Euler-Cromer method is a specialized method for second-order differential equations, or for systems of first-order differential equations where we can identify a quantity to play the role of velocity. We’ll need to write a new Euler-Cromer function for each state space we work with.</p>&#13;
<p class="indent">Next we’ll introduce one more general-purpose numerical method that could be used instead of Euler or Euler-Cromer.</p>&#13;
<h4 class="h4" id="ch15lev15">One More Numerical Method</h4>&#13;
<p class="noindent">In this section, we’ll introduce one more general-purpose numerical method, called the fourth-order Runge-Kutta method. Numerical methods are sometimes classified by an order. The order gives an expectation of how the error (the difference between the numerical solution and the exact solution) scales with the step size. When we shrink the step size by a factor of 10, the error for a first-order solver shrinks by about 10, while the error for a second-order solver shrinks by about 10<sup>2</sup>, or 100. The Euler and Euler-Cromer methods are first-order methods and have the advantage of simplicity; it is straightforward to see why they work. The fourth-order Runge-Kutta method is substantially more complex. We won’t get into why it works well or why it is a fourth-order method. However, it is a popular method for solving differential equations, and it allows us to see a second general-purpose method for solving a differential equation. Fourth-order Runge-Kutta is a general method that will work with any differential equation and state space.</p>&#13;
<p class="indent">Here is the code for the fourth-order Runge-Kutta method:</p>&#13;
<pre>rungeKutta4 :: Diff s ds =&gt; R -&gt; (s -&gt; ds) -&gt; s -&gt; s&#13;
rungeKutta4 dt deriv st0&#13;
    = let m0 = deriv                 st0&#13;
          m1 = deriv (shift (dt/2) m0 st0)&#13;
          m2 = deriv (shift (dt/2) m1 st0)&#13;
          m3 = deriv (shift  dt    m2 st0)&#13;
      in shift (dt/6) (m0 +++ m1 +++ m1 +++ m2 +++ m2 +++ m3) st0</pre>&#13;
<p class="indent">You can see that this method is more complex, but it has the same type as <span class="literal">euler</span>, and it plays the same role: transforming a differential equation into a state-update function.</p>&#13;
<p class="indent">Now that we have three numerical methods to use, let’s compare them on a differential equation to which we know the solution.</p>&#13;
<h4 class="h4" id="ch15lev16"><span epub:type="pagebreak" id="page_269"/>Comparison of Numerical Methods</h4>&#13;
<p class="noindent">Let’s do a comparison of the three numerical methods we’ve introduced. The differential equations</p>&#13;
<div class="imagec"><img src="Images/269equ01.jpg" alt="Image" width="121" height="145"/></div>&#13;
<p class="noindent">can be written in Haskell as follows:</p>&#13;
<pre>exponential :: DifferentialEquation (R,R,R) (R,R,R)&#13;
exponential (_,x0,v0) = (1,v0,x0)</pre>&#13;
<p class="indent">These differential equations are exactly solvable and have a solution of</p>&#13;
<div class="equationc"><em>x</em>(<em>t</em>) = <em>Ae<sup>t</sup></em><br/><em>v</em>(<em>t</em>) = <em>Ae<sup>t</sup></em></div>&#13;
<p class="noindent">or</p>&#13;
<div class="equationc"><em>x</em>(<em>t</em>) = <em>Ae<sup>”t</sup></em><br/><em>v</em>(<em>t</em>) = –<em>Ae<sup>–t</sup></em></div>&#13;
<p class="noindent">for some constant <em>A</em>. If we focus on the initial state in which <em>x</em>(0) = 1 and <em>v</em>(0) = 1, the solution is</p>&#13;
<div class="equationc"><em>x</em>(<em>t</em>) = <em>e<sup>t</sup></em><br/><em>v</em>(<em>t</em>) = <em>e<sup>t</sup></em></div>&#13;
<p class="noindent">Let’s compare the exact solution at <em>t</em> = 8 to the approximations given by the three numerical methods we’ve presented using different step sizes.</p>&#13;
<p class="indent">The <span class="literal">solver</span> function takes a numerical method, a differential equation, and an initial state to produce a list of states.</p>&#13;
<pre>*Mechanics1D&gt; <span class="codestrong1">solver (euler 0.01) exponential (0,1,1) !! 800</span>&#13;
(7.999999999999874,2864.8311229272326,2864.8311229272326)&#13;
*Mechanics1D&gt; <span class="codestrong1">solver (eulerCromer1D 0.1) exponential (0,1,1) !! 80</span>&#13;
(7.999999999999988,3043.379244966009,2895.0121485099035)&#13;
*Mechanics1D&gt; <span class="codestrong1">solver (rungeKutta4 1) exponential (0,1,1) !! 8</span>&#13;
(8.0,2894.789038540849,2894.789038540849)</pre>&#13;
<p class="indent">In the first use of <span class="literal">solver</span>, we’re using a step size of 0.01, so item number 800 in the list corresponds to <em>t</em> = 8. The other two uses of <span class="literal">solver</span> use different step sizes and consequently different item numbers for <em>t</em> = 8.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab5">Table 15-5</a> compares the three numerical methods we’ve discussed. You can see where these example calculations fit into the table.</p>&#13;
<p class="tabcap" id="ch15tab5"><span epub:type="pagebreak" id="page_270"/><strong>Table 15-5:</strong> Comparison of the Euler, Euler-Cromer, and Fourth-Order Runge-Kutta Methods with the Exact Solution of a Differential Equation</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"> </p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Δ<em>t</em> = 1</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Δ<em>t</em> = 0.1</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Δ<em>t</em> = 0.01</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Δ<em>t</em> = 0.001</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Exact</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">2981</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">2981</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">2981</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">2981</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">RK4</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">2895</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">2981</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">2981</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">2981</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Euler-Cromer</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">2584</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">3043</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">2988</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">2982</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Euler</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">256</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">2048</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">2865</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">2969</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The exact result does not depend on any step size; it is just <em>e</em><sup>8</sup>. All three numerical methods get closer to the exact result as the step size decreases. The Euler method is within 4 percent of the exact value at a step size of Δ<em>t</em> = 0.01 and within 1 percent at a step size of Δ<em>t</em> = 0.001. Euler-Cromer at Δ<em>t</em> = 0.1 is better than Euler at Δ<em>t</em> = 0.01, and Euler-Cromer at Δ<em>t</em> = 0.01 is better than Euler at Δ<em>t</em> = 0.001. Thus, we can use roughly 10 times the step size with Euler-Cromer compared to Euler and get comparable results for this differential equation. Similarly, we can use roughly 10 times the step size with fourth-order Runge-Kutta compared to Euler-Cromer and get comparable results.</p>&#13;
<h3 class="h3" id="ch15lev17">Summary</h3>&#13;
<p class="noindent">This chapter completed the treatment of one-dimensional mechanics begun in the previous chapter. We saw how to handle forces that depend on position. With a force that depends on position, Newton’s second law is a second-order differential equation that we transform into coupled first-order differential equations for the state variables position and velocity. We can view the solution of a mechanics problem as the transformation of information about the physical situation through a sequence of five representations: mass and force functions, differential equation, state-update function, list of states, and position-velocity functions.</p>&#13;
<p class="indent">A Ping-Pong ball oscillating on the end of a Slinky in the presence of air resistance was the central example of the chapter. We introduced the Euler-Cromer method, an improvement on the Euler method for second-order differential equations. We also introduced the fourth-order Runge-Kutta method, which, along with the Euler method, is a general-purpose numerical method for solving any differential equation with any set of state variables. In the next chapter, we’ll start three-dimensional mechanics by treating position, velocity, and acceleration as vectors.</p>&#13;
<h3 class="h3" id="ch15lev18">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 15.1.</strong> Let’s warm up with a basic projectile motion problem where we know what the answer should look like. Suppose someone throws a ball from the ground straight up into the air with an initial velocity of 10 m/s. <span epub:type="pagebreak" id="page_271"/>Ignoring air resistance, use the function <span class="literal">positionFtxv</span> to find the height of the ball as a function of time. Make a plot of height as a function of time.</p>&#13;
<p class="noindentts"><strong>Exercise 15.2.</strong> Doing the Euler method by hand on <a href="ch15.xhtml#ch15lev7">page 254</a>, we arrived at a table of values for position and velocity. Show how to calculate these values using Haskell functions. The values may not match to four decimal places because I rounded intermediate results in doing the Euler method by hand, but the first two digits after the decimal point should match in every case.</p>&#13;
<p class="noindentts"><strong>Exercise 15.3.</strong> (Euler method by hand.) Consider the differential equations</p>&#13;
<div class="imagec"><img src="Images/271equ01.jpg" alt="Image" width="260" height="96"/></div>&#13;
<p class="noindentts">along with the initial conditions</p>&#13;
<div class="imagec"><img src="Images/271equ02a.jpg" alt="Image" width="320" height="20"/></div>&#13;
<p class="indent">Use the Euler method with a step size of Δ<em>t</em> = 0.1 to approximate the value of <em>x</em>(0.3). Keep at least four figures after the decimal point in your calculations. Show your calculations in a small table. (The table will have three columns, one each for time, position, and velocity.)</p>&#13;
<p class="noindentts"><strong>Exercise 15.4.</strong> Write a Haskell function</p>&#13;
<pre>update2 :: (R,R,R)  -- starting state&#13;
        -&gt; (R,R,R)  -- ending state&#13;
update2 = undefined</pre>&#13;
<p class="noindentts">that takes a tuple (<em>t</em><sub>0</sub>, <em>x</em><sub>0</sub>, <em>v</em><sub>0</sub>) and returns a tuple (<em>t</em><sub>1</sub>, <em>x</em><sub>1</sub>, <em>v</em><sub>1</sub>) for a single step of the Euler method for the differential equations</p>&#13;
<div class="imagec"><img src="Images/271equ02.jpg" alt="Image" width="260" height="96"/></div>&#13;
<p class="noindentts">with a step size of Δ<em>t</em> = 0.1 and the same initial conditions as in the previous exercise. Show how to use the function <span class="literal">update2</span> to calculate the value <em>x</em>(0.3) that you calculated by hand in the previous exercise.</p>&#13;
<p class="noindentts"><strong>Exercise 15.5.</strong> Consider a 3-kg mass connected to a wall by a linear spring with spring constant 100,000 N/m. Ignoring gravity and friction, if the spring is extended by 0.01 m and released, what does the subsequent motion look like? Investigate this motion over several cycles of oscillation. Compare your results to the exact solution. Find a time step that is small enough so that the Euler solution and the exact solution overlap precisely on a plot. Find another time step that is big enough so that you can see the difference between the Euler solution and the exact solution on a plot.</p>&#13;
<p class="indent">Make a nice plot (with title, axis labels, and so on) with these three solutions on a single graph (bad Euler, good Euler, and exact). Label the Euler results with the time step you used, and label the exact result “Exact.”</p>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_272"/><strong>Exercise 15.6.</strong> Let’s investigate dropping things from large heights. In particular, let’s look at a Ping-Pong ball and a bowling ball. In each case, take <em>C</em> = 1/2. You will need to find out good approximations for things like the size and mass of these balls. Let’s drop them from heights of 100 m and 500 m. Make graphs of velocity as a function of time and velocity as a function of vertical position. What fraction of terminal velocity is achieved in each case? Assemble your results in some meaningful and understandable way.</p>&#13;
<p class="noindentts"><strong>Exercise 15.7.</strong> Return to the harmonic oscillator of Exercise 15.5. Compare the Euler and Euler-Cromer solutions to the exact solution for a time step of 0.001 s (you will recall that this is not a very good time step for the Euler method). Plot the displacement of the mass as a function of time for the first 0.1 s of motion. Plot Euler, Euler-Cromer, and exact solutions on one set of axes. Also give the value of the position of the mass (to four significant figures) at <em>t</em> = 0.1 s for each of the three solutions.</p>&#13;
<p class="noindentts"><strong>Exercise 15.8.</strong> Consider an object with mass <em>m</em> attached to a spring with spring constant <em>k</em>. The other end of the spring is attached to a vertical wall. The object slides horizontally across the floor. There is a coefficient of kinetic friction <em>μ<sub>k</sub></em> = 0.3 between the object and the floor. The weight of the object is <em>mg</em>, so the force of kinetic friction on the object is μ<sub>k</sub> <em>mg</em>, directed opposite the velocity of the object.</p>&#13;
<p class="indent">Let <em>m</em> = 3 kg and <em>k</em> = 12 N/m.</p>&#13;
<p class="alphats">(a) Write a function with type <span class="literal">State1D -&gt; Force</span> that gives the horizontal force of kinetic friction. You may want to use the <span class="literal">signum</span> function.</p>&#13;
<p class="alphats">(b) Use the function <span class="literal">positionFtxv</span> to find the position of the object as a function of time.</p>&#13;
<p class="alphats">(c) Make a plot of position as a function of time.</p>&#13;
<p class="noindentts"><strong>Exercise 15.9.</strong> In most situations in mechanics, the mass of the object that we care about does not change. There is no need to include a quantity that doesn’t change in the state. However, since some forces, such as gravity, depend on mass, there is some motivation to include mass in the state simply for convenience. Several of the functions we developed in this chapter accept a list of force functions <span class="literal">[State1D -&gt; Force]</span> as input. If we wanted to include Earth’s gravity as such a state-dependent force, we would need to write something like the following:</p>&#13;
<pre>earthGravity :: Mass -&gt; State1D -&gt; Force&#13;
earthGravity m _ = let g = 9.80665&#13;
                   in -m * g</pre>&#13;
<p class="indent">Suppose, on the other hand, we include the object’s mass in its state by using the following 4-tuple as the data type for state.</p>&#13;
<pre>type MState = (Time,Mass,Position,Velocity)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_273"/>Then we could write an Earth gravity function as</p>&#13;
<pre>earthGravity2 :: MState -&gt; Force&#13;
earthGravity2 (_,m,_,_) = let g = 9.80665&#13;
                          in -m * g</pre>&#13;
<p class="indent">Notice that since mass is included in the state, we no longer need <span class="literal">Mass</span> as an extra parameter in the function type.</p>&#13;
<p class="indent">Write definitions for the following functions, using <span class="literal">MState</span> in place of <span class="literal">State1D</span>:</p>&#13;
<pre>positionFtxv2 :: R                  -- time step&#13;
              -&gt; MState             -- initial state&#13;
              -&gt; [MState -&gt; Force]  -- list of force funcs&#13;
              -&gt; Time -&gt; Position   -- position function&#13;
positionFtxv2 = undefined&#13;
&#13;
statesTXV2 :: R                 -- time step&#13;
          -&gt; MState             -- initial state&#13;
          -&gt; [MState -&gt; Force]  -- list of force funcs&#13;
          -&gt; [MState]           -- infinite list of states&#13;
statesTXV2 = undefined&#13;
&#13;
updateTXV2 :: R                  -- dt for stepping&#13;
           -&gt; [MState -&gt; Force]  -- list of force funcs&#13;
           -&gt; MState             -- current state&#13;
           -&gt; MState             -- new state&#13;
updateTXV2 = undefined</pre>&#13;
<p class="noindentts"><strong>Exercise 15.10.</strong> The Lennard-Jones potential</p>&#13;
<div class="imagec"><img src="Images/273equ01.jpg" alt="Image" width="267" height="50"/></div>&#13;
<p class="noindentts">is sometimes used to model the interaction between atoms. The expression V<sub><em>LJ</em></sub> (<em>r</em>) gives the potential energy for a system of two atoms when the atoms are a distance <em>r</em> apart from each other. As <em>r</em> → 0, the potential energy becomes infinite, expressing the difficulty of having the two atoms very close together. The lowest value of potential energy occurs at an inter-atomic separation of <em>r</em> = <em>r<sub>e</sub></em>, meaning that the parameter <em>r<sub>e</sub></em> is the equilibrium separation of the atoms. The parameter <em>D<sub>e</sub></em> represents the dissociation energy for the two-atom molecule, or the amount of energy that must be provided to the molecule to pull the atoms (arbitrarily far) apart.</p>&#13;
<p class="indent">The Lennard-Jones force</p>&#13;
<div class="imagec"><img src="Images/273equ02.jpg" alt="Image" width="410" height="63"/></div>&#13;
<p class="noindentts">gives the force on one of the atoms produced by the other, with positive meaning repulsive and negative meaning attractive. We can think of the <span epub:type="pagebreak" id="page_274"/>Lennard-Jones force as coming from a nonlinear spring that connects the two atoms. When the atomic separation is greater than <em>r<sub>e</sub></em>, the spring provides an attractive force that attempts to restore equilibrium. When the atomic separation is less than <em>r<sub>e</sub></em>, the spring provides a repulsive force that attempts to restore equilibrium. The spring is nonlinear in that the restoring force is not proportional to the deviation of the atomic separation from equilibrium.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15fig8">Figure 15-8</a> shows the Lennard-Jones force as a function of inter-atomic distance <em>r</em>, along with the linear spring force that most closely approximates it.</p>&#13;
<div class="imagel" id="ch15fig8"><img src="Images/274fig01.jpg" alt="Image" width="403" height="377"/></div>&#13;
<p class="figcap"><em>Figure 15-8: The Lennard-Jones force (curved line) and the linear force (straight) that most closely approximates it</em></p>&#13;
<p class="indent">The effective spring constant for the Lennard-Jones force is the negative slope of the force as a function of inter-atomic distance.</p>&#13;
<div class="imagec"><img src="Images/274equ01.jpg" alt="Image" width="245" height="55"/></div>&#13;
<p class="indent">Suppose we have a mass <em>m</em> attached by a Lennard-Jones spring to a wall. We’ll ignore gravity and friction in this problem so that the Lennard-Jones force is the only force that acts on the mass. If an oscillation about the equilibrium position is small in amplitude, the angular frequency of the oscillation will be close to</p>&#13;
<div class="imagec"><img src="Images/274equ02.jpg" alt="Image" width="201" height="52"/></div>&#13;
<p class="noindent">and the period will be close to</p>&#13;
<div class="imagec"><img src="Images/274equ03.jpg" alt="Image" width="193" height="50"/></div>&#13;
<p class="indent">Choose any parameters for <em>r<sub>e</sub></em>, <em>D<sub>e</sub></em>, and <em>m</em>.</p>&#13;
<p class="alphats"><span epub:type="pagebreak" id="page_275"/>(a) Make a graph of position versus time when the initial position is <em>r</em> = 1.01<em>r<sub>e</sub></em> and the initial velocity is zero. The graph should be oscillatory. Confirm that the period is close to the value given earlier.</p>&#13;
<p class="alphats">(b) Make a graph of position versus time when the initial position is <em>r</em> = 5<em>r<sub>e</sub></em> and the initial velocity is zero. What is the period now?</p>&#13;
<p class="indent">This is an example of an anharmonic oscillator, where the period depends on the amplitude of oscillation. It is only the special case of the harmonic oscillator in which period is independent of amplitude.</p>&#13;
<p class="noindentts"><strong>Exercise 15.11.</strong> Applying the Euler method by hand on <a href="ch15.xhtml#ch15lev8">page 254</a>, we arrived at a table of values for position and velocity. Produce a similar table of values using the Euler-Cromer method by hand.</p>&#13;
<p class="noindentts"><strong>Exercise 15.12.</strong> Write a function <span class="literal">statesTXVEC</span> that is similar to <span class="literal">statesTXV</span> but uses the Euler-Cromer method instead of the Euler method. Use this function to check the table of values you calculated by hand in the previous exercise.</p>&#13;
<p class="noindentts"><strong>Exercise 15.13.</strong> Write versions of <span class="literal">statesTXV</span>, <span class="literal">velocityFtxv</span>, and <span class="literal">positionFtxv</span> that use the Euler-Cromer method rather than the Euler method.</p>&#13;
<p class="noindentts"><strong>Exercise 15.14.</strong> Show how to use Haskell functions to calculate the entries of the comparison table for numerical methods.</p>&#13;
<p class="noindentts"><strong>Exercise 15.15.</strong> With the code</p>&#13;
<pre>instance RealVectorSpace (R,R) where&#13;
    (dtdt0, dvdt0) +++ (dtdt1, dvdt1) = (dtdt0 + dtdt1, dvdt0 + dvdt1)&#13;
    scale w (dtdt0, dvdt0) = (w * dtdt0, w * dvdt0)&#13;
&#13;
instance Diff (Time,Velocity) (R,R) where&#13;
    shift dt (dtdt,dvdt) (t,v)&#13;
        = (t + dtdt * dt, v + dvdt * dt)</pre>&#13;
<p class="noindentts">we have made the data type <span class="literal">(R,R)</span> an instance of type class <span class="literal">RealVectorSpace</span> and written a <span class="literal">Diff</span> instance for the pair of types <span class="literal">(Time,Velocity)</span> and <span class="literal">(R,R)</span>. Now we can use <span class="literal">(Time,Velocity)</span> as a state space and <span class="literal">(R,R)</span> as its derivative space for the Euler or fourth-order Runge-Kutta methods. Write a function</p>&#13;
<pre>updateTV' :: R                           -- dt for stepping&#13;
          -&gt; Mass&#13;
          -&gt; [(Time,Velocity) -&gt; Force]  -- list of force funcs&#13;
          -&gt; (Time,Velocity)             -- current state&#13;
          -&gt; (Time,Velocity)             -- new state&#13;
updateTV' = undefined</pre>&#13;
<p class="noindentts">that does the same thing as <span class="literal">updateTV</span> from <a href="ch14.xhtml">Chapter 14</a> but uses the function <span class="literal">euler</span> from this chapter.</p>&#13;
<p class="noindentts"><strong>Exercise 15.16.</strong> Newton’s second law generally produces a second-order differential equation (recall <a href="ch14.xhtml#ch14tab1">Table 14-1</a>). Our <span class="literal">DifferentialEquation s ds</span> data <span epub:type="pagebreak" id="page_276"/>type is for functions that return the derivatives of state variables when given the state variables themselves. A function with type <span class="literal">DifferentialEquation s ds</span> expresses a set of coupled first-order differential equations.</p>&#13;
<p class="indent">In this exercise, we’ll rewrite a second-order differential equation as two coupled first-order differential equations. A second-order (ordinary) differential equation has one independent variable and one dependent variable (in other words, one unknown function). A set of two coupled first-order differential equations has one independent variable and two dependent variables (two unknown functions of the independent variable).</p>&#13;
<p class="indent">Here is the recipe for producing a set of two coupled first-order differential equations from a second-order differential equation:</p>&#13;
<ol>&#13;
<li class="noindent">The independent variable of the coupled set is the same as the independent variable of the second-order equation.</li>&#13;
<li class="noindent">For the first unknown function of the coupled set, choose the unknown function of the second-order equation.</li>&#13;
<li class="noindent">For the second unknown function of the coupled set, choose the derivative of the first unknown function with respect to the independent variable and give this function a new name.</li>&#13;
<li class="noindent">The first differential equation in the coupled set expresses that the derivative of the first unknown function is equal to the second unknown function.</li>&#13;
<li class="noindent">To form the second differential equation in the set, start with the original second-order differential equation, replace the first derivative of the unknown function with the new second unknown function, replace the second derivative of the unknown function with the derivative of the new second unknown function, and solve for the derivative of the new second unknown function.</li>&#13;
</ol>&#13;
<p class="indent">Express the differential equation</p>&#13;
<div class="imagec"><img src="Images/276equ01.jpg" alt="Image" width="328" height="55"/></div>&#13;
<p class="noindent">as a set of two coupled first-order differential equations.</p>&#13;
<p class="noindentts"><strong>Exercise 15.17.</strong> The Van der Pol oscillator is a generalization of the harmonic oscillator that is often used to explore chaos. It is described by the following differential equation:</p>&#13;
<div class="imagec"><img src="Images/276equ02.jpg" alt="Image" width="326" height="49"/></div>&#13;
<p class="indent">We can view this equation as coming from Newton’s second law with two forces present: a spring-like linear restoring force and a damping force. We will abandon SI units for this exercise, setting both mass and spring constant to unity. The spring force is then given by</p>&#13;
<div class="equationc"><em>F</em><sub>spring</sub>(<em>t, x, v</em>) = –<em>x</em></div>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_277"/>and the damping force is given by</p>&#13;
<div class="equationc"><em>F</em><sub>damping</sub>(<em>t, x, v</em>) = <em>μ</em>(1 – <em>x</em><sup>2</sup>)<em>v</em></div>&#13;
<p class="noindentts">where <em>μ</em> is a parameter that controls how nonlinear the damping force is. If <em>μ</em> = 0, the Van der Pol oscillator reduces to the harmonic oscillator.</p>&#13;
<p class="indent">When studying chaos, people often like to make phase plane plots, which are graphs of velocity as a function of position. (They can also be graphs of momentum as a function of position, but we will use velocity.) Fill in the undefined parts of the following code to make phase plane plots for <em>μ</em> = 0, <em>μ</em> = 2, <em>μ</em> = 4, and <em>μ</em> = 6, all on the same graph.</p>&#13;
<pre>forces :: R -&gt; [State1D -&gt; R]&#13;
forces mu = [\(_t,x,_v) -&gt; undefined x&#13;
            ,\(_t,x, v) -&gt; undefined mu x v]&#13;
&#13;
vdp :: R -&gt; [(R,R)]&#13;
vdp mu = map (\(_,x,v) -&gt; (x,v)) $ take 10000 $&#13;
         solver (rungeKutta4 0.01) (newtonSecond1D 1 $ forces mu) (0,2,0)&#13;
&#13;
vdpPhasePlanePlot :: IO ()&#13;
vdpPhasePlanePlot = plotPaths [Title "Van der Pol oscillator"&#13;
                             ,XLabel "x"&#13;
                             ,YLabel "v"&#13;
                             ,PNG "VanderPol.png"&#13;
                             ,Key Nothing] (undefined :: [[(R,R)]])</pre>&#13;
<p class="indent">The result should look something like <a href="ch15.xhtml#ch15fig9">Figure 15-9</a>.</p>&#13;
<div class="imagel" id="ch15fig9"><img src="Images/277fig01.jpg" alt="Image" width="528" height="391"/></div>&#13;
<p class="figcap"><em>Figure 15-9: Phase plane plots for the Van der Pol oscillator</em><span epub:type="pagebreak" id="page_278"/></p>&#13;
</div></body></html>