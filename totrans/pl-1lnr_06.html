<html><head></head><body><section class="chapter" title="Chapter&#xA0;7.&#xA0;Selectively Printing and Deleting Lines" epub:type="chapter" id="selectively_printing_and_deleting_lines"><div class="titlepage"><div><div><h2 class="title">Chapter 7. Selectively Printing and Deleting Lines</h2></div></div></div><p><a id="idx00175" class="indexterm"/>In this chapter, we’ll examine various one-liners that print and delete certain lines. These one-liners will, for example, print repeated lines, print the shortest line in a file, and print lines that match certain patterns.</p><p>But every one-liner that prints certain lines can also be viewed as one that deletes the lines that aren’t printed. For example, a one-liner that prints all unique lines deletes all repeated lines. I’ll discuss only the one-liners that print something, rather than delete something, because one is always the inverse of the other.</p><div class="sect1" title="7.1 Print the first line of a file (emulate head -1)"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_1_print_the_first_line_of_a_file_e">7.1 Print the first line of a file (emulate head -1)</h2></div></div></div><a id="I_programlisting7_id311954"/><pre class="programlisting">perl -ne 'print; exit' <span class="emphasis"><em>file</em></span></pre><p><a id="idx00130" class="indexterm"/><a id="idx00133" class="indexterm"/><a id="idx00219" class="indexterm"/><a id="idx00241" class="indexterm"/><a id="idx00254" class="indexterm"/><a id="idx00312" class="indexterm"/><a id="idx00315" class="indexterm"/><a id="idx00357" class="indexterm"/><a id="idx00501" class="indexterm"/>This one-liner is quite simple. Perl reads the first line into the <code class="literal">$_</code> variable, thanks to the <code class="literal">-n</code> option, and then calls <code class="literal">print</code> to print the contents of the <code class="literal">$_</code> variable. Then it just exits. That’s it. The first line is printed and that’s what you want.</p><p>You might also say that this one-liner deletes all lines except the first one. But don’t worry. This particular one-liner won’t delete the contents of the file unless you also specify the <code class="literal">-i</code> command-line argument, like this:</p><a id="I_programlisting7_id312060"/><pre class="programlisting">perl -i -ne 'print; exit' <span class="emphasis"><em>file</em></span></pre><p>As I explained in <a class="xref" href="ch01.html" title="Chapter 1. Introduction to Perl One-Liners">Chapter 1</a> and in one-liner 6.1 on page 59, the <code class="literal">-i</code> argument edits the file in-place. In this case, all the lines in the file would be deleted except for the first. When using <code class="literal">-i</code>, always specify a backup extension to it, like this:</p><a id="I_programlisting7_id312084"/><pre class="programlisting">perl -i.bak -ne 'print; exit' <span class="emphasis"><em>file</em></span></pre><p>This will create a backup file <span class="emphasis"><em>file.bak</em></span> before the contents are overwritten.</p><p>You can add the <code class="literal">-i</code> command-line argument to any of the one-liners to change the file content. If you don’t use the <code class="literal">-i</code> argument, the one-liners simply print the new content of the file to screen rather than modifying the file.</p></div><div class="sect1" title="7.2 Print the first 10 lines of a file (emulate head -10)"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_2_print_the_first_10_lines_of_a_fi">7.2 Print the first 10 lines of a file (emulate head -10)</h2></div></div></div><a id="I_programlisting7_id312122"/><pre class="programlisting">perl -ne 'print if $. &lt;= 10' <span class="emphasis"><em>file</em></span></pre><p>This one-liner uses the <code class="literal">$.</code> special variable, which stands for “the current line number.” Each time Perl reads in a line, it increments <code class="literal">$.</code> by 1, so clearly this one-liner simply prints the first 10 lines.</p><p>This one-liner can also be written without the <code class="literal">if</code> statement:</p><a id="I_programlisting7_id312148"/><pre class="programlisting">perl -ne '$. &lt;= 10 &amp;&amp; print' <span class="emphasis"><em>file</em></span></pre><p>Here, <code class="literal">print</code> is called only if the Boolean expression <code class="literal">$. &lt;= 10</code> is true, and this expression is true only if the current line number is less than or equal to 10.</p><p><a id="idx00043" class="indexterm"/><a id="idx00204" class="indexterm"/><a id="idx00247" class="indexterm"/><a id="idx00253" class="indexterm"/><a id="idx00448" class="indexterm"/><a id="idx00452" class="indexterm"/><a id="idx00523" class="indexterm"/>Another, though somewhat trickier, way to do this is with the range operator (<code class="literal">..</code>) in the scalar context:</p><a id="I_programlisting7_id312222"/><pre class="programlisting">perl -ne 'print if 1..10' <span class="emphasis"><em>file</em></span></pre><p>The range operator in the scalar context returns a Boolean value. The operator is <span class="emphasis"><em>bistable</em></span>, like a flip-flop, and emulates the <span class="emphasis"><em>line-range</em></span> (comma) operator in sed, awk, and various text editors. Its value is false as long as its left operand is false. Once the left operand is true, the range operator is true until the right operand is true, after which the range operator becomes false again. As a result, this bistable operator becomes true at the first line, stays true until the tenth line, and then becomes and remains false.</p><p>A fourth option is to follow the first example in this chapter:</p><a id="I_programlisting7_id312247"/><pre class="programlisting">perl -ne 'print; exit if $. == 10' <span class="emphasis"><em>file</em></span></pre><p>Here, I put a condition on <code class="literal">exit</code>, which is that the current line (which I just printed) is number 10.</p></div><div class="sect1" title="7.3 Print the last line of a file (emulate tail -1)"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_3_print_the_last_line_of_a_file_em">7.3 Print the last line of a file (emulate tail -1)</h2></div></div></div><a id="I_programlisting7_id312271"/><pre class="programlisting">perl -ne '$last = $_; END { print $last }' <span class="emphasis"><em>file</em></span></pre><p>Printing the last line of a file is trickier than printing the first line, because you never know which is the last line. As a result, you always have to keep the line you just read in memory. In this one-liner, you always save the current line held in <code class="literal">$_</code> into the <code class="literal">$last</code> variable. When the Perl program ends, it executes the code in the <code class="literal">END</code> block, which prints the last line read.</p><p>Here’s another way to do this:</p><a id="I_programlisting7_id312298"/><pre class="programlisting">perl -ne 'print if eof' <span class="emphasis"><em>file</em></span></pre><p>This one-liner uses the <code class="literal">eof</code> (or end-of-file) function, which returns 1 if the next read returns the end-of-file. Because the next read after the last line in the file will return the end-of-file, this one-liner does the job. The next read means that Perl will attempt to read a character from the current file, and if reading the character fails, it will signal that the end-of-file has been reached, meaning the whole file has been read. If the read succeeds, Perl secretly puts the character back in the input stream as if nothing had happened.</p></div><div class="sect1" title="7.4 Print the last 10 lines of a file (emulate tail -10)"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_4_print_the_last_10_lines_of_a_fil">7.4 Print the last 10 lines of a file (emulate tail -10)</h2></div></div></div><a id="I_programlisting7_id312327"/><pre class="programlisting">perl -ne 'push @a, $_; @a = @a[@a-10..$#a] if @a&gt;10; END { print @a }' <span class="emphasis"><em>file</em></span></pre><p><a id="idx00361" class="indexterm"/><a id="idx00465" class="indexterm"/><a id="idx00505" class="indexterm"/><a id="idx00533" class="indexterm"/><a id="idx00547" class="indexterm"/>This one-liner is a bit tricky. Here, you push each line to the <code class="literal">@a</code> array and then replace <code class="literal">@a</code> with a slice of itself if the list contains more than 10 elements. The phrase <code class="literal">@a = @a[@a-10..$#a]</code> means “replace <code class="literal">@a</code> with the last 10 elements of <code class="literal">@a</code>.” The bit <code class="literal">@a-10</code> causes <code class="literal">@a</code> to be evaluated in the scalar context, and thus it returns the number of elements in the array minus 10. The expression <code class="literal">$#a</code> is the last index in the <code class="literal">@a</code> array. And finally, <code class="literal">@a[@a-10..$#a]</code> slices (returns) the last 10 elements of the array, with which it overwrites <code class="literal">@a</code> itself so it always contains only the last 10 elements.</p><p>For example, suppose <code class="literal">@a</code> contains <code class="literal">(line1, line2, line3, line4)</code>, and you want to print the last four lines of the file. When you read the fifth line, the array becomes <code class="literal">(line1, line2, line3, line4, line5)</code>, and the value of <code class="literal">@a-4</code> is 1 because <code class="literal">@a</code> in the scalar context is 5. But the value of <code class="literal">$#a</code> is 4 because it’s the last index in the array. Therefore when you take the slice <code class="literal">@a[@a-4..$#a]</code>, it becomes <code class="literal">@a[1..4]</code>, which drops the front element from the array, and the <code class="literal">@a</code> array becomes <code class="literal">(line2, line3, line4, line5)</code>.</p><p>A simpler way to write this is with <code class="literal">shift</code>:</p><a id="I_programlisting7_id312478"/><pre class="programlisting">perl -ne 'push @a, $_; shift @a if @a&gt;10; END { print @a }' <span class="emphasis"><em>file</em></span></pre><p>This one-liner doesn’t need to slice <code class="literal">@a</code> because you can guarantee that if <code class="literal">@a &gt; 10</code>, then <code class="literal">@a == 11</code>. <code class="literal">shift</code> is an operator that removes the first element of an array. So in this loop, you can simply shift off the first stored line when you have more than 10 lines.</p></div><div class="sect1" title="7.5 Print only lines that match a regular expression"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_5_print_only_lines_that_match_a_re">7.5 Print only lines that match a regular expression</h2></div></div></div><a id="I_programlisting7_id312516"/><pre class="programlisting">perl -ne '/<span class="emphasis"><em>regex</em></span>/ &amp;&amp; print'</pre><p>This one-liner tests to see whether the current line matches <code class="literal">/regex/</code>. If so, the <code class="literal">/regex/</code> match succeeds and <code class="literal">print</code> is called.</p><p>Instead of using <code class="literal">&amp;&amp;</code>, you can also use <code class="literal">if</code> to reverse the <code class="literal">/regex/</code> and <code class="literal">print</code> statements:</p><a id="I_programlisting7_id312557"/><pre class="programlisting">perl -ne 'print if /<span class="emphasis"><em>regex</em></span>/'</pre></div><div class="sect1" title="7.6 Print only lines that do not match a regular expression"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_6_print_only_lines_that_do_not_mat">7.6 Print only lines that do not match a regular expression</h2></div></div></div><a id="I_programlisting7_id312576"/><pre class="programlisting">perl -ne '!/<span class="emphasis"><em>regex</em></span>/ &amp;&amp; print'</pre><p><a id="idx00038" class="indexterm"/><a id="idx00169" class="indexterm"/><a id="idx00443" class="indexterm"/>This one-liner inverts the previous one-liner. Here, I test to see that the line doesn’t match <code class="literal">/regex/</code> by inverting the match via the <code class="literal">!</code> operator. If the line doesn’t match, I call <code class="literal">print</code> to print the line.</p><p>You can also write this the other way around:</p><a id="I_programlisting7_id312623"/><pre class="programlisting">perl -ne 'print if !/<span class="emphasis"><em>regex</em></span>/'</pre><p>And you can also use <code class="literal">unless</code> instead of <code class="literal">if !</code>:</p><a id="I_programlisting7_id312641"/><pre class="programlisting">perl -ne 'print unless /<span class="emphasis"><em>regex</em></span>/'</pre><p>Another way to write this is to apply De Morgan’s law to <code class="literal">!/regex/ &amp;&amp; print</code>:</p><a id="I_programlisting7_id312656"/><pre class="programlisting">perl -ne '/<span class="emphasis"><em>regex</em></span>/ || print'</pre></div><div class="sect1" title="7.7 Print every line preceding a line that matches a regular expression"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_7_print_every_line_preceding_a_lin">7.7 Print every line preceding a line that matches a regular expression</h2></div></div></div><a id="I_programlisting7_id312675"/><pre class="programlisting">perl -ne '/<span class="emphasis"><em>regex</em></span>/ &amp;&amp; $last &amp;&amp; print $last; $last = $_'</pre><p>This one-liner prints a line when it is above a line that matches <code class="literal">/regex/</code>. Let’s walk through it, beginning at the last statement, <code class="literal">$last = $_</code>, which saves each line in the <code class="literal">$last</code> variable. Suppose the next line is read and it matches <code class="literal">/regex/</code>. Because the previous line is saved in <code class="literal">$last</code>, the one-liner simply prints it. The series of <code class="literal">&amp;&amp;</code> means first that the regular expression must match and second that <code class="literal">$last</code> must be a true value. (Blank lines are still printed because they contain the newline character.)</p><p>Say you have a file with four lines:</p><a id="I_programlisting7_id312719"/><pre class="programlisting">hello world
magic line
bye world
magic line</pre><p>and you want to print all lines above those that match <code class="literal">magic</code>. You can do this:</p><a id="I_programlisting7_id312730"/><pre class="programlisting">perl -ne '/magic/ &amp;&amp; $last &amp;&amp; print $last; $last = $_'</pre><p>and the one-liner will print:</p><a id="I_programlisting7_id312738"/><pre class="programlisting">hello world
bye world</pre></div><div class="sect1" title="7.8 Print every line following a line that matches a regular expression"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_8_print_every_line_following_a_lin">7.8 Print every line following a line that matches a regular expression</h2></div></div></div><a id="I_programlisting7_id312754"/><pre class="programlisting">perl -ne 'if ($p) { print; $p = 0 } $p++ if /<span class="emphasis"><em>regex</em></span>/'</pre><p>Here, I set the variable <code class="literal">$p</code> to 1 if the current line matches the regular expression. The fact that the variable <code class="literal">$p</code> is 1 indicates that the next line should be printed. Now, when the next line is read in and <code class="literal">$p</code> is set, that line is printed and <code class="literal">$p</code> is reset to 0. Quite simple.</p><p>Let’s say you have this four-line file:</p><a id="I_programlisting7_id312785"/><pre class="programlisting">science
physics
science
math</pre><p>and you want to print all lines below those that match <code class="literal">science</code>. Do this:</p><a id="I_programlisting7_id312797"/><pre class="programlisting">perl -ne 'if ($p) { print; $p = 0 } $p++ if /science/'</pre><p>The one-liner will print:</p><a id="I_programlisting7_id312805"/><pre class="programlisting">physics
math</pre><p>If you want to write this with <code class="literal">&amp;&amp;</code> and avoid using <code class="literal">if</code> and curly brackets, do this:</p><a id="I_programlisting7_id312820"/><pre class="programlisting">perl -ne '$p &amp;&amp; print &amp;&amp; ($p = 0); $p++ if /science/'</pre><p>You can also be very smart about this and simplify this one-liner to the following:</p><a id="I_programlisting7_id312827"/><pre class="programlisting">perl -ne '$p &amp;&amp; print; $p = /science/'</pre><p>If the current line matches <code class="literal">science</code>, then variable <code class="literal">$p</code> is set to a true value and the next line gets printed. If the current line doesn’t match <code class="literal">science</code>, then <code class="literal">$p</code> becomes undefined and the next line doesn’t get printed.</p></div><div class="sect1" title="7.9 Print lines that match regular expressions AAA and BBB in any order"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_9_print_lines_that_match_regular_e">7.9 Print lines that match regular expressions AAA and BBB in any order</h2></div></div></div><a id="I_programlisting7_id312860"/><pre class="programlisting">perl -ne '/<span class="emphasis"><em>AAA</em></span>/ &amp;&amp; /<span class="emphasis"><em>BBB</em></span>/ &amp;&amp; print'</pre><p>This one-liner tests to see whether a line matches two regular expressions. If a line matches <code class="literal">/AAA/</code> and <code class="literal">/BBB/</code>, it’s printed. Specifically, this one-liner prints the line <span class="emphasis"><em>foo AAA bar BBB baz</em></span> because it contains both <span class="emphasis"><em>AAA</em></span> and <span class="emphasis"><em>BBB</em></span>, but it won’t print the line <span class="emphasis"><em>foo AAA bar AAA</em></span> because it doesn’t contain <span class="emphasis"><em>BBB</em></span>.</p></div><div class="sect1" title="7.10 Print lines that don’t match regular expressions AAA and BBB"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_10_print_lines_that_dont_match_reg">7.10 Print lines that don’t match regular expressions AAA and BBB</h2></div></div></div><a id="I_programlisting7_id312913"/><pre class="programlisting">perl -ne '!/<span class="emphasis"><em>AAA</em></span>/ &amp;&amp; !/<span class="emphasis"><em>BBB</em></span>/ &amp;&amp; print'</pre><p>This one-liner is almost the same as the previous one. Here, I test to see if a line doesn’t match both regular expressions. If it doesn’t match <code class="literal">/AAA/</code> or <code class="literal">/BBB/</code>, it prints.</p></div><div class="sect1" title="7.11 Print lines that match regular expression AAA followed by BBB followed by CCC"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_11_print_lines_that_match_regular">7.11 Print lines that match regular expression AAA followed by BBB followed by CCC</h2></div></div></div><a id="I_programlisting7_id312947"/><pre class="programlisting">perl -ne '/<span class="emphasis"><em>AAA</em></span>.*<span class="emphasis"><em>BBB</em></span>.*<span class="emphasis"><em>CCC</em></span>/ &amp;&amp; print'</pre><p>Here, I simply chain the regular expressions <code class="literal">AAA</code>, <code class="literal">BBB</code>, and <code class="literal">CCC</code> with <code class="literal">.*</code>, which means “match anything or nothing at all.” If <code class="literal">AAA</code> is followed by <code class="literal">BBB</code>, which is followed by <code class="literal">CCC</code>, the line prints. For example, this one-liner matches and prints strings like <span class="emphasis"><em>123<span class="strong"><strong>AAA</strong></span>880<span class="strong"><strong>BBB</strong></span>222<span class="strong"><strong>CCC</strong></span>, x<span class="strong"><strong>AAA</strong></span>y<span class="strong"><strong>BBB</strong></span>z<span class="strong"><strong>CCC</strong></span></em></span>, and <span class="strong"><strong><span class="emphasis"><em>AAABBBCCC</em></span></strong></span>.</p></div><div class="sect1" title="7.12 Print lines that are at least 80 characters long"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_12_print_lines_that_are_at_least_8">7.12 Print lines that are at least 80 characters long</h2></div></div></div><a id="I_programlisting7_id313052"/><pre class="programlisting">perl -ne 'print if length &gt;= 80'</pre><p><a id="idx00340" class="indexterm"/><a id="idx00358" class="indexterm"/><a id="idx00363" class="indexterm"/><a id="idx00502" class="indexterm"/><a id="idx00508" class="indexterm"/>This one-liner prints all lines that are at least 80 characters long. In Perl, you can sometimes omit the parentheses <code class="literal">()</code> for function calls, so here I’ve omitted them for the <code class="literal">length</code> function call. In fact, the invocations <code class="literal">length</code>, <code class="literal">length()</code>, and <code class="literal">length($_)</code> are all the same as far as Perl is concerned.</p><p>If you don’t want to count line endings, you can turn on automatic handling of line endings with <code class="literal">-l</code>:</p><a id="I_programlisting7_id313139"/><pre class="programlisting">perl -lne 'print if length &gt;= 80'</pre><p>This switch ensures that a blank line has zero length, whereas it usually has length 1 or 2, depending on the file format. (UNIX newlines have length 1; Windows newlines have length 2.)</p></div><div class="sect1" title="7.13 Print lines that are fewer than 80 characters long"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_13_print_lines_that_are_fewer_than">7.13 Print lines that are fewer than 80 characters long</h2></div></div></div><a id="I_programlisting7_id313157"/><pre class="programlisting">perl -ne 'print if length() &lt; 80'</pre><p>This one-liner reverses the previous one. It checks to see whether the length of a line is less than 80 characters. Again, you use <code class="literal">-l</code> if you don’t want the line endings to be counted.</p></div><div class="sect1" title="7.14 Print only line 13"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_14_print_only_line_13">7.14 Print only line 13</h2></div></div></div><a id="I_programlisting7_id313178"/><pre class="programlisting">perl -ne '$. == 13 &amp;&amp; print &amp;&amp; exit'</pre><p>As I explained in one-liner 7.2 on page 70, the <code class="literal">$.</code> special variable stands for “the current line number.” Therefore, if <code class="literal">$.</code> has a value of 13, this one-liner prints the line and exits.</p></div><div class="sect1" title="7.15 Print all lines except line 27"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_15_print_all_lines_except_line_27">7.15 Print all lines except line 27</h2></div></div></div><a id="I_programlisting7_id313205"/><pre class="programlisting">perl -ne '$. != 27 &amp;&amp; print'</pre><p>As in the previous one-liner, this one checks to see whether the line number of the current line is 27. If a line is not 27, it prints; if it is, it doesn’t print.</p><p>You can accomplish the same thing by reversing <code class="literal">print</code> and <code class="literal">$. != 27</code> and using the <code class="literal">if</code> statement modifier—just like this:</p><a id="I_programlisting7_id313229"/><pre class="programlisting">perl -ne 'print if $. != 27'</pre><p>Or you can use <code class="literal">unless</code>:</p><a id="I_programlisting7_id313240"/><pre class="programlisting">perl -ne 'print unless $. == 27'</pre></div><div class="sect1" title="7.16 Print only lines 13, 19, and 67"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_16_print_only_lines_13_19_and_67">7.16 Print only lines 13, 19, and 67</h2></div></div></div><a id="I_programlisting7_id313254"/><pre class="programlisting">perl -ne 'print if $. == 13 || $. == 19 || $. == 67'</pre><p>This one-liner prints only lines 13, 19, and 67. It doesn’t print any other lines. Here’s how it works: It calls <code class="literal">print</code> if the current line number, stored in the <code class="literal">$.</code> variable, is 13, 19, or 67. You can use any line numbers to print specific lines. For example, to print the lines 13, 19, 88, 290, and 999, you do this:</p><a id="I_programlisting7_id313272"/><pre class="programlisting">perl -ne 'print if $. == 13 || $. == 19 || $. == 88 || $. == 290 || $. == 999'</pre><p>If you want to print more lines, you can put them in a separate array and then test whether <code class="literal">$.</code> is in this array:</p><a id="I_programlisting7_id313283"/><pre class="programlisting">perl -ne '
  @lines = (13, 19, 88, 290, 999, 1400, 2000);
  print if grep { $_ == $. } @lines
'</pre><p>This one-liner uses <code class="literal">grep</code> to test if the current line <code class="literal">$.</code> is in the <code class="literal">@lines</code> array. If the current line number is found in the <code class="literal">@lines</code> array, the <code class="literal">grep</code> function returns a list of one element that contains the current line number and this list evaluates to true. If the current line number is not found in the <code class="literal">@lines</code> array, the <code class="literal">grep</code> function returns an empty list that evaluates to false.</p></div><div class="sect1" title="7.17 Print all lines from 17 to 30"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_17_print_all_lines_from_17_to_30">7.17 Print all lines from 17 to 30</h2></div></div></div><a id="I_programlisting7_id313329"/><pre class="programlisting">perl -ne 'print if $. &gt;= 17 &amp;&amp; $. &lt;= 30'</pre><p>In this one-liner, the <code class="literal">$.</code> variable stands for the current line number. As a result, the one-liner checks to see whether the current line number is greater than or equal to 17 and less than or equal to 30.</p><p><a id="idx00044" class="indexterm"/><a id="idx00248" class="indexterm"/><a id="idx00341" class="indexterm"/><a id="idx00359" class="indexterm"/><a id="idx00362" class="indexterm"/><a id="idx00449" class="indexterm"/><a id="idx00453" class="indexterm"/><a id="idx00503" class="indexterm"/><a id="idx00506" class="indexterm"/><a id="idx00534" class="indexterm"/>You can do the same thing using the flip-flop operator, which is explained in one-liner 7.2 on page 70. The flip-flop operator operates on <code class="literal">$.</code> when used with integers:</p><a id="I_programlisting7_id313440"/><pre class="programlisting">perl -ne 'print if 17..30'</pre></div><div class="sect1" title="7.18 Print all lines between two regular expressions (including the lines that match)"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_18_print_all_lines_between_two_reg">7.18 Print all lines between two regular expressions (including the lines that match)</h2></div></div></div><a id="I_programlisting7_id313452"/><pre class="programlisting">perl -ne 'print if /<span class="emphasis"><em>regex1</em></span>/../<span class="emphasis"><em>regex2</em></span>/'</pre><p>This one-liner uses the flip-flop operator (explained in one-liner 7.2 on page 70). When used with integers, the operands are tested against the <code class="literal">$.</code> variable. When used with regular expressions, the operands are tested against the current line, stored in the <code class="literal">$_</code> variable. Initially the operator returns false. When a line matches <code class="literal">regex1</code>, the operator flips and starts returning true until another line matches <code class="literal">regex2</code>. At that point, the operator returns true for the last time and then flips to the false state. From now on the operator returns false. This one-liner, therefore, prints all lines between (and including) the lines that match <code class="literal">regex1</code> and <code class="literal">regex2</code>.</p></div><div class="sect1" title="7.19 Print the longest line"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_19_print_the_longest_line">7.19 Print the longest line</h2></div></div></div><a id="I_programlisting7_id313505"/><pre class="programlisting">perl -ne '
  $l = $_ if length($_) &gt; length($l);
  END { print $l }
'</pre><p>This one-liner keeps the longest line seen so far in the <code class="literal">$l</code> variable. If the length of the current line <code class="literal">$_</code> exceeds the length of the longest line, the value in <code class="literal">$l</code> is replaced with the value of the current line. Before exiting, the <code class="literal">END</code> block is executed, and it prints the longest line value that’s held in <code class="literal">$l</code>.</p><p>Remember to use <code class="literal">-l</code> if you want to prevent the newline characters from counting toward the line length.</p></div><div class="sect1" title="7.20 Print the shortest line"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_20_print_the_shortest_line">7.20 Print the shortest line</h2></div></div></div><a id="I_programlisting7_id313551"/><pre class="programlisting">perl -ne '
  $s = $_ if $. == 1;
  $s = $_ if length($_) &lt; length($s);
  END { print $s }
'</pre><p><a id="idx00165" class="indexterm"/><a id="idx00355" class="indexterm"/><a id="idx00499" class="indexterm"/>This one-liner is the opposite of the previous one. Because it’s finding the shortest line and <code class="literal">$s</code> is not defined for the first line, you have to set its value to the first line explicitly through <code class="literal">$s = $_ if $. == 1</code>. Then it simply does the opposite of the previous one-liner. That is, it checks to see whether the current line is the shortest line so far and, if so, assigns it to <code class="literal">$s</code>.</p></div><div class="sect1" title="7.21 Print all lines containing digits"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_21_print_all_lines_containing_digi">7.21 Print all lines containing digits</h2></div></div></div><a id="I_programlisting7_id313613"/><pre class="programlisting">perl -ne 'print if /\d/'</pre><p>This one-liner uses the regular expression <code class="literal">\d</code> (which stands for “a digit”) to see whether a line contains a digit. If so, the check succeeds, and the line is printed. For example, this line would be printed because it contains digits:</p><a id="I_programlisting7_id313626"/><pre class="programlisting">coding is as easy as 123</pre><p>However, this line wouldn’t be printed because it doesn’t contain digits:</p><a id="I_programlisting7_id313633"/><pre class="programlisting">coding is as easy as pie</pre></div><div class="sect1" title="7.22 Print all lines containing only digits"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_22_print_all_lines_containing_only">7.22 Print all lines containing only digits</h2></div></div></div><a id="I_programlisting7_id313648"/><pre class="programlisting">perl -ne 'print if /^\d+$/'</pre><p>In this one-liner, the regular expression <code class="literal">^\d+$</code> means “match a line if it contains only digits from the beginning until the end.” For example, this line would be printed because it contains only digits:</p><a id="I_programlisting7_id313660"/><pre class="programlisting">3883737189170238912377</pre><p><a id="idx00356" class="indexterm"/><a id="idx00500" class="indexterm"/>However, this line wouldn’t be printed because it also contains some characters:</p><a id="I_programlisting7_id313689"/><pre class="programlisting">8388338 foo bar random data 999</pre><p>You can also invert the <code class="literal">^\d$</code> regular expression and use <code class="literal">\D</code>:</p><a id="I_programlisting7_id313704"/><pre class="programlisting">perl -lne 'print unless /\D/'</pre><p>This one-liner is great for developing your logical reasoning because it uses logical negation twice. Here, the line prints only if it does <span class="emphasis"><em>not</em></span> contain a non-numeric character. In other words, it prints only if all the characters are numeric. (Notice that I used the <code class="literal">-l</code> command-line argument for this one-liner because of the newline character at the end of the line. If I didn’t use <code class="literal">-l</code>, the line would contain the newline character—a non-numeric character—and it wouldn’t be printed.)</p></div><div class="sect1" title="7.23 Print all lines containing only alphabetic characters"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_23_print_all_lines_containing_only">7.23 Print all lines containing only alphabetic characters</h2></div></div></div><a id="I_programlisting7_id313736"/><pre class="programlisting">perl -ne 'print if /^[[:alpha:]]+$/</pre><p>This one-liner checks to see whether a line contains only alphabetic characters. If so, it prints the line. The <code class="literal">[[:alpha:]]</code> stands for “any alphabetic character.” And <code class="literal">[[:alpha:]]+</code> stands for “all alphabetic characters.”</p></div><div class="sect1" title="7.24 Print every second line"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_24_print_every_second_line">7.24 Print every second line</h2></div></div></div><a id="I_programlisting7_id313762"/><pre class="programlisting">perl -ne 'print if $. % 2'</pre><p>This one-liner prints the first, third, fifth, and seventh lines (and so on). It does so because <code class="literal">$. % 2</code> is true when the current line number is odd and false when the current line number is even.</p></div><div class="sect1" title="7.25 Print every second line, beginning with the second line"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_25_print_every_second_line_beginni">7.25 Print every second line, beginning with the second line</h2></div></div></div><a id="I_programlisting7_id313787"/><pre class="programlisting">perl -ne 'print if $. % 2 == 0'</pre><p>This one-liner is like previous one, except it prints the second, fourth, sixth, and eighth lines (and so on) because <code class="literal">$. % 2 == 0</code> is true when the current line number is even.</p><p><a id="idx00364" class="indexterm"/><a id="idx00511" class="indexterm"/><a id="idx00538" class="indexterm"/><a id="idx00612" class="indexterm"/>Alternatively, you can simply invert the test from the previous example:</p><a id="I_programlisting7_id313838"/><pre class="programlisting">perl -ne 'print unless $. % 2'</pre></div><div class="sect1" title="7.26 Print all repeated lines only once"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_26_print_all_repeated_lines_only_o">7.26 Print all repeated lines only once</h2></div></div></div><a id="I_programlisting7_id313851"/><pre class="programlisting">perl -ne 'print if ++$a{$_} == 2'</pre><p>This one-liner tracks the lines it has seen so far and counts the number of times it has seen the lines previously. If it sees a line a second time, it prints the line because <code class="literal">++$a{$_} == 2</code> is true. If it sees a line more than two times, it does nothing because the count for this line is greater than 2.</p></div><div class="sect1" title="7.27 Print all unique lines"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="seven_27_print_all_unique_lines">7.27 Print all unique lines</h2></div></div></div><a id="I_programlisting7_id313875"/><pre class="programlisting">perl -ne 'print unless $a{$_}++'</pre><p>This one-liner prints a line only if the hash value <code class="literal">$a{$_}</code> for that line is false. Every time Perl reads in a line, it increments <code class="literal">$a{$_}</code>, which ensures that this one-liner prints only never-before-seen lines.</p></div></section></body></html>