- en: 'Chapter 60. Sockets: Server Design'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter discusses the fundamentals of designing iterative and concurrent
    servers and describes *inetd*, a special daemon designed to facilitate the creation
    of Internet servers.
  prefs: []
  type: TYPE_NORMAL
- en: Iterative and Concurrent Servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two common designs for network servers using sockets are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Iterative*: The server handles one client at a time, processing that client’s
    request(s) completely, before proceeding to the next client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Concurrent*: The server is designed to handle multiple clients simultaneously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already seen an example of an iterative server using FIFOs in [A Client-Server
    Application Using FIFOs](ch44.html#a_client-server_application_using_fifos "A
    Client-Server Application Using FIFOs") and an example of a concurrent server
    using System V message queues in Section 46.8.
  prefs: []
  type: TYPE_NORMAL
- en: Iterative servers are usually suitable only when client requests can be handled
    quickly, since each client must wait until all of the preceding clients have been
    serviced. A typical scenario for employing an iterative server is where the client
    and server exchange a single request and response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Concurrent servers are suitable when a significant amount of processing time
    is required to handle each request, or where the client and server engage in an
    extended conversation, passing messages back and forth. In this chapter, we mainly
    focus on the traditional (and simplest) method of designing a concurrent server:
    creating a new child process for each new client. Each server child performs all
    tasks necessary to service a single client and then terminates. Since each of
    these processes can operate independently, multiple clients can be handled simultaneously.
    The principal task of the main server process (the parent) is to create a new
    child process for each new client. (A variation on this approach is to create
    a new thread for each client.)'
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we look at examples of an iterative and a concurrent
    server using Internet domain sockets. These two servers implement the *echo* service
    (RFC 862), a rudimentary service that returns a copy of whatever the client sends
    it.
  prefs: []
  type: TYPE_NORMAL
- en: An Iterative UDP *echo* Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this and the next section, we present servers for the *echo* service. The
    *echo* service operates on both UDP and TCP port 7. (Since this is a reserved
    port, the *echo* server must be run with superuser privileges.)
  prefs: []
  type: TYPE_NORMAL
- en: The UDP *echo* server continuously reads datagrams, returning a copy of each
    datagram to the sender. Since the server needs to handle only a single message
    at a time, an iterative server design suffices. The header file for the server
    is shown in [Example 60-1](ch60.html#header_file_for_id_underscore_echo_under
    "Example 60-1. Header file for id_echo_sv.c and id_echo_cl.c").
  prefs: []
  type: TYPE_NORMAL
- en: Example 60-1. Header file for `id_echo_sv.c` and `id_echo_cl.c`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 60-2](ch60.html#an_iterative_server_that_implements_the "Example 60-2. An
    iterative server that implements the UDP echo service") shows the implementation
    of the server. Note the following points regarding the server implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: We use the *becomeDaemon()* function of [Creating a Daemon](ch37.html#creating_a_daemon
    "Creating a Daemon") to turn the server into a daemon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To shorten this program, we employ the Internet domain sockets library developed
    in [An Internet Domain Sockets Library](ch59.html#an_internet_domain_sockets_library
    "An Internet Domain Sockets Library").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the server can’t send a reply to the client, it logs a message using *syslog()*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a real-world application, we would probably apply some rate limit to the
    messages written with *syslog()*, both to prevent the possibility of an attacker
    filling the system log and because each call to *syslog()* is expensive, since
    (by default) *syslog()* in turn calls *fsync()*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 60-2. An iterative server that implements the UDP *echo* service
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To test the server, we use the client program shown in [Example 60-3](ch60.html#a_client_for_the_udp_echo_service
    "Example 60-3. A client for the UDP echo service"). This program also employs
    the Internet domain sockets library developed in [An Internet Domain Sockets Library](ch59.html#an_internet_domain_sockets_library
    "An Internet Domain Sockets Library"). As its first command-line argument, the
    client program expects the name of the host on which the server resides. The client
    executes a loop in which it sends each of its remaining command-line arguments
    to the server as separate datagrams, and reads and prints each response datagram
    sent back by the server.
  prefs: []
  type: TYPE_NORMAL
- en: Example 60-3. A client for the UDP *echo* service
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of what we see when we run the server and two instances
    of the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A Concurrent TCP *echo* Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The TCP *echo* service also operates on port 7\. The TCP *echo* server accepts
    a connection and then loops continuously, reading all transmitted data and sending
    it back to the client on the same socket. The server continues reading until it
    detects end-of-file, at which point it closes its socket (so that the client sees
    end-of-file if it is still reading from its socket).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the client may send an indefinite amount of data to the server (and thus
    servicing the client may take an indefinite amount of time), a concurrent server
    design is appropriate, so that multiple clients can be simultaneously served.
    The server implementation is shown in [Example 60-4](ch60.html#a_concurrent_server_that_implements_the
    "Example 60-4. A concurrent server that implements the TCP echo service"). (We
    show an implementation of a client for this service in Section 61.2.) Note the
    following points about the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: The server becomes a daemon by calling the *becomeDaemon()* function shown in
    Section 37.2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To shorten this program, we employ the Internet domain sockets library shown
    in [Example 59-9](ch59.html#an_internet_domain_sockets_librar "Example 59-9. An
    Internet domain sockets library") (page 1228).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the server creates a child process for each client connection, we must
    ensure that zombies are reaped. We do this within a `SIGCHLD` handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main body of the server consists of a `for` loop that accepts a client connection
    and then uses *fork()* to create a child process that invokes the *handleRequest()*
    function to handle that client. In the meantime, the parent continues around the
    `for` loop to accept the next client connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In a real-world application, we would probably include some code in our server
    to place an upper limit on the number of child processes that the server could
    create, in order to prevent an attacker from attempting a remote fork bomb by
    using the service to create so many processes on the system that it becomes unusable.
    We could impose this limit by adding extra code in the server to count the number
    of children currently executing (this count would be incremented after a successful
    *fork()* and decremented as each child was reaped in the `SIGCHLD` handler). If
    the limit on the number of children were reached, we could then temporarily stop
    accepting connections (or alternatively, accept connections and then immediately
    close them).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After each *fork()*, the file descriptors for the listening and connected sockets
    are duplicated in the child ([File Sharing Between Parent and Child](ch24.html#file_sharing_between_parent_and_child
    "File Sharing Between Parent and Child")). This means that both the parent and
    the child could communicate with the client using the connected socket. However,
    only the child needs to perform such communication, and so the parent closes the
    file descriptor for the connected socket immediately after the *fork()*. (If the
    parent did not do this, then the socket would never actually be closed; furthermore,
    the parent would eventually run out of file descriptors.) Since the child doesn’t
    accept new connections, it closes its duplicate of the file descriptor for the
    listening socket.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each child process terminates after handling a single client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example 60-4. A concurrent server that implements the TCP *echo* service
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Other Concurrent Server Designs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The traditional concurrent server model described in the previous section is
    adequate for many applications that need to simultaneously handle multiple clients
    via TCP connections. However, for very high-load servers (for example, web servers
    handling thousands of requests per minute), the cost of creating a new child (or
    even thread) for each client imposes a significant burden on the server (refer
    to [Speed of Process Creation](ch28.html#speed_of_process_creation "Speed of Process
    Creation")), and alternative designs need to be employed. We briefly consider
    some of these alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Preforked and prethreaded servers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Preforked and prethreaded servers are described in some detail in [Chapter 30](ch30.html
    "Chapter 30. Threads: Thread Synchronization") of [Stevens et al., 2004]. The
    key ideas are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of creating a new child process (or thread) for each client, the server
    precreates a fixed number of child processes (or threads) immediately on startup
    (i.e., before any client requests are even received). These children constitute
    a so-called *server pool*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each child in the server pool handles one client at a time, but instead of terminating
    after handling the client, the child fetches the next client to be serviced and
    services it, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Employing the above technique requires some careful management within the server
    application. The server pool should be large enough to ensure adequate response
    to client requests. This means that the server parent must monitor the number
    of unoccupied children, and, in times of peak load, increase the size of the pool
    so that there are always enough child processes available to immediately serve
    new clients. If the load decreases, then the size of the server pool should be
    reduced, since having excess processes on the system can degrade overall system
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the children in the server pool must follow some protocol to allow
    them to exclusively select individual client connections. On most UNIX implementations
    (including Linux), it is sufficient to have each child in the pool block in an
    *accept()* call on the listening descriptor. In other words, the server parent
    creates the listening socket before creating any children, and each of the children
    inherits a file descriptor for the socket during the *fork()*. When a new client
    connection arrives, only one of the children will complete the *accept()* call.
    However, because *accept()* is not an atomic system call on some older implementations,
    the call may need to be bracketed by some mutual-exclusion technique (e.g., a
    file lock) to ensure that only one child at a time performs the call ([Stevens
    et al., 2004]).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are alternatives to having all of the children in the server pool perform
    *accept()* calls. If the server pool consists of separate processes, the server
    parent can perform the *accept()* call, and then pass the file descriptor containing
    the new connection to one of the free processes in the pool, using a technique
    that we briefly describe in [Passing File Descriptors](ch61.html#passing_file_descriptors
    "Passing File Descriptors"). If the server pool consists of threads, the main
    thread can perform the *accept()* call, and then inform one of the free server
    threads that a new client is available on the connected descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: Handling multiple clients from a single process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some cases, we can design a single server process to handle multiple clients.
    To do this, we must employ one of the I/O models (I/O multiplexing, signal-driven
    I/O, or *epoll*) that allow a single process to simultaneously monitor multiple
    file descriptors for I/O events. These models are described in [Chapter 63](ch63.html
    "Chapter 63. Alternative I/O Models").
  prefs: []
  type: TYPE_NORMAL
- en: In a single-server design, the server process must take on some of the scheduling
    tasks that are normally handled by the kernel. In a solution that involves one
    server process per client, we can rely on the kernel to ensure that each server
    process (and thus client) gets a fair share of access to the resources of the
    server host. But when we use a single server process to handle multiple clients,
    the server must do some work to ensure that one or a few clients don’t monopolize
    access to the server while other clients are starved. We say a little more about
    this point in [Edge-Triggered Notification](ch63.html#edge-triggered_notification
    "Edge-Triggered Notification").
  prefs: []
  type: TYPE_NORMAL
- en: Using server farms
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Other approaches to handling high client loads involve the use of multiple server
    systems—a *server farm*.
  prefs: []
  type: TYPE_NORMAL
- en: One of the simplest approaches to building a server farm (employed by some web
    servers) is *DNS round-robin load sharing* (or *load distribution*), where the
    authoritative name server for a zone maps the same domain name to several IP addresses
    (i.e., several servers share the same domain name). Successive requests to the
    DNS server to resolve the domain name return these IP addresses in round-robin
    order. Further information about DNS round-robin load sharing can be found in
    [Albitz & Liu, 2006].
  prefs: []
  type: TYPE_NORMAL
- en: Round-robin DNS has the advantage of being inexpensive and easy to set up. However,
    it does have some shortcomings. A DNS server performing iterative resolution may
    cache its results (see [Domain Name System (DNS)](ch59.html#domain_name_system_open_parenthesis_dns
    "Domain Name System (DNS)")), with the result that future queries on the domain
    name return the same IP address, instead of the round-robin sequence generated
    by the authoritative DNS server. Also, round-robin DNS doesn’t have any built-in
    mechanisms for ensuring good load balancing (different clients may place different
    loads on a server) or ensuring high availability (what if one of the servers dies
    or the server application that it is running crashes?). Another issue that we
    may need to consider—one that is faced by many designs that employ multiple server
    machines—is ensuring *server affinity*; that is, ensuring that a sequence of requests
    from the same client are all directed to the same server, so that any state information
    maintained by the server about the client remains accurate.
  prefs: []
  type: TYPE_NORMAL
- en: A more flexible, but also more complex, solution is *server load balancing*.
    In this scenario, a single load-balancing server routes incoming client requests
    to one of the members of the server farm. (To ensure high availability, there
    may be a backup server that takes over if the primary load-balancing server crashes.)
    This eliminates the problems associated with remote DNS caching, since the server
    farm presents a single IP address (that of the load-balancing server) to the outside
    world. The load-balancing server incorporates algorithms to measure or estimate
    server load (perhaps based on metrics supplied by the members of the server farm)
    and intelligently distribute the load across the members of the server farm. The
    load-balancing server also automatically detects failures in members of the server
    farm (and the addition of new servers, if demand requires it). Finally, a load-balancing
    server may also provide support for server affinity. Further information about
    server load balancing can be found in [Kopparapu, 2002].
  prefs: []
  type: TYPE_NORMAL
- en: The *inetd* (Internet Superserver) Daemon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we look through the contents of `/etc/services`, we see literally hundreds
    of different services listed. This implies that a system could theoretically be
    running a large number of server processes. However, most of these servers would
    usually be doing nothing but waiting for infrequent connection requests or datagrams.
    All of these server processes would nevertheless occupy slots in the kernel process
    table, and consume some memory and swap space, thus placing a load on the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *inetd* daemon is designed to eliminate the need to run large numbers of
    infrequently used servers. Using *inetd* provides two main benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of running a separate daemon for each service, a single process—the
    *inetd* daemon—monitors a specified set of socket ports and starts other servers
    as required. Thus, the number of processes running on the system is reduced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The programming of the servers started by *inetd* is simplified, because *inetd*
    performs several of the steps that are commonly required by all network servers
    on startup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since it oversees a range of services, invoking other servers as required, *inetd*
    is sometimes known as the *Internet superserver*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An extended version of *inetd*, *xinetd*, is provided in some Linux distributions.
    Among other things, *xinetd* adds a number of security enhancements. Information
    about *xinetd* can be found at [http://www.xinetd.org/](http://www.xinetd.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Operation of the *inetd* daemon
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *inetd* daemon is normally started during system boot. After becoming a
    daemon process ([Creating a Daemon](ch37.html#creating_a_daemon "Creating a Daemon")),
    *inetd* performs the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: For each of the services specified in its configuration file, `/etc/inetd.conf`,
    *inetd* creates a socket of the appropriate type (i.e., stream or datagram) and
    binds it to the specified port. Each TCP socket is additionally marked to permit
    incoming connections via a call to *listen()*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the *select()* system call ([The *select()* System Call](ch63.html#the_select_open_parenthesis_close_parent
    "The select() System Call")), *inetd* monitors all of the sockets created in the
    preceding step for datagrams or incoming connection requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *select()* call blocks until either a UDP socket has a datagram available
    to read or a connection request is received on a TCP socket. In the case of a
    TCP connection, *inetd* performs an *accept()* for the connection before proceeding
    to the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To start the server specified for this socket, *inetd()* calls *fork()* to
    create a new process that then does an *exec()* to start the server program. Before
    performing the *exec()*, the child process performs the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close all of the file descriptors inherited from its parent, except the one
    for the socket on which the UDP datagram is available or the TCP connection has
    been accepted.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the techniques described in [Duplicating File Descriptors](ch05.html#duplicating_file_descriptors
    "Duplicating File Descriptors") to duplicate the socket file descriptor on file
    descriptors 0, 1, and 2, and close the socket file descriptor itself (since it
    is no longer required). After this step, the execed server is able to communicate
    on the socket by using the three standard file descriptors.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, set the user and group IDs for the execed server to values specified
    in `/etc/inetd.conf`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If a connection was accepted on a TCP socket in step 3, *inetd* closes the connected
    socket (since it is needed only in the execed server).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *inetd* server returns to step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `/etc/inetd.conf` file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The operation of the *inetd* daemon is controlled by a configuration file, normally
    /`etc/inetd.conf`. Each line in this file describes one of the services to be
    handled by *inetd*. [Example 60-5](ch60.html#example_lines_from_solidus_etc_solidus_i
    "Example 60-5. Example lines from /etc/inetd.conf") shows some examples of entries
    in the `/etc/inetd.conf` file that comes with one Linux distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Example 60-5. Example lines from `/etc/inetd.conf`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines of [Example 60-5](ch60.html#example_lines_from_solidus_etc_solidus_i
    "Example 60-5. Example lines from /etc/inetd.conf") are commented out by the initial
    `#` character; we show them now since we’ll refer to the *echo* service shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line of `/etc/inetd.conf` consists of the following fields, delimited
    by white space:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Service name*: This specifies the name of a service from the `/etc/services`
    file. In conjunction with the *protocol* field, this is used to look up `/etc/services`
    to determine which port number *inetd* should monitor for this service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Socket type*: This specifies the type of socket used by this service—for example,
    `stream` or `dgram`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Protocol*: This specifies the protocol to be used by this socket. This field
    can contain any of the Internet protocols listed in the file `/etc/protocols`
    (documented in the *protocols(5)* manual page), but almost every service specifies
    either `tcp` (for TCP) or `udp` (for UDP).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Flags*: This field contains either `wait` or `nowait`. This field specifies
    whether or not the server execed by *inetd* (temporarily) takes over management
    of the socket for this service. If the execed server manages the socket, then
    this field is specified as `wait`. This causes *inetd* to remove this socket from
    the file descriptor set that it monitors using *select()* until the execed server
    exits (*inetd* detects this via a handler for `SIGCHLD`). We say some more about
    this field below.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Login name*: This field consists of a username from `/etc/passwd`, optionally
    followed by a period (`.`) and a group name from `/etc/group`. These determine
    the user and group IDs under which the execed server is run. (Since *inetd* runs
    with an effective user ID of *root*, its children are also privileged and can
    thus use calls to *setuid()* and *setgid()* to change process credentials if desired.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Server program*: This specifies the pathname of the server program to be execed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Server program arguments*: This field specifies one or more arguments, separated
    by white space, to be used as the argument list when execing the server program.
    The first of these corresponds to *argv[0]* in the execed program and is thus
    usually the same as the basename part of the *server program* name. The next argument
    corresponds to *argv[1]*, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the example lines shown in [Example 60-5](ch60.html#example_lines_from_solidus_etc_solidus_i
    "Example 60-5. Example lines from /etc/inetd.conf") for the *ftp*, *telnet*, and
    *login* services, we see the server program and arguments are set up differently
    than just described. All three of these services cause *inetd* to invoke the same
    program, *tcpd(8)* (the TCP daemon wrapper), which performs some logging and access-control
    checks before in turn execing the appropriate program, based on the value specified
    as the first server program argument (which is available to *tcpd* via *argv[0]*).
    Further information about *tcpd* can be found in the *tcpd(8)* manual page and
    in [Mann & Mitchell, 2003].
  prefs: []
  type: TYPE_NORMAL
- en: Stream socket (TCP) servers invoked by *inetd* are normally designed to handle
    just a single client connection and then terminate, leaving *inetd* with the job
    of listening for further connections. For such servers, *flags* should be specified
    as `nowait`. (If, instead, the execed server is to accept connections, then `wait`
    should be specified, in which case *inetd* does not accept the connection, but
    instead passes the file descriptor for the *listening* socket to the execed server
    as descriptor 0.)
  prefs: []
  type: TYPE_NORMAL
- en: For most UDP servers, the *flags* field should be specified as `wait`. A UDP
    server invoked by *inetd* is normally designed to read and process all outstanding
    datagrams on the socket and then terminate. (This usually requires some sort of
    timeout when reading the socket, so that the server terminates when no new datagrams
    arrive within a specified interval.) By specifying `wait`, we prevent the *inetd*
    daemon from simultaneously trying to *select()* on the socket, which would have
    the unintended consequence that *inetd* would race the UDP server to check for
    datagrams and, if it won the race, start another instance of the UDP server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because the operation of *inetd* and the format of its configuration file are
    not specified by SUSv3, there are some (generally small) variations in the values
    that can be specified in the fields of `/etc/inetd.conf`. Most versions of *inetd*
    provide at least the syntax that we describe in the main text. For further details,
    see the *inetd.conf(8)* manual page.
  prefs: []
  type: TYPE_NORMAL
- en: As an efficiency measure, *inetd* implements a few simple services itself, instead
    of execing separate servers to perform the task. The UDP and TCP *echo* services
    are examples of services that *inetd* implements. For such services, the *server
    program* field of the corresponding `/etc/inetd.conf` record is specified as `internal`,
    and the *server program arguments* are omitted. (In the example lines in [Example 60-5](ch60.html#example_lines_from_solidus_etc_solidus_i
    "Example 60-5. Example lines from /etc/inetd.conf"), we saw that the *echo* service
    entries were commented out. To enable the *echo* service, we need to remove the
    `#` character at the start of these lines.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever we change the `/etc/inetd.conf` file, we need to send a `SIGHUP` signal
    to *inetd* to request it to reread the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: invoking a TCP *echo* service via *inetd*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We noted earlier that *inetd* simplifies the programming of servers, especially
    concurrent (usually TCP) servers. It does this by carrying out the following steps
    on behalf of the servers it invokes:'
  prefs: []
  type: TYPE_NORMAL
- en: Perform all socket-related initialization, calling *socket()*, *bind()*, and
    (for TCP servers) *listen()*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a TCP service, perform an *accept()* for the new connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new process to handle the incoming UDP datagram or TCP connection.
    The process is automatically set up as a daemon. The *inetd* program handles all
    details of process creation via *fork()* and the reaping of dead children via
    a handler for `SIGCHLD`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the file descriptor of the UDP socket or the connected TCP socket
    on file descriptors 0, 1, and 2, and close all other file descriptors (since they
    are unused in the execed server).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exec the server program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (In the description of the above steps, we assume the usual cases that the *flags*
    field of the service entry in `/etc/inetd.conf` is specified as `nowait` for TCP
    services and `wait` for UDP services.)
  prefs: []
  type: TYPE_NORMAL
- en: As an example of how *inetd* simplifies the programming of a TCP service, in
    [Example 60-6](ch60.html#tcp_echo_server_designed_to_be_invoked_v "Example 60-6. TCP
    echo server designed to be invoked via inetd"), we show the *inetd*-invoked equivalent
    of the TCP *echo* server from [Example 60-4](ch60.html#a_concurrent_server_that_implements_the
    "Example 60-4. A concurrent server that implements the TCP echo service"). Since
    *inetd* performs all of the above steps, all that remains of the server is the
    code executed by the child process to handle the client request, which can be
    read from file descriptor 0 (`STDIN_FILENO`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the server resides in the directory `/bin` (for example), then we would
    need to create the following entry in `/etc/inetd.conf` in order to have *inetd*
    invoke the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Example 60-6. TCP *echo* server designed to be invoked via *inetd*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An iterative server handles one client at a time, processing that client’s request(s)
    completely, before proceeding to the next client. A concurrent server handles
    multiple clients simultaneously. In high-load scenarios, a traditional concurrent
    server design that creates a new child process (or thread) for each client may
    not perform well enough, and we outlined a range of other approaches for concurrently
    handling large numbers of clients.
  prefs: []
  type: TYPE_NORMAL
- en: The Internet superserver daemon, *inetd*, monitors multiple sockets and starts
    the appropriate servers in response to incoming UDP datagrams or TCP connections.
    Using *inetd* allows us to decrease system load by minimizing the number of network
    server processes on the system, and also simplifies the programming of server
    processes, since it performs most of the initialization steps required by a server.
  prefs: []
  type: TYPE_NORMAL
- en: Further information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Refer to the sources of further information listed in [Further Information](ch59.html#further_information-id81
    "Further Information").
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add code to the program in [Example 60-4](ch60.html#a_concurrent_server_that_implements_the
    "Example 60-4. A concurrent server that implements the TCP echo service") (`is_echo_sv.c`)
    to place a limit on the number of simultaneously executing children.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sometimes, it may be necessary to write a socket server so that it can be invoked
    either directly from the command line or indirectly via *inetd*. In this case,
    a command-line option is used to distinguish the two cases. Modify the program
    in [Example 60-4](ch60.html#a_concurrent_server_that_implements_the "Example 60-4. A
    concurrent server that implements the TCP echo service") so that, if it is given
    a *-i* command-line option, it assumes that it is being invoked by *inetd* and
    handles a single client on the connected socket, which *inetd* supplies via `STDIN_FILENO`.
    If the *-i* option is not supplied, then the program can assume it is being invoked
    from the command line, and operate in the usual fashion. (This change requires
    only the addition of a few lines of code.) Modify `/etc/inetd.conf` to invoke
    this program for the *echo* service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
