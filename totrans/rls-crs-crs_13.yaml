- en: Chapter 11. Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When users sign up for an account on your website, they trust that you will
    keep their data safe and secure. Unfortunately, as the popularity of your application
    increases, so does the likelihood of attack. Even if your application is not popular
    yet, it can still fall victim to automated systems that scan the web looking for
    vulnerable sites.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn about four of the most common security vulnerabilities
    and how to protect your site from them. We’ll discuss authorization, injection,
    cross-site scripting, and cross-site request forgery attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization Attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You created an authentication system in [Chapter 9](ch09.html "Chapter 9. Authentication"),
    but authentication is not the same thing as authorization. *Authentication* identifies
    a user. *Authorization* specifies what a logged-in user can access within your
    application. Your authentication system uses an email address and a password to
    identify a user. Authorization systems usually deal with roles or privileges.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you aren’t defining roles for the users in your application,
    but some privileges should be in place. For example, a user should be able to
    view and edit his or her own posts but only view posts belonging to another user.
    A user should also be able to moderate comments on his or her own posts, even
    if another user added the comment.
  prefs: []
  type: TYPE_NORMAL
- en: An *authorization attack* occurs when a user manages to bypass privileges and
    access a resource that is owned by another user. The most common type of authorization
    attack is known as an *insecure direct object reference*, which means the user
    can manipulate the URL to access a restricted resource in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example from your social app. This code sample creates a method
    to allow users to edit previously created text posts, but it includes a resource
    lookup that allows an insecure direct object reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This method finds the `TextPost` to edit using the `id` parameter passed in
    as part of the URL, regardless of who originally created it. Because this code
    doesn’t check which user is trying to access the post, any authenticated user
    could edit any post in the application. All the user has to do is open one of
    his or her posts to edit, work out which part of the URL represents the post `id`,
    and change that value to another post’s `id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You only want users to be able to edit their own posts. This next listing shows
    a better way to handle this lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By using `current_user.text_posts`, the `find` method is restricted to only
    posts belonging to the current user. Now if a user changes the `id` in the URL
    in an attempt to modify another user’s post, the `find` will fail and the user
    should see the 404 error page. If a resource is owned by a user, always reference
    that user when finding the resource in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know the correct way to find a post to be edited, add the previous
    method to the text post controller at *app/controllers/text_posts_controller.rb*.
    When the user submits the `edit` text post form, the changes are sent to the `update`
    action. Use the same authorization idea to add an `update` method for text posts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This method finds the correct text post ➊ belonging to the current user and
    calls the `update` method ➋ using the `params` from the text post form. If the
    call to `update` is successful, the text post is updated in the database and the
    user is redirected to the updated post. Otherwise, the `edit` view is rendered
    again with an error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create the file *app/views/text_posts/edit.html.erb* and add the `edit`
    view for text posts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This view is the same as the `new` view for text posts except for the heading.
    This view reuses the form partial you created in the last chapter. Finally, add
    a link to the `edit` action in the `TextPost` partial at *app/views/text_posts/_text_post.html.erb*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This link should only appear if the text post belongs to the current user ➊.
    Editing image posts follows the same pattern. Add the `edit` and `update` methods,
    complete with authorization, to *app/controllers/image_posts_controller.rb*, create
    an `edit` view for image posts at *app/views/image_posts/edit.html.erb*, and add
    a link to the `edit` action in the `ImagePost` partial at *app/views/image_posts/_image_post.html.erb*.
    These steps are covered in Exercise 1 at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Injection Attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An *injection attack* occurs when input from a user is executed as part of the
    application. Injection attacks are extremely common, especially in older applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first rule of avoiding injection attacks is *never trust input from the
    user*. If an application does not ensure that all data entered by a user is safe,
    then it is vulnerable to injection attacks. Keep this in mind as we look at two
    types of injection attacks in this section: SQL injection and cross-site scripting.'
  prefs: []
  type: TYPE_NORMAL
- en: SQL Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a *SQL injection* attack, user input is added directly to an SQL statement.
    If a malicious user provides actual SQL code as input, he or she could bypass
    your application’s authorization system, query your application’s database, and
    obtain or delete restricted information.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider an application where the Rails built-in secure password
    feature is not used. Instead, the developer stores usernames and passwords in
    the database and has written his or her own `authenticate` method to verify a
    user’s credentials. This custom `User.authenticate` method shows what *not* to
    do, as it’s vulnerable to SQL injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This method accepts arguments for `username` and `password` ➊. These values
    are entered by the user and passed to the controller as parameters. These variables
    are then added to a `where` call using string interpolation ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method returns the correct user object for valid username and password
    combinations. For example, assuming a `User` with `username` tony and `password`
    secret, this method returns the `User`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The method call then generates the following SQL code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This method also works correctly when passed invalid `username` and `password`
    combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `password` is not valid so the method returns `nil`. So far,
    so good!
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing an Authentication System
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unfortunately, savvy attackers know a handy SQL string that allows them to
    bypass completely this `authenticate` method: `'' OR ''1''=''1`. In SQL, the statement
    `''1''=''1''` evaluates to `TRUE`, so if it is added to any other conditional
    statement with `OR`, the entire conditional evaluates to `TRUE`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what happens when this string is passed to the authenticate method
    for `username` and `password`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'I didn’t pass the method any valid data, so how did the `authenticate` method
    succeed? The SQL code generated by the method call shows the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Even though there is no user with an empty string for `username` and `password`,
    the addition of `OR '1'='1'` causes the `WHERE` clause to evaluate to `TRUE` and
    the method returns the first user in the database. The attacker is now logged
    in as the first user. This attack is made worse by the fact that the first user
    in the database usually belongs to the application’s creator, who might also have
    special privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing SQL Injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thankfully, you can usually find SQL injection errors just by looking at your
    code carefully. If you see string interpolation inside a `where` method, assume
    it is dangerous and needs to be corrected.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you must build your own query string, switch to hash conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, the string is completely removed from the call to the `where` method.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Cross-site scripting (XSS)* is another common injection attack. In a cross-site
    scripting attack, an attacker is allowed to enter malicious JavaScript code into
    your application. Any text field can potentially be used in a cross-site scripting
    attack. When another user views a page with malicious JavaScript, the user’s browser
    executes the code as if it were part of your application.'
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site scripting vulnerabilities can be exploited to deface your website
    or even display fake log-in forms in an attempt to steal user credentials. The
    possibilities are almost endless if an attacker is able to inject code into your
    site.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in Protection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rails includes protection from cross-site scripting by default. Your application
    is safe from XSS attacks unless you explicitly bypass this protection. As a quick
    check, try entering the following JavaScript code in the body of a new text post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After saving this post, you should see that before displaying text on the page,
    as shown in [Figure 11-1](ch11.html#text_post_with_escaped_html "Figure 11-1. Text
    post with escaped HTML"), Rails first *escapes* all HTML tags by replacing special
    characters with their corresponding character entities.
  prefs: []
  type: TYPE_NORMAL
- en: '![Text post with escaped HTML](httpatomoreillycomsourcenostarchimages2169102.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1. Text post with escaped HTML
  prefs: []
  type: TYPE_NORMAL
- en: For example, less-than signs are replaced with `&lt;` and greater-than signs
    with `&gt;`. Instead of being executed, the code is displayed on the page like
    any other text. So if you never plan to allow users to enter HTML into your site,
    your application is safe from cross-site scripting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, users might like to enter HTML tags to format their posts in
    your application. In this case, your site will need to accept at least a few HTML
    tags. You can turn off the automatic escaping of HTML tags by using the `raw`
    helper method in your view. Open *app/views/text_posts/_text_post.html.erb* and
    add `raw` before `text_post.body`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now when you refresh the page in your browser, the script tag will not be escaped,
    and you should see a pop-up window with the text “XSS,” as shown in [Figure 11-2](ch11.html#text_post_with_xss_vulnerability
    "Figure 11-2. Text post with XSS vulnerability").
  prefs: []
  type: TYPE_NORMAL
- en: '![Text post with XSS vulnerability](httpatomoreillycomsourcenostarchimages2169104.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-2. Text post with XSS vulnerability
  prefs: []
  type: TYPE_NORMAL
- en: The trick is to let your application only accept safe tags, such as `<strong>`
    for bold, `<em>` for italics, and `<p>` for marking paragraphs, while rejecting
    dangerous tags such as `<script>`. You might be tempted to write your own helper
    method to deal with these dangerous tags, but thankfully, Rails provides the `sanitize`
    helper method to take care of this for you.
  prefs: []
  type: TYPE_NORMAL
- en: The sanitize method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sanitize` helper method removes all HTML tags that are not explicitly allowed
    by its whitelist. You can see the list of allowed tags by entering **`ActionView::Base.sanitized_allowed_tags`**
    in a Rails console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try a few examples of the `sanitize` method in the Rails console to familiarize
    yourself with how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can specify your own array of allowed tags by including a value for the
    `tags` key in the `options` hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve seen the `sanitize` method in action, replace the `raw` method
    call with `sanitize` in the `TextPost` partial you edited earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Refresh the page again and you should no longer see the alert.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Request Forgery Attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *cross-site request forgery (CSRF) attack* occurs when one of your application’s
    users visits another site that has been modified by an attacker to target your
    site specifically. The malicious site attempts to use your application’s trust
    in this user to submit requests to your application.
  prefs: []
  type: TYPE_NORMAL
- en: To exploit a CSRF vulnerability, the attacker must first find the vulnerability
    in your application. Next, he or she must create a page with a link to the vulnerability.
    Finally, the attacker must trick your application’s users into visiting the malicious
    page and activating the link.
  prefs: []
  type: TYPE_NORMAL
- en: How CSRF Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you are building an online payment application. Your application includes
    a `transfer` action that accepts `amount` and `to` parameters that specify how
    much money to transfer to another user.
  prefs: []
  type: TYPE_NORMAL
- en: 'An attacker could study the requests generated by your site and attempt to
    replicate those requests on his or her own site using something as simple as an
    HTML image tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Every time someone visits this page, the user’s browser issues a GET request
    to your site when it tries to load this image. If the visitor is logged in to
    your site and your site is vulnerable to CSRF attacks, $100 is transferred from
    the visitor’s account to the attacker’s account.
  prefs: []
  type: TYPE_NORMAL
- en: 'You aren’t building a payment site, but your site is vulnerable to a CSRF attack.
    In [Chapter 10](ch10.html "Chapter 10. Testing"), you added a method for one user
    to *follow* another user on the site. In doing that, you added the following line
    to *config/routes.rb*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'By looking at the request created when I click the Follow button, I can create
    a malicious link to exploit this vulnerability. Assuming my account’s `id` is
    10, the link would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now all I need to do is convince other users to visit a page containing this
    image tag and they will follow me automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing CSRF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can prevent CSRF attacks in two steps. First, include a user-specific token
    with all requests that change state in your application, and ignore any request
    that does not include this token. Second, never use a GET request to change state.
    If a request could create or change data in the database or the session, it should
    use POST.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rails takes care of including a secret token and denying requests by default.
    Open the application layout at *app/views/layouts/application.html.erb* to see
    the code for including the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Load your site in a web browser and then view source to see the `meta` tags
    generated by this method in the page’s `head`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can also see the `authenticity_token` in a hidden field included with every
    form in your application. Every time you submit a form, the value from this hidden
    field is included with the other parameters. The `authenticity_token` is also
    automatically included with all POST requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open *app/controllers/application_controller.rb* to see the code that actually
    denies invalid requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, Rails goes one step further and raises an exception for requests that
    don’t include the CSRF token. This exception is logged and can be used to track
    down attackers.
  prefs: []
  type: TYPE_NORMAL
- en: You must handle the second step yourself. Any time you add a controller action,
    make sure you do not use a GET request if the action could change data. The `follow`
    action added in [Chapter 10](ch10.html "Chapter 10. Testing") creates a record
    in the database, so it should be a POST request. The POST request automatically
    includes the `authenticity_token`, and Rails verifies the token thanks to the
    `protect_from_forgery` method in `ApplicationController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To correct this vulnerability in your application, open *config/routes.rb*
    and change the `follow` action to use POST instead of GET:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now update the link in *app/views/users/show.html.erb* to use the POST method
    instead of the default GET:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: With these two changes, the `follow` action should now be safe from CSRF attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Malicious users and sites are unavoidable on the Web today. As your application
    gains popularity, the risk of attack rises. Thankfully, Rails provides the tools
    you need to protect your application and your users from attacks.
  prefs: []
  type: TYPE_NORMAL
- en: The security vulnerabilities covered in this chapter were taken from the Top
    10 list published by The Open Web Application Security Project (OWASP). Visit
    *[http://www.owasp.org/](http://www.owasp.org/)* to find your local OWASP chapter
    and discuss application security at free meetings in your area.
  prefs: []
  type: TYPE_NORMAL
- en: Now that your application is functional and secure, we’ll look at performance
    in the next chapter. No one likes a slow web application! Here again, Rails provides
    several tools for improving your application’s performance, but you have to put
    them to use.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| Q: | 1\. Users should also be able to edit their image posts. Add the `edit`
    and `update` methods to the `ImagePostsController` at *app/controllers/image_posts_controller.rb*.
    Also add the `ImagePost edit` view at *app/views/image_posts/edit.html.erb*. Finally,
    add a link to the `edit` action in the `ImagePost` partial at *app/views/image_posts/_image_post.html.erb*.
    The methods and views should be similar to those you added for text posts. |'
  prefs: []
  type: TYPE_TB
- en: '| Q: | 2\. Users should be able to moderate comments on their own posts. First,
    add a `@can_moderate` instance variable inside the `show` action in `PostsController`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This variable is `true` if the `current_user` is the author of the post being
    displayed. Now update the comment partial at *app/views/comments/_comment.html.erb*
    to include a link to the `destroy` action if the value of `@can_moderate` is `true.`
    Finally, add the `destroy` action to the `CommentsController` at *app/controllers/comments_controller.rb*.
    This action should find the correct comment using the `id` from the `params` hash,
    call the `destroy` method on the comment, and then redirect to the `post_path`
    with a message indicating success or failure. |
  prefs: []
  type: TYPE_NORMAL
- en: '| Q: | 3\. You need to correct one more CSRF vulnerability in your application.
    Open the routes file at *config/routes.rb* and look at the `logout` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This route leads to the `destroy` action in the `SessionsController` and you’re
    using a GET request ➊ to access it. Change this route from `get` to `delete` so
    a DELETE request is required. Also, add `method: :delete` to the *Log Out* link
    in the application layout at *app/views/layouts/application.html.erb*. |'
  prefs: []
  type: TYPE_NORMAL
