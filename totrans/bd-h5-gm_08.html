<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Rendering Canvas Sprites"><div class="titlepage"><div><div><h1 class="title"><a id="rendering_canvas_sprites"/>Chapter 6. Rendering Canvas Sprites</h1></div></div></div><p><a id="iddle1087" class="indexterm"/><a id="iddle1523" class="indexterm"/><a id="iddle1753" class="indexterm"/><a id="iddle2306" class="indexterm"/><a id="iddle2409" class="indexterm"/><a id="iddle2517" class="indexterm"/>Up until now, we’ve built <span class="emphasis"><em>Bubble Shooter</em></span> with a DOM-based approach by using HTML elements for game objects that are styled and positioned by CSS and manipulated by JavaScript. In this chapter, we’ll rework <span class="emphasis"><em>Bubble Shooter</em></span> so most of the game area is rendered to a canvas instead of using the DOM. Our game’s dialogs will remain in HTML and CSS.</p><p>Canvas rendering allows us to achieve graphical effects that are often impossible with DOM-based development, and it can often provide a faster rendering speed. To use canvas rendering for <span class="emphasis"><em>Bubble Shooter</em></span>, we need to learn how to render entire scenes to the canvas, maintain state, and perform frame-by-frame animations.</p><p><a id="iddle1206" class="indexterm"/><a id="iddle1219" class="indexterm"/><a id="iddle1472" class="indexterm"/><a id="iddle1487" class="indexterm"/><a id="iddle1656" class="indexterm"/><a id="iddle1965" class="indexterm"/><a id="iddle2085" class="indexterm"/><a id="iddle2226" class="indexterm"/><a id="iddle2235" class="indexterm"/><a id="iddle2263" class="indexterm"/>We’ll keep the existing DOM-rendering code in place for devices where the <code class="literal">canvas</code> element isn’t supported and provide progressive enhancement to the canvas for more modern browsers. We’ll do this to demonstrate the principle involved in coding for both canvas- and DOM-based animation and to highlight the differences between the two approaches.</p><div class="sect1" title="Detecting Canvas Support"><div class="titlepage"><div><div><h1 class="title"><a id="detecting_canvas_support"/>Detecting Canvas Support</h1></div></div></div><p>Modernizr can help us detect canvas features so we don’t have to remember multiple cross-browser cases. We’ll load in only a couple of extra JavaScript files for the canvas version and won’t delete any files. To detect the canvas and load in the right files, we need an extra node in <code class="literal">Modernizr.load</code> in <span class="emphasis"><em>index.html</em></span>, which will check for canvas support, and if present, load JavaScript files from an array. Add the following before <span class="emphasis"><em>game.js</em></span> is loaded:</p><p><span class="emphasis"><em>index.html</em></span></p><a id="pro_id00109"/><pre class="programlisting">},
<span class="strong"><strong>{</strong></span>
  <span class="strong"><strong>test: Modernizr.canvas,</strong></span>
  <span class="strong"><strong>yep: ["_js/renderer.js","_js/sprite.js"]</strong></span>
<span class="strong"><strong>},</strong></span>
{
  load: "_js/game.js",
  complete: function(){
    $(function(){
      var game = new BubbleShoot.Game();
      game.init();
    })
 }
<span class="strong"><strong>}</strong></span>]);</pre><p>The value of <code class="literal">Modernizr.canvas</code>, the parameter that <code class="literal">test</code> looks for, will be either <code class="literal">true</code> or <code class="literal">false</code>. If it’s <code class="literal">true</code>, the two files listed in <code class="literal">yep</code> are loaded; if it’s <code class="literal">false</code>, nothing new happens.</p><p>Create empty files for <span class="emphasis"><em>renderer.js</em></span> and <span class="emphasis"><em>sprite.js</em></span> in the <span class="emphasis"><em>_js</em></span> folder. The <code class="literal">Renderer</code> object will draw the game state at each frame, and the <code class="literal">Sprite</code> class will perform many of the operations that we’ve been using jQuery for to date. We want <code class="literal">Renderer</code> to be responsible for drawing pixels onto the canvas and not mix up game logic with it; likewise, we’ll try to keep state information inside the relevant objects. This approach makes it much easier to switch between rendering using the canvas or the DOM, depending on what we think is best for the game.</p></div><div class="sect1" title="Drawing to the Canvas"><div class="titlepage"><div><div><h1 class="title"><a id="drawing_to_the_canvas"/>Drawing to the Canvas</h1></div></div></div><p>With HTML5’s canvas feature, you can build games at a level of sophistication similar to that of Flash games or even native applications. You place <code class="literal">canvas</code> elements into documents in the same way as other elements, such as <code class="literal">&lt;div&gt;</code> or <code class="literal">&lt;img&gt;</code>, but it’s the way you work with the element that makes it <a id="iddle1009" class="indexterm"/><a id="iddle1049" class="indexterm"/><a id="iddle1088" class="indexterm"/><a id="iddle1468" class="indexterm"/><a id="iddle1478" class="indexterm"/><a id="iddle1660" class="indexterm"/><a id="iddle1699" class="indexterm"/><a id="iddle1752" class="indexterm"/><a id="iddle1757" class="indexterm"/><a id="iddle1759" class="indexterm"/><a id="iddle1774" class="indexterm"/><a id="iddle2028" class="indexterm"/><a id="iddle2307" class="indexterm"/><a id="iddle2317" class="indexterm"/><a id="iddle2362" class="indexterm"/><a id="iddle2375" class="indexterm"/><a id="iddle2582" class="indexterm"/>different. Inside the canvas, you have pixel-level control, and you can draw to individual pixels, read their values, and manipulate them. You can write JavaScript code to generate arcade shooters or even 3D games that are difficult to reproduce with a DOM-based approach.</p><div class="sidebar"><a id="dom_vsdot_the_canvas"/><p class="title">The DOM vs. The Canvas</p><p>HTML is primarily an information format; CSS was introduced as a way to format that information. Creating games using both technologies is really a misappropriation, and games like <span class="emphasis"><em>Bubble Shooter</em></span> are feasible largely because browser vendors have made an effort to increase performance. Many of the processes that are invaluable in laying out documents, such as ensuring that text areas don’t overlap or that text wraps around images, are practices that we don’t need for laying out games. As game developers, we take on responsibility for ensuring the screen is laid out well, but, unfortunately for us, the browser still runs through all of these checks in the background.</p><p>For example, adding or removing elements in the DOM can be a relatively expensive operation in terms of processing power. The reason is that if we add or remove something, the browser needs to inspect it to ensure that the change doesn’t have a domino effect on the rest of the document flow. If we were working with, say, an expanding menu on a website, we might want the browser to push a navigation area down if we add more elements to it. However, in a game it’s more likely that we will be using <code class="literal">position: absolute</code>, and we definitely don’t want the addition or removal of a new element to force everything surrounding it to be repositioned.</p><p>By contrast, when the browser sees a <code class="literal">canvas</code> element, it sees just an image. If we change the contents of the canvas, only the contents change. The browser doesn’t need to consider whether this change will have a knock-on effect on the rest of the document.</p></div><p>Unlike CSS and HTML, the canvas doesn’t let you rely on the browser to keep track of the positions of objects on the screen. Nothing automatically deals with layering or rendering backgrounds when a sprite moves over them because the canvas outputs a flat image for the browser to display. If sprite animation and movement with CSS is like moving papers around on a notice wall, canvas animation is more like working with a whiteboard: if you want to change something or move it, you’ll have to erase an area and redraw it.</p><p>Canvas rendering also differs from CSS layout in that positioning of elements can’t be offloaded to the browser. For example, with our existing DOM-based system, we can use a CSS transition to move the bubble visually from its firing position to wherever we want it to end up in the board layout. To do this takes only a couple of lines of code.</p><p><a id="iddle1135" class="indexterm"/><a id="iddle1455" class="indexterm"/><a id="iddle1465" class="indexterm"/><a id="iddle1482" class="indexterm"/><a id="iddle1488" class="indexterm"/><a id="iddle1498" class="indexterm"/><a id="iddle1509" class="indexterm"/><a id="iddle1519" class="indexterm"/><a id="iddle1549" class="indexterm"/><a id="iddle1725" class="indexterm"/><a id="iddle1743" class="indexterm"/><a id="iddle1826" class="indexterm"/><a id="iddle1948" class="indexterm"/><a id="iddle1958" class="indexterm"/><a id="iddle2042" class="indexterm"/><a id="iddle2047" class="indexterm"/><a id="iddle2271" class="indexterm"/><a id="iddle2286" class="indexterm"/><a id="iddle2368" class="indexterm"/><a id="iddle2390" class="indexterm"/><a id="iddle2544" class="indexterm"/><a id="iddle2554" class="indexterm"/><a id="iddle2580" class="indexterm"/><a id="iddle2694" class="indexterm"/>Canvas rendering, on the other hand, requires us to animate frame by frame in a way similar to the internal workings of jQuery. We must calculate how far a bubble is along its path and draw it at that position each time a frame update occurs.</p><p>On its own, animating on the canvas using JavaScript would be no more arduous than JavaScript animation using the DOM without jQuery or CSS transitions to fall back on, but the process is made more complex by the fact that if we want to change the contents of the canvas, we need to delete pixels and redraw them. Ways to optimize the redrawing process are available, but a basic approach is to draw the entire canvas afresh for each animation frame. This means that, if we want to move an object across the canvas, we have to render not just the object that we want to move but possibly every object in the scene.</p><p>We’ll draw the game board and the current bubble using the canvas, but some components, such as dialogs, are better left as DOM elements. User interface components are generally easier to update as DOM elements, and the browser usually renders text more precisely with HTML than it would render text within a <code class="literal">canvas</code> element.</p><p>Now that we’ve decided to render the game with a canvas system, let’s look at what that will involve. The key tasks are rendering the images and maintaining states for each bubble so that we know which bubbles are stationary, which are moving, and which are in the various stages of being popped.</p></div><div class="sect1" title="Image Rendering"><div class="titlepage"><div><div><h1 class="title"><a id="image_rendering"/>Image Rendering</h1></div></div></div><p>Any image you want to draw to the canvas must be preloaded so it’s available to be drawn; otherwise, nothing appears. To do this, we’ll create an in-memory <code class="literal">Image</code> object in JavaScript, set the image source to the sprite sheet, and attach an <code class="literal">onload</code> event handler to it so we know when it’s finished loading. Currently, the game is playable once the <code class="literal">init</code> function in <span class="emphasis"><em>game.js</em></span> has run and the New Game button has the <code class="literal">startGame</code> function attached to its <code class="literal">click</code> event:</p><a id="pro_id00110"/><pre class="programlisting">$(".but_start_game").bind("click",startGame);</pre><p>We still want this to happen, but we don’t want it to happen until after the sprite sheet image has loaded. This will be the first task we’ll tackle.</p><div class="sect2" title="canvas Elements"><div class="titlepage"><div><div><h2 class="title"><a id="canvas_elements"/>canvas Elements</h2></div></div></div><p>Next, we need to know how to draw images onto the canvas. A <code class="literal">canvas</code> element is an HTML element just like any other: it can be inserted into the DOM, can have CSS styling applied, and behaves in much the same way as an image. For example, to create a <code class="literal">canvas</code> element, we add the following to <span class="emphasis"><em>index.html</em></span>:</p><a id="pro_id00111"/><pre class="programlisting">&lt;canvas id="game_canvas " width="1000" height="620"&gt;&lt;/canvas&gt;</pre><p><a id="iddle1005" class="indexterm"/><a id="iddle1467" class="indexterm"/><a id="iddle1480" class="indexterm"/><a id="iddle1491" class="indexterm"/><a id="iddle1495" class="indexterm"/><a id="iddle1506" class="indexterm"/><a id="iddle1518" class="indexterm"/><a id="iddle1524" class="indexterm"/><a id="iddle1525" class="indexterm"/><a id="iddle1530" class="indexterm"/><a id="iddle1602" class="indexterm"/><a id="iddle1604" class="indexterm"/><a id="iddle1609" class="indexterm"/><a id="iddle1612" class="indexterm"/><a id="iddle1624" class="indexterm"/><a id="iddle1667" class="indexterm"/><a id="iddle1980" class="indexterm"/><a id="iddle1985" class="indexterm"/><a id="iddle2114" class="indexterm"/><a id="iddle2386" class="indexterm"/>This creates a <code class="literal">canvas</code> element with the dimensions of 1000 pixels wide by 620 pixels high. These dimensions are important because they establish the number of pixels that make up the canvas. However, we should also set these dimensions in CSS to establish the size of the canvas as it will appear on the page:</p><a id="pro_id00112"/><pre class="programlisting">#game_canvas
{
  width: 1000px;
  height: 620px;
}</pre><p>In the same way that an image can be rendered at scale, the <code class="literal">canvas</code> element can also be scaled. By setting the CSS dimensions to the same values as the HTML attributes, we ensure that we’re drawing the canvas at a scale of 1:1. If we omitted the CSS, the canvas would be rendered at the width and height specified in the attributes, but it’s good practice to specify layout dimensions within the style sheet. Not only does it help with code readability, but it also ensures that if the internal dimensions of the canvas are changed, the page layout won’t break.</p><p>To draw an image onto the canvas using JavaScript, we first need to get a <span class="emphasis"><em>context</em></span>, the object that you use to manipulate canvas contents, using the method <code class="literal">getContext</code>. A context tells the browser whether we’re working in two dimensions or three. You would write something like this to indicate you want to work in two-dimensional space rather than three-dimensional space:</p><a id="pro_id00113"/><pre class="programlisting">document.getElementById("game_canvas").getContext("2d");</pre><p>Or to write this using jQuery:</p><a id="pro_id00114"/><pre class="programlisting">$("#game_canvas").get(0).getContext("2d");</pre><p>Note that the context is a property of the DOM node, not the jQuery object, because we’re retrieving the first object in jQuery’s set with the <code class="literal">get(0)</code> call. We need the DOM node because the basic jQuery library doesn’t contain any special functions for working with <code class="literal">canvas</code> elements.</p><p>Now, to draw the image onto the canvas, we use the <code class="literal">drawImage</code> method of the context object:</p><a id="pro_id00115"/><pre class="programlisting">document.getElementById("game_canvas").getContext("2d").
drawImage(imageObject,x,y);</pre><p>Or again, to write this using jQuery:</p><a id="pro_id00116"/><pre class="programlisting">$("#game_canvas").get(0).getContext("2d").drawImage(imageObject,x,y);</pre><p><a id="iddle1481" class="indexterm"/><a id="iddle1483" class="indexterm"/><a id="iddle1503" class="indexterm"/><a id="iddle1510" class="indexterm"/><a id="iddle1515" class="indexterm"/><a id="iddle1526" class="indexterm"/><a id="iddle1606" class="indexterm"/><a id="iddle1616" class="indexterm"/><a id="iddle1619" class="indexterm"/><a id="iddle1621" class="indexterm"/><a id="iddle1625" class="indexterm"/><a id="iddle1627" class="indexterm"/><a id="iddle1726" class="indexterm"/><a id="iddle2043" class="indexterm"/><a id="iddle2391" class="indexterm"/>The parameters passed into <code class="literal">drawImage</code> are the <code class="literal">Image</code> object and then <span class="emphasis"><em>x</em></span>- and <span class="emphasis"><em>y</em></span>-coordinates at which to draw the image. These are pixels relative to the canvas context origin. By default, (0,0) is the top-left corner of the canvas.</p><p>We can also clear pixels from the canvas with the <code class="literal">clearRect</code> method:</p><a id="pro_id00117"/><pre class="programlisting">$("#game_canvas").get(0).getContext("2d").clearRect(0, 0, 1000, 620);</pre><p>The <code class="literal">clearRect</code> command removes all canvas pixels from the top-left corner (first two parameters) down to the bottom-right corner (last two parameters). Although you can just clear the canvas rectangle that you want to change, it’s usually easier to clear the entire canvas and redraw it each frame. Again, the coordinates are relative to the context origin.</p><p>The context maintains a number of state properties about the canvas, such as the current line thickness, line colors, and font properties. Most important for drawing sprites, it also maintains the coordinates of the context origin and a rotation angle. In fact, you can draw an image at a set position on the canvas in two ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Pass <span class="emphasis"><em>x</em></span>- and <span class="emphasis"><em>y</em></span>-coordinates into the <code class="literal">drawImage</code> function.</p></li><li class="listitem"><p>Move the context origin and draw the image at the origin.</p></li></ul></div><p>In practice, you’ll see the same results with either method, but there is a reason it’s often best to move—or <span class="emphasis"><em>translate</em></span>—the context origin. If you want to draw an image onto the canvas at an angle, it’s not the image that’s rotated but the canvas context that’s rotated prior to drawing the image.</p></div><div class="sect2" title="Rotating the Canvas"><div class="titlepage"><div><div><h2 class="title"><a id="rotating_the_canvas"/>Rotating the Canvas</h2></div></div></div><p>The canvas is always rotated around its origin. If you want to rotate an image around its own center, first translate the canvas origin to a new origin at the center of the image. Then rotate the canvas by the angle at which you want to rotate the image <span class="emphasis"><em>but in the opposite direction to the rotation you wanted to apply to the object</em></span>. Then draw the image as usual, rotate the canvas back to zero degrees around its new origin, and finally translate the canvas back to its initial origin. <a class="xref" href="ch06.html#drawing_a_rotated_image_onto_the_canvas" title="Figure 6-1. Drawing a rotated image onto the canvas">Figure 6-1</a> shows how this works.</p><p>For example, to draw an image that’s 100 pixels across at coordinates (100,100) and rotate it by 30 degrees around its center, you could write the following:</p><a id="pro_id00118"/><pre class="programlisting">➊ var canvas = $("#game_canvas").get(0);
➋ var context = canvas.getContext("2d");
➌ context.clearRect(0, 0, canvas.width, canvas.height);
➍ context.translate(150, 150);
➎ context.rotate(Math.PI/6);
➏ context.drawImage(imageObject, -50, -50);
➐ context.rotate(-Math.PI/6);
➑ context.translate(-150, -150);</pre><div class="figure"><a id="drawing_a_rotated_image_onto_the_canvas"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00022"/><img src="httpatomoreillycomsourcenostarchimages2184531.png.jpg" alt="Drawing a rotated image onto the canvas"/></div></div><p class="title">Figure 6-1. Drawing a rotated image onto the canvas</p></div><p><a id="iddle1499" class="indexterm"/><a id="iddle1504" class="indexterm"/><a id="iddle1516" class="indexterm"/><a id="iddle1527" class="indexterm"/><a id="iddle1617" class="indexterm"/><a id="iddle1618" class="indexterm"/><a id="iddle1620" class="indexterm"/><a id="iddle1623" class="indexterm"/><a id="iddle1628" class="indexterm"/><a id="iddle2382" class="indexterm"/>This code retrieves the canvas ➊ and the context ➋ and then clears the canvas so it’s ready for drawing ➌. We next translate the origin to the coordinates at which we want to draw the image ➍, but we also need to add half the image’s width and half of its height to the translation values, because we’ll be drawing the center of the image at the new origin.</p><p>The next step is to add rotation ➎, but remember that we rotate the <span class="emphasis"><em>context</em></span>, not the image. Angles are also specified in radians rather than degrees. The image is drawn at (-50,-50) ➏, which means that the center of the image is drawn at the context origin and then the context is rotated back ➐ and then translated back ➑. The last two steps are important because the context maintains state, so the next operation that’s performed on the canvas would be on the rotated coordinates. By reversing the rotation and the translation, we have left the canvas in the same state in which we found it.</p><p>If you don’t want to have to remember to rotate and translate the canvas back to its origin, you can simplify the whole process by storing the context before changing your image and resetting the context afterward:</p><a id="pro_id00119"/><pre class="programlisting">   var canvas = $("#game_canvas").get(0);
   var context = canvas.getContext("2d");
   context.clearRect(0, 0, canvas.width, canvas.height);
➊ context.save();
   context.translate(150, 150);
   context.rotate(Math.PI/6);
   context.drawImage(imageObject, -50, -50);
➋ context.restore();</pre><p><a id="iddle1466" class="indexterm"/><a id="iddle1489" class="indexterm"/><a id="iddle1496" class="indexterm"/><a id="iddle1507" class="indexterm"/><a id="iddle1520" class="indexterm"/><a id="iddle1531" class="indexterm"/><a id="iddle1668" class="indexterm"/><a id="iddle2315" class="indexterm"/><a id="iddle2416" class="indexterm"/><a id="iddle2456" class="indexterm"/><a id="iddle2572" class="indexterm"/><a id="iddle2695" class="indexterm"/>The call to <code class="literal">context.save</code> ➊ saves the current state of the context, although, importantly, it doesn’t save the pixel data inside the canvas. Then <code class="literal">context.restore</code> ➋ sets it back to this saved state.</p><p>These principles are all we need to draw whole images onto the canvas and to remove them again, but to draw bubbles, we’ll need to draw only a small section of the sprite sheet at a time.</p><div class="sidebar"><a id="canvas_width_and_height"/><p class="title">Canvas Width and Height</p><p>The canvas has its own settings for width and height, and it’s important to specify these when you create a <code class="literal">canvas</code> element. You could use CSS to determine the dimensions of the canvas as displayed on the screen, but they may not match the number of pixels that the canvas internally is set to render. In our case, we’ll make both the same, so drawing one pixel to the canvas will result in one pixel being displayed.</p><p>If we were to set the width and height of the <code class="literal">canvas</code> element to double what they are now, the DOM element would still take up the same amount of space on the page because of our CSS definition. The canvas interacts with CSS in the same way images do: the width and height are specified in the style sheet, but the canvas (or image) may be larger or smaller. The result is that the image we draw occupies only the top quarter of the canvas and appears to be a quarter of its original size. This happens because canvas pixels are scaled to screen pixels at render time. Try changing the <code class="literal">canvas</code> definition in <span class="emphasis"><em>index.html</em></span> to the following and see what happens:</p><a id="pro_id00120"/><pre class="programlisting">&lt;canvas id="game_canvas" width="2000" height="1240"&gt;&lt;/canvas&gt;</pre><p>The <code class="literal">canvas</code> element won’t appear any bigger on the screen because of the CSS rules. Instead, every pixel defined by CSS will be represented by 4 pixels on the canvas. In most desktop browsers, 1 CSS pixel is identical to 1 screen pixel, so there’s little benefit to setting the canvas dimensions to values larger than those in the CSS. However, modern devices, especially mobile ones, have become sophisticated in their rendering and have what is called a higher pixel density. This allows the device to render much-higher-resolution images. You can read more about pixel density at <span class="emphasis"><em><a class="ulink" href="http://www.html5rocks.com/en/tutorials/canvas/hidpi/">http://www.html5rocks.com/en/tutorials/canvas/hidpi/</a></em></span>.</p><p>When you’re working with the canvas and CSS together, you need to remember which scale you’re working at. If you’re working within the canvas, it’s the dimensions of the canvas, as specified by its HTML attributes, that are important. When working with CSS elements around—or possibly even on top of—the canvas, you’ll be using CSS pixel dimensions. For example, to draw an image at the bottom-right of a canvas that is 2000 pixels wide and 1240 pixels high, you would use something like this:</p><a id="pro_id00121"/><pre class="programlisting">$("#game_canvas").get(0).getContext("2d").drawImage(imageObject,2000,1240);</pre><p><a id="iddle1122" class="indexterm"/><a id="iddle1256" class="indexterm"/><a id="iddle1356" class="indexterm"/><a id="iddle1357" class="indexterm"/><a id="iddle1476" class="indexterm"/><a id="iddle1477" class="indexterm"/><a id="iddle1500" class="indexterm"/><a id="iddle1607" class="indexterm"/><a id="iddle1608" class="indexterm"/><a id="iddle2044" class="indexterm"/><a id="iddle2545" class="indexterm"/><a id="iddle2546" class="indexterm"/><a id="iddle2594" class="indexterm"/>But to place a DOM element at the bottom-right corner, you would use the coordinates (1000,620), such as in the following CSS:</p><a id="pro_id00122"/><pre class="programlisting">{
  left: 1000px;
  top: 620px;
}</pre><p>If possible, it’s generally easiest to keep your screen display canvas size (set in the CSS) and the width and height definitions for the canvas the same so the canvas renderer doesn’t have to try to scale pixels. But if you’re targeting devices with high pixel densities (such as Apple Retina displays), you can improve the quality of your graphics by experimenting with increasing the number of pixels in the canvas.</p></div></div></div><div class="sect1" title="Sprite Rendering"><div class="titlepage"><div><div><h1 class="title"><a id="sprite_rendering"/>Sprite Rendering</h1></div></div></div><p>We can’t use background images and position offsets to render bubble sprites, as we did with our DOM-based system. Instead, we need to draw the bubble sprites as images onto the canvas. Remember that the sprite image file contains all four bubble colors in both resting and popping states. For example, in the sprite image shown in <a class="xref" href="ch06.html#clip_boundary_required_to_draw_a_blue_bu" title="Figure 6-2. Clip boundary required to draw a blue bubble onto the board">Figure 6-2</a>, if we want to draw a blue bubble onto the board, we are interested in only the section of the image surrounded by the dotted line. To select only this part of the image, we’ll use the clip parameters that can be passed into the <code class="literal">drawImage</code> method of a canvas context.</p><div class="figure"><a id="clip_boundary_required_to_draw_a_blue_bu"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00023"/><img src="httpatomoreillycomsourcenostarchimages2184533.png.jpg" alt="Clip boundary required to draw a blue bubble onto the board"/></div></div><p class="title">Figure 6-2. Clip boundary required to draw a blue bubble onto the board</p></div><p>If we want to draw the bubble in the first stage of being popped, we would move the clip area to the right. This is similar to the way we display bubbles in the DOM version except that, rather than letting the boundaries of a <code class="literal">div</code> element define the clip boundaries, we’ll specify them in JavaScript.</p><p>To draw a clipped image to the canvas, add a couple more parameters to the <code class="literal">drawImage</code> method. Previously, we used <code class="literal">drawImage</code> with only three parameters (the <code class="literal">Image</code> object and <span class="emphasis"><em>x</em></span>- and <span class="emphasis"><em>y</em></span>-coordinates), but we can pass it a few more to clip the image. The full set of parameters that <code class="literal">drawImage</code> accepts are these:</p><a id="pro_id00123"/><pre class="programlisting">context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);</pre><p><a id="iddle1060" class="indexterm"/><a id="iddle1280" class="indexterm"/><a id="iddle1344" class="indexterm"/><a id="iddle1359" class="indexterm"/><a id="iddle1492" class="indexterm"/><a id="iddle1511" class="indexterm"/><a id="iddle1613" class="indexterm"/><a id="iddle1917" class="indexterm"/><a id="iddle1961" class="indexterm"/><a id="iddle1981" class="indexterm"/><a id="iddle2392" class="indexterm"/><a id="iddle2563" class="indexterm"/>The parameters are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="img"><span class="title"><strong><span class="strong"><strong><code class="literal">img</code></strong></span></strong></span>. The <code class="literal">Image</code> object.</p></li><li class="listitem"><p title="sx and sy"><span class="title"><strong><span class="strong"><strong><code class="literal">sx</code> and <code class="literal">sy</code></strong></span></strong></span>. The <span class="emphasis"><em>x</em></span>- and <span class="emphasis"><em>y</em></span>-coordinates at which to clip the image relative to the image’s origin. For a blue bubble in its nonpopping state, these values would be 0 and 50, respectively.</p></li><li class="listitem"><p title="swidth and sheight"><span class="title"><strong><span class="strong"><strong><code class="literal">swidth</code> and <code class="literal">sheight</code></strong></span></strong></span>. The width and height of the clip area. For our bubble sprite sheet, these values will both be 50.</p></li><li class="listitem"><p title="x and y"><span class="title"><strong><span class="strong"><strong><code class="literal">x</code> and <code class="literal">y</code></strong></span></strong></span>. The coordinates to draw the image on the canvas relative to the canvas context origin.</p></li><li class="listitem"><p title="width and height"><span class="title"><strong><span class="strong"><strong><code class="literal">width</code> and <code class="literal">height</code></strong></span></strong></span>. The width and height of the image to draw. We can use these parameters to scale an image, or we can omit them if we want the image to be drawn at 1:1.</p></li></ul></div><p>For example, to draw the blue bubble highlighted in <a class="xref" href="ch06.html#clip_boundary_required_to_draw_a_blue_bu" title="Figure 6-2. Clip boundary required to draw a blue bubble onto the board">Figure 6-2</a> at the coordinates (200,150) on the canvas, we would use the following:</p><a id="pro_id00124"/><pre class="programlisting">$("#canvas").get(0).getContext("2d").drawImage(spriteSheet,0,50,50,50,200,150,
50,50);</pre><p>This line of code assumes the sprite <code class="literal">Image</code> object is named <code class="literal">spriteSheet</code> and the sprite is 50 pixels wide and 50 pixels high.</p></div><div class="sect1" title="Defining and Maintaining States"><div class="titlepage"><div><div><h1 class="title"><a id="defining_and_maintaining_states"/>Defining and Maintaining States</h1></div></div></div><p>In the DOM-based version of the game code, we don’t have to think about bubble state; we just queue up events with timeouts and animate/callback chains. Once a bubble is drawn to the screen at a fixed position, we leave it as is unless we need to change it. The bubble will be drawn in the same spot until we tell the browser to do something else with it.</p><p>But when we switch to canvas rendering, we need to render each bubble, with the correct sprite, on each frame redraw. Our code must track the state of all bubbles on the screen, whether they’re moving, popping, falling, or just stationary. Each <code class="literal">bubble</code> object will track its current state and how long it’s been in that state. We need that duration for when we draw the frames of the popping animation. The <code class="literal">Board</code> object currently keeps track of bubbles in the main layout, and we need to add to it so we can also keep track of those bubbles that are popping, falling, or firing.</p><div class="sect2" title="Preparing the State Machine"><div class="titlepage"><div><div><h2 class="title"><a id="preparing_the_state_machine"/>Preparing the State Machine</h2></div></div></div><p>To maintain bubble state, we’ll first create a set of constants that refer to a bubble’s state. This is referred to as using a <span class="emphasis"><em>state machine</em></span>, which you’re likely to find increasingly useful as the complexity of your games increases. The basic principles of using a state machine, as related to this game, are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A bubble can exist in a number of states, such as moving, popping, or falling.</p></li><li class="listitem"><p><a id="iddle1288" class="indexterm"/><a id="iddle1372" class="indexterm"/><a id="iddle1408" class="indexterm"/><a id="iddle1410" class="indexterm"/><a id="iddle1418" class="indexterm"/><a id="iddle1449" class="indexterm"/><a id="iddle1713" class="indexterm"/><a id="iddle1840" class="indexterm"/><a id="iddle1844" class="indexterm"/><a id="iddle1857" class="indexterm"/><a id="iddle1871" class="indexterm"/><a id="iddle2282" class="indexterm"/><a id="iddle2336" class="indexterm"/><a id="iddle2348" class="indexterm"/>The way a bubble reacts in the game will depend on the state it’s in. For example, we don’t want the bubble being fired to collide with a bubble being popped.</p></li><li class="listitem"><p>The way a bubble is displayed may depend on its state, particularly if it’s being popped.</p></li><li class="listitem"><p>A bubble can be in only one state at a time; it can’t be popped and popping at the same time, or popping and falling simultaneously.</p></li></ul></div><p>Once we have the state machine set up, we’ll know what we need to do to a bubble in any given situation. Some changes of state occur as a result of a user’s actions, such as when they fire the bubble, but we’ll also store the timestamp when a bubble enters a state. As a result, we can determine when the bubble should be moved from one state to another automatically, such as when we’re in the process of popping it after a collision.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note01"/>Note</h3><p><span class="emphasis"><em>In general, even if you think your game will be relatively simple, it’s worth using a state machine as a way to manage complexity that you may not have thought of yet.</em></span></p></div><p>Add the following to <span class="emphasis"><em>bubble.js</em></span>:</p><p><span class="emphasis"><em>bubble.js</em></span></p><a id="pro_id00125"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Bubble = (function($){
➊  <span class="strong"><strong>BubbleShoot.BubbleState = {</strong></span>
      <span class="strong"><strong>CURRENT : 1,</strong></span>
      <span class="strong"><strong>ON_BOARD : 2,</strong></span>
      <span class="strong"><strong>FIRING : 3,</strong></span>
      <span class="strong"><strong>POPPING : 4,</strong></span>
      <span class="strong"><strong>FALLING : 5,</strong></span>
      <span class="strong"><strong>POPPED : 6,</strong></span>
      <span class="strong"><strong>FIRED : 7,</strong></span>
      <span class="strong"><strong>FALLEN : 8</strong></span>
    <span class="strong"><strong>}</strong></span>;
    var Bubble = function(row,col,type,sprite){
      var that = this;
➋    <span class="strong"><strong>var state;</strong></span>
      <span class="strong"><strong>var stateStart = Date.now();</strong></span>
      <span class="strong"><strong>this.getState = function(){ return state;};</strong></span>
➌    <span class="strong"><strong>this.setState = function(stateIn){</strong></span>
        <span class="strong"><strong>state = stateIn;</strong></span>
➍      <span class="strong"><strong>stateStart = Date.now();</strong></span>
      <span class="strong"><strong>};</strong></span>
➎    <span class="strong"><strong>this.getTimeInState = function(){</strong></span>
        <span class="strong"><strong>return Date.now() - stateStart;</strong></span>
      <span class="strong"><strong>};</strong></span>
      --<span class="emphasis"><em>snip</em></span>--
    };
    Bubble.create = function(rowNum,colNum,type){
      --<span class="emphasis"><em>snip</em></span>--
    };
    return Bubble;
  })(jQuery);</pre><p><a id="iddle1167" class="indexterm"/><a id="iddle1178" class="indexterm"/><a id="iddle1550" class="indexterm"/><a id="iddle1827" class="indexterm"/><a id="iddle1949" class="indexterm"/><a id="iddle1966" class="indexterm"/><a id="iddle2555" class="indexterm"/>These additions allow us to store and retrieve the bubble’s current state ➋, which will be one of the eight states at the top of the class ➊. Whenever we change a bubble’s state ➌, we also record the timestamp when it entered that state ➍. Once we determine how long the bubble has been in its current state ➎, we can work out what to draw. For example, the amount of time a bubble has spent in the <code class="literal">POPPING</code> state determines which frame of the popping sequence to display.</p></div><div class="sect2" title="Implementing States"><div class="titlepage"><div><div><h2 class="title"><a id="implementing_states"/>Implementing States</h2></div></div></div><p>Each bubble can have one of the following states, which we’ll need to implement:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="strong"><strong><code class="literal">CURRENT</code></strong></span></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Waiting to be fired.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="strong"><strong><code class="literal">ON_BOARD</code></strong></span></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Already part of the board display.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="strong"><strong><code class="literal">FIRING</code></strong></span></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Moving toward the board or off the screen.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="strong"><strong><code class="literal">POPPING</code></strong></span></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Being popped. This will display one of the popping animation frames.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="strong"><strong><code class="literal">FALLING</code></strong></span></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>An orphaned bubble that’s falling from the screen.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="strong"><strong><code class="literal">POPPED</code></strong></span></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Done <code class="literal">POPPING</code>. A popped bubble doesn’t need to be rendered.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="strong"><strong><code class="literal">FIRED</code></strong></span></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Missed the board display after <code class="literal">FIRING</code>. A fired bubble doesn’t need to be rendered.</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><span class="strong"><strong><code class="literal">FALLEN</code></strong></span></p></td><td style="" valign="top"><p>Done <code class="literal">FALLING</code> off the screen. A fallen bubble doesn’t need to be rendered.</p></td></tr></tbody></table></div><p>The bubbles displayed in the board at the beginning of a level start out in the <code class="literal">ON_BOARD</code> state, but all other bubbles will start in the <code class="literal">CURRENT</code> state and move into one of the other states, as shown in <a class="xref" href="ch06.html#flowchart_showing_bubble_states" title="Figure 6-3. Flowchart showing bubble states">Figure 6-3</a>.</p><p>We’ll add a couple of arrays to <code class="literal">Game</code> to keep track of those. At the top of the class, add:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00126"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Game = (function($){
    var Game = function(){
      var curBubble;
      var board;
      var numBubbles;
➊    <span class="strong"><strong>var bubbles = [];</strong></span>
      var MAX_BUBBLES = 70;
      this.init = function(){
        --<span class="emphasis"><em>snip</em></span>--
      };
      var startGame = function(){
        $(".but_start_game").unbind("click");
          numBubbles = MAX_BUBBLES
          BubbleShoot.ui.hideDialog();
          board = new BubbleShoot.Board();
➋        <span class="strong"><strong>bubbles = board.getBubbles();</strong></span>
          curBubble = getNextBubble();
        BubbleShoot.ui.drawBoard(board);
        $("#game").bind("click",clickGameScreen);
      };
      var getNextBubble = function(){
        var bubble = BubbleShoot.Bubble.create();
➌      <span class="strong"><strong>bubbles.push(bubble);</strong></span>
➍      <span class="strong"><strong>bubble.setState(BubbleShoot.BubbleState.CURRENT);</strong></span>
        bubble.getSprite().addClass("cur_bubble");
        $("#board").append(bubble.getSprite());
        BubbleShoot.ui.drawBubblesRemaining(numBubbles);
        numBubbles--;
        return bubble;
      };
      --<span class="emphasis"><em>snip</em></span>--
    };
    return Game;
  })(jQuery);</pre><p><a id="iddle1360" class="indexterm"/><a id="iddle1419" class="indexterm"/><a id="iddle1714" class="indexterm"/><a id="iddle1841" class="indexterm"/><a id="iddle1845" class="indexterm"/><a id="iddle1858" class="indexterm"/><a id="iddle1872" class="indexterm"/><a id="iddle1934" class="indexterm"/><a id="iddle1962" class="indexterm"/><a id="iddle1988" class="indexterm"/><a id="iddle2283" class="indexterm"/><a id="iddle2337" class="indexterm"/><a id="iddle2349" class="indexterm"/><a id="iddle2564" class="indexterm"/>This new array ➊ will contain all of the bubbles in the game, both on and off the board layout. Initially, every bubble is part of the board, so the board contents can be used to populate the array ➋. Each time we call <code class="literal">getNextBubble</code>, the bubble that’s ready to fire needs to be added ➌ and have its state set to <code class="literal">CURRENT</code> ➍.</p><div class="figure"><a id="flowchart_showing_bubble_states"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00024"/><img src="httpatomoreillycomsourcenostarchimages2184535.png" alt="Flowchart showing bubble states"/></div></div><p class="title">Figure 6-3. Flowchart showing bubble states</p></div><p><a id="iddle1168" class="indexterm"/><a id="iddle1172" class="indexterm"/><a id="iddle1179" class="indexterm"/><a id="iddle1649" class="indexterm"/><code class="literal">board.getBubbles</code> is a new method that will return all of the bubbles in the rows and columns of the board as a single flat array, so add it to <span class="emphasis"><em>board.js</em></span>:</p><p><span class="emphasis"><em>board.js</em></span></p><a id="pro_id00127"/><pre class="programlisting">var BubbleShoot = window.BubbleShoot || {};
BubbleShoot.Board = (function($){
  var NUM_ROWS = 9;
  var NUM_COLS = 32;
  var Board = function(){
    var that = this;
    --<span class="emphasis"><em>snip</em></span>--
    <span class="strong"><strong>this.getBubbles = function(){</strong></span>
      <span class="strong"><strong>var bubbles = [];</strong></span>
      <span class="strong"><strong>var rows = this.getRows();</strong></span>
      <span class="strong"><strong>for(var i=0;i&lt;rows.length;i++){</strong></span>
        <span class="strong"><strong>var row = rows[i];</strong></span>
        <span class="strong"><strong>for(var j=0;j&lt;row.length;j++){</strong></span>
          <span class="strong"><strong>var bubble = row[j];</strong></span>
          <span class="strong"><strong>if(bubble){</strong></span>
            <span class="strong"><strong>bubbles.push(bubble);</strong></span>
          <span class="strong"><strong>};</strong></span>
        <span class="strong"><strong>};</strong></span>
      <span class="strong"><strong>};</strong></span>
      <span class="strong"><strong>return bubbles;</strong></span>
    <span class="strong"><strong>};</strong></span>
    return this;
  };
  --<span class="emphasis"><em>snip</em></span>--
  return Board;
})(jQuery);</pre><p>We also need to set the state of bubbles that are on the board to <code class="literal">ON_BOARD</code>, so make this change to the <code class="literal">createLayout</code> function in the same file:</p><a id="pro_id00128"/><pre class="programlisting">var BubbleShoot = window.BubbleShoot || {};
BubbleShoot.Board = (function($){
  var NUM_ROWS = 9;
  var NUM_COLS = 32;
  var Board = function(){
    --<span class="emphasis"><em>snip</em></span>-
  };
  var createLayout = function(){
    var rows = [];
    for(var i=0;i&lt;NUM_ROWS;i++){
      var row = [];
      var startCol = i%2 == 0 ? 1 : 0;
      for(var j=startCol;j&lt;NUM_COLS;j+=2){
        var bubble = BubbleShoot.Bubble.create(i,j);
        <span class="strong"><strong>bubble.setState(BubbleShoot.BubbleState.ON_BOARD);</strong></span>
        row[j] = bubble;
      };
      rows.push(row);
    };
    return rows;
  };
  return Board;
})(jQuery);</pre><p><a id="iddle1938" class="indexterm"/><a id="iddle2332" class="indexterm"/><a id="iddle2624" class="indexterm"/><a id="iddle2638" class="indexterm"/><code class="literal">bubble.setState</code> handles the setup, which contains the states of <code class="literal">CURRENT</code> and <code class="literal">ON_BOARD</code>, but we also need to be able to change the state of a bubble.</p><p>The two states of <code class="literal">FIRING</code> and <code class="literal">FIRED</code> will be set inside <code class="literal">fireBubble</code> in <span class="emphasis"><em>ui.js</em></span>. Amend the function as follows:</p><p><span class="emphasis"><em>ui.js</em></span></p><a id="pro_id00129"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.ui = (function($){
    var ui = {
      --<span class="emphasis"><em>snip</em></span>--
      fireBubble : function(bubble,coords,duration){
➊      <span class="strong"><strong>bubble.setState(BubbleShoot.BubbleState.FIRING);</strong></span>
        var complete = function(){
          if(typeof(bubble.getRow()) !== undefined){
            bubble.getSprite().css(Modernizr.prefixed("transition"),"");
            bubble.getSprite().css({
              left : bubble.getCoords().left - ui.BUBBLE_DIMS/2,
              top : bubble.getCoords().top - ui.BUBBLE_DIMS/2
            });
➋          <span class="strong"><strong>bubble.setState(BubbleShoot.BubbleState.ON_BOARD);</strong></span>
          <span class="strong"><strong>}else{</strong></span>
➌          <span class="strong"><strong>bubble.setState(BubbleShoot.BubbleState.FIRED);</strong></span>
          <span class="strong"><strong>};</strong></span>
        --<span class="emphasis"><em>snip</em></span>--
      },
      --<span class="emphasis"><em>snip</em></span>--
    };
    return ui;
  } )(jQuery);</pre><p>When the bubble is initially fired, we set the state to <code class="literal">FIRING</code> ➊. If the bubble reaches the board, we set it to <code class="literal">ON_BOARD</code> ➋, but if it hasn’t settled into a row and column, that means it missed the board, in which case it becomes <code class="literal">FIRED</code> ➌.</p><p>The other states will be set in <span class="emphasis"><em>game.js</em></span>:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00130"/><pre class="programlisting">  var Game = function(){
    --<span class="emphasis"><em>snip</em></span>--
    var popBubbles = function(bubbles,delay){
      $.each(bubbles,function(){
        var bubble = this;
        setTimeout(function(){
➊        <span class="strong"><strong>bubble.setState(BubbleShoot.BubbleState.POPPING);</strong></span>
          bubble.animatePop();
➋        <span class="strong"><strong>setTimeout(function(){</strong></span>
            <span class="strong"><strong>bubble.setState(BubbleShoot.BubbleState.POPPED);</strong></span>
          <span class="strong"><strong>},200);</strong></span>
        },delay);
        board.popBubbleAt(bubble.getRow(),bubble.getCol());
        delay += 60;
      });
    };
    var dropBubbles = function(bubbles,delay){
      $.each(bubbles,function(){
        var bubble = this;
        board.popBubbleAt(bubble.getRow(),bubble.getCol());
        setTimeout(function(){
➌        <span class="strong"><strong>bubble.setState(BubbleShoot.BubbleState.FALLING);</strong></span>
          bubble.getSprite().kaboom({
            callback : function(){
              bubble.getSprite().remove();
➍            <span class="strong"><strong>bubble.setState(BubbleShoot.BubbleState.FALLEN);</strong></span>
            }
          })
        },delay);
      });
    };
  };</pre><p><a id="iddle1123" class="indexterm"/><a id="iddle1358" class="indexterm"/><a id="iddle1448" class="indexterm"/><a id="iddle1501" class="indexterm"/><a id="iddle1513" class="indexterm"/><a id="iddle1551" class="indexterm"/><a id="iddle1787" class="indexterm"/><a id="iddle1828" class="indexterm"/><a id="iddle1914" class="indexterm"/><a id="iddle1928" class="indexterm"/><a id="iddle1950" class="indexterm"/><a id="iddle1959" class="indexterm"/><a id="iddle2048" class="indexterm"/><a id="iddle2325" class="indexterm"/><a id="iddle2399" class="indexterm"/><a id="iddle2400" class="indexterm"/><a id="iddle2547" class="indexterm"/><a id="iddle2556" class="indexterm"/>In <code class="literal">popBubbles</code>, we set every bubble to <code class="literal">POPPING</code> ➊, and then after 200 milliseconds, when the popping animation has finished, we set them to <code class="literal">POPPED</code> ➋. In <code class="literal">dropBubbles</code>, we set them to <code class="literal">FALLING</code> ➌, and then when they’ve finished falling at the end of the <code class="literal">kaboom</code> process, they become <code class="literal">FALLEN</code> ➍.</p><p>Now that bubbles know which state they’re in at any point in the game, we can start to render them onto a canvas.</p></div></div><div class="sect1" title="Sprite Sheets and the Canvas"><div class="titlepage"><div><div><h1 class="title"><a id="sprite_sheets_and_the_canvas"/>Sprite Sheets and the Canvas</h1></div></div></div><p>We can use the existing sprite sheet PNG (<span class="emphasis"><em>bubble_sprite_sheet.png</em></span>) from the CSS version of the game when we draw to the canvas, although we need to work with it in a different way. Rather than shifting the sprite sheet around like a background image, we’ll draw part of the image that shows the correct bubble in the correct animation state. Our loading sequence will also change because we need to make sure that the sprite image is loaded before starting the game.</p><p>We’ll make a new object called <code class="literal">Renderer</code> to handle drawing to the canvas, and we’ll give it its own <code class="literal">init</code> method, which will preload the sprite sheet, and call that method within <code class="literal">game.init</code>.</p><p>Change the <code class="literal">init</code> method in <span class="emphasis"><em>game.js</em></span> to the following:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00131"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Game = (function($){
    var Game = function(){
      --<span class="emphasis"><em>snip</em></span>--
      this.init = function(){
➊    <span class="strong"><strong>if(BubbleShoot.Renderer){</strong></span>
➋      <span class="strong"><strong>BubbleShoot.Renderer.init(function(){</strong></span>
➌          <span class="strong"><strong>$(".but_start_game").click("click",startGame);</strong></span>
        <span class="strong"><strong>});</strong></span>
      <span class="strong"><strong>}else{</strong></span>
          $(".but_start_game").click("click",startGame);
      <span class="strong"><strong>};</strong></span>
      --<span class="emphasis"><em>snip</em></span>--
    };
    return Game;
  })(jQuery);</pre><p><a id="iddle1006" class="indexterm"/><a id="iddle1207" class="indexterm"/><a id="iddle1220" class="indexterm"/><a id="iddle1456" class="indexterm"/><a id="iddle1493" class="indexterm"/><a id="iddle1497" class="indexterm"/><a id="iddle1508" class="indexterm"/><a id="iddle1521" class="indexterm"/><a id="iddle1532" class="indexterm"/><a id="iddle1603" class="indexterm"/><a id="iddle1614" class="indexterm"/><a id="iddle1669" class="indexterm"/><a id="iddle1770" class="indexterm"/><a id="iddle1982" class="indexterm"/><a id="iddle2010" class="indexterm"/><a id="iddle2227" class="indexterm"/><a id="iddle2272" class="indexterm"/><a id="iddle2696" class="indexterm"/><a id="iddle2698" class="indexterm"/>First, we check if <code class="literal">BubbleShoot.Renderer</code> exists ➊. If the <code class="literal">Modernizr.canvas</code> test passes when we load in scripts, the object will exist; if canvas isn’t supported, the object won’t exist.</p><p>Then we call a <code class="literal">Renderer.init</code> method and pass it a function as its only parameter ➋. This is the function that attaches <code class="literal">startGame</code> to the New Game button ➌.</p><p>Now we need to write the <code class="literal">Renderer</code> object. In the blank <span class="emphasis"><em>renderer.js</em></span> file, add the following code:</p><p><span class="emphasis"><em>renderer.js</em></span></p><a id="pro_id00132"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Renderer = (function($){
➊  var canvas;
    var context;
    var Renderer = {
➋    init : function(callback){
➌      canvas = document.createElement("canvas");
        $(canvas).addClass("game_canvas");
➍      $("#game").prepend(canvas);
➎      $(canvas).attr("width",$(canvas).width());
        $(canvas).attr("height",$(canvas).height());
        context = canvas.getContext("2d");
        callback();
      }
    };
    return Renderer;
  })(jQuery);</pre><p>We first create variables to hold the canvas that we’ll use to render the game area ➊ and a reference to its rendering context, so we don’t have to call <code class="literal">canvas.getContext("2d")</code> constantly.</p><p>In the <code class="literal">init</code> method, we accept the callback function as a parameter ➋, create the <code class="literal">canvas</code> DOM element ➌, and then prepend it in the game <code class="literal">div</code> ➍. We also explicitly set the width and height attributes of the <code class="literal">canvas</code> ➎. Remember that these attributes define the number of pixels and the boundaries of the canvas internally, so for simplicity, we set them to the same dimensions as those rendered to the screen.</p><p>That will create the <code class="literal">canvas</code> element for us and prime a context ready to be drawn into. We need to set the width and height of <code class="literal">game_canvas</code>, so add the following into <span class="emphasis"><em>main.css</em></span>:</p><p><span class="emphasis"><em>main.css</em></span></p><a id="pro_id00133"/><pre class="programlisting">.game_canvas
{
  width: 1000px;
  height: 620px;
}</pre><p><a id="iddle1404" class="indexterm"/><a id="iddle1781" class="indexterm"/><a id="iddle2102" class="indexterm"/><a id="iddle2354" class="indexterm"/>The DOM-rendered version uses jQuery to move objects around the screen, but we won’t have DOM elements to manipulate inside a canvas, so there’s nothing for jQuery to work with. Hence, we’ll have to keep track of the position of every bubble on the screen with new code. Much of this will happen inside the new <span class="emphasis"><em>sprite.js</em></span> file we’ve created.</p><div class="sidebar"><a id="multiple_rendering_methods_two_approache"/><p class="title">Multiple Rendering Methods: Two Approaches</p><p>If you need to support different rendering methods, as we are here, you can take two approaches. First, you can create a class for each rendering method and provide identical sets of methods and properties so they can be used interchangeably. This is what we’re doing with <span class="emphasis"><em>Bubble Shooter</em></span>.</p><p>Second, you can create a single class for both rendering methods and then have code inside that branches depending on which rendering method is supported. The new class may act as just a wrapper for a different class for each method. For example, for <span class="emphasis"><em>Bubble Shooter</em></span>, we could create something like the following pseudocode:</p><a id="pro_id00134"/><pre class="programlisting">  BubbleShoot.SpriteWrapper = (function($){
➊  var SpriteWrapper = function(id){
      var wrappedObject;
➋    if(BubbleShoot.Renderer){
➌      wrappedObject = getSpriteObject(id);
      }else{
➍      wrappedObject = getJQueryObject(id);
      }
➎    this.position = function(){
        return wrappedObject.position();
      };
    };
    return SpriteWrapper;
  })(jQuery);</pre><p>Here, we would pass in some kind of identifier to an object constructor ➊ and then branch the code depending on how we’ll render the game ➋. We would need new functions to return either a <code class="literal">Sprite</code> ➌ or a <code class="literal">jQuery</code> ➍ object, which would be stored inside the class in <code class="literal">wrappedObject</code>.</p><p>From then on, if we wanted to find the position of the object, we would call the <code class="literal">position</code> method ➎ and know we would get correct data whether the object was being rendered in the DOM or on the canvas.</p><p>The main reason we’re not taking this approach with <span class="emphasis"><em>Bubble Shooter</em></span> is that we have only one type of sprite—the bubbles on the screen. These are represented well enough by the <code class="literal">Bubble</code> class, which acts as a wrapper anyway. However, if we were dealing with many different kinds of sprites, we might want to split the structure more explicitly.</p></div><p><a id="iddle1430" class="indexterm"/><a id="iddle2011" class="indexterm"/><a id="iddle2154" class="indexterm"/><a id="iddle2530" class="indexterm"/><a id="iddle2532" class="indexterm"/><a id="iddle2533" class="indexterm"/><a id="iddle2535" class="indexterm"/><a id="iddle2536" class="indexterm"/><a id="iddle2537" class="indexterm"/><a id="iddle2539" class="indexterm"/><a id="iddle2540" class="indexterm"/><a id="iddle2541" class="indexterm"/><a id="iddle2548" class="indexterm"/><a id="iddle2595" class="indexterm"/><a id="iddle2699" class="indexterm"/>We’ll write <span class="emphasis"><em>sprite.js</em></span> so that canvas sprites can be called with the same methods that we’re using on jQuery sprites. The main methods we’ve been calling are <code class="literal">position</code>, <code class="literal">width</code>, <code class="literal">height</code>, and <code class="literal">css</code>, and if we create implementations of these in <span class="emphasis"><em>sprite.js</em></span>, the <code class="literal">Sprite</code> class will look like a jQuery object as far as the rest of our code is concerned.</p><p>Add the following to <span class="emphasis"><em>sprite.js</em></span>:</p><p><span class="emphasis"><em>sprite.js</em></span></p><a id="pro_id00135"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Sprite = (function($){
    var Sprite = function(){
      var that = this;
➊    var left;
      var top;
➋    this.position = function(){
        return {
          left : left,
          top : top
        };
      };
➌    this.setPosition = function(args){
        if(arguments.length &gt; 1){
          return;
        };
        if(args.left !== null)
          left = args.left;
        if(args.top !== null)
          top = args.top;
      };
➍    this.css = this.setPosition;
      return this;
    };
➎  Sprite.prototype.width = function(){
      return BubbleShoot.ui.BUBBLE_DIMS;
    };
➏  Sprite.prototype.height = function(){
      return BubbleShoot.ui.BUBBLE_DIMS;
    };
➐  Sprite.prototype.removeClass = function(){};
    Sprite.prototype.addClass = function(){};
    Sprite.prototype.remove = function(){};
    Sprite.prototype.kaboom = function(){
      jQuery.fn.kaboom.apply(this);
    };
    return Sprite;
  })(jQuery);</pre><p>Here, we’ve created an object that implements many of the methods that we access for jQuery objects. We have left and top coordinates ➊ and a <code class="literal">position</code> method ➋ that returns those coordinates in the same way that a call to jQuery’s <code class="literal">position</code> method would. The <code class="literal">setPosition</code> method can set the top and left coordinates ➌ or do nothing if other values are passed.</p><p><a id="iddle1173" class="indexterm"/><a id="iddle1373" class="indexterm"/><a id="iddle1377" class="indexterm"/><a id="iddle1405" class="indexterm"/><a id="iddle1650" class="indexterm"/><a id="iddle1686" class="indexterm"/><a id="iddle2012" class="indexterm"/><a id="iddle2049" class="indexterm"/><a id="iddle2401" class="indexterm"/>In our DOM-based version of the game, we call the <code class="literal">css</code> method to set the screen coordinates of an object. <code class="literal">setPosition</code> has been constructed to accept the same arguments as the <code class="literal">css</code> method, and to spare us from having to rewrite code anywhere that the <code class="literal">css</code> method is called and using <code class="literal">setPosition</code> for the canvas version, we can create a <code class="literal">css</code> method of Sprite and alias it to <code class="literal">setPosition</code> ➍.</p><p>The <code class="literal">width</code> ➎ and <code class="literal">height</code> ➏ methods return the values defined for a bubble’s dimensions in <span class="emphasis"><em>ui.js</em></span>. Finally, we define empty methods for <code class="literal">removeClass</code>, <code class="literal">addClass</code>, and <code class="literal">remove</code>, which maintain compatibility with a lot of our existing code ➐. Anywhere these last methods are called will not affect the display but will also not throw an error.</p><p>When a bubble is created, we need to decide whether to create a jQuery object or an instance of <code class="literal">Sprite</code>, depending on whether we’re rendering using the DOM or canvas. We’ll do this inside the bubble creation process in <span class="emphasis"><em>bubble.js</em></span>:</p><p><span class="emphasis"><em>bubble.js</em></span></p><a id="pro_id00136"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Bubble = (function($){
    --<span class="emphasis"><em>snip</em></span>--
    var Bubble = function(row,col,type,sprite){
      --<span class="emphasis"><em>snip</em></span>--
    };
    Bubble.create = function(rowNum,colNum,type){
      if(!type){
        type = Math.floor(Math.random() * 4);
      };
➊    <span class="strong"><strong>if(!BubbleShoot.Renderer){</strong></span>
        var sprite = $(document.createElement("div"));
        sprite.addClass("bubble");
        sprite.addClass("bubble_" + type);
      <span class="strong"><strong>}else{</strong></span>
➋      <span class="strong"><strong>var sprite = new BubbleShoot.Sprite();</strong></span>
      <span class="strong"><strong>}</strong></span>
      var bubble = new Bubble(rowNum,colNum,type,sprite);
      return bubble;
    };
    return Bubble;
  })(jQuery);</pre><p>This code checks again that the <code class="literal">Renderer</code> object is loaded ➊ (which happens if canvas is enabled) and, if not, continues the DOM-based path. Otherwise, we make a new <code class="literal">Sprite</code> object ➋. With this in place, a call to <code class="literal">curBubble.getSprite</code> will return a valid object no matter whether we’re using jQuery with CSS or a pure canvas route.</p><p>The last part of initializing the <code class="literal">Sprite</code> objects is to make sure they have the correct onscreen coordinates. In the DOM version of the game, we set <a id="iddle1169" class="indexterm"/><a id="iddle1431" class="indexterm"/><a id="iddle1935" class="indexterm"/><a id="iddle1989" class="indexterm"/><a id="iddle2431" class="indexterm"/>these in the CSS, but with the canvas, we have to set them in JavaScript code. These will be set in the <code class="literal">createLayout</code> function in <span class="emphasis"><em>board.js</em></span>:</p><p><span class="emphasis"><em>board.js</em></span></p><a id="pro_id00137"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Board = (function($){
    var NUM_ROWS = 9;
    var NUM_COLS = 32;
    var Board = function(){
      --<span class="emphasis"><em>snip</em></span>--
      return this;
    };
    var createLayout = function(){
      var rows = [];
      for(var i=0;i&lt;NUM_ROWS;i++){
        var row = [];
        var startCol = i%2 == 0 ? 1 : 0;
        for(var j=startCol;j&lt;NUM_COLS;j+=2){
          var bubble = BubbleShoot.Bubble.create(i,j);
          bubble.setState(BubbleShoot.BubbleState.ON_BOARD);
➊        <span class="strong"><strong>if(BubbleShoot.Renderer){</strong></span>
➋          <span class="strong"><strong>var left = j * BubbleShoot.ui.BUBBLE_DIMS/2;</strong></span>
            <span class="strong"><strong>var top = i * BubbleShoot.ui.ROW_HEIGHT;</strong></span>
➌          <span class="strong"><strong>bubble.getSprite().setPosition({</strong></span>
              <span class="strong"><strong>left : left,</strong></span>
              <span class="strong"><strong>top : top</strong></span>
            <span class="strong"><strong>});</strong></span>
          <span class="strong"><strong>};</strong></span>
          row[j] = bubble;
        };
        rows.push(row);
      };
      return rows;
    };
    return Board;
  })(jQuery);</pre><p>If the renderer exists ➊, we calculate the left and top coordinates of where the bubble should be displayed ➋ and then set the sprite’s properties to those values ➌.</p><p>The current bubble also needs its position set, so this will happen inside <code class="literal">getNextBubble</code> in <span class="emphasis"><em>game.js</em></span>:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00138"/><pre class="programlisting">var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Game = (function($){
  var Game = function(){
    --<span class="emphasis"><em>snip</em></span>--
    var getNextBubble = function(){
      var bubble = BubbleShoot.Bubble.create();
      bubbles.push(bubble);
      bubble.setState(BubbleShoot.BubbleState.CURRENT);
      bubble.getSprite().addClass("cur_bubble");
      <span class="strong"><strong>var top = 470;</strong></span>
      <span class="strong"><strong>var left = ($("#board").width() - BubbleShoot.ui.BUBBLE_DIMS)/2;</strong></span>
      <span class="strong"><strong>bubble.getSprite().css({</strong></span>
        <span class="strong"><strong>top : top,</strong></span>
        <span class="strong"><strong>left : left</strong></span>
      <span class="strong"><strong>});</strong></span>
      $("#board").append(bubble.getSprite());
      BubbleShoot.ui.drawBubblesRemaining(numBubbles);
      numBubbles--;
      return bubble;
    };
    --<span class="emphasis"><em>snip</em></span>-
  };
  return Game;
})(jQuery);</pre><p><a id="iddle1150" class="indexterm"/><a id="iddle1474" class="indexterm"/><a id="iddle1484" class="indexterm"/><a id="iddle1512" class="indexterm"/><a id="iddle1727" class="indexterm"/><a id="iddle1895" class="indexterm"/><a id="iddle2393" class="indexterm"/><a id="iddle2488" class="indexterm"/><a id="iddle2700" class="indexterm"/>We now have all bubble positions tracked and know their state at all times. We can also manipulate a sprite representation, but nothing will appear on the screen just yet. In the next section, we’ll render our sprites to the canvas.</p></div><div class="sect1" title="The Canvas Renderer"><div class="titlepage"><div><div><h1 class="title"><a id="canvas_renderer"/>The Canvas Renderer</h1></div></div></div><p>To animate anything on the canvas, we need to clear pixels before each redraw. To render the game, we’ll use <code class="literal">setTimeout</code> with a timer to redraw the position and state of every bubble on a frame-by-frame basis. This process will be the same for just about any game you build and, certainly, for anything where the display is constantly being updated. In theory, we only need to redraw the canvas when information on the screen has changed; in practice, working out when there’s new information to show can be difficult. Fortunately, canvas rendering is so fast that there’s generally no reason not to just update the display as often as possible.</p><p>We’ll store the value of the timeout ID returned by <code class="literal">setTimeout</code> so we know whether or not the frame counter is running. This will happen at the top of <span class="emphasis"><em>game.js</em></span> in a new variable called <code class="literal">requestAnimationID</code>, where we’ll also store a timestamp for when the last animation occurred:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00139"/><pre class="programlisting">var BubbleShoot = window.BubbleShoot || {};
    var Game = function(){
      var curBubble;
      var board;
      var numBubbles;
      var bubbles = [];
      var MAX_BUBBLES = 70;
➊    <span class="strong"><strong>var requestAnimationID;</strong></span>
      this.init = function(){
      };
      --<span class="emphasis"><em>snip</em></span>--
        var startGame = function(){
        $(".but_start_game").unbind("click");
        $("#board .bubble").remove();
        numBubbles = MAX_BUBBLES;
        BubbleShoot.ui.hideDialog();
        board = new BubbleShoot.Board();
        bubbles = board.getBubbles();
➋      <span class="strong"><strong>if(BubbleShoot.Renderer)</strong></span>
        <span class="strong"><strong>{</strong></span>
          <span class="strong"><strong>if(!requestAnimationID)</strong></span>
➌          <span class="strong"><strong>requestAnimationID = setTimeout(renderFrame,40);</strong></span>
        <span class="strong"><strong>}else{</strong></span>
          BubbleShoot.ui.drawBoard(board);
        <span class="strong"><strong>};</strong></span>
        curBubble = getNextBubble(board);
        $("#game").bind("click",clickGameScreen);
      };
    };
    return Game;
  })(jQuery);</pre><p><a id="iddle1007" class="indexterm"/><a id="iddle1278" class="indexterm"/><a id="iddle1941" class="indexterm"/><a id="iddle1951" class="indexterm"/><a id="iddle2402" class="indexterm"/><a id="iddle2407" class="indexterm"/><a id="iddle2557" class="indexterm"/>We add the two variables ➊, and if the <code class="literal">Renderer</code> object exists ➋, we start the timeout running to draw the first animation frame ➌.</p><p>We haven’t written <code class="literal">renderFrame</code> yet, but before we do, we’ll write a method in <span class="emphasis"><em>renderer.js</em></span> to draw all of the bubbles. The method will accept an array of <code class="literal">bubble</code> objects as an input.</p><p>First we need to load the bubble images into <span class="emphasis"><em>renderer.js</em></span>:</p><p><span class="emphasis"><em>renderer.js</em></span></p><a id="pro_id00140"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Renderer = (function($){ var canvas;
    var context;
➊  <span class="strong"><strong>var spriteSheet;</strong></span>
➋  <span class="strong"><strong>var BUBBLE_IMAGE_DIM = 50;</strong></span>
    var Renderer = {
      init : function(callback){
        canvas = document.createElement("canvas");
        $(canvas).addClass("game_canvas");
        $("#game").prepend(canvas);
        $(canvas).attr("width",$(canvas).width());
        $(canvas).attr("height",$(canvas).height());
        context = canvas.getContext("2d");
        <span class="strong"><strong>spriteSheet = new Image();</strong></span>
➌      <span class="strong"><strong>spriteSheet.src = "_img/bubble_sprite_sheet.png";</strong></span>
➍      <span class="strong"><strong>spriteSheet.onload = function() {</strong></span>
          callback();
        <span class="strong"><strong>};</strong></span>
      }
    };
    return Renderer;
  })(jQuery);</pre><p><a id="iddle1096" class="indexterm"/><a id="iddle1249" class="indexterm"/><a id="iddle1318" class="indexterm"/><a id="iddle1337" class="indexterm"/><a id="iddle1367" class="indexterm"/><a id="iddle1406" class="indexterm"/><a id="iddle1414" class="indexterm"/><a id="iddle1475" class="indexterm"/><a id="iddle1610" class="indexterm"/><a id="iddle1626" class="indexterm"/><a id="iddle2013" class="indexterm"/><a id="iddle2345" class="indexterm"/><a id="iddle2355" class="indexterm"/><a id="iddle2397" class="indexterm"/><a id="iddle2701" class="indexterm"/>We create a variable to hold the image data ➊ and define another variable for the width and height of each bubble image ➋. The dimensions will tell us where to crop each image within the sprite sheet. We then load in the image file ➌, and the callback function that’s passed into <code class="literal">init</code> is triggered after the image has loaded ➍.</p><p>Next we’ll create the function to draw the sprites onto the canvas.</p><p><span class="emphasis"><em>renderer.js</em></span></p><a id="pro_id00141"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Renderer = (function($){
    --<span class="emphasis"><em>snip</em></span>--
    var Renderer = {
      init : function(callback){
        --<span class="emphasis"><em>snip</em></span>--
      },
➊    <span class="strong"><strong>render : function(bubbles){</strong></span>
        <span class="strong"><strong>context.clearRect(0,0,canvas.width,canvas.height);</strong></span>
        <span class="strong"><strong>context.translate(120,0);</strong></span>
➋      <span class="strong"><strong>$.each(bubbles,function(){</strong></span>
          <span class="strong"><strong>var bubble = this;</strong></span>
➌        <span class="strong"><strong>var clip = {</strong></span>
            <span class="strong"><strong>top : bubble.getType() * BUBBLE_IMAGE_DIM,</strong></span>
            <span class="strong"><strong>left : 0</strong></span>
          <span class="strong"><strong>};</strong></span>
➍        <span class="strong"><strong>Renderer.drawSprite(bubble.getSprite(),clip);</strong></span>
        <span class="strong"><strong>});</strong></span>
        <span class="strong"><strong>context.translate(-120,0);</strong></span>
      <span class="strong"><strong>},</strong></span>
      <span class="strong"><strong>drawSprite : function(sprite,clip){</strong></span>
➎      <span class="strong"><strong>context.translate(sprite.position().left + sprite.width()/2,sprite.</strong></span>
          <span class="strong"><strong>position().top + sprite.height()/2);</strong></span>
➏      <span class="strong"><strong>context.drawImage(spriteSheet,clip.left,clip.top,BUBBLE_IMAGE_DIM,</strong></span>
          <span class="strong"><strong>BUBBLE_IMAGE_DIM,-sprite.width()/2,-sprite.height()/2,BUBBLE_IMAGE_</strong></span>
          <span class="strong"><strong>DIM,BUBBLE_IMAGE_DIM);</strong></span>
➐      <span class="strong"><strong>context.translate(-sprite.position().left - sprite.width()/2,</strong></span>
          <span class="strong"><strong>-sprite.position().top - sprite.height()/2);</strong></span>
      <span class="strong"><strong>}</strong></span>
    };
    return Renderer;
  })(jQuery);</pre><p>First, we create a render method that accepts an array of <code class="literal">Bubble</code> objects ➊. We then clear the canvas and offset the context by 120 pixels so the board display is drawn in the center of the screen. The code then loops over each bubble in the array ➋ and defines an (<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em>y</em></span>) coordinate from which to extract the bubble’s sprite from the image ➌. The <span class="emphasis"><em>x</em></span>-coordinate always starts at zero until we add frames for the popping animation, and the <span class="emphasis"><em>y</em></span>-coordinate is the bubble type (0 to 3) multiplied by the height of a bubble image (50 pixels). We pass this information along with the bubble’s <code class="literal">Sprite</code> object to another new method called <code class="literal">drawSprite</code> ➍ before resetting the context position.</p><p><a id="iddle1040" class="indexterm"/><a id="iddle1050" class="indexterm"/><a id="iddle1066" class="indexterm"/><a id="iddle1208" class="indexterm"/><a id="iddle1241" class="indexterm"/><a id="iddle1469" class="indexterm"/><a id="iddle1502" class="indexterm"/><a id="iddle1517" class="indexterm"/><a id="iddle1528" class="indexterm"/><a id="iddle1622" class="indexterm"/><a id="iddle1629" class="indexterm"/><a id="iddle1794" class="indexterm"/><a id="iddle2404" class="indexterm"/><a id="iddle2489" class="indexterm"/>Inside <code class="literal">drawSprite</code>, we translate the context ➎ by the coordinates of the sprite, remembering to offset the (top,left) coordinates by half of (width,height) to get the center of the image, and then draw the image ➏. In general, it’s best to translate the canvas context so its origin is at the center of any image being drawn, because the <code class="literal">rotate</code> method of the context performs rotations around the context origin. This means that if we want to rotate an image around its center, we already have the context set up correctly to do so.</p><p>Finally, after calling <code class="literal">drawImage</code>, we translate the context back to the origin ➐. To see the board being rendered to the canvas, we just need to put <code class="literal">renderFrame</code> into <span class="emphasis"><em>game.js</em></span>:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00142"/><pre class="programlisting">var BubbleShoot = window.BubbleShoot || {};
  var Game = function(){
    --<span class="emphasis"><em>snip</em></span>--
    <span class="strong"><strong>var renderFrame = function(){</strong></span>
      <span class="strong"><strong>BubbleShoot.Renderer.render(bubbles);</strong></span>
      <span class="strong"><strong>requestAnimationID = setTimeout(renderFrame,40);</strong></span>
    <span class="strong"><strong>};</strong></span>
  };
  return Game;
})(jQuery);</pre><p>Reload the page in your browser to start the game again. After clicking New Game, you should see the board render in its initial state. However, firing a bubble produces no animation, and neither does popping, falling, or anything else. In the next section, we’ll get bubble firing working again and also animate the bubble popping. If you open the game in a browser that doesn’t support canvas, then the game will still work as before because we have left the DOM version intact. Next, we’ll add animation to the canvas version.</p></div><div class="sect1" title="Moving Sprites on the Canvas"><div class="titlepage"><div><div><h1 class="title"><a id="moving_sprites_on_the_canvas"/>Moving Sprites on the Canvas</h1></div></div></div><p>With the CSS version of the game, we used jQuery to move objects around on the screen with one call to the <code class="literal">animate</code> method. For canvas animation, we need to calculate and update movements manually.</p><p>The process of animating on the canvas is the same as jQuery’s internal processes, and we’ll give <code class="literal">Sprite</code> an <code class="literal">animate</code> method so we can continue to use our existing code. The <code class="literal">animate</code> method will do the following:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Accept destination coordinates for a bubble and the duration of the movement.</p></li><li class="listitem"><p>Move the object a small distance toward those coordinates by a value proportional to the time elapsed since the last frame.</p></li><li class="listitem"><p>Repeat step 2 until the bubble reaches its destination.</p></li></ol></div><p><a id="iddle1033" class="indexterm"/><a id="iddle1593" class="indexterm"/><a id="iddle1799" class="indexterm"/><a id="iddle2116" class="indexterm"/><a id="iddle2155" class="indexterm"/><a id="iddle2356" class="indexterm"/><a id="iddle2531" class="indexterm"/><a id="iddle2534" class="indexterm"/><a id="iddle2538" class="indexterm"/><a id="iddle2596" class="indexterm"/>This process is identical to the one that happens when we use jQuery’s <code class="literal">animate</code> method and is one you’ll use just about any time you want to move an object around the screen.</p><p>The <code class="literal">renderFrame</code> method, which is already called during each frame, will run the entire animation process. After the bubble sprites calculate their own coordinates, <code class="literal">renderFrame</code> will trigger the drawing process. We’ll add an <code class="literal">animate</code> method to the <code class="literal">Sprite</code> object so our existing game logic will work without us having to rewrite our code. Remember that when we call <code class="literal">animate</code> in <span class="emphasis"><em>ui.js</em></span>, we pass in two parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>An object specifying <code class="literal">left</code> and <code class="literal">top</code> position coordinates</p></li><li class="listitem"><p>An object specifying <code class="literal">duration</code>, <code class="literal">callback</code> function, and <code class="literal">easing</code></p></li></ul></div><p>By constructing the <code class="literal">animate</code> method of <code class="literal">Sprite</code> to take the same parameters, we can avoid making any changes to the call in <span class="emphasis"><em>ui.js</em></span>. Add the following to <span class="emphasis"><em>sprite.js</em></span>:</p><p><span class="emphasis"><em>sprite.js</em></span></p><a id="pro_id00143"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Sprite = (function($){
    var Sprite = function(){
      --<span class="emphasis"><em>snip</em></span>--
      this.css = function(args){
        --<span class="emphasis"><em>snip</em></span>--
      };
➊    <span class="strong"><strong>this.animate = function(destination,config){</strong></span>
➋      <span class="strong"><strong>var duration = config.duration;</strong></span>
➌      <span class="strong"><strong>var animationStart = Date.now();</strong></span>
➍      <span class="strong"><strong>var startPosition = that.position();</strong></span>
➎      <span class="strong"><strong>that.updateFrame = function(){</strong></span>
          <span class="strong"><strong>var elapsed = Date.now() - animationStart;</strong></span>
          <span class="strong"><strong>var proportion = elapsed/duration;</strong></span>
          <span class="strong"><strong>if(proportion &gt; 1)</strong></span>
            <span class="strong"><strong>proportion = 1;</strong></span>
➏        <span class="strong"><strong>var posLeft = startPosition.left + (destination.left - startPosition.</strong></span>
            <span class="strong"><strong>left) * proportion;</strong></span>
          <span class="strong"><strong>var posTop = startPosition.top + (destination.top - startPosition.top)</strong></span>
            <span class="strong"><strong>* proportion;</strong></span>
➐        <span class="strong"><strong>that.css({</strong></span>
            <span class="strong"><strong>left : posLeft,</strong></span>
            <span class="strong"><strong>top : posTop</strong></span>
          <span class="strong"><strong>});</strong></span>
        <span class="strong"><strong>};</strong></span>
➑      <span class="strong"><strong>setTimeout(function(){</strong></span>
➒        <span class="strong"><strong>that.updateFrame = null;</strong></span>
➓        <span class="strong"><strong>if(config.complete)</strong></span>
            <span class="strong"><strong>config.complete();</strong></span>
        <span class="strong"><strong>},duration);</strong></span>
      <span class="strong"><strong>};</strong></span>
      return this;
    };
    --<span class="emphasis"><em>snip</em></span>--
    return Sprite;
  })(jQuery);</pre><p><a id="iddle1350" class="indexterm"/><a id="iddle1407" class="indexterm"/><a id="iddle2405" class="indexterm"/>The <code class="literal">destination</code> parameter passed into <code class="literal">animate</code> ➊ represents the sprite’s destination coordinates, which are contained in an object that looks like this:</p><a id="pro_id00144"/><pre class="programlisting">{top: 100,left: 100}</pre><p>We also pass a configuration object, which will have a <code class="literal">duration</code> property ➋, plus an optional post-animation callback function to run when the animation is over.</p><p>Next, we set a start time for the animation ➌ and store the starting position ➍. These will both be used to calculate a bubble’s position at any time.</p><p>We dynamically add the <code class="literal">updateFrame</code> method onto the <code class="literal">Sprite</code> object ➎ so we can call it each frame to recalculate a bubble’s position. Inside <code class="literal">updateFrame</code>, we calculate how much of the animation is completed. In case the last timeout is called after the animation has completed, we ensure that the proportion is never greater than 1 so that a bubble never moves past its target destination. The new coordinates are calculated ➏ with the following equations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>current <span class="emphasis"><em>x</em></span> = start <span class="emphasis"><em>x</em></span> + (final <span class="emphasis"><em>x</em></span> – start <span class="emphasis"><em>x</em></span>) × proportion elapsed</p></li><li class="listitem"><p>current <span class="emphasis"><em>y</em></span> = start <span class="emphasis"><em>y</em></span> + (final <span class="emphasis"><em>y</em></span> – start <span class="emphasis"><em>y</em></span>) × proportion elapsed</p></li></ul></div><p>Once we have the new top and left coordinates, the position of the sprite is updated with a call to its <code class="literal">css</code> method ➐. We don’t need <code class="literal">updateFrame</code> to run when the object has finished moving, so a timeout call is set ➑ to remove the method after <code class="literal">duration</code> ➒ passes, which is when the animation will be complete. This also calls any post-animation function that was passed in as the <code class="literal">callback</code> property of the <code class="literal">config</code> variable ➓.</p><p>Now that we can calculate a bubble’s new coordinates, add a call to <code class="literal">updateFrame</code> in <span class="emphasis"><em>game.js</em></span>:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00145"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
    var Game = function(){
      --<span class="emphasis"><em>snip</em></span>--
      var renderFrame = function(){
➊      <span class="strong"><strong>$.each(bubbles,function(){</strong></span>
➋        <span class="strong"><strong>if(this.getSprite().updateFrame)</strong></span>
➌          <span class="strong"><strong>this.getSprite().updateFrame();</strong></span>
        <span class="strong"><strong>});</strong></span>
        BubbleShoot.Renderer.render(bubbles);
        requestAnimationID = setTimeout(renderFrame,40);
      };
    };
    return Game;
  })(jQuery);</pre><p>Each time <code class="literal">renderFrame</code> is called on a bubble ➊, if the method <code class="literal">updateFrame</code> is defined ➋, we call that method ➌.</p><p><a id="iddle1097" class="indexterm"/><a id="iddle1209" class="indexterm"/><a id="iddle1214" class="indexterm"/><a id="iddle1250" class="indexterm"/><a id="iddle1338" class="indexterm"/><a id="iddle1473" class="indexterm"/><a id="iddle1709" class="indexterm"/><a id="iddle2346" class="indexterm"/><a id="iddle2403" class="indexterm"/><a id="iddle2526" class="indexterm"/><a id="iddle2625" class="indexterm"/><a id="iddle2639" class="indexterm"/>We also need to call <code class="literal">animate</code> in <code class="literal">fireBubble</code> in <span class="emphasis"><em>ui.js</em></span> by checking for the existence of <code class="literal">BubbleShoot.Renderer</code> again. We know that <code class="literal">BubbleShoot.Renderer</code> will exist only if canvas is supported, and we want to use the canvas for rendering if that is the case. The outcome is that CSS transitions will animate the bubbles only if CSS transitions are supported <span class="emphasis"><em>and</em></span> canvas rendering isn’t supported.</p><p><span class="emphasis"><em>ui.js</em></span></p><a id="pro_id00146"/><pre class="programlisting">var BubbleShoot = window.BubbleShoot || {};
BubbleShoot.ui = (function($){
  var ui = {
    --<span class="emphasis"><em>snip</em></span>--
    fireBubble : function(bubble,coords,duration){
      --<span class="emphasis"><em>snip</em></span>--
      if(Modernizr.csstransitions <span class="strong"><strong>&amp;&amp; !BubbleShoot.Renderer</strong></span>){
        --<span class="emphasis"><em>snip</em></span>--
      }else{
        --<span class="emphasis"><em>snip</em></span>--
      }
    },
    --<span class="emphasis"><em>snip</em></span>--
  };
  return ui;
} )(jQuery);</pre><p>Reload the game and fire away! You should now have a working game again, but this time all the images are rendered onto the canvas. But now there’s no popping animation because we’re not handling changes in bubble state in the display. The game state is internally correct, but the screen isn’t entirely in sync because we never see a bubble popping. Rendering the bubbles in their correct state is the focus of the next section.</p></div><div class="sect1" title="Animating Canvas Sprite Frames"><div class="titlepage"><div><div><h1 class="title"><a id="animating_canvas_sprite_frames"/>Animating Canvas Sprite Frames</h1></div></div></div><p>Currently, every bubble is rendered in the same visual state regardless of whether it’s sitting in the board, popping, newly fired, and so on. Bubbles remain on the screen after they’ve been popped, and we’re missing out on the popping animation! This happens because bubbles are never deleted from the <code class="literal">bubbles</code> array in <code class="literal">Game</code>, so they’re rendered even after they’ve been deleted from the <code class="literal">Board</code> object.</p><p>We already know which state a bubble is in, and we have the sprite sheet image loaded into memory to access all of the animation states. Drawing the correct state involves making sure that the <code class="literal">drawSprite</code> method of <code class="literal">Renderer</code> is either called with the correct state for a visible bubble or skipped entirely for any bubbles that have been popped or dropped off the screen. The changes in a bubble’s appearance that we need to implement are listed by state in <a class="xref" href="ch06.html#visual_changes_based_on_bubble_state" title="Table 6-1. Visual Changes Based on Bubble State">Table 6-1</a>.</p><div class="table"><a id="visual_changes_based_on_bubble_state"/><p class="title">Table 6-1. Visual Changes Based on Bubble State</p><div class="table-contents"><table summary="Visual Changes Based on Bubble State" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><a id="iddle1361" class="indexterm"/><a id="iddle1362" class="indexterm"/><a id="iddle1409" class="indexterm"/><a id="iddle1411" class="indexterm"/><a id="iddle1450" class="indexterm"/><a id="iddle1715" class="indexterm"/><a id="iddle1716" class="indexterm"/><a id="iddle1842" class="indexterm"/><a id="iddle1843" class="indexterm"/><a id="iddle1846" class="indexterm"/><a id="iddle1847" class="indexterm"/><a id="iddle1859" class="indexterm"/><a id="iddle1860" class="indexterm"/><a id="iddle1873" class="indexterm"/><a id="iddle1874" class="indexterm"/><a id="iddle2284" class="indexterm"/><a id="iddle2285" class="indexterm"/><a id="iddle2338" class="indexterm"/><a id="iddle2339" class="indexterm"/><a id="iddle2350" class="indexterm"/><a id="iddle2351" class="indexterm"/><a id="iddle2406" class="indexterm"/>Bubble’s state in code</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>Visual displayed to the player</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">CURRENT_BUBBLE</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>No change</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">ON_BOARD</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>No change</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">FIRING</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>No change</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">POPPING</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Render one of four bubble frames, depending on how long the bubble has been <code class="literal">POPPING</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">FALLING</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>No change</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">POPPED</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Skip rendering</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">FALLEN</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Skip rendering</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">FIRED</code></p></td><td style="" valign="top"><p>Skip rendering</p></td></tr></tbody></table></div></div><p>Those changes will happen inside <code class="literal">Renderer.render</code>. We’ll loop over the entire bubble array and either skip the rendering stage or adjust the coordinates to clip the sprite sheet for the correct stage in the popping animation. Make the following change to <span class="emphasis"><em>renderer.js</em></span>:</p><p><span class="emphasis"><em>renderer.js</em></span></p><a id="pro_id00147"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Renderer = (function($){
    --<span class="emphasis"><em>snip</em></span>--
    var Renderer = {
      init : function(callback){
        --<span class="emphasis"><em>snip</em></span>--
      },
      render : function(bubbles){
        bubbles.each(function(){
          var bubble = this;
          var clip = {
            top : bubble.getType() * BUBBLE_IMAGE_DIM,
            left : 0
          };
➊        <span class="strong"><strong>switch(bubble.getState()){</strong></span>
            <span class="strong"><strong>case BubbleShoot.BubbleState.POPPING:</strong></span>
➋            <span class="strong"><strong>var timeInState = bubble.getTimeInState();</strong></span>
➌            <span class="strong"><strong>if(timeInState &lt; 80){</strong></span>
                <span class="strong"><strong>clip.left = BUBBLE_IMAGE_DIM;</strong></span>
➍            <span class="strong"><strong>}else if(timeInState &lt; 140){</strong></span>
                <span class="strong"><strong>clip.left = BUBBLE_IMAGE_DIM*2;</strong></span>
➎            <span class="strong"><strong>}else{</strong></span>
                <span class="strong"><strong>clip.left = BUBBLE_IMAGE_DIM*3;</strong></span>
              <span class="strong"><strong>};</strong></span>
              <span class="strong"><strong>break;</strong></span>
➏          <span class="strong"><strong>case BubbleShoot.BubbleState.POPPED:</strong></span>
              <span class="strong"><strong>return;</strong></span>
➐          <span class="strong"><strong>case BubbleShoot.BubbleState.FIRED:</strong></span>
              <span class="strong"><strong>return;</strong></span>
➑          <span class="strong"><strong>case BubbleShoot.BubbleState.FALLEN:</strong></span>
              <span class="strong"><strong>return;</strong></span>
          <span class="strong"><strong>}</strong></span>
  ➒        Renderer.drawSprite(bubble.getSprite(),clip);
        });
      },
      drawSprite : function(sprite,clip){
        --<span class="emphasis"><em>snip</em></span>--
      }
    };
    return Renderer;
  })(jQuery);</pre><p><a id="iddle1210" class="indexterm"/><a id="iddle1215" class="indexterm"/><a id="iddle2398" class="indexterm"/>First, we want to see which state the bubble is in ➊. To do this, we’ll use a <code class="literal">switch</code> statement. State machines are often written using <code class="literal">switch</code>/<code class="literal">case</code> statements rather than multiple <code class="literal">if</code>/<code class="literal">else</code> statements. Using this structure not only makes it easier to add any future states but also provides a clue to others reading the code in the future that they’re looking at a state machine.</p><p>If the bubble is popping, we want to know how long it’s been in that state ➋. That time determines which animation frame to fetch. We use the unpopped state for the first 80 milliseconds ➌, the first frame for the next 60 milliseconds ➍, and the final popping frame from that point until the <code class="literal">POPPING</code> state is cleared ➎.</p><p>If the bubble is in the <code class="literal">POPPED</code> ➏, <code class="literal">FIRED</code> ➐, or <code class="literal">FALLEN</code> ➑ states, we return and skip rendering altogether. Otherwise, we call <code class="literal">drawSprite</code> as before ➒.</p><p>Now if you reload the game, it should completely work again. Without making drastic changes, we’ve refactored our entire game area to use either canvas- or DOM-based rendering, depending on browser compatibility. The browser you use to load the game and the features that browser supports will determine how <span class="emphasis"><em>Bubble Shooter</em></span> is presented to you:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If your browser supports the <code class="literal">canvas</code> element, you’ll see that version.</p></li><li class="listitem"><p>If your browser supports CSS transitions but <span class="emphasis"><em>not</em></span> the <code class="literal">canvas</code> element, you’ll see the CSS transition version.</p></li><li class="listitem"><p>If neither of the above is supported, you’ll see the DOM version animated with jQuery.</p></li></ul></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00011"/>Summary</h1></div></div></div><p>That covers most of the core of drawing the graphics elements of an HTML5 game, whether you’re using HTML and CSS or an entirely canvas-based approach. But that doesn’t mean we’ve finished the game! We have no sound, only one level of play exists, and a scoring system would be nice. In the next chapter, we’ll implement these elements and explore a few more features of HTML5, including local storage for saving game state, <code class="literal">requestAnimationFrame</code> for smoother animations, and how to make sound work reliably.</p></div><div class="sect1" title="Further Practice"><div class="titlepage"><div><div><h1 class="title"><a id="further_practice-id00012"/>Further Practice</h1></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>When bubbles pop, the animation plays identically for every bubble. Experiment with changing the timing so that some bubbles play the animation faster and some slower. Also, try adding some rotation to the bubbles as they’re drawn onto the canvas. This should give the popping animation a much richer feel for very little effort.</p></li><li class="listitem"><p>When orphaned bubbles fall, they remain as the default sprite. Change <span class="emphasis"><em>renderer.js</em></span> so that bubbles pop as they’re falling.</p></li></ol></div></div></div></body></html>