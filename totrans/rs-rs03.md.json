["```\nfn frobnicate1(s: String) -> String\nfn frobnicate2(s: &str) -> Cow<'_, str>\nfn frobnicate3(s: impl AsRef<str>) -> impl AsRef<str>\n```", "```\n1 struct Grounded;\nstruct Launched;\n// and so on\nstruct Rocket<Stage = Grounded> {\n  2 stage: std::marker::PhantomData<Stage>,\n}\n\n3 impl Default for Rocket<Grounded> {}\nimpl Rocket<Grounded> {\n  pub fn launch(self) -> Rocket<Launched> { }\n}\n4 impl Rocket<Launched> {\n  pub fn accelerate(&mut self) { }\n  pub fn decelerate(&mut self) { }\n}\n\n5 impl<Stage> Rocket<Stage> {\n  pub fn color(&self) -> Color { }\n  pub fn weight(&self) -> Kilograms { }\n}\n```", "```\n// in your interface\npub struct Unit;\n// in user code\nlet u = lib::Unit;\n```", "```\n// in your interface\npub struct Unit { pub field: bool };\n// in user code\nfn is_true(u: lib::Unit) -> bool {\n    matches!(u, Unit { field: true })\n}\n```", "```\n// crate1 1.0\npub struct Unit;\nput trait Foo1 { fn foo(&self) }\n// note that Foo1 is not implemented for Unit\n\n// crate2; depends on crate1 1.0\nuse crate1::{Unit, Foo1};\ntrait Foo2 { fn foo(&self) }\nimpl Foo2 for Unit { .. }\nfn main() {\n  Unit.foo();\n}\n```", "```\npub trait CanUseCannotImplement: sealed::Sealed 1 { .. }\nmod sealed {\n  pub trait Sealed {}\n  2 impl<T> Sealed for T where T: TraitBounds {}\n}\nimpl<T> CanUseCannotImplement for T where T: TraitBounds {}\n```", "```\n// your crate: bestiter\npub fn iter<T>() -> itercrate::Empty<T> { .. }\n// their crate\nstruct EmptyIterator { it: itercrate::Empty<()> }\nEmptyIterator { it: bestiter::iter() }\n```", "```\nfn is_normal<T: Sized + Send + Sync + Unpin>() {}\n#[test]\nfn normal_types() {\n  is_normal::<MyType>();\n}\n```"]