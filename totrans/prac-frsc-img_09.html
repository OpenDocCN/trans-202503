<html><head></head><body>
<h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_229"/><span class="big"><strong>8</strong></span><br/><strong>SPECIAL IMAGE ACCESS TOPICS</strong></h2>&#13;
<div class="imagef"><img src="../images/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent">This chapter demonstrates techniques for getting information about disk image files and making them accessible as block devices and as mounted directories. You’ll learn to set up loop devices and create logical devices with device mapper tools. You’ll also explore methods to map or convert software-encrypted disk images, making them accessible by forensic tools. These methods are useful in situations in which the contents of an image cannot be accessed directly and a layer of active translation or decryption is needed. Examples of such images include encrypted filesystems, virtual machine (VM) images, and other image file formats that forensic tools do not directly support.</p>&#13;
<p class="indent">Each section also includes examples of safely mounting (read-only) image files as regular filesystems on the forensic acquisition host. Then you can easily browse and access the filesystem using common programs, such as file managers, office suites, file viewers, media players, and so on.</p>&#13;
<h3 class="h3" id="ch08lev1sec01"><span epub:type="pagebreak" id="page_230"/><strong>Forensically Acquired Image Files</strong></h3>&#13;
<p class="noindent">The basis for many of the methods and examples you’ll see in this section is the Linux loop device (not to be confused with a loopback device, which is a network interface). A <em>loop device</em> is a pseudo device that can be associated with a regular file, making the file accessible as a block device in <em>/dev</em>.</p>&#13;
<p class="indent">Linux systems typically create eight loop devices by default, which might not be enough for a forensic acquisition host, but you can increase that number, either manually or automatically, on boot up. To create 32 loop devices during boot up, add <code>max_loop=32</code> to the <code>GRUB_CMDLINE_LINUX_DEFAULT=</code> line in the <em>/etc/default/grub</em> file; after reboot, 32 unused loop devices should be available. The sfsimage script uses loop devices to mount SquashFS forensic evidence containers.</p>&#13;
<p class="indent">This chapter will cover different VM images from common VM systems from QEMU, VirtualBox, VMWare, and Microsoft Virtual PC. I also describe access to OS-encrypted filesystems, including Microsoft’s BitLocker, Apple’s FileVault, Linux LUKS, and VeraCrypt (a fork of TrueCrypt). But let’s begin the with the simplest form of image: a raw disk image acquired using a dd-style acquisition tool.</p>&#13;
<h4 class="h4" id="ch08lev2sec01"><em><strong>Raw Image Files with Loop Devices</strong></em></h4>&#13;
<p class="noindenta">The simplest demonstration of a loop device can be shown using a raw image file (possibly acquired from a simple <code>dd</code> command). The <code>losetup</code> command attaches and detaches loop devices from a Linux system. This example creates a block device for an <em>image.raw</em> file:</p>&#13;
<pre># <strong>losetup --read-only --find --show image.raw</strong><br/>/dev/loop0</pre>&#13;
<p class="indent">Here, the flags specify that the loop should be read-only (<code>--read-only</code>) and the next available loop device should be used (<code>--find</code>) and displayed on completion (<code>--show</code>). The filename specified (<em>image.raw</em>) will then become available as an attached block device.</p>&#13;
<p class="indent">Running the <code>losetup</code> command without parameters displays the status of all configured loop devices. Here we can see the one just created:</p>&#13;
<pre># <strong>losetup</strong><br/>NAME       SIZELIMIT OFFSET AUTOCLEAR RO BACK-FILE<br/>/dev/loop0         0      0         0  1 /exam/image.raw</pre>&#13;
<p class="indent">The <em>/dev/loop0</em> device now points to <em>/exam/image.raw</em>, and you can access it with any tools that operate on block devices. For example, here the Sleuth Kit <code>mmls</code> command is able to see the partition table on the <em>image.raw</em> file using the loop device:</p>&#13;
<pre># <strong>mmls /dev/loop0</strong><br/>DOS Partition Table<br/>Offset Sector: 0<br/>Units are in 512-byte sectors<br/><br/>     Slot    Start        End          Length       Description<br/>00:  Meta    0000000000   0000000000   0000000001   Primary Table (#0)<br/>01:  -----   0000000000   0000002047   0000002048   Unallocated<br/>02:  00:00   0000002048   0058597375   0058595328   Linux (0x83)<br/>03:  00:01   0058597376   0078129151   0019531776   Linux Swap / Solaris x86 (0x82)<br/>04:  00:02   0078129152   0078231551   0000102400   NTFS (0x07)<br/>05:  00:03   0078231552   0234441647   0156210096   Mac OS X HFS (0xaf)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_231"/>When you no longer need a loop device, simply detach it as follows:</p>&#13;
<pre># <strong>losetup --detach /dev/loop0</strong></pre>&#13;
<p class="indent">Loop devices are flexible and configurable. In the previous mmls example, a filesystem starts at sector 2048. It’s possible to specify an offset each time you run a forensic tool, but it’s easier to have a separate device for each partition (similar to <em>/dev/sda1</em> for example). You can create a separate loop device with the <code>losetup</code> command just for that partition by specifying the correct offset flag (<code>--offset</code>) and size flag (<code>--sizelimit</code>). However, a more commonly accepted way is to use the device mapper.</p>&#13;
<p class="indent">You could do this manually using dmsetup and mapping tables as described in “<a href="ch06.xhtml#ch06lev1sec07">RAID and Multidisk Systems</a>” on <a href="ch06.xhtml#page_178">page 178</a>. However, the kpartx tool automates the creation of partition devices for a particular image file. A forensically acquired image with four partitions is used in the following example to demonstrate the kpartx tool making mapper devices for each partition:</p>&#13;
<pre># <strong>kpartx -r -a -v image.raw</strong><br/>add map loop0p1 (252:0): 0 58595328 linear /dev/loop0 2048<br/>add map loop0p2 (252:1): 0 19531776 linear /dev/loop0 58597376<br/>add map loop0p3 (252:2): 0 102400 linear /dev/loop0 78129152<br/>add map loop0p4 (252:3): 0 156210096 linear /dev/loop0 78231552</pre>&#13;
<p class="indent">Here, the kpartx tool reads the partition table on a disk or image file, creates a loop device for the whole image, and then creates mapper devices for each partition. The <code>-r</code> flag ensures the drive loop and partition mappings are read-only, and the <code>-a</code> flag instructs kpartx to map everything it finds. Use the verbose flag <code>-v</code> to document the command output and to indicate what was just mapped.</p>&#13;
<p class="indent">In this example, a loop device is created (<em>/dev/loop0</em>) for the whole image file and is accessible as a raw block device. In addition, partition devices are now available in the <em>/dev/mapper</em> directory, and you can access <span epub:type="pagebreak" id="page_232"/>them using forensic tools that operate on partitions, without specifying any offsets. Here are a few example Sleuth Kit commands for some of the partitions:</p>&#13;
<pre># <strong>fsstat /dev/mapper/loop0p1</strong><br/>FILE SYSTEM INFORMATION<br/>--------------------------------------------<br/>File System Type: Ext4<br/>Volume Name:<br/>Volume ID: d4605b95ec13fcb43646de38f7f49680<br/>...<br/># <strong>fls /dev/mapper/loop0p3</strong><br/>r/r 4-128-1:    $AttrDef<br/>r/r 8-128-2:    $BadClus<br/>r/r 8-128-1:    $BadClus:$Bad<br/>r/r 6-128-1:    $Bitmap<br/>r/r 7-128-1:    $Boot<br/>d/d 11-144-2:   $Extend<br/>r/r 2-128-1:    $LogFile<br/>r/r 0-128-1:    $MFT<br/>...<br/># <strong>fsstat /dev/mapper/loop0p4</strong><br/>FILE SYSTEM INFORMATION<br/>--------------------------------------------<br/>File System Type: HFS+<br/>File System Version: HFS+<br/>...</pre>&#13;
<p class="indent">A filesystem mapped to a device from an image file can be safely mounted as read-only. This will allow you access it with a standard file manager, applications, and other file-analysis tools. You can mount and unmount loop partitions, as shown in this example:</p>&#13;
<pre># <strong>mkdir p3</strong><br/># <strong>mount --read-only /dev/mapper/loop0p3 p3</strong><br/># <strong>mc ./p3</strong><br/>...<br/># <strong>umount p3</strong><br/># <strong>rmdir p3</strong></pre>&#13;
<p class="indent">Here, a directory, <em>p3</em>, representing the partition was created in the same directory as the raw image. Then <em>p3</em> was used as the mount point (the chosen mount point can be anywhere on the examiner host filesystem). Midnight Commander (<code>mc</code>) is a text-based file manager (a Norton Commander clone) and is used in this example to review the files on the mounted partition. When the mount point is no longer needed, the <code>umount</code> command (this <span epub:type="pagebreak" id="page_233"/>command is spelled correctly with only one <em>n</em>) unmounts the filesystem, and rmdir removes the mount point directory. This is the traditional Unix way to mount and unmount a filesystem on a host system.</p>&#13;
<p class="indent">When you no longer need the drive loop and partition mappings, you can remove them all by using the kpartx delete (<code>-d</code>) flag and the name of the image file, like this:</p>&#13;
<pre># <strong>kpartx -d image.raw</strong><br/>loop deleted : /dev/loop0</pre>&#13;
<p class="indent">Note that this “delete” has no effect on the disk image’s contents. The loop and mappings are deleted, not the drive image, and the drive image is not modified.</p>&#13;
<p class="indent">If a raw image has a corrupt or overwritten partition table, you can scan the image for filesystems and use dmsetup to manually map filesystems as devices (using dmsetup tables).</p>&#13;
<p class="indent">When you create, mount, unmount, or detach a loop device, root privileges are required. They’re also required for operating on the <em>/dev/loopX</em> device with forensic tools. The examples shown in this section were run as the root user to reduce the complexity of the command lines, making them easier to understand. Prefixing the commands with <code>sudo</code> can be used to run privileged commands as a non-root user.</p>&#13;
<h4 class="h4" id="ch08lev2sec02"><em><strong>Forensic Format Image Files</strong></em></h4>&#13;
<p class="noindenta">The ewflib software package includes a tool called ewfmount to “mount” the contents of a forensic image, making it accessible as a regular raw image file.</p>&#13;
<p class="indent">The following example shows a group of <em>*.e01</em> files. A mount point, <code>raw</code> in this example, is created with <code>mkdir</code> and will contain the raw image file:</p>&#13;
<pre># <strong>ls</strong><br/>image.E01  image.E02  image.E03  image.E04  image.E05<br/># <strong>mkdir raw</strong></pre>&#13;
<p class="indent">The ewfmount tool creates a FUSE filesystem containing a virtual raw image from one or more EWF files. You can run <code>ewfmount</code> command with the first of the EnCase EWF files and the mount point to access a raw image file like this:</p>&#13;
<pre># <strong>ewfmount image.E01 raw</strong><br/>ewfmount 20160424<br/><br/># <strong>ls -l raw</strong><br/>total 0<br/>-r--r--r-- 1 root root 16001269760 May 17 21:20 ewf1</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_234"/>You can then operate on this virtual raw image file using tools that don’t support EWF formats directly. In the following example, a hex editor (without EWF support) is used in sector mode to analyze the raw image:</p>&#13;
<pre># <strong>hexedit -s raw/ewf1</strong><br/>...</pre>&#13;
<p class="indent">The kpartx tool is again useful to identify partitions and create corresponding loop devices, enabling the use of tools that can operate on block devices and allowing the mounting of the filesystems for regular browsing. The kpartx output of the <em>*.e01</em> files mounted with ewfmount is shown here:</p>&#13;
<pre># <strong>kpartx -r -a -v raw/ewf1</strong><br/>add map loop0p1 (252:0): 0 29848707 linear /dev/loop0 63<br/>add map loop0p2 (252:1): 0 2 linear /dev/loop0 29848770<br/>add map loop0p5 : 0 1397592 linear /dev/loop0 29848833</pre>&#13;
<p class="indent">Let’s continue using this example to create a mount point for a partition and mount and access a filesystem:</p>&#13;
<pre># <strong>mkdir p1</strong><br/># <strong>mount --read-only /dev/mapper/loop0p1 p1</strong><br/># <strong>ls p1</strong><br/>cdrom  home/       lib32/       media/  proc/  selinux/  tmp/  vmlinuz<br/>bin/     dev/   initrd.img  lib64        mnt/    root/  srv/      usr/<br/>boot/    etc/   lib/        lost+found/  opt/    sbin/  sys/      var/<br/>...</pre>&#13;
<p class="indent">In this example, a mount point corresponding to the partition is created in the local directory, the partition device is mounted on it, and the file-system is accessed with <code>ls</code>. If possible, avoid the use of <em>/mnt</em> or other shared mount directories when mounting evidence files and containers. It is easier to perform forensic work when the mount points for an image are in the same working directory as other related case files.</p>&#13;
<p class="indent">As before, when the work is completed, you need to clean up the mounts and virtual files. Again, this is done in the reverse order:</p>&#13;
<pre># <strong>umount p1</strong><br/># <strong>kpartx -d raw/ewf1</strong><br/>loop deleted : /dev/loop0<br/># <strong>fusermount -u raw</strong><br/># <strong>rmdir p1 raw</strong></pre>&#13;
<p class="indent">The <code>fusermount</code> command is shown in this example, but the standard Linux <code>umount</code> command would also work. Make sure your current working directory is not inside the mount point and that no programs have open files inside the mount points. Both conditions will cause these cleanup steps to fail.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_235"/>When using SquashFS forensic evidence containers, you can access the raw image by mounting the <em>*.sfs</em> file with <code>sfsimage -m</code>, creating the partition devices, and then mounting the desired partition. You can then execute regular commands on the subject image’s filesystem. A complete example is shown here:</p>&#13;
<pre># <strong>sfsimage -m image.sfs</strong><br/>image.sfs.d mount created<br/># <strong>kpartx -r -a -v image.sfs.d/image.raw</strong><br/>add map loop1p1 (252:0): 0 29848707 linear /dev/loop1 63<br/>add map loop1p2 (252:1): 0 2 linear /dev/loop1 29848770<br/>add map loop1p5 : 0 1397592 linear /dev/loop1 29848833<br/># <strong>mkdir p1</strong><br/># <strong>mount /dev/mapper/loop1p1 p1</strong><br/>mount: /dev/mapper/loop1p1 is write-protected, mounting read-only<br/># <strong>ls -l</strong><br/>...</pre>&#13;
<p class="indent">Once you are finished accessing the raw image and its filesystems, clean up with SquashFS forensic evidence containers is also done in reverse. The <code>sfsimage -u</code> command unmounts a SquashFS filesytem as shown in this example:</p>&#13;
<pre># <strong>umount p1</strong><br/># <strong>kpartx -d image.sfs.d/image.raw</strong><br/>loop deleted : /dev/loop1<br/># <strong>sfsimage -u image.sfs.d/</strong><br/>image.sfs.d unmounted</pre>&#13;
<p class="indent">This section has demonstrated several methods for accessing the contents of forensic formats, both as block devices and as regular filesystems. The ewfmount tool also works with FTK SMART files. Afflib has a similar tool called affuse for mounting <em>*.aff</em> files. Both ewfmount and affuse can operate on single or split files of their respective formats.</p>&#13;
<p class="indent">Note that many forensic tools (Sleuth Kit, for example) are able to operate directly on forensic formats without the need for a raw block device or raw file.</p>&#13;
<h4 class="h4" id="ch08lev2sec03"><em><strong>Prepare Boot Images with xmount</strong></em></h4>&#13;
<p class="noindenta">Forensic investigators often want to examine a subject drive image with nonforensic tools, such file managers, office suites, applications, or other file viewer tools. This can be done by making the drive contents safely available over a read-only mount for the local examiner machine to access.</p>&#13;
<p class="indent">In some cases, it is useful to boot a subject drive in a VM to observe and interact directly with the live subject environment. This allows you to view the subject’s desktop and use the installed programs of the subject PC. To do this, you can use a number of tools described in this section.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_236"/>The xmount (pronounced “crossmount”) tool creates a virtual disk image that you can boot using VM software, such as VirtualBox or kvmqemu. The xmount tool allows you to simulate a read-write drive, making the VM think the disk is writable, but it continues to protect the image in a read-only state. Multiple VM output formats are available, including raw, DMG, VDI, VHD, VMDK, and VMDKS.</p>&#13;
<p class="indent">The input formats include forensically acquired image files, such as <em>*.raw</em>, EnCase <em>*.ewf</em>, and AFFlib <em>*.aff</em> files.</p>&#13;
<p class="indent">Here is an example of a raw image (<em>image.raw</em>) set up with xmount as a VirtualBox <em>*.vdi</em> file:</p>&#13;
<pre>$ <strong>mkdir virtual</strong><br/>$ <strong>xmount --cache xmount.cache --in raw image.raw --out vdi virtual</strong><br/>$ <strong>ls virtual/</strong><br/>image.info  image.vdi<br/>$ <strong>cat virtual/image.info</strong><br/>------&gt; The following values are supplied by the used input library(ies) &lt;------<br/><br/>--&gt; image.raw &lt;--<br/>RAW image assembled of 1 piece(s)<br/>30016659456 bytes in total (27.955 GiB)<br/><br/>------&gt; The following values are supplied by the used morphing library &lt;------<br/><br/>None<br/>$ <strong>virtualbox</strong></pre>&#13;
<p class="indent">In this example, the directory <em>virtual</em> is created to hold the virtual image file (it will be FUSE mounted). From an existing <em>image.raw</em> file, the <code>xmount</code> command creates a write-cached VirtualBox VDI image in the <em>./virtual</em> directory. This is just a virtual representation of the image file; it is not copied or converted (thus not wasting disk space on the examiner machine). The <code>--in</code> and <code>--out</code> flags specify the image format used. The input formats must be raw, AFF, or EWF. Multiple output formats are possible.</p>&#13;
<p class="indent">Booting an OS image in a VM can be challenging when the installed OS is expecting a different hardware configuration than provided by the VM. Typically, this is less of an issue with Linux installations but can be problematic with Windows and OS X. To solve this problem, two tools, opengates and openjobs, were created to prepare Windows and OS X images for safely booting subject disks in a virtual environment. I won’t cover how to use opengates and openjobs, but you can find more information about them at <em><a href="https://www.pinguin.lu/openjobs/">https://www.pinguin.lu/openjobs/</a></em> and <em><a href="https://www.pinguin.lu/opengates/">https://www.pinguin.lu/opengates/</a></em>.</p>&#13;
<p class="indent">When you no longer need the VM image, you can clean up by unmounting the virtual image and removing the mount point directory:</p>&#13;
<pre>$ <strong>fusermount -u virtual</strong><br/>$ <strong>ls virtual/</strong><br/>$ <strong>rmdir virtual</strong></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_237"/>A <em>xmount.cache</em> file containing data written during the use of the VM might exist. You can save the file if you need to continue the previous VM session, or you can remove it.</p>&#13;
<h3 class="h3" id="ch08lev1sec02"><strong>VM Images</strong></h3>&#13;
<p class="noindent">With the increasing performance of home computers, hardware virtualization in most modern CPUs, and the availability of inexpensive or free virtualization software, there is an increased need to analyze the contents of VM images. In some cases, you might find many VM images on subject PCs. This section focuses on accessing common VM image file types such as QCOW2, VDI, VMDK, and VHD.</p>&#13;
<h4 class="h4" id="ch08lev2sec04"><em><strong>QEMU QCOW2</strong></em></h4>&#13;
<p class="noindenta">The QCOW2 format is a common VM image type found on Linux and used by the QEMU emulator. In this section, I’ll make a QCOW2 image available as a block device and safely mount it for browsing.</p>&#13;
<p class="indent">The libqcow-utils package (written by Joachim Metz, author of ewflib) contains the qcowinfo and qcowmount tools. You can use both tools in the same way as you used the ewfinfo and ewfmount tools in previous examples. But the following example shows an alternative method using the <code>qemu-img</code> command, the nbd kernel module, and the qemu-nbd tool. This method offers performance advantages because it operates in the kernel and saves you a few steps because you don’t need to use kpartx.</p>&#13;
<p class="indent">Given a <em>*.qcow2</em> file, the <code>qemu-img</code> command can provide a summary of the file:</p>&#13;
<pre># <strong>qemu-img info image.qcow2</strong><br/>image: image.qcow2<br/>file format: qcow2<br/>virtual size: 5.0G (5368709120 bytes)<br/>disk size: 141M<br/>cluster_size: 65536<br/>Format specific information:<br/>    compat: 1.1<br/>    lazy refcounts: false<br/>    refcount bits: 16<br/>    corrupt: false</pre>&#13;
<p class="indent">To access a QCOW image in a raw image representation with nbd, you need to load the nbd kernel module:</p>&#13;
<pre># <strong>modprobe nbd</strong><br/># <strong>dmesg | grep nbd</strong><br/>[16771.003241] nbd: registered device at major 43</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_238"/>Unlike with the <code>losetup</code> command, the device is not automatically chosen. A <em>/dev/nbd*</em> device needs to be specified as follows:</p>&#13;
<pre># <strong>qemu-nbd --read-only --connect /dev/nbd0 image.qcow2</strong><br/># <strong>dmesg | grep nbd0</strong><br/>[16997.777839]  nbd0: p1</pre>&#13;
<p class="indent">Here, the QCOW2 image file was connected to the kernel module in read-only mode, and the partition device was automatically detected. You can use this raw device with forensic tools, as shown in this example:</p>&#13;
<pre># <strong>mmls /dev/nbd0</strong><br/>DOS Partition Table<br/>Offset Sector: 0<br/>Units are in 512-byte sectors<br/><br/>     Slot    Start        End          Length       Description<br/>00:  Meta    0000000000   0000000000   0000000001   Primary Table (#0)<br/>01:  -----   0000000000   0000002047   0000002048   Unallocated<br/>02:  00:00   0000002048   0010485759   0010483712   Linux (0x83)</pre>&#13;
<p class="indent">The partition devices (the raw device name with <code>p1</code> in this example) are also ready for you to use directly with forensic tools. To illustrate, here’s the <code>fls</code> command operating directly on a filesystem on the partition device:</p>&#13;
<pre># <strong>fls /dev/nbd0p1</strong><br/>d/d 11: lost+found<br/>r/r 12: hosts<br/>d/d 327681:     $OrphanFiles<br/>...</pre>&#13;
<p class="indent">Mounting the devices locally for browsing is trivial. A local mount point directory is created, and the filesystem is mounted normally, as follows:</p>&#13;
<pre># <strong>mkdir p1</strong><br/># <strong>mount /dev/nbd0p1 p1</strong><br/>mount: /dev/nbd0p1 is write-protected, mounting read-only<br/># <strong>ls p1</strong><br/>hosts  lost+found/</pre>&#13;
<p class="indent">The cleanup here is similar to the examples using loop devices, but with fewer steps. All processes should close files, and you should leave the mounted directory so it can be unmounted. A <code>qemu-nbd disconnect</code> command specifying the device name will unregister the device from the kernel, like so:</p>&#13;
<pre># <strong>umount p1</strong><br/># <strong>qemu-nbd --read-only --disconnect /dev/nbd0</strong><br/>/dev/nbd0 disconnected<br/># <strong>rmdir p1</strong></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_239"/>An optional step is to remove the kernel module using <code>rmmod nbd</code>. But there is no harm in leaving it in if you’ll be doing more QCOW mounts. You can also autoload the nbd module at boot by adding it to the <em>/etc/modules</em> file.</p>&#13;
<h4 class="h4" id="ch08lev2sec05"><em><strong>VirtualBox VDI</strong></em></h4>&#13;
<p class="noindenta">VirtualBox is an open source project maintained by Oracle (formerly Sun Microsystems). Although it supports multiple VM image formats, VirtualBox VDI images are used in the examples that follow. The same <code>qemu-nbd</code> command is used as before but with an OpenSolaris image.</p>&#13;
<p class="indent">The VirtualBox software package includes a number of utilities; the VBoxManage tool is shown here, providing information about the VDI image:</p>&#13;
<pre># <strong>VBoxManage showhdinfo OpenSolaris.vdi</strong><br/>UUID:           0e2e2466-afd7-49ba-8fe8-35d73d187704<br/>Parent UUID:    base<br/>State:          created<br/>Type:           normal (base)<br/>Location:       /exam/OpenSolaris.vdi<br/>Storage format: VDI<br/>Format variant: dynamic default<br/>Capacity:       16384 MBytes<br/>Size on disk:   2803 MBytes<br/>Encryption:     disabled</pre>&#13;
<p class="indent">You can mount VirtualBox images using <code>qemu-nbd</code> and the nbd kernel module (as you saw in the previous section using QCOW2). The Open-Solaris example shown here is slightly different from the partitioning scheme Windows and Linux use. Multiple disk slices<sup><a id="fn_42" href="footnote.xhtml#fn42">1</a></sup> are also shown:</p>&#13;
<pre># <strong>qemu-nbd -c /dev/nbd0 OpenSolaris.vdi</strong><br/># <strong>dmesg</strong><br/>...<br/>[19646.708351]  nbd0: p1<br/>                p1: &lt;solaris: [s0] p5 [s1] p6 [s2] p7 [s8] p8 &gt;</pre>&#13;
<p class="indent">In this example, a single Solaris partition (<code>p1</code>) contains multiple slices (<code>p5</code>, <code>p6</code>, <code>p7</code>, and <code>p8</code>).</p>&#13;
<p class="indent">You can use the same methods as in the previous QEMU example to access the raw and partition devices, then mount the partitions as <span epub:type="pagebreak" id="page_240"/>read-only to a local mount point. Here again, you don’t need to use kpartx to find the partitions, because the kernel does it automatically. Once you are finished accessing the partitions (or slices, here), perform the cleanup steps to unmount filesystems and disconnect the nbd device.</p>&#13;
<h4 class="h4" id="ch08lev2sec06"><em><strong>VMWare VMDK</strong></em></h4>&#13;
<p class="noindenta">The <em>Virtual Machine DisK (VMDK)</em> format is used by VMWare’s VM software products. The following example uses the libvmdk-utils software package on an Apple Lion VMDK image split into multiple parts:</p>&#13;
<pre># <strong>ls</strong><br/>lion-000001-s001.vmdk  lion-000003-s007.vmdk  lion-s009.vmdk<br/>lion-000001-s002.vmdk  lion-000003-s008.vmdk  lion-s010.vmdk<br/>lion-000001-s003.vmdk  lion-000003-s009.vmdk  lion-s011.vmdk<br/>lion-000001-s004.vmdk  lion-000003-s010.vmdk  lion-s012.vmdk<br/>lion-000001-s005.vmdk  lion-000003-s011.vmdk  lion-s013.vmdk<br/>lion-000001-s006.vmdk  lion-000003-s012.vmdk  lion-s014.vmdk<br/>lion-000001-s007.vmdk  lion-000003-s013.vmdk  lion-s015.vmdk<br/>lion-000001-s008.vmdk  lion-000003-s014.vmdk  lion-s016.vmdk<br/>...</pre>&#13;
<p class="indent">You can retrieve information about the assembled image and each of the “Extents” using <code>vmdkinfo</code>:</p>&#13;
<pre># <strong>vmdkinfo lion.vmdk</strong><br/>vmdkinfo 20160119<br/><br/>VMware Virtual Disk (VMDK) information:<br/>        Disk type:                      2GB extent sparse<br/>        Media size:                     42949672960 bytes<br/>        Content identifier:             0xadba0513<br/>        Parent content identifier:      0xffffffff<br/>        Number of extents:              21<br/><br/>Extent: 1<br/>        Filename:                       lion-s001.vmdk<br/>        Type:                           Sparse<br/>        Start offset:                   0<br/>        Size:                           2146435072 bytes<br/>...</pre>&#13;
<p class="indent">Creating a mount point and mounting the image makes it accessible as a raw image file:</p>&#13;
<pre># <strong>mkdir lion</strong><br/># <strong>vmdkmount lion.vmdk lion</strong><br/>vmdkmount 20160119<br/># <strong>ls -ls lion</strong><br/>total 0<br/>0 -r--r--r-- 1 root root 42949672960 May 17 22:24 vmdk1<br/># <strong>mmls lion/vmdk1</strong><br/>GUID Partition Table (EFI)<br/>Offset Sector: 0<br/>Units are in 512-byte sectors<br/><br/>     Slot    Start        End          Length       Description<br/>00:  Meta    0000000000   0000000000   0000000001   Safety Table<br/>01:  -----   0000000000   0000000039   0000000040   Unallocated<br/>02:  Meta    0000000001   0000000001   0000000001   GPT Header<br/>03:  Meta    0000000002   0000000033   0000000032   Partition Table<br/>04:  00      0000000040   0000409639   0000409600   EFI System Partition<br/>05:  01      0000409640   0082616503   0082206864   Untitled<br/>06:  02      0082616504   0083886039   0001269536   Recovery HD<br/>07:  -----   0083886040   0083886079   0000000040   Unallocated</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_241"/>Using kpartx, as shown earlier in the chapter, will create the associated disk and partition block devices. You can then use forensic analysis tools on them directly or mount them on the local machine to browse the filesystem.</p>&#13;
<h4 class="h4" id="ch08lev2sec07"><em><strong>Microsoft VHD</strong></em></h4>&#13;
<p class="noindenta">A number of methods help you make the Microsoft VHD virtual image format accessible. For example, you can use the qemu-nbd method or use the libvhdi-utils with vhdiinfo and vhdimount.</p>&#13;
<p class="indent">A third method is available using the blktap-utils with the Xen blktap xapi interface. Similar to the nbd method, the blktap requires you to insert a kernel module and manually allocate a device. A tapdisk process is spawned, attached to the driver, and instructed to open a disk image. The manual pages for blktap-utils aren’t very useful, but you can find a description on the Xen website at <em><a href="http://wiki.xen.org/wiki/Mounting_a_.vhd_disk_image_using_blktap/tapdisk">http://wiki.xen.org/wiki/Mounting_a_.vhd_disk_image_using_blktap/tapdisk</a></em> and at <em><a href="http://lists.xen.org/archives/html/xen-api/2012-05/msg00149.html">http://lists.xen.org/archives/html/xen-api/2012-05/msg00149.html</a></em>.</p>&#13;
<p class="indent">To complete this section, I’ll repeat the process for setting up devices using the libvhdi tools. For simplicity, the previous examples used the privileged root user. But the following examples demonstrate a nonprivileged user authorized to use <code>sudo</code>.</p>&#13;
<p class="indent">To run the FUSE <code>mount</code> and <code>unmount</code> commands as a nonprivileged user, you need to set <em>user_allow_other</em> in <em>/etc/fuse.conf</em>.</p>&#13;
<p class="indent">You can find information about the image using <code>vhdiinfo</code>, and no special privileges are required:</p>&#13;
<pre>$ <strong>vhdiinfo windows.vhd</strong><br/>vhdiinfo 20160111<br/>Virtual Hard Disk (VHD) image information:<br/>        Format:                 1.0<br/>        Disk type:              Dynamic<br/>        Media size:             136365211648 bytes<br/>        Identifier:             c9f106a3-cf3f-6b42-a13f-60e349faccb5</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_242"/>You can FUSE mount the image without root privileges, but you need to explicitly instruct the <code>vhdimount</code> command to allow the root user access by adding the <code>-X allow_root</code> flag. This flag is also needed to allow root to perform further actions through <code>sudo</code> (like creating block devices with kpartx):</p>&#13;
<pre>$ <strong>mkdir raw</strong><br/>$ <strong>vhdimount -X allow_root windows.vhd raw</strong><br/>vhdimount 20160111<br/><br/>$ <strong>ls -l raw/</strong><br/>total 0<br/>-r--r--r-- 1 holmes holmes 136365211648 Jan 20 08:14 vhdi1</pre>&#13;
<p class="indent">The raw image is now available in the <em>./raw</em> directory, and you can access it with standard tools. To create loop and mapper devices, run <code>kpartx</code> with the <code>sudo</code> command. Once the devices are created, you can access them with tools via the <code>sudo</code> command. The <code>sudo</code> command is required for all block device access. Examples with kpartx and fls are shown here:</p>&#13;
<pre>$ <strong>sudo kpartx -r -a -v ./raw/vhdi1</strong><br/>add map loop0p1 (252:0): 0 266334018 linear /dev/loop0 63<br/>$ <strong>sudo fls /dev/mapper/loop0p1</strong><br/>r/r 4-128-4:    $AttrDef<br/>r/r 8-128-2:    $BadClus<br/>r/r 8-128-1:    $BadClus:$Bad<br/>r/r 6-128-1:    $Bitmap<br/>r/r 7-128-1:    $Boot<br/>d/d 11-144-4:   $Extend<br/>r/r 2-128-1:    $LogFile<br/>r/r 0-128-1:    $MFT</pre>&#13;
<p class="indent">Mounting the filesystem also requires <code>sudo</code>, and explicitly specifying <code>-o ro</code> mounts it as read-only. An example of creating a mount point, mounting the filesystem from the previous example, and accessing it with <code>ls</code> is shown here:</p>&#13;
<pre>$ <strong>mkdir p1</strong><br/>$ <strong>sudo mount -o ro /dev/mapper/loop0p1 p1</strong><br/>$ <strong>ls p1</strong><br/>AUTOEXEC.BAT                 IO.SYS          $RECYCLE.BIN/<br/>...</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_243"/>The cleanup of this session requires <code>sudo</code> for unmounting the raw image and removing the loop and mapper devices. You can remove the FUSE mount of the <em>*.vhd</em> file without root privileges. These steps are shown here:</p>&#13;
<pre>$ <strong>sudo umount p1</strong><br/>$ <strong>sudo kpartx -d raw/vhdi1</strong><br/>loop deleted : /dev/loop0<br/>$ <strong>fusermount -u raw</strong></pre>&#13;
<p class="indent">You configure the <code>sudo</code> command by editing the <em>/etc/sudoers</em> file. Many of the examples in this book use the root user for simplicity’s sake to reduce the number of commands on an already complex command line. It’s good practice to work as a nonprivileged user with security mechanisms such as <code>sudo</code>.</p>&#13;
<h3 class="h3" id="ch08lev1sec03"><strong>OS-Encrypted Filesystems</strong></h3>&#13;
<p class="noindent">Now let’s look at accessing popular encrypted filesystems. The focus is not on key recovery (although I do provide a couple of suggestions) but on accessing the filesystems with a known key. It’s assumed the keys or passwords are available from memory dumps, escrow/backup in enterprise organizations, individuals legally compelled to provide them, victims offering to help, commercial recovery services/software, or other sources.</p>&#13;
<p class="indent">You can determine the type of filesystem encryption with various partition-analysis tools that can identify headers, magic numbers, and other artifacts unique to a particular encrypted filesystem type. You’ll find an overview of identifying filesystem encryption in a forensic context at <em><a href="http://encase-forensic-blog.guidancesoftware.com/2014/04/version-7-tech-tip-spotting-full-disk.html">http://encase-forensic-blog.guidancesoftware.com/2014/04/version-7-tech-tip-spotting-full-disk.html</a></em>.</p>&#13;
<p class="indent">In this section, you’ll find the information about a particular encrypted image needed to create an unencrypted block device or file that you can access using forensic tools or safely mount for local browsing.</p>&#13;
<h4 class="h4" id="ch08lev2sec08"><em><strong>Microsoft BitLocker</strong></em></h4>&#13;
<p class="noindenta">Microsoft’s current default filesystem encryption is BitLocker. It encrypts at the block level, protecting entire volumes. A variant of BitLocker designed for removable media is called BitLocker-To-Go, which uses encrypted container files on a regular unencrypted filesystem. Two open source tools, dislocker and libbde, are shown in the examples in this section.</p>&#13;
<p class="indent">Written by Romain Coltel, you’ll find the dislocker package at <em><a href="https://github.com/Aorimn/dislocker/">https://github.com/Aorimn/dislocker/</a></em>. It provides various tools for handling BitLocker volumes, including viewing metadata, creating decrypted image files, and FUSE mounting volumes.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_244"/>The dislocker-find tool scans all attached partition devices and specified files to identify the existence of any BitLocker volumes. Scanning for BitLocker devices might not be necessary if the subject device was already identified during the process of attaching it to the acquisition host.</p>&#13;
<p class="indent">The <code>dislocker-metadata</code> command provides an overview of a BitLocker drive. The next example is an image taken from a USB thumb drive. The entire drive is encrypted, and it doesn’t have a partition table. The image file can be queried as follows:</p>&#13;
<pre># <strong>dislocker-metadata -V bitlocker-image.raw</strong><br/>...<br/>Wed Jan 20 13:46:06 2016 [INFO] BitLocker metadata found and parsed.<br/>Wed Jan 20 13:46:06 2016 [INFO] =====[ Volume header informations ]=====<br/>Wed Jan 20 13:46:06 2016 [INFO]   Signature: 'MSWIN4.1'<br/>Wed Jan 20 13:46:06 2016 [INFO]   Sector size: 0x0200 (512) bytes<br/>...<br/>Wed Jan 20 13:46:06 2016 [INFO]   Number of sectors (64 bits): 0x0000000200000000<br/>    (8589934592) bytes<br/>Wed Jan 20 13:46:06 2016 [INFO]   MFT start cluster: 0x0000000000060001 (393217)<br/>    bytes<br/>...<br/>Wed Jan 20 13:46:06 2016 [INFO] =====================[ BitLocker information<br/>    structure ]=====================<br/>Wed Jan 20 13:46:06 2016 [INFO]   Signature: '-FVE-FS-'<br/>Wed Jan 20 13:46:06 2016 [INFO]   Total Size: 0x02f0 (752) bytes (including<br/>    signature and data)<br/>Wed Jan 20 13:46:06 2016 [INFO]   Version: 2<br/>Wed Jan 20 13:46:06 2016 [INFO]   Current state: ENCRYPTED (4)<br/>Wed Jan 20 13:46:06 2016 [INFO]   Next state: ENCRYPTED (4)<br/>Wed Jan 20 13:46:06 2016 [INFO]   Encrypted volume size: 7918845952 bytes<br/>    (0x1d8000000), ~7552 MB<br/>...</pre>&#13;
<p class="indent">The output of this command provides a lot of detailed cryptographic information not shown here. You can save the output of <code>dislocker-metadata</code> to a text file for documentation purposes. This command can also operate directly on attached devices.</p>&#13;
<p class="indent">As in previous password and encryption examples, it’s assumed that you have the key. Some commercial tools are available to attempt password brute force to recover the key. In addition, you can use a volatility plug-in to extract the FVEK from a memory image (<em><a href="https://github.com/elceef/bitlocker/">https://github.com/elceef/bitlocker/</a></em>), and you could use this tool in conjunction with the inception memorydumping tool. The use of these tools is not covered here.</p>&#13;
<p class="indent">You can create a virtual file or block device to operate on a decrypted view of the disk image “in place.” The process to do so is similar to the examples in “<a href="ch08.xhtml#ch08lev1sec02">VM Images</a>” on <a href="ch08.xhtml#page_237">page 237</a>. The dislocker software package <span epub:type="pagebreak" id="page_245"/>provides a tool to create a FUSE filesystem with virtual representation of the decrypted volume:</p>&#13;
<pre># <strong>mkdir clear</strong><br/># <strong>dislocker-fuse -u -V bitlocker-image.raw clear</strong><br/>Enter the user password:<br/># <strong>ls -l clear/</strong><br/>total 0<br/>-rw-rw-rw- 1 root root 7918845952 Jan  1  1970 dislocker-file<br/>...</pre>&#13;
<p class="indent">The file that appears in the <em>clear</em> directory is a decrypted representation of the encrypted filesystem, and you can operate on it using regular forensic tools. An example using Sleuth Kit’s fsstat is shown here:</p>&#13;
<pre># <strong>fsstat clear/dislocker-file</strong><br/>FILE SYSTEM INFORMATION<br/>--------------------------------------------<br/>File System Type: FAT32<br/><br/>OEM Name: MSDOS5.0<br/>Volume ID: 0x5a08a5ba<br/>Volume Label (Boot Sector): NO NAME<br/>Volume Label (Root Directory): MY SECRETS<br/>File System Type Label: FAT32<br/>Next Free Sector (FS Info): 34304<br/>Free Sector Count (FS Info): 15418664<br/>...</pre>&#13;
<p class="indent">You can safely mount the decrypted filesystem image for normal browsing. The <code>mount</code> command has a <code>loop</code> option, which allows a partition image file to be directly mounted, as shown here:</p>&#13;
<pre># <strong>mkdir files</strong><br/># <strong>mount -o loop,ro clear/dislocker-file files</strong><br/># <strong>ls files</strong><br/>Penguins.jpg  private/  System Volume Information/<br/>...</pre>&#13;
<p class="indent">The cleanup in this example is a simple matter of unmounting the files’ mount point, removing the FUSE mount, and deleting the mount directories:</p>&#13;
<pre># <strong>umount files</strong><br/># <strong>rmdir files</strong><br/># <strong>fusermount -u clear</strong><br/># <strong>rmdir clear</strong></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_246"/>Note that the preceding examples were done with root privileges to reduce complexity and make them easier to understand. You can perform the same commands as a nonprivileged user, as shown here:</p>&#13;
<pre>$ <strong>dislocker-metadata -V bitlocker-image.raw</strong><br/>$ <strong>mkdir clear files</strong><br/>$ <strong>dislocker-fuse -u -V bitlocker-image.raw -- -o allow_root clear</strong><br/>$ <strong>sudo mount -o loop,ro,uid=holmes clear/dislocker-file files</strong><br/>...<br/>$ <strong>sudo umount files</strong><br/>$ <strong>fusermount -u clear</strong><br/>$ <strong>rmdir clear files</strong></pre>&#13;
<p class="indent">Here <code>dislocker-fuse</code> passes <code>-o allow_root</code> to the FUSE driver, allowing <code>sudo</code> to be used for mounting and unmounting. The <code>uid=holmes</code> ensures that Mr. Holmes can access the mounted files without root privileges. It’s assumed that Mr. Holmes is a member of the FUSE Unix group, and the <em>/etc/fuse.conf</em> file contains the line <em>user_allow_other</em>.</p>&#13;
<p class="indent">Using dislocker, you can provide three possible credentials to unlock a BitLocker container. A <code>-u</code> flag (used in the previous example) specifies that the user’s password be requested. A <code>-p</code> flag provides a recovery password (48 digits long). And an <code>-f</code> flag specifies a key file (BEK file).</p>&#13;
<p class="indent">Using a recovery password (<code>-p</code>) instead of a user password (<code>-u</code>) requires manually keying in the 48-digit recovery password, as follows:</p>&#13;
<pre># <strong>dislocker-fuse -p -V bitlocker-image.raw clear</strong><br/>Enter the recovery password: XXXXXX-XXXXXX-XXXXXX-XXXXXX-XXXXXX-XXXXXX-XXXXXX-XXXXXX<br/>Valid password format, continuing.</pre>&#13;
<p class="indent">The non-root version of this command passes flags to FUSE, which allows for mounting with <code>sudo</code>:</p>&#13;
<pre>$ <strong>dislocker-fuse -p -V bitlocker-image.raw -- -o allow_root clear</strong></pre>&#13;
<p class="indent">You can also decrypt the BitLocker image and save it separately as a regular filesystem image (only the specified volume is saved, not the partition table or other partitions). This will take some time depending on the size of the BitLocker image, as the entire image is decrypted and written to a new image file on the disk. You’ll need to do some capacity planning, because the two images, encrypted and decrypted, will take up space on the acquisition host. You can create a decrypted version of the volume as follows:</p>&#13;
<pre># <strong>dislocker-file -u -V bitlocker-image.raw bitlocker-image.clear</strong><br/>Enter the user password:<br/># <strong>ls -hs</strong><br/>total 15G<br/>7.4G bitlocker-image.clear  7.4G bitlocker-image.raw</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_247"/>The resulting decrypted image file is the same size as the original because each BitLocker block was decrypted and the cleartext block written to the new image. This command does not need root privileges.</p>&#13;
<p class="indent">Now you can mount the decrypted BitLocker image file and access it as a partition using a <code>mount</code> command with a <code>loop</code> option:</p>&#13;
<pre># <strong>mkdir files</strong><br/># <strong>mount -o loop,ro bitlocker-image.clear files</strong><br/># <strong>ls files/</strong><br/>Penguins.jpg  private/  System Volume Information/</pre>&#13;
<p class="indent">The only command that is different for non-root use is <code>mount</code>:</p>&#13;
<pre>$ <strong>sudo mount -o loop,ro,uid=holmes bitlocker-image.clear files</strong></pre>&#13;
<p class="indent">Because BitLocker is the default filesystem encryption on the dominant OS platform, it’s worth providing a second example using a different software package. The libbde package (written by Joachim Metz, the author of ewflib) also provides libraries and tools to access BitLocker images.</p>&#13;
<p class="indent">The example shown next is slightly more complex than the previous one, because it involves a notebook disk with a regular partition table (in contrast to a USB thumb drive without a partition table). After calculating the offsets from the mmls output, the bdeinfo tool is demonstrated to provide a compact overview of the BitLocker container.</p>&#13;
<p class="indent">Both dislocker and libbde can be given a byte offset for the start of the BitLocker-encrypted volume. But this is unnecessary when working with image files of volumes/partitions or devices without partitions. In this example, an acquired image has a partition table, and the BitLocker-encrypted volume offset (in bytes) must be calculated.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong>NOTE</strong></p>&#13;
<p class="notep"><em>Always be sure about the units used for a command. Some tools use sector offsets, and others use byte offsets. It is important to distinguish and convert between the two.</em></p>&#13;
</div>&#13;
<p class="indent">The next example demonstrates how to determine the byte offset. The Sleuth Kit <code>mmls</code> command displays the partition table and the sector offsets for each partition. The sector offset must be converted into a byte offset, which can be used with the decryption tools:</p>&#13;
<pre># <strong>mmls image0.raw</strong><br/>DOS Partition Table<br/>Offset Sector: 0<br/>Units are in 512-byte sectors<br/><br/>     Slot    Start        End          Length       Description<br/>00:  Meta    0000000000   0000000000   0000000001   Primary Table (#0)<br/>01:  -----   0000000000   0000002047   0000002048   Unallocated<br/>02:  00:00   0000002048   0004098047   0004096000   NTFS (0x07)<br/>03:  00:01   0004098048   0625140399   0621042352   NTFS (0x07)<br/>04:  -----   0625140400   0625142447   0000002048   Unallocated<br/># <strong>echo $((4098048*512))</strong><br/>2098200576</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_248"/>You can convert the sector offset shown by <code>mmls</code> to a byte offset by multiplying by the sector size. On the command line it is convenient to use Bash math expansion. In this example, the sector offset is 4098048 and the sector size is 512. Multiplying these gives a byte offset of 2098200576. You can use this value for the <code>bdeinfo</code> command as follows:</p>&#13;
<pre># <strong>bdeinfo -o 2098200576 image0.raw</strong><br/>bdeinfo 20160119<br/><br/>BitLocker Drive Encryption information:<br/>        Encryption method:              AES-CBC 128-bit with Diffuser<br/>        Volume identifier:              5f61cbf2-75b5-32e5-caef-537fce3cf412<br/>        Creation time:                  Jan 10, 2014 17:43:50.838892200 UTC<br/>        Description:                    Notebook System 15.01.2014<br/>        Number of key protectors:       2<br/><br/>Key protector 0:<br/>        Identifier:                     3cd1fd6c-2ecb-2dc7-c150-839ce9e710b6<br/>        Type:                           TPM<br/><br/>Key protector 1:<br/>        Identifier:                     837ef544-e1ca-65c1-a910-83acd492bc1a<br/>        Type:                           Recovery password<br/>...</pre>&#13;
<p class="indent">The <code>bdemount</code> command operates similarly to the <code>dislocker</code> command and creates a virtual file that represents the decrypted image (the full key has been shortened here):</p>&#13;
<pre># <strong>mkdir raw</strong><br/># <strong>bdemount -o 2098200576 -r 630641-...-154814 image.raw raw</strong></pre>&#13;
<p class="indent">The file will appear in the <em>./raw</em> directory, where you can analyze it directly or mount it to a loop device for regular browsing. The mount commands are the same as the previous BitLocker example, so they’re not repeated here.</p>&#13;
<h4 class="h4" id="ch08lev2sec09"><em><strong>Apple FileVault</strong></em></h4>&#13;
<p class="noindenta">Apple’s filesystem encryption built into OS X is FileVault. It is also a block-level encryption system, and several open source tools are available to decrypt it. Two tools I’ll describe here are libfvde and VFDecrypt. (The libfvde software package was written by Omar Choudary and Joachim Metz, and you’ll find it at <em><a href="https://github.com/libyal/libfvde/">https://github.com/libyal/libfvde/</a></em>.)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_249"/>Before you use the libfvde tools, you need to calculate the correct byte offset of the FileVault-encrypted volume. The <code>mmls</code> command provides the sector offset of the volume, which needs to be converted to bytes:</p>&#13;
<pre># <strong>mmls image.raw</strong><br/>GUID Partition Table (EFI)<br/>Offset Sector: 0<br/>Units are in 512-byte sectors<br/><br/>     Slot    Start        End          Length       Description<br/>00:  Meta    0000000000   0000000000   0000000001   Safety Table<br/>01:  -----   0000000000   0000000039   0000000040   Unallocated<br/>02:  Meta    0000000001   0000000001   0000000001   GPT Header<br/>03:  Meta    0000000002   0000000033   0000000032   Partition Table<br/>04:  00      0000000040   0000409639   0000409600   EFI System Partition<br/>05:  01      0000409640   0235708599   0235298960   HDD<br/>06:  02      0235708600   0236978135   0001269536   Recovery HD<br/>07:  -----   0236978136   0236978175   0000000040   Unallocated<br/># <strong>echo $((409640*512))</strong><br/>209735680</pre>&#13;
<p class="indent">Multiplying the sector offset by the sector size using simple Bash math expansion provides a byte offset of 209735680, which you can use for the fvdeinfo and fvdemount tools.</p>&#13;
<p class="indent">The fvdeinfo tool provides an overview of the FileVault-encrypted volume:</p>&#13;
<pre># <strong>fvdeinfo -o 209735680 image.raw</strong><br/>fvdeinfo 20160108<br/><br/>Core Storage information:<br/><br/>Physical volume:<br/>        Size: 120473067520             bytes<br/>        Encryption method:             AES XTS<br/><br/>Logical volume:<br/>        Size:                          120137519104 bytes</pre>&#13;
<p class="indent">To decrypt the FileVault volume, you need to recover the <em>EncryptedRoot.plist.wipekey</em> file and provide either a user password or recovery key. You can find and extract the <em>wipekey</em> file using Sleuth Kit tools, as shown here:</p>&#13;
<pre># <strong>fls -r -o 235708600 image.raw | grep EncryptedRoot.plist.wipekey</strong><br/>+++++ r/r 1036: EncryptedRoot.plist.wipekey<br/># <strong>icat -o 235708600 image.raw 1036 &gt; EncryptedRoot.plist.wipekey</strong></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_250"/>The recursive fls output of the Recovery HD partition uses the sector offset found with mmls. The output is grepped for the <em>EncryptedRoot.plist.wipekey</em> file. After it’s found, the icat tool is used to extract it (using the inode, which is 1036 in this example). Notice how a sector offset was used with fls and icat, and not a byte offset.</p>&#13;
<p class="indent">The 24-character recovery key is used with the <code>-r</code> flag and the now-recovered <em>EncryptedRoot.plist.wipekey</em> file. You can then use this key to create a FUSE mount of a decrypted representation of the volume, as shown here (the recovery key has been shortened):</p>&#13;
<pre># <strong>mkdir clear</strong><br/># <strong>fvdemount -o 209735680 -r FKZV-...-H4PD -e EncryptedRoot.plist.wipekey image.raw</strong><br/>    <strong>clear</strong><br/>fvdemount 20160108<br/><br/># <strong>ls -l clear</strong><br/>total 0<br/>-r--r--r-- 1 root root 120137519104 Jan 20 22:23 fvde1<br/>...</pre>&#13;
<p class="indent">You can provide a user password (<code>-p</code>) instead of a recovery key (<code>-r</code>), and also using the <em>EncryptedRoot.plist.wipekey</em> file, you can access the resulting volume image with regular forensic tools. An example using Sleuthkit’s fsstat on the decrypted volume is shown here:</p>&#13;
<pre># <strong>fsstat clear/fvde1</strong><br/>FILE SYSTEM INFORMATION<br/>--------------------------------------------<br/>File System Type: HFS+<br/>File System Version: HFS+<br/><br/>Volume Name: HDD<br/>...</pre>&#13;
<p class="indent">You can also mount this decrypted volume as a regular filesystem for browsing, as follows:</p>&#13;
<pre># <strong>mkdir files</strong><br/># <strong>mount -o loop,ro clear/fvde1 files</strong><br/># <strong>ls -l files</strong><br/>total 8212<br/>drwxrwxr-x 1 root   80      50 Mar  2  2015 Applications/<br/>drwxr-xr-x 1 root root      39 Jun  2  2015 bin/<br/>drwxrwxr-t 1 root   80       2 Aug 25  2013 cores/<br/>dr-xr-xr-x 1 root root       2 Aug 25  2013 dev/<br/>...</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_251"/>When the analysis work is complete, you’ll need to do some cleanup:</p>&#13;
<pre># <strong>umount files</strong><br/># <strong>rmdir files</strong><br/># <strong>fusermount -u clear</strong><br/># <strong>rmdir clear</strong></pre>&#13;
<p class="indent">Note that the preceding examples were done with root privileges to reduce complexity and make them easier to understand. Most of the commands can be done as non-root with a few exceptions. Examples in which a command is different when run by a nonprivileged user are shown here:</p>&#13;
<pre>$ <strong>fvdemount -o 209735680 -r FKZV-...-H4PD -e EncryptedRoot.plist.wipekey image.raw</strong><br/>    <strong>-X allow_root clear</strong><br/>$ <strong>sudo mount -o loop,ro clear/fvde1 files</strong><br/>$ <strong>sudo ls files/Users/somebody/private/directory</strong><br/>$ <strong>sudo umount files</strong></pre>&#13;
<p class="indent">The <code>-X allow_root</code> string in the <code>fvdemount</code> command allows root to access the FUSE mounted directory. The <code>sudo</code> command is needed to mount and unmount the hfsplus filesystem. When you’re browsing the filesystem, you might also need the <code>sudo</code> command if filesystem permissions restrict access to files or directories.</p>&#13;
<p class="indent">Several other notable open source tools exist for operating on File-Vault images. The VFDecrypt tool also provides decryption of FileVault images. Originally written by Ralf-Philipp Weinmann, David Hulton, and Jacob Appelbaum, it is now maintained by Drake Allegrini. You’ll find it at <em><a href="https://github.com/andyvand/VFDecrypt/">https://github.com/andyvand/VFDecrypt/</a></em>. It can decrypt an image into an unencrypted volume image.</p>&#13;
<p class="indent">FileVault Cracking software was created by some of the same authors as VFDecrypt; you’ll find it at <em><a href="http://openciphers.sourceforge.net/oc/vfcrack.php">http://openciphers.sourceforge.net/oc/vfcrack.php</a></em>.</p>&#13;
<h4 class="h4" id="ch08lev2sec10"><em><strong>Linux LUKS</strong></em></h4>&#13;
<p class="noindenta">A number of file encryption systems are available in the open source world. Some, like eCryptfs or encfs, are directory based. Others, like GPG and various crypt tools, operate on individual files.</p>&#13;
<p class="indent">In this section, I mainly focus on the LUKS encryption system, but I’ll also touch on plain dm-crypt and loop-AES. Using the cryptsetup tool, you can set up all three. (You can also use the cryptsetup tool to manage True-Crypt volumes, which I’ll describe in the following section.)</p>&#13;
<p class="indent">The examples that follow operate on a forensically acquired image with a LUKS-encrypted filesystem. We’ll create a block device representing the decrypted content of an encrypted filesystem and show methods to safely mount the filesystem structure for browsing with regular tools. The three goals are to get information about the encryption, create a device that can be accessed with forensic tools, and safely mount the filesystem for regular browsing.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_252"/>The first step requires the byte offset of the LUKS-encrypted partition. The sector offset is shown by Sleuth Kit’s <code>mmls</code> of the image file. The byte offset is the sector offset multiplied by the sector size, which is calculated to be 1048576 using simple Bash math expansion:</p>&#13;
<pre># <strong>mmls luks.raw</strong><br/>DOS Partition Table<br/>Offset Sector: 0<br/>Units are in 512-byte sectors<br/><br/>     Slot    Start        End          Length       Description<br/>00:  Meta    0000000000   0000000000   0000000001   Primary Table (#0)<br/>01:  -----   0000000000   0000002047   0000002048   Unallocated<br/>02:  00:00   0000002048   0058626287   0058624240   Linux (0x83)<br/># <strong>echo $((2048*512))</strong><br/>1048576</pre>&#13;
<p class="indent">You can use the byte offset to create a loop device of the encrypted partition by employing <code>losetup</code> as follows:</p>&#13;
<pre># <strong>losetup --read-only --find --show -o 1048576 luks.raw</strong><br/>/dev/loop0</pre>&#13;
<p class="indent">The LUKS-encrypted partition is now accessible as a block device, which the cryptsetup tool can use. You can find information about the encrypted partition using cryptsetup’s <code>luksDump</code> command:</p>&#13;
<pre># <strong>cryptsetup luksDump /dev/loop0</strong><br/>LUKS header information for /dev/loop0<br/><br/>Version:        1<br/>Cipher name:    aes<br/>Cipher mode:    xts-plain64<br/>Hash spec:      sha1<br/>Payload offset: 4096<br/>MK bits:        256<br/>MK digest:      8b 88 36 1e d1 a4 c9 04 0d 3f fd ba 0f be d8 4c 9b 96 fb 86<br/>MK salt:        14 0f 0d fa 7b c3 a2 41 19 d4 6a e4 8a 16 fe 72<br/>                88 78 a2 18 7b 0f 74 8e 26 6d 94 23 3d 11 2e aa<br/>MK iterations:  172000<br/>UUID:           10dae7db-f992-4ce4-89cb-61d126223f05<br/><br/>Key Slot 0: ENABLED<br/>        Iterations:             680850<br/>        Salt:                   8a 39 90 e1 f9 b6 59 e1 a6 73 30 ea 73 d6 98 5a<br/>                                e1 d3 b6 94 a0 73 36 f7 00 68 a2 19 3f 09 62 b8<br/>        Key material offset:    8<br/>        AF stripes:             4000<br/>Key Slot 1: DISABLED<br/>Key Slot 2: DISABLED<br/>Key Slot 3: DISABLED<br/>Key Slot 4: DISABLED<br/>Key Slot 5: DISABLED<br/>Key Slot 6: DISABLED<br/>Key Slot 7: DISABLED</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_253"/>The key slots can be of interest from a forensics perspective. A LUKS volume can have up to eight keys, meaning there are potentially eight different passwords where you can attempt recovery.</p>&#13;
<p class="indent">With the password to the LUKS-encrypted filesystem, you can use cryptsetup’s <code>open</code> command on the loop0 device to create a mapper device. This device provides a decrypted representation of the encrypted image. The mapper device is named <em>clear</em> in this example:</p>&#13;
<pre># <strong>cryptsetup -v --readonly open /dev/loop0 clear</strong><br/>Enter passphrase for /hyb/luks/luks.raw:<br/>Key slot 0 unlocked.<br/>Command successful.</pre>&#13;
<p class="indent">The encrypted loop device is opened with the <code>--readonly</code> flag. The verbose (<code>-v</code>) flag is also given to provide more information about the success of the decryption key. After a successful key has been entered, a new (decrypted) partition device will appear in the <em>/dev/mapper</em> directory and can be operated on using standard forensic tools. For example, you can run the Sleuth Kit fsstat tool:</p>&#13;
<pre># <strong>fsstat /dev/mapper/clear</strong><br/>FILE SYSTEM INFORMATION<br/>--------------------------------------------<br/>File System Type: Ext4<br/>Volume Name: My Secrets<br/>Volume ID: ba673056efcc5785f046654c00943860<br/>...</pre>&#13;
<p class="indent">You can also mount this partition device on the local machine for regular browsing:</p>&#13;
<pre># <strong>mkdir clear</strong><br/># <strong>mount --read-only /dev/mapper/clear clear</strong><br/># <strong>ls clear</strong><br/>lost+found/  the plan.txt</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_254"/>Once the examination work is complete, the cleanup process can take place. Each step is done in reverse:</p>&#13;
<pre># <strong>umount clear</strong><br/># <strong>rmdir clear</strong><br/># <strong>cryptsetup close clear</strong><br/># <strong>losetup --detach /dev/loop0</strong></pre>&#13;
<p class="indent">Note that this is a simplified example of a single partition on a single non-bootable data disk. A LUKS-encrypted disk with an bootable OS may have an additional Logical Volume Manager (LVM) layer. Such disks may have additional devices that appear in the <em>/dev/mapper</em> directory (root, swap, and so on). You can access or mount each of these devices individually. During the cleanup process, you need to remove the partition devices with dmsetup before closing the LVM device with cryptsetup.</p>&#13;
<p class="indent">For simplicity, the steps shown in this section were performed as a root user. To run the examples as a non-root user, <code>losetup</code>, <code>cryptsetup</code>, <code>mount</code>, and <code>umount</code> need <code>sudo</code> to execute, as do any tools that access the <em>/dev/mapper</em> partition device. Depending on the filesystem mounted, additional user options may be useful (<code>uid=holmes</code> for example).</p>&#13;
<p class="indent">Images encrypted with plain dm-crypt and loop-AES can also be decrypted using the cryptstetup tool. These follow a similar process as the preceding LUKS example. The cryptsetup <code>open</code> command needs to have either <code>plain</code> or <code>loopaes</code> specified using the <code>--type</code> flag. For example:</p>&#13;
<pre># <strong>cryptsetup -v --readonly open --type plain /dev/loop0 clear</strong><br/>Enter passphrase:<br/>Command successful.</pre>&#13;
<p class="indent">Using <code>--type loopaes</code> will also require a key file. Specifying <code>--type luks</code> is also possible, but unnecessary, because it’s the default.</p>&#13;
<p class="indent">You’ll find more information about cryptsetup and LUKS at <em><a href="https://gitlab.com/cryptsetup/cryptsetup/wikis/home/">https://gitlab.com/cryptsetup/cryptsetup/wikis/home/</a></em>. And you’ll find a compatible Windows implementation at <em><a href="https://github.com/t-d-k/librecrypt/">https://github.com/t-d-k/librecrypt/</a></em>.</p>&#13;
<h4 class="h4" id="ch08lev2sec11"><em><strong>TrueCrypt and VeraCrypt</strong></em></h4>&#13;
<p class="noindenta">After development of TrueCrypt was stopped, several forks emerged. The dominating fork at the moment is VeraCrypt. It offers backward compatibility as well as new extensions.</p>&#13;
<p class="indent">The two examples of VeraCrypt I’ll provide are a normal encrypted container and a hidden container. I used the standard command line version of VeraCrypt in conjunction with familiar tools to make the containers available for further analysis.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_255"/>The first example shows a simple encrypted TrueCrypt or VeraCrypt container file. The <code>--file-system=none</code> flag is important because it prevents VeraCrypt from mounting any filesystems:</p>&#13;
<pre>$ <strong>veracrypt --mount-options=readonly --filesystem=none secrets.tc</strong><br/>Enter password for /exam/secrets.tc:<br/>Enter PIM for /exam/secrets.tc:<br/>Enter keyfile [none]:</pre>&#13;
<p class="indent">Using the <code>-l</code> flag, you can list all the decrypted containers on the host system by slot number. The slot number is an important identifier to use in subsequent commands. In this example, the slot number is <code>1</code> and the familiar <code>/dev/mapper/*</code> directory is used:</p>&#13;
<pre>$ <strong>veracrypt -l</strong><br/>1: /exam/secrets.tc /dev/mapper/veracrypt1 -</pre>&#13;
<p class="noindent">After providing the correct credentials, you can request more information about the container by specifying the slot number, as shown here:</p>&#13;
<pre>$ <strong>veracrypt --volume-properties --slot=1</strong><br/>Slot: 1<br/>Volume: /exam/secrets.tc<br/>Virtual Device: /dev/mapper/veracrypt1<br/>Mount Directory:<br/>Size: 2.0 GB<br/>Type: Normal<br/>Read-Only: Yes<br/>Hidden Volume Protected: No<br/>Encryption Algorithm: AES<br/>Primary Key Size: 256 bits<br/>Secondary Key Size (XTS Mode): 256 bits<br/>Block Size: 128 bits<br/>Mode of Operation: XTS<br/>PKCS-5 PRF: HMAC-SHA-512<br/>Volume Format Version: 2<br/>Embedded Backup Header: Yes</pre>&#13;
<p class="indent">Two devices have been created. The device <em>/dev/loop0</em> is encrypted as a raw image (the same as the file on the filesystem). The device shown in the volume properties, <em>/dev/mapper/veracrypt1</em>, is the decrypted volume, which you can operate on directly using forensic tools. Here is an example of Sleuth Kit examining the filesystem:</p>&#13;
<pre>$ <strong>sudo fls /dev/mapper/veracrypt1</strong><br/>r/r * 4:        photo.jpg<br/>r/r 6:  spy-photo.jpg<br/>v/v 66969091:   $MBR<br/>v/v 66969092:   $FAT1<br/>v/v 66969093:   $FAT2<br/>d/d 66969094:   $OrphanFiles</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_256"/>You can also mount the mapper device on the local machine and browse the filesystem with regular tools, like this:</p>&#13;
<pre>$ <strong>mkdir clear</strong><br/>$ <strong>sudo mount -o ro,uid=holmes /dev/mapper/veracrypt1 clear</strong><br/>$ <strong>ls -l clear</strong><br/>total 360<br/>-rwxr-x--- 1 holmes root 366592 Jan 21 23:41 spy-photo.jpg</pre>&#13;
<p class="indent">Obviously, deleted files will not be visible in the user-mounted area; they will only be visible when you use forensic tools via the <em>/dev/mapper/veracrypt1</em> device.</p>&#13;
<p class="indent">Again, the cleanup process is the reverse of the setup process:</p>&#13;
<pre>$ <strong>sudo umount clear</strong><br/>$ <strong>rmdir clear</strong><br/>$ <strong>veracrypt -d --slot=1</strong></pre>&#13;
<p class="indent">The second VeraCrypt example I’ll provide shows how to access a hidden volume. One feature of TrueCrypt and VeraCrypt is that it’s possible to have two passwords that reveal two separate volumes. The use of both passwords is compared in the two command outputs below.</p>&#13;
<p class="indent">Here, <em>hidden.raw</em> is a VeraCrypt drive containing a hidden volume. Providing the first password produces a functioning standard TrueCrypt container with files, claiming the full 1GB capacity of the drive and showing <code>Type: Normal</code>:</p>&#13;
<pre>$ <strong>ls -l</strong><br/>total 3098104<br/>-rw-r----- 1 holmes holmes 1024966656 Jan 22 00:07 hidden.raw<br/>...<br/>$ <strong>veracrypt --mount-options=readonly --filesystem=none hidden.raw</strong><br/>Enter password for /exam/hidden.raw: [XXXXXXXXXXX]<br/>...<br/>$ <strong>veracrypt --volume-properties --slot=1</strong><br/>Slot: 1<br/>Volume: /exam/hidden.raw<br/>Virtual Device: /dev/mapper/veracrypt1<br/>Mount Directory:<br/>Size: 977 MB<br/>Type: Normal<br/>Read-Only: Yes<br/>...<br/>$ <strong>sudo fls /dev/mapper/veracrypt1</strong><br/>...<br/>r/r 20: fake secrets.pdf<br/>...</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_257"/>If the volume is dismounted and then mounted again using the hidden volume’s password, you’ll see a completely different set of files. The time needed to mount the volume is also different. With the container in the preceding example, 3.5 seconds was needed to unlock it, whereas unlocking the hidden container in the same file needed 29 seconds. This is because the standard volume decryption is attempted first (with all supported algorithms), and upon failing, the decryption of a hidden volume is finally tried. In the volume properties, the real size is now shown together with <code>Type: Hidden</code>, as shown here:</p>&#13;
<pre>$ <strong>veracrypt -d --slot=1</strong><br/>$ <strong>veracrypt --mount-options=readonly --filesystem=none hidden.raw</strong><br/>Enter password for /exam/hidden.raw: [YYYYYYYYYYY]<br/>...<br/>$ <strong>veracrypt --volume-properties --slot=1</strong><br/>Slot: 1<br/>Volume: /exam/hidden.raw<br/>Virtual Device: /dev/mapper/veracrypt1<br/>Mount Directory:<br/>Size: 499 MB<br/>Type: Hidden<br/>Read-Only: Yes<br/>...<br/>$ <strong>sudo fls /dev/mapper/veracrypt1</strong><br/>...<br/>r/r 19: the real hidden secrets.pdf<br/>...</pre>&#13;
<p class="indent">The mapped device of a hidden volume produces a filesystem that you can directly analyze with forensic tools.</p>&#13;
<p class="indent">TrueCrypt and VeraCrypt volumes can also be managed by newer versions of cryptsetup (version 1.6.7 and later), providing you with similar mounting possibilities.</p>&#13;
<p class="indent">There are commercial and open source cracking tools for TrueCrypt/VeraCrypt containers, but their use is beyond the scope of this book.</p>&#13;
<h3 class="h3" id="ch08lev1sec04"><span epub:type="pagebreak" id="page_258"/><strong>Closing Thoughts</strong></h3>&#13;
<p class="noindent">In this chapter, you learned to make acquired image files available as block devices, create partition devices, and safely make them available for use with regular filesystem tools. You also learned to use loop devices and became more familiar with <em>/dev/mapper</em> devices. I showed tips for booting up suspect images and demonstrated methods for accessing VM images from various VM formats. Finally, you learned how to make a variety of encrypted filesystems available for access in decrypted form.</p>&#13;
</body></html>