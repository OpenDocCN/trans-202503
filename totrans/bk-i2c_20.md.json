["```\n40 04 01 02 03 04\n40 24\n41 `ww xx yy zz`\n```", "```\n// attiny84_Periph.ino\n//\n// Implements a simple I2C peripheral\n// running on a SparkFun Atto84 (ATtiny84).\n//\n// I2C protocol for this device:\n//\n// For I2C write operations:\n//\n//  |adrs+W| cmd | optional Data |\n//\n//  cmd:\n//      00drrsss\n//\n// where d is 0 for write operation and 1 for read,\n// rr specifies a \"register number\" (which is an index\n// into \"i2c_regs\" array below), and sss is a size (0-4).\n//\n// For write operations (d = 0) then, there will be sss\n// additional bytes (max 4) following the cmd byte.\n// These bytes will be written to i2c_regs starting\n// at offset rr (wrapping around to the beginning\n// of the array if sss+rr >= 4).\n//\n// For read operations (d = 1), any additional data beyond\n// the cmd byte is ignored (up to the stop condition).\n//\n// For I2C read operations:\n//\n//  |adrs+R| Data |\n//\n// where \"Data\" is the number of bytes specified by the\n// last I2C write operation with d = 1 (number of bytes will\n// be sss). Data transferred is from i2c_regs starting at\n// location rr (from the last write operation).\n//\n// Consecutive I2C read operations, without intervening\n// writes, will read the same locations from the registers.\n\n#define I2C_PERIPH_ADDRESS 0x20 // The 7-bit address\n\n#define __AVR_ATtiny84__\nextern \"C\" {\n  #include <inttypes.h>\n  #include \"usiI2CPeriph.h\"\n  #include <avr/interrupt.h>\n  }\n\n#include \"Arduino.h\"\n```", "```\n// attiny84_Periph.ino (cont.)\n//\n// 4-byte R/W register area\n// for this sample program:\n\nvolatile uint8_t i2c_regs[4] =\n{\n    0xDE,\n    0xAD,\n    0xBE,\n    0xEF,\n};\n\n// Tracks the current register pointer position\n// for read and write operations.\n//\n// *_position holds the index into i2c_regs\n// where I2C reads and writes will begin.\n//\n// *size holds the number of bytes for\n// the read/write operation.\n\nvolatile byte reg_position;    // For writes\nvolatile byte size;            // For writes\n\nvolatile size_t read_position; // For reads\nvolatile size_t read_size;     // For reads\n\nconst byte reg_size = sizeof( i2c_regs );\n\n// Command byte bits:\n\n#define cmdSizeMask (0b000111)\n#define cmdRegMask  (0b011000)\n#define cmdDirMask  (0b100000)\n```", "```\n// attiny84_Periph.ino (cont.)\n//\n// requestHandledEvent-\n//\n// Called after data has been shipped\n// to the controller.\n\nvoid requestHandledEvent()\n{\n}\n```", "```\n// attiny84_Periph.ino (cont.)\n//\n// requestEvent-\n//\n// Called before data has been shipped\n// to the controller.\n\nvoid requestEvent()\n{\n        for( size_t i=0; i < read_size; ++i )\n        {\n            size_t index = (read_position+i) %  reg_size;\n            usiI2CTransmitByte( i2c_regs[index] );\n        }\n}\n```", "```\n// attiny84_Periph.ino (cont.)\n//\n// receiveEvent-\n//\n// Called when data has been received\n// from the controller.\n//\n// Parse the received data and set up the\n// position and size variables as needed.\n// If optional data arrives, store it into\n// the i2c_regs array.\n//\n// rcvCnt parameter specifies the\n// number of bytes received.\n\nvoid receiveEvent( uint8_t rcvCnt )\n{\n    byte cmd;\n\n    // Punt if controller sent too\n    // much data...\n\n    if( rcvCnt > I2C_RX_BUFFER_SIZE )\n    {\n        return;\n    }\n\n    // ...or too little:\n\n    if( rcvCnt > 0 )\n    {\n        cmd             = usiI2CReceiveByte();\n        size            = cmd & cmdSizeMask;\n\n        // cmdSizeMask is 3 bits, but\n        // the maximum size is 4.\n        // Enforce that here:\n\n        if( size > 4 )\n        {\n            size = 4;\n        }\n        reg_position    = cmd & cmdRegMask;\n        reg_position  >>= 3;\n\n        // Determine if the controller is\n        // specifying a read operation or a\n        // write operation. This is not the\n // R/W bit in the address byte (you\n        // got here on an I2C write). The\n        // direction bit specifies whether\n        // whether you can expect an I2C\n        // read operation after this command\n        // to read the specified data.\n\n        if( cmd & cmdDirMask )\n        {\n             // A read command, just set up\n             // the count and pointer values\n             // for any upcoming reads.\n\n            read_size = size;\n            read_position = reg_position;\n        }\n        else // A write command\n        {\n            // Copy any additional data the\n            // controller sends you to the\n            // i2c_regs array. Note that\n            // this code ignores any bytes\n            // beyond the fourth one the\n            // controller sends.\n\n            byte maxXfer = 4;\n            while( --rcvCnt && maxXfer-- )\n            {\n                i2c_regs[reg_position] = usiI2CReceiveByte();\n                reg_position++;\n                if( reg_position >= reg_size )\n                {\n                    reg_position = 0;\n                }\n            }\n        }\n    }\n}\n```", "```\n// attiny84_Periph.ino (cont.)\n//\n// Usual Arduino initialization code\n// even for an I2C peripheral application.\n\nvoid setup()\n{\n\n    // Initialize the peripheral code:\n\n    usiI2CPeripheralInit( I2C_PERIPH_ADDRESS );\n\n    // Set up callbacks to local functions:\n\n    usi_onReceiverPtr = receiveEvent;\n    usi_onRequestPtr = requestEvent;\n    usi_afterRequestPtr = requestHandledEvent;\n}\n```", "```\n// attiny84_Periph.ino (cont.)\n//\n// The main loop does nothing but spin its\n// wheels. All the work in this sample\n// program is done inside the ISRs and\n// callback functions. If this peripheral\n// were a little more complex, background\n// activities could be taken care of here.\n\nvoid loop()\n{\n    // Do nothing.\n}\n```", "```\n// usiI2CPeriph.c\n//\n// USI I2C Peripheral driver.\n// \n// Created by Donald R. Blake, donblake at worldnet.att.net.\n// Adapted by Jochen Toppe, jochen.toppe at jtoee.com.\n// Further modifications by Randall Hyde for \"The Book of I2C.\"\n// \n// ----------------------------------------------------------\n// \n// Created from Atmel source files for Application Note \n// AVR312: Using the USI Module as an I2C peripheral.\n\n#include <avr/io.h>\n#include <avr/interrupt.h>\n\n#include \"usiI2CPeriph.h\"\n\n#define breakif(x) if(x) break\n\n// Device dependent defines:\n\n#define DDR_USI             DDRA\n#define PORT_USI            PORTA\n#define PIN_USI             PINA\n#define PORT_USI_SDA        PORTA6\n#define PORT_USI_SCL        PORTA4\n#define PIN_USI_SDA         PINA6\n#define PIN_USI_SCL         PINA4\n#define USI_START_COND_INT  USISIF\n#define USI_START_VECTOR    USI_START_vect\n#define USI_OVERFLOW_VECTOR USI_OVF_vect\n\n// These macros make the stop condition detection code \n// more readable.\n\n#define USI_PINS_SCL_SDA            \\\n    (                               \\\n            ( 1 << PIN_USI_SDA )    \\\n        |   ( 1 << PIN_USI_SCL )    \\\n    )\n\n#define USI_PINS_SDA     ( 1 << PIN_USI_SDA )\n#define USI_PINS_SCL     ( 1 << PIN_USI_SCL )\n```", "```\n// usiI2CPeriph.c (cont.)\n//\n/***********************************************************\n\n                     typedef's\n\n************************************************************/\n\n// ISRstate_t are the different states possible for\n// the ISR state machine that handles incoming\n// bytes from the controller.\n\ntypedef enum\n{\n    // Address byte has just arrived:\n\n    USI_PERIPH_CHECK_ADDRESS                = 0x00,\n\n    // Peripheral is transmitting bytes to\n    // the controller (I2C read transaction).\n\n    USI_PERIPH_SEND_DATA                    = 0x01,\n\n    // Receive an ACK from controller after sending\n    // a byte to it.\n\n    USI_PERIPH_REQUEST_REPLY_FROM_SEND_DATA = 0x02,\n\n    // Deals with ACK or NAK received from\n    // controller after sending a byte\n    // to the controller (I2C read).\n\n    USI_PERIPH_CHECK_REPLY_FROM_SEND_DATA   = 0x03,\n\n    // Handle data coming to the peripheral\n    // (I2C write operation).\n\n    USI_PERIPH_REQUEST_DATA                 = 0x04,\n    USI_PERIPH_GET_DATA_AND_SEND_ACK        = 0x05\n} ISRstate_t;\n```", "```\n// usiI2CPeriph.c (cont.)\n//\n/***********************************************************\n\n                    local variables\n\n************************************************************/\n\n// periphAddress holds the 7-bit I2C address.\n\nstatic uint8_t              periphAddress;\nstatic uint8_t              sleep_enable_bit;\nstatic uint8_t              in_transaction;\nstatic volatile ISRstate_t  ISRstate;\n\nstatic uint8_t          rxBuf[I2C_RX_BUFFER_SIZE];\nstatic volatile uint8_t rxHead;\nstatic volatile uint8_t rxTail;\nstatic volatile uint8_t rxCount;\n\nstatic uint8_t          txBuf[I2C_TX_BUFFER_SIZE];\nstatic volatile uint8_t txHead;\nstatic volatile uint8_t txTail;\nstatic volatile uint8_t txCount;\n```", "```\n// usiI2CPeriph.c (cont.)\n//\n// Dummy functions so you don’t have to check if\n// usi_afterRequestPtr or usi_onReceiverPtr are NULL.\n\nstatic void dummy1( void ){}\nstatic void dummy2( uint8_t d ){}\n\nvoid    (*usi_afterRequestPtr)( void )    = dummy1;\nvoid    (*usi_onRequestPtr)( void )       = dummy1;\nvoid    (*usi_onReceiverPtr)( uint8_t )   = dummy2;\n```", "```\n// usiI2CPeriph.c (cont.)\n//\n/***********************************************************\n\n                    Local functions\n\n************************************************************/\n\n// Flushes the I2C buffers.\n\nstatic void flushI2CBuffers( void )\n{\n  rxTail = 0;\n  rxHead = 0;\n  rxCount = 0;\n  txTail = 0;\n  txHead = 0;\n  txCount = 0;\n} // End flushI2CBuffers\n```", "```\n// usiI2CPeriph.c (cont.)\n//\n// startSetConditionMode-\n//\n// This initializes the interrupt system so that\n// the code waits for the arrival of a start\n// condition (and generates an interrupt when\n// one arrives).\n\nstatic void setStartConditionMode( void )\n{\n    USICR =\n            // Enable Start Condition Interrupt.\n\n            ( 1 << USISIE )\n\n            // Disable Overflow Interrupt.\n\n        |   ( 0 << USIOIE )\n\n            // Set USI in two-wire mode.\n\n        |   ( 1 << USIWM1 ) \n\n // No USI Counter overflow hold.\n\n        |   ( 0 << USIWM0 )\n\n            // Shift Register Clock Source = external, \n            // positive edge.\n\n        |   ( 1 << USICS1 )\n        |   ( 0 << USICS0 ) \n\n            // 4-Bit Counter Source = external, \n            // both edges.\n\n        |   ( 0 << USICLK )\n\n            // No toggle clock-port pin.\n\n        |   ( 0 << USITC );\n\n    // Clear all interrupt flags, except Start Cond.\n\n    USISR =\n            ( 0 << USI_START_COND_INT )\n        |   ( 1 << USIOIF )\n        |   ( 1 << USIPF )\n        |   ( 1 << USIDC )\n        |   ( 0x0 << USICNT0 );\n}\n```", "```\n// usiI2CPeriph.c (cont.)\n//\n/***********************************************************\n\n                    Public functions\n\n************************************************************/\n\n// Initialize USI for I2C peripheral mode.\n\nvoid usiI2CPeripheralInit( uint8_t ownAddress )\n{\n    // Initialize the TX and RX buffers to empty.\n\n    flushI2CBuffers( );\n periphAddress = ownAddress;\n\n    // In two-wire (I2C) mode (USIWM1, USIWM0 = 1X),\n    // the peripheral USI will pull SCL low when a \n    // start condition is detected or a counter \n    // overflow (only for USIWM1, USIWM0 = 11). This\n    // inserts a wait state. SCL is released by the \n    // ISRs (USI_START_vect and USI_OVERFLOW_vect).\n    // \n    // Set SCL and SDA as output.\n\n    DDR_USI |= ( 1 << PORT_USI_SCL ) | ( 1 << PORT_USI_SDA );\n\n    // Set SCL high.\n\n    PORT_USI |= ( 1 << PORT_USI_SCL );\n\n    // Set SDA high.\n\n    PORT_USI |= ( 1 << PORT_USI_SDA );\n\n    // Set SDA as input.\n\n    DDR_USI &= ~( 1 << PORT_USI_SDA );\n\n    USICR =\n            // Enable Start Condition Interrupt.\n\n            ( 1 << USISIE )\n\n            // Disable Overflow Interrupt.\n\n       |    ( 0 << USIOIE )\n\n            // Set USI in two-wire mode.\n\n       |    ( 1 << USIWM1 ) \n\n            // No USI Counter overflow hold.\n\n       |    ( 0 << USIWM0 )\n\n           // Shift Register Clock Source = external, \n           // positive edge.\n           // 4-Bit Counter Source = external, both edges.\n\n        |   ( 1 << USICS1 ) \n        |   ( 0 << USICS0 )\n        |   ( 0 << USICLK )\n\n           // No toggle clock-port pin.\n\n       |    ( 0 << USITC );\n // Clear all interrupt flags and reset overflow counter.\n\n    USISR = \n            ( 1 << USI_START_COND_INT ) \n        |   ( 1 << USIOIF ) \n        |   ( 1 << USIPF )\n        |   ( 1 << USIDC );\n\n    // The in_transaction variable remembers if the \n    // usiI2CPeriph driver is in the middle of\n    // an I2C transaction. Initialize it to 0.\n\n    in_transaction = 0;\n\n} // end usiI2CPeripheralInit\n```", "```\n// usiI2CPeriph.c (cont.)\n//\n// usiI2CDataInTransmitBuffer-\n//\n// Return 0 (false) if the transmit buffer is empty, true\n// (nonzero) if data is available in the transmit buffer.\n\nbool usiI2CDataInTransmitBuffer( void )\n{\n    return txCount; // Actual count is nonzero\n                    // if data available :)\n} // End usiI2CDataInTransmitBuffer\n\n// usiI2CTransmitByte-\n//\n// Adds a byte to the transmission buffer, \n// wait for bytes to be transmitted \n// if buffer is full.\n//\n// Race condition warning: As this function\n// modifies txCount, it should be called only\n// from the USI_OVERFLOW_VECTOR ISR or code\n// called from it. Otherwise, there could\n// be problems with the updates of the global\n// txBuf, txHead, and txCount variables (which\n// are unprotected).\n//\n// In particular, it is safe to call this\n// function from whomever usi_afterRequestPtr,\n// usi_onRequestPtr, or usi_onReceiverPtr\n// point at, but you must not call this\n// code from the main Arduino loop or\n// setup function.\n\nvoid usiI2CTransmitByte( uint8_t data )\n{\n\n    // Wait for free space in buffer.\n\n    while( txCount == I2C_TX_BUFFER_SIZE ) ;\n\n    // Store data in buffer.\n\n    txBuf[txHead] = data;\n    txHead = ( txHead + 1 ) & I2C_TX_BUFFER_MASK;\n    txCount++;\n\n}   // End usiI2CTransmitByte\n\n// usiI2CReceiveByte-\n// \n// Return a byte from the receive \n// buffer, wait if buffer is empty. \n// As above, call this only from the\n// USI_OVERFLOW_VECTOR ISR or code\n// called by it.\n\nuint8_t usiI2CReceiveByte( void )\n{\n    uint8_t rtn_byte;\n\n    // Wait for Rx data.\n\n    while( !rxCount ); \n\n    rtn_byte = rxBuf[rxTail];\n\n    // Calculate buffer index.\n\n    rxTail = ( rxTail + 1 ) & I2C_RX_BUFFER_MASK;\n    rxCount--;\n\n    // Return data from the buffer.\n\n    return rtn_byte;\n\n}   // End usiI2CReceiveByte\n\n// usiI2CAmountDataInReceiveBuffer-\n//\n// Returns the number of bytes in the\n// receive buffer.\n\nuint8_t usiI2CAmountDataInReceiveBuffer( void )\n{\n    return rxCount;\n}\n```", "```\n// usiI2CPeriph.c (cont.)\n//\n/********************************************************\n\n                USI Start Condition ISR\n\n*********************************************************/\n\n// USI_START_VECTOR interrupt service routine.\n//\n// This ISR gets invoked whenever a start condition\n// appears on the I2C bus (assuming the USISIE/start\n// condition interrupt is enabled in USICR).\n//\n// The global variable \"in_transaction\" is nonzero if\n// this is a repeated start condition (that is, haven’t\n// seen a stop condition since the last start).\n\nISR( USI_START_VECTOR )\n{\n    uint8_t usi_pins;\n\n    // Notes about ISR. The compiler in the Arduino IDE handles \n    // some of the basic ISR plumbing (unless the \"ISR_NAKED\" \n    // attribute is applied):\n    //\n    //   * The AVR processor resets the SREG.I bit \n    //     when jumping into an ISR.\n    //   * The compiler automatically adds code to save SREG.\n    //   * < user’s ISR code goes here >\n    //   * The compiler automatically adds code to restore SREG.\n    //   * The compiler automatically uses the RETI instruction \n    //     to return from the ISR.\n    //\n    //     The RETI instruction enables interrupts after the \n    //     return from ISR.\n    //\n    // cli() call is not necessary. Processor disables \n    // interrupts when calling to an ISR.\n    //\n    // No need to save the SREG. The compiler does this \n    // automatically when using the ISR construct without \n    // modifying attributes.\n\n  ❶ if( !in_transaction )\n    {\n        // Remember the sleep enable bit when entering the ISR.\n\n        sleep_enable_bit = MCUCR & ( 1 << SE );\n\n // Clear the sleep enable bit to prevent the CPU from \n        // entering sleep mode while executing this ISR.\n\n        MCUCR &= ~( 1 << SE );\n    }\n\n    // Set default starting conditions for new I2C packet.\n\n  ❷ ISRstate = USI_PERIPH_CHECK_ADDRESS;\n\n    // Program SDA pin as input.\n\n    DDR_USI &= ~( 1 << PORT_USI_SDA );\n\n    // The start condition is that the controller pulls SDA low\n    // (while SCL is high).\n    //\n    // Wait for SCL to go low to ensure the start condition \n    // has completed (the start detector will hold SCL low);\n    // if a stop condition arises, then leave the interrupt to \n    // prevent waiting forever. Don’t use USISR to test for \n    // stop condition as in Application Note AVR312, because\n    // the stop condition flag is going to be set from the last\n    // I2C sequence.\n\n  ❸ while\n    (\n            ( usi_pins = PIN_USI & USI_PINS_SCL_SDA ) \n        ==  USI_PINS_SCL \n    ){\n        // While SCL is high and SDA is low.\n     }\n\n    // If SDA line was low at SCL edge, then start \n    // condition occurred.\n\n  ❹ if( !( usi_pins & USI_PINS_SDA ) )\n    {\n        // A stop condition did not occur.\n\n        // Execute callback if this is a repeated start.\n\n        if( in_transaction )\n        {\n            if( usiI2CAmountDataInReceiveBuffer() )\n            {\n                usi_onReceiverPtr\n                (\n                    usiI2CAmountDataInReceiveBuffer()\n                );\n            }\n        }\n\n        // Now that you’ve seen a start condition,\n // you need to dynamically enable the\n        // overflow interrupt that tells you when\n        // you’ve received a byte of data.\n\n     ❺ USICR =\n                // Keep start condition interrupt  \n                // enabled to detect RESTART.\n\n                ( 1 << USISIE )\n\n                // Enable overflow interrupt.\n\n            |   ( 1 << USIOIE )\n\n                // Set USI in two-wire mode, hold SCL\n                // low on USI Counter overflow.\n\n            |   ( 1 << USIWM1 ) \n            |   ( 1 << USIWM0 ) \n\n                // Shift register clock source = external, \n                // positive edge.\n\n            |   ( 1 << USICS1 )\n            |   ( 0 << USICS0 ) \n\n                // 4-Bit Counter Source = external, both edges.\n\n            |   ( 0 << USICLK )\n\n                // No toggle clock-port pin.\n\n            |   ( 0 << USITC );\n\n        // Remember that the USI is in a valid I2C transaction.\n\n        in_transaction = 1;\n\n    }\n    else // SDA was high\n    {\n         // A stop condition did occur; reset\n         // the interrupts to look for a new\n         // start condition.\n\n      ❻ USICR =\n                // Enable start condition interrupt.\n\n                ( 1 << USISIE )\n\n                // Disable overflow interrupt.\n\n            |   ( 0 << USIOIE )\n\n // Set USI in two-wire mode.\n\n            |   ( 1 << USIWM1 ) \n\n                // No USI counter overflow hold.\n\n            |   ( 0 << USIWM0 )\n\n                // Shift register clock source = external, \n                // positive edge.\n\n            |   ( 1 << USICS1 )\n            |   ( 0 << USICS0 )\n\n                // 4-Bit counter source = external, \n                // both edges.\n\n            |   ( 0 << USICLK )\n\n                // No toggle clock-port pin.\n\n            |   ( 0 << USITC );\n\n        // No longer in valid I2C transaction.\n\n        in_transaction = 0;\n\n        // Restore the sleep enable bit.\n\n        MCUCR |= sleep_enable_bit;\n\n    }  // end if\n\n    USISR =\n            // Clear interrupt flags - resetting the Start \n            // Condition Flag will release SCL.\n\n            ( 1 << USI_START_COND_INT ) \n        |   ( 1 << USIOIF )\n        |   ( 1 << USIPF ) \n        |   ( 1 << USIDC )\n\n            // Set USI to sample 8 bits (count 16\n            // external SCL pin toggles).\n\n        |   ( 0x0 << USICNT0);\n\n} // End ISR( USI_START_VECTOR )\n```", "```\n// usiI2CPeriph.c (cont.)\n//\n// USI Overflow ISR-\n//\n// Invoked when the shift register is full (programmable\n// size, usually 1 or 8 bits). Because the byte coming\n// in could be any part of an I2C transmission, this ISR\n// uses a state machine to track the incoming bytes. This\n// ISR handles controller reads and writes (peripheral\n// writes and reads).\n//\n// Note that this ISR is disabled when waiting for a\n// start condition to arrive (incoming bytes at that\n// point are intended for a different device).\n\nISR( USI_OVERFLOW_VECTOR )\n{\n  uint8_t finished;\n  uint8_t usi_pins;\n\n  // This ISR is only ever entered because the \n  // ISR(USI_START_VECTOR) interrupt routine ran \n  // first. That routine saved the sleep mode and \n  // disabled sleep.\n  //\n  // ISRstate is the state machine variable for\n  // the overflow.\n\n  // Most of the time this routine exits, it has set up the \n  // USI to shift in/out bits and is expected to have re-entered \n  // because of the USI overflow interrupt. Track whether or\n  // not the transaction is completely finished.\n\n  finished = 0;\n```", "```\n// usiI2CPeriph.c (cont.)\n\n  switch ( ISRstate )\n  {\n\n    // Address mode: \n    // Check address and send ACK (and next \n    // USI_PERIPH_SEND_DATA) if OK, else reset USI.\n\n    case USI_PERIPH_CHECK_ADDRESS:\n        if( \n                ( USIDR == 0 ) \n            ||  (( USIDR >> 1 ) == periphAddress ) \n        ){\n            if( USIDR & 0x01 ) // Controller read request?\n            {\n                ISRstate = USI_PERIPH_SEND_DATA;\n                usi_onRequestPtr();\n\n            }\n            else    // Must be controller write operation\n            {\n                ISRstate = USI_PERIPH_REQUEST_DATA;\n            }       // end if\n\n            // Acknowledge the start frame.\n            // Sets up the USI to pull SDA low\n            // and clock 1 bit (two edges).\n\n            USIDR = 0; // Prepare ACK, acknowledge is a single 0 \n\n            // Set SDA data direction as output.\n\n            DDR_USI |= ( 1 << PORT_USI_SDA );\n\n            // Clear all interrupt flags, except start cond.\n\n            USISR = \n                    ( 0 << USI_START_COND_INT ) \n                |   ( 1 << USIOIF ) \n                |   ( 1 << USIPF )\n                |   ( 1 << USIDC )\n                |   ( 0x0E << USICNT0 ); // Shift 1 bit\n        }\n        else    // I2C transaction for some other device\n        {\n            setStartConditionMode();\n            finished = 1;\n        }\n        break;\n```", "```\n// usiI2CPeriph.c (cont.)\n//\n// USI_PERIPH_CHECK_REPLY_FROM_SEND_DATA-\n//\n// State that executes when you’ve received\n// an ACK or a NAK from the controller after\n// sending it a byte.\n// Check reply and go to USI_PERIPH_SEND_DATA\n// if OK, else reset USI.\n\ncase USI_PERIPH_CHECK_REPLY_FROM_SEND_DATA:\n\n    // Execute request callback after each byte’s\n    // ACK or NAK has arrived.\n\n    usi_afterRequestPtr();\n\n    if( USIDR )\n    {\n    // If NAK, the controller does not want more data.\n\n        setStartConditionMode();\n        finished = 1;\n    break;\n    }\n\n    // From here you just drop straight \n    // into USI_PERIPH_SEND_DATA if the\n    // controller sent an ACK.\n```", "```\n// usiI2CPeriph.c (cont.)\n//\n// Controller read operation (peripheral write operation).\n//\n// Copy data from buffer to USIDR and set USI to shift byte\n// next USI_PERIPH_REQUEST_REPLY_FROM_SEND_DATA.\n\ncase USI_PERIPH_SEND_DATA:\n\n    // Get data from buffer.\n\n    if( txCount )\n    {\n        USIDR = txBuf[ txTail ];\n        txTail = ( txTail + 1 ) & I2C_TX_BUFFER_MASK;\n        txCount--;\n\n        ISRstate = \n            USI_PERIPH_REQUEST_REPLY_FROM_SEND_DATA;\n\n        DDR_USI |=  ( 1 << PORT_USI_SDA );\n\n        // Clear all interrupt flags, except start cond.\n\n        USISR    =  \n            ( 0 << USI_START_COND_INT ) \n            |   ( 1 << USIOIF ) \n            |   ( 1 << USIPF ) \n            |   ( 1 << USIDC) \n            |   ( 0x0 << USICNT0 ); // Shift 8 bits\n    }\n    else\n    {\n        // The buffer is empty.\n\n        // Read an ACK:\n        //\n        // This might be necessary sometimes. See \n        // http://www.avrfreaks.net/index.php?name=\n        // PNphpBB2&file=viewtopic&p=805227#805227.\n\n        DDR_USI &= ~( 1 << PORT_USI_SDA );\n        USIDR = 0; // Must ship out a 0 bit for ACK\n\n        USISR =     \n                // Clear all interrupt flags, \n                // except start cond.\n\n                ( 0 << USI_START_COND_INT ) \n            |   ( 1 << USIOIF )\n            |   ( 1 << USIPF )\n |   ( 1 << USIDC )\n\n                // Set USI ctr to shift 1 bit.\n\n            |   ( 0x0E << USICNT0 );     \n\n        setStartConditionMode();\n    } // end if\n    break;\n```", "```\n// usiI2CPeriph.c (cont.)\n//\n// This state sets up the state machine\n// to accept an ACK from the controller\n// device after sending a byte to the\n// controller (an I2C read operation).\n// \n// Set USI to sample reply from controller\n// next USI_PERIPH_CHECK_REPLY_FROM_SEND_DATA.\n\ncase USI_PERIPH_REQUEST_REPLY_FROM_SEND_DATA:\n\n    ISRstate = \n        USI_PERIPH_CHECK_REPLY_FROM_SEND_DATA;\n\n    // Read an ACK:\n\n    DDR_USI &= ~( 1 << PORT_USI_SDA );\n    USIDR = 0; // Must ship out a zero bit for ACK\n    USISR =     \n            // Clear all interrupt flags, \n            // except Start Cond.\n\n            ( 0 << USI_START_COND_INT ) \n        |   ( 1 << USIOIF )\n        |   ( 1 << USIPF )\n        |   ( 1 << USIDC )\n\n            // Set USI ctr to shift 1 bit.\n\n        |   ( 0x0E << USICNT0 );     \n\n    break;\n```", "```\n// usiI2CPeriph.c (cont.)\n//\n// Controller-send / peripheral-receive- \n//\n// Set USI to sample data from controller, \n// next: USI_PERIPH_GET_DATA_AND_SEND_ACK.\n\ncase USI_PERIPH_REQUEST_DATA:\n\n    ISRstate = USI_PERIPH_GET_DATA_AND_SEND_ACK;\n\n    // Set USI to read data.\n    //\n    // Set SDA as input.\n\n    DDR_USI &= ~( 1 << PORT_USI_SDA );\n\n    // Clear all interrupt flags, except start cond.\n\n    USISR    =\n        ( 0 << USI_START_COND_INT ) \n    |   ( 1 << USIOIF ) \n    |   ( 1 << USIPF )\n    |   ( 1 << USIDC )\n    |   ( 0x0 << USICNT0 ); // Read 8 bits\n\n    // With the code above, the USI has been set to catch the \n    // next byte if the controller sends one. While that′s\n    // going on, look for a stop condition here when the\n    // SDA line goes high after the SCL line.\n    //\n    // Wait until SCL goes high.\n\n    while\n    ( \n        !(\n                ( usi_pins = PIN_USI & USI_PINS_SCL_SDA ) \n            &   USI_PINS_SCL \n        )\n    );\n\n    // If SDA line was high at SCL edge, \n    // then not a stop condition.\n\n    breakif( usi_pins & USI_PINS_SDA );\n    while\n    ( \n            ( usi_pins = PIN_USI & USI_PINS_SCL_SDA ) \n        ==  USI_PINS_SCL\n ){\n        // Wait until SCL goes low or SDA goes high.\n    };\n\n    // If both SCL and SDA are high, then stop \n    // condition occurred.\n\n    if( usi_pins == USI_PINS_SCL_SDA )\n    {\n        if( usiI2CAmountDataInReceiveBuffer() )\n        {\n            usi_onReceiverPtr\n            ( \n                usiI2CAmountDataInReceiveBuffer() \n            );\n        }\n        setStartConditionMode();\n        finished = 1;\n    }\n\n    break;\n```", "```\n// usiI2CPeriph.c (cont.)\n//\n// This state sends an ACK to the\n// controller after receiving a byte\n// from the controller (I2C write).\n//\n// Copy data from USIDR and send ACK\n// next USI_PERIPH_REQUEST_DATA.\n\ncase USI_PERIPH_GET_DATA_AND_SEND_ACK:\n\n    // Put data into buffer and\n    // check buffer size.\n\n    if( rxCount < I2C_RX_BUFFER_SIZE )\n    {\n        rxBuf[rxHead] = USIDR;\n        rxHead = ( rxHead + 1 ) & I2C_RX_BUFFER_MASK;\n        rxCount++;\n    } \n    else \n    {\n        // Overrun, drop data.\n    }\n\n    // Next: USI_PERIPH_REQUEST_DATA\n    // (keep accepting bytes from\n    // the controller until a stop\n // condition happens).\n\n    ISRstate = USI_PERIPH_REQUEST_DATA;\n\n    // Send acknowledge.\n\n    USIDR = 0; // Prepare ACK, acknowledge is a single 0 \n\n    // Set SDA data direction as output.\n\n    DDR_USI |= ( 1 << PORT_USI_SDA );\n\n    // Clear all interrupt flags, except start cond.\n\n    USISR = \n            ( 0 << USI_START_COND_INT ) \n        |   ( 1 << USIOIF ) \n        |   ( 1 << USIPF )\n        |   ( 1 << USIDC )\n        |   ( 0x0E << USICNT0 ); // Shift 1 bit\n\n    break;\n\n  }     // End switch\n\n  if(finished)\n  {\n        // No longer in valid I2C transaction.\n\n        in_transaction = 0;\n\n        // Restore the sleep enable bit.\n        // This allows sleep but does\n        // not cause sleep; must execute\n        // the \"sleep\" instruction to \n        // actually put MCU in sleep mode.\n\n        MCUCR |= sleep_enable_bit;\n  }\n} // End ISR( USI_OVERFLOW_VECTOR )\n```", "```\n// [Listing16-1](#listinganchor16-1).ino\n//\n// A very simple Arduino application\n// that exercises the Atto84 memory\n// peripheral device.\n\n#include <Wire.h>\n#define periph (0x20) // Peripheral address\n\n// Usual Arduino initialization code.\n\nvoid setup( void )\n{\n\n    Serial.begin( 9600 );\n    delay( 1000 );\n    Serial.println( \"Test reading ATTO84\" );\n    Wire.begin();    // Initialize I2C library\n\n    // Initialize the four registers on the\n    // memory device with 0x12, 0x34, 0x56,\n    // and 0x78.\n\n    Wire.beginTransmission( periph );\n\n    // cmd byte; d=0 (W), rr=00, sss=100 (4)\n\n    Wire.write( 0b000100 );\n\n    // Register initialization data.\n\n    Wire.write( 0x12 );\n    Wire.write( 0x34 );\n    Wire.write( 0x56 );\n    Wire.write( 0x78 );\n    Wire.endTransmission();\n}\n\n// Arduino main loop.\n\nvoid loop( void )\n{\n    static int value =0;\n\n    // Send a command to the\n    // memory peripheral to set\n    // the read address and length:\n    //\n    // d = 1 (R), rr = 00, sss = 100 (4)\n\n    Wire.beginTransmission( periph );\n    Wire.write( 0b100100 );\n    Wire.endTransmission();\n\n    delayMicroseconds( 25 );\n\n    // Read the 4 bytes from\n    // the memory peripheral and\n    // display them in the\n    // Arduino Serial window.\n\n    Wire.requestFrom( periph, 4 );\n    uint8_t b = Wire.read();\n    Serial.print( b, 16 );\n    b=Wire.read();\n    Serial.print( b, 16 );\n    b=Wire.read();\n    Serial.print( \" \" );\n    Serial.print( b, 16 );\n    b=Wire.read();\n    Serial.println( b, 16 );\n\n    delay( 25 );\n }\n```"]