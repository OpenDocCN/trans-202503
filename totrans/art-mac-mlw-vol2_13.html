<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch10">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_233" aria-label="233"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch10">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">10</span></span>&#13;
<span class="CT"><span class="Sans_Dogma_B">PERSISTENCE ENUMERATOR</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="377" height="376"/></figure>&#13;
<p class="CO">In early 2014, a close friend begged me for help disinfecting his Mac. When I plopped myself in front of his screen, I saw obvious signs of a rampant adware infection: flagrant browser pop-ups, as well as a hijacked home page. Even worse, resetting his browser didn’t work; it reverted to its infected state upon each reboot, suggesting the presence of a persistent component buried somewhere deep within the system.</p>&#13;
<p class="TX">At the time, I was an experienced Windows malware analyst just beginning my foray into the world of macOS. Naively, I thought I could download a tool capable of enumerating all persistent software installed on the system to reveal the malicious component. Well-known security tools, such as Microsoft’s AutoRuns,<sup><a role="doc-noteref" id="chapter10_1" href="#chapter10-1">1</a></sup> provided such a capability for Windows systems, but I soon discovered nothing similar existed for Macs.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_234" aria-label="234"/>I returned home and spent the next few days putting together a Python script that, while embarrassingly ugly, was capable of enumerating several types of persistent software. Running the script revealed an unrecognized launch agent on my friend’s computer that turned out to be the core persistent component of the adware. Once I removed it, his Mac was as good as new.</p>&#13;
<p class="TX">Realizing that my script could benefit other Mac users, I cleaned it up and released it under the moniker KnockKnock.<sup><a role="doc-noteref" id="chapter10_2" href="#chapter10-2">2</a></sup> (Why KnockKnock? Because it tells you who’s there!) Today, KnockKnock has evolved greatly from its beginnings as a humble command line script. Now distributed as a native macOS application, it’s capable of detecting a myriad of persistently installed items on any macOS system. Coupled with an intuitive user interface (UI), integration with VirusTotal, and the ability to export its findings for ingestion into security information and event management (SIEM), it’s the first tool I run on any Mac that I suspect is infected.</p>&#13;
<p class="TX">In this chapter, I’ll walk through KnockKnock’s design and implemen- tation to give you an in-depth look at the tool and expand your understand-ing of the persistence methods that Mac malware often does (or could) abuse. In the process, we’ll go beyond the detection mechanism discussed in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, which focused solely upon the Background Task Management database, to look at other ways of persisting on macOS, including browser extensions and dynamic library hijacks. You can find the complete source code on Objective-See’s GitHub page in the KnockKnock repository at <a href="https://github.com/Objective-see/KnockKnock"><i>https://<wbr/>github<wbr/>.com<wbr/>/Objective<wbr/>-see<wbr/>/KnockKnock</i></a>.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-61"/><span class="SANS_Futura_Std_Bold_B_11">Tool Design</span></h3>&#13;
<p class="TNI">KnockKnock is a standard UI-based application (as shown in <a href="chapter10.xhtml#fig10-1">Figure 10-1</a>), but users can also execute it in the terminal as a command line tool.</p>&#13;
<figure class="IMG"><img class="img1" id="fig10-1" src="../images/Figure10-1.jpg" alt="" width="1390" height="822"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-1: KnockKnock’s user interface</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_235" aria-label="235"/>As this isn’t a book about writing UIs (thank goodness!), I won’t delve into the code related to KnockKnock’s UI. Instead, I focus mainly on its core components, such as its many plug-ins responsible for querying various aspects of the operating system to enumerate persistently installed items.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-72"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Command Line Options</span></h4>&#13;
<p class="TNI">The code for any Objective-C program starts at the standard <span class="SANS_TheSansMonoCd_W5Regular_11">main</span> function, and KnockKnock is no exception. In its <span class="SANS_TheSansMonoCd_W5Regular_11">main</span> function, KnockKnock begins by checking its program arguments to determine whether it should display its usage information or perform a command line scan (<a href="chapter10.xhtml#Lis10-1">Listing 10-1</a>).</p>&#13;
<span id="Lis10-1"/>&#13;
<pre><code>int main(int argc, const char* argv[]) {&#13;
    ...&#13;
    if((YES == [NSProcessInfo.processInfo.arguments containsObject:@"-h"]) ||&#13;
        (YES == [NSProcessInfo.processInfo.arguments containsObject:@"-help"])) {&#13;
        usage();&#13;
        goto bail;&#13;
    }&#13;
&#13;
    if(YES == [NSProcessInfo.processInfo.arguments containsObject:@"-whosthere"]) {&#13;
        ...&#13;
        cmdlineScan();&#13;
    }&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-1: Parsing command line options</span></p>&#13;
<p class="TX">You might be familiar with accessing a program’s command line arguments via the main function’s <span class="SANS_TheSansMonoCd_W5Regular_11">argv</span>. Objective-C supports this approach, but we can also access the arguments via the <span class="SANS_TheSansMonoCd_W5Regular_11">arguments</span> array of the <span class="SANS_TheSansMonoCd_W5Regular_11">processInfo</span> property in the <span class="SANS_TheSansMonoCd_W5Regular_11">NSProcessInfo</span> class. This technique has several advantages, most notably that it converts the arguments into Objective-C objects. This means, for example, that we can use the <span class="SANS_TheSansMonoCd_W5Regular_11">containsObject:</span> method to easily determine whether the user has specified a certain command line argument regardless of the order of the arguments.</p>&#13;
<p class="TX">To determine whether to run a command line scan, KnockKnock checks if the user specified the <span class="SANS_TheSansMonoCd_W5Regular_11">-whosthere</span> command line option. If so, it invokes its <span class="SANS_TheSansMonoCd_W5Regular_11">cmdlineScan</span> function to perform a scan of the system, printing out information about persistently installed items directly to the terminal.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-73"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Plug-ins</span></h4>&#13;
<p class="TNI">Because malware can persist on macOS in many ways and researchers discover new methods from time to time, KnockKnock’s design relies on the concept of what I’ll refer to as plug-ins. Each plug-in corresponds to one type of persistence and implements the logic to enumerate items of that persistence type. The plug-ins then call into other parts of KnockKnock to perform actions such as displaying each item in the UI. This modular approach provides a simple and efficient way to add support for new persistence techniques. For example, after the researcher Csaba Fitzl published the blog <span role="doc-pagebreak" epub:type="pagebreak" id="pg_236" aria-label="236"/>post “Beyond the Good Ol’ LaunchAgents -32- Dock Tile Plugins,” which detailed a new persistence strategy involving macOS Dock plug-ins,<sup><a role="doc-noteref" id="chapter10_3" href="#chapter10-3">3</a></sup> I added a corresponding detection to KnockKnock via a new plug-in within the hour.</p>&#13;
<p class="TX">Each of KnockKnock’s plug-ins inherits from a custom plug-in base class named <span class="SANS_TheSansMonoCd_W5Regular_11">PluginBase</span>, which declares properties common to all plug-ins, as well as base methods. Found in <i>PluginBase.h</i>, it includes plug-in metadata, such as a name and a description, and arrays that the plug-in populates as it encounters persisting items (<a href="chapter10.xhtml#Lis10-2">Listing 10-2</a>).</p>&#13;
<span id="Lis10-2"/>&#13;
<pre><code>@interface PluginBase : NSObject&#13;
    @property(retain, nonatomic)NSString* name;&#13;
    @property(retain, nonatomic)NSString* icon;&#13;
    @property(retain, nonatomic)NSString* description;&#13;
&#13;
    @property(retain, nonatomic)NSMutableArray* allItems;&#13;
    @property(retain, nonatomic)NSMutableArray* flaggedItems;&#13;
    @property(retain, nonatomic)NSMutableArray* unknownItems;&#13;
&#13;
    @property(copy, nonatomic) void (^callback)(ItemBase*);&#13;
    ....&#13;
@end&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-2: The base plug-in class’s properties</span></p>&#13;
<p class="TX">The class also declares various base methods (<a href="chapter10.xhtml#Lis10-3">Listing 10-3</a>).</p>&#13;
<span id="Lis10-3"/>&#13;
<pre><code>-(void)scan;&#13;
-(void)reset;&#13;
-(void)processItem:(ItemBase*)item;&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-3: The base plug-in class’s methods</span></p>&#13;
<p class="TX">Each plug-in must implement the <span class="SANS_TheSansMonoCd_W5Regular_11">scan</span> method with logic to enumerate one type of persistent item. For example, the Background Task Management plug-in will parse the Background Task Management database to extract persistent items managed by the Background Task Management subsystem, while the Browser Extension plug-in will enumerate installed browsers and, for each, extract any installed browser extensions. If researchers uncover a new persistence mechanism, we can trivially add a new plug-in with a <span class="SANS_TheSansMonoCd_W5Regular_11">scan</span> method capable of enumerating items that persist in this new way.</p>&#13;
<p class="TX">The base class’s <span class="SANS_TheSansMonoCd_W5Regular_11">scan</span> method throws an exception if called directly (<a href="chapter10.xhtml#Lis10-4">Listing 10-4</a>).</p>&#13;
<span id="Lis10-4"/>&#13;
<pre><code>@implementation PluginBase&#13;
...&#13;
-(void)scan {&#13;
    @throw [NSException exceptionWithName:kExceptName&#13;
    reason:[NSString stringWithFormat:kErrFormat, NSStringFromSelector(_cmd),&#13;
    [self class]] userInfo:nil];&#13;
}&#13;
@end&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-4: The base scan method will throw an exception if called.</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_237" aria-label="237"/>This design allows KnockKnock to easily invoke each plug-in’s <span class="SANS_TheSansMonoCd_W5Regular_11">scan</span> method without having to know anything about how each plug-in actually enumerates persistent items of its specific type. The class provides base implementations for the other two methods, <span class="SANS_TheSansMonoCd_W5Regular_11">reset</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">processItem:</span>, though plug-ins can override them if needed. (Otherwise, the plug-in will just call the base class’s implementation.)</p>&#13;
<p class="TX">Both methods affect the application’s UI. For example, when performing a UI scan, the <span class="SANS_TheSansMonoCd_W5Regular_11">reset</span> method handles situations in which a user stops and then restarts a scan, while the <span class="SANS_TheSansMonoCd_W5Regular_11">processItem:</span> method updates the UI as plug-ins uncover persistent items. During a command line scan, the <span class="SANS_TheSansMonoCd_W5Regular_11">processItem:</span> method will still keep track of detected items and print each one to the terminal once the scan completes (<a href="chapter10.xhtml#Lis10-5">Listing 10-5</a>).</p>&#13;
<span id="Lis10-5"/>&#13;
<pre><code>-(void)processItem:(ItemBase*)item {&#13;
    ...&#13;
    @synchronized(self.allItems) {&#13;
        [self.allItems addObject:item];&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-5: Updating a global list of persistent items</span></p>&#13;
<p class="TX">KnockKnock declares a static list of all plug-ins by their class name. Later, the code iterates over this list, instantiating each plug-in (<a href="chapter10.xhtml#Lis10-6">Listing 10-6</a>).</p>&#13;
<span id="Lis10-6"/>&#13;
<pre><code>static NSString* const SUPPORTED_PLUGINS[] = {@"AuthorizationPlugins",&#13;
@"BrowserExtensions", @"BTM", @"CronJobs", @"DirectoryServicesPlugins",&#13;
@"DockTiles", @"EventRules", @"Extensions", @"Kexts", @"LaunchItems",&#13;
@"DylibInserts", @"DylibProxies", @"LoginItems", @"LogInOutHooks",&#13;
@"PeriodicScripts", @"QuicklookPlugins", @"SpotlightImporters",&#13;
@"StartupScripts", @"SystemExtensions"};&#13;
&#13;
PluginBase* pluginObj = nil;&#13;
&#13;
for(NSUInteger i = 0; i &lt; sizeof(SUPPORTED_PLUGINS)/sizeof(SUPPORTED_PLUGINS[0]); i++) {&#13;
    pluginObj = [[NSClassFromString(SUPPORTED_PLUGINS[i]) alloc] init]; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-6: Initializing each plug-in by name</span></p>&#13;
<p class="TX">For each plug-in class name, KnockKnock invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">NSClassFromString</span> API, which obtains a plug-in class based on the given name.<sup><a role="doc-noteref" id="chapter10_4" href="#chapter10-4">4</a></sup> Then it invokes the class’s <span class="SANS_TheSansMonoCd_W5Regular_11">alloc</span> method to allocate an instance of the class (in other words, to create an object). Next, it invokes the newly created object’s <span class="SANS_TheSansMonoCd_W5Regular_11">init</span> method to allow the plug-in object to perform any initializations <span class="CodeAnnotation" aria-label="annotation1">❶</span>. We’ll consider some initialization examples shortly. Although not shown here, KnockKnock will then invoke each of the plug-in’s <span class="SANS_TheSansMonoCd_W5Regular_11">scan</span> methods.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_238" aria-label="238"/>&#13;
<h4 class="H2" id="sec4"><span id="h2-74"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Persistent Item Types</span></h4>&#13;
<p class="TNI">KnockKnock assigns one of three types to persistent items: file, command, or browser extension. Most persisted items are executable files, such as scripts or Mach-O binaries. However, as in the case of cron jobs, malware sometimes persists as a command; other times, it persists as a bundle of files and resources in the form of a browser extension. It’s important for KnockKnock to correctly classify items, as each type has unique characteristics. For example, a persistent file might have extractable code signing information to help us classify it. We can also hash such files to check for known malware.</p>&#13;
<p class="TX">The three item types are subclasses of a custom <span class="SANS_TheSansMonoCd_W5Regular_11">ItemBase</span> class, shown in <a href="chapter10.xhtml#Lis10-7">Listing 10-7</a>.</p>&#13;
<span id="Lis10-7"/>&#13;
<pre><code>@interface ItemBase : NSObject&#13;
    @property(nonatomic, retain)PluginBase* plugin;&#13;
&#13;
    @property BOOL isTrusted;&#13;
    @property(retain, nonatomic)NSString* name;&#13;
    @property(retain, nonatomic)NSString* path;&#13;
    @property(nonatomic, retain)NSDictionary* attributes;&#13;
&#13;
    -(id)initWithParams:(NSDictionary*)params;&#13;
    -(NSString*)pathForFinder;&#13;
    -(NSString*)toJSON;&#13;
&#13;
@end&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-7: The interface for the <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ItemBase</span> class</span></p>&#13;
<p class="TX">This base class declares various properties, such as the plug-in that discovered the item, the item’s name, and its path. Not all item types set every property. For example, commands don’t have paths, whereas files and extensions do. The <span class="SANS_TheSansMonoCd_W5Regular_11">ItemBase</span> class also implements base methods to initialize an item, return its path to show it in the Finder app, and convert it to JSON. Although objects that inherit from this base class can reimplement each method if they need to, the base class’s implementation may suffice.</p>&#13;
<p class="TX">Once a plug-in’s <span class="SANS_TheSansMonoCd_W5Regular_11">scan</span> method completes, it stores any discovered items in a plug-in property called <span class="SANS_TheSansMonoCd_W5Regular_11">allItems</span>. In a command line scan, KnockKnock converts each persistent item to JSON and appends it to a string that it prints out (<a href="chapter10.xhtml#Lis10-8">Listing 10-8</a>).</p>&#13;
<span id="Lis10-8"/>&#13;
<pre><code>NSMutableString* output = [NSMutableString string];&#13;
...&#13;
for(NSUInteger i = 0; i &lt; sizeof(SUPPORTED_PLUGINS)/sizeof(SUPPORTED_PLUGINS[0]); i++) {&#13;
    ...&#13;
    [plugin scan];&#13;
&#13;
    for(ItemBase* item in plugin.allItems) {&#13;
        ...&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_239" aria-label="239"/>        [output appendFormat:@"{%@},", [item toJSON]];&#13;
    }&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-8: Converting persistent items to JSON</span></p>&#13;
<p class="TX">Each item type implements its own logic to convert the information collected about a persistent item to JSON. Let’s take a look at the implementation of the <span class="SANS_TheSansMonoCd_W5Regular_11">toJSON</span> method for items whose type is <span class="SANS_TheSansMonoCd_W5Regular_11">File</span> (<a href="chapter10.xhtml#Lis10-9">Listing 10-9</a>).</p>&#13;
<span id="Lis10-9"/>&#13;
<pre><code>@implementation File&#13;
-(NSString*)toJSON {&#13;
    NSData* jsonData = nil;&#13;
&#13;
    jsonData =&#13;
    [NSJSONSerialization dataWithJSONObject:self.signingInfo options:kNilOptions error:NULL]; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
    NSString* fileSigs =&#13;
    [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];&#13;
&#13;
    jsonData =&#13;
    [NSJSONSerialization dataWithJSONObject:self.hashes options:kNilOptions error:NULL]; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
    NSString* fileHashes = [[NSString alloc] initWithData:jsonData encoding:&#13;
    NSUTF8StringEncoding];&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-9: Converting File object properties to JSON</span></p>&#13;
<p class="TX">First, the code makes use of the <span class="SANS_TheSansMonoCd_W5Regular_11">NSJSONSerialization</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">dataWithJSONObject:options:error:</span> method to convert various dictionaries into JSON. These dictionaries include the item’s code signing information <span class="CodeAnnotation" aria-label="annotation1">❶</span> and hashes <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The method also converts numeric values from VirusTotal scan results (<a href="chapter10.xhtml#Lis10-10">Listing 10-10</a>).</p>&#13;
<span id="Lis10-10"/>&#13;
<pre><code>NSString* vtDetectionRatio = [NSString stringWithFormat:@"%lu/%lu",&#13;
(unsigned long)[self.vtInfo[VT_RESULTS_POSITIVES] unsignedIntegerValue],&#13;
(unsigned long)[self.vtInfo[VT_RESULTS_TOTAL] unsignedIntegerValue]];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-10: Computing a detection ratio based on scan results from VirusTotal</span></p>&#13;
<p class="TX">Technically, KnockKnock itself doesn’t include logic to detect malicious code; it merely enumerates persistently installed items. This is by design, as it allows KnockKnock to detect new persistent malware even with no direct a priori knowledge of it. However, KnockKnock’s integration with VirusTotal allows it to flag already known malware by submitting a POST request with a hash of each persistent item to a VirusTotal query API. This API returns basic detection information, such as how many antivirus engines scanned the items and how many of those engines flagged it as malicious. KnockKnock converts this data into a string ratio of the form <span role="doc-pagebreak" epub:type="pagebreak" id="pg_240" aria-label="240"/><i>positive detections</i>/<i>antivirus engines</i> and then displays this result in the UI or command line output.<sup><a role="doc-noteref" id="chapter10_5" href="#chapter10-5">5</a></sup></p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">toJSON</span> method finishes by building a single string object that combines the converted dictionaries, formatted numerical values, and all other properties of the item object (<a href="chapter10.xhtml#Lis10-11">Listing 10-11</a>).</p>&#13;
<span id="Lis10-11"/>&#13;
<pre><code>NSString* json = [NSString stringWithFormat:@"\"name\": \"%@\", \"path\":&#13;
\"%@\", \"plist\": \"%@\", \"hashes\": %@, \"signature(s)\": %@, \"VT&#13;
detection\": \"%@\"", self.name, self.path, filePlist, fileHashes,&#13;
fileSigs, vtDetectionRatio];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-11: Building a JSON-ified string</span></p>&#13;
<p class="TX">It returns this string to the caller to print out. For example, on a system infected with the persistent DazzleSpy malware, KnockKnock would display the following JSON in the terminal:</p>&#13;
&#13;
<pre><code>% <b>KnockKnock.app/Contents/MacOS/KnockKnock -whosthere -pretty</b>&#13;
{&#13;
    "path" : "\/Users\/User\/.local\/softwareupdate",&#13;
    "hashes" : {&#13;
        "md5" : "9DC9D317A9B63599BBC1CEBA6437226E",&#13;
        "sha1" : "EE0678E58868EBD6603CC2E06A134680D2012C1B"&#13;
    },&#13;
    "VT detection" : "35\/76",&#13;
    "name" : "softwareupdate",&#13;
    "plist" : "\/Library\/LaunchDaemons\/com.apple.softwareupdate.plist",&#13;
    "signature(s)" : {&#13;
        "signatureStatus" : -67062&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="TX">The output shows several red flags pointing to the fact that this item is likely malicious. For example, it’s running from a hidden directory (<i>.local</i>), and while it claims to be an Apple software updater, its signature status is <span class="SANS_TheSansMonoCd_W5Regular_11">-67062</span>, which maps to the <span class="SANS_TheSansMonoCd_W5Regular_11">errSecCSUnsigned</span> constant. What conclusively identifies this item as malware, though, is the VirusTotal detection ratio, which shows that roughly half of the antivirus engines on the site flagged it as malicious.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h1-62"/><span class="SANS_Futura_Std_Bold_B_11">Exploring the Plug-ins</span></h3>&#13;
<p class="TNI">KnockKnock has approximately 20 plug-ins to detect a myriad of persistent items, including items stored in Background Task Management, browser extensions, cron jobs, dynamic library inserts and proxies, kernel extensions, launch items, login items, Spotlight importers, system extensions, and many more. Although I won’t cover every plug-in here, I’ll dive into a few of them and provide examples of the malware they can detect.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_241" aria-label="241"/>&#13;
<h4 class="H2" id="sec6"><span id="h2-75"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Background Task Management</span></h4>&#13;
<p class="TNI">In <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, we explored the undocumented Background Task Manage-ment subsystem, which macOS leverages to govern and track persistent items such as launch agents, daemons, and login items. Through reverse engineering, I showed you how to deserialize the items managed by the subsystem, which could include persistently installed malware. We then created an open source library that I dubbed <i>DumpBTM</i>, which is available on GitHub (<a href="https://github.com/objective-see/DumpBTM"><i>https://<wbr/>github<wbr/>.com<wbr/>/objective<wbr/>-see<wbr/>/DumpBTM</i></a>). To enumerate persistently installed launch and login items, KnockKnock leverages this library.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="SANS_Dogma_OT_Bold_B_21">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>In Xcode, you can link in a library under your project’s Build Phases tab. There, expand Link Binary With Libraries, click</i> <b>+</b><i>, and then browse to the library.</i></p>&#13;
<p class="TX">After linking in the <i>DumpBTM</i> library, KnockKnock’s Background Task Management plug-in can directly invoke its exported APIs, such as its <span class="SANS_TheSansMonoCd_W5Regular_11">parseBTM</span> function. The function takes a path to a Background Task Management file (or nil, to default to the system’s file) and returns a dictionary containing deserialized metadata about each persistent item managed by Background Task Management. <a href="chapter10.xhtml#Lis10-12">Listing 10-12</a> shows a snippet of the code in the plug-in’s <span class="SANS_TheSansMonoCd_W5Regular_11">scan</span> method.</p>&#13;
<span id="Lis10-12"/>&#13;
<pre><code>#import "dumpBTM.h"&#13;
&#13;
-(void)scan {&#13;
    ...&#13;
    if(@available(macOS 13, *)) {&#13;
        NSDictionary* contents = parseBTM(nil);&#13;
        ...&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-12: Calling into the</span> <span class="SANS_Futura_Std_Book_11">DumpBTM</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">library</span></p>&#13;
<p class="TX">This code makes use of the <span class="SANS_TheSansMonoCd_W5Regular_11">@available</span> Objective-C keyword to ensure that the plug-in executes only on versions 13 and newer of macOS (as the Background Task Management subsystem doesn’t exist on earlier versions). KnockKnock then iterates over the metadata for each persistent item returned by the <i>DumpBTM</i> library’s <span class="SANS_TheSansMonoCd_W5Regular_11">parseBTM</span> function and, for each, instantiates a <span class="SANS_TheSansMonoCd_W5Regular_11">File</span> item object. It does this by invoking the <span class="SANS_TheSansMonoCd_W5Regular_11">File</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">initWithParams:</span> method, which accepts a dictionary of values for the object, including a path and, for launch items, the property list.</p>&#13;
<p class="TX">Note that the code explicitly checks for a property list, as some persistent items in the Background Task Management database, such as login items, won’t contain one (<a href="chapter10.xhtml#Lis10-13">Listing 10-13</a>). This is an important check, as inserting a nonexistent (nil) item into a dictionary will cause your program to crash.</p>&#13;
<span id="Lis10-13"/>&#13;
<pre><code>NSMutableDictionary* parameters = [NSMutableDictionary dictionary];&#13;
&#13;
parameters[KEY_RESULT_PATH] = item[KEY_BTM_ITEM_EXE_PATH];&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_242" aria-label="242"/>if(nil != item[KEY_BTM_ITEM_PLIST_PATH]) {&#13;
    parameters[KEY_RESULT_PLIST] = item[KEY_BTM_ITEM_PLIST_PATH];&#13;
}&#13;
&#13;
File* fileObj = [[File alloc] initWithParams:parameters];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-13: Creating a dictionary of parameters to initialize a <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">File object</span></span></p>&#13;
<p class="TX">With an initialized <span class="SANS_TheSansMonoCd_W5Regular_11">File</span> object in hand, KnockKnock’s Background Task Management plug-in can now invoke the base plug-in class’s <span class="SANS_TheSansMonoCd_W5Regular_11">processItem:</span> method to trigger a refresh of the UI or, in a command line scan, add the item to the list of items persistently installed on the system.</p>&#13;
<p class="TX">Using the <i>DumpBTM</i> library, KnockKnock can easily enumerate all persistent items managed by the subsystem. In the following output, you can see the tool displaying details of the cyber-espionage implant WindTail, which persists an app named <i>Final_Presentation.app</i> as a login item:</p>&#13;
&#13;
<pre><code>% <b>KnockKnock.app/Contents/MacOS/KnockKnock -whosthere -pretty</b>&#13;
...&#13;
"Background Managed Tasks" : [&#13;
    {&#13;
        "path" : "\/Users\/User\/Library\/Final_Presentation.app\/Contents\/MacOS\/usrnode",&#13;
        "hashes" : {&#13;
            "md5" : "C68A856EC8F4529147CE9FD3A77D7865",&#13;
            "sha1" : "758F10BD7C69BD2C0B38FD7D523A816DB4ADDD90"&#13;
        },&#13;
        "VT detection" : "41\/75",&#13;
        "name" : "usrnode",&#13;
        "plist" : "n\/a",&#13;
        "signature(s)" : {&#13;
            "signatureStatus" : -2147409652&#13;
        }&#13;
    }&#13;
]&#13;
</code></pre>&#13;
<p class="TX">Many antivirus engines on VirusTotal now flag the malware, and a check of its signature returns <span class="SANS_TheSansMonoCd_W5Regular_11">-2147409652</span>, which maps to the “certificate revoked” constant, <span class="SANS_TheSansMonoCd_W5Regular_11">CSSMERR_TP_CERT_REVOKED</span>. However, KnockKnock would have shown the presence of the persistent item even before the antivirus engines on VirusTotal developed signatures for it.</p>&#13;
<p class="TX">Unfortunately, no external library can enumerate many of KnockKnock’s other classes of persistence, so we’ll have to write more code ourselves. One example is the browser extension plug-in, which we’ll look at now.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-76"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Browser Extension</span></h4>&#13;
<p class="TNI">Most macOS adware installs a malicious browser extension to hijack search results, display ads, or even intercept browser traffic. Common examples of such adware include Genieo, Yontoo, and Shlayer.</p>&#13;
<p class="TX">Because no macOS APIs can enumerate installed browser extensions, KnockKnock must do so itself. Worse, as each browser manages its extensions <span role="doc-pagebreak" epub:type="pagebreak" id="pg_243" aria-label="243"/>in its own way, KnockKnock must implement specific enumeration code for each. Currently, the tool supports extension enumeration for Safari, Chrome, Firefox, and Opera browsers. In this section, we’ll cover the code specific to Safari.</p>&#13;
<p class="TX">To list the installed browsers, KnockKnock uses relatively unknown Launch Services APIs (<a href="chapter10.xhtml#Lis10-14">Listing 10-14</a>).</p>&#13;
<span id="Lis10-14"/>&#13;
<pre><code>-(NSArray*)getInstalledBrowsers {&#13;
    NSMutableArray* browsers = [NSMutableArray array];&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> CFArrayRef browserIDs = LSCopyAllHandlersForURLScheme(CFSTR("https"));&#13;
&#13;
    for(NSString* browserID in (__bridge NSArray *)browserIDs) {&#13;
        CFURLRef browserURL = NULL;&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> LSFindApplicationForInfo(kLSUnknownCreator,&#13;
        (__bridge CFStringRef)(browserID), NULL, NULL, &amp;browserURL);&#13;
&#13;
        [browsers addObject:[(__bridge NSURL *)browserURL path]];&#13;
        ...&#13;
    }&#13;
    ...&#13;
    return browsers;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-14: Obtaining a list of installed browsers using Launch Services APIs</span></p>&#13;
<p class="TX">The code invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">LSCopyAllHandlersForURLScheme</span> API with the URL scheme <span class="SANS_TheSansMonoCd_W5Regular_11">https</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which returns an array containing the bundle IDs of applications capable of handling that scheme. The code then invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">LSFindApplicationForInfo</span> API to map each ID to an application path <span class="CodeAnnotation" aria-label="annotation2">❷</span>, saving these into an array that it returns to the caller.</p>&#13;
<p class="TX">In macOS 12, Apple added the <span class="SANS_TheSansMonoCd_W5Regular_11">URLsForApplicationsToOpenURL:</span> method to the <span class="SANS_TheSansMonoCd_W5Regular_11">NSWorkspace</span> class to return all applications capable of opening a specified URL. Invoking this method with a URL to a web page will return a list of all installed browsers. For newer versions of macOS, KnockKnock makes use of this API (<a href="chapter10.xhtml#Lis10-15">Listing 10-15</a>).</p>&#13;
<span id="Lis10-15"/>&#13;
<pre><code>#define PRODUCT_URL @"https://objective-see.org/products/knockknock.html"&#13;
&#13;
NSMutableArray* browsers = [NSMutableArray array];&#13;
if(@available(macOS 12.0, *)) {&#13;
    for(NSURL* browser in [NSWorkspace.sharedWorkspace URLsForApplicationsToOpenURL:&#13;
    [NSURL URLWithString:PRODUCT_URL]]) {&#13;
        [browsers addObject:browser.path];&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-15: Obtaining a list of installed browsers with the <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">URLsForApplicationsToOpenURL</span>: method</span></p>&#13;
<p class="TX">You can find the code to enumerate Safari browser extensions in the <span class="SANS_TheSansMonoCd_W5Regular_11">scanExtensionsSafari:</span> method of KnockKnock’s browser extension plug-in. In <a href="chapter10.xhtml#Lis10-16">Listing 10-16</a>, the code invokes this method with Safari’s location, found using the previous code.</p>&#13;
<span id="Lis10-16"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_244" aria-label="244"/>NSArray* installedBrowsers = [self getInstalledBrowsers];&#13;
&#13;
for(NSString* installedBrowser in installedBrowsers) {&#13;
    if(NSNotFound != [installedBrowser rangeOfString:@"Safari.app"].location) {&#13;
        [self scanExtensionsSafari:installedBrowser];&#13;
    }&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-16: Invoking Safari-specific logic to enumerate its extensions</span></p>&#13;
<p class="TX">The location of Safari’s browser extensions has changed over the years; you could find them in the <i>~/Library/Safari/Extensions</i> directory until Apple decided to move them into the keychain. Older versions of KnockKnock tried to keep up with these changes, but now, it uses a simpler method: executing the macOS <span class="SANS_TheSansMonoCd_W5Regular_11">pluginkit</span> utility (<a href="chapter10.xhtml#Lis10-17">Listing 10-17</a>).</p>&#13;
<span id="Lis10-17"/>&#13;
<pre><code>for(NSString* match in @[@"com.apple.Safari.extension", @"com.apple.Safari.content-blocker"]) {&#13;
    NSData* taskOutput = execTask(PLUGIN_KIT, @[@"-mAvv", @"-p", match]);&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-17: Enumerating installed Safari extensions</span></p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">-m</span> argument finds all plug-ins that match the search criteria specified in the <span class="SANS_TheSansMonoCd_W5Regular_11">-p</span> argument; the <span class="SANS_TheSansMonoCd_W5Regular_11">-A</span> argument returns all versions of the installed plug-ins, rather than just the highest version; and <span class="SANS_TheSansMonoCd_W5Regular_11">-vv</span> returns verbose output that includes the display name and parent bundle. For the <span class="SANS_TheSansMonoCd_W5Regular_11">-p</span> argument, we first use <span class="SANS_TheSansMonoCd_W5Regular_11">com.apple.Safari.extension</span>, then <span class="SANS_TheSansMonoCd_W5Regular_11">com.apple.Safari.content-blocker</span>. This ensures that we enumerate both traditional extensions and content blocker extensions.</p>&#13;
<p class="TX">We execute <span class="SANS_TheSansMonoCd_W5Regular_11">pluginkit</span> in a helper function we’ve named <span class="SANS_TheSansMonoCd_W5Regular_11">execTask</span> (discussed in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>), which simply launches the specified program along with any specified arguments and returns the output to the caller. Try running <span class="SANS_TheSansMonoCd_W5Regular_11">pluginkit</span> yourself to enumerate the Safari extensions installed on your Mac. In the following output, you can see that I’ve installed an ad blocker:</p>&#13;
&#13;
<pre><code>% <b>pluginkit -mAvv -p com.apple.Safari.extension</b>&#13;
...&#13;
org.adblockplus.adblockplussafarimac.AdblockPlusSafariToolbar&#13;
Path = /Applications/Adblock Plus.app/Contents/PlugIns/Adblock Plus Toolbar.appex&#13;
UUID = 87C62A05-974F-4E6C-81EE-304D4548DA60&#13;
SDK = com.apple.Safari.extension&#13;
Parent Bundle = /Applications/Adblock Plus.app&#13;
Display Name = ABP Control Panel&#13;
Short Name = $(PRODUCT_NAME)&#13;
Parent Name = Adblock Plus&#13;
Platform = macOS&#13;
</code></pre>&#13;
<p class="TX">Leveraging this external binary has the downside of introducing a dependency and the need to parse its output, but it’s still the most <span role="doc-pagebreak" epub:type="pagebreak" id="pg_245" aria-label="245"/>reliable option. There are many ways to parse any output. In <a href="chapter10.xhtml#Lis10-18">Listing 10-18</a>, KnockKnock takes the approach of extracting each extension’s name, path, and UUID.</p>&#13;
<span id="Lis10-18"/>&#13;
<pre><code>-(void)parseSafariExtensions:(NSData*)extensions browserPath:(NSString*)browserPath {&#13;
    NSMutableDictionary* extensionInfo = [NSMutableDictionary dictionary];&#13;
&#13;
    extensionInfo[KEY_RESULT_PLUGIN] = self;&#13;
    extensionInfo[KEY_EXTENSION_BROWSER] = browserPath;&#13;
&#13;
    for(NSString* line in&#13;
    [[[NSString alloc] initWithData:extensions encoding:NSUTF8StringEncoding]&#13;
    componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]]) {&#13;
        NSArray* components = [[line stringByTrimmingCharactersInSet:&#13;
        [NSCharacterSet whitespaceCharacterSet]] componentsSeparatedByString:@"="];&#13;
        // key and value set to first and last component&#13;
&#13;
        if(YES == [key isEqualToString:@"Display Name"]) {&#13;
            extensionInfo[KEY_RESULT_NAME] = value;&#13;
        } else if(YES == [key isEqualToString:@"Path"]) {&#13;
            extensionInfo[KEY_RESULT_PATH] = value;&#13;
        } else if(YES == [key isEqualToString:@"UUID"]) {&#13;
            extensionInfo[KEY_EXTENSION_ID] = value;&#13;
        }&#13;
        ...&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-18: Parsing output containing installed Safari extensions</span></p>&#13;
<p class="TX">The parsing code separates the output line by line, then splits each line into key-value pairs using an equal sign (<i>=</i>) as a delimiter. This will, for example, split the line <span class="SANS_TheSansMonoCd_W5Regular_11">Path = /Applications/Adblock Plus.app/Contents/PlugIns/Adblock Plus Toolbar.appex</span> into the key <span class="SANS_TheSansMonoCd_W5Regular_11">Path</span> and a value containing the path to the installed ad blocker extension. The code then extracts key-value pairs of interest, such as the path, name, and UUID.</p>&#13;
<p class="TX">Using the path to the extension, we load its <i>Info.plist</i> file and extract a description of the extension from the <span class="SANS_TheSansMonoCd_W5Regular_11">NSHumanReadableDescription</span> key (<a href="chapter10.xhtml#Lis10-19">Listing 10-19</a>).</p>&#13;
<span id="Lis10-19"/>&#13;
<pre><code>details = [NSDictionary dictionaryWithContentsOfFile:&#13;
[NSString stringWithFormat:@"%@/Contents/Info.plist",&#13;
extensionInfo[KEY_RESULT_PATH]]][@"NSHumanReadableDescription"];&#13;
&#13;
extensionInfo[KEY_EXTENSION_DETAILS] = details;&#13;
&#13;
Extension* extensionObj = [[Extension alloc] initWithParams:extensionInfo];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-19: Initializing an <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Extension</span> object for each extension</span></p>&#13;
<p class="TX">Finally, we create a KnockKnock browser <span class="SANS_TheSansMonoCd_W5Regular_11">Extension</span> item object with the collected extension metadata.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_246" aria-label="246"/>&#13;
<h4 class="H2" id="sec8"><span id="h2-77"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dynamic Library Insertion</span></h4>&#13;
<p class="TNI">A malware sample known as Flashback shattered the notion that Apple’s operating system was immune to malware.<sup><a role="doc-noteref" id="chapter10_6" href="#chapter10-6">6</a></sup> Flashback exploited an unpatched vulnerability capable of automatically infecting users who browsed to a malicious website. Discovered in 2012, it amassed more than half a million victims, making it the most successful Mac malware at the time.</p>&#13;
<p class="TX">Flashback also persisted in a novel and stealthy manner. On an infected system, the malware gained user-assisted persistence by subverting Safari’s <i>Info.plist</i> file and inserting the following dictionary under a key named <span class="SANS_TheSansMonoCd_W5Regular_11">LSEnvironment</span>:</p>&#13;
&#13;
<pre><code>&lt;key&gt;LSEnvironment&lt;/key&gt;&#13;
&lt;dict&gt;&#13;
  &lt;key&gt;DYLD_INSERT_LIBRARIES&lt;/key&gt;&#13;
  &lt;string&gt;/Applications/Safari.app/Contents/Resources/UnHackMeBuild&lt;/string&gt;&#13;
&lt;/dict&gt;&#13;
...&#13;
</code></pre>&#13;
<p class="TX">The dictionary’s <span class="SANS_TheSansMonoCd_W5Regular_11">DYLD_INSERT_LIBRARIES</span> key contains a string pointing to the malicious library <i>UnHackMeBuild</i>. Safari will load this library into the browser when launched, where the malware could stealthily execute.</p>&#13;
<p class="TX">Today, Apple has mostly mitigated dylib insertions via the <span class="SANS_TheSansMonoCd_W5Regular_11">DYLD_INSERT_LIBRARIES</span> environment variable and other approaches. The dynamic loader now ignores these variables in a wide range of cases, such as for platform binaries or for applications compiled with the hardened runtime.<sup><a role="doc-noteref" id="chapter10_7" href="#chapter10-7">7</a></sup> However, programs supporting third-party plug-ins, especially on older versions of macOS, may still be at risk.</p>&#13;
<p class="TX">As such, KnockKnock contains a plug-in to detect this type of subversion. It scans launch items and applications, checking for the presence of a <span class="SANS_TheSansMonoCd_W5Regular_11">DYLD_INSERT_LIBRARIES</span> entry. For launch items, this entry lives under the <span class="SANS_TheSansMonoCd_W5Regular_11">EnvironmentVariables</span> key in their property list file, and for applications, you can find it under a key named <span class="SANS_TheSansMonoCd_W5Regular_11">LSEnvironment</span> in the app’s <i>Info.plist</i> file, as we saw with Flashback. Because legitimate items rarely make use of persistent <span class="SANS_TheSansMonoCd_W5Regular_11">DYLD_INSERT_LIBRARIES</span> insertions, you should closely examine any that you uncover.</p>&#13;
<p class="TX">Other plug-ins require a similar list of all launch items and applications, so KnockKnock produces this list in a global enumerator. Let’s briefly look at how KnockKnock tackles such enumeration, focusing on the case of installed apps, as there are multiple ways to list these items on a Mac. The least recommended is to manually enumerate bundles found in the common application directories (such as <i>/Applications</i>), as you’d have to take into account subdirectories such as <i>/Applications/Utilities/</i>, as well as user- specific applications. Plus, applications could be installed in other locations.</p>&#13;
<p class="TX">A Stack Overflow post suggests better options.<sup><a role="doc-noteref" id="chapter10_8" href="#chapter10-8">8</a></sup> These include leveraging the <span class="SANS_TheSansMonoCd_W5Regular_11">lsregister</span> utility to list all applications that have been registered with Launch Services, using the <span class="SANS_TheSansMonoCd_W5Regular_11">mdfind</span> utility or related Spotlight APIs to list all applications indexed by macOS, or making use of the macOS <span role="doc-pagebreak" epub:type="pagebreak" id="pg_247" aria-label="247"/><span class="SANS_TheSansMonoCd_W5Regular_11">system_profiler</span> utility to obtain a list of applications known to the operating system’s software configuration.</p>&#13;
<p class="TX">KnockKnock opts for the <span class="SANS_TheSansMonoCd_W5Regular_11">system_profiler</span> approach. The tool can output XML or JSON, which is easy to programmatically ingest and parse. Here is an example of XML output, along with the metadata for an instance of KnockKnock installed on my computer:</p>&#13;
&#13;
<pre><code>% <b>system_profiler SPApplicationsDataType -xml</b>&#13;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&#13;
...&#13;
&lt;plist version="1.0"&gt;&#13;
&lt;array&gt;&#13;
    &lt;dict&gt;&#13;
    ...&#13;
    &lt;key&gt;_items&lt;/key&gt;&#13;
    &lt;array&gt;&#13;
        &lt;dict&gt;&#13;
             &lt;key&gt;_name&lt;/key&gt;&#13;
             &lt;string&gt;KnockKnock&lt;/string&gt;&#13;
             &lt;key&gt;arch_kind&lt;/key&gt;&#13;
             &lt;string&gt;arch_arm_i64&lt;/string&gt;&#13;
             ...&#13;
             &lt;key&gt;path&lt;/key&gt;&#13;
             &lt;string&gt;/Applications/KnockKnock.app&lt;/string&gt;&#13;
             &lt;key&gt;signed_by&lt;/key&gt;&#13;
             &lt;array&gt;&#13;
                &lt;string&gt;Developer ID Application: Objective-See, LLC (VBG97UB4TA)&lt;/string&gt;&#13;
                &lt;string&gt;Developer ID Certification Authority&lt;/string&gt;&#13;
                &lt;string&gt;Apple Root CA&lt;/string&gt;&#13;
             &lt;/array&gt;&#13;
             &lt;key&gt;version&lt;/key&gt;&#13;
             &lt;string&gt;2.5.0&lt;/string&gt;&#13;
        &lt;/dict&gt;&#13;
        ...&#13;
</code></pre>&#13;
<p class="TX">KnockKnock executes <span class="SANS_TheSansMonoCd_W5Regular_11">system_profiler</span> via the <span class="SANS_TheSansMonoCd_W5Regular_11">execTask</span> helper function discussed earlier in this chapter (<a href="chapter10.xhtml#Lis10-20">Listing 10-20</a>).</p>&#13;
<span id="Lis10-20"/>&#13;
<pre><code>-(void)enumerateApplications {&#13;
    NSData* taskOutput = execTask(SYSTEM_PROFILER, @[@"SPApplicationsDataType", @"-xml"]); <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
    NSArray* serializedOutput =&#13;
    [NSPropertyListSerialization propertyListWithData:taskOutput&#13;
    options:kNilOptions format:NULL error:NULL]; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
    self.applications = serializedOutput[0][@"_items"]; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-20: Installed applications enumerated via <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">system_profiler</span></span></p>&#13;
<p class="TX">Once this helper function returns <span class="CodeAnnotation" aria-label="annotation1">❶</span>, KnockKnock serializes the XML output into an Objective-C object <span class="CodeAnnotation" aria-label="annotation2">❷</span>, then saves the list of applications found under the <span class="SANS_TheSansMonoCd_W5Regular_11">_items</span> key into an instance variable aptly named <span class="SANS_TheSansMonoCd_W5Regular_11">applications</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_248" aria-label="248"/>Now that KnockKnock’s global enumerator has obtained a list of applications (and launch items, although I didn’t show this logic here), the dylib insertion plug-in can scan each, looking for the addition of the <span class="SANS_TheSansMonoCd_W5Regular_11">DYLD_INSERT_LIBRARIES</span> environment variable. <a href="chapter10.xhtml#Lis10-21">Listing 10-21</a> shows this implementation in a method called <span class="SANS_TheSansMonoCd_W5Regular_11">scanApplications</span>.</p>&#13;
<span id="Lis10-21"/>&#13;
<pre><code>-(void)scanApplications {&#13;
    ...&#13;
    for(NSDictionary* installedApp in sharedItemEnumerator.applications) { <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
        NSBundle* appBundle = [NSBundle bundleWithPath:installedApp[@"path"]]; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
        NSURL* appPlist = appBundle.infoDictionary[@"CFBundleInfoPlistURL"]; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
        NSDictionary* enviroVars = appBundle.infoDictionary[@"LSEnvironment"]; <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
&#13;
        if((nil == enviroVars) ||&#13;
            (nil == enviroVars[@"DYLD_INSERT_LIBRARIES"])) {&#13;
            continue;&#13;
        }&#13;
&#13;
        NSString* dylibPath = enviroVars[@"DYLD_INSERT_LIBRARIES"]; <span class="codewide_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
&#13;
        File* fileObj = [[File alloc] initWithParams:&#13;
        @{KEY_RESULT_PLUGIN:self, KEY_RESULT_PATH:dylibPath, KEY_RESULT_PLIST:appPlist.path}];&#13;
&#13;
        [super processItem:fileObj];&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-21: Enumerating applications containing an inserted environment variable</span></p>&#13;
<p class="TX">The code iterates over all apps found by the global enumerator <span class="CodeAnnotation" aria-label="annotation1">❶</span>. For each, it uses the application’s path to load the application’s bundle <span class="CodeAnnotation" aria-label="annotation2">❷</span>, which has useful metadata about the application. This includes the contents of the app’s <i>Info.plist</i> file, which we can access through the bundle object’s <span class="SANS_TheSansMonoCd_W5Regular_11">infoDictionary</span> property. After extracting the path to the <i>Info.plist</i> file <span class="CodeAnnotation" aria-label="annotation3">❸</span>, it uses the key <span class="SANS_TheSansMonoCd_W5Regular_11">LSEnvironment</span> to extract the dictionary containing specific environment variables <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Of course, most apps won’t set any environment variables, so the code skips these. However, for those that have the <span class="SANS_TheSansMonoCd_W5Regular_11">DYLD_INSERT_LIBRARIES</span> key set, the code extracts its value: a path to the library inserted each time the application is run <span class="CodeAnnotation" aria-label="annotation5">❺</span>. In Flashback, which subverted Safari, recall that the key-value pair looks like this:</p>&#13;
&#13;
<pre><code>&lt;key&gt;DYLD_INSERT_LIBRARIES&lt;/key&gt;&#13;
&lt;string&gt;/Applications/Safari.app/Contents/Resources/UnHackMeBuild&lt;/string&gt;&#13;
</code></pre>&#13;
<p class="TX">Finally, the code in the plug-in creates and processes a <span class="SANS_TheSansMonoCd_W5Regular_11">File</span> item object representing the inserted library, saving it to the list of persistent items uncovered by KnockKnock to then print to the terminal or display in the UI.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_249" aria-label="249"/>&#13;
<h4 class="H2" id="sec9"><span id="h2-78"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dynamic Library Proxying and Hijacking</span></h4>&#13;
<p class="TNI">The last plug-in I’ll cover in this chapter detects two other persistence mechanisms that make use of dynamic libraries. <i>Dylib proxying</i> replaces a library on which a target process depends with a malicious library. Whenever the target application starts, the malicious dynamic library loads and runs as well. To keep the application from losing legitimate functionality, it proxies requests to and from the original library.<sup><a role="doc-noteref" id="chapter10_9" href="#chapter10-9">9</a></sup></p>&#13;
<p class="TX">Closely related to dylib proxying is <i>dylib hijacking</i>, which exploits the fact that the loader may look for dependencies in multiple locations. Malware could take advantage of this behavior by tricking the loader into using a malicious dependency instead of a legitimate one. Although malware doesn’t commonly abuse this technique, the post-exploitation agent EmPyre supports it as a persistence mechanism.<sup><a role="doc-noteref" id="chapter10_10" href="#chapter10-10">10</a></sup> Dynamic libraries that perform such hijacking also proxy requests to keep from breaking legitimate functionality.</p>&#13;
<p class="TX">To detect either technique, KnockKnock generates a list of dynamic libraries, then checks each for an <span class="SANS_TheSansMonoCd_W5Regular_11">LC_REEXPORT_DYLIB</span> load command that loads and proxies requests to the original library. While this load command is legitimate, benign libraries rarely use it, so we should closely examine any that do.</p>&#13;
<p class="TX">Unfortunately, there isn’t a simple way to list all dynamic libraries installed on a macOS system, so KnockKnock focuses on those that are currently open or loaded by running processes. This approach isn’t as comprehensive as a scan of the entire system, but then again, any persisted malware is probably running somewhere.</p>&#13;
<p class="TX">To build a list of loaded libraries, KnockKnock runs the <span class="SANS_TheSansMonoCd_W5Regular_11">lsof</span> utility to list all open files on the system, then filters out everything but executables. If a dynamic library has been loaded somewhere, there should be an open file handle to it, which <span class="SANS_TheSansMonoCd_W5Regular_11">lsof</span> can enumerate.</p>&#13;
<p class="TX">While getting a list of open files is fairly simple, determining whether a file is executable isn’t as easy as you might expect. You can’t just look for files whose extension is <i>.dylib</i> because that list wouldn’t include frameworks, which are technically libraries but don’t normally end in <i>.dylib</i>. For example, take a look at the <i>Electron</i> framework. The <span class="SANS_TheSansMonoCd_W5Regular_11">file</span> command reports that it is indeed a dynamic library, though its extension isn’t <i>.dylib</i>:</p>&#13;
&#13;
<pre><code>% <b>file "/Applications/Signal.app/Contents/Frameworks/Electron</b>&#13;
<b>Framework.framework/Electron Framework"</b>&#13;
Mach-O 64-bit dynamically linked shared library arm64&#13;
</code></pre>&#13;
<p class="TX">Another strategy might be to check which of the open files are binaries by checking the file’s executable bit, but this would include scripts and other random files on macOS, such as certain archives (which, as we can see here, have the executable bit, <span class="SANS_TheSansMonoCd_W5Regular_11">x</span>, set):</p>&#13;
&#13;
<pre><code>% <b>ls -l /System/Library/PrivateFrameworks/GPUCompiler.framework/Versions/</b>&#13;
<b>32023/Libraries/lib/clang/32023.26/lib/darwin/libair_rt_iosmac.rtlib</b>&#13;
-rwxr-xr-x  1 root  wheel  140328 Oct 19 21:35&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_250" aria-label="250"/>% <b>file /System/Library/PrivateFrameworks/GPUCompiler.framework/Versions/</b>&#13;
<b>32023/Libraries/lib/clang/32023.26/lib/darwin/libair_rt_iosmac.rtlib</b>&#13;
current ar archive&#13;
</code></pre>&#13;
<p class="TX">While you could manually parse each file, looking for a universal or Mach-O magic value, it turns out an Apple-provided API can do this for you. The relatively unknown <span class="SANS_TheSansMonoCd_W5Regular_11">CFBundleCopyExecutableArchitecturesForURL</span> API extracts the executable architecture of a file, returning <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> or an empty array for nonbinary files.<sup><a role="doc-noteref" id="chapter10_11" href="#chapter10-11">11</a></sup> KnockKnock, which makes use of this API, also checks for binaries of supported architectures (<a href="chapter10.xhtml#Lis10-22">Listing 10-22</a>).</p>&#13;
<span id="Lis10-22"/>&#13;
<pre><code>BOOL isBinary(NSString* file) {&#13;
    static dispatch_once_t once;&#13;
    static NSMutableArray* supportedArchitectures = nil;&#13;
&#13;
    dispatch_once(&amp;once, ^ {&#13;
        supportedArchitectures = <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
        [@[[NSNumber numberWithInt:kCFBundleExecutableArchitectureI386],&#13;
        [NSNumber numberWithInt:kCFBundleExecutableArchitectureX86_64]] mutableCopy];&#13;
&#13;
        if(@available(macOS 11, *)) { <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
            [supportedArchitectures addObject:&#13;
            [NSNumber numberWithInt:kCFBundleExecutableArchitectureARM64]];&#13;
        }&#13;
    });&#13;
&#13;
    CFArrayRef architectures = CFBundleCopyExecutableArchitecturesForURL( <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
    (__bridge CFURLRef)[NSURL fileURLWithPath:file]);&#13;
&#13;
    NSNumber* matchedArchitecture = [(__bridge NSArray*)architectures&#13;
    firstObjectCommonWithArray:supportedArchitectures]; <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
    ...&#13;
    return nil != matchedArchitecture;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-22: Determining whether an item is a binary</span></p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">isBinary</span> function builds an array of architectures with values for both 32 and 64 Intel in a <span class="SANS_TheSansMonoCd_W5Regular_11">dispatch_once</span> to ensure that the initialization only occurs once, as we’ll invoke this function for every file any process has open <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Also, the code makes use of the <span class="SANS_TheSansMonoCd_W5Regular_11">@available</span> Objective-C keyword to only add the ARM64 architecture on versions of macOS that support it <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">Next, we extract the executable architecture of the passed-in file <span class="CodeAnnotation" aria-label="annotation3">❸</span>, using the <span class="SANS_TheSansMonoCd_W5Regular_11">firstObjectCommonWithArray:</span> method to check for any of the supported architectures <span class="CodeAnnotation" aria-label="annotation4">❹</span>. If we find them, we can be sure that the open file is indeed a binary capable of executing on the macOS system. We add these binaries to a list of dynamic libraries that KnockKnock will shortly check for proxying capabilities.</p>&#13;
<p class="TX">KnockKnock also enumerates all running processes to extract the dependencies of the process’s main binary. Each of these dependencies is added to the list of libraries to check (<a href="chapter10.xhtml#Lis10-23">Listing 10-23</a>).</p>&#13;
<span id="Lis10-23"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_251" aria-label="251"/>-(NSMutableArray*)enumLinkedDylibs:(NSArray*)runningProcs {&#13;
    NSMutableArray* dylibs = [NSMutableArray array];&#13;
&#13;
    for(NSString* runningProc in runningProcs) { <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
        MachO* machoParser = [[MachO alloc] init]; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
        [machoParser parse:runningProc classify:NO];&#13;
&#13;
        [dylibs addObjectsFromArray:machoParser.binaryInfo[KEY_LC_LOAD_DYLIBS]]; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
        [dylibs addObjectsFromArray:machoParser.binaryInfo[KEY_LC_LOAD_WEAK_DYLIBS]];&#13;
    }&#13;
    ...&#13;
    return [[NSSet setWithArray:dylibs] allObjects]; <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-23: Enumerating the dependencies of all running processes</span></p>&#13;
<p class="TX">To enumerate all running processes, the plug-in makes use of the <span class="SANS_TheSansMonoCd_W5Regular_11">proc _listallpids</span> API discussed in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>. Then, to extract each process’s dependencies, it invokes a method named <span class="SANS_TheSansMonoCd_W5Regular_11">enumLinkedDylibs</span>, which iterates over each loaded process <span class="CodeAnnotation" aria-label="annotation1">❶</span>, parses it using a Mach-O class I wrote based on code in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and saves both strong and weak dependencies <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Finally, the function returns a list containing all dependencies found in all running processes <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">Next, we scan the list of libraries enumerated via <span class="SANS_TheSansMonoCd_W5Regular_11">lsof</span> and via the running processes (<a href="chapter10.xhtml#Lis10-24">Listing 10-24</a>).</p>&#13;
<span id="Lis10-24"/>&#13;
<pre><code>-(NSMutableArray*)findProxies:(NSMutableArray*)dylibs {&#13;
    NSMutableArray* proxies = [NSMutableArray array];&#13;
&#13;
    for(NSString* dylib in dylibs) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> MachO* machoParser = [[MachO alloc] init];&#13;
        [machoParser parse:dylib classify:NO];&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if(MH_DYLIB != [[machoParser.binaryInfo[KEY_MACHO_HEADERS]&#13;
        firstObject][KEY_HEADER_BINARY_TYPE] intValue]) {&#13;
            continue;&#13;
        }&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if([machoParser.binaryInfo[KEY_LC_REEXPORT_DYLIBS] count]) {&#13;
            [proxies addObject:dylib];&#13;
        }&#13;
    }&#13;
    return proxies;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-24: Checking whether a binary is a dynamic library that (likely) performs proxying</span></p>&#13;
<p class="TX">For each library to scan, the code snippet parses it via the Mach-O class <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Specifically, it checks the type of binary, ignoring any that aren’t explicitly dynamic libraries (identified by the <span class="SANS_TheSansMonoCd_W5Regular_11">MH_DYLIB</span> type) <span class="CodeAnnotation" aria-label="annotation2">❷</span>. For dynamic libraries, it checks and saves the library if it has a load command of type <span class="SANS_TheSansMonoCd_W5Regular_11">LC_REEXPORT_DYLIB</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_252" aria-label="252"/>The method returns a list of any proxy libraries it finds so KnockKnock can display them to the user, either in the terminal or in the UI.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h1-63"/><span class="SANS_Futura_Std_Bold_B_11">Conclusion</span></h3>&#13;
<p class="TNI">Most Mac malware persists, so a tool that can enumerate persistently installed items can uncover even sophisticated or never-before-seen threats. In this chapter, we examined KnockKnock, a tool that provides this capability, leaving persistent Mac malware with almost no hope of remaining undetected. In the next chapter, we’ll explore persistence further and cover a tool capable of detecting persistent Mac malware in real time.</p>&#13;
</section>&#13;
<section epub:type="rearnotes" role="doc-endnotes" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span class="SANS_Futura_Std_Bold_B_11">Notes</span></h3>&#13;
<ol class="footnotes">&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter10-1" href="#chapter10_1">  1</a></span>.  See <a href="https://learn.microsoft.com/en-us/sysinternals/downloads/autoruns"><i>https://<wbr/>learn<wbr/>.microsoft<wbr/>.com<wbr/>/en<wbr/>-us<wbr/>/sysinternals<wbr/>/downloads<wbr/>/autoruns</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter10-2" href="#chapter10_2">  2</a></span>.  See <a href="https://web.archive.org/web/20180117193229/https://github.com/synack/knockknock"><i>https://<wbr/>web<wbr/>.archive<wbr/>.org<wbr/>/web<wbr/>/20180117193229<wbr/>/https:<wbr/>/<wbr/>/github<wbr/>.com<wbr/>/synack<wbr/>/knockknock</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter10-3" href="#chapter10_3">  3</a></span>.  Csaba Fitzl, “Beyond the Good Ol’ LaunchAgents -32- Dock Tile Plugins,” <i>Theevilbit Blog</i>, September 28, 2023, <a href="https://theevilbit.github.io/beyond/beyond_0032/"><i>https://<wbr/>theevilbit<wbr/>.github<wbr/>.io<wbr/>/beyond<wbr/>/beyond<wbr/>_0032<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter10-4" href="#chapter10_4">  4</a></span>.  “NSClassFromString(_:),” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/foundation/1395135-nsclassfromstring"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/foundation<wbr/>/1395135<wbr/>-nsclassfromstring</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter10-5" href="#chapter10_5">  5</a></span>.  You can read more about programmatic integration with VirusTotal in the service’s developer documentation at <a href="https://docs.virustotal.com/reference/overview"><i>https://<wbr/>docs<wbr/>.virustotal<wbr/>.com<wbr/>/reference<wbr/>/overview</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter10-6" href="#chapter10_6">  6</a></span>.  Patrick Wardle, “Methods of Malware Persistence on Mac OS X,” VirusBulletin, September 24, 2014, <a href="https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf"><i>https://<wbr/>www<wbr/>.virusbulletin<wbr/>.com<wbr/>/uploads<wbr/>/pdf<wbr/>/conference<wbr/>/vb2014<wbr/>/VB2014<wbr/>-Wardle<wbr/>.pdf</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter10-7" href="#chapter10_7">  7</a></span>.  Patrick Wardle, <i>The Art of Mac Malware: The Guide to Analyzing Malicious Software</i>, Volume 1 (San Francisco: No Starch Press, 2022), 36.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter10-8" href="#chapter10_8">  8</a></span>.  “Enumerate All Installed Applications on OS X,” Stack Overflow, <a href="https://stackoverflow.com/questions/15164132/enumerate-all-installed-applications-on-os-x"><i>https://<wbr/>stackoverflow<wbr/>.com<wbr/>/questions<wbr/>/15164132<wbr/>/enumerate<wbr/>-all<wbr/>-installed<wbr/>-applications<wbr/>-on<wbr/>-os<wbr/>-x</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter10-9" href="#chapter10_9">  9</a></span>.  Wardle, <i>The Art of Mac Malware</i>, 1:36–37.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter10-10" href="#chapter10_10">10</a></span>.  See <a href="https://github.com/EmpireProject/EmPyre/blob/master/lib/modules/persistence/osx/CreateHijacker.py"><i>https://<wbr/>github<wbr/>.com<wbr/>/EmpireProject<wbr/>/EmPyre<wbr/>/blob<wbr/>/master<wbr/>/lib<wbr/>/modules<wbr/>/persistence<wbr/>/osx<wbr/>/CreateHijacker<wbr/>.py</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter10-11" href="#chapter10_11">11</a></span>.  “CFBundleCopyExecutableArchitecturesForURL,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/corefoundation/1537108-cfbundlecopyexecutablearchitectu?language=objc"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/corefoundation<wbr/>/1537108<wbr/>-cfbundlecopyexecutablearchitectu<wbr/>?language<wbr/>=objc</i></a>.</p></li>&#13;
</ol>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>