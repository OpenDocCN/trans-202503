["```\nif (character >= 'a') and (character <= 'z') then\n    character := chr(ord(character) - 32);\n```", "```\n mov  w1, #'z'\n    ldrb w0, [fp, #character]  // Assume \"character\" is local.\n    cmp  w0, #'a'\n  ❶ ccmp w0, w1, #0b0010, hs\n    bhi  notLower\n  ❷ eor  w0, w0, #0x20\nnotLower:\n    strb w0, [fp, #character]\n```", "```\nlea  x1, xlatTbl\nldrb w0, [fp, #character]\nldrb w0, [x1, w0, uxt2 #0]\nstrb w0, [fp, #character]\n```", "```\nxlatTbl:    .byte       0,1,2,3,4,5,6,7\n            .byte       8,9,10,11,12,13,14,15\n            .byte       16,17,18,19,20,21,22,23\n            .byte       24,25,26,27,28,29,30,31\n            .byte       32,33,34,35,36,37,38,39\n            .byte       40,41,42,43,44,45,46,47\n            .byte       48,49,50,51,52,53,54,55\n            .byte       56,57,58,59,60,61,62,63\n            .byte       64\n            .ascii      \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n            .byte       91,92,93,94,95,96\n            .ascii      \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n            .byte       123,124,125,126,127\n```", "```\n// Listing10-1.S\n//\n// Lowercase-to-uppercase conversion\n\n            #include    \"aoaa.inc\"\n\n            .section    .rodata, \"\"\n\nttlStr:     .asciz      \"Listing 10-1\"\n\ntextStr:    .ascii      \"abcdefghijklmnopqrstuvwxyz\\n\"\n            .ascii      \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\n\"\n            .asciz      \"0123456789\\n\"\n\n// Translation table to convert lowercase to uppercase:\n\nxlatTbl:    .byte       0, 1, 2, 3, 4, 5, 6, 7\n            .byte       8, 9, 10, 11, 12, 13, 14, 15\n            .byte       16, 17, 18, 19, 20, 21, 22, 23\n            .byte       24, 25, 26, 27, 28, 29, 30, 31\n            .byte       32, 33, 34, 35, 36, 37, 38, 39\n            .byte       40, 41, 42, 43, 44, 45, 46, 47\n            .byte       48, 49, 50, 51, 52, 53, 54, 55\n            .byte       56, 57, 58, 59, 60, 61, 62, 63\n            .byte       64\n            .ascii      \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n            .byte       91, 92, 93, 94, 95, 96\n            .ascii      \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n            .byte       123, 124, 125, 126, 127\n\n// Various printf format strings this program uses:\n\nfmtStr1:    .asciz      \"Standard conversion:\\n\"\nfmtStr2:    .asciz      \"\\nConversion via lookup table:\\n\"\nfmtStr:     .asciz      \"%c\"\n\n            .code\n            .extern     printf\n\n////////////////////////////////////////////////////////////////////\n//\n// Return program title to C++ program:\n\n            proc        getTitle, public\n            lea         x0, ttlStr\n            ret\n            endp        getTitle\n\n////////////////////////////////////////////////////////////////////\n//\n// Here is the asmMain function:\n\n            proc    asmMain, public\n\n            locals  am\n            dword   am.x20\n            dword   am.x21\n            byte    am.shadow, 64\n            endl    am\n\n            enter   am.size\n            str     x20, [fp, #am.x20]\n            str     x21, [fp, #am.x21]\n\n// Print first title string:\n\n            lea     x0, fmtStr1\n            bl      printf\n\n// Convert textStr to uppercase using\n// standard \"if and EOR\" operation:\n\n            lea     x20, textStr    // String to convert\n            mov     x21, #'z'       // CCMP doesn't like #'z'.\n            b.al    testNot0\n\n// Check to see if W1 is in the range 'a'..'z'. If so,\n// invert bit 5 to convert it to uppercase:\n\nstdLoop:    cmp     w1, #'a'\n            ccmp    w1, w21, #0b0010, hs\n            bhi     notLower\n            eor     w1, w1, #0x20\nnotLower:\n\n// Print the converted character:\n\n            lea     x0, fmtStr\n            mstr    x1, [sp]\n            bl      printf\n\n// Fetch the next character from the string:\n\ntestNot0:   ldrb    w1, [x20], #1\n            cmp     w1, #0\n            bne     stdLoop\n\n// Convert textStr to uppercase by using\n// a lookup table. Begin by printing\n// an explanatory string before the\n// output:\n\n            lea x0, fmtStr2\n            bl      printf\n\n// textStr is the string to convert.\n// xlatTbl is the lookup table that will convert\n// lowercase characters to uppercase:\n\n            lea     x20, textStr\n            lea     x21, xlatTbl\n            b.al    testNot0a\n\n// Convert the character from lowercase to\n// uppercase via a lookup table:\n\nxlatLoop:   ldrb    w1, [x21, w1, uxtw #0]\n\n// Print the character:\n\n            lea     x0, fmtStr\n            mstr    x1, [sp]\n            bl      printf\n\n// Fetch the next character from the string:\n\ntestNot0a:  ldrb    w1, [x20], #1\n            cmp     w1, #0\n            bne     xlatLoop\n\nallDone:    ldr     x20, [fp, #am.x20]\n            ldr     x21, [fp, #am.x21]\n            leave   // Returns to caller\n            endp    asmMain\n```", "```\n% ./build Listing10-1\n% ./Listing10-1\nCalling Listing10-1:\nStandard conversion:\nABCDEFGHIJKLMNOPQRSTUVWXYZ\nABCDEFGHIJKLMNOPQRSTUVWXYZ\n0123456789\n\nConversion via lookup table:\nABCDEFGHIJKLMNOPQRSTUVWXYZ\nABCDEFGHIJKLMNOPQRSTUVWXYZ\n0123456789\nListing10-1 terminated\n```", "```\n// If it's lowercase, convert it to uppercase:\n\n    mov  w1, #'z'\n    ldrb w0, [fp, #character]  // Assume \"character\" is local.\n    cmp  w0, #'a'\n    ccmp w0, w1, #0b0010, hs\n bhi  notLower\n    eor  w0, w0, #0x20\n    b.al allDone\n\n// If it's uppercase, convert it to lowercase:\n\nnotLower:\n    mov  w1, #'Z'\n    cmp  w0, #'A'\n    ccmp w0, w1, #0b0010, hs\n    bhi  allDone\n    eor  w0, w0, #0x20\n\nallDone:\n    strb w0, [fp, #character]\n```", "```\n lea  x1, xlatTbl2\n    ldrb w0, [fp, #character]\n    ldrb w0, [x1, w0, uxtw #0]\n    strb w0, [fp, #character]\n```", "```\nlea x1, table\nldrb w0, [x1, w0, uxtw #0]\n```", "```\nB = Func(X);\n```", "```\nbyte Func(word `parm)` {...}\n```", "```\nlea  x1, FuncTbl\nldr  w0, X       // Using appropriate addressing mode\nldrb w0, [x1, w0, uxtw #0]\nstrb w0, B       // Using appropriate addressing mode\n```", "```\nX = Posn % 80;\n```", "```\nY = Posn / 25;\n```", "```\nlea  x2, xTbl\nlea  x3, yTbl\nldr  w4, Posn   // Using an appropriate addressing mode\nldrb w0, [x2, w4, uxtw #0] // Get X.\nldrb w1, [x3, w4, uxtw #0] // Get Y.\n```", "```\n`Element_Address` = `Base` + `Index` × `Element_Size`\n```", "```\nshort F(word x) {...} // short is a half word (16 bits).\n```", "```\nlea  x1, F\nldrh w0, x    // Using an appropriate addressing mode\nldrh w0, [x1, w0, uxtw #1] // Shift left does multiply by 2.\n```", "```\nsin x = sin x|(x∈[-2π,2π])\n```", "```\n-2π <= x <= 2π\n```", "```\nshort val(short x)\n{\n    switch (x)\n    {\n        case 0: return 1;\n        case 1: return 1;\n        case 2: return 4;\n        case 3: return 27;\n        case 4: return 256;\n    }\n    return 0;\n}\n```", "```\n mov  w0, #0       // Result = 0, assume x > 4\n    ldrh w1, [fp, #x] // Assume x is local.\n cmp  w1, #4       // See if in the range 0 to 4.\n    bhi  outOfRange\n    lea  x2, valTbl   // Address of lookup table\n    ldrh w0, [x2, w1, uxtw #1] // index * 2 (half-word table)\noutOfRange:\n```", "```\nlea   x1, Sines     // Table of 16-bit values\nldr   w0, [fp, #x]  // Assume x is local.\nldrh  w0, [x1, w0, uxtw #1]  // index * 2 for half words\nldrh  w2, [fp, #r]  // Assume r is local.\nsxth  x0, w0\nsxth  x2, w2\nsmul  w0, w0, w2    // r *(1000 * sin(x))\nmov   w2, #1000\nsdiv  x0, x0, x2    // r *(1000 * sin(x))/ 1000\n```", "```\n// Listing10-2.cpp\n//\n// g++ -o Listing10-2 Listing10-2.c -lm\n//\n// GenerateSines\n//\n// A C program that generates a table of sine values for\n// an assembly language lookup table\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n\nint main(int argc, char **argv)\n{\n    FILE *outFile;\n    int angle;\n    int r;\n\n    // Open the file:\n\n    outFile = fopen(\"sines.inc\", \"w\");\n\n    // Emit the initial part of the declaration to\n    // the output file:\n\n    fprintf\n    (\n        outFile,\n        \"Sines:\"  // sin(0) = 0\n    );\n\n    // Emit the Sines table:\n\n    for(angle = 0; angle <= 359; ++angle)\n    {\n        // Convert angle in degrees to an angle in\n        // radians using:\n        //\n        // radians = angle * 2.0 * pi / 360.0;\n        //\n        // Multiply by 1000 and store the rounded\n        // result into the integer variable r.\n\n        double theSine =\n            sin\n            (\n                angle * 2.0 *\n                3.14159265358979323846 /\n                360.0\n            );\n        r = (int) (theSine * 1000.0);\n\n        // Write out the integers eight per line to the\n        // source file.\n        // Note: If (angle AND %111) is 0, then angle\n        // is divisible by 8 and you should output a\n        // newline first.\n\n if((angle & 7) == 0)\n        {\n            fprintf(outFile, \"\\n\\t.hword\\t\");\n        }\n        fprintf(outFile, \"%5d\", r);\n        if ((angle & 7) != 7)\n        {\n            fprintf(outFile, \",\");\n        }\n\n    } // endfor\n    fprintf(outFile, \"\\n\");\n\n    fclose(outFile);\n    return 0;\n\n} // end main\n```", "```\nSines:\n     .hword      0,   17,   34,   52,   69,   87,  104,  121\n     .hword    139,  156,  173,  190,  207,  224,  241,  258\n     .hword    275,  292,  309,  325,  342,  358,  374,  390\n     .hword    406,  422,  438,  453,  469,  484,  499,  515\n     .hword    529,  544,  559,  573,  587,  601,  615,  629\n     .hword    642,  656,  669,  681,  694,  707,  719,  731\n     .hword    743,  754,  766,  777,  788,  798,  809,  819\n        .\n        .\n        .\n     .hword   -529, -515, -500, -484, -469, -453, -438, -422\n     .hword   -406, -390, -374, -358, -342, -325, -309, -292\n     .hword   -275, -258, -241, -224, -207, -190, -173, -156\n     .hword   -139, -121, -104,  -87,  -69,  -52,  -34,  -17\n```"]