["```\n\n/* C code */\n\nret = write(fd, buff, size);\n\n# IA32 translation\n\nwrite:\n\n...            # set up state and parameters for OS to perform write\n\nmovl $4, %eax  # load 4 (unique ID for write) into register eax\n\nint  $0x80     # trap instruction: interrupt the CPU and transition to the OS\n\naddl $8, %ebx  # an example instruction after the trap instruction\n\n```", "```\n pid_t pid;\n\npid = fork();   /* create a new child process */\n\nprint(\"pid = %d\\n\", pid);  /* both parent and child execute this */ \n```", "```\n\npid_t pid;\n\npid = fork();   /* create a new child process */\n\nif (pid == 0) {\n\n    /* only the child process executes this code */\n\n    ...\n\n} else if (pid != -1)  {\n\n    /* only the parent process executes this code */\n\n    ...\n\n} \n```", "```\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <unistd.h>\n\nint main() {\n\n    pid_t pid, mypid;\n\n    printf(\"A\\n\");\n\n    pid = fork();   /* create a new child process */\n\n    if(pid == -1) {  /* check and handle error return value */\n\n        printf(\"fork failed!\\n\");\n\n        exit(pid);\n\n    }\n\n    if (pid == 0) { /* the child process */\n\n        mypid = getpid();\n\n        printf(\"Child: fork returned %d, my pid %d\\n\", pid, mypid);\n\n    } else  {  /* the parent process */\n\n        mypid = getpid();\n\n        printf(\"Parent: fork returned %d, my pid %d\\n\", pid, mypid);\n\n    }\n\n    printf(\"B:%d\\n\", mypid);\n\n    return 0;\n\n}\n\n```", "```\nA\n\nParent: fork returned 14, my pid 12\n\nB:12\n\nChild: fork returned 0, my pid 14\n\nB:14\n```", "```\nint execvp(char *filename, char *argv[]);\n```", "```\n\npid_t pid;\n\nint ret;\n\nchar *argv[2];\n\nargv[0] = \"a.out\";  // initialize command line arguments for main\n\nargv[1] = NULL;\n\npid = fork();\n\nif (pid == 0) { /* child process */\n\n    ret = execvp(\"a.out\", argv);\n\n    if (ret < 0) {\n\n        printf(\"Error: execvp returned!!!\\n\");\n\n        exit(ret);\n\n    }\n\n}\n\n```", "```\nint main(int argc, char *argv) { ...\n```", "```\n\npid_t pid;\n\nint ret;\n\npid = fork();\n\nif (pid == 0) { /* child process */\n\n    ret = execvp(\"a.out\", argv);\n\n    printf(\"Error: execvp returned!!!\\n\");  /* only executed if execvp fails */\n\n    exit(ret);\n\n}\n\n```", "```\n\n$  a.out        # shell process forks child and calls wait\n\n$  a.out &      # shell process forks child but does not call wait\n\n$  ps           # (the shell can run ps and a.out concurrently)\n\n```", "```\n\npid_t pid1, pid2, ret;\n\nint status;\n\nprintf(\"A\\n\");\n\npid1 = fork();\n\nif (pid1 == 0 ) {       /* child 1 */\n\n    printf(\"B\\n\");\n\n    pid2 = fork();\n\n    if (pid2 == 0 ){    /* child 2 */\n\n        printf(\"C\\n\");\n\n        execvp(\"a.out\", NULL);\n\n    } else {            /* child 1 (parent of child 2) */\n\n        ret = wait(&status);\n\n        printf(\"D\\n\");\n\n        exit(0);\n\n    }\n\n} else {                /* original parent */\n\n    printf(\"E\\n\");\n\n    ret = wait(&status);\n\n    printf(\"F\\n\");\n\n}\n\n```", "```\n\n/* a simple program */\n\n#include <stdio.h>\n\nint main(int argc, char* argv[]) {\n\n    int x, y;\n\n    printf(\"enter a value: \");\n\n    scanf(\"%d\", &y);\n\n    if (y > 10) {\n\n        x = y;\n\n    } else {\n\n        x = 6;\n\n    }\n\n    printf(\"x is %d\\n\", x);\n\n    return 0;\n\n}\n\n```", "```\n\nmovl $0x24100, %eax    # load 0x24100 into register eax\n\nmovl $6, (%eax)        # store 6 at memory address 0x24100\n\n```", "```\n\nP1: 0000100\n\nP1: 0000000\n\nP1: 0010000\n\n              <---- context switch\n\nP2: 0010000\n\nP2: 0001010\n\nP2: 1011001\n\n              <---- context switch\n\nP1: 1011001\n\n```", "```\n\n/*\n\n * Example of signal handlers for SIGALRM, SIGINT, and SIGCONT\n\n *\n\n * A signal handler function prototype must match:\n\n *   void handler_function_name(int signum);\n\n *\n\n * Compile and run this program, then send this process signals by executing:\n\n *  kill -INT  pid  (or Ctrl-C) will send a SIGINT\n\n *  kill -CONT pid  (or Ctrl-Z fg) will send a SIGCONT\n\n */\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <unistd.h>\n\n#include <signal.h>\n\n/* signal handler for SIGALRM */\n\nvoid sigalarm_handler(int sig) {\n\n    printf(\"BEEP, signal number %d\\n.\", sig);\n\n    fflush(stdout);\n\n    alarm(5);  /* sends another SIGALRM in 5 seconds */\n\n}\n\n/* signal handler for SIGCONT */\n\nvoid sigcont_handler(int sig) {\n\n    printf(\"in sigcont handler function, signal number %d\\n.\", sig);\n\n    fflush(stdout);\n\n}\n\n/* signal handler for SIGINT */\n\nvoid sigint_handler(int sig) {\n\n    printf(\"in sigint handler function, signal number %d...exiting\\n.\", sig);\n\n    fflush(stdout);\n\n    exit(0);\n\n}\n\n/* main: register signal handlers and repeatedly block until receive signal */\n\nint main() {\n\n    /* Register signal handlers. */\n\n    if (signal(SIGCONT, sigcont_handler) == SIG_ERR) {\n\n        printf(\"Error call to signal, SIGCONT\\n\");\n\n        exit(1);\n\n    }\n\n    if (signal(SIGINT, sigint_handler) == SIG_ERR) {\n\n        printf(\"Error call to signal, SIGINT\\n\");\n\n        exit(1);\n\n    }\n\n    if (signal(SIGALRM, sigalarm_handler) == SIG_ERR) {\n\n        printf(\"Error call to signal, SIGALRM\\n\");\n\n        exit(1);\n\n    }\n\n    printf(\"kill -CONT %d to send SIGCONT\\n\", getpid());\n\n    alarm(5);  /* sends a SIGALRM in 5 seconds */\n\n    while(1) {\n\n        pause(); /* wait for a signal to happen */\n\n    }\n\n} \n```", "```\n\n$ pkill -INT a.out\n\n$ kill  -INT 1234\n\n$ pkill -CONT a.out\n\n$ kill  -CONT 1234\n\n```", "```\n\n/*\n\n * signal handler for SIGCHLD: reaps zombie children\n\n *  signum: the number of the signal (will be 20 for SIGCHLD)\n\n */\n\nvoid sigchld_handler(int signum) {\n\n    int status;\n\n    pid_t pid;\n\n    /*\n\n     * reap any and all exited child processes\n\n     * (loop because there could be more than one)\n\n     */\n\n    while( (pid = waitpid(-1, &status, WNOHANG)) > 0) {\n\n        /* uncomment debug print stmt to see what is being handled\n\n        printf(\"signal %d me:%d child: %d\\n\", signum, getpid(), pid);\n\n         */\n\n    }\n\n}\n\nint main() {\n\n    /* register SIGCHLD handler: */\n\n    if ( signal(SIGCHLD, sigchild_handler) == SIG_ERR) {\n\n        printf(\"ERROR signal failed\\n\");\n\n    exit(1);\n\n    }\n\n    ...\n\n    /* create a child process */\n\n    pid = fork();\n\n    if(pid == 0) {\n\n        /* child code...maybe call execvp */\n\n        ...\n\n    }\n\n    /* the parent continues executing concurrently with child */\n\n    ...\n\n```", "```\n$ cat foo.c | grep factorial\n```"]