<html><head></head><body>
<h2 class="h2"><span epub:type="pagebreak" id="page_xxiii"/><strong>INTRODUCTION</strong></h2>
<div class="image1"><img alt="Image" src="../images/common01.jpg"/></div>
<p class="noindent">I’m assuming that you’ve learned to use a programming language such as C, C++, Java, or Python . . . and I’m hoping that you’re hooked. It’s hard to explain to nonprogrammers why solving problems through programming is so rewarding and fun.</p>
<p class="indent">I’m also hoping that you’re ready to take your programming skill to the next level. I have the privilege of helping you do that.</p>
<h3 class="h3" id="lev1">What We’ll Do</h3>
<p class="noindent">I could start by teaching you some fancy new techniques, telling you why they’re useful, and comparing them to other fancy techniques, but I won’t. That material would lay inert, holding on for a little, waiting for the opportunity to spring into action—if in fact some opportunity ever did present itself.</p>
<p class="indent">Instead, what I do throughout this book is pose problems: hard problems. These are problems that I hope you cannot solve, problems that I hope stymie your current approaches. You’re a programmer. You want to solve problems. Now it’s time for learning those fancy techniques. This book is all about posing hard problems and then solving them by bridging between what you know and what you need.</p>
<p class="indent"><span epub:type="pagebreak" id="page_xxiv"/>You won’t see traditional textbook problems here. You won’t find an optimal way to multiply a chain of matrices or compute Fibonacci numbers. I promise: you won’t solve the Towers of Hanoi puzzle. There are many excellent textbooks out there that do these things, but I suspect that many people are not motivated by those kinds of puzzles.</p>
<p class="indent">My approach is to use new problems that you haven’t seen before. Each year, thousands of people participate in programming competitions, and these competitions require new problems to measure what participants can come up with on their own rather than who can google the fastest. These problems are fascinating, riffing on the classics while adding twists and context to challenge people to find new solutions. There is a seemingly endless stream of programming and computing knowledge encompassed by these problems. We can learn as much as we like by choosing the right problems.</p>
<p class="indent">Let’s start with some basics. A <em>data structure</em> is a way to organize data so that desirable operations are fast. An <em>algorithm</em> is a sequence of steps that solves a problem. Sometimes we can make fast algorithms without using sophisticated data structures; other times, the right data structure can offer a significant speed boost. My goal is not to turn you into a competitive programmer, though I’d take that as a happy side benefit. Rather, my goal is to teach you data structures and algorithms using problems from the competitive programming world—and to have fun while doing so. You can reach me at <em><a href="mailto:daniel.zingaro@gmail.com">daniel.zingaro@gmail.com</a></em>. Email me if you have learned. Email me if you have laughed.</p>
<h3 class="h3" id="lev2">New to the Second Edition</h3>
<p class="noindent">I’ve thoroughly enjoyed the opportunity to discuss the first edition of this book with readers. Their feedback has led to many of the changes and improvements in this new edition.</p>
<p class="indent">I’ve made small improvements and additions throughout, but here are the major highlights of what’s new:</p>
<p class="block"><strong><a href="ch01.xhtml">Chapter 1</a></strong>   I removed the Compound Words problem, as it can be solved in ways that did not require a hash table. Instead, now we have a problem about passwords on a social networking website. I’ve also streamlined the code in this chapter to help those without a C/C++ programming background, and I added more information about the efficiency of hash tables.</p>
<p class="block"><strong><a href="ch03.xhtml">Chapter 3</a></strong>   I added more guidance for how to discover the needed subproblems when solving a problem with dynamic programming.</p>
<p class="block"><strong><a href="ch04.xhtml">Chapter 4</a></strong>   This chapter is completely new, and it focuses on more advanced uses of memoization and dynamic programming. This was a frequent request of readers, and I’m excited to have been able to add this. You’ll learn how to look at dynamic programming problems in reverse (and why you’d want to), how to work with more dimensions in your subproblem arrays, and how to further optimize your dynamic programming code when it’s just not fast enough.</p>
<p class="block"><span epub:type="pagebreak" id="page_xxv"/><strong><a href="ch05.xhtml">Chapter 5</a>, previously <a href="ch04.xhtml">Chapter 4</a></strong>   I added guidance on how to choose between using dynamic programming and using a graph.</p>
<p class="block"><strong><a href="ch08.xhtml">Chapter 8</a>, previously <a href="ch07.xhtml">Chapter 7</a></strong>   I added further discussion of why we implement heaps as arrays rather than as explicit trees.</p>
<p class="block"><strong><a href="ch10.xhtml">Chapter 10</a></strong>   This chapter is completely new and teaches you how to use randomization, a topic not often covered in books. Randomization is a technique that can help you design algorithms that are simple and fast. You’ll use two types of randomization algorithms to solve problems that would otherwise be very difficult. You’ll also learn what to look for in a problem when trying to decide whether to use randomization in the first place.</p>
<h3 class="h3" id="lev3">Who This Book Is For</h3>
<p class="noindent">This book is for any programmer who wants to learn how to solve tough problems. You’ll learn many data structures and algorithms, their benefits, the types of problems they can help you solve, and how to implement them. You’ll be a better programmer after this!</p>
<p class="indent">Are you taking a course on data structures and algorithms and getting your butt kicked by a wall of theorems and proofs? It doesn’t have to be that way. This book can serve as a companion text for you, helping you get to the core of what’s going on so that you can write code and solve problems.</p>
<p class="indent">Are you looking for an edge in your next coding interview? You need to be able to compare and contrast different approaches for solving a problem, choose the best data structure or algorithm, and explain and implement your solution. You’ll practice all of these skills over and over as you read this book. Never fear hash tables, recursion, dynamic programming, trees, graphs, or heaps again!</p>
<p class="indent">Are you an independent learner working toward expertise in data structures and algorithms? Piecing together stuff from all over the internet can be tiring and lead to knowledge gaps if the right resources are not found. This book will provide you the solid foundation and consistent presentation that you need to become an expert.</p>
<p class="indent">As explored further in the next section, all code in this book is written in the C programming language. However, this isn’t a book on learning C. If your prior programming experience is in C or C++, then jump right in. If instead you’ve programmed in a language such as Java or Python, I suspect that you’ll pick up most of what you need by reading, but you may wish to review some C concepts now or on first encounter. In particular, I’ll use pointers and dynamic memory allocation, so, no matter what your prior experience, you might like to brush up on those topics. The best C book I can recommend is <em>C Programming: A Modern Approach</em>, 2nd edition, by K. N. King. Even if you’re okay with C, read it anyway. It’s that good and a wonderful companion any time you get tripped up by C stuff.<span epub:type="pagebreak" id="page_xxvi"/></p>
<h3 class="h3" id="lev4">Our Programming Language</h3>
<p class="noindent">I’ve chosen to use C as the programming language for this book, rather than some higher-level language such as C++, Java, or Python. I’ll discuss why and also justify a couple of other C-related decisions I’ve made.</p>
<h4 class="h4" id="sec1"><em>Why Use C?</em></h4>
<p class="noindent">The primary reason for using C is that I want to teach you data structures and algorithms from the ground up. When we want a hash table, we’ll build it ourselves. There will be no reliance on dictionaries or hashmaps or similar data structures of other languages. When we don’t know the maximum length of a string, we’ll build an extensible array: we won’t let the language handle memory allocation for us. I want you to know exactly what’s going on, with no tricks up my sleeve. Using C helps me toward this goal.</p>
<p class="indent">Solving programming problems in C, as we do in this book, is a useful primer should you decide to continue with C++. If you become serious about competitive programming, then you’ll be happy to know that C++ is the most popular language used by competitive programmers, thanks to its rich standard library and ability to generate code that favors speed.</p>
<h4 class="h4" id="sec2"><em>Static Keyword</em></h4>
<p class="noindent">Regular local variables are stored on what’s called the <em>call stack</em>. On each call of a function, some of the call stack memory is used to store local variables. Then, when the function returns, that memory is freed up for other local variables to use later. The call stack is small, though, and isn’t appropriate for some of the massive arrays that we’ll meet in this book. Enter the <code>static</code> keyword. When used on a local variable, it changes the storage duration from automatic to static, which means that the variable maintains its value between function calls. As a side effect, these variables are <em>not</em> stored in the same memory area along with regular local variables, since then their values would be lost when a function is terminated. Instead, they’re stored in their own separate segment of memory, where they don’t have to compete with whatever else might be on the call stack.</p>
<p class="indent">One thing to watch out for with this <code>static</code> keyword is that such local variables are only initialized once! For a quick example, see <a href="#ch00ex1">Listing 1</a>.</p>
<pre>int f(void) {
<span class="ent">❶</span> static int x = 5;
   printf("%d\n", x);
   x++;
}

int main(void) {
  f();
  f();
  f();
  return 0;
}</pre>
<p class="excap" id="ch00ex1"><span epub:type="pagebreak" id="page_xxvii"/><em>Listing 1: A local variable with a <span class="codeitalic1">static</span> keyword</em></p>
<p class="indent">I’ve used <code>static</code> on local variable <code>x</code> <span class="ent">❶</span>. Without that, you’d expect <code>5</code> to be printed three times. However, since <code>static</code> is there, you should see this output instead:</p>
<pre>5
6
7</pre>
<h4 class="h4" id="sec3"><em>Include Files</em></h4>
<p class="noindent">To save space, I don’t include the <code>#include</code> lines that should be added to the start of C programs. You’ll be safe if you include the following:</p>
<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;</pre>
<h4 class="h4" id="sec4"><em>Freeing Memory</em></h4>
<p class="noindent">Unlike Java or Python, C requires the programmer to free all memory that is manually allocated. The pattern is to allocate memory using <code>malloc</code>, use that memory, and then free the memory using <code>free</code>.</p>
<p class="indent">For two reasons, though, I do not free memory here. First, freeing memory adds clutter, distracting from the primary teaching purpose of the code. Second, these programs are not long-lived: your program will run on a few test cases, and that’s it. The operating system reclaims all of the unfreed memory on program termination, so there’s nothing to worry about even if you run a program many times. Of course, not freeing memory is quite irresponsible in practice: no one is happy with a program that consumes more and more memory as it runs. If you’d like to practice freeing memory, you can add calls of <code>free</code> to the programs presented in this book.</p>
<h3 class="h3" id="lev5">Topic Selection</h3>
<p class="noindent">The fields of data structures and algorithms are too large to be corralled by one book (or by this one author!). I used three criteria to help me decide what topics made the cut.</p>
<p class="indent">First, I chose topics of broad applicability: each can be used to solve not only the corresponding problems in the book but many other problems as well. In each chapter, I focus on at least two problems. I generally use the first problem to introduce the data structure or algorithm and one of its prototypical uses. The other problems are meant to give a sense of what else <span epub:type="pagebreak" id="page_xxviii"/>the data structure or algorithm can do. For example, in <a href="ch06.xhtml">Chapter 6</a>, we study Dijkstra’s algorithm. If you google it, you’ll see that Dijkstra’s algorithm is used to find shortest paths. Indeed, in the first problem of the chapter, we use it for that very purpose. However, in the second problem, we go further, tweaking Dijkstra’s algorithm to find not only the shortest path but also the number of shortest paths. I hope that, as you progress through each chapter, you learn more and more about the affordances, constraints, and subtleties of each technique.</p>
<p class="indent">Second, I chose topics whose implementation did not overwhelm the surrounding discussion. I wanted the solution to any problem to top out at around 150 lines. That includes reading the input, solving the problem itself, and producing the output. A data structure or algorithm whose implementation took 200 or 300 lines was for practical reasons not suitable.</p>
<p class="indent">Third, I chose topics that lend themselves to correctness arguments that I hope are convincing and intuitive. Teaching you specific data structures and algorithms is of course one of my goals, because I am imagining that you’re here to learn powerful problem-solving approaches and how to implement them. Meanwhile, I’m also hoping that you’re interested in <em>why</em> what you’re learning works, so I have more quietly pursued another goal: convincing you that the data structure or algorithm is correct. There won’t be formal proofs or anything like that. Nonetheless, if I have succeeded in my secret goal, then you’ll learn about correctness right along with the data structure or algorithm. Don’t be content in merely tracing code and marveling that it magically works every time. There is no magic, and the insights that make code tick are within your grasp, just as is the code itself.</p>
<p class="indent">If you’d like to go beyond the chapters of this book, I recommend starting with <a href="app02.xhtml">Appendix B</a>. There, I’ve included some additional material related to <a href="ch01.xhtml">Chapters 1</a>, <a href="ch03.xhtml">3</a>, <a href="ch05.xhtml">5</a>, <a href="ch08.xhtml">8</a>, <a href="ch09.xhtml">9</a>, and <a href="ch10.xhtml">10</a>.</p>
<p class="indent">Many readers will benefit by practicing or reading additional material as they progress through the book. The Notes sections at the end of the chapters point to additional resources, some of which contain further examples and sample problems. There are also online resources that offer a curated, categorized list of problems and their solution strategies. The <em>Methods to Solve</em> page by Steven Halim and Felix Halim is the most comprehensive that I’ve found; see <a href="https://cpbook.net/methodstosolve"><em>https://cpbook.net/methodstosolve</em></a>.</p>
<h3 class="h3" id="lev6">Programming Judges</h3>
<p class="noindent">Each problem that I have chosen is available on a programming-judge website. Many such websites exist, each of which generally contains hundreds of problems. I’ve tried to keep the number of judges that we use small but large enough to give me the flexibility to choose the most appropriate problems. For each judge website, you’ll need a username and password; it’s worth setting up your accounts now so that you don’t have to stop to do so while working through the book. Here are the judges that we’ll use:<span epub:type="pagebreak" id="page_xxix"/></p>
 <p class="block"><strong>Codeforces</strong>   <a href="https://codeforces.com"><em>https://codeforces.com</em></a></p>
<p class="block"><strong>DMOJ</strong>   <a href="https://dmoj.ca"><em>https://dmoj.ca</em></a></p>
<p class="block"><strong>POJ</strong>   <a href="http://poj.org"><em>http://poj.org</em></a></p>
<p class="block"><strong>SPOJ</strong>   <a href="http://spoj.com"><em>http://spoj.com</em></a></p>
<p class="block"><strong>UVa</strong>   <a href="https://uva.onlinejudge.org"><em>https://uva.onlinejudge.org</em></a></p>
<p class="indent">Each problem description begins by indicating the judge website where the problem can be found and the particular problem code that you should use to access it.</p>
<p class="indent">While some problems on the judge websites are written by individual contributors, others are originally from well-known competitions. Here are some of the competitions from which problems in this book originate:</p>
<p class="block"><strong>International Olympiad in Informatics (IOI)</strong>   This is a prestigious annual competition for high school students. Each participating country sends up to four participants, but each participant competes individually. The competition runs over two days, with multiple programming tasks on each day.</p>
<p class="block"><strong>Canadian Computing Competition (CCC) and Canadian Computing Olympiad (CCO)</strong>   These annual competitions for high school students are organized by the University of Waterloo. CCC (aka Stage 1) takes place at individual schools, with the top performers moving on to take the CCO (aka Stage 2) at the University of Waterloo. The top performers in Stage 2 represent Canada at the IOI. When I was a high school student, I participated in the CCC, but I never made it to the CCO—I wasn’t even close.</p>
<p class="block"><strong>Croatian Open Competition in Informatics (COCI)</strong>   This online competition is offered many times per year. Performance is used to determine the Croatian IOI team.</p>
<p class="block"><strong>National Olympiad in Informatics in Province (NOIP)</strong>   This is an annual competition for high school students in China, similar in function to the CCC. The top performers are invited to the National Olympiad in Informatics (NOI), China. The top NOI contestants are eligible for further training and possible selection to China’s IOI team.</p>
<p class="block"><strong>South African Programming Olympiad (SAPO)</strong>   This competition is offered in three rounds per year. The rounds increase in difficulty, from Round 1 to Round 2 to the Final Round. Performance is used to select students to represent South Africa at the IOI.</p>
<p class="block"><strong>USA Computing Olympiad (USACO)</strong>   This online competition is offered several times per year, the most challenging of which is the US Open competition. In each competition, you’ll encounter four levels of problems: bronze (easiest), silver, gold, and platinum (hardest). Performance is used to determine the American IOI team.</p>
<p class="block"><strong>East Central North America (ECNA) Regional Programming Contest</strong>   In this annual competition for university students, the top performers are <span epub:type="pagebreak" id="page_xxx"/>invited to the annual International Collegiate Programming Contest (ICPC) world finals. Unlike the other competitions here, where students compete individually, ECNA and the world finals competitions are team competitions.</p>
<p class="block"><strong>DWITE</strong>   This was an online programming contest designed to help students practice for annual competitions. Unfortunately, DWITE is no longer running, but the old problems—and they are good ones!—are still available.</p>
<p class="indenta">See <a href="app03.xhtml">Appendix C</a> for the source of each problem in this book.</p>
<p class="indent">When you submit code for a problem, the judge compiles your program and runs it on test cases. If your program passes all test cases, and does so within the allotted time, then your code is accepted as correct; judges show <code>AC</code> for accepted solutions. If your program fails one or more test cases, then your program is not accepted; judges show <code>WA</code> (for “Wrong Answer”) in these cases. A final popular outcome is for when your program is too slow, in which case judges show <code>TLE</code> (“Time-Limit Exceeded”). Note that <code>TLE</code> does not mean that your code is otherwise correct: if your code times out, the judges do not run any further test cases, so there may be some <code>WA</code> bugs hidden behind the <code>TLE</code>.</p>
<p class="indent">At the time of publication, my solution for each problem passes all test cases within the allotted time with the specified judge. Within those base requirements, my aim has been to make the code readable and to choose clarity over speed. This is a book about teaching data structures and algorithms, not squeezing further performance out of a program that otherwise gets the job done.</p>
<h3 class="h3" id="lev7">Anatomy of a Problem Description</h3>
<p class="noindent">Before solving a problem, we must be precise about what we are being asked to do. This precision is required not only in understanding the task itself but also in the way that we should read input and produce output. For this reason, each problem begins with a problem description of three components:</p>
<p class="block"><strong>The Problem</strong>   Here, I provide the context for the problem and what we are being asked to do. It’s important to read this material carefully so that you know exactly what problem we’re solving. Sometimes, misreading or misinterpreting seemingly small words can lead to incorrect solutions. For example, one of our problems in <a href="ch03.xhtml">Chapter 3</a> asks us to buy “at least” a certain number of apples: if you instead buy “exactly” that many apples, your program will fail some of the test cases.</p>
<p class="block"><strong>Input</strong>   The author of the problem provides test cases, all of which must be passed for a submission to be deemed correct. It’s our responsibility to read each test case from the input so that we can process it. How do we know how many test cases there are? What is on each line of each test case? If there are numbers, what are their ranges? If there are strings, how long can they be? All of this information is provided here.<span epub:type="pagebreak" id="page_xxxi"/></p>
<p class="block"><strong>Output</strong>   It can be very frustrating to have a program that produces the correct answer but fails test cases because it does not output answers in the correct format. The output portion of a problem description dictates exactly how we should produce output. For example, it will tell us how many lines of output to produce for each test case, what to put on each line, whether blank lines are required between or after test cases, and so on. In addition, I provide the time limit for the problem here: if the program does not output the solution for all test cases within the time limit, then the program does not pass.</p>
<p class="indenta">I have rewritten the text of each problem from the official description so that I can maintain a consistent presentation throughout. Despite these tweaks, my description will convey the same information as the official description.</p>
<p class="indent">For most problems in this book, we’ll read input from standard input and write output to standard output. (There are only two problems where standard input and output are not involved; they are in <a href="ch07.xhtml">Chapter 7</a>.) This means we should use C functions such as <code>scanf</code>, <code>getchar</code>, <code>printf</code>, and so on and not explicitly open and close files.</p>
<h3 class="h3" id="lev8">Starter Problem: Food Lines</h3>
<p class="noindent">Let’s familiarize ourselves with a sample problem description. I’ll provide some commentary in parentheses along the way, directing your attention to the important bits. Once we understand the problem, I can think of nothing better to do than solve it. Unlike the other problems in the book, we’ll be able to do so with programming constructs and ideas that I hope you already know. If you can solve the problem on your own or work through my solution with little or no trouble, then I think you’re ready for what’s to come. If you get seriously stuck, then you may wish to revisit programming fundamentals and/or solve a few other starter problems before continuing.</p>
<p class="indent">This is DMOJ problem <code>lkp18c2p1</code>. (You might like to go now to the DMOJ website and search for this problem so that you’re ready to submit our code once we’re done.)</p>
<h4 class="h4" id="sec5"><em>The Problem</em></h4>
<p class="noindent">There are <em>n</em> lines of people waiting for food. We know the number of people that are already waiting in each line. Then, each of <em>m</em> new people will arrive, and they will join a shortest line (a line with the fewest number of people). Our task is to determine the number of people in each line that each of the <em>m</em> people joins.</p>
<p class="indent">(Spend a little time interpreting the above paragraph. There’s an example coming next, so if anything is unclear, try to remedy it with the combination of the above paragraph and the example below.)</p>
<p class="indent">Here’s an example. Suppose that there are three lines of people, with three people in Line 1, two people in Line 2, and five people in Line 3. Then, four new people arrive. (Try to work out what happens for this case before <span epub:type="pagebreak" id="page_xxxii"/>reading the rest of this paragraph.) The first person joins a line with two people, Line 2; now Line 2 has three people. The second person joins a line with three people, Line 1 or Line 2—let’s say Line 1; Line 1 now has four people. The third person joins a line with three people, Line 2; Line 2 now has four people. The fourth and final person joins a line with four people, Line 1 or Line 2—let’s say Line 1; Line 1 now has five people.</p>
<h5 class="h5">Input</h5>
<p class="noindent">The input contains one test case. The first line of input contains two positive integers, <em>n</em> and <em>m</em>, giving the number of lines of people and number of new people, respectively. <em>n</em> and <em>m</em> are at most 100. The second line of input contains <em>n</em> positive integers, giving the number of people in each line of people before the new people arrive. Each of these integers is at most 100.</p>
<p class="indent">Here’s the input for the above test case:</p>
<pre>3 4
3 2 5</pre>
<p class="noindent">(Note how there is exactly one test case here. Therefore, we should expect to read exactly two lines of input.)</p>
<h5 class="h5">Output</h5>
<p class="noindent">For each of the <em>m</em> new people, output a line containing the number of people in the line that they join.</p>
<p class="indent">The correct output for the above test case is:</p>
<pre>2
3
3
4</pre>
<p class="indent">The time limit for solving the test case is three seconds. (Given that we have to handle at most 100 new people for each test case, three seconds is a long time. We won’t need any fancy data structures or algorithms.)</p>
<h4 class="h4" id="sec6"><em>Solving the Problem</em></h4>
<p class="noindent">For problems involving data structures that are difficult to build by hand, I may start by reading the input. Otherwise, I tend to save that code for last. The reason for this is that we can generally test the functions we’re writing by calling them with sample values; there is no need to worry about parsing the input until we’re ready to solve the whole problem.</p>
<p class="indent">The key data that we need to maintain are the number of people in each line. The appropriate storage technique is an array, using one index per line. We’ll use a variable named <code>lines</code> for that array.</p>
<p class="indent">Each new person that arrives chooses to join a shortest line, so we’ll need a helper function to tell us which line that is. That helper function is given in <a href="#ch00ex2">Listing 2</a>.<span epub:type="pagebreak" id="page_xxxiii"/></p>
<pre>int shortest_line_index(int lines[], int n) {
  int j;
  int shortest = 0;
  for (j = 1; j &lt; n; j++)
    if (lines[j] &lt; lines[shortest])
      shortest = j;
  return shortest;
}</pre>
<p class="excap" id="ch00ex2"><em>Listing 2: Index of a shortest line</em></p>
<p class="indent">Now, given a <code>lines</code> array and <code>n</code> and <code>m</code>, we can solve a test case, the code for which is given in <a href="#ch00ex3">Listing 3</a>:</p>
<pre>void solve(int lines[], int n, int m) {
  int i, shortest;
  for (i = 0; i &lt; m; i++) {
    shortest = shortest_line_index(lines, n);
    printf("%d\n", lines[shortest]);
 <span class="ent">❶</span> lines[shortest]++;
  }
}</pre>
<p class="excap" id="ch00ex3"><em>Listing 3: Solving the problem</em></p>
<p class="indent">For each iteration of the <code>for</code> loop, we call our helper function to grab the index of the shortest line. We then print the length of that shortest line. This person then joins that line: that’s why we must increment the number of people in that line by one <span class="ent">❶</span>.</p>
<p class="indent">All that’s left is to read the input and call <code>solve</code>; that’s done in <a href="#ch00ex4">Listing 4</a>.</p>
<pre>#define MAX_LINES 100

int main(void) {
  int lines[MAX_LINES];
  int n, m, i;
  scanf("%d%d", &amp;n, &amp;m);
  for (i = 0; i &lt; n; i++)
    scanf("%d", &amp;lines[i]);
  solve(lines, n, m);
  return 0;
}</pre>
<p class="excap" id="ch00ex4"><em>Listing 4: The <span class="codeitalic1">main</span> function</em></p>
<p class="indent">Putting together our <code>shortest_line_index</code>, <code>solve</code>, and <code>main</code> functions and adding the required <code>#include</code> lines at the top gives us a complete solution that we can submit to the judge. When doing so, be sure to choose the correct programming language: for the programs in this book, you want to find GCC, or C99, or C11, or however the judge refers to a compiler for C.</p>
<p class="indent"><span epub:type="pagebreak" id="page_xxxiv"/>If you want to test your code locally before submitting it to the judge, then you have a few options. Since our programs read from standard input, one thing you can do is run the program and type a test case by hand. That’s a reasonable thing to do for small test cases, but it’s tedious doing that over and over, especially for large test cases. (You may also need to issue an end-of-file control code after you type the input, such as <small>CTRL</small>-Z on Windows or <small>CTRL</small>-D on other operating systems.) A better option is to store the input in a file and then use <em>input redirection</em> from the command prompt to have the program read from that file instead of the keyboard. For example, if you store a test case for the present problem in file <em>food.txt</em>, and your compiled program is called <em>food</em>, then try:</p>
<pre>$ <span class="codestrong1">food &lt; food.txt</span></pre>
<p class="noindent">This makes it easy to play with many test cases: just change what’s in <em>food.txt</em> and then run the program with input redirection again.</p>
<p class="indent">Congratulations! You’ve solved your first problem. Moreover, you now know our game plan for each problem in the book, as we’ll use the same general structure I have given here. We’ll first understand the problem itself and work through some examples. Then we’ll start writing code to solve the problem. We won’t always get it right the first time, though. Maybe our code will be too slow or fail some specific test cases. That’s okay! We’ll learn new data structures and algorithms and then strike back at the problem. Eventually, we will solve each one—and after each such experience, we will know more and be better programmers than when we started.</p>
<p class="indent">Let’s get to it.</p>
<h3 class="h3" id="lev9">Online Resources</h3>
<p class="noindent">Supplementary resources for this book, including downloadable code and additional exercises, are available at <a href="https://nostarch.com/algorithmic-thinking-2nd-edition"><em>https://nostarch.com/algorithmic-thinking-2nd-edition</em></a>.</p>
<h3 class="h3" id="lev10">Notes</h3>
<p class="noindent">Food Lines is originally from the 2018 LKP Contest 2, hosted by DMOJ.</p>
</body></html>