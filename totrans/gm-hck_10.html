<html><head></head><body>
<h2 class="h2c" id="ch07"><span epub:type="pagebreak" id="page_133"/><span class="big1"><strong>7</strong></span><br/><strong>CODE INJECTION</strong></h2>&#13;
<div class="image"><img src="../images/common.jpg" alt="image"/></div>&#13;
<p class="noindent">Imagine being able to walk into a game company’s office, sit down, and start adding code to their game client. Imagine that you can do this for any game you want, whenever you want, and for any functionality you want. Almost any gamer you talk to will have ideas on how to improve a game, but, as far as they know, it’s just a pipe dream. But you know that dreams are meant to be fulfilled, and now that you’ve learned a bit about how memory works, you’re ready to start throwing the rules out the window. Using code injection, you can, for all intents and purposes, become as powerful as any game’s developers.</p>&#13;
<p class="indent"><em>Code injection</em> is a means of forcing any process to execute foreign code within its own memory space and execution context. I touched on this topic previously in “<a href="ch06.xhtml#ch00lev1sec132">Bypassing ASLR in Production</a>” on <a href="ch06.xhtml#page_128">page 128</a>, where I showed you how to remotely subvert ASLR using <span class="literal">CreateRemoteThread()</span>, but that example only scratched the surface. In the first part of this chapter, you’ll learn how to create code caves, inject new threads, and hijack thread <span epub:type="pagebreak" id="page_134"/>execution to force games to execute small snippets of assembly code. In the second part, you’ll learn how to inject foreign binaries directly into games, forcing those games to execute entire programs that you’ve created.</p>&#13;
<h3 class="h3" id="ch00lev1sec134"><strong>Injecting Code Caves with Thread Injection</strong></h3>&#13;
<p class="noindent">The first step to injecting code into another process is writing position-agnostic assembly code, known as <em>shellcode</em>, in the form of a byte array. You can write shellcode to remote processes to form <em>code caves</em>, which act as the entry point for a new thread that you want a game to execute. Once a code cave is created, you can execute it using either <em>thread injection</em> or <em>thread hijacking</em>. I’ll show you an example of thread injection in this section, and I’ll illustrate thread hijacking in “<a href="ch07.xhtml#ch00lev1sec139">Hijacking a Game’s Main Thread to Execute Code Caves</a>” on <a href="ch07.xhtml#page_138">page 138</a>.</p>&#13;
<p class="indent">You’ll find example code for this chapter in this book’s resource files in the directory <em>GameHackingExamples/Chapter7_CodeInjection</em>. Open <em>main-codeInjection.cpp</em> to follow along as I explain how to build a simplified version of the function <span class="literal">injectCodeUsingThreadInjection()</span> from that file.</p>&#13;
<h4 class="h4" id="ch00lev1sec135"><strong><em>Creating an Assembly Code Cave</em></strong></h4>&#13;
<p class="noindent">In “<a href="ch06.xhtml#ch00lev1sec132">Bypassing ASLR in Production</a>” on <a href="ch06.xhtml#page_128">page 128</a>, I used thread injection to call the function <span class="literal">GetModuleHandle()</span> by way of <span class="literal">CreateRemoteThread()</span> and obtain a process handle. In that case, <span class="literal">GetModuleHandle()</span> acted as the code cave; it had the proper code structure to act as the entry point for a new thread. Thread injection isn’t always that easy, though.</p>&#13;
<p class="indent">For example, say you want your external bot to remotely call a function within a game, and the function has this prototype:</p>&#13;
<p class="programs">DWORD __cdecl someFunction(int times, const char* string);</p>&#13;
<p class="indent">A few things make remotely calling this function tricky. First, it has two parameters, meaning you need to create a code cave that will both set up the stack and properly make the call. <span class="literal">CreateRemoteThread()</span> allows you to pass one argument to the code cave, and you can access that argument relative to <span class="literal">ESP</span>, but the other one would still need to be hardcoded into the code cave. Hardcoding the first argument, <span class="literal">times</span>, is easiest. Additionally, you’d need to make sure that the cave properly cleans the stack.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Recall that when bypassing ASLR in <a href="ch06.xhtml#ch06">Chapter 6</a>, I used</em> <span class="literal"><span class="codeitalic">CreateRemoteThread()</span></span> <em>to start new threads by executing any arbitrary code at a given address and passing that code a single parameter. That’s why these examples can pass one parameter using the stack.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_135"/>Ultimately, the code cave to inject that call to <span class="literal">someFunction</span> into a running game process would look something like this pseudocode:</p>&#13;
<p class="programs">PUSH DWORD PTR:[ESP+0x4] // get second arg from stack<br/>PUSH times <br/>CALL someFunction <br/>ADD ESP, 0x8 <br/>RETN</p>&#13;
<p class="indent">This code cave is almost perfect, but it could be less complex. The <span class="literal">CALL</span> operation expects one of two operands: either a register with an absolute function address or an immediate integer that holds an offset to a function, relative to the return address. This means you’d have to do a bunch of offset calculations, which can be tedious.</p>&#13;
<p class="indent">To keep the cave position agnostic, modify it to use a register instead, as in <a href="ch07.xhtml#ch7exe1">Listing 7-1</a>.</p>&#13;
<p class="programs">PUSH DWORD PTR:[ESP+0x4] // get second arg from stack<br/>PUSH times <br/>MOV EAX, someFunction<br/>CALL EAX <br/>ADD ESP, 0x8 <br/>RETN</p>&#13;
<p class="listt"><a id="ch7exe1"/><em>Listing 7-1: A code cave to call <span class="literal">someFunction</span></em></p>&#13;
<p class="indent">Since a caller knows that a function it calls will overwrite <span class="literal">EAX</span> with its return value, the caller should ensure that <span class="literal">EAX</span> doesn’t hold any critical data. Knowing this, you can use <span class="literal">EAX</span> to hold the absolute address of <span class="literal">someFunction</span>.</p>&#13;
<h4 class="h4" id="ch00lev1sec136"><strong><em>Translating the Assembly to Shellcode</em></strong></h4>&#13;
<p class="noindent">Because code caves need to be written to another process’s memory, they cannot be written directly in assembly. Instead, you’ll need to write them byte by byte. There’s no standard way to determine which bytes represent which assembly code, but there are a few hacky approaches. My personal favorite is to compile an empty C++ application with the assembly code in a function and use OllyDbg to inspect that function. Alternatively, you could open OllyDbg on any arbitrary process and scan through the disassembly until you find the bytes for all of the operations you need. This method is actually really good, as your code caves should be written as simply as possible, meaning all of the operations should be very common. You can also find charts of assembly opcodes online, but I find that they’re all pretty hard to read; the methods I just described are easier overall.</p>&#13;
<p class="indent">When you know what your bytes should be, you can use C++ to easily generate the proper shellcode. <a href="ch07.xhtml#ch7exe2">Listing 7-2</a> shows the finished shellcode skeleton for the assembly in <a href="ch07.xhtml#ch7exe1">Listing 7-1</a>.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_136"/><br/>BYTE codeCave[20] = {<br/>    0xFF, 0x74, 0x24, 0x04,       // PUSH DWORD PTR:[ESP+0x4]<br/>    0x68, 0x00, 0x00, 0x00, 0x00, // PUSH 0<br/>    0xB8, 0x00, 0x00, 0x00, 0x00, // MOV EAX, 0x0<br/>    0xFF, 0xD0,                   // CALL EAX<br/>    0x83, 0xC4, 0x08,             // ADD ESP, 0x08<br/>    0xC3                          // RETN<br/>};</p>&#13;
<p class="listt"><a id="ch7exe2"/><em>Listing 7-2: Shellcode skeleton</em></p>&#13;
<p class="indent">This example creates a <span class="literal">BYTE</span> array containing the needed bytes of shellcode. But the <span class="literal">times</span> argument needs to be dynamic, and it’s impossible to know the address of <span class="literal">someFunction</span> at compile time, which is why this shellcode is written as a skeleton. The two groups of four sequential 0x00 bytes are placeholders for <span class="literal">times</span> and the address of <span class="literal">someFunction</span>, and you can insert the real values into your code cave at runtime by calling <span class="literal">memcpy()</span>, as in the snippet in <a href="ch07.xhtml#ch7exe3">Listing 7-3</a>.</p>&#13;
<p class="programs">memcpy(&amp;codeCave[5], &amp;times, 4);<br/>memcpy(&amp;codeCave[10], &amp;addressOfSomeFunc, 4);</p>&#13;
<p class="listt"><a id="ch7exe3"/><em>Listing 7-3: Inserting <span class="literal">times</span> and the location of <span class="literal">someFunction</span> into the code cave</em></p>&#13;
<p class="indent">Both <span class="literal">times</span> and the address of <span class="literal">someFunction</span> are 4 bytes each (recall that <span class="literal">times</span> is an <span class="literal">int</span> and addresses are 32-bit values), and they belong at <span class="literal">codeCave[5-8]</span> and <span class="literal">codeCave[10-13]</span>, respectively. The two calls to <span class="literal">memcpy()</span> pass this information as parameters to fill the blanks in the <span class="literal">codeCave</span> array.</p>&#13;
<h4 class="h4" id="ch00lev1sec137"><strong><em>Writing the Code Cave to Memory</em></strong></h4>&#13;
<p class="noindent">With the proper shellcode created, you can place it inside the target process using <span class="literal">VirtualAllocEx()</span> and <span class="literal">WriteProcessMemory()</span>. <a href="ch07.xhtml#ch7exe4">Listing 7-4</a> shows one way to do this.</p>&#13;
<p class="programs">   int stringlen = strlen(string) + 1; // +1 to include null terminator<br/>   int cavelen = sizeof(codeCave);<br/><span class="ent">➊</span> int fulllen = stringlen + cavelen;<br/>   auto remoteString = // allocate the memory with EXECUTE rights<br/><span class="ent">➋</span>      VirtualAllocEx(process, 0, fulllen, MEM_COMMIT, PAGE_EXECUTE);<br/><br/>   auto remoteCave = // keep a note of where the code cave will go<br/><span class="ent">➌</span>      (LPVOID)((DWORD)remoteString + stringlen);<br/><br/>   // write the string first<br/><span class="ent">➍</span> WriteProcessMemory(process, remoteString, string, stringlen, NULL);<br/><br/>   // write the code cave next<br/><span class="ent">➎</span> WriteProcessMemory(process, remoteCave, codeCave, cavelen, NULL);</p>&#13;
<p class="listt"><a id="ch7exe4"/><em>Listing 7-4: Writing the final shellcode to a code cave memory</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_137"/>First, this code determines exactly how many bytes of memory it will need to write the <span class="literal">string</span> argument and the code cave into the game’s memory, and it stores that value in <span class="literal">fulllen</span> <span class="ent">➊</span>. Then, it calls the API function <span class="literal">VirtualAllocEx()</span> to allocate <span class="literal">fulllen</span> bytes inside of <span class="literal">process</span> with <span class="literal">PAGE_EXECUTE</span> protection (you can always use <span class="literal">0</span> and <span class="literal">MEM_COMMIT</span>, respectively, for the second and fourth parameters), and it stores the address of the memory in <span class="literal">remoteString</span> <span class="ent">➋</span>. It also increments <span class="literal">remoteString</span> by <span class="literal">stringlen</span> bytes and stores the result in <span class="literal">remoteCave</span> <span class="ent">➌</span>, as the shellcode should be written directly to the memory following the <span class="literal">string</span> argument. Finally, it uses <span class="literal">WriteProcessMemory()</span> to fill the allocated buffer with <span class="literal">string</span> <span class="ent">➍</span> and the assembly bytes <span class="ent">➎</span> stored in <span class="literal">codeCave</span>.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch7tab1">Table 7-1</a> shows how a memory dump of the code cave might look, assuming that it is allocated at 0x030000, <span class="literal">someFunction</span> is at 0xDEADBEEF, <span class="literal">times</span> is set to <span class="literal">5</span>, and <span class="literal">string</span> is pointing to the <span class="literal">injected!</span> text.</p>&#13;
<p class="tablecap"><a id="ch7tab1"/><strong>Table 7-1:</strong> Code Cave Memory Dump</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Address</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Code representation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Raw data</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Data meaning</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x030000</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">remoteString[0-4]</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x69 0x6E 0x6A 0x65 0x63</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">injec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x030005</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">remoteString[5-9]</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x74 0x65 0x64 0x0A 0x00</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">ted!\0</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x03000A</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">remoteCave[0-3]</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0xFF 0x74 0x24 0x04</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">PUSH DWORD</span> <span class="literal">PTR[ESP+0x4]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x03000E</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">remoteCave[4-8]</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x68 0x05 0x00 0x00 0x00</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">PUSH 0x05</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x030013</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">remoteCave[9-13]</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0xB8 0xEF 0xBE 0xAD 0xDE</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MOV EAX, 0xDEADBEEF</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x030018</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">remoteCave[14-15]</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0xFF 0xD0</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">CALL EAX</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x03001A</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">remoteCave[16-18]</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">0x83 0xC4 0x08</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ADD ESP, 0x08</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x03001D</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">remoteCave[19]</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0xC3</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">RETN</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The Address column shows where each piece of the cave is located in memory; the Code representation column tells you which indexes of <span class="literal">remoteString</span> and <span class="literal">remoteCave</span> correspond to the bytes in the Raw data column; and the Data meaning column shows what the bytes represent, in human-readable format. You can see the <span class="literal">injected!</span> string at 0x030000, the value of <span class="literal">times</span> at 0x03000E, and the address of <span class="literal">someFunction</span> at 0x030014.</p>&#13;
<h4 class="h4" id="ch00lev1sec138"><strong><em>Using Thread Injection to Execute the Code Cave</em></strong></h4>&#13;
<p class="noindent">With a complete code cave written to memory, the only thing left to do is execute it. In this example, you could execute the cave using the following code:</p>&#13;
<p class="programs">HANDLE thread = CreateRemoteThread(process, NULL, NULL,<br/>                    (LPTHREAD_START_ROUTINE)remoteCave,<br/>                    remoteString, NULL, NULL);<br/><span epub:type="pagebreak" id="page_138"/><br/>WaitForSingleObject(thread, INFINITE);<br/>CloseHandle(thread);<br/>VirtualFreeEx(process, remoteString, fulllen, MEM_RELEASE)</p>&#13;
<p class="indent">The calls to <span class="literal">CreateRemoteThread()</span>, <span class="literal">WaitForSingleObject()</span>, and <span class="literal">CloseHandle()</span> work to inject and execute the code cave, and <span class="literal">VirtalFreeEx()</span> covers the bot’s tracks by freeing the memory allocated in code like <a href="ch07.xhtml#ch7exe4">Listing 7-4</a>. In the simplest form, that’s all there is to executing a code cave injected into a game. In practice, you should also check return values after calling <span class="literal">VirtualAllocEx()</span>, <span class="literal">WriteProcessMemory()</span>, and <span class="literal">CreateRemoteThread()</span> to make sure that everything was successful.</p>&#13;
<p class="indent">For instance, if <span class="literal">VirtualAllocEx()</span> returns 0x00000000, it means that the memory allocation failed. If you don’t handle the failure, <span class="literal">WriteProcessMemory()</span> will also fail and <span class="literal">CreateRemoteThread()</span> will begin executing with an entry point of 0x00000000, ultimately crashing the game. The same is true for the return values of <span class="literal">WriteProcessMemory()</span> and <span class="literal">CreateRemoteThread()</span>. Typically, these functions will only fail when the process handle is opened without the required access flags.</p>&#13;
<h3 class="h3" id="ch00lev1sec139"><strong>Hijacking a Game’s Main Thread to Execute Code Caves</strong></h3>&#13;
<p class="noindent">In some cases, injected code caves need to be in sync with the main thread of the game process. Solving this problem can be very tricky because it means that you must control the existing threads in an external process.</p>&#13;
<p class="indent">You could simply suspend the main thread until the code cave finishes executing, which might work, but that would prove very slow. The overhead required to wait for a code cave and then resume a thread is pretty heavy. A faster alternative is to force the thread to execute the code for you, a process called <em>thread hijacking</em>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Open the</em> main-codeInjection.cpp <em>file in this book’s source code files to follow along with building this thread-hijacking example, which is a simplified version of</em> <span class="literal"><span class="codeitalic">injectCodeUsingThreadHijacking()</span></span>.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec140"><strong><em>Building the Assembly Code Cave</em></strong></h4>&#13;
<p class="noindent">As with thread injection, the first step to thread hijacking is knowing what you want to happen in your code cave. This time, however, you don’t know what the thread will be executing when you hijack it, so you’ll need to make sure to save the thread’s state when the code cave starts and restore the state when you’re done hijacking it. This means your shellcode needs to be wrapped in some assembly, as in <a href="ch07.xhtml#ch7exe5">Listing 7-5</a>.</p>&#13;
<p class="programs">PUSHAD // push general registers to the stack<br/>PUSHFD // push EFLAGS to the stack<br/><span epub:type="pagebreak" id="page_139"/><br/>// shellcode should be here<br/><br/>POPFD // pop EFLAGS from the stack<br/>POPAD // pop general registers to the stack<br/><br/>// resume the thread without using registers here</p>&#13;
<p class="listt"><a id="ch7exe5"/><em>Listing 7-5: A framework for the thread-hijacking code cave</em></p>&#13;
<p class="indent">If you were to call the same <span class="literal">someFunction</span> that you did with thread injection, you could use shellcode similar to that in <a href="ch07.xhtml#ch7exe2">Listing 7-2</a>. The only difference is that you couldn’t pass the second parameter to your bot using the stack because you wouldn’t be using <span class="literal">CreateRemoteThread()</span>. But that’s no problem; you could just push it the same way you’d push the first parameter. The part of the code cave that executes the function you want to call would need to look like <a href="ch07.xhtml#ch7exe6">Listing 7-6</a>.</p>&#13;
<p class="programs">PUSH string<br/>PUSH times <br/>MOV EAX, someFunction<br/>CALL EAX <br/>ADD ESP, 0x8</p>&#13;
<p class="listt"><a id="ch7exe6"/><em>Listing 7-6: Assembly skeleton for calling <span class="literal">someFunction</span></em></p>&#13;
<p class="indent">All that’s changed here from <a href="ch07.xhtml#ch7exe1">Listing 7-1</a> is that this example pushes <span class="literal">string</span> explicitly and there’s no <span class="literal">RETN</span>. You don’t call <span class="literal">RETN</span> in this case because you want the game thread to go back to whatever it was doing before you hijacked it.</p>&#13;
<p class="indent">To resume the execution of the thread normally, the cave needs to jump back to the thread’s original EIP without using registers. Fortunately, you can use the <span class="literal">GetThreadContext()</span> function to fetch <span class="literal">EIP</span>, filling the shellcode skeleton in C++. Then you can push it to the stack inside your code cave and do a return. <a href="ch07.xhtml#ch7exe7">Listing 7-7</a> shows how your code cave would need to end.</p>&#13;
<p class="programs">PUSH originalEIP<br/>RETN</p>&#13;
<p class="listt"><a id="ch7exe7"/><em>Listing 7-7: Jumping to EIP indirectly</em></p>&#13;
<p class="indent">A return jumps to the value on the top of the stack, so doing this immediately after pushing EIP will do the trick. You should use this method instead of a jump, because jumps require offset calculation and make the shellcode a bit more complex to generate. If you tie <a href="ch07.xhtml#ch7exe5">Listings 7-5</a> through <a href="ch07.xhtml#ch7exe7">7-7</a> together, you come up with the following code cave:</p>&#13;
<p class="programs">//save state<br/>PUSHAD           // push general registers to the stack<br/>PUSHFD           // push EFLAGS to the stack<br/><span epub:type="pagebreak" id="page_140"/><br/>// do work with shellcode<br/>PUSH string <br/>PUSH times <br/>MOV EAX, someFunction<br/>CALL EAX <br/>ADD ESP, 0x8<br/><br/>// restore state<br/>POPFD            // pop EFLAGS from the stack<br/>POPAD            // pop general registers to the stack<br/><br/>// un-hijack: resume the thread without using registers<br/>PUSH originalEIP <br/>RETN</p>&#13;
<p class="indent">Next, follow the instructions in “<a href="ch07.xhtml#ch00lev1sec136">Translating the Assembly to Shellcode</a>” on <a href="ch07.xhtml#page_135">page 135</a> and plug those bytes into an array representing your code cave.</p>&#13;
<h4 class="h4" id="ch00lev1sec141"><strong><em>Generating Skeleton Shellcode and Allocating Memory</em></strong></h4>&#13;
<p class="noindent">Using the same method shown in <a href="ch07.xhtml#ch7exe2">Listing 7-2</a>, you could generate the shellcode for this cave, as shown in <a href="ch07.xhtml#ch7exe8">Listing 7-8</a>.</p>&#13;
<p class="programs">BYTE codeCave[31] = {<br/>    0x60,                         // PUSHAD<br/>    0x9C,                         // PUSHFD<br/>    0x68, 0x00, 0x00, 0x00, 0x00, // PUSH 0<br/>    0x68, 0x00, 0x00, 0x00, 0x00, // PUSH 0<br/>    0xB8, 0x00, 0x00, 0x00, 0x00, // MOV EAX, 0x0<br/>    0xFF, 0xD0,                   // CALL EAX<br/>    0x83, 0xC4, 0x08,             // ADD ESP, 0x08<br/>    0x9D,                         // POPFD<br/>    0x61,                         // POPAD<br/>    0x68, 0x00, 0x00, 0x00, 0x00, // PUSH 0<br/>    0xC3                          // RETN<br/>};<br/><br/>// we'll need to add some code here to place<br/>// the thread's EIP into threadContext.Eip<br/><br/>memcpy(&amp;codeCave[3], &amp;remoteString, 4);<br/>memcpy(&amp;codeCave[8], &amp;times, 4);<br/>memcpy(&amp;codeCave[13], &amp;func, 4);<br/>memcpy(&amp;codeCave[25], &amp;threadContext.Eip, 4);</p>&#13;
<p class="listt"><a id="ch7exe8"/><em>Listing 7-8: Creating the thread-hijacking shellcode array</em></p>&#13;
<p class="indent">As in <a href="ch07.xhtml#ch7exe3">Listing 7-3</a>, <span class="literal">memcpy()</span> is used to put the variables into the skeleton. Unlike in that listing, though, there are two variables that cannot be copied right away; <span class="literal">times</span> and <span class="literal">func</span> are known immediately, but <span class="literal">remoteString</span> is a result of allocation and <span class="literal">threadContext.Eip</span> will be known only once the thread is frozen. It also makes sense to allocate memory before freezing the thread, <span epub:type="pagebreak" id="page_141"/>because you don’t want the thread to be frozen any longer than it has to be. Here’s how this might look:</p>&#13;
<p class="programs">int stringlen = strlen(string) + 1;<br/>int cavelen = sizeof(codeCave);<br/>int fulllen = stringlen + cavelen;<br/><br/>auto remoteString =<br/>    VirtualAllocEx(process, 0, fulllen, MEM_COMMIT, PAGE_EXECUTE);<br/>auto remoteCave =<br/>    (LPVOID)((DWORD)remoteString + stringlen);</p>&#13;
<p class="indent">The allocation code is the same as it was for thread injection, so you can reuse the same snippet.</p>&#13;
<h4 class="h4" id="ch00lev1sec142"><strong><em>Finding and Freezing the Main Thread</em></strong></h4>&#13;
<p class="noindent">The code to freeze the main thread is a bit trickier. First, you get the thread’s unique identifier. This works much like getting a PID, and you can do it using <span class="literal">CreateToolhelp32Snapshot()</span>, <span class="literal">Thread32First()</span>, and <span class="literal">Thread32Next()</span> from <em>TlHelp32.h</em>. As discussed in “<a href="ch06.xhtml#ch00lev1sec120">Obtaining the Game’s Process Identifier</a>” on <a href="ch06.xhtml#page_120">page 120</a>, these functions are used to essentially iterate over a list. A process can have many threads, but the following example assumes that the first thread the game process created is the one that needs to be hijacked:</p>&#13;
<p class="programs">DWORD GetProcessThreadID(HANDLE Process) {<br/>    THREADENTRY32 entry;<br/>    entry.dwSize = sizeof(THREADENTRY32);<br/>    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);<br/><br/>    if (Thread32First(snapshot, &amp;entry) == TRUE) {<br/>        DWORD PID = GetProcessId(Process);<br/>        while (Thread32Next(snapshot, &amp;entry) == TRUE) {<br/>            if (entry.th32OwnerProcessID == PID) {<br/>                CloseHandle(snapshot);<br/>                return entry.th32ThreadID;<br/>            }<br/>        }<br/>    }<br/>    CloseHandle(snapshot);<br/>    return NULL;<br/>}</p>&#13;
<p class="indent">This code simply iterates over the list of all threads on the system and finds the first one that matches the game’s PID. Then it gets the thread identifier from the snapshot entry. Once you know the thread identifier, fetch the thread’s current register state like this:</p>&#13;
<p class="programs">HANDLE thread = OpenThread(<br/>    (THREAD_GET_CONTEXT | THREAD_SUSPEND_RESUME | THREAD_SET_CONTEXT),<br/>    false, threadID);<br/>SuspendThread(thread);<br/><span epub:type="pagebreak" id="page_142"/><br/>CONTEXT threadContext;<br/>threadContext.ContextFlags = CONTEXT_CONTROL;<br/>GetThreadContext(thread, &amp;threadContext);</p>&#13;
<p class="indent">This code uses <span class="literal">OpenThread()</span> to get a thread handle. It then suspends the thread using <span class="literal">SuspendThread()</span> and obtains the values of its registers using <span class="literal">GetThreadContext()</span>. After this, the <span class="literal">memcpy()</span> code in <a href="ch07.xhtml#ch7exe8">Listing 7-8</a> should have all of the variables it needs to finish generating the shellcode.</p>&#13;
<p class="indent">With the shellcode generated, the code cave can be written to the allocated memory in the same fashion as in <a href="ch07.xhtml#ch7exe4">Listing 7-4</a>:</p>&#13;
<p class="programs">WriteProcessMemory(process, remoteString, string, stringlen, NULL);<br/>WriteProcessMemory(process, remoteCave, codeCave, cavelen, NULL);</p>&#13;
<p class="indent">Once the cave is ready and waiting in memory, all you need to do is set the thread’s <span class="literal">EIP</span> to the address of the code cave and let the thread resume execution, as follows:</p>&#13;
<p class="programs">threadContext.Eip = (DWORD)remoteCave;<br/>threadContext.ContextFlags = CONTEXT_CONTROL;<br/>SetThreadContext(thread, &amp;threadContext);<br/>ResumeThread(thread);</p>&#13;
<p class="indent">This code causes the thread to resume execution at the address of the code cave. Because of the way the code cave is written, the thread has no clue that anything has changed. The cave stores the thread’s original state, executes the payload, restores the thread’s original state, and then returns to the original code with everything intact.</p>&#13;
<p class="indent">When you’re using any form of code injection, it is also important to understand what data your code caves touch. For example, if you were to create a code cave that calls a game’s internal functions to create and send a network packet, you’d need to make sure that any global variables that the functions touch (like a packet buffer, packet position marker, and so on) are safely restored once you’re done. You never know what the game is doing when your code cave is executed—it could be calling the same function as you!</p>&#13;
<h3 class="h3" id="ch00lev1sec143"><strong>Injecting DLLs for Full Control</strong></h3>&#13;
<p class="noindent">Code caves are very powerful (you can make a game do anything using assembly shellcode), but handcrafting shellcode isn’t practical. It would be much more convenient to inject C++ code, wouldn’t it? That’s possible, but the process is far more complex: the code must be compiled to assembly, packaged in a position-agnostic format, made aware of any external dependencies, entirely mapped into memory, and then executed on some entry point.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_143"/>Luckily, all of these things are already taken care of in Windows. By changing a C++ project to compile as a dynamic library, you can create a self-contained, position-agnostic binary called a <em>dynamic link library (DLL)</em>. Then you can use a mix of thread injection or hijacking and the <span class="literal">LoadLibrary()</span> API function to map your DLL file into a game’s memory.</p>&#13;
<p class="indent">Open <em>main-codeInjection.cpp</em> in the <em>GameHackingExamples/Chapter7_ CodeInjection</em> directory and <em>dllmain.cpp</em> under <em>GameHackingExamples/Chapter7_CodeInjection_DLL</em> to follow along with some example code as you read this section. In <em>main-codeInjection.cpp</em>, look at the <span class="literal">LoadDLL()</span> function specifically.</p>&#13;
<h4 class="h4" id="ch00lev1sec144"><strong><em>Tricking a Process into Loading Your DLL</em></strong></h4>&#13;
<p class="noindent">Using a code cave, you can trick a remote process into invoking <span class="literal">LoadLibrary()</span> on a DLL, effectively loading foreign code into its memory space. Because <span class="literal">LoadLibrary()</span> takes only a single parameter, you could create a code cave to call it as follows:</p>&#13;
<p class="programs">// write the dll name to memory<br/>wchar_t* dllName = "c:\\something.dll";<br/>int namelen = wcslen(dllName) + 1;<br/>LPVOID remoteString =<br/>    VirtualAllocEx(process, NULL, namelen * 2, MEM_COMMIT, PAGE_EXECUTE);<br/>WriteProcessMemory(process, remoteString, dllName, namelen * 2, NULL);<br/><br/>// get the address of LoadLibraryW()<br/>HMODULE k32 = GetModuleHandleA("kernel32.dll");<br/>LPVOID funcAdr = GetProcAddress(k32, "LoadLibraryW");<br/><br/>// create a thread to call LoadLibraryW(dllName)<br/>HANDLE thread =<br/>    CreateRemoteThread(process, NULL, NULL,<br/>        (LPTHREAD_START_ROUTINE)funcAdr,<br/>        remoteString, NULL, NULL);<br/><br/>// let the thread finish and clean up<br/>WaitForSingleObject(thread, INFINITE);<br/>CloseHandle(thread);</p>&#13;
<p class="indent">This code is somewhat a mix of the thread injection code from “<a href="ch06.xhtml#ch00lev1sec132">Bypassing ASLR in Production</a>” on <a href="ch06.xhtml#page_128">page 128</a> and the code cave created to call <span class="literal">someFunction</span> in <a href="ch07.xhtml#ch7exe2">Listings 7-2</a> and <a href="ch07.xhtml#ch7exe3">7-3</a>. Like the former, this example uses the body of a single-parameter API function, namely <span class="literal">LoadLibrary</span>, as the body of the code cave. Like the latter, though, it has to inject a string into memory, since <span class="literal">LoadLibrary</span> expects a string pointer as its first argument. Once the thread is injected, it forces <span class="literal">LoadLibrary</span> to load the DLL whose name was injected into memory, effectively putting foreign code into a game.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_144"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Give any DLL you plan to inject a unique name, like</em> MySuperBotV2Hook.dll. <em>Simpler names, such as</em> Hook.dll <em>or</em> Injected.dll<em>, are dangerously generic. If the name conflicts with a DLL that is already loaded,</em> <span class="literal"><span class="codeitalic">LoadLibrary()</span></span> <em>will assume that it is the same DLL and not load it!</em></p>&#13;
</div>&#13;
<p class="indent">Once the <span class="literal">LoadLibrary()</span> code cave loads your DLL into a game, the DLL’s entry point—known as <span class="literal">DllMain()</span>—will be executed with <span class="literal">DLL_PROCESS_ATTACH</span> as the reason. When the process is killed or <span class="literal">FreeLibrary()</span> is called on the DLL, its entry point will be called with the <span class="literal">DLL_PROCESS_DETACH</span> reason. Handling these events from the entry point might look like this:</p>&#13;
<p class="programs">BOOL APIENTRY DllMain(HMODULE hModule,<br/>                      DWORD ul_reason_for_call,<br/>                      LPVOID lpReserved) {<br/>    switch (ul_reason_for_call) {<br/>        case DLL_PROCESS_ATTACH:<br/>            printf("DLL attached!\n");<br/>            break;<br/>        case DLL_PROCESS_DETACH:<br/>            printf("DLL detached!\n");<br/>            break;<br/>    }<br/>    return TRUE;<br/>}</p>&#13;
<p class="indent">This example function starts by checking why <span class="literal">DllMain()</span> was called. It then outputs text indicating whether it was called because the DLL was attached or detached, returning <span class="literal">TRUE</span> either way.</p>&#13;
<p class="indent">Keep in mind that the entry point of a DLL is executed inside a <em>loader lock</em>, which is a global synchronization lock used by all functions that read or modify the list of modules loaded in a process. This loader lock gets used by functions like <span class="literal">GetModuleHandle()</span>, <span class="literal">GetModuleFileName()</span>, <span class="literal">Module32First()</span>, and <span class="literal">Module32Next()</span>, which means that running nontrivial code from a DLL entry point can lead to deadlocks and should be avoided.</p>&#13;
<p class="indent">If you need to run code from a DLL entry point, do so from a new thread, as follows:</p>&#13;
<p class="programs">DWORD WINAPI runBot(LPVOID lpParam) {<br/>    // run your bot<br/>    return 1;<br/>}<br/><br/>// do this from DllMain() for case DLL_PROCESS_ATTACH<br/>auto thread = CreateThread(NULL, 0, &amp;runBot, NULL, 0, NULL);<br/>CloseHandle(thread);</p>&#13;
<p class="indent">From <span class="literal">DllMain()</span>, this code creates a new thread starting on the function <span class="literal">runBot()</span>. It then immediately closes its handle to the thread, as doing any further operations from <span class="literal">DllMain()</span> can lead to serious problems. From inside <span epub:type="pagebreak" id="page_145"/>this <span class="literal">runBot()</span>, you can begin executing your bot’s code. The code runs inside the game, meaning you can directly manipulate memory using the type-casting methods. You can also do a lot more, as you’ll see in <a href="ch08.xhtml#ch08">Chapter 8</a>.</p>&#13;
<p class="indent">When injecting DLLs, make sure you have no dependency issues. If your DLL relies on some nonstandard DLLs, for example, you have to either inject those DLLs into the game first or put them in a folder that <span class="literal">LoadLibrary()</span> will search, such as any folder in the <span class="literal">PATH</span> environment variable. The former will work only if the DLLs have no dependencies of their own, whereas the latter is a bit tricky to implement and subject to name collisions. The best option is to link all external libraries statically so that they are compiled directly into your DLL.</p>&#13;
<h4 class="h4" id="ch00lev1sec145"><strong><em>Accessing Memory in an Injected DLL</em></strong></h4>&#13;
<p class="noindent">When you’re trying to access a game’s memory from an injected DLL, process handles and API functions are a hindrance. Because a game shares the same memory space as all code injected into it, you can access a game’s memory directly from injected code. For example, to access a <span class="literal">DWORD</span> value from injected code, you could write the following:</p>&#13;
<p class="programs">DWORD value = *((DWORD*)adr); // read a DWORD from adr<br/>*((DWORD*)adr) = 1234;        // write 1234 to DWORD adr</p>&#13;
<p class="indent">This simply typecasts the memory address <span class="literal">adr</span> to a <span class="literal">DWORD*</span> and dereferences that pointer to a <span class="literal">DWORD</span>. Doing typecasts in place like that is fine, but your memory access code will look cleaner if the functions are abstracted and made generic, just like the Windows API wrappers.</p>&#13;
<p class="indent">The generic functions for accessing memory from inside injected code look something like this:</p>&#13;
<p class="programs">template&lt;typename T&gt;<br/>T readMemory(LPVOID adr) {<br/>    return *((T*)adr);<br/>}<br/><br/>template&lt;typename T&gt;<br/>void writeMemory(LPVOID adr, T val) {<br/>    *((T*)adr) = val;<br/>}</p>&#13;
<p class="indent">Using these templates is just like using the functions under “<a href="ch06.xhtml#ch00lev1sec126">Writing Templated Memory Access Functions</a>” on <a href="ch06.xhtml#page_123">page 123</a>. Here’s an example:</p>&#13;
<p class="programs">DWORD value = readMemory&lt;DWORD&gt;(adr); // read<br/>writeMemory&lt;DWORD&gt;(adr, value++);     // increment and write</p>&#13;
<p class="indent">These calls are nearly identical to the calls in <a href="ch06.xhtml#ch6exe6">Listing 6-6</a> on <a href="ch06.xhtml#page_124">page 124</a>; they just don’t need to take the process handle as an argument because <span epub:type="pagebreak" id="page_146"/>they’re being called from inside the process itself. You can make this method even more flexible by creating a third templated function called <span class="literal">pointMemory()</span>, as follows:</p>&#13;
<p class="programs">template&lt;typename T&gt;<br/>T* pointMemory(LPVOID adr) {<br/>    return ((T*)adr);<br/>}</p>&#13;
<p class="indent">This function skips the dereferencing step of a memory read and simply gives you the pointer to the data. From there, you’re free to both read from and write to the memory by dereferencing that pointer yourself, like this:</p>&#13;
<p class="programs">DWORD* pValue = pointMemory&lt;DWORD&gt;(adr); // point<br/>DWORD value = *pValue;                   // 'read'<br/>(*pValue)++;                             // increment and 'write'</p>&#13;
<p class="indent">With a function like <span class="literal">pointMemory()</span> in place, you could eliminate the calls to <span class="literal">readMemory()</span> and <span class="literal">writeMemory()</span>. You’d still need to find <span class="literal">adr</span> ahead of time, but from there, the code to read a value, change it, and write it back would be much simpler to follow.</p>&#13;
<h4 class="h4" id="ch00lev1sec146"><strong><em>Bypassing ASLR in an Injected DLL</em></strong></h4>&#13;
<p class="noindent">Similarly, since the code is injected, there’s no need to inject a thread into the game to get the base address. Instead, you can just call <span class="literal">GetModuleHandle()</span> directly, like so:</p>&#13;
<p class="programs">DWORD newBase = (DWORD)GetModuleHandle(NULL);</p>&#13;
<p class="indent">A faster way to get the base address is to utilize the game’s FS memory segment, which is another superpower you get from injected code. This memory segment points to a structure called the <em>thread environment block (TEB)</em>, and 0x30 bytes into the TEB is a pointer to the <em>process environment block (PEB)</em> structure. These structures are used by the operating system and contain a ton of data about the current thread and the current process, but we’re interested only in the base address of the main module, which is stored 0x8 bytes into the PEB. Using inline assembly, you can traverse these structures to get <span class="literal">newBase</span>, like this:</p>&#13;
<p class="programs">DWORD newBase;<br/>__asm {<br/>    MOV EAX, DWORD PTR FS:[0x30]<br/>    MOV EAX, DWORD PTR DS:[EAX+0x8]<br/>    MOV newBase, EAX<br/>}</p>&#13;
<p class="indent">The first command stores the <span class="literal">PEB</span> address in <span class="literal">EAX</span>, and the second command reads the main module’s base address and stores it in <span class="literal">EAX</span>. The final command then copies <span class="literal">EAX</span> to <span class="literal">newBase</span>.</p>&#13;
<h3 class="h3" id="ch00lev1sec147"><span epub:type="pagebreak" id="page_147"/><strong>Closing Thoughts</strong></h3>&#13;
<p class="noindent">In <a href="ch06.xhtml#ch06">Chapter 6</a>, I showed you how to read from memory remotely and how an injected DLL can directly access a game’s memory using pointers. This chapter demonstrated how to inject all types of code, from pure assembly byte code to entire C++ binaries. In the next chapter, you’ll learn just how much power being in a game’s memory space actually gives you. If you thought assembly code injection was cool, you’ll love what you can do when you mix injected C++ with control flow manipulation.</p>&#13;
<p class="indent">The example code for this chapter contains proofs of concept for everything we’ve discussed. If you’re still unclear about any of the topics, you can poke at the code to learn exactly what’s going on and see all of the tricks in action.<span epub:type="pagebreak" id="page_148"/></p>&#13;
</body></html>