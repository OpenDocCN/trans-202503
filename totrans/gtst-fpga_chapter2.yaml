- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">SETTING
    UP YOUR HARDWARE AND TOOLS</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">设置你的硬件和工具</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: This chapter walks you through the process of choosing an FPGA development board
    and setting up the associated software tools that you’ll need to translate your
    Verilog or VHDL code into physical circuits on your FPGA. You’ll learn about the
    features to look for in a board, download and install the tools you need to work
    with it, and test them out by designing your first FPGA project to target your
    development board. This project will also give you an overview of the main steps
    in the FPGA development process.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将引导你完成选择 FPGA 开发板的过程，并设置相关的软件工具，这些工具将帮助你将 Verilog 或 VHDL 代码转换为 FPGA 上的物理电路。你将了解在选择开发板时需要关注的特性，下载并安装你需要的工具，并通过设计你的第一个
    FPGA 项目来进行测试，以便在开发板上运行。这个项目还将为你提供 FPGA 开发过程的主要步骤概述。
- en: An FPGA development board isn’t strictly required to use this book. You can
    still learn from the projects without a board, and you can always test your Verilog
    or VHDL code by running it through a free online FPGA simulator tool like EDA
    Playground (a topic we’ll cover in [Chapter 5](chapter5.xhtml)). However, there’s
    something satisfying about writing some code, programming it to a development
    board, and seeing the results in action—even when it does something as simple
    as blinking an LED. For this reason, I highly recommend that you have an FPGA
    development board on hand when learning about FPGAs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这本书并不严格要求你拥有 FPGA 开发板。即使没有开发板，你仍然可以通过项目进行学习，而且你总是可以通过像 EDA Playground 这样的免费在线
    FPGA 模拟器工具来测试你的 Verilog 或 VHDL 代码（这一主题将在[第 5 章](chapter5.xhtml)中讲解）。然而，编写一些代码，将其编程到开发板上，并看到结果付诸实践——即使只是像闪烁一个
    LED 这样简单的功能——这总是令人满意的。因此，我强烈建议你在学习 FPGA 时拥有一块开发板。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Choosing an FPGA Development Board</samp>
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">选择 FPGA 开发板</samp>
- en: 'An FPGA development board (or *dev board*) is a printed circuit board (PCB)
    with an FPGA on it that allows you to program the FPGA with your Verilog or VHDL
    code and test it out. The board may also have peripherals on it that are connected
    to the FPGA, such as LEDs, switches, and connectors for linking the FPGA to other
    devices. FPGA development boards range from devices the size of a pack of gum
    that cost less than $100 to laptop-size devices that cost thousands of dollars.
    With such a wide range of options, there are many factors you should consider
    when choosing a development board, including price, ease of use, and enjoyability:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA 开发板（或 *开发板*）是一块带有 FPGA 的印刷电路板（PCB），可以让你用 Verilog 或 VHDL 代码对 FPGA 进行编程并进行测试。该开发板可能还会有连接到
    FPGA 的外设，如 LED、开关和用于将 FPGA 与其他设备连接的接口。FPGA 开发板的价格从不到 100 美元的口香糖大小设备到几千美元的笔记本大小设备不等。由于选择范围如此广泛，选择开发板时有许多因素需要考虑，包括价格、易用性和乐趣：
- en: '**Cost**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**成本**'
- en: For an FPGA beginner, I recommend starting off with an inexpensive development
    board. Larger, more expensive boards often have many extra features, like SerDes
    and DDR memory, that are unnecessary and potentially overwhelming for new users.
    You can always invest in one of these more sophisticated boards as your skills
    mature and you grow out of your first board.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 FPGA 初学者，我建议从一块价格便宜的开发板开始。更大、价格更高的开发板通常具有许多额外的功能，如 SerDes 和 DDR 内存，这些对于新手来说并不必要，而且可能会让人感到困惑。随着你的技能提高，你可以随时投资购买这些更先进的开发板，并逐步超越你的第一块开发板。
- en: '**Simplicity**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**简易性**'
- en: 'The board you start out with and the software required to work with it should
    be simple to use. It’s challenging enough to learn how an FPGA works; if you also
    have to learn how to use a complicated design tool, the process becomes even more
    difficult. I recommend focusing on boards built around Lattice Semiconductor’s
    iCE40 family of FPGAs, since these FPGAs are compatible with a lightweight and
    simple set of software tools: iCEcube2 and Diamond Programmer. These programs
    are streamlined to do the minimum required to build your FPGA, without all the
    bells and whistles of more advanced programs. You’ll learn how to use both of
    them in this chapter.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你开始使用的开发板和所需的软件应该简单易用。了解 FPGA 的工作原理已经足够具有挑战性；如果还需要学习如何使用复杂的设计工具，过程将变得更加困难。我推荐关注基于
    Lattice Semiconductor 的 iCE40 系列 FPGA 的开发板，因为这些 FPGA 与一套轻量且简单的软件工具兼容：iCEcube2
    和 Diamond Programmer。这些程序经过简化，能够完成构建 FPGA 所需的最低要求，而不包含更高级程序中的繁杂功能。本章将教你如何使用这两款工具。
- en: '**Fun**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**乐趣**'
- en: An FPGA development board should be fun to use, with peripherals like LEDs,
    push buttons, and seven-segment displays that you can take advantage of in different
    projects. Some cheaper boards cut costs by removing peripherals; they just have
    an FPGA and nothing else. FPGA development is much more fun and interesting when
    you can interface the FPGA with other devices.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA 开发板应该易于使用，配备如 LED、按键和七段显示器等外设，以便你在不同的项目中加以利用。有些价格较便宜的开发板通过去除外设来削减成本，它们仅有一个
    FPGA，没有其他功能。能将 FPGA 与其他设备连接，进行更多有趣的互动，能让 FPGA 开发变得更加有趣。
- en: Keep these factors in mind as you consider the development boards available
    on the market.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑市面上的开发板时，记得牢记以下因素。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Requirements for the Book</samp>
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">本书要求</samp>
- en: 'You’ll get the most value out of this book if you follow along with the projects
    and program your own development board. To go through the projects exactly as
    written, you’ll need your development board to have the following features ([Appendix
    A](appendix_A.xhtml) lists a few boards that meet these requirements, or can meet
    them with a few modifications):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能跟随项目一起进行并编程自己的开发板，那么你将从本书中获得最大的价值。为了准确地按照书中的方式完成项目，你需要确保开发板具备以下特点（[附录 A](appendix_A.xhtml)
    列出了几款满足这些要求的开发板，或者经过一些修改后能满足要求的开发板）：
- en: '**Lattice iCE40 FPGA**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lattice iCE40 FPGA**'
- en: iCE40 FPGAs have emerged as the best option for FPGA beginners. They’ve been
    available for many years at affordable prices, while providing enough resources
    to support interesting projects. The iCE40 architecture is relatively simple,
    with few distracting bells and whistles, so you can focus on what’s important.
    As I mentioned earlier, iCE40 FPGAs are compatible with the free, easy-to-use
    iCEcube2 and Diamond Programmer software tools, which we’ll explore in this chapter.
    The iCE40 family is also compatible with open source FPGA tools, if you want to
    avoid proprietary software altogether.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: iCE40 FPGA 已成为 FPGA 初学者的最佳选择。它们已经推出多年，价格适中，同时提供足够的资源来支持有趣的项目。iCE40 架构相对简单，功能不会过于复杂，因此你可以专注于重要的内容。正如我之前提到的，iCE40
    FPGA 兼容免费且易用的 iCEcube2 和 Diamond Programmer 软件工具，本章我们将一一探索这些工具。iCE40 系列还兼容开源 FPGA
    工具，如果你希望完全避免使用专有软件，也可以选择这些工具。
- en: '**USB**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**USB**'
- en: Your development board should have a USB interface to power and program the
    board. This way, all you need is one USB cable and you’re ready to go. Older FPGA
    development boards often require an external programmer (a separate piece of hardware
    that can itself cost hundreds of dollars), so make sure simple built-in USB programming
    is possible with the board you choose.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你的开发板应该配备 USB 接口，以便为板子供电并进行编程。这样，你只需要一根 USB 数据线就可以开始使用了。较旧的 FPGA 开发板通常需要外接编程器（一个独立的硬件设备，可能需要数百美元），所以确保你选择的开发板能够支持简单的内建
    USB 编程。
- en: '**LEDs**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**LED**'
- en: The book’s projects assume that your board has four LEDs. These are a convenient
    way to get output from the FPGA. For example, our first project later this chapter
    will involve lighting up the LEDs, which allows you to get immediate feedback
    that you’ve successfully programmed the FPGA. There’s nothing more satisfying
    than getting that first LED to light up!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的项目假设你的开发板上有四个 LED。这些 LED 是从 FPGA 获取输出的便捷方式。例如，本章的第一个项目将涉及点亮这些 LED，这样你就能立即得到反馈，确认你已成功编程
    FPGA。没有什么比看到第一个 LED 点亮更令人满足的了！
- en: '**Switches**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**开关**'
- en: For each of the four LEDs, you’ll need a corresponding push-button switch. These
    switches provide input to the FPGA, allowing you to easily change the state of
    the board.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个LED，你需要一个相应的按键开关。这些开关为FPGA提供输入，使你能够轻松地改变开发板的状态。
- en: '**Seven-Segment Display**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**七段显示器**'
- en: Your board will need one seven-segment display to implement the memory game
    project in [Chapter 8](chapter8.xhtml). This kind of display provides a fun way
    to output data. Lighting up individual LEDs is one thing, but lighting up numbers
    and letters on a seven-segment display is much more engaging.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你的开发板需要一个七段显示器来实现[第8章](chapter8.xhtml)中的记忆游戏项目。这种显示器提供了一种有趣的输出数据方式。点亮单个LED是一回事，但在七段显示器上显示数字和字母则要更有趣得多。
- en: 'If your development board doesn’t meet all these requirements, don’t worry:
    you can still work through this book’s projects with a few adjustments. For example,
    if you’d prefer to work with a board built around a different kind of FPGA, you
    can. As we’ll discuss in later chapters, there are advanced features that vary
    from one FPGA to another, but the code for this book’s projects is general enough
    that it should work on any modern FPGA. That’s part of the beauty of Verilog and
    VHDL: they’re FPGA-agnostic.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的开发板不符合所有这些要求，也不用担心：你仍然可以通过做一些调整来完成本书的项目。例如，如果你更愿意使用基于另一种FPGA的开发板，你是可以的。正如我们在后面的章节中将讨论的那样，不同的FPGA具有不同的高级功能，但本书项目的代码足够通用，应该可以在任何现代FPGA上运行。这也是Verilog和VHDL的魅力之一：它们与FPGA无关。
- en: Do be aware that if you aren’t working with an iCE40 FPGA, however, you’ll need
    to use a different set of software tools than the ones discussed in this chapter.
    Each FPGA company provides its own tools specifically aimed at its FPGAs. For
    example, AMD (Xilinx) has Vivado, and Intel (Altera) has Quartus. If your board
    has an FPGA from one of these companies, look online for resources about using
    the appropriate software.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但需要注意的是，如果你不是在使用iCE40 FPGA，你将需要使用与本章讨论的不同的软件工具。每个FPGA厂商提供的工具都是专门为其FPGA设计的。例如，AMD（赛灵思）有Vivado，Intel（阿尔特拉）有Quartus。如果你的开发板使用了其中某家公司的FPGA，可以在线查找关于使用相应软件的资源。
- en: If you don’t have all the necessary peripherals for the projects in this book,
    you have a few options. First, you can modify the projects’ Verilog or VHDL code
    to use fewer LEDs and switches. This will work in most cases, although the memory
    game project in [Chapter 8](chapter8.xhtml) will be less satisfying the fewer
    LEDs and switches you use.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有本书项目所需的所有外设，你有几个选择。首先，你可以修改项目的Verilog或VHDL代码，使用更少的LED和开关。大多数情况下这样做是可行的，尽管如果你减少了LED和开关的数量，[第8章](chapter8.xhtml)中的记忆游戏项目可能就不那么令人满意了。
- en: Alternatively, many FPGA development boards, including some of the boards discussed
    in [Appendix A](appendix_A.xhtml), have connection points for wiring up your own
    peripherals. In particular, look for a development board with a Pmod (peripheral
    module) connector. Pmod is a standard connector made famous by Digilent for attaching
    accessory boards with extra peripherals— not just the ones used in this book,
    but also devices like temperature sensors, accelerometers, audio jacks, microSD
    cards, and more. If you’ve ever worked with Arduino Shields, it’s the same concept.
    If your board has a Pmod connector, that will greatly expand the range of projects
    you can work on with your FPGA.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，许多FPGA开发板，包括[附录A](appendix_A.xhtml)中讨论的一些开发板，都有用于连接外部外设的接口点。特别是，寻找带有Pmod（外设模块）连接器的开发板。Pmod是一个标准连接器，由Digilent公司使其广为人知，用于连接带有额外外设的附加板——不仅仅是本书中使用的外设，还包括温度传感器、加速度计、音频插孔、microSD卡等设备。如果你曾经使用过Arduino
    Shields，它们的概念是一样的。如果你的开发板有Pmod连接器，那将大大扩展你可以用FPGA进行的项目范围。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setting Up Your Development Environment</samp>
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">设置你的开发环境</samp>
- en: 'To use the iCE40 FPGA on your development board, you’ll need to install two
    software tools on your computer: iCEcube2 and Diamond Programmer. These free tools
    from Lattice Semiconductor are designed specifically for working with iCE40 FPGAs.
    This section walks you through the process of setting them up. If you’re on Windows,
    you’ll have the easiest time, since the tools are designed for the Windows operating
    system. For Linux or macOS users, I recommend creating a Windows virtual machine
    on your computer, then running the Lattice tools in that. There are many tutorials
    online for setting up a Windows virtual machine using VirtualBox or a similar
    product.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的开发板上使用 iCE40 FPGA，你需要在计算机上安装两个软件工具：iCEcube2 和 Diamond Programmer。这些来自 Lattice
    Semiconductor 的免费工具是专门为 iCE40 FPGA 设计的。本节将指导你完成这些工具的安装过程。如果你是 Windows 用户，将会最为方便，因为这些工具是为
    Windows 操作系统设计的。对于 Linux 或 macOS 用户，我建议在你的计算机上创建一个 Windows 虚拟机，然后在其中运行 Lattice
    工具。网上有许多关于如何使用 VirtualBox 或类似产品创建 Windows 虚拟机的教程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">iCEcube2</samp>
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">iCEcube2</samp>
- en: iCEcube2 is Lattice’s free integrated development environment (IDE) for turning
    the VHDL or Verilog code you write on your computer into a file that the FPGA
    can be programmed with. It’s much easier to use than other IDEs like Vivado, Quartus,
    or even Lattice Diamond (not to be confused with Diamond Programmer), Lattice’s
    tool for working with more sophisticated FPGAs. Their compatibility with iCEcube2
    is part of what makes iCE40 FPGAs an especially good choice for beginners. Those
    other programs are all several gigabytes in size and extremely complicated. They
    have many bells and whistles, most of which you won’t need when you’re getting
    started. By contrast, iCEcube2 is more streamlined, making it a more straightforward
    tool for learning about FPGAs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: iCEcube2 是 Lattice 提供的免费集成开发环境（IDE），可以将你在计算机上编写的 VHDL 或 Verilog 代码转换成 FPGA 可编程的文件。它比其他
    IDE（如 Vivado、Quartus，甚至 Lattice Diamond 工具，后者用于处理更复杂的 FPGA）更易于使用。它与 iCEcube2 的兼容性是
    iCE40 FPGA 成为初学者特别好选择的原因之一。其他这些程序的体积都在几个 gigabytes 以上，而且非常复杂。它们有许多功能，大多数在刚开始时你并不需要。相反，iCEcube2
    更加简洁，是学习 FPGA 的更直接的工具。
- en: 'To download and install iCEcube2, follow these steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载并安装 iCEcube2，请按照以下步骤操作：
- en: 1.  Visit [*https://<wbr>latticesemi<wbr>.com<wbr>/icecube2*](https://latticesemi.com/icecube2)
    or search the internet for “iCEcube2 download.”
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  访问 [*https://<wbr>latticesemi<wbr>.com<wbr>/icecube2*](https://latticesemi.com/icecube2)
    或在网上搜索 “iCEcube2 download”。
- en: 2.  Find the download link for the latest Windows version of iCEcube2, whether
    you’re running Windows natively or in a virtual machine. If you’re a Linux user,
    you may be tempted to download the Linux version instead, but I wouldn’t recommend
    it. That version is buggy; you might have success, or you might not.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  找到 iCEcube2 最新版本的 Windows 下载链接，无论你是直接使用 Windows 还是在虚拟机中使用。如果你是 Linux 用户，你可能会想下载
    Linux 版本，但我不建议这样做。该版本存在一些漏洞，可能会成功，也可能不会。
- en: 3.  When you click the download link, you’ll be asked to create an account on
    the Lattice website. You must create an account to get a license for this tool.
    Make sure to use a real email address, as they’ll email you the free license.
    Once you create an account, you should be able to download the software.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  当你点击下载链接时，系统会要求你在 Lattice 网站上创建一个账户。你必须创建账户才能获取此工具的许可证。确保使用真实的电子邮件地址，因为他们会通过邮件将免费许可证发送给你。一旦创建了账户，你应该能够下载该软件。
- en: 4.  As the software is downloading, find the **iCECube2 Software Free License**
    link on the download page and click it to request a license.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  在软件下载的同时，找到下载页面上的 **iCECube2 Software Free License** 链接，点击它来请求许可证。
- en: '5.  You’ll need your computer’s MAC address to obtain the license. To find
    it on Windows, open a command prompt by clicking the Start button and searching
    for “cmd.” Then enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ipconfig /all</samp>
    at the command line. You should see something like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  你需要计算机的 MAC 地址来获取许可证。要在 Windows 上找到它，点击开始按钮并搜索“cmd”来打开命令提示符。然后在命令行中输入 <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">ipconfig /all</samp>。你应该会看到类似这样的信息：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 6.  Your MAC address is the 12-digit hexadecimal number next to <samp class="SANS_TheSansMonoCd_W5Regular_11">Physical
    Address</samp>. Copy this into the Lattice license request form and submit the
    form to have a license file sent to your email address.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  你的 MAC 地址是紧挨着 <samp class="SANS_TheSansMonoCd_W5Regular_11">物理地址</samp>
    的 12 位十六进制数字。将其复制到 Lattice 许可证请求表单中并提交，以便将许可证文件发送到你的电子邮件地址。
- en: 7.  Launch the iCEcube2 installer once it finishes downloading and point it
    to your license file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  下载完成后，启动 iCEcube2 安装程序，并指向你的许可证文件。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*If you already installed iCEcube2 before obtaining the license, you can use
    the program* LicenseSetup.exe *in the same folder where you installed the tool
    to point it at your license file.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在获取许可证之前已安装了 iCEcube2，可以使用位于工具安装文件夹中的程序* LicenseSetup.exe *来指向你的许可证文件。*'
- en: When it’s done installing, launch iCEcube2\. The main window will look something
    like [Figure 2-1](#fig2-1).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，启动 iCEcube2。主窗口将类似于 [图 2-1](#fig2-1)。
- en: '![](../images/Figure2-1.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The iCEcube2 main
    window</samp>'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-1：iCEcube2 主窗口</samp>
- en: Click around to get a feel for the program. We’ll explore it in more detail
    later in this chapter with a project that will take you through the entire FPGA
    build process.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 四处点击以熟悉程序的使用。我们将在本章的后续部分通过一个项目深入探索，带你完成整个 FPGA 构建过程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Diamond Programmer</samp>
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Diamond Programmer</samp>
- en: 'Diamond Programmer is a free standalone programming tool from Lattice that
    takes the output of iCEcube2 and uses it to program your FPGA via your development
    board’s USB connection. More sophisticated software tools like Vivado and Quartus
    have a built-in programmer, so you don’t need to download a separate program.
    It’s unfortunate that iCEcube2 doesn’t have one built in, but such is the life
    of an iCE40 FPGA designer! Here’s how to install Diamond Programmer:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Diamond Programmer 是 Lattice 提供的免费独立编程工具，它接收 iCEcube2 的输出，并通过开发板的 USB 连接编程你的
    FPGA。像 Vivado 和 Quartus 这样的更复杂的软件工具有内置的编程器，因此你不需要单独下载程序。遗憾的是，iCEcube2 并未内置编程器，但这就是
    iCE40 FPGA 设计师的生活！以下是如何安装 Diamond Programmer：
- en: 1.  Go to [*https://<wbr>latticesemi<wbr>.com<wbr>/programmer*](https://latticesemi.com/programmer)
    or search the internet for “lattice diamond software” to locate the download page.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  访问 [*https://<wbr>latticesemi<wbr>.com<wbr>/programmer*](https://latticesemi.com/programmer)
    或在互联网上搜索“lattice diamond software”来找到下载页面。
- en: 2.  The Diamond Programmer page has many download links to choose from. Find
    and click the link for the latest version of Programmer Standalone 64-bit for
    Windows.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  Diamond Programmer 页面有多个下载链接可供选择。找到并点击 Windows 版 64 位的 Programmer Standalone
    最新版本的链接。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">WARNING</samp>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">警告</samp>
- en: '*Be sure to download Programmer Standalone and not the Programmer Standalone
    Encryption Pack. The latter isn’t needed.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*请确保下载 Programmer Standalone 而不是 Programmer Standalone Encryption Pack。后者是不需要的。*'
- en: 3.  Diamond Programmer doesn’t require a license, so simply run the installer
    once it downloads.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  Diamond Programmer 不需要许可证，因此下载后只需运行安装程序即可。
- en: You’re now ready to dive into your first FPGA project, where you’ll learn how
    to work with these tools and program your FPGA.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好开始你的第一个 FPGA 项目，在这个项目中，你将学习如何使用这些工具并编程你的 FPGA。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #1: Wiring Switches to LEDs</samp>'
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #1：开关与 LED 的连接</samp>'
- en: 'In this project, you’ll get familiar with the build process by creating a simple
    FPGA design: when you press one of the push-button switches on your FPGA development
    board, one of the LEDs should light up. The project assumes that you have four
    switches and four LEDs, so you’ll design and program your FPGA to wire up each
    switch to one of the LEDs. (As mentioned earlier, you can adapt the project to
    use fewer switches and LEDs if needed.) [Figure 2-2](#fig2-2) shows a diagram
    of what we want to do.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将通过创建一个简单的 FPGA 设计来熟悉构建过程：当你按下 FPGA 开发板上的某个按钮开关时，某个 LED 应该点亮。该项目假设你有四个开关和四个
    LED，因此你需要设计和编程 FPGA，将每个开关与一个 LED 相连。（如前所述，如果需要，你可以调整项目使用更少的开关和 LED。）[图 2-2](#fig2-2)
    显示了我们要实现的目标示意图。
- en: '![](../images/Figure2-2.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: The Project #1
    block diagram</samp>'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-2：项目 #1 方框图</samp>'
- en: On the left we have the board’s four switches, labeled SW1 through SW4\. By
    default, these will be open (not connected), meaning the corresponding input pin
    of the FPGA will have a low voltage when the switch isn’t pressed, due to an onboard
    pull-down resistor. When you press a switch down, the FPGA will see a high voltage
    present at the input pin connected to that switch. On the output side we have
    four LEDs, labeled D1 through D4\. We want to create an FPGA that will connect
    the switches and LEDs such that, for example, when the user presses SW1, the D1
    LED illuminates. We’ll literally be creating a physical wired connection between
    the SW1 input and the D1 output using our FPGA. In other words, with FPGAs you’re
    programming at such a low level that you’re creating wires between pins, throughout
    your device.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧是板上的四个开关，标记为SW1到SW4。默认情况下，这些开关将是打开状态（未连接），这意味着当开关未被按下时，FPGA的对应输入引脚将有低电压，因为板载有下拉电阻。当你按下一个开关时，FPGA将看到连接到该开关的输入引脚上有高电压。在输出侧，我们有四个LED，标记为D1到D4。我们希望创建一个FPGA，使得例如当用户按下SW1时，D1
    LED会点亮。我们将实际创建一个物理连接，将SW1输入和D1输出连接起来，使用我们的FPGA。换句话说，通过FPGA，你在如此低的层级编程，实际上是为引脚之间创建了连接线，贯穿整个设备。
- en: To implement this project, we’ll go through four main steps. These steps, summarized
    in [Figure 2-3](#fig2-3), form the main phases of the FPGA build process.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个项目，我们将经过四个主要步骤。这些步骤在[图2-3](#fig2-3)中做了总结，构成了FPGA构建过程的主要阶段。
- en: '![](../images/Figure2-3.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-3: The FPGA build
    process</samp>'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图2-3：FPGA构建过程</samp>
- en: 'You’ll familiarize yourself with the steps at a high level through this project.
    Then you’ll expand your knowledge of each step throughout the book. The four steps
    are:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在这个项目中对这些步骤有一个大致的了解。然后，在全书中，你将进一步扩展对每个步骤的认识。这四个步骤是：
- en: 1.  **Design.** In this step, you write the Verilog or VHDL code that describes
    how the FPGA will function. You might also write tests to ensure that your code
    will work as you intend, a concept we’ll discuss in [Chapter 5](chapter5.xhtml).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 1. **设计（Design）**。在这一步，你编写描述FPGA如何工作的Verilog或VHDL代码。你可能还会编写测试，确保你的代码按预期工作，这一概念我们将在[第5章](chapter5.xhtml)中讨论。
- en: 2.  **Synthesis.** The synthesis process is what turns your code into low-level
    components that perform the actual functionality on your FPGA. It’s similar to
    how a compiler in a programming language like C turns your C code into Assembly
    instructions. In this book, we’ll use iCEcube2 as a synthesis tool.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 2. **综合（Synthesis）**。综合过程是将你的代码转化为在FPGA上执行实际功能的低级组件。这类似于编程语言（如C语言）中的编译器将你的C代码转换为汇编指令。在本书中，我们将使用iCEcube2作为综合工具。
- en: 3.  **Place and route.** This process will take your synthesized design and
    map it to the physical layout of your specific FPGA. It will wire up (route) the
    connections between components, including connecting the input and output pins
    to the inner FPGA components. Creating links between pins and signals in your
    code is one of the purposes of the *physical constraints file*. You’ll see how
    to write a constraint file in this project. iCEcube2 handles the place and route
    step at the same time that it handles synthesis.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 3. **布局与布线（Place and route）**。这个过程将把你综合后的设计映射到你特定FPGA的物理布局上。它将布线（route）组件之间的连接，包括将输入输出引脚连接到FPGA内部组件。创建引脚和信号之间链接的一个重要目的就是*物理约束文件*。你将在这个项目中看到如何编写约束文件。iCEcube2在处理综合的同时，也会处理布局与布线的步骤。
- en: 4.  **Programming.** This is where you take the output of the previous steps
    and load it onto your physical FPGA. The programming file literally creates wired
    connections between pins and FPGA components, and within the FPGA itself. This
    project will simply create wires between pins, but in future projects we’ll use
    other FPGA components as well. The programming step happens within Diamond Programmer.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 4. **编程（Programming）**。在这一步，你将把前一步的输出加载到实际的FPGA中。编程文件实际上在引脚和FPGA组件之间，以及FPGA内部，创建了连接。这个项目将仅创建引脚之间的连接线，但在未来的项目中，我们还将使用其他FPGA组件。编程步骤在Diamond
    Programmer中进行。
- en: All the projects in this book will follow this same basic process. As you work
    on later projects, refer back to this section if you need a refresher on using
    iCEcube2 and Diamond Programmer.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有项目都将遵循相同的基本过程。当你进行后续项目时，如果需要复习如何使用iCEcube2和Diamond Programmer，可以回顾本节内容。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Code</samp>
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">编写代码</samp>
- en: Let’s design an FPGA that links the switch inputs to the LED outputs using Verilog
    or VHDL. Hopefully by this point you’ve chosen which language you want to learn;
    I suggest focusing on just one for now, but you can always pick up the other later.
    All of this book’s code examples are shown in both languages, so you can compare
    and contrast the code as well.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设计一个 FPGA，用 Verilog 或 VHDL 将开关输入连接到 LED 输出。希望到这个时候你已经选择了想要学习的语言；我建议现在专注于学习一种，但你也可以稍后学习另一种。本书中的所有代码示例都以两种语言展示，所以你也可以进行对比和对照。
- en: I’ve had success writing FPGA code with Visual Studio Code (VS Code), a free
    tool from Microsoft. You can download extensions that will enable Verilog or VHDL
    syntax highlighting and other useful features, like the ability to tie to GitHub
    repositories directly from the code editor. You could also write your code directly
    in iCEcube2, but I wouldn’t recommend it, as it doesn’t have syntax highlighting.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我成功地在 Visual Studio Code (VS Code) 中编写了 FPGA 代码，VS Code 是微软提供的一款免费的工具。你可以下载扩展插件，使其支持
    Verilog 或 VHDL 语法高亮及其他实用功能，例如直接从代码编辑器连接到 GitHub 仓库。你也可以直接在 iCEcube2 中编写代码，但我不推荐这样做，因为它不支持语法高亮。
- en: Whatever tool you choose, enter the following Verilog or VHDL code and save
    it on your computer. Take note of the filename and location, as you’ll need it
    later. All of the code in this book is also available in the book’s GitHub repository,
    [*https://<wbr>github<wbr>.com<wbr>/nandland<wbr>/getting<wbr>-started<wbr>-with<wbr>-fpgas*](https://github.com/nandland/getting-started-with-fpgas).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择什么工具，输入以下 Verilog 或 VHDL 代码并将其保存在电脑中。请记住文件名和位置，因为稍后会用到。书中的所有代码也可以在本书的 GitHub
    仓库中找到，[*https://<wbr>github<wbr>.com<wbr>/nandland<wbr>/getting<wbr>-started<wbr>-with<wbr>-fpgas*](https://github.com/nandland/getting-started-with-fpgas)。
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s consider broadly how this code is structured, since all our projects will
    follow this same general format. The design for an FPGA is encapsulated inside
    one or more *modules* (in Verilog) or *entities* (in VHDL). These modules/entities
    define the interface to a block of code. The interface has signals, which can
    be inputs or outputs. At the highest level of your FPGA, these signals will connect
    to physical pins on your device, thereby creating the interfaces to other components,
    such as switches and LEDs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们广泛地考虑一下这段代码的结构，因为我们所有的项目都将遵循相同的基本格式。FPGA 的设计被封装在一个或多个 *模块*（在 Verilog 中）或
    *实体*（在 VHDL 中）中。这些模块/实体定义了代码块的接口。接口包含信号，这些信号可以是输入或输出。在 FPGA 的最高层次，这些信号将连接到设备上的物理引脚，从而创建与其他组件（如开关和
    LED）的接口。
- en: To create a module in Verilog, you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">module</samp>
    keyword and provide a descriptive name—in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">Switches_To_LEDs</samp>
    ❶. Inside the module, the first thing you do is declare all the input ❷ and output
    ❸ signals, enclosed in a set of parentheses. Then comes the code for what you
    want the module to actually do, which we’ll discuss in detail momentarily, followed
    by the <samp class="SANS_TheSansMonoCd_W5Regular_11">endmodule</samp> keyword.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Verilog 中创建一个模块时，你需要使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">module</samp>
    关键字，并提供一个描述性的名称——在这个例子中是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Switches_To_LEDs</samp>
    ❶。在模块内部，首先要声明所有的输入 ❷ 和输出 ❸ 信号，这些信号放在一对括号中。接下来是你希望模块执行的代码，我们稍后会详细讨论，最后是 <samp class="SANS_TheSansMonoCd_W5Regular_11">endmodule</samp>
    关键字。
- en: Looking at the VHDL version, the first thing you might notice is that it’s a
    bit longer than the Verilog version. This is typical; VHDL generally takes more
    typing to accomplish the same task compared to Verilog. Some of the extra length
    comes at the very beginning of the listing, where we specify which VHDL library
    and package we’ll be using. In this case, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_1164</samp>
    package from the <samp class="SANS_TheSansMonoCd_W5Regular_11">ieee</samp> library.
    We need this to get access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic</samp>
    data type, which is commonly used to represent binary values (0, 1) within your
    FPGA. Get used to including this library and package. You’ll need it for every
    VHDL design you create.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 VHDL 版本时，首先你可能会注意到它比 Verilog 版本稍长。这是典型现象；与 Verilog 相比，VHDL 通常需要更多的输入来完成相同的任务。额外的长度主要出现在代码的最开始部分，在这里我们指定了将使用的
    VHDL 库和包。在这种情况下，我们使用来自 <samp class="SANS_TheSansMonoCd_W5Regular_11">ieee</samp>
    库的 <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_1164</samp> 包。我们需要这个包来访问
    <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic</samp> 数据类型，它通常用来表示 FPGA
    中的二进制值（0，1）。你需要习惯在每个 VHDL 设计中包含这个库和包。
- en: Whereas in Verilog you declare the inputs and outputs and code the actual logic
    of the module as part of the same code block, in VHDL you do this with two separate
    code blocks. This is another reason why the VHDL version is longer. First, you
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">entity</samp> keyword to
    declare the VHDL entity ❶, giving it a name and specifying its inputs ❷ and outputs
    ❸. Then, in a separate code block, you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">architecture</samp>
    keyword to declare the *architecture* of the entity, which is the code that defines
    the entity’s functionality. You’ll almost always have a single entity/architecture
    pair in a VHDL file, with the entity describing the input/output interface and
    the architecture describing the functionality.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Verilog 中，你声明输入和输出，并将模块的实际逻辑编码在同一个代码块中；而在 VHDL 中，你会用两个独立的代码块来完成这些操作。这是 VHDL
    版本较长的另一个原因。首先，你使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">entity</samp>
    关键字声明 VHDL 实体❶，为其命名并指定输入❷和输出❸。然后，在一个独立的代码块中，你使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">architecture</samp>
    关键字声明实体的 *架构*，这是定义实体功能的代码。你几乎总是会在一个 VHDL 文件中使用一个实体/架构对，实体描述输入/输出接口，而架构描述功能。
- en: 'Now that we’ve covered the structure of the code, let’s look at the specifics.
    In both the Verilog and VHDL versions, we define the four input signals ❷ corresponding
    to the four switches: <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_3</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_4</samp>. In Verilog,
    these inputs will be defined as 1 bit wide (a single 0 or 1) by default, whereas
    in VHDL we explicitly define them as <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic</samp>,
    which is a 1-bit-wide data type. We similarly define the four outputs, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_3</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_4</samp>, for the four
    LEDs ❸. Notice that I like to precede my input signal names with <samp class="SANS_TheSansMonoCd_W5Regular_11">i_</samp>
    and my output signal names with <samp class="SANS_TheSansMonoCd_W5Regular_11">o_</samp>.
    This helps me to keep track of which direction each signal is going in.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讲解了代码的结构，让我们来看一下具体内容。在 Verilog 和 VHDL 版本中，我们都定义了对应于四个开关的四个输入信号❷：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_2</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_3</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_4</samp>。在
    Verilog 中，这些输入默认定义为 1 位宽（单个 0 或 1），而在 VHDL 中，我们明确地将它们定义为 <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic</samp>，这是一种
    1 位宽的数据类型。我们同样定义了四个输出：<samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_LED_2</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_3</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_4</samp>，对应四个 LED ❸。注意，我喜欢在输入信号名称前加上
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_</samp>，在输出信号名称前加上 <samp class="SANS_TheSansMonoCd_W5Regular_11">o_</samp>。这样可以帮助我跟踪每个信号的方向。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*You can define your inputs and outputs in any order, but it’s customary to
    put inputs first.*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以按任意顺序定义输入和输出，但通常习惯先定义输入。*'
- en: Finally, we define the logic of the design—the code that actually does the work—by
    *assigning* the inputs to the outputs ❹. For example, we take the value on input
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp> and assign it
    to the output <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>. When
    the FPGA is built, this will create a physical wire between these two pins. In
    Verilog we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">assign</samp>
    keyword, which requires the <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    for the actual signal assignment. In VHDL, we can just use the <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>
    assignment to create the wire between the input and the output.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过*分配*输入和输出来定义设计的逻辑——实际上执行工作的代码❹。例如，我们将输入<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>的值分配给输出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>。当FPGA构建完成后，这将创建这两个引脚之间的物理连接。在Verilog中，我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">assign</samp>关键字，并需要使用<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>进行实际的信号分配。在VHDL中，我们只需使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>赋值符号，即可在输入和输出之间创建连接线。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a New iCEcube2
    Project</samp>
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建新iCEcube2项目</samp>
- en: Once you have the coding done, it’s time to bring the design into iCEcube2 so
    you can build it. Open iCEcube2 and select **File****New Project**. You’ll be
    taken to a window asking for information about your FPGA board, as shown in [Figure
    2-4](#fig2-4). Let’s review the settings in this window.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完成编码后，就可以将设计导入到iCEcube2中进行构建。打开iCEcube2，选择**文件****新建项目**。系统会弹出一个窗口，要求输入有关FPGA板的信息，如[图2-4](#fig2-4)所示。我们先来查看这个窗口中的设置。
- en: '![](../images/Figure2-4.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-4: The iCEcube2 New
    Project window</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图2-4：iCEcube2新建项目窗口</samp>
- en: For the Project Name, give your project whatever name you like, and for the
    Project Directory, choose where on your computer you want it saved. Next, you
    need to tell the tool which FPGA you’re using. It needs to know how many resources
    the FPGA has, which pins go where, and everything about how it works to properly
    turn your code into something compatible with your specific device. To do this,
    select **iCE40** from the Device Family drop-down, then choose your FPGA’s specific
    device name and package from the Device and Device Package drop-downs. For example,
    if you were using the Nandland Go Board (one of the boards discussed in [Appendix
    A](appendix_A.xhtml)), you would choose HX1K for the device and VQ100 for the
    package, then select 3.3 from the topBank, leftBank, bottomBank, and rightBank
    drop-downs. This tells the tool that all the pins on the device operate at 3.3
    volts. Everything else in the window can remain at the default settings. Click
    **Next** when you’re done.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于项目名称，给你的项目取一个名字；对于项目目录，选择你希望将项目保存到计算机的位置。接下来，你需要告诉工具你使用的是哪款FPGA。工具需要知道FPGA的资源数量、引脚分配以及如何工作，才能正确地将你的代码转化为与你的特定设备兼容的格式。为此，选择**iCE40**作为设备系列，从设备和设备封装下拉框中选择你FPGA的具体设备名称和封装。例如，如果你使用的是Nandland
    Go板（[附录A](appendix_A.xhtml)中讨论的板之一），你会选择HX1K作为设备，VQ100作为封装，然后在topBank、leftBank、bottomBank和rightBank下拉框中选择3.3。这表示所有引脚的电压为3.3伏特。窗口中的其他设置可以保持默认。完成后，点击**下一步**。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*You’ll use these same settings for every single project, so you can refer
    back to this section each time you create a new project.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*你将在每个项目中使用这些相同的设置，因此每次创建新项目时，你可以参考这一部分内容。*'
- en: You’ll be taken to another dialog that prompts you to add the Verilog or VHDL
    source file that you created previously. Go ahead and add your file, or click
    **Finish** to skip this step for now. If you choose to skip adding your file from
    the dialog, you can do so later by expanding the Synthesis Tool menu on the left
    side of the main iCEcube2 project window, right-clicking Design Files, and selecting
    Add Files, as shown in [Figure 2-5](#fig2-5).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 系统将带你进入另一个对话框，提示你添加之前创建的Verilog或VHDL源文件。你可以添加文件，或者点击**完成**跳过此步骤。如果你选择跳过文件添加，可以稍后通过展开iCEcube2主项目窗口左侧的综合工具菜单，右击设计文件，选择添加文件，如[图2-5](#fig2-5)所示。
- en: '![](../images/Figure2-5.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-5: Adding Verilog
    or VHDL source files to your project</samp>'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-5：将 Verilog 或 VHDL 源文件添加到你的项目中</samp>
- en: This Design Files menu also makes it possible to add additional files to an
    existing project after it’s been created, or to remove and replace files that
    you’ve added previously.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计文件菜单还允许在项目创建后向现有项目添加额外文件，或删除和替换先前添加的文件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Pin Constraints</samp>
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">添加引脚约束</samp>
- en: The next step in the build process is to add the pin constraints to your project.
    These constraints, which you declare in a *.pcf (physical constraints file)* file
    (sometimes referred to as pin constraint file), tell the tool which signals in
    your Verilog or VHDL code will be connected to which physical pins on your FPGA.
    This information is critical to the place and route stage of the build process,
    when the output of the synthesis process is mapped to the physical resources on
    your FPGA. The tool needs to know which pins are connected to the switches and
    LEDs so all the wires in the design can be routed to where they need to go.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程中的下一步是将引脚约束添加到你的项目中。这些约束在*.pcf（物理约束文件）*文件中声明（有时称为引脚约束文件），它们告诉工具你在 Verilog
    或 VHDL 代码中的哪些信号将连接到 FPGA 上的哪些物理引脚。这些信息对构建过程中的布局与布线阶段至关重要，在该阶段，综合过程的输出将映射到 FPGA
    上的物理资源。工具需要知道哪些引脚连接到开关和 LED，以便将设计中的所有连线路由到它们需要去的地方。
- en: 'Each FPGA manufacturer has its own keywords for writing constraints. To declare
    a pin constraint for Lattice’s iCEcube2, you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_io</samp>
    keyword, followed by the name of one of the signals in your design, followed by
    the corresponding pin number on the FPGA itself. Here’s an example of what the
    physical constraint file should look like for this project, but keep in mind that
    the actual pin numbers will vary depending on your development board. As an example,
    these pin numbers would work for the Nandland Go Board:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 FPGA 制造商都有自己的约束编写关键字。要声明 Lattice iCEcube2 的引脚约束，你需要使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">set_io</samp>
    关键字，后跟设计中信号的名称，然后是 FPGA 上对应的引脚号。以下是该项目的物理约束文件的示例，但请记住，实际的引脚编号将根据你的开发板有所不同。例如，这些引脚编号适用于
    Nandland Go 开发板：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each line maps one of the signals in our code to one of the pins on the FPGA.
    For example, we set the Verilog/VHDL signal <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>
    to be connected to pin <samp class="SANS_TheSansMonoCd_W5Regular_11">56</samp>
    on the FPGA ❶. The signal names you use in the physical constraint file must match
    the signal names in your Verilog/VHDL code exactly. If the names don’t match,
    the tool won’t know which signal goes to which physical pin on the device.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行将我们代码中的一个信号映射到 FPGA 上的一个引脚。例如，我们将 Verilog/VHDL 信号<samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>设置为连接到
    FPGA 上的引脚<samp class="SANS_TheSansMonoCd_W5Regular_11">56</samp> ❶。你在物理约束文件中使用的信号名称必须与
    Verilog/VHDL 代码中的信号名称完全匹配。如果名称不匹配，工具将不知道哪个信号连接到设备上的哪个物理引脚。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Notice that comments in the physical constraint file are preceded with a #
    symbol—an octothorpe, pound sign, or hashtag, depending on your age.*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，物理约束文件中的注释前面有一个#符号——这是一个井号、磅号或标签，具体取决于你的年龄。*'
- en: When setting your pin constraints, you’ll need to look at the reference schematic
    for your FPGA development board. The schematic contains the wiring diagram for
    the circuit board. It tells you which pin of the FPGA is connected to which LED,
    button, connector pin, or other device. Learning how to read this basic schematic
    information is a critical skill for an FPGA designer, as setting pin constraints
    is a common task.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置引脚约束时，你需要查看 FPGA 开发板的参考原理图。该原理图包含电路板的接线图，告诉你 FPGA 的哪个引脚连接到哪个 LED、按钮、连接器引脚或其他设备。学习如何阅读这些基本的原理图信息是
    FPGA 设计师的关键技能，因为设置引脚约束是常见的任务。
- en: To add the physical constraint file to your project, find the P&R Flow section
    in the menu on the left side of the iCEcube2 project window, expand **Add P&R
    Files**, and right-click **Constraint Files**. Then click **Add Files** and select
    your *.pcf* file. Once you do this, you’ll see the file listed under Constraint
    Files.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要将物理约束文件添加到项目中，在 iCEcube2 项目窗口左侧菜单中找到 P&R 流程部分，展开 **添加 P&R 文件**，右键点击 **约束文件**，然后点击
    **添加文件**，选择你的 *.pcf* 文件。完成后，你将看到该文件列在约束文件下。
- en: Forgetting to add a physical constraint file is a common mistake when working
    with FPGAs. If you don’t add one, the tool won’t warn you about it. Instead, they’ll
    just connect the signals in your code to randomly chosen pins on your device.
    This will almost certainly be wrong, and your design won’t work as you expect.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 忘记添加物理约束文件是使用 FPGA 时常见的错误。如果没有添加该文件，工具不会给你任何警告。它们会将你代码中的信号随机连接到设备上的引脚，这几乎肯定是错误的，导致你的设计无法按预期工作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Build</samp>
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">运行构建</samp>
- en: You’re now ready to run the build in iCEcube2\. To do this, simply click **Tool****Run
    All**. This will execute both the synthesis and place and route processes, creating
    the FPGA image file that you’ll use to program the FPGA. iCEcube2 generates a
    report for each of these steps, visible under the Reports section. You’re welcome
    to explore these reports to see what type of information they contain; we’ll dive
    into the details in future chapters.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好在 iCEcube2 中运行构建了。为此，只需点击 **工具****全部运行**。这将执行综合、布局与布线的过程，创建你将用来编程 FPGA
    的 FPGA 映像文件。iCEcube2 会为每个步骤生成报告，可以在报告部分查看。你可以随意查看这些报告，了解它们包含了哪些信息；我们将在后续章节中详细探讨。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Connecting Your Development
    Board</samp>
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">连接你的开发板</samp>
- en: You now need to connect your board to your computer to program the FPGA. Take
    a minute to make sure this connection works and that your computer recognizes
    the device. With the board unplugged, open up Device Manager in Windows and expand
    the Ports (COM & LPT) section. Now go ahead and plug in the board via USB. You
    should see two devices labeled “USB Serial Port (COM*X*)” pop up, as shown in
    [Figure 2-6](#fig2-6). The specific COM port index numbers don’t matter. If this
    works for you, then your board is connected to your computer and you’re ready
    to go.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要将开发板连接到电脑，以便编程 FPGA。花一点时间确保这个连接正常，并且电脑能识别设备。拔掉开发板后，打开 Windows 中的设备管理器，并展开“端口（COM
    与 LPT）”部分。然后通过 USB 插入开发板。你应该会看到两个标记为“USB 串口 (COM*X*)”的设备，如 [图 2-6](#fig2-6) 所示。具体的
    COM 端口编号不重要。如果一切正常，那说明你的开发板已成功连接到电脑，你可以开始工作了。
- en: '![](../images/Figure2-6.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-6: Viewing the board
    connection in Device Manager</samp>'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-6：在设备管理器中查看开发板连接情况</samp>
- en: If you don’t see the USB serial ports in Device Manager, there are a few troubleshooting
    techniques to try. First, check if your board has a power LED for indicating when
    it’s on. If it does, but that LED isn’t illuminated, you don’t have power, so
    check that the USB cable is firmly plugged into the board and into your computer.
    If the LED *is* illuminated, then the next most likely issue is the USB cable
    itself. Some Micro-USB cables are “charge only,” meaning they don’t have the wires
    that allow for data transfer. Get another cable that you know works to transfer
    data to and from a computer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在设备管理器中没有看到 USB 串口，可以尝试以下几种故障排除方法。首先，检查开发板上是否有电源指示灯，用于显示电源是否开启。如果有，但指示灯没有亮起，说明没有供电，请检查
    USB 电缆是否已牢固插入开发板和电脑。如果指示灯 *亮着*，那么下一个最可能的问题就是 USB 电缆本身。一些 Micro-USB 电缆仅支持“充电”，即没有传输数据的线缆。请更换一条你知道可以正常进行数据传输的电缆。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Programming the FPGA</samp>
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">编程 FPGA</samp>
- en: The final step in the process is to program your design to your FPGA using Diamond
    Programmer. An FPGA development board typically features an integrated circuit
    that turns its USB connection into the SPI interface, which Diamond Programmer
    uses to program a flash memory chip installed on the board. Once that’s done,
    the FPGA will boot up from the flash, and you’ll see the fruits of your labor!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 过程的最后一步是使用Diamond Programmer将设计编程到FPGA中。FPGA开发板通常配备一个集成电路，将其USB连接转为SPI接口，Diamond
    Programmer使用该接口对安装在板上的闪存芯片进行编程。完成后，FPGA将从闪存启动，你将看到努力的成果！
- en: With your board connected, open up Diamond Programmer to get started. You’ll
    be greeted with the dialog shown in [Figure 2-7](#fig2-7). Click **OK** to create
    a new project.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接好开发板后，打开Diamond Programmer开始操作。你将看到如[图2-7](#fig2-7)所示的对话框。点击**确定**以创建新项目。
- en: '![](../images/Figure2-7.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-7: The Diamond Programmer
    dialog</samp>'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图2-7：Diamond Programmer对话框</samp>
- en: Once you click OK, the tool will try to scan the board to automatically identify
    which FPGA is connected. It will fail. That’s fine; we can manually tell Diamond
    Programmer which FPGA to target from the next screen, which is shown in [Figure
    2-8](#fig2-8).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦点击确定，工具将尝试扫描开发板并自动识别连接的FPGA。这将失败。没关系；我们可以从下一个界面手动告诉Diamond Programmer目标FPGA，具体内容如[图2-8](#fig2-8)所示。
- en: '![](../images/Figure2-8.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-8.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-8: The Diamond Programmer
    device selection screen</samp>'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图2-8：Diamond Programmer设备选择界面</samp>
- en: Set the Device Family to **iCE40** and choose your specific FPGA from the Device
    drop-down, as shown in [Figure 2-8](#fig2-8). Next, double-click the field under
    Operation. You’ll be greeted with a new window, shown in [Figure 2-9](#fig2-9).
    Note that you may need to change the access mode to SPI Flash Programming to see
    the contents shown here.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将设备系列设置为**iCE40**，并从设备下拉框中选择你的具体FPGA，如[图2-8](#fig2-8)所示。接下来，双击操作字段下的内容。你将看到一个新窗口，如[图2-9](#fig2-9)所示。请注意，你可能需要将访问模式更改为SPI闪存编程，以查看此处显示的内容。
- en: '![](../images/Figure2-9.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-9.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-9: The Diamond Programmer
    Device Properties window</samp>'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图2-9：Diamond Programmer设备属性窗口</samp>
- en: This window lets you tell Diamond Programmer how to program your FPGA. In the
    Device Operation section, set the access mode to **SPI Flash** **Programming**.
    For the SPI Flash Options section, you’ll have to consult the programming guide
    for your development board to determine which SPI flash device is used. For the
    Go Board, for example, you’d set the family to SPI Serial Flash, the vendor to
    Micron, and the device to M25P10, as shown in [Figure 2-9](#fig2-9).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口让你可以告诉Diamond Programmer如何编程FPGA。在设备操作部分，将访问模式设置为**SPI闪存** **编程**。对于SPI闪存选项部分，你需要参考你的开发板的编程指南，以确定使用的是哪个SPI闪存设备。例如，对于Go开发板，你需要将系列设置为SPI串行闪存，供应商设置为Micron，设备设置为M25P10，如[图2-9](#fig2-9)所示。
- en: Finally, in the Programming Options section, click the three dots next to the
    Programming File box and choose the *.bin* file to program to the FPGA. This is
    the file you generated using iCEcube2, located in the */<Project_Name>_Implmnt/sbt/outputs/bitmap/*
    subdirectory inside the directory where you saved your iCEcube2 project. Leave
    all the other settings on their defaults, and click **OK** to close this window.
    Now you’re ready to program.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在编程选项部分，点击编程文件框旁边的三个点，选择要编程到FPGA的*.bin*文件。这个文件是你通过iCEcube2生成的，位于保存iCEcube2项目的目录下的*/<Project_Name>_Implmnt/sbt/outputs/bitmap/*子目录中。保留其他所有设置为默认值，并点击**确定**以关闭此窗口。现在你已经准备好进行编程了。
- en: 'Open the **Design** menu and select **Program**. If everything was done correctly,
    you should see <samp class="SANS_TheSansMonoCd_W5Regular_11">INFO — Operation:
    successful</samp> after a few seconds. This means that your SPI flash has been
    programmed and your FPGA is running! Try pushing each switch on your board. You
    should see the corresponding LED light up when the button is held down. Congratulations,
    you’ve built your first FPGA project!'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**设计**菜单并选择**程序**。如果一切操作正确，几秒钟后你应该看到 <samp class="SANS_TheSansMonoCd_W5Regular_11">INFO
    — 操作：成功</samp>。这意味着你的SPI闪存已被编程，FPGA正在运行！尝试按下开发板上的每个开关。按住按钮时，相应的LED灯应亮起。恭喜你，你已经完成了第一个FPGA项目！
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*I recommend saving your Diamond Programmer project so you can reuse the settings
    for the other projects in the book. All you’ll have to do is select a different*
    .bin *file to program to the FPGA.*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*我建议保存你的Diamond Programmer项目，这样你可以将设置用于书中的其他项目。你只需要选择一个不同的*.bin*文件来编程到FPGA中。*'
- en: 'If the programming fails, you might get a <samp class="SANS_TheSansMonoCd_W5Regular_11">CHECK_ID</samp>
    error like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编程失败，你可能会遇到类似这样的<samp class="SANS_TheSansMonoCd_W5Regular_11">CHECK_ID</samp>错误：
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you see this error, go to the Cable Settings section in the right pane of
    Diamond Programmer and change your port from FTUSB-0 to **FTUSB-1**, as shown
    in [Figure 2-10](#fig2-10).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到这个错误，请转到Diamond Programmer右侧面板中的Cable Settings部分，并将端口从FTUSB-0更改为**FTUSB-1**，如[图2-10](#fig2-10)所示。
- en: '![](../images/Figure2-10.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-10.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-10: Troubleshooting
    a CHECK_ID error</samp>'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图2-10：排查CHECK_ID错误</samp>
- en: Once you make the change, try to program your device again. This time it should
    work.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你进行更改，再次尝试编程设备。这次应该能成功。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: 'In this chapter, you created an FPGA development environment and learned how
    to work with a development board. Through your first project, you learned about
    the main steps in the FPGA development process: design, where you write code for
    the FPGA using Verilog or VHDL; synthesis, where you translate that code into
    FPGA components; place and route, where you map the synthesized design to the
    resources on your specific FPGA; and programming, where the design is physically
    transferred to the FPGA. We’ll explore these concepts in more detail later in
    the book, but as you work through other projects, remember that you can refer
    back to this chapter if you need a refresher on the basics of using your FPGA
    tools.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你创建了一个FPGA开发环境，并学习了如何使用开发板。通过你的第一个项目，你了解了FPGA开发过程中的主要步骤：设计，即使用Verilog或VHDL编写FPGA代码；综合，即将代码转换为FPGA组件；布置与布线，即将综合设计映射到特定FPGA的资源；以及编程，即将设计物理地传输到FPGA中。我们将在本书后面更详细地探讨这些概念，但在进行其他项目时，如果你需要复习使用FPGA工具的基础知识，可以随时参考本章。
