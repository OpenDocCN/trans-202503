- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">SETTING
    UP YOUR HARDWARE AND TOOLS</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter walks you through the process of choosing an FPGA development board
    and setting up the associated software tools that you’ll need to translate your
    Verilog or VHDL code into physical circuits on your FPGA. You’ll learn about the
    features to look for in a board, download and install the tools you need to work
    with it, and test them out by designing your first FPGA project to target your
    development board. This project will also give you an overview of the main steps
    in the FPGA development process.
  prefs: []
  type: TYPE_NORMAL
- en: An FPGA development board isn’t strictly required to use this book. You can
    still learn from the projects without a board, and you can always test your Verilog
    or VHDL code by running it through a free online FPGA simulator tool like EDA
    Playground (a topic we’ll cover in [Chapter 5](chapter5.xhtml)). However, there’s
    something satisfying about writing some code, programming it to a development
    board, and seeing the results in action—even when it does something as simple
    as blinking an LED. For this reason, I highly recommend that you have an FPGA
    development board on hand when learning about FPGAs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Choosing an FPGA Development Board</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An FPGA development board (or *dev board*) is a printed circuit board (PCB)
    with an FPGA on it that allows you to program the FPGA with your Verilog or VHDL
    code and test it out. The board may also have peripherals on it that are connected
    to the FPGA, such as LEDs, switches, and connectors for linking the FPGA to other
    devices. FPGA development boards range from devices the size of a pack of gum
    that cost less than $100 to laptop-size devices that cost thousands of dollars.
    With such a wide range of options, there are many factors you should consider
    when choosing a development board, including price, ease of use, and enjoyability:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cost**'
  prefs: []
  type: TYPE_NORMAL
- en: For an FPGA beginner, I recommend starting off with an inexpensive development
    board. Larger, more expensive boards often have many extra features, like SerDes
    and DDR memory, that are unnecessary and potentially overwhelming for new users.
    You can always invest in one of these more sophisticated boards as your skills
    mature and you grow out of your first board.
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The board you start out with and the software required to work with it should
    be simple to use. It’s challenging enough to learn how an FPGA works; if you also
    have to learn how to use a complicated design tool, the process becomes even more
    difficult. I recommend focusing on boards built around Lattice Semiconductor’s
    iCE40 family of FPGAs, since these FPGAs are compatible with a lightweight and
    simple set of software tools: iCEcube2 and Diamond Programmer. These programs
    are streamlined to do the minimum required to build your FPGA, without all the
    bells and whistles of more advanced programs. You’ll learn how to use both of
    them in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fun**'
  prefs: []
  type: TYPE_NORMAL
- en: An FPGA development board should be fun to use, with peripherals like LEDs,
    push buttons, and seven-segment displays that you can take advantage of in different
    projects. Some cheaper boards cut costs by removing peripherals; they just have
    an FPGA and nothing else. FPGA development is much more fun and interesting when
    you can interface the FPGA with other devices.
  prefs: []
  type: TYPE_NORMAL
- en: Keep these factors in mind as you consider the development boards available
    on the market.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Requirements for the Book</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ll get the most value out of this book if you follow along with the projects
    and program your own development board. To go through the projects exactly as
    written, you’ll need your development board to have the following features ([Appendix
    A](appendix_A.xhtml) lists a few boards that meet these requirements, or can meet
    them with a few modifications):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lattice iCE40 FPGA**'
  prefs: []
  type: TYPE_NORMAL
- en: iCE40 FPGAs have emerged as the best option for FPGA beginners. They’ve been
    available for many years at affordable prices, while providing enough resources
    to support interesting projects. The iCE40 architecture is relatively simple,
    with few distracting bells and whistles, so you can focus on what’s important.
    As I mentioned earlier, iCE40 FPGAs are compatible with the free, easy-to-use
    iCEcube2 and Diamond Programmer software tools, which we’ll explore in this chapter.
    The iCE40 family is also compatible with open source FPGA tools, if you want to
    avoid proprietary software altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**USB**'
  prefs: []
  type: TYPE_NORMAL
- en: Your development board should have a USB interface to power and program the
    board. This way, all you need is one USB cable and you’re ready to go. Older FPGA
    development boards often require an external programmer (a separate piece of hardware
    that can itself cost hundreds of dollars), so make sure simple built-in USB programming
    is possible with the board you choose.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEDs**'
  prefs: []
  type: TYPE_NORMAL
- en: The book’s projects assume that your board has four LEDs. These are a convenient
    way to get output from the FPGA. For example, our first project later this chapter
    will involve lighting up the LEDs, which allows you to get immediate feedback
    that you’ve successfully programmed the FPGA. There’s nothing more satisfying
    than getting that first LED to light up!
  prefs: []
  type: TYPE_NORMAL
- en: '**Switches**'
  prefs: []
  type: TYPE_NORMAL
- en: For each of the four LEDs, you’ll need a corresponding push-button switch. These
    switches provide input to the FPGA, allowing you to easily change the state of
    the board.
  prefs: []
  type: TYPE_NORMAL
- en: '**Seven-Segment Display**'
  prefs: []
  type: TYPE_NORMAL
- en: Your board will need one seven-segment display to implement the memory game
    project in [Chapter 8](chapter8.xhtml). This kind of display provides a fun way
    to output data. Lighting up individual LEDs is one thing, but lighting up numbers
    and letters on a seven-segment display is much more engaging.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your development board doesn’t meet all these requirements, don’t worry:
    you can still work through this book’s projects with a few adjustments. For example,
    if you’d prefer to work with a board built around a different kind of FPGA, you
    can. As we’ll discuss in later chapters, there are advanced features that vary
    from one FPGA to another, but the code for this book’s projects is general enough
    that it should work on any modern FPGA. That’s part of the beauty of Verilog and
    VHDL: they’re FPGA-agnostic.'
  prefs: []
  type: TYPE_NORMAL
- en: Do be aware that if you aren’t working with an iCE40 FPGA, however, you’ll need
    to use a different set of software tools than the ones discussed in this chapter.
    Each FPGA company provides its own tools specifically aimed at its FPGAs. For
    example, AMD (Xilinx) has Vivado, and Intel (Altera) has Quartus. If your board
    has an FPGA from one of these companies, look online for resources about using
    the appropriate software.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t have all the necessary peripherals for the projects in this book,
    you have a few options. First, you can modify the projects’ Verilog or VHDL code
    to use fewer LEDs and switches. This will work in most cases, although the memory
    game project in [Chapter 8](chapter8.xhtml) will be less satisfying the fewer
    LEDs and switches you use.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, many FPGA development boards, including some of the boards discussed
    in [Appendix A](appendix_A.xhtml), have connection points for wiring up your own
    peripherals. In particular, look for a development board with a Pmod (peripheral
    module) connector. Pmod is a standard connector made famous by Digilent for attaching
    accessory boards with extra peripherals— not just the ones used in this book,
    but also devices like temperature sensors, accelerometers, audio jacks, microSD
    cards, and more. If you’ve ever worked with Arduino Shields, it’s the same concept.
    If your board has a Pmod connector, that will greatly expand the range of projects
    you can work on with your FPGA.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setting Up Your Development Environment</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the iCE40 FPGA on your development board, you’ll need to install two
    software tools on your computer: iCEcube2 and Diamond Programmer. These free tools
    from Lattice Semiconductor are designed specifically for working with iCE40 FPGAs.
    This section walks you through the process of setting them up. If you’re on Windows,
    you’ll have the easiest time, since the tools are designed for the Windows operating
    system. For Linux or macOS users, I recommend creating a Windows virtual machine
    on your computer, then running the Lattice tools in that. There are many tutorials
    online for setting up a Windows virtual machine using VirtualBox or a similar
    product.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">iCEcube2</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: iCEcube2 is Lattice’s free integrated development environment (IDE) for turning
    the VHDL or Verilog code you write on your computer into a file that the FPGA
    can be programmed with. It’s much easier to use than other IDEs like Vivado, Quartus,
    or even Lattice Diamond (not to be confused with Diamond Programmer), Lattice’s
    tool for working with more sophisticated FPGAs. Their compatibility with iCEcube2
    is part of what makes iCE40 FPGAs an especially good choice for beginners. Those
    other programs are all several gigabytes in size and extremely complicated. They
    have many bells and whistles, most of which you won’t need when you’re getting
    started. By contrast, iCEcube2 is more streamlined, making it a more straightforward
    tool for learning about FPGAs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To download and install iCEcube2, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Visit [*https://<wbr>latticesemi<wbr>.com<wbr>/icecube2*](https://latticesemi.com/icecube2)
    or search the internet for “iCEcube2 download.”
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Find the download link for the latest Windows version of iCEcube2, whether
    you’re running Windows natively or in a virtual machine. If you’re a Linux user,
    you may be tempted to download the Linux version instead, but I wouldn’t recommend
    it. That version is buggy; you might have success, or you might not.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  When you click the download link, you’ll be asked to create an account on
    the Lattice website. You must create an account to get a license for this tool.
    Make sure to use a real email address, as they’ll email you the free license.
    Once you create an account, you should be able to download the software.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  As the software is downloading, find the **iCECube2 Software Free License**
    link on the download page and click it to request a license.
  prefs: []
  type: TYPE_NORMAL
- en: '5.  You’ll need your computer’s MAC address to obtain the license. To find
    it on Windows, open a command prompt by clicking the Start button and searching
    for “cmd.” Then enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ipconfig /all</samp>
    at the command line. You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 6.  Your MAC address is the 12-digit hexadecimal number next to <samp class="SANS_TheSansMonoCd_W5Regular_11">Physical
    Address</samp>. Copy this into the Lattice license request form and submit the
    form to have a license file sent to your email address.
  prefs: []
  type: TYPE_NORMAL
- en: 7.  Launch the iCEcube2 installer once it finishes downloading and point it
    to your license file.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*If you already installed iCEcube2 before obtaining the license, you can use
    the program* LicenseSetup.exe *in the same folder where you installed the tool
    to point it at your license file.*'
  prefs: []
  type: TYPE_NORMAL
- en: When it’s done installing, launch iCEcube2\. The main window will look something
    like [Figure 2-1](#fig2-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The iCEcube2 main
    window</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Click around to get a feel for the program. We’ll explore it in more detail
    later in this chapter with a project that will take you through the entire FPGA
    build process.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Diamond Programmer</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Diamond Programmer is a free standalone programming tool from Lattice that
    takes the output of iCEcube2 and uses it to program your FPGA via your development
    board’s USB connection. More sophisticated software tools like Vivado and Quartus
    have a built-in programmer, so you don’t need to download a separate program.
    It’s unfortunate that iCEcube2 doesn’t have one built in, but such is the life
    of an iCE40 FPGA designer! Here’s how to install Diamond Programmer:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Go to [*https://<wbr>latticesemi<wbr>.com<wbr>/programmer*](https://latticesemi.com/programmer)
    or search the internet for “lattice diamond software” to locate the download page.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  The Diamond Programmer page has many download links to choose from. Find
    and click the link for the latest version of Programmer Standalone 64-bit for
    Windows.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">WARNING</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*Be sure to download Programmer Standalone and not the Programmer Standalone
    Encryption Pack. The latter isn’t needed.*'
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Diamond Programmer doesn’t require a license, so simply run the installer
    once it downloads.
  prefs: []
  type: TYPE_NORMAL
- en: You’re now ready to dive into your first FPGA project, where you’ll learn how
    to work with these tools and program your FPGA.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #1: Wiring Switches to LEDs</samp>'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project, you’ll get familiar with the build process by creating a simple
    FPGA design: when you press one of the push-button switches on your FPGA development
    board, one of the LEDs should light up. The project assumes that you have four
    switches and four LEDs, so you’ll design and program your FPGA to wire up each
    switch to one of the LEDs. (As mentioned earlier, you can adapt the project to
    use fewer switches and LEDs if needed.) [Figure 2-2](#fig2-2) shows a diagram
    of what we want to do.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: The Project #1
    block diagram</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: On the left we have the board’s four switches, labeled SW1 through SW4\. By
    default, these will be open (not connected), meaning the corresponding input pin
    of the FPGA will have a low voltage when the switch isn’t pressed, due to an onboard
    pull-down resistor. When you press a switch down, the FPGA will see a high voltage
    present at the input pin connected to that switch. On the output side we have
    four LEDs, labeled D1 through D4\. We want to create an FPGA that will connect
    the switches and LEDs such that, for example, when the user presses SW1, the D1
    LED illuminates. We’ll literally be creating a physical wired connection between
    the SW1 input and the D1 output using our FPGA. In other words, with FPGAs you’re
    programming at such a low level that you’re creating wires between pins, throughout
    your device.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this project, we’ll go through four main steps. These steps, summarized
    in [Figure 2-3](#fig2-3), form the main phases of the FPGA build process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-3: The FPGA build
    process</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll familiarize yourself with the steps at a high level through this project.
    Then you’ll expand your knowledge of each step throughout the book. The four steps
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  **Design.** In this step, you write the Verilog or VHDL code that describes
    how the FPGA will function. You might also write tests to ensure that your code
    will work as you intend, a concept we’ll discuss in [Chapter 5](chapter5.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 2.  **Synthesis.** The synthesis process is what turns your code into low-level
    components that perform the actual functionality on your FPGA. It’s similar to
    how a compiler in a programming language like C turns your C code into Assembly
    instructions. In this book, we’ll use iCEcube2 as a synthesis tool.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  **Place and route.** This process will take your synthesized design and
    map it to the physical layout of your specific FPGA. It will wire up (route) the
    connections between components, including connecting the input and output pins
    to the inner FPGA components. Creating links between pins and signals in your
    code is one of the purposes of the *physical constraints file*. You’ll see how
    to write a constraint file in this project. iCEcube2 handles the place and route
    step at the same time that it handles synthesis.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  **Programming.** This is where you take the output of the previous steps
    and load it onto your physical FPGA. The programming file literally creates wired
    connections between pins and FPGA components, and within the FPGA itself. This
    project will simply create wires between pins, but in future projects we’ll use
    other FPGA components as well. The programming step happens within Diamond Programmer.
  prefs: []
  type: TYPE_NORMAL
- en: All the projects in this book will follow this same basic process. As you work
    on later projects, refer back to this section if you need a refresher on using
    iCEcube2 and Diamond Programmer.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Code</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s design an FPGA that links the switch inputs to the LED outputs using Verilog
    or VHDL. Hopefully by this point you’ve chosen which language you want to learn;
    I suggest focusing on just one for now, but you can always pick up the other later.
    All of this book’s code examples are shown in both languages, so you can compare
    and contrast the code as well.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve had success writing FPGA code with Visual Studio Code (VS Code), a free
    tool from Microsoft. You can download extensions that will enable Verilog or VHDL
    syntax highlighting and other useful features, like the ability to tie to GitHub
    repositories directly from the code editor. You could also write your code directly
    in iCEcube2, but I wouldn’t recommend it, as it doesn’t have syntax highlighting.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever tool you choose, enter the following Verilog or VHDL code and save
    it on your computer. Take note of the filename and location, as you’ll need it
    later. All of the code in this book is also available in the book’s GitHub repository,
    [*https://<wbr>github<wbr>.com<wbr>/nandland<wbr>/getting<wbr>-started<wbr>-with<wbr>-fpgas*](https://github.com/nandland/getting-started-with-fpgas).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let’s consider broadly how this code is structured, since all our projects will
    follow this same general format. The design for an FPGA is encapsulated inside
    one or more *modules* (in Verilog) or *entities* (in VHDL). These modules/entities
    define the interface to a block of code. The interface has signals, which can
    be inputs or outputs. At the highest level of your FPGA, these signals will connect
    to physical pins on your device, thereby creating the interfaces to other components,
    such as switches and LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: To create a module in Verilog, you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">module</samp>
    keyword and provide a descriptive name—in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">Switches_To_LEDs</samp>
    ❶. Inside the module, the first thing you do is declare all the input ❷ and output
    ❸ signals, enclosed in a set of parentheses. Then comes the code for what you
    want the module to actually do, which we’ll discuss in detail momentarily, followed
    by the <samp class="SANS_TheSansMonoCd_W5Regular_11">endmodule</samp> keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the VHDL version, the first thing you might notice is that it’s a
    bit longer than the Verilog version. This is typical; VHDL generally takes more
    typing to accomplish the same task compared to Verilog. Some of the extra length
    comes at the very beginning of the listing, where we specify which VHDL library
    and package we’ll be using. In this case, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_1164</samp>
    package from the <samp class="SANS_TheSansMonoCd_W5Regular_11">ieee</samp> library.
    We need this to get access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic</samp>
    data type, which is commonly used to represent binary values (0, 1) within your
    FPGA. Get used to including this library and package. You’ll need it for every
    VHDL design you create.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas in Verilog you declare the inputs and outputs and code the actual logic
    of the module as part of the same code block, in VHDL you do this with two separate
    code blocks. This is another reason why the VHDL version is longer. First, you
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">entity</samp> keyword to
    declare the VHDL entity ❶, giving it a name and specifying its inputs ❷ and outputs
    ❸. Then, in a separate code block, you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">architecture</samp>
    keyword to declare the *architecture* of the entity, which is the code that defines
    the entity’s functionality. You’ll almost always have a single entity/architecture
    pair in a VHDL file, with the entity describing the input/output interface and
    the architecture describing the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve covered the structure of the code, let’s look at the specifics.
    In both the Verilog and VHDL versions, we define the four input signals ❷ corresponding
    to the four switches: <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_3</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_4</samp>. In Verilog,
    these inputs will be defined as 1 bit wide (a single 0 or 1) by default, whereas
    in VHDL we explicitly define them as <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic</samp>,
    which is a 1-bit-wide data type. We similarly define the four outputs, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_3</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_4</samp>, for the four
    LEDs ❸. Notice that I like to precede my input signal names with <samp class="SANS_TheSansMonoCd_W5Regular_11">i_</samp>
    and my output signal names with <samp class="SANS_TheSansMonoCd_W5Regular_11">o_</samp>.
    This helps me to keep track of which direction each signal is going in.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*You can define your inputs and outputs in any order, but it’s customary to
    put inputs first.*'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we define the logic of the design—the code that actually does the work—by
    *assigning* the inputs to the outputs ❹. For example, we take the value on input
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp> and assign it
    to the output <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>. When
    the FPGA is built, this will create a physical wire between these two pins. In
    Verilog we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">assign</samp>
    keyword, which requires the <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    for the actual signal assignment. In VHDL, we can just use the <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>
    assignment to create the wire between the input and the output.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a New iCEcube2
    Project</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have the coding done, it’s time to bring the design into iCEcube2 so
    you can build it. Open iCEcube2 and select **File****New Project**. You’ll be
    taken to a window asking for information about your FPGA board, as shown in [Figure
    2-4](#fig2-4). Let’s review the settings in this window.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-4: The iCEcube2 New
    Project window</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: For the Project Name, give your project whatever name you like, and for the
    Project Directory, choose where on your computer you want it saved. Next, you
    need to tell the tool which FPGA you’re using. It needs to know how many resources
    the FPGA has, which pins go where, and everything about how it works to properly
    turn your code into something compatible with your specific device. To do this,
    select **iCE40** from the Device Family drop-down, then choose your FPGA’s specific
    device name and package from the Device and Device Package drop-downs. For example,
    if you were using the Nandland Go Board (one of the boards discussed in [Appendix
    A](appendix_A.xhtml)), you would choose HX1K for the device and VQ100 for the
    package, then select 3.3 from the topBank, leftBank, bottomBank, and rightBank
    drop-downs. This tells the tool that all the pins on the device operate at 3.3
    volts. Everything else in the window can remain at the default settings. Click
    **Next** when you’re done.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*You’ll use these same settings for every single project, so you can refer
    back to this section each time you create a new project.*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll be taken to another dialog that prompts you to add the Verilog or VHDL
    source file that you created previously. Go ahead and add your file, or click
    **Finish** to skip this step for now. If you choose to skip adding your file from
    the dialog, you can do so later by expanding the Synthesis Tool menu on the left
    side of the main iCEcube2 project window, right-clicking Design Files, and selecting
    Add Files, as shown in [Figure 2-5](#fig2-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-5: Adding Verilog
    or VHDL source files to your project</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This Design Files menu also makes it possible to add additional files to an
    existing project after it’s been created, or to remove and replace files that
    you’ve added previously.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Pin Constraints</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step in the build process is to add the pin constraints to your project.
    These constraints, which you declare in a *.pcf (physical constraints file)* file
    (sometimes referred to as pin constraint file), tell the tool which signals in
    your Verilog or VHDL code will be connected to which physical pins on your FPGA.
    This information is critical to the place and route stage of the build process,
    when the output of the synthesis process is mapped to the physical resources on
    your FPGA. The tool needs to know which pins are connected to the switches and
    LEDs so all the wires in the design can be routed to where they need to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each FPGA manufacturer has its own keywords for writing constraints. To declare
    a pin constraint for Lattice’s iCEcube2, you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_io</samp>
    keyword, followed by the name of one of the signals in your design, followed by
    the corresponding pin number on the FPGA itself. Here’s an example of what the
    physical constraint file should look like for this project, but keep in mind that
    the actual pin numbers will vary depending on your development board. As an example,
    these pin numbers would work for the Nandland Go Board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Each line maps one of the signals in our code to one of the pins on the FPGA.
    For example, we set the Verilog/VHDL signal <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>
    to be connected to pin <samp class="SANS_TheSansMonoCd_W5Regular_11">56</samp>
    on the FPGA ❶. The signal names you use in the physical constraint file must match
    the signal names in your Verilog/VHDL code exactly. If the names don’t match,
    the tool won’t know which signal goes to which physical pin on the device.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that comments in the physical constraint file are preceded with a #
    symbol—an octothorpe, pound sign, or hashtag, depending on your age.*'
  prefs: []
  type: TYPE_NORMAL
- en: When setting your pin constraints, you’ll need to look at the reference schematic
    for your FPGA development board. The schematic contains the wiring diagram for
    the circuit board. It tells you which pin of the FPGA is connected to which LED,
    button, connector pin, or other device. Learning how to read this basic schematic
    information is a critical skill for an FPGA designer, as setting pin constraints
    is a common task.
  prefs: []
  type: TYPE_NORMAL
- en: To add the physical constraint file to your project, find the P&R Flow section
    in the menu on the left side of the iCEcube2 project window, expand **Add P&R
    Files**, and right-click **Constraint Files**. Then click **Add Files** and select
    your *.pcf* file. Once you do this, you’ll see the file listed under Constraint
    Files.
  prefs: []
  type: TYPE_NORMAL
- en: Forgetting to add a physical constraint file is a common mistake when working
    with FPGAs. If you don’t add one, the tool won’t warn you about it. Instead, they’ll
    just connect the signals in your code to randomly chosen pins on your device.
    This will almost certainly be wrong, and your design won’t work as you expect.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Build</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’re now ready to run the build in iCEcube2\. To do this, simply click **Tool****Run
    All**. This will execute both the synthesis and place and route processes, creating
    the FPGA image file that you’ll use to program the FPGA. iCEcube2 generates a
    report for each of these steps, visible under the Reports section. You’re welcome
    to explore these reports to see what type of information they contain; we’ll dive
    into the details in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Connecting Your Development
    Board</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You now need to connect your board to your computer to program the FPGA. Take
    a minute to make sure this connection works and that your computer recognizes
    the device. With the board unplugged, open up Device Manager in Windows and expand
    the Ports (COM & LPT) section. Now go ahead and plug in the board via USB. You
    should see two devices labeled “USB Serial Port (COM*X*)” pop up, as shown in
    [Figure 2-6](#fig2-6). The specific COM port index numbers don’t matter. If this
    works for you, then your board is connected to your computer and you’re ready
    to go.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-6: Viewing the board
    connection in Device Manager</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the USB serial ports in Device Manager, there are a few troubleshooting
    techniques to try. First, check if your board has a power LED for indicating when
    it’s on. If it does, but that LED isn’t illuminated, you don’t have power, so
    check that the USB cable is firmly plugged into the board and into your computer.
    If the LED *is* illuminated, then the next most likely issue is the USB cable
    itself. Some Micro-USB cables are “charge only,” meaning they don’t have the wires
    that allow for data transfer. Get another cable that you know works to transfer
    data to and from a computer.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Programming the FPGA</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final step in the process is to program your design to your FPGA using Diamond
    Programmer. An FPGA development board typically features an integrated circuit
    that turns its USB connection into the SPI interface, which Diamond Programmer
    uses to program a flash memory chip installed on the board. Once that’s done,
    the FPGA will boot up from the flash, and you’ll see the fruits of your labor!
  prefs: []
  type: TYPE_NORMAL
- en: With your board connected, open up Diamond Programmer to get started. You’ll
    be greeted with the dialog shown in [Figure 2-7](#fig2-7). Click **OK** to create
    a new project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-7: The Diamond Programmer
    dialog</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once you click OK, the tool will try to scan the board to automatically identify
    which FPGA is connected. It will fail. That’s fine; we can manually tell Diamond
    Programmer which FPGA to target from the next screen, which is shown in [Figure
    2-8](#fig2-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-8: The Diamond Programmer
    device selection screen</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Set the Device Family to **iCE40** and choose your specific FPGA from the Device
    drop-down, as shown in [Figure 2-8](#fig2-8). Next, double-click the field under
    Operation. You’ll be greeted with a new window, shown in [Figure 2-9](#fig2-9).
    Note that you may need to change the access mode to SPI Flash Programming to see
    the contents shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-9.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-9: The Diamond Programmer
    Device Properties window</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This window lets you tell Diamond Programmer how to program your FPGA. In the
    Device Operation section, set the access mode to **SPI Flash** **Programming**.
    For the SPI Flash Options section, you’ll have to consult the programming guide
    for your development board to determine which SPI flash device is used. For the
    Go Board, for example, you’d set the family to SPI Serial Flash, the vendor to
    Micron, and the device to M25P10, as shown in [Figure 2-9](#fig2-9).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the Programming Options section, click the three dots next to the
    Programming File box and choose the *.bin* file to program to the FPGA. This is
    the file you generated using iCEcube2, located in the */<Project_Name>_Implmnt/sbt/outputs/bitmap/*
    subdirectory inside the directory where you saved your iCEcube2 project. Leave
    all the other settings on their defaults, and click **OK** to close this window.
    Now you’re ready to program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Design** menu and select **Program**. If everything was done correctly,
    you should see <samp class="SANS_TheSansMonoCd_W5Regular_11">INFO — Operation:
    successful</samp> after a few seconds. This means that your SPI flash has been
    programmed and your FPGA is running! Try pushing each switch on your board. You
    should see the corresponding LED light up when the button is held down. Congratulations,
    you’ve built your first FPGA project!'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*I recommend saving your Diamond Programmer project so you can reuse the settings
    for the other projects in the book. All you’ll have to do is select a different*
    .bin *file to program to the FPGA.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the programming fails, you might get a <samp class="SANS_TheSansMonoCd_W5Regular_11">CHECK_ID</samp>
    error like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you see this error, go to the Cable Settings section in the right pane of
    Diamond Programmer and change your port from FTUSB-0 to **FTUSB-1**, as shown
    in [Figure 2-10](#fig2-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-10.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-10: Troubleshooting
    a CHECK_ID error</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once you make the change, try to program your device again. This time it should
    work.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, you created an FPGA development environment and learned how
    to work with a development board. Through your first project, you learned about
    the main steps in the FPGA development process: design, where you write code for
    the FPGA using Verilog or VHDL; synthesis, where you translate that code into
    FPGA components; place and route, where you map the synthesized design to the
    resources on your specific FPGA; and programming, where the design is physically
    transferred to the FPGA. We’ll explore these concepts in more detail later in
    the book, but as you work through other projects, remember that you can refer
    back to this chapter if you need a refresher on the basics of using your FPGA
    tools.'
  prefs: []
  type: TYPE_NORMAL
