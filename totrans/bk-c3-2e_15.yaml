- en: '**15**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**15**'
- en: '**FLEXIBLE BOX LAYOUT**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**弹性盒布局**'
- en: '![Image](graphics/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/common-01.jpg)'
- en: That web pages look as good as they do is a minor miracle (comparatively speaking,
    of course!). Since the move away from tablebased layouts to pure CSS, developers
    have often had to create complex page structures using simple tools such as `float`,
    `margin`, and `position`—tools perhaps not even intended for that purpose when
    they were first created. As CSS has matured and browsers have grown more powerful,
    a new range of alternative layout approaches has been proposed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 网页看起来如此美观，可以说是一种小小的奇迹（当然，相对而言！）。自从从基于表格的布局转向纯 CSS 布局以来，开发人员经常不得不使用简单的工具，如 `float`、`margin`
    和 `position`，来创建复杂的页面结构——这些工具在最初设计时可能并非为了这个目的。随着 CSS 的成熟和浏览器功能的增强，提出了一系列新的替代布局方法。
- en: The one most widely implemented is called Flexible Box Layout (or *Flexbox*).
    This approach is defined in the Flexible Box Layout Module (*[http://www.w3.org/TR/css-flexbox-1/](http://www.w3.org/TR/css-flexbox-1/)*),
    and it makes elements resize flexibly to better fit their available space, without
    the need for floats, positioning, or complex calculations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最广泛实现的方法被称为弹性盒布局（或 *Flexbox*）。这种方法定义在弹性盒布局模块（*[http://www.w3.org/TR/css-flexbox-1/](http://www.w3.org/TR/css-flexbox-1/)*）中，它使得元素能够灵活调整大小，更好地适应可用空间，而无需使用浮动、定位或复杂的计算。
- en: Although you can certainly create entire page layouts with Flexbox, it is most
    suitable for working with interface elements and smaller components. When working
    with whole page layouts, consider using the Grid Layout Module, which I’ll introduce
    in [Chapter 17](ch17.html#ch17). But if you’re building a user interface or an
    app (especially an app with a lot of buttons, form elements, or interactive regions),
    you’ll find Flexbox extremely useful.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你完全可以使用 Flexbox 创建整个页面布局，但它更适用于处理界面元素和较小的组件。在处理整个页面布局时，建议使用网格布局模块（Grid Layout
    Module），我将在[第 17 章](ch17.html#ch17)中介绍它。但如果你正在构建用户界面或应用程序（尤其是包含许多按钮、表单元素或交互区域的应用），你会发现
    Flexbox 非常有用。
- en: '**Declaring the Flexible Box Model**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**声明弹性盒模型**'
- en: 'The first step in using Flexbox is to create the *flex container*—the parent
    element that will create a new formatting context for its contents. To declare
    a flex container, you simply use a new value for the `display` property:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Flexbox 的第一步是创建*弹性容器*——这个父元素将为其内容创建一个新的格式化上下文。要声明一个弹性容器，你只需为 `display` 属性使用一个新值：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This creates a block-level flex container; you can use the alternate `inline-flex`
    value if you prefer an inline-level container.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个块级弹性容器；如果你更喜欢内联级容器，可以使用 `inline-flex` 值。
- en: 'Now you can add *flex items* to the flex container. A flex item is any child
    of the flex container, which is subject to the formatting context created by the
    container. For example, in the following code if `#container` is set as the flex
    container, the two child items will become flex items:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将*弹性项目*添加到弹性容器中。弹性项目是弹性容器的任何子项，它会受到容器创建的格式化上下文的影响。例如，在以下代码中，如果 `#container`
    被设置为弹性容器，那么这两个子项将成为弹性项目：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This combination of markup and CSS is shown in [Figure 15-1](ch15.html#ch15fig1).
    Notice that the two elements are of equal width and laid out next to each other,
    without needing to use floats or positioning properties. By default, flex items
    are laid out in the direction of the document text—that is, from left to right
    for languages such as English, from right to left for languages such as Arabic
    (specified with the `dir` HTML attribute or `direction` CSS property), and from
    top to bottom for languages such as Japanese (set with the `text-direction` CSS
    property, but not yet broadly supported).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种标记和 CSS 的组合如[图 15-1](ch15.html#ch15fig1)所示。请注意，这两个元素的宽度相等并且并排排列，无需使用浮动或定位属性。默认情况下，弹性项目会按照文档文本的方向排列——即，对于英语等语言，从左到右排列；对于阿拉伯语等语言，从右到左排列（可以通过
    `dir` HTML 属性或 `direction` CSS 属性来指定）；对于日语等语言，从上到下排列（通过 `text-direction` CSS 属性设置，但尚未广泛支持）。
- en: '![Image](graphics/f15-01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f15-01.jpg)'
- en: '*Figure 15-1: Child items of a flex container are laid out horizontally by
    default.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-1：弹性容器的子项默认水平排列。*'
- en: '**NOTE**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All of the examples throughout the rest of this chapter use the left-to-right
    direction, unless otherwise stated.*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章其余部分的所有示例都使用从左到右的方向，除非另有说明。*'
- en: To alter the default layout direction, you can use the `flex-direction` property
    on the container. The default value `row` lays items out in a row, whereas a value
    of `column` lays them out from top to bottom in a column.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改默认的布局方向，您可以在容器上使用`flex-direction`属性。默认值`row`会将项目排列成一行，而`column`值则会将项目从上到下排列成一列。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Flexbox Alignment**'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Flexbox 对齐方式**'
- en: 'Flexbox uses two axes for alignment. As shown in [Figure 15-2](ch15.html#ch15fig2),
    the *main axis* goes in the direction that items are placed, from left to right
    or top to bottom. When the value of `flex-direction` is `row`, the main axis is
    horizontal; when it is `column`, the main axis is vertical. The *cross axis* is
    the line that runs perpendicular to the main axis: it’s vertical when the direction
    is `row` and horizontal when it’s `column`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Flexbox使用两条轴线进行对齐。如[图 15-2](ch15.html#ch15fig2)所示，*主轴*沿着项目排列的方向，横向或纵向排列。当`flex-direction`的值为`row`时，主轴是水平的；当它是`column`时，主轴是垂直的。*交叉轴*是与主轴垂直的线：当方向为`row`时，交叉轴是垂直的；当方向为`column`时，交叉轴是水平的。
- en: '![Image](graphics/f15-02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f15-02.jpg)'
- en: '*Figure 15-2: The main and cross axes depend on the direction of the layout
    of the flex children.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-2：主轴和交叉轴取决于flex子项的布局方向。*'
- en: When dealing with flex containers and items, you’ll often see points referred
    to as the start and end of axes. Because flex axes can be reversed (from top to
    bottom or bottom to top, and left to right or right to left), you use start and
    end rather than relative directions to prevent confusion. For example, when the
    main axis is horizontal and the direction is from left to right, the start of
    the main axis is the left and the end is the right; but if the main axis is vertical,
    the start of the main axis is at the top and the end is at the bottom (or vice
    versa if reversed).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理flex容器和项目时，您经常会看到所谓的轴的起点和终点。因为flex轴可以被反转（从上到下或从下到上，从左到右或从右到左），所以使用起点和终点，而不是相对方向，以避免混淆。例如，当主轴是水平的且方向是从左到右时，主轴的起点是左侧，终点是右侧；但如果主轴是垂直的，则主轴的起点是在顶部，终点在底部（如果反转则相反）。
- en: '**Reversing the Content Order**'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**反转内容顺序**'
- en: One of Flexbox’s great capabilities is that you can quickly change the order
    in which items are displayed, regardless of their order in the DOM. For example,
    [Figure 15-1](ch15.html#ch15fig1) shows two items laid out in a row, in the order
    in which they’re declared in the DOM. What if you want to change their order so
    `#b` comes before `#a`?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Flexbox的一个强大功能是，您可以快速更改项目的显示顺序，而不管它们在DOM中的顺序。例如，[图 15-1](ch15.html#ch15fig1)显示了两个项目按它们在DOM中声明的顺序排列成一行。如果您想更改它们的顺序，让`#b`排在`#a`之前，该怎么办呢？
- en: You can do this quickly with the `flex-direction` property, using the value
    `row-reverse` to reverse the order in which the flex items are displayed, as shown
    here. (The `column-reverse` property value reverses the order of flex items vertically
    displayed in columns.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`flex-direction`属性快速做到这一点，使用`row-reverse`值来反转flex项目的显示顺序，如图所示。（`column-reverse`属性值会反转垂直排列的flex项目的顺序。）
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The result is shown in [Figure 15-3](ch15.html#ch15fig3).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如[图 15-3](ch15.html#ch15fig3)所示。
- en: '![Image](graphics/f15-03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f15-03.jpg)'
- en: '*Figure 15-3: The* `*row-reverse*` *value quickly reverses the order of flex
    items.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-3：*`*row-reverse*`*值快速反转flex项目的顺序。*'
- en: Because reversing directions like this also reverses the axis direction, in
    the case of `row-reverse`, the start of the axis is on the left, and the end is
    on the right. In the case of `column-reverse`, the start is at the bottom, and
    the end is at the top.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于像这样的方向反转也会反转轴的方向，因此在`row-reverse`的情况下，轴的起点在左侧，终点在右侧；在`column-reverse`的情况下，起点在底部，终点在顶部。
- en: '**Fully Reordering Content**'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**完全重新排列内容**'
- en: 'You can create custom ordering patterns with the `order` property. The `order`
    property is applied to the flex items (not their container). The value of the
    property is a number that creates an *ordinal group* that groups together items
    with the same value and orders them by their ordinal group: All items in the lowest
    numbered group come first, then all items in the second-lowest numbered group,
    and so on. Any items without a declared value are shown first because they have
    the default value of 0.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`order`属性创建自定义的排序模式。`order`属性应用于flex项目（而不是它们的容器）。该属性的值是一个数字，用于创建一个*顺序组*，该组将具有相同值的项目分组，并按顺序组的顺序排列它们：最低编号的顺序组中的所有项目排在最前面，然后是第二低编号顺序组的所有项目，依此类推。任何没有声明值的项目会首先显示，因为它们的默认值为0。
- en: 'Items with the same ordinal group number are grouped in the order in which
    they appear in the DOM. For example, consider four flex items, `#a` through `#d`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有相同顺序组编号的项目按它们在DOM中出现的顺序进行分组。例如，考虑四个flex项目，`#a`到`#d`：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If no explicit values are set, and if `flex-direction` isn’t reversed, the
    children are displayed in the order in which they appear in the DOM: `#a`, `#b`,
    `#c`, `#d`. But let’s reorder them by using different values on the `order` property:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有设置显式的值，并且如果`flex-direction`没有被反转，那么子项将按照它们在DOM中出现的顺序显示：`#a`、`#b`、`#c`、`#d`。但是，接下来我们通过使用不同的`order`属性值来重新排列它们：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With these rules applied, the order in which the items are laid out becomes:
    `#c`, `#a`, `#b`, `#d`. Item `#c` comes first because it has the lowest ordinal
    group number, followed by `#a` with the next highest number, then `#b` and `#d`—both
    of which are in ordinal group 3\. Item `#d` comes last because it comes later
    in the DOM order.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 应用这些规则后，项目的排列顺序变为：`#c`、`#a`、`#b`、`#d`。项目`#c`排在最前面，因为它属于最低编号的顺序组，接着是编号次低的`#a`，然后是`#b`和`#d`——这两者都属于顺序组3。项目`#d`排在最后，因为它在DOM顺序中排得较晚。
- en: '[Figure 15-4](ch15.html#ch15fig4) shows the result.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15-4](ch15.html#ch15fig4)显示了结果。'
- en: '![Image](graphics/f15-04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f15-04.jpg)'
- en: '*Figure 15-4: The flex items reordered using ordinal groups*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-4：使用顺序组重新排列的flex项目*'
- en: 'Notice that items `#c` and `#a` share the same background colors, as do `#b`
    and `#d`. The background colors should alternate because I’m using the `:nth-child()`
    pseudo-class discussed in [Chapter 4](ch04.html#ch04):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`#c`和`#a`共享相同的背景颜色，`#b`和`#d`也是如此。背景颜色应该交替显示，因为我使用了在[第4章](ch04.html#ch04)中讨论的`:nth-child()`伪类：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But remember that the items have only changed order visually; they retain the
    same order in the markup, which is why `:nth-child()` applies the gray background
    to the elements that should be even numbered—namely, `#b` and `#d`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，项目只是视觉上改变了顺序；它们在标记中的顺序保持不变，这就是为什么`:nth-child()`将灰色背景应用于应为偶数编号的元素——即`#b`和`#d`。
- en: '**Adding Flexibility**'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加灵活性**'
- en: When using Flexbox, you will almost certainly encounter situations where the
    combined lengths of flex items along the main axis are greater or less than the
    width of the flex container. When this happens, the “flexible” part of Flexbox
    comes into play. Several properties allow flex items to grow or shrink to fill
    their container. I’ll walk you through them in this section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Flexbox时，你几乎肯定会遇到这种情况：沿主轴的flex项目的总长度大于或小于flex容器的宽度。当这种情况发生时，Flexbox的“灵活”特性就会发挥作用。几个属性允许flex项目根据需要增长或缩小以填充它们的容器。我将在本节中带你了解这些属性。
- en: '***The flex-grow Property***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***`flex-grow`属性***'
- en: Let’s say you have a flex container 600px wide that contains three flex items.
    Each one is 150px wide, making a combined width of 450px. The difference between
    the width of the container and the combined width of the items leaves an empty
    space of 150px (that’s 600 − 450) at the end of the items, as shown in [Figure
    15-5](ch15.html#ch15fig5).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个宽度为600px的flex容器，里面包含三个flex项目。每个项目的宽度是150px，总宽度为450px。容器的宽度和项目的总宽度之间的差异留出了150px的空白区域（即600
    − 450），如[图15-5](ch15.html#ch15fig5)所示。
- en: '![Image](graphics/f15-05.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f15-05.jpg)'
- en: '*Figure 15-5: Three flex items with a combined width narrower than the width
    of their container leaves empty space on the right.*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-5：三个flex项目的总宽度小于其容器的宽度，导致右侧留有空白区域。*'
- en: 'To expand the items to fill the container, you can use the `flex-grow` property:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要扩展项目以填充容器，你可以使用`flex-grow`属性：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The value of the `flex-grow` property is basically a ratio that’s used to distribute
    the empty space between the flex items so they expand. In this case, I used a
    1:1:1 ratio to divide the empty 150px equally between the three flex items. Because
    150 divided by 3 is 50, each item is expanded by 50px, making their total width
    equal to the width of the container, as shown in [Figure 15-6](ch15.html#ch15fig6).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex-grow`属性的值基本上是一个比率，用于在flex项目之间分配空余空间，以便它们扩展。在这个例子中，我使用了1:1:1的比例，将空余的150px均等地分配给三个flex项目。因为150除以3等于50，每个项目扩展了50px，使得它们的总宽度等于容器的宽度，如[图15-6](ch15.html#ch15fig6)所示。'
- en: '![Image](graphics/f15-06.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f15-06.jpg)'
- en: '*Figure 15-6: The three flex items now fill the width of their container.*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-6：这三个flex项目现在填充了它们容器的宽度。*'
- en: 'You can also provide different values to adjust the distribution ratio. For
    example, to make `#b` take up more of the width of the container than the other
    two items, you could set a value of 3 for `#b`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以提供不同的值来调整分配比例。例如，若要使`#b`占据比其他两个项目更多的容器宽度，你可以为`#b`设置一个值为3：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now the 150px will be redistributed using the ratio 1:3:1, so for every one
    pixel distributed to `#a` and `#c`, `#b` will receive three. As a result `#a`
    and `#c` will each be expanded to 180px wide, whereas `#b` will be 240px wide
    as shown in [Figure 15-7](ch15.html#ch15fig7).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，150px将按1:3:1的比例重新分配，因此对于每一个分配给`#a`和`#c`的像素，`#b`将分配到三个像素。结果是`#a`和`#c`的宽度各自扩展到180px，而`#b`的宽度将变为240px，如[图15-7](ch15.html#ch15fig7)所示。
- en: '![Image](graphics/f15-07.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f15-07.jpg)'
- en: '*Figure 15-7: Because* `*#b*` *has a higher* `*flex-grow*` *value, when resized,
    it’s wider than its siblings.*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-7：因为* `*#b*` *的`*flex-grow*` *值更高，当调整大小时，它比其他兄弟项更宽。*'
- en: Because the default value for `flex-grow` is 0 (zero), flex items will keep
    their width and not expand to fill the container unless explicitly instructed
    to do so.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`flex-grow`的默认值是0（零），所以flex项目会保持它们的宽度，并不会扩展来填充容器，除非明确指示这样做。
- en: '***The flex-shrink Property***'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***flex-shrink属性***'
- en: Just as `flex-grow` is used to expand flex items to fill their container, `flex-shrink`
    is used to shrink items. For example, let’s revisit our flex container from the
    previous section with items `#a`, `#b`, and `#c`; only in this case, we’ll make
    each item 300px wide. Now the total width of the three items is 900px, which exceeds
    the 600px width of the parent by 300px.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`flex-grow`用于扩展flex项目以填充容器一样，`flex-shrink`用于缩小项目。例如，让我们回到前一节的flex容器，包含`#a`、`#b`和`#c`项目；只不过这次我们将每个项目的宽度设为300px。现在，三个项目的总宽度是900px，超过了父容器600px的宽度，超出部分为300px。
- en: 'To shrink these elements to fit within the container width, you could use the
    `flex-shrink` property:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些元素缩小到适应容器的宽度，你可以使用`flex-shrink`属性：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `flex-shrink` property works like `flex-grow` but in the opposite direction.
    For example, a value of 1 (the default) reduces each item by the same proportion—each
    by 100px (300 divided by 3). The resulting items will be 200px each, for a total
    of 600px, which matches the width of the container.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex-shrink`属性的作用类似于`flex-grow`，但方向相反。例如，值为1（默认值）时，每个项目的宽度会按相同比例缩小——每个项目缩小100px（300除以3）。结果是每个项目的宽度为200px，总宽度为600px，与容器宽度一致。'
- en: Like `flex-grow`, different values change the distribution ratio. For example,
    if you use a value of 3 for item `#b`, its width is reduced by three pixels for
    every one-pixel reduction of the other two items.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 像`flex-grow`一样，不同的值会改变分配比例。例如，如果你为项目`#b`使用值为3，它的宽度将在每次其他两个项目缩小1px时，减少3px。
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Higher numbers reduce the elements by a greater factor. In this example, for
    each pixel removed from the width of `#a` and `#c`, three are removed from `#b`.
    As you can see in [Figure 15-8](ch15.html#ch15fig8), `#a` and `#c` are 240px in
    width, whereas `#b` is only 120px, which is narrower than its original width.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 较高的数字会更大比例地缩小元素。在这个例子中，`#a`和`#c`的宽度每减少1px，`#b`的宽度就会减少3px。正如你在[图15-8](ch15.html#ch15fig8)中看到的，`#a`和`#c`的宽度为240px，而`#b`只有120px，比它原本的宽度更窄。
- en: '![Image](graphics/f15-08.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f15-08.jpg)'
- en: '*Figure 15-8: Flex item* `*#b*` *has a higher* `*flex-shrink*` *value than
    its siblings, so it’s shrunk proportionally more to fit its container.*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-8：Flex项目* `*#b*` *的`*flex-shrink*` *值比它的兄弟项更高，因此它被按比例缩小以适应容器。*'
- en: '***The flex-basis Property***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***flex-basis属性***'
- en: 'The width of flex items can be set either by the content they contain or by
    an explicit `width` value, and any growth or shrinkage is calculated from that
    base width. To change how the width adjustment is calculated, you can set a `flex-basis`
    value on an element. This property takes as a value a length unit. Here’s an example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When `flex-basis` is applied, any existing `width` value is ignored, and the
    value that you specify for the `flex-basis` is used to calculate the adjustment.
    For example, in the previous two sections, the `width` value of 150px is ignored
    and all growth or shrinking is based on the `flex-basis` value of 100px. You could
    add the `flex-basis` value of 100px to `#b` in [Figure 15-7](ch15.html#ch15fig7),
    like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now the empty space in the container will be redistributed using the ratio 1:3:1,
    which means that, based on the `width` values, `#a` and `#c` would expand by 30px
    each and `#b` by 90px. Because of the `flex-basis` value, however, that space
    distribution is performed as if `#b` had a width of 100px, not the specified `width`
    value of 150px.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: At first, it seems illogical that `#b` ends up wider than its siblings despite
    having a lower width set by its `flex-basis` value. The reason is that there is
    now a spare width of 200px (the combined widths of the flex items is 400px; the
    parent is 600px). This 200 is redistributed between the three boxes using the
    ratio 1:3:1\. Although `#b` begins at 100px wide, it receives 120px of the spare
    space whereas `#a` and `#c` receive 40px.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: As a result, `#a` and `#c` end up 190px wide, and `#b` is 220px wide. Compare
    the result shown in [Figure 15-9](ch15.html#ch15fig9) with [Figure 15-7](ch15.html#ch15fig7)
    to see the difference.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f15-09.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-9: Because* `*#b*` *has a* `*flex-basis*` *value applied, it’s resized
    to be larger than its siblings.*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '***The flex Shorthand***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As with many properties, the `flex-*` family has a shorthand property called
    `flex`. The values it takes are, in order, `flex-grow`, `flex-shrink`, and `flex-basis`.
    Consider this example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, element `*E*` has a `flex-grow` value of 1 and a `flex-shrink` value of
    2\. The value used is chosen based on the width of the flex items in comparison
    with their flex container; where flex items don’t fill their container, the `flex-grow`
    value is used, and where flex items exceed their container, the `flex-shrink`
    value comes into play. The final value, 150px, is the `flex-basis` value.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '**Alignment Inside the Container**'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you have items with fixed dimensions inside a flex container, you’ll likely
    have empty space along one or both of the axes. For example, in [Figure 15-5](ch15.html#ch15fig5),
    three flex items that are each 150px wide didn’t fill the width of their 600px
    container. When this is the case, you can align the items inside the container
    to make better use of the available space.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '***Horizontal Alignment with justify-content***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Thankfully, Flexbox offers tight control over alignment and placement, allowing
    you to redistribute unused space with the `justify-content` property. This property
    is applied to the flex container and accepts a series of keyword values that are
    applied differently depending on the direction of the flex parent (row, column,
    reversed row, and so on):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Flexbox 提供了对对齐和定位的精确控制，允许你使用`justify-content`属性重新分配未使用的空间。此属性应用于弹性容器，并接受一系列关键字值，根据弹性父容器的方向（如行、列、反转行等）以不同方式应用：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The default value is `flex-start`, which (as shown in [Figure 15-5](ch15.html#ch15fig5))
    aligns all flex items to the left of the parent with the unused space occupying
    the remaining width to the right. The alternative values are the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值是`flex-start`，这将所有弹性项对齐到父容器的左侧，未使用的空间占据剩余的右侧宽度。[图 15-5](ch15.html#ch15fig5)展示了这一效果。其他可选值包括：
- en: • `flex-end`, which aligns items to the right of the container with the unused
    space to the left
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: • `flex-end`，将项目对齐到容器的右侧，未使用的空间位于左侧
- en: • `center`, which distributes the unused space to either side of all items,
    centering the items in the container
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: • `center`，将未使用的空间分配到所有项目两侧，使项目居中
- en: • `space-between`, which adds an equal amount of space between each item but
    none before the first or after the last item
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: • `space-between`，在每个项目之间添加相等的空间，但第一个和最后一个项目之间没有空间
- en: • `space-around`, which puts an equal amount of space on both sides of each
    item
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: • `space-around`，在每个项目的两侧留有相等的空白
- en: The following code shows a few different values for the sake of comparison,
    with the results shown in [Figure 15-10](ch15.html#ch15fig10).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了一些不同的值供比较，结果见[图 15-10](ch15.html#ch15fig10)。
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Image](graphics/f15-10.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f15-10.jpg)'
- en: '*Figure 15-10: Different values for the* `*justify-content*` *property:* `*flex-start*`
    *(top),* `*center*` *(middle), and* `*space-around*` *(bottom)*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-10：`*justify-content*`属性的不同值：* `*flex-start*` *(顶部)，* `*center*` *(中间)，和*
    `*space-around*` *(底部)*'
- en: '***Vertical Alignment with align-items***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用align-items进行垂直对齐***'
- en: 'When the height of your flex items is less than the height of the flex container,
    you can use the property `align-items` to adjust the items within the container:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的弹性项高度小于弹性容器的高度时，可以使用`align-items`属性来调整容器内的项目：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The principal keyword values for this property are:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性的主要关键字值包括：
- en: • `stretch`, which makes items the same height as the parent
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: • `stretch`，使项目与父容器高度相同
- en: • `flex-start`, which aligns items to the top of the container
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: • `flex-start`，将项目对齐到容器的顶部
- en: • `flex-end`, which aligns items to the bottom of the container
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: • `flex-end`，将项目对齐到容器的底部
- en: • `center`, which aligns items to the vertical center of the container, with
    equal space above and below
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: • `center`，将项目对齐到容器的垂直中心，上下方留有相等的空白
- en: The default value is `stretch` if the items have no height explicitly specified,
    or `flex-start` if they do.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目没有明确指定高度，则默认值为`stretch`，如果有则为`flex-start`。
- en: In the following listing, I’ve set the flex container to have a `flex-direction`
    value of `column`, so the main axis is vertical and the cross axis is horizontal.
    [Figure 15-11](ch15.html#ch15fig11) shows the results.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，我将弹性容器的`flex-direction`值设置为`column`，因此主轴是垂直的，交叉轴是水平的。[图 15-11](ch15.html#ch15fig11)展示了结果。
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Image](graphics/f15-11.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f15-11.jpg)'
- en: '*Figure 15-11: Alignment on the cross axis is controlled with different values
    for* `*align-items*`*:* `*stretch*` *(left),* `*flex-end*` *(middle), and* `*center*`
    *(right).*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-11：交叉轴对齐通过不同的`*align-items*`值进行控制：* `*stretch*` *(左)，* `*flex-end*` *(中)，和*
    `*center*` *(右)*。*'
- en: Notice that with no explicit width set, the flex items in the second and third
    columns are sized only to the width of their content, and then aligned within
    the container based on its `align-items` value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在未设置明确宽度的情况下，第二列和第三列中的弹性项仅根据其内容的宽度来设置大小，然后根据容器的`align-items`值进行对齐。
- en: '***Cross-Axis Alignment with align-self***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用align-self进行交叉轴对齐***'
- en: To control the cross-axis alignment of individual items, use the `align-self`
    property. This property applies to the item, not the container. The values are
    the same as for `align-items`, and they have the same effects on the selected
    item only; sibling items are unaffected.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制单个项目在交叉轴上的对齐方式，请使用`align-self`属性。此属性适用于项目，而不是容器。其值与`align-items`相同，且仅对选中的项目产生影响；兄弟项目不受影响。
- en: 'For example, in the following listing, element `#c` has a different value than
    its siblings:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下代码中，元素`#c`的值与其兄弟元素不同：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The effect (using the default row direction) is shown in [Figure 15-12](ch15.html#ch15fig12).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 效果（使用默认的行方向）如[图 15-12](ch15.html#ch15fig12)所示。
- en: '![Image](graphics/f15-12.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f15-12.jpg)'
- en: '*Figure 15-12: Flex item* `*#c*` *is aligned differently from its siblings
    because of the* `*align-self*` *property.*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-12：弹性项* `*#c*` *由于* `*align-self*` *属性的作用，与其兄弟元素的对齐方式不同。*'
- en: '***Wrap and Flow***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***换行与流动***'
- en: When you have too many items to fit comfortably into one row (or column) of
    a container, you can break them onto multiple lines using the `flex-wrap` property.
    The default value of `nowrap` preserves all the items on the same line, whereas
    a value of `wrap` breaks them onto extra lines below the first (or to the right
    in column view), if required.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器中的项太多，无法舒适地放入一行（或一列）时，你可以使用`flex-wrap`属性将它们分布到多行中。`nowrap`的默认值将所有项保持在同一行，而`wrap`的值则会在需要时将它们分到第一行下方的额外行中（或在列视图中向右分布）。
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The value `wrap-reverse` changes the direction of the cross axis so new lines
    appear above (or to the left). [Figure 15-13](ch15.html#ch15fig13) compares the
    effect of the two different values.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrap-reverse`的值会改变交叉轴的方向，使新的行出现在上方（或左侧）。[图 15-13](ch15.html#ch15fig13)对比了这两个不同值的效果。'
- en: '![Image](graphics/f15-13.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f15-13.jpg)'
- en: '*Figure 15-13: Comparing the effects of different values for the* `*flex-wrap*`
    *property. The top example has a value of* `*wrap*`*, so element* `*#c*` *appears
    on a new line below, whereas in the bottom example, the value is* `*wrap-reverse*`*,
    so element* `*#c*` *is on a new line above.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-13：对比不同`*flex-wrap*`属性值的效果。顶部示例的值为`*wrap*`，因此元素`*#c*`出现在下方的新行中，而底部示例的值为`*wrap-reverse*`，因此元素`*#c*`出现在上方的新行中。*'
- en: '***The flex-flow Shorthand***'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***flex-flow 简写***'
- en: 'You can combine `flex-wrap` with `flex-direction` in the shorthand `flex-flow`
    property. For example, to set a column with multiple lines and a reversed cross
    axis, use this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`flex-wrap`与`flex-direction`结合，使用`flex-flow`属性的简写形式。例如，要设置一个带有多行并且交叉轴反转的列，可以使用以下代码：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***Aligning Multiple Lines with align-content***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 align-content 对齐多行***'
- en: When items wrap over multiple lines, you can control their alignment with the
    `align-content` property. This property works like `justify-content` but on the
    cross axis. It has the same possible values—`flex-start`, `flex-end`, `center`,
    `space-between`, and `space-around`—and also adds `stretch`, which resizes the
    items to fill all unused space. [Figure 15-14](ch15.html#ch15fig14) compares the
    effects of the values `center` and `space-between`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目在多行中换行时，你可以通过`align-content`属性控制它们的对齐方式。此属性的作用类似于`justify-content`，但应用于交叉轴。它具有相同的可能值——`flex-start`、`flex-end`、`center`、`space-between`和`space-around`——并且还添加了`stretch`，它会调整项的大小以填充所有未使用的空间。[图
    15-14](ch15.html#ch15fig14)对比了`center`和`space-between`值的效果。
- en: '![Image](graphics/f15-14.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Image](graphics/f15-14.jpg)'
- en: '*Figure 15-14: Alignment on the cross axis when flex items are wrapped is controlled
    with* `*align-content*`*:* `*center*` *(top) and* `*space-between*` *(bottom).*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-14：当弹性项被换行时，交叉轴上的对齐由*`*align-content*`*控制：*`*center*`*（顶部）和*`*space-between*`*（底部）。*'
- en: '**Browser Support and Legacy Syntaxes**'
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**浏览器支持和遗留语法**'
- en: 'As I write this, Flexbox is well implemented across all major modern browsers,
    but it has a long history of syntax changes, and supporting a handful of older
    browsers can be troublesome. For example, Internet Explorer 10 implements an earlier
    version of the spec, which uses the `-ms-` prefix for all properties. The IE10
    implementation and the modern spec have a few key differences: IE10 uses `-ms-flexbox`
    as the name of the value for the `display` property, rather than `flex`; and `-ms-flex-align`
    and `-ms-flex-pack` are used rather than `align-items` and `justify-content` (their
    values differ a little, too). IE10 also lacks any implementation of `flex-wrap`
    or the `flex-flow` shorthand. If you need to support IE10, I suggest reading all
    about the differences from the spec in the IE10 Developer Guide (*[http://msdn.microsoft.com/en-us/library/ie/hh673531%28v=vs.85%29.aspx](http://msdn.microsoft.com/en-us/library/ie/hh673531%28v=vs.85%29.aspx)*).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在写这篇文章时，Flexbox 已经在所有主流现代浏览器中得到了很好的实现，但它有着长时间的语法变更历史，支持一些较旧的浏览器可能会比较麻烦。例如，Internet
    Explorer 10 实现了该规范的早期版本，所有属性都使用 `-ms-` 前缀。IE10 实现与现代规范有一些关键区别：IE10 使用 `-ms-flexbox`
    作为 `display` 属性的值名称，而不是 `flex`；并且使用 `-ms-flex-align` 和 `-ms-flex-pack`，而不是 `align-items`
    和 `justify-content`（它们的值也略有不同）。IE10 还没有实现 `flex-wrap` 或 `flex-flow` 简写。如果你需要支持
    IE10，建议阅读关于该规范差异的 IE10 开发者指南 (*[http://msdn.microsoft.com/en-us/library/ie/hh673531%28v=vs.85%29.aspx](http://msdn.microsoft.com/en-us/library/ie/hh673531%28v=vs.85%29.aspx)*)。
- en: Older versions of WebKit-based browsers, especially Safari 6 and below, use
    an even more outdated syntax. If you really need to support these older browsers
    fully, see Stephen Hay’s introductory article from 2009 (*[http://www.the-haystack.com/2010/01/23/css3-flexbox-part-1/](http://www.the-haystack.com/2010/01/23/css3-flexbox-part-1/)*).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版本的 WebKit 核心浏览器，特别是 Safari 6 及以下版本，使用了更为过时的语法。如果你真的需要完全支持这些旧浏览器，可以查看 Stephen
    Hay 2009 年的介绍文章 (*[http://www.the-haystack.com/2010/01/23/css3-flexbox-part-1/](http://www.the-haystack.com/2010/01/23/css3-flexbox-part-1/)*).
- en: But don’t let these concerns put you off from using Flexbox. Only a handful
    of browsers require these older properties, and with a little extra work, you
    can take advantage of the layout gains that Flexbox brings.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要让这些问题阻止你使用 Flexbox。只有少数几个浏览器需要这些较旧的属性，只需稍加努力，你就能利用 Flexbox 带来的布局优势。
- en: '**Summary**'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Although it introduces a number of unfamiliar new terms and concepts to CSS,
    Flexbox is an elegant and logical proposal that solves several common problems
    with website layouts. Flexbox is harder to describe in writing than it is to learn
    by doing!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它为 CSS 引入了许多不熟悉的新术语和概念，但 Flexbox 是一个优雅且合乎逻辑的提案，解决了网站布局中几个常见的问题。Flexbox 比起写作，亲自实践学习要容易得多！
- en: Taking the time to understand Flexbox fully is certainly worthwhile, as many
    of the new concepts and keywords it introduces are essential to other layout modules
    now being produced, making it essential to the future of rich layouts on the Web.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 花时间完全理解 Flexbox 是非常值得的，因为它引入的许多新概念和关键字现在在其他布局模块中也至关重要，这使得它成为 Web 上丰富布局未来的核心。
- en: '**Flexbox: Browser Support**'
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Flexbox: 浏览器支持**'
- en: '|  | **Chrome** | **Firefox** | **Safari** | **IE** |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '|  | **Chrome** | **Firefox** | **Safari** | **IE** |'
- en: '| Flexible box layout | Yes | Yes | Yes^([*](ch15.html#footnote33a)) | IE10^([†](ch15.html#footnote34a)),
    IE11 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 弹性盒布局 | 是 | 是 | 是^([*](ch15.html#footnote33a)) | IE10^([†](ch15.html#footnote34a)),
    IE11 |'
- en: '[*](ch15.html#footnote_33a) With vendor prefix'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[*](ch15.html#footnote_33a) 带有厂商前缀'
- en: '[†](ch15.html#footnote_34a) Supports an older syntax, with vendor prefix'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[†](ch15.html#footnote_34a) 支持旧的语法，并带有厂商前缀'
