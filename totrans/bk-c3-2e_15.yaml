- en: '**15**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**FLEXIBLE BOX LAYOUT**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That web pages look as good as they do is a minor miracle (comparatively speaking,
    of course!). Since the move away from tablebased layouts to pure CSS, developers
    have often had to create complex page structures using simple tools such as `float`,
    `margin`, and `position`—tools perhaps not even intended for that purpose when
    they were first created. As CSS has matured and browsers have grown more powerful,
    a new range of alternative layout approaches has been proposed.
  prefs: []
  type: TYPE_NORMAL
- en: The one most widely implemented is called Flexible Box Layout (or *Flexbox*).
    This approach is defined in the Flexible Box Layout Module (*[http://www.w3.org/TR/css-flexbox-1/](http://www.w3.org/TR/css-flexbox-1/)*),
    and it makes elements resize flexibly to better fit their available space, without
    the need for floats, positioning, or complex calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can certainly create entire page layouts with Flexbox, it is most
    suitable for working with interface elements and smaller components. When working
    with whole page layouts, consider using the Grid Layout Module, which I’ll introduce
    in [Chapter 17](ch17.html#ch17). But if you’re building a user interface or an
    app (especially an app with a lot of buttons, form elements, or interactive regions),
    you’ll find Flexbox extremely useful.
  prefs: []
  type: TYPE_NORMAL
- en: '**Declaring the Flexible Box Model**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step in using Flexbox is to create the *flex container*—the parent
    element that will create a new formatting context for its contents. To declare
    a flex container, you simply use a new value for the `display` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This creates a block-level flex container; you can use the alternate `inline-flex`
    value if you prefer an inline-level container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can add *flex items* to the flex container. A flex item is any child
    of the flex container, which is subject to the formatting context created by the
    container. For example, in the following code if `#container` is set as the flex
    container, the two child items will become flex items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This combination of markup and CSS is shown in [Figure 15-1](ch15.html#ch15fig1).
    Notice that the two elements are of equal width and laid out next to each other,
    without needing to use floats or positioning properties. By default, flex items
    are laid out in the direction of the document text—that is, from left to right
    for languages such as English, from right to left for languages such as Arabic
    (specified with the `dir` HTML attribute or `direction` CSS property), and from
    top to bottom for languages such as Japanese (set with the `text-direction` CSS
    property, but not yet broadly supported).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f15-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Child items of a flex container are laid out horizontally by
    default.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All of the examples throughout the rest of this chapter use the left-to-right
    direction, unless otherwise stated.*'
  prefs: []
  type: TYPE_NORMAL
- en: To alter the default layout direction, you can use the `flex-direction` property
    on the container. The default value `row` lays items out in a row, whereas a value
    of `column` lays them out from top to bottom in a column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Flexbox Alignment**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Flexbox uses two axes for alignment. As shown in [Figure 15-2](ch15.html#ch15fig2),
    the *main axis* goes in the direction that items are placed, from left to right
    or top to bottom. When the value of `flex-direction` is `row`, the main axis is
    horizontal; when it is `column`, the main axis is vertical. The *cross axis* is
    the line that runs perpendicular to the main axis: it’s vertical when the direction
    is `row` and horizontal when it’s `column`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f15-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: The main and cross axes depend on the direction of the layout
    of the flex children.*'
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with flex containers and items, you’ll often see points referred
    to as the start and end of axes. Because flex axes can be reversed (from top to
    bottom or bottom to top, and left to right or right to left), you use start and
    end rather than relative directions to prevent confusion. For example, when the
    main axis is horizontal and the direction is from left to right, the start of
    the main axis is the left and the end is the right; but if the main axis is vertical,
    the start of the main axis is at the top and the end is at the bottom (or vice
    versa if reversed).
  prefs: []
  type: TYPE_NORMAL
- en: '**Reversing the Content Order**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of Flexbox’s great capabilities is that you can quickly change the order
    in which items are displayed, regardless of their order in the DOM. For example,
    [Figure 15-1](ch15.html#ch15fig1) shows two items laid out in a row, in the order
    in which they’re declared in the DOM. What if you want to change their order so
    `#b` comes before `#a`?
  prefs: []
  type: TYPE_NORMAL
- en: You can do this quickly with the `flex-direction` property, using the value
    `row-reverse` to reverse the order in which the flex items are displayed, as shown
    here. (The `column-reverse` property value reverses the order of flex items vertically
    displayed in columns.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The result is shown in [Figure 15-3](ch15.html#ch15fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f15-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The* `*row-reverse*` *value quickly reverses the order of flex
    items.*'
  prefs: []
  type: TYPE_NORMAL
- en: Because reversing directions like this also reverses the axis direction, in
    the case of `row-reverse`, the start of the axis is on the left, and the end is
    on the right. In the case of `column-reverse`, the start is at the bottom, and
    the end is at the top.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fully Reordering Content**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can create custom ordering patterns with the `order` property. The `order`
    property is applied to the flex items (not their container). The value of the
    property is a number that creates an *ordinal group* that groups together items
    with the same value and orders them by their ordinal group: All items in the lowest
    numbered group come first, then all items in the second-lowest numbered group,
    and so on. Any items without a declared value are shown first because they have
    the default value of 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Items with the same ordinal group number are grouped in the order in which
    they appear in the DOM. For example, consider four flex items, `#a` through `#d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If no explicit values are set, and if `flex-direction` isn’t reversed, the
    children are displayed in the order in which they appear in the DOM: `#a`, `#b`,
    `#c`, `#d`. But let’s reorder them by using different values on the `order` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With these rules applied, the order in which the items are laid out becomes:
    `#c`, `#a`, `#b`, `#d`. Item `#c` comes first because it has the lowest ordinal
    group number, followed by `#a` with the next highest number, then `#b` and `#d`—both
    of which are in ordinal group 3\. Item `#d` comes last because it comes later
    in the DOM order.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-4](ch15.html#ch15fig4) shows the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f15-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The flex items reordered using ordinal groups*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that items `#c` and `#a` share the same background colors, as do `#b`
    and `#d`. The background colors should alternate because I’m using the `:nth-child()`
    pseudo-class discussed in [Chapter 4](ch04.html#ch04):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: But remember that the items have only changed order visually; they retain the
    same order in the markup, which is why `:nth-child()` applies the gray background
    to the elements that should be even numbered—namely, `#b` and `#d`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding Flexibility**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using Flexbox, you will almost certainly encounter situations where the
    combined lengths of flex items along the main axis are greater or less than the
    width of the flex container. When this happens, the “flexible” part of Flexbox
    comes into play. Several properties allow flex items to grow or shrink to fill
    their container. I’ll walk you through them in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '***The flex-grow Property***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s say you have a flex container 600px wide that contains three flex items.
    Each one is 150px wide, making a combined width of 450px. The difference between
    the width of the container and the combined width of the items leaves an empty
    space of 150px (that’s 600 − 450) at the end of the items, as shown in [Figure
    15-5](ch15.html#ch15fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f15-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Three flex items with a combined width narrower than the width
    of their container leaves empty space on the right.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To expand the items to fill the container, you can use the `flex-grow` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The value of the `flex-grow` property is basically a ratio that’s used to distribute
    the empty space between the flex items so they expand. In this case, I used a
    1:1:1 ratio to divide the empty 150px equally between the three flex items. Because
    150 divided by 3 is 50, each item is expanded by 50px, making their total width
    equal to the width of the container, as shown in [Figure 15-6](ch15.html#ch15fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f15-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: The three flex items now fill the width of their container.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also provide different values to adjust the distribution ratio. For
    example, to make `#b` take up more of the width of the container than the other
    two items, you could set a value of 3 for `#b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now the 150px will be redistributed using the ratio 1:3:1, so for every one
    pixel distributed to `#a` and `#c`, `#b` will receive three. As a result `#a`
    and `#c` will each be expanded to 180px wide, whereas `#b` will be 240px wide
    as shown in [Figure 15-7](ch15.html#ch15fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f15-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-7: Because* `*#b*` *has a higher* `*flex-grow*` *value, when resized,
    it’s wider than its siblings.*'
  prefs: []
  type: TYPE_NORMAL
- en: Because the default value for `flex-grow` is 0 (zero), flex items will keep
    their width and not expand to fill the container unless explicitly instructed
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: '***The flex-shrink Property***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as `flex-grow` is used to expand flex items to fill their container, `flex-shrink`
    is used to shrink items. For example, let’s revisit our flex container from the
    previous section with items `#a`, `#b`, and `#c`; only in this case, we’ll make
    each item 300px wide. Now the total width of the three items is 900px, which exceeds
    the 600px width of the parent by 300px.
  prefs: []
  type: TYPE_NORMAL
- en: 'To shrink these elements to fit within the container width, you could use the
    `flex-shrink` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `flex-shrink` property works like `flex-grow` but in the opposite direction.
    For example, a value of 1 (the default) reduces each item by the same proportion—each
    by 100px (300 divided by 3). The resulting items will be 200px each, for a total
    of 600px, which matches the width of the container.
  prefs: []
  type: TYPE_NORMAL
- en: Like `flex-grow`, different values change the distribution ratio. For example,
    if you use a value of 3 for item `#b`, its width is reduced by three pixels for
    every one-pixel reduction of the other two items.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Higher numbers reduce the elements by a greater factor. In this example, for
    each pixel removed from the width of `#a` and `#c`, three are removed from `#b`.
    As you can see in [Figure 15-8](ch15.html#ch15fig8), `#a` and `#c` are 240px in
    width, whereas `#b` is only 120px, which is narrower than its original width.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f15-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-8: Flex item* `*#b*` *has a higher* `*flex-shrink*` *value than
    its siblings, so it’s shrunk proportionally more to fit its container.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The flex-basis Property***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The width of flex items can be set either by the content they contain or by
    an explicit `width` value, and any growth or shrinkage is calculated from that
    base width. To change how the width adjustment is calculated, you can set a `flex-basis`
    value on an element. This property takes as a value a length unit. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When `flex-basis` is applied, any existing `width` value is ignored, and the
    value that you specify for the `flex-basis` is used to calculate the adjustment.
    For example, in the previous two sections, the `width` value of 150px is ignored
    and all growth or shrinking is based on the `flex-basis` value of 100px. You could
    add the `flex-basis` value of 100px to `#b` in [Figure 15-7](ch15.html#ch15fig7),
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now the empty space in the container will be redistributed using the ratio 1:3:1,
    which means that, based on the `width` values, `#a` and `#c` would expand by 30px
    each and `#b` by 90px. Because of the `flex-basis` value, however, that space
    distribution is performed as if `#b` had a width of 100px, not the specified `width`
    value of 150px.
  prefs: []
  type: TYPE_NORMAL
- en: At first, it seems illogical that `#b` ends up wider than its siblings despite
    having a lower width set by its `flex-basis` value. The reason is that there is
    now a spare width of 200px (the combined widths of the flex items is 400px; the
    parent is 600px). This 200 is redistributed between the three boxes using the
    ratio 1:3:1\. Although `#b` begins at 100px wide, it receives 120px of the spare
    space whereas `#a` and `#c` receive 40px.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, `#a` and `#c` end up 190px wide, and `#b` is 220px wide. Compare
    the result shown in [Figure 15-9](ch15.html#ch15fig9) with [Figure 15-7](ch15.html#ch15fig7)
    to see the difference.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f15-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-9: Because* `*#b*` *has a* `*flex-basis*` *value applied, it’s resized
    to be larger than its siblings.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The flex Shorthand***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As with many properties, the `flex-*` family has a shorthand property called
    `flex`. The values it takes are, in order, `flex-grow`, `flex-shrink`, and `flex-basis`.
    Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, element `*E*` has a `flex-grow` value of 1 and a `flex-shrink` value of
    2\. The value used is chosen based on the width of the flex items in comparison
    with their flex container; where flex items don’t fill their container, the `flex-grow`
    value is used, and where flex items exceed their container, the `flex-shrink`
    value comes into play. The final value, 150px, is the `flex-basis` value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Alignment Inside the Container**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you have items with fixed dimensions inside a flex container, you’ll likely
    have empty space along one or both of the axes. For example, in [Figure 15-5](ch15.html#ch15fig5),
    three flex items that are each 150px wide didn’t fill the width of their 600px
    container. When this is the case, you can align the items inside the container
    to make better use of the available space.
  prefs: []
  type: TYPE_NORMAL
- en: '***Horizontal Alignment with justify-content***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Thankfully, Flexbox offers tight control over alignment and placement, allowing
    you to redistribute unused space with the `justify-content` property. This property
    is applied to the flex container and accepts a series of keyword values that are
    applied differently depending on the direction of the flex parent (row, column,
    reversed row, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The default value is `flex-start`, which (as shown in [Figure 15-5](ch15.html#ch15fig5))
    aligns all flex items to the left of the parent with the unused space occupying
    the remaining width to the right. The alternative values are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • `flex-end`, which aligns items to the right of the container with the unused
    space to the left
  prefs: []
  type: TYPE_NORMAL
- en: • `center`, which distributes the unused space to either side of all items,
    centering the items in the container
  prefs: []
  type: TYPE_NORMAL
- en: • `space-between`, which adds an equal amount of space between each item but
    none before the first or after the last item
  prefs: []
  type: TYPE_NORMAL
- en: • `space-around`, which puts an equal amount of space on both sides of each
    item
  prefs: []
  type: TYPE_NORMAL
- en: The following code shows a few different values for the sake of comparison,
    with the results shown in [Figure 15-10](ch15.html#ch15fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](graphics/f15-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-10: Different values for the* `*justify-content*` *property:* `*flex-start*`
    *(top),* `*center*` *(middle), and* `*space-around*` *(bottom)*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Vertical Alignment with align-items***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When the height of your flex items is less than the height of the flex container,
    you can use the property `align-items` to adjust the items within the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The principal keyword values for this property are:'
  prefs: []
  type: TYPE_NORMAL
- en: • `stretch`, which makes items the same height as the parent
  prefs: []
  type: TYPE_NORMAL
- en: • `flex-start`, which aligns items to the top of the container
  prefs: []
  type: TYPE_NORMAL
- en: • `flex-end`, which aligns items to the bottom of the container
  prefs: []
  type: TYPE_NORMAL
- en: • `center`, which aligns items to the vertical center of the container, with
    equal space above and below
  prefs: []
  type: TYPE_NORMAL
- en: The default value is `stretch` if the items have no height explicitly specified,
    or `flex-start` if they do.
  prefs: []
  type: TYPE_NORMAL
- en: In the following listing, I’ve set the flex container to have a `flex-direction`
    value of `column`, so the main axis is vertical and the cross axis is horizontal.
    [Figure 15-11](ch15.html#ch15fig11) shows the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![Image](graphics/f15-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-11: Alignment on the cross axis is controlled with different values
    for* `*align-items*`*:* `*stretch*` *(left),* `*flex-end*` *(middle), and* `*center*`
    *(right).*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that with no explicit width set, the flex items in the second and third
    columns are sized only to the width of their content, and then aligned within
    the container based on its `align-items` value.
  prefs: []
  type: TYPE_NORMAL
- en: '***Cross-Axis Alignment with align-self***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To control the cross-axis alignment of individual items, use the `align-self`
    property. This property applies to the item, not the container. The values are
    the same as for `align-items`, and they have the same effects on the selected
    item only; sibling items are unaffected.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following listing, element `#c` has a different value than
    its siblings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The effect (using the default row direction) is shown in [Figure 15-12](ch15.html#ch15fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f15-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-12: Flex item* `*#c*` *is aligned differently from its siblings
    because of the* `*align-self*` *property.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Wrap and Flow***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you have too many items to fit comfortably into one row (or column) of
    a container, you can break them onto multiple lines using the `flex-wrap` property.
    The default value of `nowrap` preserves all the items on the same line, whereas
    a value of `wrap` breaks them onto extra lines below the first (or to the right
    in column view), if required.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The value `wrap-reverse` changes the direction of the cross axis so new lines
    appear above (or to the left). [Figure 15-13](ch15.html#ch15fig13) compares the
    effect of the two different values.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f15-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-13: Comparing the effects of different values for the* `*flex-wrap*`
    *property. The top example has a value of* `*wrap*`*, so element* `*#c*` *appears
    on a new line below, whereas in the bottom example, the value is* `*wrap-reverse*`*,
    so element* `*#c*` *is on a new line above.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The flex-flow Shorthand***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can combine `flex-wrap` with `flex-direction` in the shorthand `flex-flow`
    property. For example, to set a column with multiple lines and a reversed cross
    axis, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '***Aligning Multiple Lines with align-content***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When items wrap over multiple lines, you can control their alignment with the
    `align-content` property. This property works like `justify-content` but on the
    cross axis. It has the same possible values—`flex-start`, `flex-end`, `center`,
    `space-between`, and `space-around`—and also adds `stretch`, which resizes the
    items to fill all unused space. [Figure 15-14](ch15.html#ch15fig14) compares the
    effects of the values `center` and `space-between`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f15-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-14: Alignment on the cross axis when flex items are wrapped is controlled
    with* `*align-content*`*:* `*center*` *(top) and* `*space-between*` *(bottom).*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Browser Support and Legacy Syntaxes**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As I write this, Flexbox is well implemented across all major modern browsers,
    but it has a long history of syntax changes, and supporting a handful of older
    browsers can be troublesome. For example, Internet Explorer 10 implements an earlier
    version of the spec, which uses the `-ms-` prefix for all properties. The IE10
    implementation and the modern spec have a few key differences: IE10 uses `-ms-flexbox`
    as the name of the value for the `display` property, rather than `flex`; and `-ms-flex-align`
    and `-ms-flex-pack` are used rather than `align-items` and `justify-content` (their
    values differ a little, too). IE10 also lacks any implementation of `flex-wrap`
    or the `flex-flow` shorthand. If you need to support IE10, I suggest reading all
    about the differences from the spec in the IE10 Developer Guide (*[http://msdn.microsoft.com/en-us/library/ie/hh673531%28v=vs.85%29.aspx](http://msdn.microsoft.com/en-us/library/ie/hh673531%28v=vs.85%29.aspx)*).'
  prefs: []
  type: TYPE_NORMAL
- en: Older versions of WebKit-based browsers, especially Safari 6 and below, use
    an even more outdated syntax. If you really need to support these older browsers
    fully, see Stephen Hay’s introductory article from 2009 (*[http://www.the-haystack.com/2010/01/23/css3-flexbox-part-1/](http://www.the-haystack.com/2010/01/23/css3-flexbox-part-1/)*).
  prefs: []
  type: TYPE_NORMAL
- en: But don’t let these concerns put you off from using Flexbox. Only a handful
    of browsers require these older properties, and with a little extra work, you
    can take advantage of the layout gains that Flexbox brings.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it introduces a number of unfamiliar new terms and concepts to CSS,
    Flexbox is an elegant and logical proposal that solves several common problems
    with website layouts. Flexbox is harder to describe in writing than it is to learn
    by doing!
  prefs: []
  type: TYPE_NORMAL
- en: Taking the time to understand Flexbox fully is certainly worthwhile, as many
    of the new concepts and keywords it introduces are essential to other layout modules
    now being produced, making it essential to the future of rich layouts on the Web.
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexbox: Browser Support**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '|  | **Chrome** | **Firefox** | **Safari** | **IE** |'
  prefs: []
  type: TYPE_TB
- en: '| Flexible box layout | Yes | Yes | Yes^([*](ch15.html#footnote33a)) | IE10^([†](ch15.html#footnote34a)),
    IE11 |'
  prefs: []
  type: TYPE_TB
- en: '[*](ch15.html#footnote_33a) With vendor prefix'
  prefs: []
  type: TYPE_NORMAL
- en: '[†](ch15.html#footnote_34a) Supports an older syntax, with vendor prefix'
  prefs: []
  type: TYPE_NORMAL
