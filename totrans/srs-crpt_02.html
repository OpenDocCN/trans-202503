<html><head></head><body>
<h2 class="h2" id="ch1"><span epub:type="pagebreak" id="page_1"/><span class="big">1</span><br/>ENCRYPTION</h2>
<div class="image9"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">Encryption is the principal application of cryptography; it makes data incomprehensible in order to ensure its <em>confidentiality</em>. Encryption uses an algorithm called a <em>cipher</em> and a secret value called the <em>key</em>; if you don’t know the secret key, you can’t decrypt, nor can you learn any bit of information on the encrypted message—and neither can any attacker.</p>
<p class="indent">This chapter will focus on symmetric encryption, which is the simplest kind of encryption. In <em>symmetric encryption</em>, the key used to decrypt is the same as the key used to encrypt (unlike <em>asymmetric encryption</em>, or <em>public-key encryption</em>, in which the key used to decrypt is different from the key used to encrypt). You’ll start by learning about the weakest forms of symmetric encryption, classical ciphers that are secure against only the most illiterate attacker, and then move on to the strongest forms that are secure forever.</p>
<h3 class="h3" id="lev1sec5"><span epub:type="pagebreak" id="page_2"/>The Basics</h3>
<p class="noindent">When we’re encrypting a message, <em>plaintext</em> refers to the unencrypted message and <em>ciphertext</em> to the encrypted message. A cipher is therefore composed of two functions: <em>encryption</em> turns a plaintext into a ciphertext, and <em>decryption</em> turns a ciphertext back into a plaintext. But we’ll often say “cipher” when we actually mean “encryption.” For example, <a href="ch01.xhtml#ch1fig1">Figure 1-1</a> shows a cipher, <strong>E</strong>, represented as a box taking as input a plaintext, <em>P</em>, and a key, <em>K</em>, and producing a ciphertext, <em>C</em>, as output. I’ll write this relation as <em>C</em> = <strong>E</strong>(<em>K</em>, <em>P</em>). Similarly, when the cipher is in decryption mode, I’ll write <strong>D</strong>(<em>K</em>, <em>C</em>).</p>
<div class="image"><img src="../images/f01-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch1fig1"/><em>Figure 1-1: Basic encryption and decryption</em></p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>For some ciphers, the ciphertext is the same size as the plaintext; for some others, the ciphertext is slightly longer. However, ciphertexts can never be shorter than plaintexts.</em></p>
</div>
<h3 class="h3" id="lev1sec6">Classical Ciphers</h3>
<p class="noindent">Classical ciphers are ciphers that predate computers and therefore work on letters rather than on bits. They are much simpler than a modern cipher like DES—for example, in ancient Rome or during WWI, you couldn’t use a computer chip’s power to scramble a message, so you had to do everything with only pen and paper. There are many classical ciphers, but the most famous are the Caesar cipher and Vigenère cipher.</p>
<h4 class="h4" id="lev2sec5"><em>The Caesar Cipher</em></h4>
<p class="noindent">The Caesar cipher is so named because the Roman historian Suetonius reported that Julius Caesar used it. It encrypts a message by shifting each of the letters down three positions in the alphabet, wrapping back around to A if the shift reaches Z. For example, ZOO encrypts to CRR, FDHVDU decrypts to CAESAR, and so on, as shown in <a href="ch01.xhtml#ch1fig2">Figure 1-2</a>. There’s nothing special about the value 3; it’s just easier to compute in one’s head than 11 or 23.</p>
<p class="indent">The Caesar cipher is super easy to break: to decrypt a given ciphertext, simply shift the letters three positions back to retrieve the plaintext. That said, the Caesar cipher may have been strong enough during the time of Crassus and Cicero. Because no secret key is involved (it’s always 3), users of Caesar’s cipher only had to assume that attackers were illiterate or too uneducated to figure it out—an assumption that’s much less realistic today. (In fact, in 2006, the Italian police arrested a mafia boss after decrypting messages written on small scraps of paper that were encrypted using a variant of the Caesar cipher: ABC was encrypted to 456 instead of DEF, for example.)</p>
<div class="image"><span epub:type="pagebreak" id="page_3"/><img src="../images/f01-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch1fig2"/><em>Figure 1-2: The Caesar cipher</em></p>
<p class="indent">Could the Caesar cipher be made more secure? You can, for example, imagine a version that uses a secret shift value instead of always using 3, but that wouldn’t help much because an attacker could easily try all 25 possible shift values until the decrypted message makes sense.</p>
<h4 class="h4" id="lev2sec6"><em>The Vigenère Cipher</em></h4>
<p class="noindent">It took about 1500 years to see a meaningful improvement of the Caesar cipher in the form of the Vigenère cipher, created in the 16th century by an Italian named Giovan Battista Bellaso. The name “Vigenère” comes from the Frenchman Blaise de Vigenère, who invented a different cipher in the 16th century, but due to historical misattribution, Vigenère’s name stuck. Nevertheless, the Vigenère cipher became popular and was later used during the American Civil War by Confederate forces and during WWI by the Swiss Army, among others.</p>
<p class="indent">The Vigenère cipher is similar to the Caesar cipher, except that letters aren’t shifted by three places but rather by values defined by a <em>key</em>, a collection of letters that represent numbers based on their position in the alphabet. For example, if the key is DUH, letters in the plaintext are shifted using the values 3, 20, 7 because <em>D</em> is three letters after <em>A</em>, <em>U</em> is 20 letters after <em>A</em>, and <em>H</em> is seven letters after <em>A</em>. The 3, 20, 7 pattern repeats until you’ve encrypted the entire plaintext. For example, the word CRYPTO would encrypt to FLFSNV using DUH as the key: <em>C</em> is shifted three positions to <em>F</em>, <em>R</em> is shifted 20 positions to <em>L</em>, and so on. <a href="ch01.xhtml#ch1fig3">Figure 1-3</a> illustrates this principle when encrypting the sentence THEY DRINK THE TEA.</p>
<div class="image"><img src="../images/f01-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch1fig3"/><em>Figure 1-3: The Vigenère cipher</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_4"/>The Vigenère cipher is clearly more secure than the Caesar cipher, yet it’s still fairly easy to break. The first step to breaking it is to figure out the key’s length. For example, take the example in <a href="ch01.xhtml#ch1fig3">Figure 1-3</a>, wherein THEY DRINK THE TEA encrypts to WBLBXYLHRWBLWYH with the key DUH. (Spaces are usually removed to hide word boundaries.) Notice that in the ciphertext WBLBXYLHRWBLWYH, the group of three letters WBL appears twice in the ciphertext at nine-letter intervals. This suggests that the same three-letter word was encrypted using the same shift values, producing WBL each time. A cryptanalyst can then deduce that the key’s length is either nine or a value divisible by nine (that is, three). Furthermore, they may guess that this repeated three-letter word is THE and therefore determine DUH as a possible encryption key.</p>
<p class="indent">The second step to breaking the Vigenère cipher is to determine the actual key using a method called <em>frequency analysis</em>, which exploits the uneven distribution of letters in languages. For example, in English, <em>E</em> is the most common letter, so if you find that <em>X</em> is the most common letter in a ciphertext, then the most likely plaintext value at this position is <em>E</em>.</p>
<p class="indent">Despite its relative weakness, the Vigenère cipher may have been good enough to securely encrypt messages when it was used. First, because the attack just outlined needs messages of at least a few sentences, it wouldn’t work if the cipher was used to encrypt only short messages. Second, most messages needed to be secret only for short periods of time, so it didn’t matter if ciphertexts were eventually decrypted by the enemy. (The 19th-century cryptographer Auguste Kerckhoffs estimated that most encrypted wartime messages required confidentiality for only three to four hours.)</p>
<h3 class="h3" id="lev1sec7">How Ciphers Work</h3>
<p class="noindent">Based on simplistic ciphers like the Caesar and Vigenère ciphers, we can try to abstract out the workings of a cipher, first by identifying its two main components: a permutation and a mode of operation. A <em>permutation</em> is a function that transforms an item (in cryptography, a letter or a group of bits) such that each item has a unique inverse (for example, the Caesar cipher’s three-letter shift). A <em>mode of operation</em> is an algorithm that uses a permutation to process messages of arbitrary size. The mode of the Caesar cipher is trivial: it just repeats the same permutation for each letter, but as you’ve seen, the Vigenère cipher has a more complex mode, where letters at different positions undergo different permutations.</p>
<p class="indent">In the following sections, I discuss in more detail what these are and how they relate to a cipher’s security. I use each component to show why classical ciphers are doomed to be insecure, unlike modern ciphers that run on high-speed computers.</p>
<h4 class="h4" id="lev2sec7"><em>The Permutation</em></h4>
<p class="noindent">Most classical ciphers work by replacing each letter with another letter—in other words, by performing a <em>substitution</em>. In the Caesar and Vigenère ciphers, the substitution is a shift in the alphabet, though the alphabet or <span epub:type="pagebreak" id="page_5"/>set of symbols can vary: instead of the English alphabet, it could be the Arabic alphabet; instead of letters, it could be words, numbers, or ideograms, for example. The representation or encoding of information is a separate matter that is mostly irrelevant to security. (We’re just considering Latin letters because that’s what classical ciphers use.)</p>
<p class="indent">A cipher’s substitution can’t be just any substitution. It should be a permutation, which is a rearrangement of the letters <em>A</em> to <em>Z</em>, such that each letter has a unique inverse. For example, a substitution that transforms the letters <em>A</em>, <em>B</em>, <em>C</em>, and <em>D</em>, respectively to <em>C</em>, <em>A</em>, <em>D</em>, and <em>B</em> is a permutation, because each letter maps onto another single letter. But a substitution that transforms <em>A</em>, <em>B</em>, <em>C</em>, <em>D</em> to <em>D</em>, <em>A</em>, <em>A</em>, <em>C</em> is not a permutation, because both B and C map onto A. With a permutation, each letter has exactly one inverse.</p>
<p class="indentb">Still, not every permutation is secure. In order to be secure, a cipher’s permutation should satisfy three criteria:</p>
<ul>
<li class="noindent"><strong>The permutation should be determined by the key</strong>, so as to keep the permutation secret as long as the key is secret. In the Vigenère cipher, if you don’t know the key, you don’t know which of the 26 permutations was used; hence, you can’t easily decrypt.</li>
<li class="noindent"><strong>Different keys should result in different permutations</strong>. Otherwise, it becomes easier to decrypt without the key: if different keys result in identical permutations, that means there are fewer distinct keys than distinct permutations, and therefore fewer possibilities to try when decrypting without the key. In the Vigenère cipher, each letter from the key determines a substitution; there are 26 distinct letters, and as many distinct permutations.</li>
<li class="noindent"><strong>The permutation should look random</strong>, loosely speaking. There should be no pattern in the ciphertext after performing a permutation, because patterns make a permutation predictable for an attacker, and therefore less secure. For example, the Vigenère cipher’s substitution is pretty predictable: if you determine that <em>A</em> encrypts to <em>F</em>, you could conclude that the shift value is 5 and you would also know that <em>B</em> encrypts to <em>G</em>, that <em>C</em> encrypts to <em>H</em>, and so on. However, with a randomly chosen permutation, knowing that <em>A</em> encrypts to <em>F</em> would only tell you that <em>B</em> does <em>not</em> encrypt to <em>F</em>.</li>
</ul>
<p class="indentt">We’ll call a permutation that satisfies these criteria a <em>secure permutation</em>. But as you’ll see next, a secure permutation is necessary but not sufficient on its own for building a secure cipher. A cipher will also need a mode of operation to support messages of any length.</p>
<h4 class="h4" id="lev2sec8"><em>The Mode of Operation</em></h4>
<p class="noindent">Say we have a secure permutation that transforms <em>A</em> to <em>X</em>, <em>B</em> to <em>M</em>, and <em>N</em> to <em>L</em>, for example. The word BANANA therefore encrypts to MXLXLX, where each occurrence of <em>A</em> is replaced by an <em>X</em>. Using the same permutation for all the letters in the plaintext thus reveals any duplicate letters in the plaintext. By analyzing these duplicates, you might not learn the entire message, <span epub:type="pagebreak" id="page_6"/>but you’ll learn <em>something</em> about the message. In the BANANA example, you don’t need the key to guess that the plaintext has the same letter at the three <em>X</em> positions and another same letter at the two <em>L</em> positions. So if you know, for example, that the message is a fruit’s name, you could determine that it’s BANANA rather than CHERRY, LYCHEE, or another six-letter fruit.</p>
<p class="indent">The mode of operation (or just <em>mode</em>) of a cipher mitigates the exposure of duplicate letters in the plaintext by using different permutations for duplicate letters. The mode of the Vigenère cipher partially addresses this: if the key is <em>N</em> letters long, then <em>N</em> different permutations will be used for every <em>N</em> consecutive letters. However, this can still result in patterns in the ciphertext because every <em>N</em>th letter of the message uses the same permutation. That’s why frequency analysis works to break the Vigenère cipher, as you saw earlier.</p>
<p class="indent">Frequency analysis can be defeated if the Vigenère cipher only encrypts plaintexts that are of the same length as the key. But even then, there’s another problem: reusing the same key several times exposes similarities between plaintexts. For example, with the key KYN, the words TIE and PIE encrypt to DGR and ZGR, respectively. Both end with the same two letters (<em>GR</em>), revealing that both plaintexts share their last two letters as well. Finding these patterns shouldn’t be possible with a secure cipher.</p>
<p class="indent">To build a secure cipher, you must combine a secure permutation with a secure mode. Ideally, this combination prevents attackers from learning anything about a message other than its length.</p>
<h4 class="h4" id="lev2sec9"><em>Why Classical Ciphers Are Insecure</em></h4>
<p class="noindent">Classical ciphers are doomed to be insecure because they’re limited to operations you can do in your head or on a piece of paper. They lack the computational power of a computer and are easily broken by simple computer programs. Let’s see the fundamental reason why that simplicity makes them insecure in today’s world.</p>
<p class="indentb">Remember that a cipher’s permutation should look random in order to be secure. Of course, the best way to look random is to <em>be</em> random—that is, to select every permutation randomly from the set of all permutations. And there are many permutations to choose from. In the case of the 26-letter English alphabet, there are approximately 2<sup>88</sup> permutations:</p>
<p class="center">26! = 403291461126605635584000000 ≈ 2<sup>88</sup></p>
<p class="indent1">Here, the exclamation point (!) is the factorial symbol, defined as follows:</p>
<p class="center"><em>n</em>! = <em>n</em> × (<em>n</em> − 1) × (<em>n</em> – 2) × … × 3 × 2</p>
<p class="indentt">(To see why we end up with this number, count the permutations as lists of reordered letters: there are 26 choices for the first possible letter, then 25 possibilities for the second, 24 for the third, and so on.) This number is huge: it’s of the same order of magnitude as the number of atoms in <span epub:type="pagebreak" id="page_7"/>the human body. But classical ciphers can only use a small fraction of those permutations—namely, those that need only simple operations (such as shifts) and that have a short description (like a short algorithm or a small look-up table). The problem is that a secure permutation can’t accommodate both of these limitations.</p>
<p class="indent">You can get secure permutations using simple operations by picking a random permutation, representing it as a table of 25 letters (enough to represent a permutation of 26 letters, with the 26th one missing), and applying it by looking up letters in this table. But then you wouldn’t have a short description. For example, it would take 250 letters to describe 10 different permutations, rather than just the 10 letters used in the Vigenère cipher.</p>
<p class="indent">You can also produce secure permutations with a short description. Instead of just shifting the alphabet, you could use more complex operations such as addition, multiplication, and so on. That’s how modern ciphers work: given a key of typically 128 or 256 bits, they perform hundreds of bit operations to encrypt a single letter. This process is fast on a computer that can do billions of bit operations per second, but it would take hours to do by hand, and would still be vulnerable to frequency analysis.</p>
<h3 class="h3" id="lev1sec8">Perfect Encryption: The One-Time Pad</h3>
<p class="noindent">Essentially, a classical cipher can’t be secure unless it comes with a huge key, but encrypting with a huge key is impractical. However, the one-time pad is such a cipher, and it is the most secure cipher. In fact, it guarantees <em>perfect secrecy</em>: even if an attacker has unlimited computing power, it’s impossible to learn anything about the plaintext except for its length.</p>
<p class="indent">In the next sections, I’ll show you how a one-time pad works and then offer a sketch of its security proof.</p>
<h4 class="h4" id="lev2sec10"><em>Encrypting with the One-Time Pad</em></h4>
<p class="noindent">The one-time pad takes a plaintext, <em>P</em>, and a random key, <em>K</em>, that’s the same length as <em>P</em> and produces a ciphertext <em>C</em>, defined as</p>
<p class="center"><em>C</em> = <em>P</em> ⊕ <em>K</em></p>
<p class="noindentt">where <em>C</em>, <em>P</em>, and <em>K</em> are bit strings of the same length and where ⊕ is the bitwise exclusive OR operation (XOR), defined as 0 ⊕ 0 = 0, 0 ⊕ 1 = 1, 1 ⊕ 0 = 1, 1 ⊕ 1 = 0.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>I’m presenting the one-time pad in its usual form, as working on bits, but it can be adapted to other symbols. With letters, for example, you would end up with a variant of the Caesar cipher with a shift index picked at random for each letter.</em></p>
</div>
<p class="indentt">The one-time pad’s decryption is identical to encryption; it’s just an XOR: <em>P</em> = <em>C</em> ⊕ <em>K</em>. Indeed, we can verify <em>C</em> ⊕ <em>K</em> = <em>P</em> ⊕ <em>K</em> ⊕ <em>K</em> = <em>P</em> because XORing <em>K</em> with itself gives the all-zero string 000 … 000. That’s it—even simpler than the Caesar cipher.</p>
<p class="indent"><span epub:type="pagebreak" id="page_8"/>For example, if <em>P</em> = 01101101 and <em>K</em> = 10110100, then we can calculate the following:</p>
<p class="center"><em>C</em> = <em>P</em> ⊕ <em>K</em> = 01101101 ⊕ 10110100 = 11011001</p>
<p class="indent1">Decryption retrieves <em>P</em> by computing the following:</p>
<p class="center"><em>P</em> = <em>C</em> ⊕ <em>K</em> = 11011001 ⊕ 10110100 = 01101101</p>
<p class="indent">The important thing is that a one-time pad can only be used <em>one time</em>: each key <em>K</em> should be used only once. If the same <em>K</em> is used to encrypt <em>P</em><sub>1</sub> and <em>P</em><sub>2</sub> to <em>C</em><sub>1</sub> and <em>C</em><sub>2</sub>, then an eavesdropper can compute the following:</p>
<p class="center"><em>C</em><sub>1</sub> ⊕ <em>C</em><sub>2</sub> = (<em>P</em><sub>1</sub> ⊕ <em>K</em>) ⊕ (<em>P</em><sub>2</sub> ⊕ <em>K</em>) = <em>P</em><sub>1</sub> ⊕ <em>P</em><sub>2</sub> ⊕ <em>K</em> ⊕ <em>K</em> = <em>P</em><sub>1</sub> ⊕ <em>P</em><sub>2</sub></p>
<p class="indent">An eavesdropper would thus learn the XOR difference of <em>P</em><sub>1</sub> and <em>P</em><sub>2</sub>, information that should be kept secret. Moreover, if either plaintext message is known, then the other message can be recovered.</p>
<p class="indent">Of course, the one-time pad is utterly inconvenient to use because it requires a key as long as the plaintext and a new random key for each new message or group of data. To encrypt a one-terabyte hard drive, you’d need another one-terabyte drive to store the key! Nonetheless, the one-time pad has been used throughout history. For example, it was used by the British Special Operations Executive during WWII, by KGB spies, by the NSA, and is still used today in specific contexts. (I’ve heard of Swiss bankers who couldn’t agree on a cipher trusted by both parties and ended up using one-time pads, but I don’t recommend doing this.)</p>
<h4 class="h4" id="lev2sec11"><em>Why Is the One-Time Pad Secure?</em></h4>
<p class="noindent">Although the one-time pad is not practical, it’s important to understand what makes it secure. In the 1940s, American mathematician Claude Shannon proved that the one-time pad’s key must be at least as long as the message to achieve perfect secrecy. The proof’s idea is fairly simple. You assume that the attacker has unlimited power, and thus can try all the keys. The goal is to encrypt such that the attacker can’t rule out any possible plaintext given some ciphertext.</p>
<p class="indent">The intuition behind the one-time pad’s perfect secrecy goes as follows: if <em>K</em> is random, the resulting <em>C</em> looks as random as <em>K</em> to an attacker because the XOR of a random string with any fixed string yields a random string. To see this, consider the probability of getting 0 as the first bit of a random string (namely, a probability of 1/2). What’s the probability that a random bit XORed with the second bit is 0? Right, 1/2 again. The same argument can be iterated over bit strings of any length. The ciphertext <em>C</em> thus looks random to an attacker that doesn’t know <em>K</em>, so it’s literally impossible to learn anything about <em>P</em> given <em>C</em>, even for an attacker with unlimited time and power. In other words, knowing the ciphertext gives no information whatsoever about the plaintext except its length—pretty much the definition of a secure cipher.</p>
<p class="indent"><span epub:type="pagebreak" id="page_9"/>For example, if a ciphertext is 128 bits long (meaning the plaintext is 128 bits as well), there are 2<sup>128</sup> possible ciphertexts; therefore, there should be 2<sup>128</sup> possible plaintexts from the attacker’s point of view. But if there are fewer than 2<sup>128</sup> possible keys, the attacker can rule out some plaintexts. If the key is only 64 bits, for example, the attacker can determine the 2<sup>64</sup> possible plaintexts and rule out the overwhelming majority of 128-bit strings. The attacker wouldn’t learn what the plaintext is, but they would learn what the plaintext is not, which makes the encryption’s secrecy imperfect.</p>
<p class="indent">As you can see, you must have a key as long as the plaintext to achieve perfect security, but this quickly becomes impractical for real-world use. Next, I’ll discuss the approaches taken in modern-day encryption to achieve the best security that’s both possible and practical.</p>
<div class="sidebar">
<p class="sidebart">PROBABILITY IN CRYPTOGRAPHY</p>
<p class="spara">A <em>probability</em> is a number that expresses the likelihood, or chance, of some event happening. It’s expressed as a number between 0 and 1, where 0 means “never” and 1 means “always.” The higher the probability, the greater the chance. You’ll find many explanations of probability, usually in terms of white balls and red balls in a bag and the probability of picking a ball of either color.</p>
<p class="spara1">Cryptography often uses probabilities to measure an attack’s chances of success, by 1) counting the number of successful events (for example, the event “find the one correct secret key”) and 2) counting the total number of possible events (for example, the total number of keys is 2<sup><em>n</em></sup> if we deal with <em>n</em>-bit keys). In this example, the probability that a randomly chosen key is the correct one is 1/2<sup><em>n</em></sup>, or the count of successful events (1 secret key) and the count of possible events (2<sup><em>n</em></sup> possible keys). The number 1/2<sup><em>n</em></sup> is negligibly small for common key lengths such as 128 and 256.</p>
<p class="spara1">The probability of an event <em>not happening</em> is 1 – <em>p</em>, if the event’s probability is <em>p</em>. The probability of getting a wrong key in our previous example is therefore 1 – 1/2<sup><em>n</em></sup>, a number very close to 1, meaning almost certainty.</p>
</div>
<h3 class="h3" id="lev1sec9">Encryption Security</h3>
<p class="noindent">You’ve seen that classical ciphers aren’t secure and that a perfectly secure cipher like the one-time pad is impractical. We’ll thus have to give a little in terms of security if we want secure <em>and</em> usable ciphers. But what does “secure” really mean, besides the obvious and informal “eavesdroppers can’t decrypt secure messages”?</p>
<p class="indentb"><span epub:type="pagebreak" id="page_10"/>Intuitively, a cipher is secure if, even given a large number of plaintext–ciphertext pairs, <em>nothing can be learned</em> about the cipher’s behavior when applied to other plaintexts or ciphertexts. This opens up new questions:</p>
<ul>
<li class="noindent">How does an attacker come by these pairs? How large is a “large number”? This is all defined by <em>attack models</em>, assumptions about what the attacker can and cannot do.</li>
<li class="noindent">What could be “learned” and what “cipher’s behavior” are we talking about? This is defined by <em>security goals</em>, descriptions of what is considered a successful attack.</li>
</ul>
<p class="indentt">Attack models and security goals must go together; you can’t claim that a system is secure without explaining against whom or from what it’s safe. A <em>security notion</em> is thus the combination of some security goal with some attack model. We’ll say that a cipher <em>achieves</em> a certain security notion if any attacker working in a given model can’t achieve the security goal.</p>
<h4 class="h4" id="lev2sec12"><em>Attack Models</em></h4>
<p class="noindentb">An attack model is a set of assumptions about how attackers might interact with a cipher and what they can and can’t do. The goals of an attack model are as follows:</p>
<ul>
<li class="noindent">To set requirements for cryptographers who design ciphers, so that they know what attackers and what kinds of attacks to protect against.</li>
<li class="noindent">To give guidelines to users, about whether a cipher will be safe to use in their environment.</li>
<li class="noindent">To provide clues for cryptanalysts who attempt to break ciphers, so they know whether a given attack is valid. An attack is only valid if it’s doable in the model considered.</li>
</ul>
<p class="indentt">Attack models don’t need to match reality exactly; they’re an approximation. As the statistician George E. P. Box put it, “all models are wrong; the practical question is how wrong do they have to be to not be useful.” To be useful in cryptography, attack models should at least encompass what attackers can actually do to attack a cipher. It’s okay and a good thing if a model overestimates attackers’ capabilities, because it helps anticipate future attack techniques—only the paranoid cryptographers survive. A bad model underestimates attackers and provides false confidence in a cipher by making it seem secure in theory when it’s not secure in reality.</p>
<h5 class="h5">Kerckhoffs’s Principle</h5>
<p class="noindent">One assumption made in all models is the so-called <em>Kerckhoffs’s principle</em>, which states that the security of a cipher should rely only on the secrecy of the key and not on the secrecy of the cipher. This may sound obvious today, when ciphers and protocols are publicly specified and used by everyone. But historically, Dutch linguist Auguste Kerckhoffs was referring to military encryption machines specifically designed for a given army or division. <span epub:type="pagebreak" id="page_11"/>Quoting from his 1883 essay “La Cryptographie Militaire,” where he listed six requirements of a military encryption system: “The system must not require secrecy and can be stolen by the enemy without causing trouble.”</p>
<h5 class="h5">Black-Box Models</h5>
<p class="noindent">Let’s now consider some useful attack models expressed in terms of what the attacker can observe and what queries they can make to the cipher. A <em>query</em> for our purposes is the operation that sends an input value to some function and gets the output in return, without exposing the details of that function.</p>
<p class="indent">An <em>encryption query</em>, for example, takes a plaintext and returns a corresponding ciphertext, without revealing the secret key.</p>
<p class="indent">We call these models <em>black-box models</em>, because the attacker only sees what goes in and out of the cipher. For example, some smart card chips securely protect a cipher’s internals as well as its keys, yet you’re allowed to connect to the chip and ask it to decrypt any ciphertext. The attacker would then receive the corresponding plaintext, which may help them determine the key. That’s a real example where <em>decryption queries</em> are possible.</p>
<p class="indentb">There are several different black-box attack models. Here, I list them in order from weakest to strongest, describing attackers’ capabilities for each model:</p>
<ul>
<li class="noindent"><em>Ciphertext-only attackers (COA)</em> observe ciphertexts but don’t know the associated plaintexts, and don’t know how the plaintexts were selected. Attackers in the COA model are passive and can’t perform encryption or decryption queries.</li>
<li class="noindent"><em>Known-plaintext attackers (KPA)</em> observe ciphertexts and do know the associated plaintexts. Attackers in the KPA model thus get a list of plaintext–ciphertext pairs, where plaintexts are assumed to be randomly selected. Again, KPA is a passive attacker model.</li>
<li class="noindent"><em>Chosen-plaintext attackers (CPA)</em> can perform encryption queries for plaintexts of their choice and observe the resulting ciphertexts. This model captures situations where attackers can choose all or part of the plaintexts that are encrypted and then get to see the ciphertexts. Unlike COA or KPA, which are passive models, CPA are <em>active</em> attackers, because they influence the encryption processes rather than passively eavesdropping.</li>
<li class="noindent"><em>Chosen-ciphertext attackers (CCA)</em> can both encrypt and decrypt; that is, they get to perform encryption queries and decryption queries. The CCA model may sound ludicrous at first—if you can decrypt, what else do you need?—but like the CPA model, it aims to represent situations where attackers can have some influence on the ciphertext and later get access to the plaintext. Moreover, decrypting something is not always enough to break a system. For example, some video-protection devices allow attackers to perform encryption queries and decryption queries using the device’s chip, but in that context attackers are interested in the key in order to redistribute it; in this case, being able to decrypt “for free” isn’t sufficient to break the system.</li>
</ul>
<p class="indentt"><span epub:type="pagebreak" id="page_12"/>In the preceding models, ciphertexts that are observed as well as queried don’t come for free. Each ciphertext comes from the computation of the encryption function. This means that generating 2<sup><em>n</em></sup> plaintext–ciphertext pairs through encryption queries takes about as much computation as trying 2<sup><em>n</em></sup> keys, for example. The cost of queries should be taken into account when you’re computing the cost of an attack.</p>
<h5 class="h5">Gray-Box Models</h5>
<p class="noindent">In a <em>gray-box model</em>, the attacker has access to a cipher’s <em>i</em><em>mplementation</em>. This makes gray-box models more realistic than black-box models for applications such as smart cards, embedded systems, and virtualized systems, to which attackers often have physical access and can thus tamper with the algorithms’ internals. By the same token, gray-box models are more difficult to define than black-box ones because they depend on physical, analog properties rather than just on an algorithm’s input and outputs, and crypto theory will often fail to abstract the complexity of the real world.</p>
<p class="indent">S<em>ide-channel attacks</em> are a family of attacks within gray-box models. A side channel is a source of information that depends on the implementation of the cipher, be it in software or hardware. Side-channel attackers observe or measure analog characteristics of a cipher’s implementation but don’t alter its integrity; they are <em>noninvasive</em>. For pure software implementations, typical side channels are the execution time and the behavior of the system that surrounds the cipher, such as error messages, return values, branches, and so on. In the case of implementations on smart cards, for example, typical side-channel attackers measure power consumption, electromagnetic emanations, or acoustic noise.</p>
<p class="indent"><em>Invasive</em> <em>attacks</em> are a family of attacks on cipher implementations that are more powerful than side-channel attacks, and more expensive because they require sophisticated equipment. You can run basic side-channel attacks with a standard PC and an off-the-shelf oscilloscope, but invasive attacks require tools such as a high-resolution microscopes and a chemical lab. Invasive attacks thus consist of a whole set of techniques and procedures, from using nitric acid to remove a chip’s packaging to microscopic imagery acquisition, partial reverse engineering, and possible modification of the chip’s behavior with something like laser fault injection.</p>
<h4 class="h4" id="lev2sec13"><em>Security Goals</em></h4>
<p class="noindentb">I’ve informally defined the goal of security as “nothing can be learned about the cipher’s behavior.” To turn this idea into a rigorous mathematical definition, cryptographers define two main security goals that correspond to different ideas of what it means to learn something about a cipher’s behavior:</p>
<p class="hang"><strong>Indistinguishability (IND)</strong> Ciphertexts should be indistinguishable from random strings. This is usually illustrated with this hypothetical game: if an attacker picks two plaintexts and then receives a ciphertext of one of the two (chosen at random), they shouldn’t be able to tell <span epub:type="pagebreak" id="page_13"/>which plaintext was encrypted, even by performing encryption queries with the two plaintexts (and decryption queries, if the model is CCA rather than CPA).</p>
<p class="hang"><strong>Non-malleability (NM)</strong> Given a ciphertext <em>C</em><sub>1</sub> = <strong>E</strong>(<em>K</em>, <em>P</em><sub>1</sub>), it should be impossible to create another ciphertext, <em>C</em><sub>2</sub>, whose corresponding plaintext, <em>P</em><sub>2</sub>, is related to <em>P</em><sub>1</sub> in a meaningful way (for example, to create a <em>P</em><sub>2</sub> that is equal to <em>P</em><sub>1</sub> ⊕ 1 or to <em>P</em><sub>1</sub> ⊕ <em>X</em> for some known value <em>X</em>). Surprisingly, the one-time pad is malleable: given a ciphertext <em>C</em><sub>1</sub> = <em>P</em><sub>1</sub> ⊕ <em>K</em>, you can define <em>C</em><sub>2</sub> = <em>C</em><sub>1</sub> ⊕ 1, which is a valid ciphertext of <em>P</em><sub>2</sub> = <em>P</em><sub>1</sub> ⊕ 1 under the same key <em>K</em>. Oops, so much for our perfect cipher.</p>
<p class="indentt">Next, I’ll discuss these security goals in the context of different attack models.</p>
<h4 class="h4" id="lev2sec14"><em>Security Notions</em></h4>
<p class="noindent">Security goals are only useful when combined with an attack model. The convention is to write a security notion as <em>GOAL</em>-<em>MODEL</em>. For example, IND-CPA denotes indistinguishability against chosen-plaintext attackers, NM-CCA denotes nonmalleability against chosen-ciphertext attackers, and so on. Let’s start with the security goals for an attacker.</p>
<h5 class="h5">Semantic Security and Randomized Encryption: IND-CPA</h5>
<p class="noindent">The most important security notion is IND-CPA, also called <em>semantic</em> <em>security</em>. It captures the intuition that ciphertexts shouldn’t leak any information about plaintexts as long as the key is secret. To achieve IND-CPA security, encryption must return different ciphertexts if called twice on the same plaintext; otherwise, an attacker could identify duplicate plaintexts from their ciphertexts, contradicting the definition that ciphertexts shouldn’t reveal any information.</p>
<p class="indent">One way to achieve IND-CPA security is to use <em>randomized encryption</em>. As the name suggests, it randomizes the encryption process and returns different ciphertexts when the same plaintext is encrypted twice. Encryption can then be expressed as <em>C</em> = <strong>E</strong>(<em>K</em>, <em>R</em>, <em>P</em>), where <em>R</em> is fresh random bits. Decryption remains deterministic, however, because given <strong>E</strong>(<em>K</em>, <em>R</em>, <em>P</em>), you should always get <em>P</em>, regardless of the value of <em>R</em>.</p>
<p class="indent">What if encryption isn’t randomized? In the IND game introduced in <a href="ch01.xhtml#lev2sec13">“Security Goals”</a> on page 12, the attacker picks two plaintexts, <em>P</em><sub>1</sub> and <em>P</em><sub>2</sub>, and receives a ciphertext of one of the two, but doesn’t know which plaintext the ciphertext corresponds to. That is, they get <em>C</em><sub><em>i</em></sub> = <strong>E</strong>(<em>K</em>, <em>P</em><sub><em>i</em></sub>) and have to guess whether <em>i</em> is 1 or 2. In the CPA model, the attacker can perform encryption queries to determine both <em>C</em><sub>1</sub> = <strong>E</strong>(<em>K</em>, <em>P</em><sub>1</sub>) and <em>C</em><sub>2</sub> = <strong>E</strong>(<em>K</em>, <em>P</em><sub>2</sub>). If encryption isn’t randomized, it suffices to see if <em>C</em><sub><em>i</em></sub> is equal to <em>C</em><sub>1</sub> or to <em>C</em><sub>2</sub> in order to determine which plaintext was encrypted and thereby win the IND game. Therefore, randomization is key to the IND-CPA notion.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_14"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>With randomized encryption, ciphertexts must be slightly longer than plaintexts in order to allow for more than one possible ciphertext per plaintext. For example, if there are 2<sup>64</sup> possible ciphertexts per plaintext, ciphertexts must be at least 64 bits longer than plaintexts.</em></p>
</div>
<h5 class="h5">Achieving Semantically Secure Encryption</h5>
<p class="noindentb">One of the simplest constructions of a semantically secure cipher uses a <em>deterministic random bit generator (DRBG)</em>, an algorithm that returns random-looking bits given some secret value:</p>
<p class="center"><em>E</em>(<em>K</em>, <em>R</em>, <em>P</em>) = (<strong>DRBG</strong>(<em>K</em> || <em>R</em>) ⊕ <em>P</em>, <em>R</em>)</p>
<p class="indent">Here, <em>R</em> is a string randomly chosen for each new encryption and given to a DRBG along with the key (<em>K</em> || <em>R</em> denotes the string consisting of <em>K</em> followed by <em>R</em>). This approach is reminiscent of the one-time pad: instead of picking a random key of the same length as the message, we leverage a random bit generator to get a random-looking string.</p>
<p class="indent">The proof that this cipher is IND-CPA secure is simple, if we assume that the DRBG produces random bits. The proof works ad absurdum: if you can distinguish ciphertexts from random strings, which means that you can distinguish <strong>DRBG</strong>(<em>K</em> || <em>R</em>) ⊕ <em>P</em> from random, then this means that you can distinguish <strong>DRBG</strong>(<em>K</em> || <em>R</em>) from random. Remember that the CPA model lets you get ciphertexts for chosen values of <em>P</em>, so you can XOR <em>P</em> to <strong>DRBG</strong>(<em>K</em>, <em>R</em>) ⊕ <em>P</em> and get <strong>DRBG</strong>(<em>K</em>, <em>R</em>). But now we have a contradiction, because we started by assuming that <strong>DRBG</strong>(<em>K</em>, <em>R</em>) can’t be distinguished from random, producing random strings. So we conclude that ciphertexts can’t be distinguished from random strings, and therefore that the cipher is secure.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>As an exercise, try to determine what other security notions are satisfied by the above cipher <strong>E</strong></em>(<strong>K</strong>, <strong>R</strong>, <strong>P</strong>) = (<em><strong>DRBG</strong></em>(<strong>K</strong> || <strong>R</strong>) ⊕ <strong>P</strong>, <strong>R</strong>). <em>Is it NM-CPA? IND-CCA? You’ll find the answers in the next section.</em></p>
</div>
<h5 class="h5">Comparing Security Notions</h5>
<p class="noindent">You’ve learned that attack models such as CPA and CCA are combined with security goals such as NM and IND to build the security notions NM-CPA, NM-CCA, IND-CPA, and IND-CCA. How are these notions related? Can we prove that satisfying notion X implies satisfying notion Y?</p>
<p class="indent">Some relations are obvious: IND-CCA implies IND-CPA, and NM-CCA implies NM-CPA, because anything a CPA attacker can do, a CCA attacker can do as well. That is, if you can’t break a cipher by performing chosen-ciphertext and chosen-plaintext queries, you can’t break it by performing chosen-plaintext queries only.</p>
<p class="indent">A less obvious relation is that IND-CPA does not imply NM-CPA. To understand this, observe that the previous IND-CPA construction <span epub:type="pagebreak" id="page_15"/>(<strong>DRBG</strong>(<em>K</em> || <em>R</em>) ⊕ <em>P</em>, <em>R</em>) is not NM-CPA: given a ciphertext (<em>X</em>, <em>R</em>), you can create the ciphertext (<em>X</em> ⊕ 1, <em>R</em>), which is a valid ciphertext of <em>P</em> ⊕ 1, thus contradicting the notion of non-malleability.</p>
<p class="indent">But the opposite relation does hold: NM-CPA implies IND-CPA. The intuition is that IND-CPA encryption is like putting items in a bag: you don’t get to see them, but you can rearrange their positions in the bag by shaking it up and down. NM-CPA is more like a safe: once inside, you can’t interact with what you put in there. But this analogy doesn’t work for IND-CCA and NM-CCA, which are equivalent notions that each imply the presence of the other. I’ll spare you the proof, which is pretty technical.</p>
<div class="sidebar">
<p class="sidebart">TWO TYPES OF ENCRYPTION APPLICATIONS</p>
<p class="spara">There are two main types of encryption applications. <em>In-transit</em> encryption protects data sent from one machine to another: data is encrypted before being sent and decrypted after being received, as in encrypted connections to e-commerce websites. <em>At-rest encryption</em> protects data stored on an information system. Data is encrypted before being written to memory and decrypted before being read. Examples include disk encryption systems on laptops as well as virtual machine encryption for cloud virtual instances. The security notions we’ve seen apply to both types of applications, but the right notion to consider may depend on the application.</p>
</div>
<h3 class="h3" id="lev1sec10">Asymmetric Encryption</h3>
<p class="noindent">So far we’ve considered only symmetric encryption, where two parties share a key. In <em>asymmetric encryption</em>, there are two keys: one to encrypt and another to decrypt. The encryption key is called a <em>public key</em> and is generally considered publicly available to anyone who wants to send you encrypted messages. The decryption key, however, must remain secret and is called a <em>private key</em>.</p>
<p class="indent">The public key can be computed from the private key, but obviously the private key can’t be computed from the public key. In other words, it’s easy to compute in one direction, but not in the other—and that’s the point of <em>public-key cryptography</em>, whose functions are easy to compute in one direction but practically impossible to invert.</p>
<p class="indent">The attack models and security goals for asymmetric encryption are about the same as for symmetric encryption, except that because the encryption key is public, any attacker can make encryption queries by using the public key to encrypt. The default model for asymmetric encryption is therefore the chosen-plaintext attacker (CPA).</p>
<p class="indent">Symmetric and asymmetric encryption are the two main types of encryption, and they are usually combined to build secure communication systems. They’re also used to form the basis of more sophisticated schemes, as you’ll see next.</p>
<h3 class="h3" id="lev1sec11"><span epub:type="pagebreak" id="page_16"/>When Ciphers Do More Than Encryption</h3>
<p class="noindent">Basic encryption turns plaintexts into ciphertexts and ciphertexts into plaintexts, with no requirements other than security. However, some applications often need more than that, be it extra security features or extra functionalities. That’s why cryptographers created variants of symmetric and asymmetric encryption. Some are well-understood, efficient, and widely deployed, while others are experimental, hardly used, and offer poor performance.</p>
<h4 class="h4" id="lev2sec15"><em>Authenticated Encryption</em></h4>
<p class="noindent"><em>Authenticated encryption (AE)</em> is a type of symmetric encryption that returns an <em>authentication tag</em> in addition to a ciphertext. <a href="ch01.xhtml#ch1fig4">Figure 1-4</a> shows authenticated encryption sets <strong>AE</strong>(<em>K</em>, <em>P</em>) = (<em>C</em>, <em>T</em>), where the authentication tag <em>T</em> is a short string that’s impossible to guess without the key. Decryption takes <em>K</em>, <em>C</em>, and <em>T</em> and returns the plaintext <em>P</em> only if it verifies that <em>T</em> is a valid tag for that plaintext–ciphertext pair; otherwise, it aborts and returns some error.</p>
<div class="image"><img src="../images/f01-04.jpg" alt="image"/></div>
<p class="figcap"><a id="ch1fig4"/><em>Figure 1-4: Authenticated encryption</em></p>
<p class="indent">The tag ensures the <em>integrity</em> of the message and serves as evidence that the ciphertext received is identical to the one sent in the first place by a legitimate party that knows the key <em>K</em>. When <em>K</em> is shared with only one other party, the tag also guarantees that the message was sent by that party; that is, it implicitly <em>authenticates</em> the expected sender as the actual creator of the message.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>I use “creator” rather than “sender” here because an eavesdropper can record some</em> (C, T) <em>pairs sent by party A to party B and then send them again to B, pretending to be A. This is called a replay attack, and it can be prevented, for example, by including a counter number in the message. When a message is decrypted, its counter</em> i <em>is increased by one:</em> i + 1. <em>In this way, one could check the counter to see if a message has been sent twice, indicating that an attacker is attempting a replay attack by resending the message. This also enables the detection of lost messages.</em></p>
</div>
<p class="indent"><em>Authenticated encryption</em> <em>with associated data (AEAD)</em> is an extension of authenticated encryption that takes some cleartext and unencrypted data and uses it to generate the authentication tag <strong>AEAD</strong>(<em>K</em>, <em>P</em>, <em>A</em>) = (<em>C</em>, <em>T</em>). A typical application of AEAD is used to protect protocols’ datagrams with a cleartext header and an encrypted payload. In such cases, at least some header data has to remain in the clear; for example, destination addresses need to be clear in order to route network packets.</p>
<p class="indent">For more on authenticated encryption, jump to <a href="ch08.xhtml#ch8">Chapter 8</a>.</p>
<h4 class="h4" id="lev2sec16"><em>Format-Preserving Encryption</em></h4>
<p class="noindent">A basic cipher takes bits and returns bits; it doesn’t care whether bits represents text, an image, or a PDF document. The ciphertext may in turn be <span epub:type="pagebreak" id="page_17"/>encoded as raw bytes, hexadecimal characters, base64, and other formats. But what if you need the ciphertext to have the same format as the plaintext, as is sometimes required by database systems that can only record data in a prescribed format?</p>
<p class="indent"><em>Format-preserving encryption (FPE)</em> solves this problem. It can create ciphertexts that have the same format as the plaintext. For example, FPE can encrypt IP addresses to IP addresses (as shown in <a href="ch01.xhtml#ch1fig5">Figure 1-5</a>), ZIP codes to ZIP codes, credit card numbers to credit card numbers with a valid checksum, and so on.</p>
<div class="image"><img src="../images/f01-05.jpg" alt="image"/></div>
<p class="figcap"><a id="ch1fig5"/><em>Figure 1-5: Format-preserving encryption for IP addresses</em></p>
<h4 class="h4" id="lev2sec17"><em>Fully Homomorphic Encryption</em></h4>
<p class="noindent"><em>Fully homomorphic encryption (FHE)</em> is the holy grail to cryptographers: it enables its users to replace a ciphertext, <em>C</em> = <strong>E</strong>(<em>K</em>, <em>P</em>), with another ciphertext, <em>C</em>′ = <strong>E</strong>(<em>K</em>, <strong>F</strong>(<em>P</em>)), for <strong>F</strong>(<em>P</em>) can be any function of <em>P</em>, and without ever decrypting the initial ciphertext <em>C</em>. For example, <em>P</em> can be a text document, and <strong>F</strong> can be the modification of part of the text. You can imagine a cloud application that stores your encrypted data, but where the cloud provider doesn’t know what the data is or the type of changes made when you change that data. Sounds amazing, doesn’t it?</p>
<p class="indent">But there’s a flip side: this type of encryption is slow—so slow that even the most basic operation would take an unacceptably long time. The first FHE scheme was created in 2009, and since then more efficient variants appeared, but it remains unclear whether FHE will ever be fast enough to be useful.</p>
<h4 class="h4" id="lev2sec18"><em>Searchable Encryption</em></h4>
<p class="noindent"><em>Searchable encryption</em> enables searching over an encrypted database without leaking the searched terms by encrypting the search query itself. Like fully homomorphic encryption, searchable encryption could enhance the privacy of many cloud-based applications by hiding your searches from your cloud provider. Some commercial solutions claim to offer searchable encryption, though they’re mostly based on standard cryptography with a few tricks to enable partial searchability. As of this writing, however, searchable encryption remains experimental within the research community.</p>
<h4 class="h4" id="lev2sec19"><em>Tweakable Encryption</em></h4>
<p class="noindentb"><em>Tweakable encryption (TE)</em> is similar to basic encryption, except for an additional parameter called the <em>tweak</em>, which aims to simulate different versions <span epub:type="pagebreak" id="page_18"/>of a cipher (see <a href="ch01.xhtml#ch1fig6">Figure 1-6</a>). The tweak might be a unique per-customer value to ensure that a customer’s cipher can’t be cloned by other parties using the same product, but the main application of TE is <em>disk encryption</em>. However, TE is not bound to a single application and is a lower-level type of encryption used to build other schemes, such as authentication encryption modes.</p>
<div class="image"><img src="../images/f01-06.jpg" alt="image"/></div>
<p class="figcap"><a id="ch1fig6"/><em>Figure 1-6: Tweakable encryption</em></p>
<p class="indentt">In disk encryption, TE encrypts the content of storage devices such as hard drives or solid-state drives. (Randomized encryption can’t be used because it increases the size of the data, which is unacceptable for files on storage media.) To make encryption unpredictable, TE uses a tweak value that depends on the position of the data encrypted, which is usually a sector number or a block index.</p>
<h3 class="h3" id="lev1sec12">How Things Can Go Wrong</h3>
<p class="noindent">Encryption algorithms or implementations thereof can fail to protect confidentiality in many ways. This can be due to a failure to match the security requirements (such as “be IND-CPA secure”) or to set requirements matching reality (if you target only IND-CPA security when attackers can actually perform chosen-ciphertext queries). Alas, many engineers don’t even think about cryptographic security requirements and just want to be “secure” without understanding what that actually means. That’s usually a recipe for disaster. Let’s look at two examples.</p>
<h4 class="h4" id="lev2sec20"><em>Weak Cipher</em></h4>
<p class="noindent">Our first example concerns ciphers that can be attacked using cryptanalysis techniques, as occurred with the 2G mobile communication standard. Encryption in 2G mobile phones used a cipher called A5/1 that turned out to be weaker than expected, enabling the interception of calls by anyone with the right skills and tools. Telecommunication operators had to find workarounds to prevent the attack.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The 2G standard also defined A5/2, a cipher for areas other than the EU and US. A5/2 was purposefully weaker to prevent the use of strong encryption everywhere.</em></p>
</div>
<p class="indent">That said, attacking A5/1 isn’t trivial, and it took more than 10 years for researchers to come up with an effective cryptanalysis method. Furthermore, the attack is a <em>time-memory trade-off (TMTO)</em>, a type of method that first runs computations for days or weeks in order to build large look-up tables, which are subsequently used for the actual attack. For A5/1, the precomputed tables are more than 1TB. Later standards for mobile encryption, such as 3G and LTE, specify stronger ciphers, but that doesn’t mean that their encryption won’t be compromised; rather, it simply means that the encryption won’t be compromised by breaking the symmetric cipher that’s part of the system.</p>
<h4 class="h4" id="lev2sec21"><span epub:type="pagebreak" id="page_19"/><em>Wrong Model</em></h4>
<p class="noindent">The next example concerns an invalid attack model that overlooked some side channels.</p>
<p class="indent">Many communication protocols that use encryption ensure that they use ciphers considered secure in the CPA or CCA model. However, some attacks don’t require encryption queries, as in the CPA model, nor do they require decryption queries, as in the CCA model. They simply need <em>validity queries</em> to tell whether a ciphertext is valid, and these queries are usually sent to the system responsible for decrypting ciphertexts. <em>Padding oracle attacks</em> are an example of such attacks, wherein an attacker learns whether a ciphertext conforms to the required format.</p>
<p class="indent">Specifically, in the case of padding oracle attacks, a ciphertext is valid only if its plaintext has the proper <em>padding</em>, a sequence of bytes appended to the plaintext to simplify encryption. Decryption fails if the padding is incorrect, and attackers can often detect decryption failures and attempt to exploit them. For example, the presence of the Java exception <code>javax.crypto.BadPaddingException</code> would indicate that an incorrect padding was observed.</p>
<p class="indent">In 2010, researchers found padding oracle attacks in several web application servers. The validity queries consisted of sending a ciphertext to some system and observing whether it threw an error. Thanks to these queries, they could decrypt otherwise secure ciphertexts without knowing the key.</p>
<p class="indent">Cryptographers often overlook attacks like padding oracle attacks because they usually depend on an application’s behavior and on how users can interact with the application. But if you don’t anticipate such attacks and fail to include them in your model when designing and deploying cryptography, you may have some nasty surprises.</p>
<h3 class="h3" id="lev1sec13">Further Reading</h3>
<p class="noindent">We discuss encryption and its various forms in more detail throughout this book, especially how modern, secure ciphers work. Still, we can’t cover everything, and many fascinating topics won’t be discussed. For example, to learn the theoretical foundations of encryption and gain a deeper understanding of the notion of indistinguishability (IND), you should read the 1982 paper that introduced the idea of semantic security, “Probabilistic Encryption and How to Play Mental Poker Keeping Secret All Partial Information” by Goldwasser and Micali. If you’re interested in physical attacks and cryptographic hardware, the proceedings of the CHES conference are the main reference.</p>
<p class="indent">There are also many more types of encryption than those presented in this chapter, including attribute-based encryption, broadcast encryption, functional encryption, identity-based encryption, message-locked encryption, and proxy re-encryption, to cite but a few. For the latest research on those topics, you should check <em><a href="https://eprint.iacr.org/">https://eprint.iacr.org/</a></em>, an electronic archive of cryptography research papers.<span epub:type="pagebreak" id="page_20"/></p>
</body></html>