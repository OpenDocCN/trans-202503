- en: Chapter 3. Numbering
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’ll look at various one-liners for numbering lines and words,
    and you’ll get to know the `$.` special variable. You’ll also learn about Perl
    golfing, a “sport” that involves writing the shortest Perl program to get a task
    done.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Number all lines in a file
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As I explained in one-liner 2.1 (page 7), `-p` tells Perl to assume a loop around
    the program (specified by `-e`) that reads each line of input into the `$_` variable,
    executes the program, and then prints the contents of the `$_` variable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: This one-liner simply modifies `$_` by prepending the `$.` variable to it. The
    special variable `$.` contains the current line number of the input. The result
    is that each line has its line number prepended.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can also use the `-n` argument and print the string `"$. $_"`,
    which is the current line number followed by the line:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Say a file contains three lines:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running this one-liner numbers them:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 3.2 Number only non-empty lines in a file
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here you employ an “action if condition” statement that executes an action only
    if the condition is true. In this case, the condition is the regular expression
    `/./`, which matches all characters other than newline (that is, it matches a
    non-empty line). The action `$_ = ++$x." $_"` prepends the variable `$x` incremented
    by one to the current line. Because you’re not using the `strict` pragma, `$x`
    is created automatically the first time it’s incremented.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The result is that at each non-empty line `$x` is incremented by one and prepended
    to that line. Nothing is modified at the empty lines, and they are printed as
    is.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'One-liner 2.2 (page 11) shows another way to match non-empty lines through
    the `\S` regular expression:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Say a file contains four lines, two of which are empty:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Running this one-liner numbers only lines one and four:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 3.3 Number and print only non-empty lines in a file (drop empty lines)
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This one-liner uses the `-n` program argument, which places the line in the
    `$_` variable and then executes the program specified by `-e`. Unlike `-p`, `-n`
    does not print the line after executing the code in `-e`, so you have to call
    `print` explicitly to print the contents of the `$_` variable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The one-liner calls `print` only on lines with at least one character, and as
    in the previous one-liner, it increments the line number in the variable `$x`
    by one for each non-empty line. The empty lines are ignored and never printed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Say a file contains the same four lines as in one-liner 3.2:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Running this one-liner drops the empty lines and numbers lines one and four:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 3.4 Number all lines but print line numbers only for non-empty lines
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This one-liner is similar to one-liner 3.2\. Here, you modify the `$_` variable
    that holds the entire line only if the line has at least one character. All other
    empty lines are printed as is, without line numbers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Say a file contains four lines:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running this one-liner numbers all the lines but prints the line numbers only
    for lines one and four:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 3.5 Number only lines that match a pattern; print others unmodified
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, again, you use an “action if condition” statement, and again the condition
    is a pattern (a regular expression): `/regex/`. The action is the same as in one-liner
    3.2.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Say a file contains these lines:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'and you want to number the lines that contain the word *record*. You can replace
    `/regex/` in the one-liner with `/record/`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When you run this one-liner, it gives you the following output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 3.6 Number and print only lines that match a pattern
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This one-liner is almost exactly like one-liner 3.3, except it only numbers
    and prints lines that match `/regex/`. It doesn’t print nonmatching lines.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a file contains the same lines as in one-liner 3.5:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And let’s say you want to number and print only the lines that contain the
    word *record*. In this case, changing `/regex/` to `/record/` and running the
    one-liner gives you this result:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 3.7 Number all lines but print line numbers only for lines that match a pattern
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This one-liner is similar to one-liners 3.4 and 3.6\. Here, the line number
    is prepended to the line if the line matches a `/regex/`; otherwise, it’s simply
    printed without a line number.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Replacing `/regex/` with `/record/` and running this one-liner on the same
    example file shown in one-liner 3.6 gives you this output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 3.8 Number all lines in a file using a custom format
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This one-liner uses `printf` to print the line number together with the line
    contents. `printf` does formatted printing. You specify the format and send it
    the data to print, and it formats and prints the data accordingly. Here, the format
    for the line numbers is `%-5d`, which aligns the line numbers five positions to
    the left.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example. Say the input to this one-liner is
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then the output is
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Other format strings include `%5d`, which aligns the line numbers five positions
    to the right, and `%05d`, which zero-fills and right-justifies the line numbers.
    Here’s the output you get with the `%5d` format string for line numbers:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And this is what you get with the `%05d` format string:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To learn more about the various formats that are available, run `perldoc -f
    sprintf` at the command line.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 3.9 Print the total number of lines in a file (emulate wc -l)
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This one-liner uses the `END` block that Perl took as a feature from the Awk
    language. The `END` block is executed once the Perl program has executed. Here,
    the Perl program is the hidden loop over the input created by the `-n` argument.
    Once it loops over the input, the special variable `$.` contains the number of
    lines in the input, and the `END` block prints this variable. The `-l` parameter
    sets the output record separator for `print` to a newline, so you don’t have to
    print the newline yourself, like this: `print "$.\n"`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do the same thing with this one-liner:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This one-liner is easy to grasp if you understand Perl contexts well. The `()
    = <>` part tells Perl to evaluate the `<>` operator (the *diamond operator*) in
    the list context, which makes the diamond operator read the whole file as a list
    of lines. Next, you assign this list to `$n`. Because `$n` is scalar, this list
    assignment is evaluated in the scalar context.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s really happening here is the `=` operator is right-associative, meaning
    the `=` on the right is done first and the `=` on the left is done second:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Evaluating a list assignment in the scalar context returns the number of elements
    in the list; thus, the `$n = () = <>` construction is equal to the number of lines
    in the input, that is, the number of lines in the file. The `print` statement
    prints this number. The `-l` argument ensures a newline is added after printing
    this number.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also drop the variable `$n` from this one-liner and force the scalar
    context through the `scalar` operator:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, instead of evaluating a list assignment in the scalar context by assigning
    it again to another scalar, you simply evaluate the list assignment in the scalar
    context using the `scalar` operator.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'And now for a more obvious version:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, instead of using an empty list `()` to force the list context on `<>`,
    you use the variable `@foo` to achieve the same effect.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'And here’s another way to do it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This one-liner uses the so-called *eskimo operator* `}{` (actually a clever
    construct) in conjunction with the `-n` command-line argument. As I explained
    earlier, the `-n` argument forces Perl to assume a `while(<>) { }` loop around
    the program. The eskimo operator forces Perl to escape the loop, and the one-liner
    expands to
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, this program just loops over all the input, and once it’s finished,
    it prints the `$.`, which is the number of lines in the input. It becomes even
    more obvious if you change the formatting a little:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, this is just an empty loop that loops over all the input, followed
    by the `print` statement wrapped in curly brackets.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 3.10 Print the number of non-empty lines in a file
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This one-liner uses Perl’s `grep` function, which is similar to the `grep` UNIX
    command. Given a list of values, `grep { condition } list` returns only those
    values in the `list` that make the `condition` true. In this case, the condition
    is a regular expression that matches at least one character, so the input is filtered
    and `grep{ /./ }` returns all non-empty lines. To get the number of lines, you
    evaluate `grep` in the scalar context and print the result.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Some Perl programmers like to create the shortest Perl program that does some
    particular task—an exercise called *Perl golfing*. A golfer’s version of this
    one-liner would replace `scalar()` with `~~` (double bitwise negate) and drop
    the spaces, shortening it like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This double bitwise negate trick is effectively a synonym for `scalar` because
    the bitwise negation works on scalar values, so `grep` is evaluated in the scalar
    context.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make this even shorter by dropping the space after `print` and getting
    rid of the curly brackets:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you have Perl 5.10 or later, you can also use the `-E` command-line switch
    and the `say` operator:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: A true golfer’s masterpiece!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 3.11 Print the number of empty lines in a file
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, you use the variable `$x` to count the number of empty lines encountered.
    Once you’ve looped over all the lines, you print the value of `$x` in the `END`
    block. You use the `$x+0` construction to ensure that `0` is output if no lines
    are empty. (Otherwise `$x` is never created and is undefined. Adding `+0` to the
    undefined value produces `0`.) An alternative to `$x+0` is the `int` operator:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You could also modify the previous one-liner by doing this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Or write it with `~~`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `~~` does bitwise negation twice, which makes `grep` execute in the scalar
    context and return the number of empty lines.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: These last two versions are not as effective as the one-liner with the `END`
    block because they read the whole file into memory, whereas the one-liner with
    the `END` block does it line by line and, therefore, keeps only one line of input
    in memory.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 3.12 Print the number of lines in a file that match a pattern (emulate grep
    -c)
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This one-liner is basically the same as 3.11, except it increments the line
    counter `$x` by one when a line matches the regular expression `/regex/`. The
    `$x+0` trick makes sure `0` is printed when no lines match `/regex/`. (See one-liner
    3.11 for a more detailed explanation of the `$x+0` trick.)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 3.13 Number words across all lines
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This one-liner uses the `/e` flag, which makes Perl evaluate the `replace` part
    of the `s/regex/replace/` expression as code!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'The code here is `++$i.".$1"`, which means “increment variable `$i` by one
    and then add it in front of the string `".$1"` (that is, a dot followed by the
    contents of the matched group `$1`).” The matched group here is each word: `(\w+)`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: In one sentence, this one-liner matches a word `(\w+)`, puts it in `$1`, and
    then executes the `++$i.".$1"` code that numbers the word globally (`/g` flag).
    There—all words are numbered.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have a file with the following three lines:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'running this one-liner numbers each word in the file and produces the following
    output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 3.14 Number words on each individual line
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This is similar to one-liner 3.13, except that you reset the `$i` variable
    to `0` on each line. Here’s the result of running this one-liner on the example
    from one-liner 3.13:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, in each line the words are numbered independently of other lines.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 3.15 Replace all words with their numeric positions
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This one-liner is almost the same as one-liner 3.13\. Here, you simply replace
    each word with its numeric position, which is kept in the variable `$i`. For example,
    if you run this one-liner on the file from one-liners 3.13 and 3.14, it replaces
    the words in the file with their numeric positions to produce this output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行命令几乎与单行命令 3.13 相同。在这里，你只需用每个单词的数字位置来替换它，而这个数字位置保存在变量`$i`中。例如，如果你在单行命令 3.13
    和 3.14 中的文件上运行这个单行命令，它会将文件中的单词替换为它们的数字位置，输出如下：
- en: '[PRE51]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Fun!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 好玩！
