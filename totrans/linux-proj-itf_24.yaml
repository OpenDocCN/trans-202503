- en: Chapter 24. Process Creation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 24 章：进程创建
- en: In this and the next three chapters, we look at how a process is created and
    terminates, and how a process can execute a new program. This chapter covers process
    creation. However, before diving into that subject, we present a short overview
    of the main system calls covered in these four chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章及接下来的三章中，我们将探讨一个进程是如何创建和终止的，以及进程如何执行一个新程序。本章将讨论进程的创建。然而，在深入讨论之前，我们将简要概述这四章中涉及的主要系统调用。
- en: Overview of *fork()*, *exit()*, *wait()*, and *execve()*
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*fork()*、*exit()*、*wait()* 和 *execve()* 概述'
- en: The principal topics of this and the next few chapters are the system calls
    *fork()*, *exit()*, *wait()*, and *execve()*. Each of these system calls has variants,
    which we’ll also look at. For now, we provide an overview of these four system
    calls and how they are typically used together.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章及接下来的几章的主要话题是系统调用 *fork()*、*exit()*、*wait()* 和 *execve()*。这些系统调用各自有不同的变体，我们也会进行讨论。现在，我们先对这四个系统调用及其常见的联合使用方式进行概述。
- en: 'The *fork()* system call allows one process, the parent, to create a new process,
    the child. This is done by making the new child process an (almost) exact duplicate
    of the parent: the child obtains copies of the parent’s stack, data, heap, and
    text segments ([Memory Layout of a Process](ch06.html#memory_layout_of_a_process
    "Memory Layout of a Process")). The term *fork* derives from the fact that we
    can envisage the parent process as dividing to yield two copies of itself.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*fork()* 系统调用允许一个进程（父进程）创建一个新的进程（子进程）。这通过将新的子进程几乎完全复制父进程来实现：子进程获得父进程的堆栈、数据、堆和文本段的副本（[进程的内存布局](ch06.html#memory_layout_of_a_process
    "进程的内存布局")）。*fork* 这个术语源于我们可以想象父进程分裂成两个相同的副本。'
- en: The *exit(status)* library function terminates a process, making all resources
    (memory, open file descriptors, and so on) used by the process available for subsequent
    reallocation by the kernel. The *status* argument is an integer that determines
    the termination status for the process. Using the *wait()* system call, the parent
    can retrieve this status.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*exit(status)* 库函数用于终止进程，使该进程使用的所有资源（内存、打开的文件描述符等）可供内核后续重新分配。*status* 参数是一个整数，确定进程的终止状态。父进程可以使用
    *wait()* 系统调用获取此状态。'
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *exit()* library function is layered on top of the *_exit()* system call.
    In [Chapter 25](ch25.html "Chapter 25. Process Termination"), we explain the difference
    between the two interfaces. In the meantime, we’ll just note that, after a *fork()*,
    generally only one of the parent and child terminate by calling *exit()*; the
    other process should terminate using *_exit()*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*exit()* 库函数是建立在 *_exit()* 系统调用之上的。在 [第 25 章](ch25.html "第 25 章：进程终止")中，我们将解释这两者接口的区别。与此同时，我们仅需注意，在
    *fork()* 后，通常只有父进程或子进程之一会通过调用 *exit()* 终止；另一个进程应通过调用 *_exit()* 终止。'
- en: The *wait(&status)* system call has two purposes. First, if a child of this
    process has not yet terminated by calling *exit()*, then *wait()* suspends execution
    of the process until one of its children has terminated. Second, the termination
    status of the child is returned in the status argument of *wait()*.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*wait(&status)* 系统调用有两个用途。首先，如果该进程的子进程尚未通过调用 *exit()* 终止，则 *wait()* 会挂起该进程的执行，直到其子进程之一终止。其次，子进程的终止状态会通过
    *wait()* 的状态参数返回。'
- en: The *execve(pathname, argv, envp)* system call loads a new program (*pathname*,
    with argument list *argv*, and environment list *envp*) into a process’s memory.
    The existing program text is discarded, and the stack, data, and heap segments
    are freshly created for the new program. This operation is often referred to as
    *execing* a new program. Later, we’ll see that several library functions are layered
    on top of *execve()*, each of which provides a useful variation in the programming
    interface. Where we don’t care about these interface variations, we follow the
    common convention of referring to these calls generically as *exec()*, but be
    aware that there is no system call or library function with this name.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*execve(pathname, argv, envp)* 系统调用将一个新程序（*pathname*，包含参数列表 *argv* 和环境列表 *envp*）加载到进程的内存中。现有的程序文本会被丢弃，新的堆栈、数据和堆段会为新程序重新创建。这个操作通常被称为
    *execing* 一个新程序。稍后我们会看到，多个库函数层叠在 *execve()* 之上，每个库函数都提供了编程接口的有用变化。当我们不关心这些接口变化时，通常按照惯例将这些调用统称为
    *exec()*，但需要注意的是，实际上并没有名为 *exec()* 的系统调用或库函数。'
- en: Some other operating systems combine the functionality of *fork()* and *exec()*
    into a single operation—a so-called *spawn*—that creates a new process that then
    executes a specified program. By comparison, the UNIX approach is usually simpler
    and more elegant. Separating these two steps makes the APIs simpler (the *fork()*
    system call takes *no* arguments) and allows a program a great degree of flexibility
    in the actions it performs between the two steps. Moreover, it is often useful
    to perform a *fork()* without a following *exec()*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他操作系统将*fork()*和*exec()*的功能合并为一个单独的操作——所谓的*spawn*——该操作创建一个新的进程，然后执行指定的程序。相比之下，UNIX方法通常更简单、更优雅。将这两个步骤分开使得API更简洁（*fork()*系统调用不需要任何参数），并且在这两个步骤之间的操作更加灵活。此外，执行*fork()*而不跟随*exec()*通常是很有用的。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 specifies the optional *posix_spawn()* function, which combines the effect
    of *fork()* and *exec()*. This function, and several related APIs specified by
    SUSv3, are implemented on Linux in *glibc*. SUSv3 specifies *posix_spawn()* to
    permit portable applications to be written for hardware architectures that don’t
    provide swap facilities or memory-management units (this is typical of many embedded
    systems). On such architectures, a traditional *fork()* is difficult or impossible
    to implement.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3规范了可选的*posix_spawn()*函数，它结合了*fork()*和*exec()*的效果。这个函数和SUSv3规范的几个相关API在Linux的*glibc*中得到了实现。SUSv3定义*posix_spawn()*是为了允许开发便于在没有交换设施或内存管理单元的硬件架构上运行的可移植应用程序（这在许多嵌入式系统中是典型的）。在这种架构下，传统的*fork()*实现起来困难或不可能。
- en: '[Figure 24-1](ch24.html#overview_of_the_use_of_fork_open_parenth "Figure 24-1. Overview
    of the use of fork(), exit(), wait(), and execve()") provides an overview of how
    *fork()*, *exit()*, *wait()*, and *execve()* are commonly used together. (This
    diagram outlines the steps taken by the shell in executing a command: the shell
    continuously executes a loop that reads a command, performs various processing
    on it, and then forks a child process to exec the command.)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 24-1](ch24.html#overview_of_the_use_of_fork_open_parenth "图 24-1. *fork()*,
    *exit()*, *wait()*, 和 *execve()* 的使用概览")提供了*fork()*, *exit()*, *wait()* 和 *execve()*
    常见的共同使用概览。（该图概述了Shell执行命令的步骤：Shell持续执行一个循环，读取命令，进行各种处理，然后fork一个子进程来执行命令。）'
- en: The use of *execve()* shown in this diagram is optional. Sometimes, it is instead
    useful to have the child carry on executing the same program as the parent. In
    either case, the execution of the child is ultimately terminated by a call to
    *exit()* (or by delivery of a signal), yielding a termination status that the
    parent can obtain via *wait()*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此图中展示的*execve()*的使用是可选的。有时，子进程继续执行与父进程相同的程序更为有用。无论哪种情况，子进程的执行最终会通过调用*exit()*（或发送信号）终止，父进程可以通过*wait()*获得终止状态。
- en: The call to *wait()* is likewise optional. The parent can simply ignore its
    child and continue executing. However, we’ll see later that the use of *wait()*
    is usually desirable, and is often employed within a handler for the `SIGCHLD`
    signal, which the kernel generates for a parent process when one of its children
    terminates. (By default, `SIGCHLD` is ignored, which is why we label it as being
    optionally delivered in the diagram.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 调用*wait()*同样是可选的。父进程可以简单地忽略其子进程并继续执行。然而，稍后我们将看到，通常需要使用*wait()*，并且它通常被用于处理`SIGCHLD`信号，该信号由内核生成，当父进程的某个子进程终止时会发送此信号。（默认情况下，`SIGCHLD`信号会被忽略，这也是我们在图中标注为“可选交付”的原因。）
- en: '![Overview of the use of fork(), exit(), wait(), and execve()](figs/web/24-1_PROCEXEC-overview-scale90.png.jpg)Figure 24-1. Overview
    of the use of *fork()*, *exit()*, *wait()*, and *execve()*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![*fork()*, *exit()*, *wait()*, 和 *execve()* 的使用概览](figs/web/24-1_PROCEXEC-overview-scale90.png.jpg)图
    24-1. *fork()*, *exit()*, *wait()*, 和 *execve()* 的使用概览'
- en: 'Creating a New Process: *fork()*'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新进程：*fork()*
- en: In many applications, creating multiple processes can be a useful way of dividing
    up a task. For example, a network server process may listen for incoming client
    requests and create a new child process to handle each request; meanwhile, the
    server process continues to listen for further client connections. Dividing tasks
    up in this way often makes application design simpler. It also permits greater
    concurrency (i.e., more tasks or requests can be handled simultaneously).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用中，创建多个进程是一种有效的任务划分方式。例如，一个网络服务器进程可能会监听来自客户端的请求，并为每个请求创建一个新的子进程来处理；与此同时，服务器进程继续监听其他客户端连接。以这种方式划分任务通常会使应用程序设计更简洁。它还允许更高的并发性（即，可以同时处理更多的任务或请求）。
- en: The *fork()* system call creates a new process, the *child*, which is an almost
    exact duplicate of the calling process, the *parent*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*fork()* 系统调用创建一个新的进程，即 *子进程*，它几乎是调用进程（即 *父进程*）的一个精确副本。'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In parent: returns process ID of child on success, or -1 on error; in successfully
    created child: always returns 0'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在父进程中：成功时返回子进程的进程 ID，出错时返回 -1；在成功创建的子进程中：总是返回 0
- en: The key point to understanding *fork()* is to realize that after it has completed
    its work, two processes exist, and, in each process, execution continues from
    the point where *fork()* returns.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 *fork()* 的关键点在于认识到，在 *fork()* 完成工作后，存在两个进程，并且在每个进程中，执行会从 *fork()* 返回的地方继续。
- en: The two processes are executing the same program text, but they have separate
    copies of the stack, data, and heap segments. The child’s stack, data, and heap
    segments are initially exact duplicates of the corresponding parts the parent’s
    memory. After the *fork()*, each process can modify the variables in its stack,
    data, and heap segments without affecting the other process.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个进程执行相同的程序代码，但它们有各自独立的栈、数据和堆段。子进程的栈、数据和堆段最初是父进程内存中相应部分的精确副本。在 *fork()* 之后，每个进程可以修改自己栈、数据和堆段中的变量，而不会影响另一个进程。
- en: Within the code of a program, we can distinguish the two processes via the value
    returned from *fork()*. For the parent, *fork()* returns the process ID of the
    newly created child. This is useful because the parent may create, and thus need
    to track, several children (via *wait()* or one of its relatives). For the child,
    *fork()* returns 0\. If necessary, the child can obtain its own process ID using
    *getpid()*, and the process ID of its parent using *getppid()*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的代码中，我们可以通过 *fork()* 返回的值来区分这两个进程。对于父进程，*fork()* 返回新创建子进程的进程 ID。这非常有用，因为父进程可能需要创建并跟踪多个子进程（通过
    *wait()* 或其相关函数）。对于子进程，*fork()* 返回 0。如果需要，子进程可以使用 *getpid()* 获取自己的进程 ID，并使用 *getppid()*
    获取父进程的进程 ID。
- en: If a new process can’t be created, *fork()* returns -1. Possible reasons for
    failure are that the resource limit (`RLIMIT_NPROC`, described in [Details of
    Specific Resource Limits](ch36.html#details_of_specific_resource_limits "Details
    of Specific Resource Limits")) on the number of processes permitted to this (real)
    user ID has been exceeded or that the system-wide limit on the number of processes
    that can be created has been reached.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法创建新进程，*fork()* 会返回 -1。失败的可能原因包括该（真实）用户 ID 允许的进程数资源限制（`RLIMIT_NPROC`，详见 [特定资源限制详情](ch36.html#details_of_specific_resource_limits
    "特定资源限制详情")）已被超出，或者系统范围内允许创建的最大进程数已达到上限。
- en: 'The following idiom is sometimes employed when calling *fork()*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 *fork()* 时，有时会使用以下习惯用法：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is important to realize that after a *fork()*, it is indeterminate which
    of the two processes is next scheduled to use the CPU. In poorly written programs,
    this indeterminacy can lead to errors known as race conditions, which we describe
    further in Section 24.4.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 需要意识到的是，*fork()* 之后，无法确定哪一个进程将被调度使用 CPU。在写得不好的程序中，这种不确定性可能会导致称为竞争条件的错误，我们将在第
    24.4 节进一步讨论这一问题。
- en: '[Example 24-1](ch24.html#using_fork_open_parenthesis_close_parent "Example 24-1. Using
    fork()") demonstrates the use of *fork()*. This program creates a child that modifies
    the copies of global and automatic variables that it inherits during the during
    the *fork()*.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 24-1](ch24.html#using_fork_open_parenthesis_close_parent "示例 24-1. 使用 fork()")
    展示了 *fork()* 的使用。这个程序创建了一个子进程，修改了它在 *fork()* 过程中继承的全局变量和自动变量的副本。'
- en: The use of *sleep()* (in the code executed by the parent) in this program permits
    the child to be scheduled for the CPU before the parent, so that the child can
    complete its work and terminate before the parent continues execution. Using *sleep()*
    in this manner is not a foolproof method of guaranteeing this result; we look
    at a better method in Section 24.5.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本程序中父进程执行的 *sleep()* 函数允许子进程在父进程之前获得 CPU 时间片，从而使得子进程可以先完成任务并终止，然后父进程再继续执行。以这种方式使用
    *sleep()* 并不是保证结果的万无一失的方法；我们将在第 24.5 节讨论更好的方法。
- en: 'When we run the program in [Example 24-1](ch24.html#using_fork_open_parenthesis_close_parent
    "Example 24-1. Using fork()"), we see the following output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 [示例 24-1](ch24.html#using_fork_open_parenthesis_close_parent "示例 24-1.
    使用 fork()") 程序时，看到以下输出：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The above output demonstrates that the child process gets its own copy of the
    stack and data segments at the time of the *fork()*, and it is able to modify
    variables in these segments without affecting the parent.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出演示了在执行*fork()*时，子进程获得了栈和数据段的独立副本，并且可以修改这些段中的变量，而不会影响父进程。
- en: Example 24-1. Using *fork()*
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 24-1. 使用*fork()*
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: File Sharing Between Parent and Child
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 父子进程之间的文件共享
- en: When a *fork()* is performed, the child receives duplicates of all of the parent’s
    file descriptors. These duplicates are made in the manner of *dup()*, which means
    that corresponding descriptors in the parent and the child refer to the same open
    file description. As we saw in [Relationship Between File Descriptors and Open
    Files](ch05.html#relationship_between_file_descriptors_an "Relationship Between
    File Descriptors and Open Files"), the open file description contains the current
    file offset (as modified by *read()*, *write()*, and *lseek()*) and the open file
    status flags (set by *open()* and changed by the *fcntl()* `F_SETFL` operation).
    Consequently, these attributes of an open file are shared between the parent and
    child. For example, if the child updates the file offset, this change is visible
    through the corresponding descriptor in the parent.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 执行*fork()*时，子进程会接收到父进程所有文件描述符的副本。这些副本是通过*dup()*方式创建的，这意味着父子进程中对应的描述符指向相同的打开文件描述符。正如我们在[文件描述符与打开文件之间的关系](ch05.html#relationship_between_file_descriptors_an
    "文件描述符与打开文件之间的关系")中看到的，打开文件描述符包含当前的文件偏移量（由*read()*、*write()*和*lseek()*修改）以及打开文件的状态标志（由*open()*设置，并通过*fcntl()*的`F_SETFL`操作更改）。因此，打开文件的这些属性在父子进程之间是共享的。例如，如果子进程更新了文件偏移量，这一更改将通过父进程中的对应描述符可见。
- en: 'The fact that these attributes are shared by the parent and child after a *fork()*
    is demonstrated by the program in [Example 24-2](ch24.html#sharing_of_file_offset_and_open_file_sta
    "Example 24-2. Sharing of file offset and open file status flags between parent
    and child"). This program opens a temporary file using *mkstemp()*, and then calls
    *fork()* to create a child process. The child changes the file offset and open
    file status flags of the temporary file, and exits. The parent then retrieves
    the file offset and flags to verify that it can see the changes made by the child.
    When we run the program, we see the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 父子进程在执行*fork()*后共享这些属性的事实，通过[示例 24-2](ch24.html#sharing_of_file_offset_and_open_file_sta
    "示例 24-2. 父子进程之间共享文件偏移量和打开文件状态标志")中的程序得到了证明。该程序使用*mkstemp()*打开一个临时文件，然后调用*fork()*创建一个子进程。子进程更改了临时文件的文件偏移量和打开文件状态标志，并退出。父进程随后检索文件偏移量和标志，以验证它可以看到子进程所做的更改。当我们运行该程序时，看到如下输出：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For an explanation of why we cast the return value from *lseek()* to *long long*
    in [Example 24-2](ch24.html#sharing_of_file_offset_and_open_file_sta "Example 24-2. Sharing
    of file offset and open file status flags between parent and child"), see [I/O
    on Large Files](ch05.html#i_solidus_o_on_large_files "I/O on Large Files").
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有关为什么我们在[示例 24-2](ch24.html#sharing_of_file_offset_and_open_file_sta "示例 24-2.
    父子进程之间共享文件偏移量和打开文件状态标志")中将*lseek()*的返回值强制转换为*long long*的解释，请参见[大文件的I/O操作](ch05.html#i_solidus_o_on_large_files
    "大文件的I/O操作")。
- en: Example 24-2. Sharing of file offset and open file status flags between parent
    and child
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 24-2. 父子进程之间共享文件偏移量和打开文件状态标志
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Sharing of open file attributes between the parent and child processes is frequently
    useful. For example, if the parent and child are both writing to a file, sharing
    the file offset ensures that the two processes don’t overwrite each other’s output.
    It does not, however, prevent the output of the two processes from being randomly
    intermingled. If this is not desired, then some form of process synchronization
    is required. For example, the parent can use the *wait()* system call to pause
    until the child has exited. This is what the shell does, so that it prints its
    prompt only after the child process executing a command has terminated (unless
    the user explicitly runs the command in the background by placing an ampersand
    character at the end of the command).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 父子进程共享打开的文件属性通常是非常有用的。例如，如果父进程和子进程都在向同一个文件写入，文件偏移量的共享可以确保两个进程不会覆盖对方的输出。然而，这并不能防止两个进程的输出被随机交织在一起。如果不希望这种情况发生，则需要某种形式的进程同步。例如，父进程可以使用*wait()*系统调用暂停，直到子进程退出。这正是shell所做的，它仅在执行命令的子进程终止后才打印提示符（除非用户通过在命令末尾添加“&”符号显式地让命令在后台运行）。
- en: If sharing of file descriptors in this manner is not required, then an application
    should be designed so that, after a *fork()*, the parent and child use different
    file descriptors, with each process closing unused descriptors (i.e., those used
    by the other process) immediately after forking. (If one of the processes performs
    an *exec()*, the close-on-exec flag described in [File Descriptors and *exec()*](ch27.html#file_descriptors_and_exec_open_parenthes
    "File Descriptors and exec()") can also be useful.) These steps are shown in [Figure 24-2](ch24.html#duplication_of_file_descriptors_during_f
    "Figure 24-2. Duplication of file descriptors during fork(), and closing of unused
    descriptors").
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要以这种方式共享文件描述符，则应用程序应该设计成，在*fork()*之后，父进程和子进程使用不同的文件描述符，并且每个进程在fork后立即关闭未使用的描述符（即由另一个进程使用的描述符）。（如果其中一个进程执行*exec()*，在[文件描述符和*exec()*](ch27.html#file_descriptors_and_exec_open_parenthes
    "文件描述符和exec()")中描述的close-on-exec标志也可能会有所帮助。）这些步骤在[图24-2](ch24.html#duplication_of_file_descriptors_during_f
    "图24-2. fork()期间文件描述符的复制，以及关闭未使用的描述符")中展示。
- en: '![Duplication of file descriptors during fork(), and closing of unused descriptors](figs/web/24-2_PROCEXEC-fork-descriptors.png.jpg)Figure 24-2. Duplication
    of file descriptors during *fork()*, and closing of unused descriptors'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![fork()期间文件描述符的复制，以及关闭未使用的描述符](figs/web/24-2_PROCEXEC-fork-descriptors.png.jpg)图24-2.
    *fork()*期间文件描述符的复制，以及关闭未使用的描述符'
- en: Memory Semantics of *fork()*
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*fork()*的内存语义'
- en: 'Conceptually, we can consider *fork()* as creating copies of the parent’s text,
    data, heap, and stack segments. (Indeed, in some early UNIX implementations, such
    duplication was literally performed: a new process image was created by copying
    the parent’s memory to swap space, and making that swapped-out image the child
    process while the parent kept its own memory.) However, actually performing a
    simple copy of the parent’s virtual memory pages into the new child process would
    be wasteful for a number of reasons—one being that a *fork()* is often followed
    by an immediate *exec()*, which replaces the process’s text with a new program
    and reinitializes the process’s data, heap, and stack segments. Most modern UNIX
    implementations, including Linux, use two techniques to avoid such wasteful copying:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，我们可以将*fork()*看作是创建父进程的文本、数据、堆和栈段的副本。（实际上，在一些早期的UNIX实现中，这种复制操作是字面上执行的：通过将父进程的内存复制到交换空间，创建一个新的进程映像，并将该交换出的映像作为子进程，而父进程保持自己的内存。）然而，实际上简单地将父进程的虚拟内存页复制到新的子进程中是低效的，原因有很多——其中一个原因是*fork()*通常会紧接着一个*exec()*，后者会用一个新程序替换进程的文本，并重新初始化进程的数据显示、堆和栈段。大多数现代UNIX实现，包括Linux，使用两种技术来避免这种浪费性的复制：
- en: The kernel marks the text segment of each process as read-only, so that a process
    can’t modify its own code. This means that the parent and child can share the
    same text segment. The *fork()* system call creates a text segment for the child
    by building a set of per-process page-table entries that refer to the same virtual
    memory page frames already used by the parent.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核将每个进程的文本段标记为只读，这样进程就无法修改自己的代码。这意味着父进程和子进程可以共享相同的文本段。*fork()*系统调用通过构建一组每个进程的页表项来为子进程创建一个文本段，这些页表项指向已经被父进程使用的相同虚拟内存页面框架。
- en: For the pages in the data, heap, and stack segments of the parent process, the
    kernel employs a technique known as *copy-on-write*. (The implementation of copy-on-write
    is described in [Bach, 1986] and [Bovet & Cesati, 2005].) Initially, the kernel
    sets things up so that the page-table entries for these segments refer to the
    same physical memory pages as the corresponding page-table entries in the parent,
    and the pages themselves are marked read-only. After the *fork()*, the kernel
    traps any attempts by either the parent or the child to modify one of these pages,
    and makes a duplicate copy of the about-to-be-modified page. This new page copy
    is assigned to the faulting process, and the corresponding page-table entry for
    the child is adjusted appropriately. From this point on, the parent and child
    can each modify their private copies of the page, without the changes being visible
    to the other process. [Figure 24-3](ch24.html#page_tables_before_and_after_modificatio
    "Figure 24-3. Page tables before and after modification of a shared copy-on-write
    page") illustrates the copy-on-write technique.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于父进程中数据段、堆段和栈段的页面，内核使用一种叫做*写时复制*（copy-on-write）的技术。（写时复制的实现可以参考[Bach, 1986]和[Bovet
    & Cesati, 2005]。）最初，内核会设置这些段的页表项，使其指向与父进程中相应页表项相同的物理内存页面，并且这些页面本身被标记为只读。在*fork()*之后，内核会拦截父进程或子进程任何修改这些页面的尝试，并为即将被修改的页面创建一个副本。这个新的页面副本会分配给故障进程，并适当调整子进程的相应页表项。从此之后，父进程和子进程可以各自修改它们的私有页面副本，而修改不会对另一个进程可见。[图
    24-3](ch24.html#page_tables_before_and_after_modificatio "图 24-3. 共享写时复制页面修改前后的页表")展示了写时复制技术。
- en: '![Page tables before and after modification of a shared copy-on-write page](figs/web/24-3_PROCEXEC-fork-cow.png.jpg)Figure 24-3. Page
    tables before and after modification of a shared copy-on-write page'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![共享写时复制页面修改前后的页表](figs/web/24-3_PROCEXEC-fork-cow.png.jpg)图 24-3. 共享写时复制页面修改前后的页表'
- en: Controlling a process’s memory footprint
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制进程的内存占用
- en: We can combine the use of *fork()* and *wait()* to control the memory footprint
    of a process. The process’s memory footprint is the range of virtual memory pages
    used by the process, as affected by factors such as the adjustment of the stack
    as functions are called and return, calls to *exec()*, and, of particular interest
    to this discussion, modification of the heap as a consequence of calls to *malloc()*
    and *free()*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以结合使用*fork()*和*wait()*来控制进程的内存占用。进程的内存占用是指进程使用的虚拟内存页面范围，受诸如函数调用和返回时栈调整、调用*exec()*、以及特别需要关注的因调用*malloc()*和*free()*导致堆内存修改等因素的影响。
- en: 'Suppose that we bracket a call to some function, *func()*, using *fork()* and
    *wait()* in the manner shown in [Example 24-3](ch24.html#calling_a_function_without_changing_the
    "Example 24-3. Calling a function without changing the process’s memory footprint").
    After executing this code, we know that the memory footprint of the parent is
    unchanged from the point before *func()* was called, since all possible changes
    will have occurred in the child process. This can be useful for the following
    reasons:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在[示例 24-3](ch24.html#calling_a_function_without_changing_the "示例 24-3. 在不改变进程内存占用的情况下调用函数")中展示的方式下，使用*fork()*和*wait()*来包围对某个函数*func()*的调用。在执行完这些代码后，我们知道父进程的内存占用没有改变，因为所有可能的修改都发生在子进程中。这对于以下原因非常有用：
- en: If we know that *func()* causes memory leaks or excessive fragmentation of the
    heap, this technique eliminates the problem. (We might not otherwise be able to
    deal with these problems if we don’t have access to the source code of *func()*.)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们知道*func()*会导致内存泄漏或堆内存的过度碎片化，那么这种技术可以消除这个问题。（如果我们无法访问*func()*的源代码，可能无法解决这些问题。）
- en: Suppose that we have some algorithm that performs memory allocation while doing
    a tree analysis (for example, a game program that analyzes a range of possible
    moves and their responses). We could code such a program to make calls to *free()*
    to deallocate all of the allocated memory. However, in some cases, it is simpler
    to employ the technique we describe here in order to allow us to backtrack, leaving
    the caller (the parent) with its original memory footprint unchanged.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们有一个算法，在进行树形分析时会执行内存分配（例如，一个分析可能移动及其响应的游戏程序）。我们可以编写这样的程序，通过调用*free()*来释放所有分配的内存。然而，在某些情况下，使用我们在此描述的技术会更简单，这使得我们可以回溯，并让调用者（父进程）保持原始内存占用不变。
- en: In the implementation shown in [Example 24-3](ch24.html#calling_a_function_without_changing_the
    "Example 24-3. Calling a function without changing the process’s memory footprint"),
    the result of *func()* must be expressed in the 8 bits that *exit()* passes from
    the terminating child to the parent calling *wait()*. However, we could employ
    a file, a pipe, or some other interprocess communication technique to allow *func()*
    to return larger results.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 24-3](ch24.html#calling_a_function_without_changing_the_process’s_memory_footprint
    "示例 24-3. 不改变进程内存占用的情况下调用函数")中的实现中，*func()*的结果必须以*exit()*从终止的子进程传递给调用*wait()*的父进程的8位数据形式表达。然而，我们可以使用文件、管道或其他进程间通信技术来允许*func()*返回更大的结果。
- en: Example 24-3. Calling a function without changing the process’s memory footprint
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 24-3. 不改变进程内存占用的情况下调用函数
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The *vfork()* System Call
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*vfork()*系统调用'
- en: Early BSD implementations were among those in which *fork()* performed a literal
    duplication of the parent’s data, heap, and stack. As noted earlier, this is wasteful,
    especially if the *fork()* is followed by an immediate *exec()*. For this reason,
    later versions of BSD introduced the *vfork()* system call, which was far more
    efficient than BSD’s *fork()*, although it operated with slightly different (in
    fact, somewhat strange) semantics. Modern UNIX implementations employing copy-on-write
    for implementing *fork()* are much more efficient than older *fork()* implementations,
    thus largely eliminating the need for *vfork()*. Nevertheless, Linux (like many
    other UNIX implementations) provides a *vfork()* system call with BSD semantics
    for programs that require the fastest possible fork. However, because the unusual
    semantics of *vfork()* can lead to some subtle program bugs, its use should normally
    be avoided, except in the rare cases where it provides worthwhile performance
    gains.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的BSD实现中，*fork()*会执行父进程数据、堆和栈的字面复制。如前所述，这种方式是浪费的，尤其是在*fork()*后立即跟着*exec()*调用的情况下。因此，后来的BSD版本引入了*vfork()*系统调用，它比BSD的*fork()*更高效，尽管其操作语义稍微不同（实际上，有些奇怪）。现代UNIX实现通过复制写入（copy-on-write）方式来实现*fork()*，比旧版*fork()*实现更高效，从而基本消除了对*vfork()*的需求。然而，Linux（与许多其他UNIX实现一样）为需要最快可能的fork的程序提供了具有BSD语义的*vfork()*系统调用。然而，由于*vfork()*的非传统语义可能导致一些微妙的程序错误，因此通常应避免使用它，除非在少数情况下它提供了值得的性能提升。
- en: Like *fork()*, *vfork()* is used by the calling process to create a new child
    process. However, *vfork()* is expressly designed to be used in programs where
    the child performs an immediate *exec()* call.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 和*fork()*一样，*vfork()*也用于调用进程创建一个新的子进程。然而，*vfork()*专门设计用于子进程立即执行*exec()*调用的程序中。
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In parent: returns process ID of child on success, or -1 on error; in successfully
    created child: always returns 0'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在父进程中：成功时返回子进程的进程ID，出错时返回-1；在成功创建的子进程中：始终返回0
- en: 'Two features distinguish the *vfork()* system call from *fork()* and make it
    more efficient:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个特点使得*vfork()*系统调用与*fork()*不同，并且使得它更高效：
- en: No duplication of virtual memory pages or page tables is done for the child
    process. Instead, the child shares the parent’s memory until it either performs
    a successful *exec()* or calls *_exit()* to terminate.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于子进程，不会进行虚拟内存页面或页面表的复制。相反，子进程共享父进程的内存，直到它执行成功的*exec()*或调用*_exit()*来终止。
- en: Execution of the parent process is suspended until the child has performed an
    *exec()* or *_exit()*.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父进程的执行将被挂起，直到子进程执行*exec()*或*_exit()*。
- en: 'These points have some important implications. Since the child is using the
    parent’s memory, any changes made by the child to the data, heap, or stack segments
    will be visible to the parent once it resumes. Furthermore, if the child performs
    a function return between the *vfork()* and a later *exec()* or *_exit()*, this
    will also affect the parent. This is similar to the example described in [Performing
    a Nonlocal Goto: *setjmp()* and *long jmp()*](ch06.html#performing_a_nonlocal_goto_colon_setjmp
    "Performing a Nonlocal Goto: setjmp() and long jmp()") of trying to *longjmp()*
    into a function from which a return has already been performed. Similar chaos—typically
    a segmentation fault (`SIGSEGV`)—is likely to result.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要点有一些重要的含义。由于子进程使用的是父进程的内存，任何子进程对数据、堆或栈段的修改在子进程恢复执行时都能被父进程看到。此外，如果子进程在*vfork()*与后续的*exec()*或*_exit()*之间执行函数返回，这也会影响父进程。这类似于在[执行非局部跳转：*setjmp()*与*longjmp()*](ch06.html#performing_a_nonlocal_goto_colon_setjmp
    "执行非局部跳转：setjmp()与longjmp()")中描述的示例，尝试从一个已经执行过返回的函数中进行*longjmp()*。类似的混乱——通常是段错误（`SIGSEGV`）——很可能会发生。
- en: There are a few things that the child process can do between *vfork()* and *exec()*
    without affecting the parent. Among these are operations on open file descriptors
    (but not *stdio* file streams). Since the file descriptor table for each process
    is maintained in kernel space ([Relationship Between File Descriptors and Open
    Files](ch05.html#relationship_between_file_descriptors_an "Relationship Between
    File Descriptors and Open Files")) and is duplicated during *vfork()*, the child
    process can perform file descriptor operations without affecting the parent.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程可以在*vfork()*与*exec()*之间执行一些操作，而不会影响父进程。这些操作包括对打开文件描述符的操作（但不包括*stdio*文件流）。由于每个进程的文件描述符表保存在内核空间中（[文件描述符与打开文件之间的关系](ch05.html#relationship_between_file_descriptors_an
    "文件描述符与打开文件之间的关系")），并且在*vfork()*时会被复制，子进程可以执行文件描述符操作而不影响父进程。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'SUSv3 says that the behavior of a program is undefined if it: a) modifies any
    data other than a variable of type *pid_t* used to store the return value of *vfork()*;
    b) returns from the function in which *vfork()* was called; or c) calls any other
    function before successfully calling *_exit()* or performing an *exec()*.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3规定，如果程序：a) 修改除存储*vfork()*返回值的*pid_t*类型变量以外的任何数据；b) 从调用*vfork()*的函数中返回；或c)
    在成功调用*_exit()*或执行*exec()*之前调用任何其他函数，程序的行为是未定义的。
- en: When we look at the *clone()* system call in [The *clone()* System Call](ch28.html#the_clone_open_parenthesis_close_parenth
    "The clone() System Call"), we’ll see that a child created using *fork()* or *vfork()*
    also obtains its own copies of a few other process attributes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看[clone()系统调用](ch28.html#the_clone_open_parenthesis_close_parenth "clone()系统调用")时，我们会发现使用*fork()*或*vfork()*创建的子进程也会获得自己的一些其他进程属性的副本。
- en: 'The semantics of *vfork()* mean that after the call, the child is guaranteed
    to be scheduled for the CPU before the parent. In [Creating a New Process: *fork()*](ch24.html#creating_a_new_process_colon_fork_open_p
    "Creating a New Process: fork()"), we noted that this is not a guarantee made
    by *fork()*, after which either the parent or the child may be scheduled first.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*vfork()*的语义意味着，在调用之后，子进程会在父进程之前被调度到CPU上。在[创建新进程：*fork()*](ch24.html#creating_a_new_process_colon_fork_open_p
    "创建新进程：fork()")中，我们注意到这是*fork()*所不保证的，调用后父进程或子进程都可能先被调度。'
- en: '[Example 24-4](ch24.html#using_vfork_open_parenthesis_close_paren "Example 24-4. Using
    vfork()") shows the use of *vfork()*, demonstrating both of the semantic features
    that distinguish it from *fork()*: the child shares the parent’s memory, and the
    parent is suspended until the child terminates or calls *exec()*. When we run
    this program, we see the following output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例24-4](ch24.html#using_vfork_open_parenthesis_close_paren "示例24-4. 使用vfork()")展示了*vfork()*的使用，展示了它与*fork()*的两个语义特征：子进程共享父进程的内存，且父进程在子进程终止或调用*exec()*之前会被挂起。当我们运行此程序时，看到以下输出：'
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From the last line of output, we can see that the change made by the child to
    the variable *istack* was performed on the parent’s variable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从最后一行输出中，我们可以看到子进程对变量*istack*所做的修改实际上是作用于父进程的变量。
- en: Example 24-4. Using *vfork()*
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 示例24-4. 使用*vfork()*
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Except where speed is absolutely critical, new programs should avoid the use
    of *vfork()* in favor of *fork()*. This is because, when *fork()* is implemented
    using copy-on-write semantics (as is done on most modern UNIX implementations),
    it approaches the speed of *vfork()*, and we avoid the eccentric behaviors associated
    with *vfork()* described above. (We show some speed comparisons between *fork()*
    and *vfork()* in Section 28.3.)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除非速度至关重要，否则新程序应避免使用*vfork()*，而应使用*fork()*。这是因为，当*fork()*使用写时复制语义（大多数现代UNIX实现中采用的方式）时，它的速度接近于*vfork()*，同时避免了上述与*vfork()*相关的怪异行为。（我们在第28.3节中展示了*fork()*和*vfork()*之间的一些速度对比。）
- en: SUSv3 marks *vfork()* as obsolete, and SUSv4 goes further, removing the specification
    of *vfork()*. SUSv3 leaves many details of the operation of *vfork()* unspecified,
    allowing the possibility that it is implemented as a call to *fork()*. When implemented
    in this manner, the BSD semantics for *vfork()* are not preserved. Some UNIX systems
    do indeed implement *vfork()* as a call to *fork()*, and Linux also did this in
    kernel 2.0 and earlier.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3将*vfork()*标记为废弃，SUSv4进一步删除了*vfork()*的规范。SUSv3没有明确规定*vfork()*的许多操作细节，允许其作为对*fork()*的调用来实现。当以这种方式实现时，*vfork()*的BSD语义不再保留。一些UNIX系统确实将*vfork()*实现为对*fork()*的调用，Linux在2.0及之前的内核版本中也这样做过。
- en: Where it is used, *vfork()* should generally be immediately followed by a call
    to *exec()*. If the *exec()* call fails, the child process should terminate using
    *_exit()*. (The child of a *vfork()* should not terminate by calling *exit()*,
    since that would cause the parent’s *stdio* buffers to be flushed and closed.
    We go into more detail on this point in Section 25.4.)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用*vfork()*的地方，通常应紧接着调用*exec()*。如果*exec()*调用失败，子进程应通过调用*_exit()*来终止。（*vfork()*的子进程不应通过调用*exit()*来终止，因为这会导致父进程的*stdio*缓冲区被刷新并关闭。我们将在第25.4节对此问题进行详细讨论。）
- en: Other uses of *vfork()*—in particular, those relying on its unusual semantics
    for memory sharing and process scheduling—are likely to render a program nonportable,
    especially to implementations where *vfork()* is implemented simply as a call
    to *fork()*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 其他使用*vfork()*的情况——尤其是那些依赖于其独特语义来共享内存和调度进程的情况——可能会使程序变得不可移植，特别是在那些将*vfork()*仅仅作为对*fork()*的调用来实现的系统上。
- en: Race Conditions After *fork()*
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*fork()*之后的竞争条件'
- en: After a *fork()*, it is indeterminate which process—the parent or the child—next
    has access to the CPU. (On a multiprocessor system, they may both simultaneously
    get access to a CPU.) Applications that implicitly or explicitly rely on a particular
    sequence of execution in order to achieve correct results are open to failure
    due to *race conditions*, which we described in Section 5.1\. Such bugs can be
    hard to find, as their occurrence depends on scheduling decisions that the kernel
    makes according to system load.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在一次*fork()*之后，不确定是父进程还是子进程首先访问CPU。（在多处理器系统中，它们可能会同时获得CPU的访问权。）依赖于特定执行顺序以确保正确结果的应用程序，可能会因为*竞争条件*而失败，我们在第5.1节中描述了这一点。这类bug可能难以发现，因为它们的发生取决于内核根据系统负载做出的调度决策。
- en: 'We can use the program in [Example 24-5](ch24.html#parent_and_child_race_to_write_a_message
    "Example 24-5. Parent and child race to write a message after fork()") to demonstrate
    this indeterminacy. This program loops, using *fork()* to create multiple children.
    After each *fork()*, both parent and child print a message containing the loop
    counter value and a string indicating whether the process is the parent or child.
    For example, if we asked the program to produce just one child, we might see the
    following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用[示例 24-5](ch24.html#parent_and_child_race_to_write_a_message "示例 24-5.
    父进程和子进程在fork()之后争夺写消息的机会")中的程序来演示这种不确定性。该程序通过循环，使用*fork()*来创建多个子进程。每次调用*fork()*后，父进程和子进程都会打印一条消息，消息中包含循环计数器的值，并且会标明该进程是父进程还是子进程。例如，如果我们要求程序只创建一个子进程，我们可能会看到如下结果：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can use this program to create a large number of children, and then analyze
    the output to see whether the parent or the child is the first to print its message
    each time. Analyzing the results when using this program to create 1 million children
    on a Linux/x86-32 2.2.19 system showed that the parent printed its message first
    in all but 332 cases (i.e., in 99.97% of the cases).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用该程序创建大量子进程，然后分析输出，看看每次哪个进程首先打印其消息。在使用该程序在Linux/x86-32 2.2.19系统上创建100万个子进程时的分析结果显示，父进程在除332个案例之外的所有情况中首先打印消息（即在99.97%的情况下）。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The results from running the program in [Example 24-5](ch24.html#parent_and_child_race_to_write_a_message
    "Example 24-5. Parent and child race to write a message after fork()") were analyzed
    using the script `procexec/fork_whos_on_first.count.awk`, which is provided in
    the source code distribution for this book.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 24-5](ch24.html#parent_and_child_race_to_write_a_message "示例 24-5. 父子进程在
    fork() 后竞争写入消息") 中运行该程序的结果，使用了脚本 `procexec/fork_whos_on_first.count.awk` 进行分析，该脚本包含在本书的源代码分发中。
- en: From these results, we may surmise that, on Linux 2.2.19, execution always continues
    with the parent process after a *fork()*. The reason that the child occasionally
    printed its message first was that, in 0.03% of cases, the parent’s CPU time slice
    ran out before it had time to print its message. In other words, if this example
    represented a case where we were relying on the parent to always be scheduled
    first after *fork()*, then things would usually go right, but one time out of
    every 3000, things would go wrong. Of course, if the application expected that
    the parent should be able to carry out a larger piece of work before the child
    was scheduled, the possibility of things going wrong would be greater. Trying
    to debug such errors in a complex program can be difficult.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些结果来看，我们可以推测，在 Linux 2.2.19 上，执行在调用 *fork()* 后总是继续由父进程进行。子进程偶尔先打印消息的原因是，在
    0.03% 的情况下，父进程的 CPU 时间片耗尽，来不及打印它的消息。换句话说，如果这个例子假设我们依赖父进程总是在 *fork()* 后首先被调度，那么大多数情况下会按预期运行，但每
    3000 次中，可能会有一次出现问题。当然，如果应用程序期望父进程在子进程被调度之前能够完成更多的工作，那么出现问题的可能性会更大。调试这种复杂程序中的错误可能非常困难。
- en: Example 24-5. Parent and child race to write a message after *fork()*
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 24-5. 父子进程在 *fork()* 后竞争写入消息
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Although Linux 2.2.19 always continues execution with the parent after a *fork()*,
    we can’t rely on this being the case on other UNIX implementations, or even across
    different versions of the Linux kernel. During the 2.4 stable kernel series, experiments
    were briefly made with a “child first after *fork()*” patch, which completely
    reverses the results obtained from 2.2.19\. Although this change was later dropped
    from the 2.4 kernel series, it was subsequently adopted in Linux 2.6\. Thus, programs
    that assume the 2.2.19 behavior would be broken by the 2.6 kernel.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 Linux 2.2.19 中总是由父进程继续执行 *fork()* 后的操作，但我们不能依赖其他 UNIX 实现，甚至是不同版本的 Linux
    内核也会是这种情况。在 2.4 稳定内核系列期间，曾对“子进程先于 *fork()* 后执行”的补丁做过短暂的实验，这完全颠覆了 2.2.19 所得到的结果。虽然这个变化后来被从
    2.4 内核系列中删除，但随后在 Linux 2.6 中得到了采纳。因此，假设 2.2.19 行为的程序会在 2.6 内核中无法运行。
- en: Some more recent experiments reversed the kernel developers’ assessment of whether
    it was better to run the child or the parent first after *fork()*, and, since
    Linux 2.6.32, it is once more the parent that is, by default, run first after
    a *fork()*. This default can be changed by assigning a nonzero value to the Linux-specific
    /`proc/sys/kernel/sched_child_runs_first` file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一些较新的实验推翻了内核开发者对于 *fork()* 后该先运行子进程还是父进程的评估，从 Linux 2.6.32 开始，默认情况下，父进程会在 *fork()*
    后首先运行。这个默认设置可以通过为 Linux 特定的 `/`proc/sys/kernel/sched_child_runs_first` 文件分配一个非零值来进行更改。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To see the argument for the “children first after *fork()*” behavior, consider
    what happens with copy-on-write semantics when the child of a *fork()* performs
    an immediate *exec()*. In this case, as the parent carries on after the *fork()*
    to modify data and stack pages, the kernel duplicates the to-be-modified pages
    for the child. Since the child performs an *exec()* as soon as it is scheduled
    to run, this duplication is wasted. According to this argument, it is better to
    schedule the child first, so that by the time the parent is next scheduled, no
    page copying is required. Using the program in [Example 24-5](ch24.html#parent_and_child_race_to_write_a_message
    "Example 24-5. Parent and child race to write a message after fork()") to create
    1 million child processes on one busy Linux/x86-32 system running kernel 2.6.30
    showed that, in 99.98% of cases, the child process displayed its message first.
    (The precise percentage depends on factors such as system load.) Testing this
    program on other UNIX implementations showed wide variation in the rules that
    govern which process runs first after *fork()*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看清“子进程先于*fork()*后执行”的理由，考虑当*fork()*的子进程立即执行*exec()*时，复制写语义会发生什么情况。在这种情况下，由于父进程在*fork()*之后继续修改数据和栈页面，内核会为子进程复制将要修改的页面。由于子进程一旦被调度就执行*exec()*，这种复制是浪费的。根据这个论点，最好先调度子进程，这样等父进程下次调度时，就不需要进行页面复制了。在[示例
    24-5](ch24.html#parent_and_child_race_to_write_a_message "示例 24-5. 父子进程在*fork()*后争先写消息")中，使用该程序在一个运行着2.6.30版本内核的忙碌Linux/x86-32系统上创建了100万个子进程，结果显示在99.98%的情况下，子进程首先显示了消息。（具体百分比依赖于如系统负载等因素。）在其他UNIX实现上测试此程序时，显示出父进程和子进程在*fork()*后哪个先运行的规则差异较大。
- en: The argument for switching back to “parent first after *fork()*” in Linux 2.6.32
    was based on the observation that, after a *fork()*, the parent’s state is already
    active in the CPU and its memory-management information is already cached in the
    hardware memory management unit’s translation look-aside buffer (TLB). Therefore,
    running the parent first should result in better performance. This was informally
    verified by measuring the time required for kernel builds under the two behaviors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux 2.6.32中，回到“父进程先于*fork()*后执行”的论点是基于以下观察：在*fork()*之后，父进程的状态已经在CPU中处于活动状态，其内存管理信息已经被缓存到硬件内存管理单元的翻译旁路缓冲区（TLB）中。因此，先调度父进程应该能带来更好的性能。通过测量在两种行为下构建内核所需的时间，这一观点得到了非正式的验证。
- en: In conclusion, it is worth noting that the performance differences between the
    two behaviors are rather small, and won’t affect most applications.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，值得注意的是，两种行为之间的性能差异非常小，并不会影响大多数应用程序。
- en: From the preceding discussion, it is clear that we can’t assume a particular
    order of execution for the parent and child after a *fork()*. If we need to guarantee
    a particular order, we must use some kind of synchronization technique. We describe
    several synchronization techniques in later chapters, including semaphores, file
    locks, and sending messages between processes using pipes. One other method, which
    we describe next, is to use signals.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的讨论中可以看出，我们不能假设父进程和子进程在*fork()*之后有特定的执行顺序。如果我们需要保证特定的顺序，就必须使用某种同步技术。我们将在后续章节中描述几种同步技术，包括信号量、文件锁和使用管道在进程之间发送消息。还有一种方法，我们接下来会描述，就是使用信号。
- en: Avoiding Race Conditions by Synchronizing with Signals
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过信号同步避免竞态条件
- en: After a *fork()*, if either process needs to wait for the other to complete
    an action, then the active process can send a signal after completing the action;
    the other process waits for the signal.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在*fork()*之后，如果任一进程需要等待另一个进程完成某个操作，则活动进程可以在完成操作后发送信号；另一个进程则等待该信号。
- en: '[Example 24-6](ch24.html#using_signals_to_synchronize_process_act "Example 24-6. Using
    signals to synchronize process actions") demonstrates this technique. In this
    program, we assume that it is the parent that must wait on the child to carry
    out some action. The signal-related calls in the parent and child can be swapped
    if the child must wait on the parent. It is even possible for both parent and
    child to signal each other multiple times in order to coordinate their actions,
    although, in practice, such coordination is more likely to be done using semaphores,
    file locks, or message passing.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 24-6](ch24.html#using_signals_to_synchronize_process_act "示例 24-6. 使用信号同步进程操作")
    演示了这种技术。在此程序中，我们假设父进程必须等待子进程执行某些操作。如果子进程必须等待父进程，则父进程和子进程中的信号相关调用可以互换。实际上，父子进程之间可能会多次相互发送信号，以协调它们的操作，尽管通常这种协调更多是通过信号量、文件锁或消息传递来实现。'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '[Stevens & Rago, 2005] suggests encapsulating such synchronization steps (block
    signal, send signal, catch signal) into a standard set of functions for process
    synchronization. The advantage of such encapsulation is that we can then later
    replace the use of signals by another IPC mechanism, if desired.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[Stevens & Rago, 2005] 建议将此类同步步骤（屏蔽信号、发送信号、接收信号）封装为一套标准的进程同步函数。封装的好处是，如果需要，我们以后可以将信号的使用替换为其他
    IPC 机制。'
- en: Note that we block the synchronization signal `(SIGUSR1)` before the *fork()*
    call in [Example 24-6](ch24.html#using_signals_to_synchronize_process_act "Example 24-6. Using
    signals to synchronize process actions"). If the parent tried blocking the signal
    after the *fork()*, it would remain vulnerable to the very race condition we are
    trying to avoid. (In this program, we assume that the state of the signal mask
    in the child is irrelevant; if necessary, we can unblock `SIGUSR1` in the child
    after the *fork()*.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 [示例 24-6](ch24.html#using_signals_to_synchronize_process_act "示例 24-6.
    使用信号同步进程操作") 中，我们在 *fork()* 调用之前屏蔽了同步信号 `(SIGUSR1)`。如果父进程在 *fork()* 之后尝试屏蔽信号，那么它将仍然容易受到我们试图避免的竞态条件的影响。（在此程序中，我们假设子进程中的信号屏蔽状态无关紧要；如有必要，我们可以在
    *fork()* 后在子进程中解除屏蔽 `SIGUSR1`。）
- en: 'The following shell session log shows what happens when we run the program
    in [Example 24-6](ch24.html#using_signals_to_synchronize_process_act "Example 24-6. Using
    signals to synchronize process actions"):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 shell 会话日志显示了当我们运行 [示例 24-6](ch24.html#using_signals_to_synchronize_process_act
    "示例 24-6. 使用信号同步进程操作") 中的程序时发生了什么：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Example 24-6. Using signals to synchronize process actions
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 24-6. 使用信号同步进程操作
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The *fork()* system call creates a new process (the child) by making an almost
    exact duplicate of the calling process (the parent). The *vfork()* system call
    is a more efficient version of *fork()*, but is usually best avoided because of
    its unusual semantics, whereby the child uses the parent’s memory until it either
    performs an *exec()* or terminates; in the meantime, execution of the parent process
    is suspended.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*fork()* 系统调用通过几乎完全复制调用进程（父进程）来创建一个新进程（子进程）。*vfork()* 系统调用是 *fork()* 的一种更高效的版本，但通常最好避免使用，因为它具有不寻常的语义，其中子进程在执行
    *exec()* 或终止之前，会使用父进程的内存；在此期间，父进程的执行会被挂起。'
- en: After a *fork()* call, we can’t rely on the order in which the parent and the
    child are next scheduled to use the CPU(s). Programs that make assumptions about
    the order of execution are susceptible to errors known as race conditions. Because
    the occurrence of such errors depends on external factors such as system load,
    they can be difficult to find and debug.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *fork()* 调用之后，我们无法依赖父进程和子进程被调度到 CPU 的顺序。假设执行顺序的程序容易出现所谓的竞态条件错误。由于这些错误的发生依赖于诸如系统负载等外部因素，因此它们通常难以发现和调试。
- en: Further information
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步信息
- en: '[Bach, 1986] and [Goodheart & Cox, 1994] provide details of the implementation
    of *fork()*, *execve()*, *wait()*, and *exit()* on UNIX systems. [Bovet & Cesati,
    2005] and [Love, 2010] provide Linux-specific implementation details of process
    creation and termination.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[Bach, 1986] 和 [Goodheart & Cox, 1994] 提供了 *fork()*、*execve()*、*wait()* 和 *exit()*
    在 UNIX 系统中的实现细节。[Bovet & Cesati, 2005] 和 [Love, 2010] 提供了 Linux 特定的进程创建和终止实现细节。'
- en: Exercises
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: After a program executes the following series of *fork()* calls, how many new
    processes will result (assuming that none of the calls fails)?
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序执行以下一系列 *fork()* 调用后，将会产生多少个新进程（假设这些调用没有失败）？
- en: '[PRE14]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Write a program to demonstrate that after a *vfork()*, the child process can
    close a file descriptor (e.g., descriptor 0) without affecting the corresponding
    file descriptor in the parent.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序演示在执行*vfork()*后，子进程可以关闭一个文件描述符（例如描述符 0），而不影响父进程中的相应文件描述符。
- en: Assuming that we can modify the program source code, how could we get a core
    dump of a process at a given moment in time, while letting the process continue
    execution?
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们可以修改程序源代码，我们如何在给定的时刻获取一个进程的核心转储，同时让进程继续执行？
- en: Experiment with the program in [Example 24-5](ch24.html#parent_and_child_race_to_write_a_message
    "Example 24-5. Parent and child race to write a message after fork()") (`fork_whos_on_first.c`)
    on other UNIX implementations to determine how these implementations schedule
    the parent and child processes after a *fork()*.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其他UNIX实现上实验[示例 24-5](ch24.html#parent_and_child_race_to_write_a_message "示例
    24-5. 父进程和子进程在fork()后竞争写入消息")（`fork_whos_on_first.c`）程序，确定这些实现如何调度父进程和子进程的执行。
- en: Suppose that in the program in [Example 24-6](ch24.html#using_signals_to_synchronize_process_act
    "Example 24-6. Using signals to synchronize process actions"), the child process
    also needed to wait on the parent to complete some actions. What changes to the
    program would be required in order to enforce this?
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设在[示例 24-6](ch24.html#using_signals_to_synchronize_process_act "示例 24-6. 使用信号同步进程操作")中的程序里，子进程也需要等待父进程完成一些操作。为了强制执行这一点，程序需要做哪些修改？
