- en: Chapter 24. Process Creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this and the next three chapters, we look at how a process is created and
    terminates, and how a process can execute a new program. This chapter covers process
    creation. However, before diving into that subject, we present a short overview
    of the main system calls covered in these four chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of *fork()*, *exit()*, *wait()*, and *execve()*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The principal topics of this and the next few chapters are the system calls
    *fork()*, *exit()*, *wait()*, and *execve()*. Each of these system calls has variants,
    which we’ll also look at. For now, we provide an overview of these four system
    calls and how they are typically used together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *fork()* system call allows one process, the parent, to create a new process,
    the child. This is done by making the new child process an (almost) exact duplicate
    of the parent: the child obtains copies of the parent’s stack, data, heap, and
    text segments ([Memory Layout of a Process](ch06.html#memory_layout_of_a_process
    "Memory Layout of a Process")). The term *fork* derives from the fact that we
    can envisage the parent process as dividing to yield two copies of itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *exit(status)* library function terminates a process, making all resources
    (memory, open file descriptors, and so on) used by the process available for subsequent
    reallocation by the kernel. The *status* argument is an integer that determines
    the termination status for the process. Using the *wait()* system call, the parent
    can retrieve this status.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *exit()* library function is layered on top of the *_exit()* system call.
    In [Chapter 25](ch25.html "Chapter 25. Process Termination"), we explain the difference
    between the two interfaces. In the meantime, we’ll just note that, after a *fork()*,
    generally only one of the parent and child terminate by calling *exit()*; the
    other process should terminate using *_exit()*.
  prefs: []
  type: TYPE_NORMAL
- en: The *wait(&status)* system call has two purposes. First, if a child of this
    process has not yet terminated by calling *exit()*, then *wait()* suspends execution
    of the process until one of its children has terminated. Second, the termination
    status of the child is returned in the status argument of *wait()*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *execve(pathname, argv, envp)* system call loads a new program (*pathname*,
    with argument list *argv*, and environment list *envp*) into a process’s memory.
    The existing program text is discarded, and the stack, data, and heap segments
    are freshly created for the new program. This operation is often referred to as
    *execing* a new program. Later, we’ll see that several library functions are layered
    on top of *execve()*, each of which provides a useful variation in the programming
    interface. Where we don’t care about these interface variations, we follow the
    common convention of referring to these calls generically as *exec()*, but be
    aware that there is no system call or library function with this name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some other operating systems combine the functionality of *fork()* and *exec()*
    into a single operation—a so-called *spawn*—that creates a new process that then
    executes a specified program. By comparison, the UNIX approach is usually simpler
    and more elegant. Separating these two steps makes the APIs simpler (the *fork()*
    system call takes *no* arguments) and allows a program a great degree of flexibility
    in the actions it performs between the two steps. Moreover, it is often useful
    to perform a *fork()* without a following *exec()*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SUSv3 specifies the optional *posix_spawn()* function, which combines the effect
    of *fork()* and *exec()*. This function, and several related APIs specified by
    SUSv3, are implemented on Linux in *glibc*. SUSv3 specifies *posix_spawn()* to
    permit portable applications to be written for hardware architectures that don’t
    provide swap facilities or memory-management units (this is typical of many embedded
    systems). On such architectures, a traditional *fork()* is difficult or impossible
    to implement.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 24-1](ch24.html#overview_of_the_use_of_fork_open_parenth "Figure 24-1. Overview
    of the use of fork(), exit(), wait(), and execve()") provides an overview of how
    *fork()*, *exit()*, *wait()*, and *execve()* are commonly used together. (This
    diagram outlines the steps taken by the shell in executing a command: the shell
    continuously executes a loop that reads a command, performs various processing
    on it, and then forks a child process to exec the command.)'
  prefs: []
  type: TYPE_NORMAL
- en: The use of *execve()* shown in this diagram is optional. Sometimes, it is instead
    useful to have the child carry on executing the same program as the parent. In
    either case, the execution of the child is ultimately terminated by a call to
    *exit()* (or by delivery of a signal), yielding a termination status that the
    parent can obtain via *wait()*.
  prefs: []
  type: TYPE_NORMAL
- en: The call to *wait()* is likewise optional. The parent can simply ignore its
    child and continue executing. However, we’ll see later that the use of *wait()*
    is usually desirable, and is often employed within a handler for the `SIGCHLD`
    signal, which the kernel generates for a parent process when one of its children
    terminates. (By default, `SIGCHLD` is ignored, which is why we label it as being
    optionally delivered in the diagram.)
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of the use of fork(), exit(), wait(), and execve()](figs/web/24-1_PROCEXEC-overview-scale90.png.jpg)Figure 24-1. Overview
    of the use of *fork()*, *exit()*, *wait()*, and *execve()*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a New Process: *fork()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many applications, creating multiple processes can be a useful way of dividing
    up a task. For example, a network server process may listen for incoming client
    requests and create a new child process to handle each request; meanwhile, the
    server process continues to listen for further client connections. Dividing tasks
    up in this way often makes application design simpler. It also permits greater
    concurrency (i.e., more tasks or requests can be handled simultaneously).
  prefs: []
  type: TYPE_NORMAL
- en: The *fork()* system call creates a new process, the *child*, which is an almost
    exact duplicate of the calling process, the *parent*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In parent: returns process ID of child on success, or -1 on error; in successfully
    created child: always returns 0'
  prefs: []
  type: TYPE_NORMAL
- en: The key point to understanding *fork()* is to realize that after it has completed
    its work, two processes exist, and, in each process, execution continues from
    the point where *fork()* returns.
  prefs: []
  type: TYPE_NORMAL
- en: The two processes are executing the same program text, but they have separate
    copies of the stack, data, and heap segments. The child’s stack, data, and heap
    segments are initially exact duplicates of the corresponding parts the parent’s
    memory. After the *fork()*, each process can modify the variables in its stack,
    data, and heap segments without affecting the other process.
  prefs: []
  type: TYPE_NORMAL
- en: Within the code of a program, we can distinguish the two processes via the value
    returned from *fork()*. For the parent, *fork()* returns the process ID of the
    newly created child. This is useful because the parent may create, and thus need
    to track, several children (via *wait()* or one of its relatives). For the child,
    *fork()* returns 0\. If necessary, the child can obtain its own process ID using
    *getpid()*, and the process ID of its parent using *getppid()*.
  prefs: []
  type: TYPE_NORMAL
- en: If a new process can’t be created, *fork()* returns -1. Possible reasons for
    failure are that the resource limit (`RLIMIT_NPROC`, described in [Details of
    Specific Resource Limits](ch36.html#details_of_specific_resource_limits "Details
    of Specific Resource Limits")) on the number of processes permitted to this (real)
    user ID has been exceeded or that the system-wide limit on the number of processes
    that can be created has been reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following idiom is sometimes employed when calling *fork()*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is important to realize that after a *fork()*, it is indeterminate which
    of the two processes is next scheduled to use the CPU. In poorly written programs,
    this indeterminacy can lead to errors known as race conditions, which we describe
    further in Section 24.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 24-1](ch24.html#using_fork_open_parenthesis_close_parent "Example 24-1. Using
    fork()") demonstrates the use of *fork()*. This program creates a child that modifies
    the copies of global and automatic variables that it inherits during the during
    the *fork()*.'
  prefs: []
  type: TYPE_NORMAL
- en: The use of *sleep()* (in the code executed by the parent) in this program permits
    the child to be scheduled for the CPU before the parent, so that the child can
    complete its work and terminate before the parent continues execution. Using *sleep()*
    in this manner is not a foolproof method of guaranteeing this result; we look
    at a better method in Section 24.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the program in [Example 24-1](ch24.html#using_fork_open_parenthesis_close_parent
    "Example 24-1. Using fork()"), we see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The above output demonstrates that the child process gets its own copy of the
    stack and data segments at the time of the *fork()*, and it is able to modify
    variables in these segments without affecting the parent.
  prefs: []
  type: TYPE_NORMAL
- en: Example 24-1. Using *fork()*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: File Sharing Between Parent and Child
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a *fork()* is performed, the child receives duplicates of all of the parent’s
    file descriptors. These duplicates are made in the manner of *dup()*, which means
    that corresponding descriptors in the parent and the child refer to the same open
    file description. As we saw in [Relationship Between File Descriptors and Open
    Files](ch05.html#relationship_between_file_descriptors_an "Relationship Between
    File Descriptors and Open Files"), the open file description contains the current
    file offset (as modified by *read()*, *write()*, and *lseek()*) and the open file
    status flags (set by *open()* and changed by the *fcntl()* `F_SETFL` operation).
    Consequently, these attributes of an open file are shared between the parent and
    child. For example, if the child updates the file offset, this change is visible
    through the corresponding descriptor in the parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that these attributes are shared by the parent and child after a *fork()*
    is demonstrated by the program in [Example 24-2](ch24.html#sharing_of_file_offset_and_open_file_sta
    "Example 24-2. Sharing of file offset and open file status flags between parent
    and child"). This program opens a temporary file using *mkstemp()*, and then calls
    *fork()* to create a child process. The child changes the file offset and open
    file status flags of the temporary file, and exits. The parent then retrieves
    the file offset and flags to verify that it can see the changes made by the child.
    When we run the program, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For an explanation of why we cast the return value from *lseek()* to *long long*
    in [Example 24-2](ch24.html#sharing_of_file_offset_and_open_file_sta "Example 24-2. Sharing
    of file offset and open file status flags between parent and child"), see [I/O
    on Large Files](ch05.html#i_solidus_o_on_large_files "I/O on Large Files").
  prefs: []
  type: TYPE_NORMAL
- en: Example 24-2. Sharing of file offset and open file status flags between parent
    and child
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Sharing of open file attributes between the parent and child processes is frequently
    useful. For example, if the parent and child are both writing to a file, sharing
    the file offset ensures that the two processes don’t overwrite each other’s output.
    It does not, however, prevent the output of the two processes from being randomly
    intermingled. If this is not desired, then some form of process synchronization
    is required. For example, the parent can use the *wait()* system call to pause
    until the child has exited. This is what the shell does, so that it prints its
    prompt only after the child process executing a command has terminated (unless
    the user explicitly runs the command in the background by placing an ampersand
    character at the end of the command).
  prefs: []
  type: TYPE_NORMAL
- en: If sharing of file descriptors in this manner is not required, then an application
    should be designed so that, after a *fork()*, the parent and child use different
    file descriptors, with each process closing unused descriptors (i.e., those used
    by the other process) immediately after forking. (If one of the processes performs
    an *exec()*, the close-on-exec flag described in [File Descriptors and *exec()*](ch27.html#file_descriptors_and_exec_open_parenthes
    "File Descriptors and exec()") can also be useful.) These steps are shown in [Figure 24-2](ch24.html#duplication_of_file_descriptors_during_f
    "Figure 24-2. Duplication of file descriptors during fork(), and closing of unused
    descriptors").
  prefs: []
  type: TYPE_NORMAL
- en: '![Duplication of file descriptors during fork(), and closing of unused descriptors](figs/web/24-2_PROCEXEC-fork-descriptors.png.jpg)Figure 24-2. Duplication
    of file descriptors during *fork()*, and closing of unused descriptors'
  prefs: []
  type: TYPE_NORMAL
- en: Memory Semantics of *fork()*
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conceptually, we can consider *fork()* as creating copies of the parent’s text,
    data, heap, and stack segments. (Indeed, in some early UNIX implementations, such
    duplication was literally performed: a new process image was created by copying
    the parent’s memory to swap space, and making that swapped-out image the child
    process while the parent kept its own memory.) However, actually performing a
    simple copy of the parent’s virtual memory pages into the new child process would
    be wasteful for a number of reasons—one being that a *fork()* is often followed
    by an immediate *exec()*, which replaces the process’s text with a new program
    and reinitializes the process’s data, heap, and stack segments. Most modern UNIX
    implementations, including Linux, use two techniques to avoid such wasteful copying:'
  prefs: []
  type: TYPE_NORMAL
- en: The kernel marks the text segment of each process as read-only, so that a process
    can’t modify its own code. This means that the parent and child can share the
    same text segment. The *fork()* system call creates a text segment for the child
    by building a set of per-process page-table entries that refer to the same virtual
    memory page frames already used by the parent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the pages in the data, heap, and stack segments of the parent process, the
    kernel employs a technique known as *copy-on-write*. (The implementation of copy-on-write
    is described in [Bach, 1986] and [Bovet & Cesati, 2005].) Initially, the kernel
    sets things up so that the page-table entries for these segments refer to the
    same physical memory pages as the corresponding page-table entries in the parent,
    and the pages themselves are marked read-only. After the *fork()*, the kernel
    traps any attempts by either the parent or the child to modify one of these pages,
    and makes a duplicate copy of the about-to-be-modified page. This new page copy
    is assigned to the faulting process, and the corresponding page-table entry for
    the child is adjusted appropriately. From this point on, the parent and child
    can each modify their private copies of the page, without the changes being visible
    to the other process. [Figure 24-3](ch24.html#page_tables_before_and_after_modificatio
    "Figure 24-3. Page tables before and after modification of a shared copy-on-write
    page") illustrates the copy-on-write technique.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Page tables before and after modification of a shared copy-on-write page](figs/web/24-3_PROCEXEC-fork-cow.png.jpg)Figure 24-3. Page
    tables before and after modification of a shared copy-on-write page'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling a process’s memory footprint
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can combine the use of *fork()* and *wait()* to control the memory footprint
    of a process. The process’s memory footprint is the range of virtual memory pages
    used by the process, as affected by factors such as the adjustment of the stack
    as functions are called and return, calls to *exec()*, and, of particular interest
    to this discussion, modification of the heap as a consequence of calls to *malloc()*
    and *free()*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we bracket a call to some function, *func()*, using *fork()* and
    *wait()* in the manner shown in [Example 24-3](ch24.html#calling_a_function_without_changing_the
    "Example 24-3. Calling a function without changing the process’s memory footprint").
    After executing this code, we know that the memory footprint of the parent is
    unchanged from the point before *func()* was called, since all possible changes
    will have occurred in the child process. This can be useful for the following
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: If we know that *func()* causes memory leaks or excessive fragmentation of the
    heap, this technique eliminates the problem. (We might not otherwise be able to
    deal with these problems if we don’t have access to the source code of *func()*.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose that we have some algorithm that performs memory allocation while doing
    a tree analysis (for example, a game program that analyzes a range of possible
    moves and their responses). We could code such a program to make calls to *free()*
    to deallocate all of the allocated memory. However, in some cases, it is simpler
    to employ the technique we describe here in order to allow us to backtrack, leaving
    the caller (the parent) with its original memory footprint unchanged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the implementation shown in [Example 24-3](ch24.html#calling_a_function_without_changing_the
    "Example 24-3. Calling a function without changing the process’s memory footprint"),
    the result of *func()* must be expressed in the 8 bits that *exit()* passes from
    the terminating child to the parent calling *wait()*. However, we could employ
    a file, a pipe, or some other interprocess communication technique to allow *func()*
    to return larger results.
  prefs: []
  type: TYPE_NORMAL
- en: Example 24-3. Calling a function without changing the process’s memory footprint
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The *vfork()* System Call
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Early BSD implementations were among those in which *fork()* performed a literal
    duplication of the parent’s data, heap, and stack. As noted earlier, this is wasteful,
    especially if the *fork()* is followed by an immediate *exec()*. For this reason,
    later versions of BSD introduced the *vfork()* system call, which was far more
    efficient than BSD’s *fork()*, although it operated with slightly different (in
    fact, somewhat strange) semantics. Modern UNIX implementations employing copy-on-write
    for implementing *fork()* are much more efficient than older *fork()* implementations,
    thus largely eliminating the need for *vfork()*. Nevertheless, Linux (like many
    other UNIX implementations) provides a *vfork()* system call with BSD semantics
    for programs that require the fastest possible fork. However, because the unusual
    semantics of *vfork()* can lead to some subtle program bugs, its use should normally
    be avoided, except in the rare cases where it provides worthwhile performance
    gains.
  prefs: []
  type: TYPE_NORMAL
- en: Like *fork()*, *vfork()* is used by the calling process to create a new child
    process. However, *vfork()* is expressly designed to be used in programs where
    the child performs an immediate *exec()* call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In parent: returns process ID of child on success, or -1 on error; in successfully
    created child: always returns 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two features distinguish the *vfork()* system call from *fork()* and make it
    more efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: No duplication of virtual memory pages or page tables is done for the child
    process. Instead, the child shares the parent’s memory until it either performs
    a successful *exec()* or calls *_exit()* to terminate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution of the parent process is suspended until the child has performed an
    *exec()* or *_exit()*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These points have some important implications. Since the child is using the
    parent’s memory, any changes made by the child to the data, heap, or stack segments
    will be visible to the parent once it resumes. Furthermore, if the child performs
    a function return between the *vfork()* and a later *exec()* or *_exit()*, this
    will also affect the parent. This is similar to the example described in [Performing
    a Nonlocal Goto: *setjmp()* and *long jmp()*](ch06.html#performing_a_nonlocal_goto_colon_setjmp
    "Performing a Nonlocal Goto: setjmp() and long jmp()") of trying to *longjmp()*
    into a function from which a return has already been performed. Similar chaos—typically
    a segmentation fault (`SIGSEGV`)—is likely to result.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few things that the child process can do between *vfork()* and *exec()*
    without affecting the parent. Among these are operations on open file descriptors
    (but not *stdio* file streams). Since the file descriptor table for each process
    is maintained in kernel space ([Relationship Between File Descriptors and Open
    Files](ch05.html#relationship_between_file_descriptors_an "Relationship Between
    File Descriptors and Open Files")) and is duplicated during *vfork()*, the child
    process can perform file descriptor operations without affecting the parent.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SUSv3 says that the behavior of a program is undefined if it: a) modifies any
    data other than a variable of type *pid_t* used to store the return value of *vfork()*;
    b) returns from the function in which *vfork()* was called; or c) calls any other
    function before successfully calling *_exit()* or performing an *exec()*.'
  prefs: []
  type: TYPE_NORMAL
- en: When we look at the *clone()* system call in [The *clone()* System Call](ch28.html#the_clone_open_parenthesis_close_parenth
    "The clone() System Call"), we’ll see that a child created using *fork()* or *vfork()*
    also obtains its own copies of a few other process attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The semantics of *vfork()* mean that after the call, the child is guaranteed
    to be scheduled for the CPU before the parent. In [Creating a New Process: *fork()*](ch24.html#creating_a_new_process_colon_fork_open_p
    "Creating a New Process: fork()"), we noted that this is not a guarantee made
    by *fork()*, after which either the parent or the child may be scheduled first.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 24-4](ch24.html#using_vfork_open_parenthesis_close_paren "Example 24-4. Using
    vfork()") shows the use of *vfork()*, demonstrating both of the semantic features
    that distinguish it from *fork()*: the child shares the parent’s memory, and the
    parent is suspended until the child terminates or calls *exec()*. When we run
    this program, we see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: From the last line of output, we can see that the change made by the child to
    the variable *istack* was performed on the parent’s variable.
  prefs: []
  type: TYPE_NORMAL
- en: Example 24-4. Using *vfork()*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Except where speed is absolutely critical, new programs should avoid the use
    of *vfork()* in favor of *fork()*. This is because, when *fork()* is implemented
    using copy-on-write semantics (as is done on most modern UNIX implementations),
    it approaches the speed of *vfork()*, and we avoid the eccentric behaviors associated
    with *vfork()* described above. (We show some speed comparisons between *fork()*
    and *vfork()* in Section 28.3.)
  prefs: []
  type: TYPE_NORMAL
- en: SUSv3 marks *vfork()* as obsolete, and SUSv4 goes further, removing the specification
    of *vfork()*. SUSv3 leaves many details of the operation of *vfork()* unspecified,
    allowing the possibility that it is implemented as a call to *fork()*. When implemented
    in this manner, the BSD semantics for *vfork()* are not preserved. Some UNIX systems
    do indeed implement *vfork()* as a call to *fork()*, and Linux also did this in
    kernel 2.0 and earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Where it is used, *vfork()* should generally be immediately followed by a call
    to *exec()*. If the *exec()* call fails, the child process should terminate using
    *_exit()*. (The child of a *vfork()* should not terminate by calling *exit()*,
    since that would cause the parent’s *stdio* buffers to be flushed and closed.
    We go into more detail on this point in Section 25.4.)
  prefs: []
  type: TYPE_NORMAL
- en: Other uses of *vfork()*—in particular, those relying on its unusual semantics
    for memory sharing and process scheduling—are likely to render a program nonportable,
    especially to implementations where *vfork()* is implemented simply as a call
    to *fork()*.
  prefs: []
  type: TYPE_NORMAL
- en: Race Conditions After *fork()*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After a *fork()*, it is indeterminate which process—the parent or the child—next
    has access to the CPU. (On a multiprocessor system, they may both simultaneously
    get access to a CPU.) Applications that implicitly or explicitly rely on a particular
    sequence of execution in order to achieve correct results are open to failure
    due to *race conditions*, which we described in Section 5.1\. Such bugs can be
    hard to find, as their occurrence depends on scheduling decisions that the kernel
    makes according to system load.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the program in [Example 24-5](ch24.html#parent_and_child_race_to_write_a_message
    "Example 24-5. Parent and child race to write a message after fork()") to demonstrate
    this indeterminacy. This program loops, using *fork()* to create multiple children.
    After each *fork()*, both parent and child print a message containing the loop
    counter value and a string indicating whether the process is the parent or child.
    For example, if we asked the program to produce just one child, we might see the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can use this program to create a large number of children, and then analyze
    the output to see whether the parent or the child is the first to print its message
    each time. Analyzing the results when using this program to create 1 million children
    on a Linux/x86-32 2.2.19 system showed that the parent printed its message first
    in all but 332 cases (i.e., in 99.97% of the cases).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The results from running the program in [Example 24-5](ch24.html#parent_and_child_race_to_write_a_message
    "Example 24-5. Parent and child race to write a message after fork()") were analyzed
    using the script `procexec/fork_whos_on_first.count.awk`, which is provided in
    the source code distribution for this book.
  prefs: []
  type: TYPE_NORMAL
- en: From these results, we may surmise that, on Linux 2.2.19, execution always continues
    with the parent process after a *fork()*. The reason that the child occasionally
    printed its message first was that, in 0.03% of cases, the parent’s CPU time slice
    ran out before it had time to print its message. In other words, if this example
    represented a case where we were relying on the parent to always be scheduled
    first after *fork()*, then things would usually go right, but one time out of
    every 3000, things would go wrong. Of course, if the application expected that
    the parent should be able to carry out a larger piece of work before the child
    was scheduled, the possibility of things going wrong would be greater. Trying
    to debug such errors in a complex program can be difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Example 24-5. Parent and child race to write a message after *fork()*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Although Linux 2.2.19 always continues execution with the parent after a *fork()*,
    we can’t rely on this being the case on other UNIX implementations, or even across
    different versions of the Linux kernel. During the 2.4 stable kernel series, experiments
    were briefly made with a “child first after *fork()*” patch, which completely
    reverses the results obtained from 2.2.19\. Although this change was later dropped
    from the 2.4 kernel series, it was subsequently adopted in Linux 2.6\. Thus, programs
    that assume the 2.2.19 behavior would be broken by the 2.6 kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Some more recent experiments reversed the kernel developers’ assessment of whether
    it was better to run the child or the parent first after *fork()*, and, since
    Linux 2.6.32, it is once more the parent that is, by default, run first after
    a *fork()*. This default can be changed by assigning a nonzero value to the Linux-specific
    /`proc/sys/kernel/sched_child_runs_first` file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see the argument for the “children first after *fork()*” behavior, consider
    what happens with copy-on-write semantics when the child of a *fork()* performs
    an immediate *exec()*. In this case, as the parent carries on after the *fork()*
    to modify data and stack pages, the kernel duplicates the to-be-modified pages
    for the child. Since the child performs an *exec()* as soon as it is scheduled
    to run, this duplication is wasted. According to this argument, it is better to
    schedule the child first, so that by the time the parent is next scheduled, no
    page copying is required. Using the program in [Example 24-5](ch24.html#parent_and_child_race_to_write_a_message
    "Example 24-5. Parent and child race to write a message after fork()") to create
    1 million child processes on one busy Linux/x86-32 system running kernel 2.6.30
    showed that, in 99.98% of cases, the child process displayed its message first.
    (The precise percentage depends on factors such as system load.) Testing this
    program on other UNIX implementations showed wide variation in the rules that
    govern which process runs first after *fork()*.
  prefs: []
  type: TYPE_NORMAL
- en: The argument for switching back to “parent first after *fork()*” in Linux 2.6.32
    was based on the observation that, after a *fork()*, the parent’s state is already
    active in the CPU and its memory-management information is already cached in the
    hardware memory management unit’s translation look-aside buffer (TLB). Therefore,
    running the parent first should result in better performance. This was informally
    verified by measuring the time required for kernel builds under the two behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, it is worth noting that the performance differences between the
    two behaviors are rather small, and won’t affect most applications.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding discussion, it is clear that we can’t assume a particular
    order of execution for the parent and child after a *fork()*. If we need to guarantee
    a particular order, we must use some kind of synchronization technique. We describe
    several synchronization techniques in later chapters, including semaphores, file
    locks, and sending messages between processes using pipes. One other method, which
    we describe next, is to use signals.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Race Conditions by Synchronizing with Signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After a *fork()*, if either process needs to wait for the other to complete
    an action, then the active process can send a signal after completing the action;
    the other process waits for the signal.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 24-6](ch24.html#using_signals_to_synchronize_process_act "Example 24-6. Using
    signals to synchronize process actions") demonstrates this technique. In this
    program, we assume that it is the parent that must wait on the child to carry
    out some action. The signal-related calls in the parent and child can be swapped
    if the child must wait on the parent. It is even possible for both parent and
    child to signal each other multiple times in order to coordinate their actions,
    although, in practice, such coordination is more likely to be done using semaphores,
    file locks, or message passing.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Stevens & Rago, 2005] suggests encapsulating such synchronization steps (block
    signal, send signal, catch signal) into a standard set of functions for process
    synchronization. The advantage of such encapsulation is that we can then later
    replace the use of signals by another IPC mechanism, if desired.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we block the synchronization signal `(SIGUSR1)` before the *fork()*
    call in [Example 24-6](ch24.html#using_signals_to_synchronize_process_act "Example 24-6. Using
    signals to synchronize process actions"). If the parent tried blocking the signal
    after the *fork()*, it would remain vulnerable to the very race condition we are
    trying to avoid. (In this program, we assume that the state of the signal mask
    in the child is irrelevant; if necessary, we can unblock `SIGUSR1` in the child
    after the *fork()*.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shell session log shows what happens when we run the program
    in [Example 24-6](ch24.html#using_signals_to_synchronize_process_act "Example 24-6. Using
    signals to synchronize process actions"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Example 24-6. Using signals to synchronize process actions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *fork()* system call creates a new process (the child) by making an almost
    exact duplicate of the calling process (the parent). The *vfork()* system call
    is a more efficient version of *fork()*, but is usually best avoided because of
    its unusual semantics, whereby the child uses the parent’s memory until it either
    performs an *exec()* or terminates; in the meantime, execution of the parent process
    is suspended.
  prefs: []
  type: TYPE_NORMAL
- en: After a *fork()* call, we can’t rely on the order in which the parent and the
    child are next scheduled to use the CPU(s). Programs that make assumptions about
    the order of execution are susceptible to errors known as race conditions. Because
    the occurrence of such errors depends on external factors such as system load,
    they can be difficult to find and debug.
  prefs: []
  type: TYPE_NORMAL
- en: Further information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Bach, 1986] and [Goodheart & Cox, 1994] provide details of the implementation
    of *fork()*, *execve()*, *wait()*, and *exit()* on UNIX systems. [Bovet & Cesati,
    2005] and [Love, 2010] provide Linux-specific implementation details of process
    creation and termination.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After a program executes the following series of *fork()* calls, how many new
    processes will result (assuming that none of the calls fails)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write a program to demonstrate that after a *vfork()*, the child process can
    close a file descriptor (e.g., descriptor 0) without affecting the corresponding
    file descriptor in the parent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming that we can modify the program source code, how could we get a core
    dump of a process at a given moment in time, while letting the process continue
    execution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Experiment with the program in [Example 24-5](ch24.html#parent_and_child_race_to_write_a_message
    "Example 24-5. Parent and child race to write a message after fork()") (`fork_whos_on_first.c`)
    on other UNIX implementations to determine how these implementations schedule
    the parent and child processes after a *fork()*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Suppose that in the program in [Example 24-6](ch24.html#using_signals_to_synchronize_process_act
    "Example 24-6. Using signals to synchronize process actions"), the child process
    also needed to wait on the parent to complete some actions. What changes to the
    program would be required in order to enforce this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
