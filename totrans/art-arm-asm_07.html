<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch5">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_227" aria-label="227"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch5">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">5</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">PROCEDURES</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="378" height="378"/>&#13;
</figure>&#13;
<p class="ChapterIntro">In a procedural programming language, the basic unit of code is the procedure. A <i>procedure</i> is a set of instructions that compute a value or take an action, such as printing or reading a character value. This chapter discusses how Gas implements procedures, parameters, and local variables. By the end of this chapter, you should be well versed in writing your own procedures and functions. You’ll also fully understand parameter passing and the ARM application binary interface (ABI) calling convention.</p>&#13;
<p class="TX">This chapter covers several topics, including the following:</p>&#13;
<ul class="ul">&#13;
<li class="BL">An introduction to assembly language programming style, along with some <i>aoaa.inc</i> macros to improve the readability of your programs</li>&#13;
<li class="BL"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_228" aria-label="228"/>Gas procedures/functions and their implementation (including the use of the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">br</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instructions), along with more <i>aoaa.inc</i> macros to allow the better declaration of procedures in your source files</li>&#13;
<li class="BL">Activation records, automatic variables, local symbols, register preservation, and the ARM stack</li>&#13;
<li class="BL">Various ways to pass parameters to a procedure, including pass by value and pass by reference, and how to use procedure pointers and procedural parameters</li>&#13;
</ul>&#13;
<p class="TX">This chapter also discusses how to return function results to a caller and how to call and use recursive functions.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-65"/><span class="SANS_Futura_Std_Bold_B_11">5.1 Assembly Language Programming Style</span></h3>&#13;
<p class="TNI1">Up until this chapter, I’ve not stressed good assembly language programming style for two reasons. First, this book assumes you’re already familiar with the need for good programming style based on your experience with HLLs. Second, the programs quoted up to this point have been relatively trivial, and programming style doesn’t matter much with trivial code. However, as you begin to write more advanced ARM assembly language programs, style becomes more important.</p>&#13;
<p class="TX">As you can probably tell by now, ARM assembly language code is nowhere near as readable as code written in an HLL such as C/C++, Java, or Swift. Therefore, as an assembly language programmer, you must expend extra effort to write assembly code that is as readable and maintainable as possible. As I’ve pointed out, the GNU assembler was written not as a tool for assembly language programmers but as a backend to the GCC compiler to process the compiler’s output. Because of this and the fact that Gas attempted to absorb as many features as possible from a huge number of assembly languages (for many CPUs, not just the ARM), writing high-quality code with Gas is a difficult task.</p>&#13;
<p class="TX">Fortunately, you can use Gas’s macro processor (and ability to take advantage of the CPP) to modify the Gas assembly language somewhat, accessing features that can help improve your programming style. The <i>aoaa.inc</i> include file contains a fair number of predefined macros and symbol definitions to help achieve this goal. <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span> covers the contents of <i>aoaa.inc</i> line by line and explains how you can use these macros, and create macros of your own, to improve the readability of your ARM assembly language programs.</p>&#13;
<p class="TX">When you write assembly language source files, feel free to include <i>aoaa.inc</i> in that code or incorporate any features from that code in your assembly language source files. Even if you don’t require the cross-platform portability offered by <i>aoaa.inc</i>, its macros and other definitions can help you write more readable and maintainable code. The <i>aoaa.inc</i> header file is open source and covered by the Creative Commons 4.0 Attribution license (see section 5.12, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="chapter5.xhtml#pg_290">page 290</a></span>).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_229" aria-label="229"/>As an example of using macros to make code more readable, consider the <span class="SANS_TheSansMonoCd_W5Regular_11">.code</span> macro from <i>aoaa.inc</i>. It expands into the following two statements:</p>&#13;
<pre id="pre-344"><code>.text &#13;
.align 2 </code></pre>&#13;
<p class="TX">As a general rule, you should always ensure that the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section is aligned on a word boundary (code could get misaligned if you’ve declared some data in the previous code section whose length is not a multiple of 4). It’s good programming style to always align a <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section; just to be sure an instruction begins at a proper address. Rather than clutter up your code with a bunch of extra <span class="SANS_TheSansMonoCd_W5Regular_11">.align</span> directives, I recommend using the <span class="SANS_TheSansMonoCd_W5Regular_11">.code</span> directive to automatically handle the alignment. Having less clutter makes your code easier to read.</p>&#13;
<p class="TX">The <i>aoaa.inc</i> header file contains several additional macros I will present throughout the rest of this chapter that take the 1960s-style Gas syntax and attempt to provide features found in more modern assemblers (such as the Microsoft Macro Assembler, or MASM, and the HLA assemblers available for the x86 processor family). Using these features (such as formal procedure declarations and local variable declarations) can help produce easier-to-read assembly language source code.</p>&#13;
<p class="TX">Even when writing traditional assembly language source code, you can follow certain rules to produce more readable code. Throughout this book, I’ve generally organized assembly language statements as follows (braces surround optional items and don’t appear in the actual source code):</p>&#13;
<pre id="pre-345"><code>{<var>Label</var>:}   {{<var>instruction</var>}     <var>operands</var>}  {// <var>Comment</var>}</code></pre>&#13;
<p class="TX">As a general rule, I try to put all label definitions in column 1 and to line up all the instruction mnemonics in column 2. I try to start the operands in column 3. The exact number of spaces between these columns is not important, but be sure that the mnemonics are generally lined up together, in one column, and that the operands tend to start in the next column. This is the traditional assembly language programming style and the format that most assembly language programmers will want to see when reading your code.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>For formatting reasons, this book often compresses the amount of space between the columns and sometimes varies the position of each column within the same listing. This was done to ensure source lines fit on one line within the book. In a normal source file, you should try to keep all the columns aligned (two 4-character tab positions for column 2, column 3 around character position 16, and so on).</i></p>&#13;
<p class="TX">In general, don’t try to indent statements as you would blocks in an HLL. Assembly language is not a block-structured language and does not lend itself to the same indentation techniques that work well for block-structured languages. If you need to set apart a sequence of statements, the best approach is to insert two or more blank lines before and after that <span role="doc-pagebreak" epub:type="pagebreak" id="pg_230" aria-label="230"/>sequence of statements. Comments are also useful for differentiating two separate, loosely coupled blocks of code.</p>&#13;
<p class="TX">Gas usually expects an entire assembly language instruction to reside on a single line of source code. In theory, you could use the backslash character immediately before a newline character to break a single statement across two lines:</p>&#13;
<pre id="pre-346"><code>b.al   \&#13;
  targetLabel </code></pre>&#13;
<p class="Continued1">However, there’s almost never a good argument for doing this. Keep your instructions on a single line unless you have a really good reason to split them across multiple lines (for example, if the source line becomes inordinately long for some reason, which is rare). The label field is an exception to this rule: labels may appear on a line by themselves even if they are associated with the next machine instruction in the program.</p>&#13;
<p class="TX">Gas (under Linux) allows putting multiple assembly language instructions on the same line, separated by a semicolon. However, putting multiple statements on the same source line is an even worse idea in assembly language than it is in HLLs—don’t do it. In any case, the macOS assembler does not support this feature.</p>&#13;
<p class="TX">With a few assembly language style guidelines out of the way, it’s time to consider the main topic of this chapter: procedures (functions) in assembly language.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-66"/><span class="SANS_Futura_Std_Bold_B_11">5.2 Gas Procedures</span></h3>&#13;
<p class="TNI1">Most procedural programming languages implement procedures by using the call/return mechanism. The code calls a procedure, the procedure performs whatever actions it was written to do, and then the procedure returns to the caller. The call and return operations provide the ARM’s <i>procedure invocation mechanism</i>. The calling code calls a procedure with the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> instruction, and the procedure returns to the caller with the <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction. For example, the following ARM instruction calls the C stdlib library <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> function:</p>&#13;
<pre id="pre-347"><code>bl printf </code></pre>&#13;
<p class="TX">Alas, the C stdlib does not supply all the routines you’ll need. Most of the time, you’ll have to write your own Gas procedures. A basic Gas procedure declaration takes the following form:</p>&#13;
<pre id="pre-348"><code><var>procName</var>: &#13;
<var>    Procedure statements</var> &#13;
    ret </code></pre>&#13;
<p class="TX">Technically, the procedure does not need to end with a <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction; the <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> could be somewhere in the middle of the procedure, with a <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_231" aria-label="231"/>instruction at the end. However, it’s considered good programming style to use a <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction (or an equivalent) as the last instruction of a procedure’s body.</p>&#13;
<p class="TX">Procedure declarations appear in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section of your program. In the preceding syntax example, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">procName</span> represents the name of the procedure you wish to define. This can be any valid (and unique) Gas identifier.</p>&#13;
<p class="TX">Here is a concrete example of a Gas procedure declaration. This procedure stores 0s into the 256 words at which X0 points upon entry into the procedure:</p>&#13;
<pre id="pre-349"><code>zeroBytes: &#13;
          mov  x1, #256*4     // 1,024 bytes = 256 words &#13;
repeatlp: subs x1, x1, #4 &#13;
          str  wzr, [x0, x1]  // Store *after* subtraction! &#13;
          bne  repeatlp       // Repeat while X1 &gt;= 0. &#13;
          ret </code></pre>&#13;
<p class="TX">As you’ve probably noticed, this simple procedure doesn’t bother with the “magic” instructions that add and subtract a value to and from the SP register. Those instructions are a requirement of the ARM ABI when the procedure will be calling other C/C++ code (or other code written in an ARM ABI–compliant language). Because this little function doesn’t call any other procedures, it doesn’t bother executing such code.</p>&#13;
<p class="TX">Also note that this code uses the loop index to count down from 1,024 down to 0 by 4, filling in the 256-word array backward (from end to beginning) rather than filling it in from beginning to end. This is a common technique in assembly language. Finally, this code decrements X1 by 4 before storing the 0 into memory. This is because the loop index (X1) is initialized just beyond the end of the array pointed at by X0. The <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> instruction does not affect the flags, so the <span class="SANS_TheSansMonoCd_W5Regular_11">bne</span> instruction responds to the flags set by the <span class="SANS_TheSansMonoCd_W5Regular_11">subs</span> instruction.</p>&#13;
<p class="TX">You can use the ARM <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> instruction to call this procedure. When, during program execution, the code falls into the <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction, the procedure returns to whoever called it and begins executing the first instruction beyond <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span>. Listing 5-1 provides an example of a call to the <span class="SANS_TheSansMonoCd_W5Regular_11">zeroBytes</span> routine.</p>&#13;
<pre id="pre-350"><code>// Listing5-1.S &#13;
//&#13;
// Simple procedure call example &#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
stackSpace  =       64 &#13;
saveLR      =       56 &#13;
&#13;
            .section .rodata, ""&#13;
ttlStr:     .asciz   "Listing 5-1"&#13;
&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_232" aria-label="232"/>            .data &#13;
wArray:     .space   256 * (4), 0xff // Fill with 0xFF. &#13;
&#13;
&#13;
            .text &#13;
            .align   2 &#13;
&#13;
// getTitle &#13;
//&#13;
// Return program title to C++ program: &#13;
&#13;
            .global getTitle &#13;
getTitle: &#13;
            lea     x0, ttlStr &#13;
            ret &#13;
&#13;
// zeroBytes &#13;
//&#13;
// Here is the user-written procedure &#13;
// that zeros out a 256-word buffer. &#13;
// On entry, X0 contains the address &#13;
// of the buffer. &#13;
&#13;
zeroBytes: &#13;
            mov     x1, #256 * 4 &#13;
repeatlp:   subs    x1, x1, #4 &#13;
            str     wzr, [x0, x1] // Store *after* subtraction! &#13;
            bne     repeatlp      // Repeat while X1 != 0. &#13;
            ret &#13;
&#13;
// Here is the asmMain function: &#13;
&#13;
            .global asmMain &#13;
asmMain: &#13;
            sub     sp, sp, #stackSpace // Reserve stack storage. &#13;
            str     lr, [sp, #saveLR] &#13;
&#13;
            lea     x0, wArray &#13;
            bl      zeroBytes &#13;
&#13;
            ldr     lr, [sp, #saveLR]   // Restore return address. &#13;
            add     sp, sp, #stackSpace // Clean up stack. &#13;
            ret     // Returns to caller </code></pre>&#13;
<p class="Continued1">I won’t bother with a build or run command, as this program doesn’t produce any real output beyond saying that it ran and terminated.</p>&#13;
<p class="TX">The Gas language doesn’t really have a syntactical concept of a program component we think of as a procedure (or function). It has labels you can call with the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> instruction, along with the <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction, which you can use to return from a procedure. However, it has no syntactical entity you can use to delineate one procedure from another in your assembly language source file.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_233" aria-label="233"/>So far, the few procedures in this book have delineated the code in the procedure by using a label and a return statement. For example, the following procedure begins with <span class="SANS_TheSansMonoCd_W5Regular_11">zeroBytes</span> and ends with <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span>:</p>&#13;
<pre id="pre-351"><code>zeroBytes: &#13;
          mov  x1, #256 * 4 &#13;
repeatlp: subs x1, x1, #4 &#13;
          str  wzr, [x0, x1] // Store *after* subtraction! &#13;
          bge  repeatlp      // Repeat while X1 &gt;= 0. &#13;
          ret </code></pre>&#13;
<p class="TX">A comment immediately before the procedure might help separate it from previous code. However, the person reading the code has to work to differentiate the <span class="SANS_TheSansMonoCd_W5Regular_11">zeroBytes</span> label from the <span class="SANS_TheSansMonoCd_W5Regular_11">repeatlp</span> label. In fact, there’s no reason you couldn’t use both labels as entry points for a procedure (<span class="SANS_TheSansMonoCd_W5Regular_11">zeroBytes</span> would always zero out 256 words starting at the address passed in X0, and <span class="SANS_TheSansMonoCd_W5Regular_11">repeatlp</span> would zero out the number of words specified in X1/4). Of course, a procedure isn’t required to use just a single <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction (or any at all, since there are other ways to return from a procedure). The last instruction of a procedure also doesn’t have to be a <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span>. Therefore, relying on a statement label and a <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction to delineate the procedure is not always appropriate.</p>&#13;
<p class="TX">Though it’s always a good idea to put comments at the beginning and end of your Gas procedures to clarify what’s happening, the best way to solve this problem would be to use <i>syntactical sugar</i>—statements that clarify meaning without generating any code—to delineate procedures. Although Gas does not provide such statements, you can write your own macros for the same purpose. The <i>aoaa.inc</i> include file provides a couple of these macros: <span class="SANS_TheSansMonoCd_W5Regular_11">proc</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">endp</span>. Here is their syntax:</p>&#13;
<pre id="pre-352"><code>proc <var>procedureName</var> {, public}  // Braces denote optional item. &#13;
&#13;
     <var>Body of the procedure</var> &#13;
&#13;
endp <var>procedureName</var> </code></pre>&#13;
<p class="Continued1">Here, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">procedureName</span> will be the name of the procedure, and you must supply the same name in the <span class="SANS_TheSansMonoCd_W5Regular_11">proc</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">endp</span> statements. The <span class="SANS_TheSansMonoCd_W5Regular_11">, public</span> argument is optional, as denoted by the meta-symbol braces. If the <span class="SANS_TheSansMonoCd_W5Regular_11">public</span> argument is present, the <span class="SANS_TheSansMonoCd_W5Regular_11">proc</span> macro will automatically generate a <span class="SANS_TheSansMonoCd_W5Regular_11">.global</span> directive for the procedure.</p>&#13;
<p class="TX">Here’s a very simple example of using the <span class="SANS_TheSansMonoCd_W5Regular_11">proc</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">endp</span> macros with the <span class="SANS_TheSansMonoCd_W5Regular_11">getTitle</span> function:</p>&#13;
<pre id="pre-353"><code>proc    getTitle, public &#13;
lea     x0, ttlStr &#13;
ret &#13;
endp    getTitle </code></pre>&#13;
<p class="Continued1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_234" aria-label="234"/>These macros generate the usual statements for the <span class="SANS_TheSansMonoCd_W5Regular_11">getTitle</span> procedure:</p>&#13;
<pre id="pre-354"><code>             .global     getTitle  // Generated by public &#13;
getTitle:    // Generated by proc &#13;
             lea         x0, ttlStr &#13;
             ret </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">endp</span> macro doesn’t generate anything in the program. It simply checks the identifier passed as an argument to ensure that it matches the procedure’s name in the <span class="SANS_TheSansMonoCd_W5Regular_11">proc</span> macro invocation.</p>&#13;
<p class="TX">Because the <span class="SANS_TheSansMonoCd_W5Regular_11">proc</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">endp</span> statements neatly isolate a procedure’s body from other code in the program, this book uses them for procedures from this point forward. I suggest you take advantage of these macros to help make your own future procedures more readable too.</p>&#13;
<p class="TX">Procedures and functions in an HLL provide useful features in the form of local symbols. The next section covers the limited form of local labels supported by Gas.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-91"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">5.2.1 Gas Local Labels</span></h4>&#13;
<p class="TNI1">Unlike HLLs, Gas does not support <i>lexically scoped symbols</i>. Labels you define in a procedure are not limited in scope to that procedure. Except for one special case, symbols you define in a Gas procedure, including those defined with <span class="SANS_TheSansMonoCd_W5Regular_11">proc</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">endp</span>, are visible throughout the source file.</p>&#13;
<p class="TX">However, Gas does support a limited form of <i>local labels</i>, which consist of a single numeric digit followed by a colon (<span class="SANS_TheSansMonoCd_W5Regular_11">0:</span> through <span class="SANS_TheSansMonoCd_W5Regular_11">9:</span>). In your code, refer to these symbols by using <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">N</span><span class="SANS_TheSansMonoCd_W5Regular_11">b</span> or <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">N</span><span class="SANS_TheSansMonoCd_W5Regular_11">f</span>, where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">N</span> is the digit (<span class="SANS_TheSansMonoCd_W5Regular_11">0</span> through <span class="SANS_TheSansMonoCd_W5Regular_11">9</span>). A symbol of the form <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">N</span><span class="SANS_TheSansMonoCd_W5Regular_11">b</span> references the previous <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">N</span><span class="SANS_TheSansMonoCd_W5Regular_11">:</span> label in the source file (<span class="SANS_TheSansMonoCd_W5Regular_11">b</span> is for <i>backward</i>). A symbol of the form <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">N</span><span class="SANS_TheSansMonoCd_W5Regular_11">f</span> references the next <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">N</span><span class="SANS_TheSansMonoCd_W5Regular_11">:</span> symbol in the source file (<span class="SANS_TheSansMonoCd_W5Regular_11">f</span> is for <i>forward</i>).</p>&#13;
<p class="TX">Here’s an example of a Gas local label in the <span class="SANS_TheSansMonoCd_W5Regular_11">zeroBytes</span> procedure (rewritten from the previous section):</p>&#13;
<pre id="pre-355"><code>          proc zeroBytes &#13;
          mov  x1, #256 * 4 &#13;
0:        subs x1, x1, #4 &#13;
          str  wzr, [x0, x1] // Store *after* subtraction! &#13;
          bne  0b            // Repeat while X1 != 0. &#13;
          ret &#13;
          endp zeroBytes </code></pre>&#13;
<p class="TX">Local labels are useful when there is no compelling reason to use a more meaningful name. Be careful about using these local symbols, though. When used sparingly, they help reduce the distraction of meaningless labels in your program, but using too many will destroy the readability of your programs (“to which <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> label is this code jumping?”).</p>&#13;
<p class="TX">When you use local labels, your target label should be only a few instructions away; if the code jumps any great distance, you run the risk of inserting that same local label between the source and targets when <span role="doc-pagebreak" epub:type="pagebreak" id="pg_235" aria-label="235"/>enhancing your code later. This would produce undesirable consequences, and Gas won’t notify you of the error.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-92"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">5.2.2 bl, ret, and br</span></h4>&#13;
<p class="TNI1">Once you can declare a procedure, the next problem is how to call (and return from) a procedure. As you’ve seen many times throughout this book, you call procedures by using <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> and return from those procedures by using <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span>. This section covers those instructions (as well as the <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> instruction) in more detail, including the effects of their use.</p>&#13;
<p class="TX">The ARM <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> instruction does two things: it copies the (64-bit) address of the instruction immediately following the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> to the LR register, and then it transfers control to the address of the specified procedure. The value that <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> copies to LR is known as the <i>return address</i>.</p>&#13;
<p class="TX">When a procedure wants to return to the caller and continue execution with the first statement following the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> instruction, that procedure commonly returns to its caller by executing a <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction. The <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction transfers control indirectly to that address held in the LR register (X30).</p>&#13;
<p class="TX">The ARM <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction takes two forms</p>&#13;
<pre id="pre-356"><code>ret&#13;
ret <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">64</span></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">64</span> is one of the ARM’s thirty-two 64-bit registers. If a 64-bit register operand appears, the CPU uses the address held in that register as the return address; if no register is present, the default is X30 (LR).</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction is actually a special case of the <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> (branch indirect through register) instruction. The <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> syntax is</p>&#13;
<pre id="pre-357"><code>br  <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">64</span></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">64</span> is one of the ARM’s thirty-two 64-bit registers. This instruction also transfers control to the address held in the specified register. Whereas the <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">64</span> instruction provides a hint to the CPU that this is an actual return-from-subroutine, the <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">64</span> instruction offers no such hint. In some circumstances, the ARM can execute the code faster if it’s given the hint. <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span> covers some uses for the <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> instruction.</p>&#13;
<p class="TX">The following is an example of the <span class="SANS_TheSansMonoCd_W5Regular_11">minimal</span> Gas procedure:</p>&#13;
<pre id="pre-358"><code>proc minimal&#13;
ret&#13;
endp minimal</code></pre>&#13;
<p class="TX">If you call this procedure with the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> instruction, <span class="SANS_TheSansMonoCd_W5Regular_11">minimal</span> will simply return to the caller. If you fail to put the <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction in the procedure, the program will not return to the caller upon encountering the <span class="SANS_TheSansMonoCd_W5Regular_11">endp</span> statement. Instead, the program will fall through to whatever code happens to follow the procedure in memory.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_236" aria-label="236"/>Listing 5-2 demonstrates this problem. The main program calls <span class="SANS_TheSansMonoCd_W5Regular_11">noRet</span>, which falls straight through to <span class="SANS_TheSansMonoCd_W5Regular_11">followingProc</span> (printing the <span class="SANS_TheSansMonoCd_W5Regular_11">followingProc was called</span> message).</p>&#13;
<pre id="pre-359"><code>// Listing5-2.S&#13;
//&#13;
// A procedure without a ret instruction&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
stackSpace  =           64&#13;
saveLR      =           56&#13;
&#13;
            .section    .rodata, ""&#13;
ttlStr:     .asciz      "Listing 5-2"&#13;
fpMsg:      .asciz      "followingProc was called\n"&#13;
&#13;
            .code&#13;
            .extern     printf&#13;
&#13;
// Return program title to C++ program:&#13;
&#13;
            proc    getTitle, public&#13;
            lea     x0, ttlStr&#13;
            ret&#13;
            endp    getTitle&#13;
&#13;
// noRet&#13;
//&#13;
// Demonstrates what happens when a procedure&#13;
// does not have a return instruction&#13;
&#13;
            proc    noRet&#13;
            endp    noRet&#13;
&#13;
            proc    followingProc&#13;
            sub     sp, sp, #stackSpace&#13;
            str     lr, [sp, #saveLR]&#13;
&#13;
            lea     x0, fpMsg&#13;
            bl      printf&#13;
&#13;
            ldr     lr, [sp, #saveLR]&#13;
            add     sp, sp, #stackSpace&#13;
            ret&#13;
            endp    followingProc&#13;
&#13;
// Here is the asmMain function:&#13;
&#13;
            proc    asmMain, public&#13;
            sub     sp, sp, #stackSpace&#13;
            str     lr, [sp, #saveLR]&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_237" aria-label="237"/>            bl      noRet&#13;
&#13;
            ldr     lr, [sp, #saveLR]&#13;
            add     sp, sp, #stackSpace&#13;
            ret&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">As you can see, there is no <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction in <span class="SANS_TheSansMonoCd_W5Regular_11">noRet</span>, so when the main program (<span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span>) calls <span class="SANS_TheSansMonoCd_W5Regular_11">noRet</span>, it will fall straight through into <span class="SANS_TheSansMonoCd_W5Regular_11">followingProc</span>. Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample execution:</p>&#13;
<pre id="pre-360"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing5-2</span>&#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing5-2</span>&#13;
Calling Listing5-2:&#13;
followingProc was called&#13;
Listing5-2 terminated</code></pre>&#13;
<p class="TX">Although this behavior might be desirable in certain rare circumstances, it usually represents a defect in most programs. Therefore, always remember to explicitly return from the procedure by using the <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h1-67"/><span class="SANS_Futura_Std_Bold_B_11">5.3 Saving the State of the Machine</span></h3>&#13;
<p class="TNI1">Listing 5-3 attempts to print 20 lines of 40 spaces and an asterisk.</p>&#13;
<pre id="pre-361"><code>// Listing5-3.S&#13;
//&#13;
// Preserving registers (failure) example&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
stackSpace  =           64&#13;
saveLR      =           56&#13;
saveX19     =           48&#13;
&#13;
            .section    .rodata, ""&#13;
ttlStr:     .asciz      "Listing 5-3"&#13;
space:      .asciz      " "&#13;
asterisk:   .asciz      "*, %d\n"&#13;
&#13;
            .data&#13;
loopIndex:  .word       .-.     // Used to print loop index value&#13;
&#13;
            .code&#13;
            .extern     printf&#13;
&#13;
// getTitle&#13;
//&#13;
// Return program title to C++ program:&#13;
&#13;
            proc    getTitle, public&#13;
            lea     x0, ttlStr&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_238" aria-label="238"/>            ret&#13;
            endp    getTitle&#13;
&#13;
// print40Spaces&#13;
//&#13;
// Prints out a sequence of 40 spaces&#13;
// to the console display&#13;
&#13;
            proc    print40Spaces&#13;
            sub     sp, sp, #stackSpace&#13;
            str     lr, [sp, #saveLR]&#13;
&#13;
            mov     w19, #40&#13;
printLoop:  lea     x0, space&#13;
            bl      printf&#13;
            subs    w19, w19, #1&#13;
            bne     printLoop // Until W19 == 0&#13;
            ldr     lr, [sp, #saveLR]&#13;
            add     sp, sp, #stackSpace&#13;
            ret&#13;
            endp    print40Spaces&#13;
&#13;
// Here is the asmMain function:&#13;
&#13;
            proc    asmMain, public&#13;
&#13;
            sub     sp, sp, #stackSpace&#13;
            str     lr, [sp, #saveLR]   // Save return address.&#13;
            str     x19, [sp, #saveX19] // Must preserve nonvolatile register.&#13;
&#13;
            mov     w19, #20&#13;
astLp:      bl      print40Spaces&#13;
            lea     x0, loopIndex&#13;
            str     w19, [x0]&#13;
            lea     x0, asterisk&#13;
            vparm2  loopIndex&#13;
            bl      printf&#13;
            subs    w19, w19, #1&#13;
            bne     astLp&#13;
&#13;
            ldr     x19, [sp, #saveX19]&#13;
            ldr     lr, [sp, #saveLR]&#13;
            add     sp, sp, #stackSpace&#13;
            ret     // Returns to caller&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">Unfortunately, a subtle bug creates an infinite loop. The main program uses the <span class="SANS_TheSansMonoCd_W5Regular_11">bne printLoop</span> instruction to create a loop that calls <span class="SANS_TheSansMonoCd_W5Regular_11">Print40Spaces</span> 20 times. This function uses W19 to count off the 40 spaces it prints, and then returns with W19 containing 0. The main program prints an asterisk and a newline, decrements W19, and then repeats because W19 isn’t 0 (it will always contain –1 at this point).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_239" aria-label="239"/>The problem here is that the <span class="SANS_TheSansMonoCd_W5Regular_11">print40Spaces</span> subroutine doesn’t preserve the W19 register. Preserving a register means you save it upon entry into the subroutine and restore it before leaving. Had the <span class="SANS_TheSansMonoCd_W5Regular_11">print40Spaces</span> subroutine preserved the contents of the W19 register, Listing 5-3 would have functioned properly. There is no need to build and run this program; it just runs in an infinite loop.</p>&#13;
<p class="TX">Consider the following code for <span class="SANS_TheSansMonoCd_W5Regular_11">print40Spaces</span>:</p>&#13;
<pre id="pre-362"><code>            proc    print40Spaces&#13;
            sub     sp, sp, #stackSpace&#13;
            str     lr, [sp, #saveLR]&#13;
            str     x19, [sp, #saveX19]&#13;
&#13;
            mov     w19, #40&#13;
printLoop:  lea     x0, space&#13;
            bl      printf&#13;
            subs    w19, w19, #1&#13;
            bne     printLoop // Until W19 == 0&#13;
            ldr     lr, [sp, #saveLR]&#13;
            ldr     x19, [sp, #saveX19]&#13;
            add     sp, sp, #stackSpace&#13;
            ret&#13;
            endp    print40Spaces</code></pre>&#13;
<p class="TX">This variant of <span class="SANS_TheSansMonoCd_W5Regular_11">print40Spaces</span> saves and restores X19 on the stack, along with the LR register. Because X19 is a nonvolatile register (in the ARM ABI), it is the responsibility of the callee (the procedure) to preserve it.</p>&#13;
<p class="TX">Note that <span class="SANS_TheSansMonoCd_W5Regular_11">print40Spaces</span> uses X19 rather than one of the X0 to X15 registers specifically because it is nonvolatile. The <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> function does not have to preserve X0 to X15 because they are <i>volatile</i> registers in the ARM ABI. Any attempt to use those registers would have likely failed because <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> doesn’t have to preserve their values.</p>&#13;
<p class="TX">In general, either the caller (the code containing the call instruction) or the callee (the subroutine) can take responsibility for preserving the registers. When following the ARM ABI, it is the caller’s responsibility to preserve volatile registers and the callee’s responsibility to preserve nonvolatile registers. Of course, when writing your own procedures that won’t be called by ABI-compliant functions and don’t call any ABI-compliant functions, you can choose whichever register preservation scheme you prefer.</p>&#13;
<p class="TX">Listing 5-4 shows the corrected version of the program in Listing 5-3, which properly preserves X19 in the call to <span class="SANS_TheSansMonoCd_W5Regular_11">print40Spaces</span>.</p>&#13;
<pre id="pre-363"><code>// Listing5-4.S&#13;
//&#13;
// Preserving registers (successful) example&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
stackSpace  =           64&#13;
saveLR      =           56&#13;
saveX19     =           48&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_240" aria-label="240"/>            .section    .rodata, ""&#13;
ttlStr:     .asciz      "Listing 5-4"&#13;
space:      .asciz      " "&#13;
asterisk:   .asciz      "*, %d\n"&#13;
&#13;
            .data&#13;
loopIndex:  .word       .-.     // Used to print loop index value&#13;
&#13;
            .code&#13;
            .extern     printf&#13;
&#13;
// Return program title to C++ program:&#13;
&#13;
            proc    getTitle, public&#13;
            lea     x0, ttlStr&#13;
            ret&#13;
            endp    getTitle&#13;
&#13;
// print40Spaces&#13;
//&#13;
// Prints out a sequence of 40 spaces&#13;
// to the console display&#13;
&#13;
            proc    print40Spaces&#13;
            sub     sp, sp, #stackSpace&#13;
            str     lr, [sp, #saveLR]&#13;
            str     x19, [sp, #saveX19]&#13;
&#13;
            mov     w19, #40&#13;
printLoop:  lea     x0, space&#13;
            bl      printf&#13;
            subs    w19, w19, #1&#13;
            bne     printLoop // Until W19 == 0&#13;
            ldr     lr, [sp, #saveLR]&#13;
            ldr     x19, [sp, #saveX19]&#13;
            add     sp, sp, #stackSpace&#13;
            ret&#13;
            endp    print40Spaces&#13;
&#13;
// Here is the asmMain function:&#13;
&#13;
            proc    asmMain, public&#13;
&#13;
            sub     sp, sp, #stackSpace&#13;
            str     lr, [sp, #saveLR]   // Save return address.&#13;
            str     x19, [sp, #saveX19] // Must preserve nonvolatile register.&#13;
&#13;
            mov     w19, #20&#13;
astLp:      bl      print40Spaces&#13;
            lea     x0, loopIndex&#13;
            str     w19, [x0]&#13;
            lea     x0, asterisk&#13;
            vparm2  loopIndex&#13;
            bl      printf&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_241" aria-label="241"/>            subs    w19, w19, #1&#13;
            bne     astLp&#13;
&#13;
            ldr     lr, [sp, #saveLR]&#13;
            ldr     x19, [sp, #saveX19]&#13;
            add     sp, sp, #stackSpace&#13;
            ret     // Returns to caller&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for Listing 5-4:</p>&#13;
<pre id="pre-364"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing5-4</span>&#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing5-4</span>&#13;
Calling Listing5-4:&#13;
                                        *, 20&#13;
                                        *, 19&#13;
                                        *, 18&#13;
                                        *, 17&#13;
                                        *, 16&#13;
                                        *, 15&#13;
                                        *, 14&#13;
                                        *, 13&#13;
                                        *, 12&#13;
                                        *, 11&#13;
                                        *, 10&#13;
                                        *, 9&#13;
                                        *, 8&#13;
                                        *, 7&#13;
                                        *, 6&#13;
                                        *, 5&#13;
                                        *, 4&#13;
                                        *, 3&#13;
                                        *, 2&#13;
                                        *, 1&#13;
Listing5-4 terminated</code></pre>&#13;
<p class="Continued1">As you can see, this program executes properly without entering an infinite loop.</p>&#13;
<p class="TX">Callee preservation has two advantages: space and maintainability. If the callee (the procedure) preserves all affected registers, only one copy of the <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instructions exists—those that the procedure contains. If the caller saves the values in the registers, the program needs a set of preservation instructions around every call. This makes your programs not only longer but also harder to maintain. It’s not easy to remember which registers to save and restore on each procedure call.</p>&#13;
<p class="TX">On the other hand, a subroutine may unnecessarily preserve some registers if it preserves all the registers it modifies. If the caller is preserving the registers, the subroutine doesn’t have to save registers it doesn’t care about.</p>&#13;
<p class="TX">One big problem with having the caller preserve registers is that your program may change over time. You may modify the calling code or the procedure to use additional registers. Such changes, of course, may change <span role="doc-pagebreak" epub:type="pagebreak" id="pg_242" aria-label="242"/>the set of registers that you must preserve. Worse still, if the modification is in the subroutine itself, you will need to locate <i>every</i> call to the routine and verify that the subroutine does not change any registers that the calling code uses.</p>&#13;
<p class="TX">Assembly language programmers typically use a common convention with respect to register preservation: unless there is a good reason (performance) for doing otherwise, most programmers will preserve each register that a procedure modifies (and doesn’t explicitly return a value in a modified register). This reduces the likelihood of defects occurring in a program because a procedure modifies a register the caller expects to be preserved. Of course, you could follow the rules concerning the ARM ABI with respect to volatile and nonvolatile registers; however, such calling conventions impose their own inefficiencies on both programmers and other programs. This book generally adheres to the ARM ABI with respect to volatile and nonvolatile registers, though many examples preserve all affected registers in a procedure.</p>&#13;
<p class="TX">There’s more to preserving the environment than preserving registers. You can also preserve variables and other values that a subroutine might change.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h1-68"/><span class="SANS_Futura_Std_Bold_B_11">5.4 Call Trees, Leaf Procedures, and the Stack</span></h3>&#13;
<p class="TNI1">Imagine a procedure, A, that calls two other procedures B and C. Also assume that B calls two procedures D and E, and procedure C calls two other procedures F and G. We can diagram this calling sequence by using a <i>call tree</i>, as shown in <a href="chapter5.xhtml#fig5-1">Figure 5-1</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig5-1" src="../images/Figure5-1.jpg" alt="" width="669" height="399"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-1: A call-tree diagram</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This entire call graph is the tree, and the procedures at the bottom that do not call any other procedures—in this case, D, E, F, and G—are known as <i>leaf procedures</i>.</p>&#13;
<p class="TX">Leaf procedures are different from non-leaf procedures in ARM assembly language because they can leave the return address in the LR register rather than saving it to memory (the stack). As leaf procedures don’t make any other calls via the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> instruction, the procedure won’t disturb the value in LR upon entry into the procedure. (This assumes that the procedure doesn’t explicitly modify LR, but generally, there is no good reason for doing so.) Therefore, leaf procedures can be slightly more efficient than <span role="doc-pagebreak" epub:type="pagebreak" id="pg_243" aria-label="243"/>non-leaf procedures, as they are spared the need to preserve the value in the LR register. Leaf procedures can also make full use of the volatile register set without worrying about their values being scrambled during a call to another procedure.</p>&#13;
<p class="TX">Non-leaf procedures must preserve the value in the LR register because calls they make (via <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span>) will overwrite the value in LR. A procedure can preserve LR in a few places: in another register, on a stack, or in a global memory location, as our examples did before <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> introduced the stack.</p>&#13;
<p class="TX">I’ve already pointed out that using global variables to preserve LR is a poor choice in nearly every case. That scheme can handle only one level of calls and completely fails when using recursion (see section 5.8, <span class="Xref">“Recursion,”</span> on <span class="Xref"><a href="chapter5.xhtml#pg_277">page 277</a></span>) or writing multithreaded applications. It’s also slower, uses more code, and is less convenient to use than other schemes.</p>&#13;
<p class="TX">You could use another register to temporarily hold the return address while calling another procedure. Of course, that register must be nonvolatile (or, at least, the procedure you’re calling must not modify that register’s value) so that it will still contain the saved return address whenever the procedure you call returns. Using a register to preserve LR like this is very fast. Unfortunately, guaranteeing that other procedures won’t modify the saved value often means you have to preserve that value in memory within the second procedure to be called. Since you still have to write the value to memory (and read it back), you may as well have saved LR directly to memory in the first place.</p>&#13;
<p class="TX">The most common place to save the return address in LR is on the stack. Usually, one of the first instructions in a procedure will move the contents of the LR register into the stack. This is typically done in one of two ways. The first is to directly push the LR register onto the stack:</p>&#13;
<pre id="pre-365"><code>str lr, [sp, #-16]!</code></pre>&#13;
<p class="Continued1">The second is to adjust the stack down in memory and store LR into the storage area just created:</p>&#13;
<pre id="pre-366"><code>sub sp, sp, #<var>someAmount</var>   // Make room for LR on stack.&#13;
str lr, [sp, #<var>someOffset</var>] // Store LR into space allocated on stack.</code></pre>&#13;
<p class="Continued1">Here, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">someAmount</span> is a multiple of 16 (or another value that keeps the stack 16-byte aligned), and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">someOffset</span> is an index into the space just allocated on the stack by the <span class="SANS_TheSansMonoCd_W5Regular_11">sub</span> instruction.</p>&#13;
<p class="TX">Notice that the former example uses the pre-indexed addressing mode to adjust SP downward and store LR into the vacated space (because of stack alignment issues, this actually reserves 16 bytes, though it uses only 8 of them). The latter example uses the indirect-plus-offset addressing mode to simply store the return address into the storage allocated by the <span class="SANS_TheSansMonoCd_W5Regular_11">sub</span> instruction. This book most commonly uses the latter form because the cost of <span class="SANS_TheSansMonoCd_W5Regular_11">sub</span> is often shared by other code that uses the stack.</p>&#13;
<p class="TX">Wasting 8 bytes by using the pre-indexed addressing mode won’t turn out to be an issue. As you’ll see shortly, most of the time you’ll want to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_244" aria-label="244"/>preserve the value of the FP register along with the return address, so you’ll commonly use an <span class="SANS_TheSansMonoCd_W5Regular_11">stp</span> instruction, like one of the following, that won’t waste any memory:</p>&#13;
<pre id="pre-367"><code>stp fp, lr, [sp, #-16]!</code></pre>&#13;
<p class="Continued1">or</p>&#13;
<pre id="pre-368"><code>sub sp, sp, #<var>someAmount</var>&#13;
stp fp, lr, [sp, #<var>someOffset</var>]</code></pre>&#13;
<p class="TX">The following subsections cover the use of the stack in procedures, including activation records, accessing data within activation records (local and automatic variables as well as parameters), how the ARM ABI influences activation records and passing parameters, and how to build and destroy activation records.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-93"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">5.4.1 Activation Records</span></h4>&#13;
<p class="TNI1">When you call a procedure, the program associates certain information with that procedure call, including the return address, parameters, and automatic local variables (which I’ll discuss in later sections). To do so, it uses a data structure called an <i>activation record</i>, also known as a <i>stack frame</i>. The program creates an activation record when calling (activating) a procedure, and the data in the record is organized in a manner identical to structs.</p>&#13;
<p class="TX">This section covers traditional activation records created by a hypothetical compiler, ignoring the parameter-passing conventions of the ARM ABI. A later section of this chapter presents the ARM ABI conventions.</p>&#13;
<p class="TX">Construction of an activation record begins in the code that calls a procedure. The caller makes room for the parameter data (if any) on the stack and copies the data onto the stack. The <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> instruction then passes the return address into the procedure. At this point, construction of the activation record continues within the procedure itself. The procedure typically pushes the value in LR onto the stack along with other registers and other important state information, then makes room in the activation record for local variables. The procedure might also update the FP register (X29) so that it points at the base address of the activation record.</p>&#13;
<p class="TX">To see what a traditional activation record looks like, consider the following C++ procedure declaration:</p>&#13;
<pre id="pre-369"><code>void ARDemo(unsigned i, int j, unsigned k) &#13;
{&#13;
     int a; &#13;
     float r; &#13;
     char c; &#13;
     bool bb; &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_245" aria-label="245"/>     short w; &#13;
      . &#13;
      . &#13;
      . &#13;
}</code></pre>&#13;
<p class="TX">Whenever a program calls this <span class="SANS_TheSansMonoCd_W5Regular_11">ARDemo</span> procedure, it begins by pushing the data for the parameters onto the stack. In the original C/C++ calling convention (ignoring the ARM ABI), the calling code pushes all the parameters onto the stack in the opposite order in which they appear in the parameter list, from right to left. Therefore, the calling code pushes first the value for the <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> parameter, then the value for the <span class="SANS_TheSansMonoCd_W5Regular_11">j</span> parameter, and finally the data for the <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> parameter (with possible padding for the parameters to keep the stack aligned).</p>&#13;
<p class="TX">Next, the program calls <span class="SANS_TheSansMonoCd_W5Regular_11">ARDemo</span>. Immediately upon entry into the <span class="SANS_TheSansMonoCd_W5Regular_11">ARDemo</span> procedure, the stack contains these three items arranged as shown in <a href="chapter5.xhtml#fig5-2">Figure 5-2</a>. Since the program pushes the parameters in reverse order, they appear on the stack in the correct order, with the first parameter at the lowest address in memory.</p>&#13;
<figure class="IMG"><img class="img5" id="fig5-2" src="../images/Figure5-2.jpg" alt="" width="749" height="699"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-2: Stack organization immediately upon entry into</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">ARDemo</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The first few instructions in <span class="SANS_TheSansMonoCd_W5Regular_11">ARDemo</span> push the current values of LR and FP onto the stack, then copy the value of SP into FP. Next, the code drops the stack pointer down in memory to make room for the local variables. This produces the stack organization shown in <a href="chapter5.xhtml#fig5-3">Figure 5-3</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_246" aria-label="246"/>&#13;
<figure class="IMG"><img class="img5" id="fig5-3" src="../images/Figure5-3.jpg" alt="" width="815" height="1003"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-3: The activation record for</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">ARDemo</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Because local variables can be any size in the activation record, their total storage might not be a multiple of 16 bytes. However, the entire block of local variables must be a multiple of 16 bytes so that SP remains aligned on a 16-byte boundary as required by the ARM CPU—hence the presence of possible padding in <a href="chapter5.xhtml#fig5-3">Figure 5-3</a>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-94"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">5.4.2 Objects in the Activation Record</span></h4>&#13;
<p class="TNI1">To access objects in the activation record, you can use offsets from the FP register to the desired object. The two items of immediate interest to you are the parameters and the local variables. You can access the parameters at positive offsets from the FP register; you can access the local variables at negative offsets from the FP register, as <a href="chapter5.xhtml#fig5-4">Figure 5-4</a> shows (the figure assumes that the <span class="SANS_TheSansMonoCd_W5Regular_11">i</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">j</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> parameters are all 64-bit integers with appropriate padding to 8 bytes each).</p>&#13;
<p class="TX">ARM specifically reserves the X29/FP register for use as a pointer to the base of the activation record. This is why you should avoid using the FP register for general calculations. If you arbitrarily change the value in the FP register, you could lose access to the current procedure’s parameters and local variables.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_247" aria-label="247"/>&#13;
<figure class="IMG"><img class="img5" id="fig5-4" src="../images/Figure5-4.jpg" alt="" width="819" height="1003"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-4: Offsets of objects in the</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">ARDemo</span> <span class="SANS_Futura_Std_Book_Oblique_11">activation record</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The local variables are aligned on offsets that are equal to their native size: chars are aligned on 1-byte addresses; shorts/hwords are aligned on 2-byte addresses; longs, ints, unsigned, and words are aligned on 4-byte addresses; and so forth. In the <span class="SANS_TheSansMonoCd_W5Regular_11">ARDemo</span> example, all the locals just happen to be allocated on appropriate addresses (assuming a compiler allocates storage in the order of declaration).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-95"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">5.4.3 ARM ABI Parameter-Passing Conventions</span></h4>&#13;
<p class="TNI1">The ARM ABI makes several modifications to the activation record model:</p>&#13;
<ul class="ul">&#13;
<li class="BL">The caller passes the first eight (non-floating-point) parameters in registers (X0 through X7) rather than on the stack.</li>&#13;
<li class="BL">Parameters are always 8-byte values, either in registers or on the stack (if the formal parameter is fewer than 8 bytes in size, the unused HO bits are undefined).</li>&#13;
<li class="BL">Structures and unions greater than 16 bytes in size are passed by value on the stack above any other parameters, but with a pointer to the value in the normal parameter position (in a register or on the stack). Structs and unions that are 8 bytes (or fewer) are passed in a 64-bit register; those that are 9 to 16 bytes are passed in two consecutive registers.</li>&#13;
</ul>&#13;
<p class="TX">You must follow these conventions only when calling ARM ABI–compliant code. For assembly language procedures that you write and call, you can use any convention you like.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_248" aria-label="248"/>Apple’s calling conventions for macOS (iOS, iPadOS, and so on) vary a little from the standard ARM ABI. This will affect your assembly code if you’re doing the following:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Passing more than eight parameters to a procedure</li>&#13;
<li class="BL">Passing parameters to a variadic procedure</li>&#13;
</ul>&#13;
<p class="TX">When passing parameters on the stack—that is, when you’re passing more than eight arguments to a function—Apple packs them on the stack, meaning it doesn’t simply allocate 8 bytes for each parameter on the stack. It does ensure that each value is aligned in memory on its natural size (chars = 1 byte, half words = 2 bytes, words = 4 bytes, and so on).</p>&#13;
<p class="TX"><i>Variadic procedures</i> are those with a variable number of parameters, such as the C <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> function. Apple passes all variadic parameters on the stack and allocates 8 bytes for each parameter, regardless of type. This is the purpose behind the <span class="SANS_TheSansMonoCd_W5Regular_11">vparm2</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">vparm3</span>, ..., macros in <i>aoaa.inc</i>: calls to <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> under macOS must pass the arguments on the stack, while the same calls on Linux pass the first eight parameters in registers.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">vparm2</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">vparm3</span>, and so on, macros automatically generate the appropriate code based on the OS (either putting the parameters in the stack or passing them in registers).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-96"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">5.4.4 Standard Entry Sequence</span></h4>&#13;
<p class="TNI1">The caller of a procedure is responsible for allocating storage for parameters on the stack and moving the parameter data to its appropriate location. In the simplest case, this just involves moving the data onto the stack by using <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">stp</span> instructions. It is the procedure’s responsibility to construct the rest of the activation record. You can accomplish this by using the following assembly language <i>standard entry sequence</i> code:</p>&#13;
<pre id="pre-370"><code>stp fp, lr, [sp, #-16]!   // Save LR and FP values.&#13;
mov fp, sp                // Get activation record ptr in FP.&#13;
sub sp, sp, #<var>NumVars</var>      // Allocate local storage.</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">mov fp, sp</span> instruction copies the current address held in SP into the FP register. As SP is currently pointing at the old value of FP pushed on the stack, FP will point at the original FP value after the execution of this instruction, as shown in <a href="chapter5.xhtml#fig5-4">Figure 5-4</a>. When using the <span class="SANS_TheSansMonoCd_W5Regular_11">stp</span> instruction in the standard entry sequence, make sure to specify the FP register as the first argument so that it is stored at location <span class="SANS_TheSansMonoCd_W5Regular_11">[SP]</span> and LR is stored at location <span class="SANS_TheSansMonoCd_W5Regular_11">[SP, #8]</span>. This ensures that FP will point at the old FP value after the <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction.</p>&#13;
<p class="TX">In the third instruction, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">NumVars</span> represents the number of bytes of local variables needed by the procedure, a constant that should be a multiple of 16 so that the SP register remains aligned on a 16-byte boundary. If the number of bytes of local variables in the procedure is not a multiple of 16, round up the value to the next higher multiple of 16 before subtracting this constant from SP. Doing so will slightly increase the amount of storage the procedure uses for local variables but will not otherwise affect the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_249" aria-label="249"/>operation of the procedure. If the procedure doesn’t have any local variables or call any other functions, the</p>&#13;
<pre id="pre-371"><code>sub sp, sp, #<var>NumVars</var></code></pre>&#13;
<p class="Continued1">instruction isn’t necessary.</p>&#13;
<p class="TX">In theory, you could use any register to access the data in the stack frame. However, the OS, and especially debugger applications, often depend on the activation record being built with FP pointing at the old FP value in the activation record.</p>&#13;
<p class="TX">If an ARM ABI–compliant program calls your procedure, the stack will be aligned on a 16-byte boundary immediately prior to the execution of the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> instruction. Pushing LR and FP onto the stack (before copying SP into FP) adds another 16 bytes to the stack so that SP remains 16-byte aligned. Therefore, assuming the stack was 16-byte aligned prior to the call, and the number you subtract from SP is a multiple of 16, the stack will be 16-byte aligned after allocating storage for local variables.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">ARDemo</span> activation record from the previous section has only 12 bytes of local storage. Therefore, subtracting 12 from SP for the local variables will not leave the stack 16-byte aligned. The entry sequence in the <span class="SANS_TheSansMonoCd_W5Regular_11">ARDemo</span> program must subtract 16 (which will include 4 bytes of padding) to keep the stack properly aligned (as shown in <a href="chapter5.xhtml#fig5-4">Figure 5-4</a>).</p>&#13;
<p class="TX">A possible alternate entry code sequence that is equivalent to the earlier example takes this form:</p>&#13;
<pre id="pre-372"><code>sub sp, sp, #<var>numVars </var>+ 16   // Space for locals and SP/LR&#13;
stp fp, lr, [sp, #<var>numVars</var>]&#13;
add fp, sp, #<var>numVars</var></code></pre>&#13;
<p class="TX">The ARM ABI calling convention suggests saving the LR and FP values <i>below</i> the local variables. However, it is often convenient to allocate parameter space for additional procedure calls (from the current procedure) while allocating local variables. If you save the LR and FP values at the bottom of the activation record in memory, you will need an extra instruction to make room for those parameters, and cleaning up the activation record will take more effort when the procedure returns.</p>&#13;
<p class="TX">Because you’ll so often use the standard entry sequence, the <i>aoaa.inc</i> include file provides a macro to generate this sequence for you:</p>&#13;
<pre id="pre-373"><code>enter <var>numVars</var></code></pre>&#13;
<p class="TX">The single constant argument is the amount of stack space to allocate (for local variables and other memory objects) in addition to the 16 bytes set aside to preserve the LR and FP registers. This macro generates the following sequence of instructions for the entry sequence:</p>&#13;
<pre id="pre-374"><code>stp fp, lr, [sp, #-16]!&#13;
mov fp, sp&#13;
sub sp, sp, #(<var>numVars</var> + 15) &amp; 0xFFFFFFFFFFFFFFF0</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_250" aria-label="250"/>The final expression involving <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">numVars</span> ensures that the space allocated on the stack is a multiple of 16 bytes, to keep the stack 16-byte aligned.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-97"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">5.4.5 Standard Exit Sequence</span></h4>&#13;
<p class="TNI1">The standard exit sequence for an assembly language program is the following:</p>&#13;
<pre id="pre-375"><code>mov sp, fp             // Deallocates storage for all the local vars&#13;
ldp fp, lr, [sp], #16  // Pop FP and return address.&#13;
ret                    // Return to caller.</code></pre>&#13;
<p class="TX">In the <i>aoaa.inc</i> include file, the <span class="SANS_TheSansMonoCd_W5Regular_11">leave</span> macro expands to the original standard exit sequence.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h1-69"/><span class="SANS_Futura_Std_Bold_B_11">5.5 Local Variables</span></h3>&#13;
<p class="TNI1">Procedures and functions in most HLLs let you declare local variables (also known as <i>automatic variables</i>). The previous sections mentioned that procedures maintain local variables in an activation record, but they didn’t really define how to create and use them. This section (and the subsections that follow) defines local variables and describes how to allocate storage for them and use them.</p>&#13;
<p class="TX">Local variables possess two special attributes in HLLs: scope and lifetime<i>.</i> The <i>scope</i> of an identifier determines where that identifier is visible (accessible) in the source file during compilation. In most HLLs, the scope of a procedure’s local variable is the body of that procedure; the identifier is inaccessible outside that procedure. Sadly, Gas does not support locally scoped variables in a procedure, since Gas has no syntax to determine the bounds of a procedure.</p>&#13;
<p class="TX">Whereas scope is a compile-time attribute of a symbol, lifetime is a runtime attribute. The <i>lifetime</i> of a variable is a range of time, from that point when storage is first bound to the variable until the point where the storage is no longer available for that variable. Static objects (those you declare in the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> sections) have a lifetime equivalent to the total runtime of the application. The program allocates storage for such variables when the program first loads into memory, and those variables maintain that storage until the program terminates.</p>&#13;
<p class="TX">Local variables, more properly known as <i>automatic variables</i>, have their storage allocated upon entry into a procedure. That storage is then returned for other use when the procedure returns to its caller. The name <i>automatic</i> refers to the program automatically allocating and deallocating storage for the variable on procedure invocation and return.</p>&#13;
<p class="TX">Under Linux, a procedure can access any global <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> object exactly the same way the main program accesses such variables: by referencing the name, using the PC-relative addressing mode (sadly, macOS’s PIE format doesn’t allow easy access to non-<span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section objects). Accessing global objects is convenient and easy. However, accessing global <span role="doc-pagebreak" epub:type="pagebreak" id="pg_251" aria-label="251"/>objects makes your programs harder to read, understand, and maintain, so you should avoid using global variables within procedures.</p>&#13;
<p class="TX">Although accessing global variables within a procedure may sometimes be the best solution to a given problem, you likely won’t be writing such code at this point, so carefully consider your options before doing so. (An example of a legitimate use of global variables might be when sharing data between threads in a multithreaded application, a bit beyond the scope of this chapter.)</p>&#13;
<p class="TX">This argument against accessing global variables does not apply to other global symbols, however. It is perfectly reasonable to access global constants, types, procedures, and other objects in your programs.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h2-98"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">5.5.1 Low-Level Implementation of Automatic Variables</span></h4>&#13;
<p class="TNI1">Your program accesses local variables in a procedure by using negative offsets from the activation record base address (FP). Consider the Gas procedure in Listing 5-5, which is intended primarily to demonstrate the use of local variables.</p>&#13;
<pre id="pre-376"><code>// Listing5-5.S&#13;
//&#13;
// Accessing local variables&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
               .text&#13;
&#13;
// local_vars&#13;
//&#13;
// Word a is at offset -4 from FP.&#13;
// Word bb is at offset -8 from FP.&#13;
//&#13;
// On entry, W0 and W1 contain values to store&#13;
// into the local variables a &amp; bb (respectively).&#13;
&#13;
            proc    local_vars&#13;
            enter   8&#13;
&#13;
            str     w0, [fp, #-4]   // a = W0&#13;
            str     w1, [fp, #-8]   // bb = W1&#13;
&#13;
    // Additional code here that uses a &amp; bb&#13;
&#13;
            leave&#13;
            endp    local_vars</code></pre>&#13;
<p class="TX">This program isn’t runnable, so I won’t bother providing a <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command for it. The <span class="SANS_TheSansMonoCd_W5Regular_11">enter</span> macro will actually allocate 16 bytes of storage, rather than the 8 specified by the argument (for locals <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span>), in order to keep the stack 16-byte aligned.</p>&#13;
<p class="TX">The activation record for <span class="SANS_TheSansMonoCd_W5Regular_11">local_vars</span> appears in <a href="chapter5.xhtml#fig5-5">Figure 5-5</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_252" aria-label="252"/>&#13;
<figure class="IMG"><img class="img5" id="fig5-5" src="../images/Figure5-5.jpg" alt="" width="820" height="795"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-5: The activation record for the</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">local_vars</span> <span class="SANS_Futura_Std_Book_Oblique_11">procedure</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Of course, having to refer to the local variables by the numeric offset from the FP register is truly horrible. This code is not only difficult to read (Is <span class="SANS_TheSansMonoCd_W5Regular_11">[FP, #-4]</span> the <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> or the <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span> variable?) but also hard to maintain. For example, if you decide you no longer need the <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> variable, you’d have to go find every occurrence of <span class="SANS_TheSansMonoCd_W5Regular_11">[FP, #-8]</span> (accessing the <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span> variable) and change it to <span class="SANS_TheSansMonoCd_W5Regular_11">[FP, #-4]</span>.</p>&#13;
<p class="TX">A slightly better solution is to create equates for your local variable names. Consider the modification to Listing 5-5 shown in Listing 5-6.</p>&#13;
<pre id="pre-377"><code>// Listing5-6.S&#13;
//&#13;
// Accessing local variables #2&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
            .code&#13;
&#13;
// local_vars&#13;
//&#13;
// Demonstrates local variable access&#13;
//&#13;
// Word a is at offset -4 from FP.&#13;
// Word bb is at offset -8 from FP.&#13;
//&#13;
// On entry, W0 and W1 contain values to store&#13;
// into the local variables a &amp; bb (respectively).&#13;
&#13;
#define a [fp, #-4]&#13;
#define bb [fp, #-8]&#13;
&#13;
            proc    local_vars&#13;
            enter   8&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_253" aria-label="253"/>            str     w0, a&#13;
            str     w1, bb&#13;
&#13;
    <var>Additional code here that uses a &amp; bb.</var>&#13;
&#13;
            leave&#13;
            endp    local_vars</code></pre>&#13;
<p class="TX">In Listing 5-6, the CPP replaces <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span> with the appropriate indirect-plus-offset addressing mode to access those local variables on the stack. This is considerably easier to read and maintain than the program in Listing 5-5. However, this approach still requires some manual work to set the local variable offsets in the <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statements, and modifying the code (when adding or removing local variables) can create maintenance issues. I’ll provide a better solution in the next section.</p>&#13;
<p class="TX">One big advantage to automatic storage allocation is that it efficiently shares a fixed pool of memory among several procedures. For example, say you call three procedures in a row, like this:</p>&#13;
<pre id="pre-378"><code>bl ProcA&#13;
bl ProcB&#13;
bl ProcC</code></pre>&#13;
<p class="TX">In this example, <span class="SANS_TheSansMonoCd_W5Regular_11">ProcA</span> allocates its local variables on the stack. Upon return, <span class="SANS_TheSansMonoCd_W5Regular_11">ProcA</span> deallocates that stack storage. Upon entry into <span class="SANS_TheSansMonoCd_W5Regular_11">ProcB</span>, the program allocates storage for <span class="SANS_TheSansMonoCd_W5Regular_11">ProcB</span>’s local variables by using the same memory locations just freed by <span class="SANS_TheSansMonoCd_W5Regular_11">ProcA</span>. Likewise, when <span class="SANS_TheSansMonoCd_W5Regular_11">ProcB</span> returns and the program calls <span class="SANS_TheSansMonoCd_W5Regular_11">ProcC</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">ProcC</span> uses the same stack space for its local variables that <span class="SANS_TheSansMonoCd_W5Regular_11">ProcB</span> recently freed up. This memory reuse makes efficient use of the system resources and is probably the greatest advantage to using automatic variables.</p>&#13;
<p class="TX">Now that you’ve seen how assembly language allocates and deallocates storage for local variables, it’s easy to understand why automatic variables do not maintain their values between two calls to the same procedure. Once the procedure returns to its caller, the storage for the automatic variable is lost, and, therefore, the value is lost as well. Thus, <i>you must always assume that a local variable object is uninitialized upon entry into a procedure</i>. If you need to maintain the value of a variable between calls to a procedure, you should use one of the static variable declaration types.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h2-99"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">5.5.2 The locals Macro</span></h4>&#13;
<p class="TNI1">Using equates to maintain local variable references is a lot of work. Granted, it’s better than using magic numbers in all your local variable references, but even when using equates, inserting and deleting local variables in a procedure takes time and effort. What would be really nice is a declaration section that lets you declare your local variables in an HLL-like fashion and leave it up to the assembler to maintain all the offsets into the activation record. The <i>aoaa.inc</i> header file provides a set of macros you <span role="doc-pagebreak" epub:type="pagebreak" id="pg_254" aria-label="254"/>can use to automate the creation of local variables. This section describes those macros.</p>&#13;
<p class="TX">The activation record is a <i>record</i> (structure). In theory, you could use the <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span> macro from <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span> to define an activation record. However, it’s easy enough to modify the <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">ends</span> macros to create something even better for local variables. To achieve that, the <i>aoaa.inc</i> include file includes two additional macros for declaring local variables: <span class="SANS_TheSansMonoCd_W5Regular_11">locals</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">endl</span>. Use these in a manner almost identical to the <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">ends</span> macros</p>&#13;
<pre id="pre-379"><code>locals <var>procName</var>&#13;
  <var>declarations (same as for struct)</var>&#13;
endl   <var>procName</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">procName</span> is an identifier (usually the name of the procedure that the local variables are associated with).</p>&#13;
<p class="TX">Like the <span class="SANS_TheSansMonoCd_W5Regular_11">ends</span> macro, <span class="SANS_TheSansMonoCd_W5Regular_11">endl</span> generates a symbol with the name <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">procName</span><span class="SANS_TheSansMonoCd_W5Regular_11">.size</span> that is an equate set to the size of the local variable space. You can supply this value to the <span class="SANS_TheSansMonoCd_W5Regular_11">enter</span> macro to specify the amount of space to reserve for the local variables:</p>&#13;
<pre id="pre-380"><code>    proc   myProc&#13;
&#13;
    locals myProc&#13;
    dword  mp.ptrVar&#13;
    word   mp.counter&#13;
    byte   mp.inputChar&#13;
    salign 4&#13;
    word   mp.endIndex&#13;
    endl   myProc&#13;
&#13;
    enter  myProc.size&#13;
&#13;
<var>Insert procedure's body here.</var>&#13;
&#13;
    leave&#13;
    endp   myProc</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">locals</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">endl</span> declarations create a set of equates whose values correspond to the offsets of the symbols within an activation record. For example, the symbols in the previous example have the following values:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">mp.ptrVar</span>    –8</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">mp.counter</span>    –12</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">mp.inputChar</span>    –13</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">mp.endIndex</span>    –20</p>&#13;
</div>&#13;
<p class="TX">You can use these offsets with the <span class="SANS_TheSansMonoCd_W5Regular_11">[FP, #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">offset</span>] addressing mode to reference these local variables in the activation record. For example:</p>&#13;
<pre id="pre-381"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_255" aria-label="255"/>ldr w0, [fp, #mp.counter]&#13;
ldr x1, [fp, #mp.ptrVar]&#13;
str w0, [x1]</code></pre>&#13;
<p class="Continued1">This is a whole lot easier than accessing global variables in the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section!</p>&#13;
<p class="TX">When allocating offsets for variables between the <span class="SANS_TheSansMonoCd_W5Regular_11">locals</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">endl</span> macros, the declaration macros first decrease the offset counter by the size of the variable’s declaration and then assign the decremented offset value to the symbol. Specifying the <span class="SANS_TheSansMonoCd_W5Regular_11">salign</span> directive will then adjust the offset to the specified boundary (2<i><sup>n</sup></i>, where <i>n</i> is the <span class="SANS_TheSansMonoCd_W5Regular_11">salign</span> operand’s value). The next declaration will not use this offset, but rather it will first decrement the running offset counter by the size of the declaration and assign that offset to the variable. In the earlier example, the <span class="SANS_TheSansMonoCd_W5Regular_11">salign</span> directive set the running offset to –16 (because 13 bytes of variables were allocated at that point). The following variable’s offset is –20, because <span class="SANS_TheSansMonoCd_W5Regular_11">mp.endIndex</span> consumes 4 bytes.</p>&#13;
<p class="TX">As I mentioned earlier, Gas does not support the concept of lexically scoped local variable names, which are private to a procedure. Therefore, all symbols you declare within the <span class="SANS_TheSansMonoCd_W5Regular_11">locals</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">endl</span> block are visible throughout the source file. This can lead to <i>namespace pollution</i>, where you wind up creating names in one procedure and cannot reuse those names in a different procedure.</p>&#13;
<p class="TX">In the examples of this section, I use a convention that I continue throughout this book to alleviate namespace pollution: I use local variable names of the form <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">proc.local</span>, where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">proc</span> is the procedure’s name (or an abbreviation of the procedure’s name) and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">local</span> is the specific local variable name I want to use. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">mp.ptrVar</span> is the <span class="SANS_TheSansMonoCd_W5Regular_11">ptrVar</span> local variable within the <span class="SANS_TheSansMonoCd_W5Regular_11">myProc</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">mp</span>) procedure.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1" id="sec15"><span id="h1-70"/><span class="SANS_Futura_Std_Bold_B_11">5.6 Parameters</span></h3>&#13;
<p class="TNI1">Although many procedures are totally self-contained, most procedures require input data and return data to the caller (parameters).</p>&#13;
<p class="TX">The first aspect to consider when discussing parameters is how we pass them to a procedure. If you are familiar with Pascal or C/C++, you’ve probably seen two ways to pass parameters: pass by value and pass by reference. Anything you can do with an HLL can be done in assembly language (obviously, as HLL code compiles into machine code), but you have to provide the instruction sequence to access those parameters in an appropriate fashion.</p>&#13;
<p class="TX">Another concern when dealing with parameters is <i>where</i> you pass them. There are many places to pass parameters: in registers, on the stack, in the code stream, in global variables, or a combination of these. The following subsections cover several of the possibilities.</p>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h2-100"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">5.6.1 Passing by Value</span></h4>&#13;
<p class="TNI1">A parameter <i>passed by value</i> is just that—the caller passes a value to the procedure. Pass-by-value parameters are input-only parameters. You can <span role="doc-pagebreak" epub:type="pagebreak" id="pg_256" aria-label="256"/>pass them to a procedure, but the procedure cannot return values through them. Consider this C/C++ function call:</p>&#13;
<pre id="pre-382"><code>CallProc(I);</code></pre>&#13;
<p class="TX">If you pass <span class="SANS_TheSansMonoCd_W5Regular_11">I</span> by value, <span class="SANS_TheSansMonoCd_W5Regular_11">CallProc()</span> does not change the value of <span class="SANS_TheSansMonoCd_W5Regular_11">I</span>, regardless of what happens to the parameter inside <span class="SANS_TheSansMonoCd_W5Regular_11">CallProc()</span>.</p>&#13;
<p class="TX">Because you must pass a copy of the data to the procedure, you should use this method only for passing small objects like bytes, words, double words, and quad words. Passing large arrays and records by value is inefficient, because you must create and pass a copy of the object to the procedure.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h2-101"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">5.6.2 Passing by Reference</span></h4>&#13;
<p class="TNI1">To pass a parameter <i>by reference</i>, you must pass the address of a variable rather than its value. In other words, you must pass a pointer to the data. The procedure must dereference this pointer to access the data. Passing parameters by reference is useful when you must modify the actual parameter or when you pass large data structures between procedures. Because pointers on the ARM are 64 bits wide, a parameter that you pass by reference will consist of a double-word value, typically in one of the general-purpose registers.</p>&#13;
<p class="TX">You can use the <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> macro to take the address of any static variable you’ve declared in your <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> sections. Listing 5-7 demonstrates how to obtain the address of a static variable (<span class="SANS_TheSansMonoCd_W5Regular_11">staticVar</span>) and pass that address to a procedure (<span class="SANS_TheSansMonoCd_W5Regular_11">someFunc</span>) in the X0 register.</p>&#13;
<pre id="pre-383"><code>// Listing5-7.S&#13;
//&#13;
// Demonstrate obtaining the address&#13;
// of a variable by using the lea instruction.&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
            .data&#13;
staticVar:  .word   .-.&#13;
&#13;
            .code&#13;
            .extern someFunc&#13;
&#13;
            proc    get_address&#13;
            enter   0&#13;
            lea     x0, staticVar&#13;
            bl      someFunc&#13;
            leave&#13;
            endp    get_address</code></pre>&#13;
<p class="TX">Calculating the address of a nonstatic variable is a bit more work. Unfortunately, the <span class="SANS_TheSansMonoCd_W5Regular_11">adr</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">adrp</span> instructions compute only the address of a PC-relative memory access. If your variable is referenced by one of the other <span role="doc-pagebreak" epub:type="pagebreak" id="pg_257" aria-label="257"/>ARM addressing modes, you’ll have to manually compute the effective address yourself.</p>&#13;
<p class="TX"><a href="chapter5.xhtml#tab5-1">Table 5-1</a> describes the process for effective address calculation. In the table, the <span class="SANS_TheSansMonoCd_W5Regular_11">[X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">const</span>] (scaled form) addressing mode describes a machine encoding, not an assembler syntax. In source code, the scaled and unscaled variants share the same syntax: <span class="SANS_TheSansMonoCd_W5Regular_11">[X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">const</span>]. The assembler will pick the correct machine encoding based on the value of the constant.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab5-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 5-1:</span></span> <span class="SANS_Futura_Std_Book_11">Effective Address Calculations</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Addressing mode</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Effective address</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">[X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_Futura_Std_Book_11">]</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">For the register-indirect addressing mode, the effective address is just the value held in the register.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">[X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">const</span><span class="SANS_Futura_Std_Book_11">]</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span> <span class="SANS_Futura_Std_Book_11">+</span> <span class="SANS_Futura_Std_Book_Oblique_11">const</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">For the indirect-plus-offset addressing mode, the sum of the X</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span> <span class="SANS_Futura_Std_Book_11">register and the constant is the effective address. This assumes the constant is –256 to +255 and the shift is 0.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">[X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">const</span><span class="SANS_Futura_Std_Book_11">]</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span> <span class="SANS_Futura_Std_Book_11">+</span> <span class="SANS_Futura_Std_Book_Oblique_11">const</span> <span class="SANS_Futura_Std_Book_11">(scaled)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">For the scaled-indirect-plus-offset mode (where the scaling factor is determined by the size of the data being loaded or stored), the constant has to be multiplied by the size of the memory operand prior to adding with the X</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span> <span class="SANS_Futura_Std_Book_11">register. For</span> <span class="SANS_TheSansMonoCd_W5Regular_11">strb</span><span class="SANS_Futura_Std_Book_11">/</span><span class="SANS_TheSansMonoCd_W5Regular_11">ldrb</span><span class="SANS_Futura_Std_Book_11">, the multiplier is 1; for</span> <span class="SANS_TheSansMonoCd_W5Regular_11">strh</span><span class="SANS_Futura_Std_Book_11">/</span><span class="SANS_TheSansMonoCd_W5Regular_11">ldrh</span><span class="SANS_Futura_Std_Book_11">, the multiplier is 2; for</span> <span class="SANS_TheSansMonoCd_W5Regular_11">str</span><span class="SANS_Futura_Std_Book_11">/</span><span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> <span class="SANS_Futura_Std_Book_11">(word register), the multiplier is 4; and for</span> <span class="SANS_TheSansMonoCd_W5Regular_11">str</span><span class="SANS_Futura_Std_Book_11">/</span><span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> <span class="SANS_Futura_Std_Book_11">(dword register), the multiplier is 8. For</span> <span class="SANS_TheSansMonoCd_W5Regular_11">strb/ldrb</span><span class="SANS_Futura_Std_Book_11">, the constant must be in the range 0–4,096. For</span> <span class="SANS_TheSansMonoCd_W5Regular_11">strh/ldrh</span><span class="SANS_Futura_Std_Book_11">, the constant must be in the range 0–8,191 and must be an even number. For</span> <span class="SANS_TheSansMonoCd_W5Regular_11">ldr/str</span> <span class="SANS_Futura_Std_Book_11">with a word-sized register operand, the constant must be in the range 0–16,383 and must be a multiple of 4. For</span> <span class="SANS_TheSansMonoCd_W5Regular_11">ldr/str</span> <span class="SANS_Futura_Std_Book_11">with a dword-sized register operand, the constant must be in the range 0–32,767 and must be a multiple of 8.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">[X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">const</span><span class="SANS_TheSansMonoCd_W5Regular_11">]!</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span> <span class="SANS_Futura_Std_Book_11">+</span> <span class="SANS_Futura_Std_Book_Oblique_11">const</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">For the pre-indexed addressing mode, the effective address is the sum of the X</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span> <span class="SANS_Futura_Std_Book_11">register and the constant.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">[X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">], #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">const</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">For the post-indexed addressing mode, the effective address is just the value in the X</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span> <span class="SANS_Futura_Std_Book_11">register.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">[X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span><span class="SANS_Futura_Std_Book_11">]</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span> <span class="SANS_Futura_Std_Book_11">+ X</span><span class="SANS_Futura_Std_Book_Oblique_11">m</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">For the scaled-indexed addressing mode, with a scaling factor of 1, the effective address is the sum of the two registers (sign- or zero-extend X</span><span class="SANS_Futura_Std_Book_Oblique_11">m</span><span class="SANS_Futura_Std_Book_11">, if specified).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">[X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, X</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span><span class="SANS_TheSansMonoCd_W5Regular_11">, extend #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">s</span><span class="SANS_TheSansMonoCd_W5Regular_11">]</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span> <span class="SANS_Futura_Std_Book_11">+ (X</span><span class="SANS_Futura_Std_Book_Oblique_11">m</span> <span class="SANS_Futura_Std_Book_11">&lt;&lt;</span> <span class="SANS_Futura_Std_Book_Oblique_11">s</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">For the scaled-indexed addressing mode with a shift extension, the effective address is the sum of X</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span> <span class="SANS_Futura_Std_Book_11">plus the value in X</span><span class="SANS_Futura_Std_Book_Oblique_11">m</span> <span class="SANS_Futura_Std_Book_11">shifted to the left</span> <span class="SANS_Futura_Std_Book_Oblique_11">s</span> <span class="SANS_Futura_Std_Book_11">positions (with X</span><span class="SANS_Futura_Std_Book_Oblique_11">m</span> <span class="SANS_Futura_Std_Book_11">zero- or sign-extended, if specified).</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Suppose that a procedure has a local variable and you want to pass that on to a second procedure by reference. Because you access local variables by using the <span class="SANS_TheSansMonoCd_W5Regular_11">[FP, #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">offset</span>] addressing mode, the effective address is <span class="SANS_TheSansMonoCd_W5Regular_11">FP</span> + <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">offset</span>. You would have to use the following instruction to compute the address of that variable (leaving the address in X0):</p>&#13;
<pre id="pre-384"><code>add x0, fp, #<var>offset</var></code></pre>&#13;
<p class="TX">Listing 5-8 demonstrates passing a local variable as a reference parameter to a procedure.</p>&#13;
<pre id="pre-385"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_258" aria-label="258"/>// Listing5-8.S&#13;
//&#13;
// Demonstrate passing a local variable&#13;
// by reference to another procedure.&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
            .data&#13;
staticVar:  .word   .-.&#13;
&#13;
            .code&#13;
            .extern aSecondFunction&#13;
&#13;
            proc    demoPassLclByRef&#13;
&#13;
            locals  ga&#13;
            word    ga.aLocalVariable&#13;
            endl    ga&#13;
&#13;
            enter   ga.size&#13;
            add     x0, fp, #ga.aLocalVariable // Pass parameter in X0.&#13;
            bl      aSecondFunction&#13;
&#13;
            leave&#13;
            endp    demoPassLclByRef</code></pre>&#13;
<p class="TX">Pass by reference is usually less efficient than pass by value. You must dereference all pass-by-reference parameters on each access; this is slower than simply using a value because it typically requires at least two instructions: one to fetch the address into a register and one to fetch the value indirectly through that register.</p>&#13;
<p class="TX">However, when passing a large data structure, pass by reference is faster because you do not have to copy the large data structure before calling the procedure. Of course, you’d probably need to access elements of that large data structure (such as an array) by using a pointer, so little efficiency is lost when you pass large arrays by reference.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h4 class="H2" id="sec18"><span id="h2-102"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">5.6.3 Using Low-Level Parameter Implementation</span></h4>&#13;
<p class="TNI1">A parameter-passing mechanism is a contract between the caller and the callee (the procedure). Both parties have to agree on where the parameter data will appear and what form it will take (for example, value or address).</p>&#13;
<p class="TX">If your assembly language procedures are being called only by other assembly language code that you’ve written, you control both sides of the contract negotiation and get to decide where and how you’re going to pass parameters. However, if external code is calling your procedure, or your procedure is calling external code, your procedure will have to adhere to whatever calling convention that external code uses.</p>&#13;
<p class="TX">Before discussing the particular calling conventions, this section considers the situation of calling code that you’ve written (and, therefore, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_259" aria-label="259"/>have complete control over its calling conventions). The following sections describe the various ways you can pass parameters in pure assembly language code (without the overhead associated with the ARM or macOS ABIs).</p>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h5 class="H3" id="sec19"><span class="SANS_Futura_Std_Bold_Condensed_B_11">5.6.3.1 Passing Parameters in Registers</span></h5>&#13;
<p class="TNI1">Having touched on <i>how</i> to pass parameters to a procedure, the next topic to discuss is <i>where</i> to pass parameters. This depends on the size and number of those parameters. If you are passing a small number of parameters to a procedure, the registers are an excellent place to pass them. If you are passing a single parameter to a procedure, pass that data in X0, as described in <a href="chapter5.xhtml#tab5-2">Table 5-2</a>.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab5-2"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 5-2:</span></span> <span class="SANS_Futura_Std_Book_11">Parameter Size and Location</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Parameter size</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Location</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Byte</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Pass a byte parameter in the LO byte of W0.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Half word</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Pass a halfword parameter in the LO half-word of W0.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Word</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Pass a word in W0.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Dword</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Pass a dword in X0.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">&gt; 8 bytes</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">I suggest passing a pointer to the data structure in X0, or the value in X0/X1 if 16 bytes or fewer.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">When passing fewer than 32 bits in X0, the macOS ABI requires that the value be zero- or sign-extended throughout the X0 register. The ARM ABI does not require this. Of course, when passing data to a procedure you’ve written in assembly language, it is up to you to define what must be done with the HO bits. The safest course of action, portable everywhere, is to zero-extend or sign-extend the value into the HO bits (depending on whether the value is unsigned or signed).</p>&#13;
<p class="TX">If you need to pass more than 8 bytes as a parameter, you could also pass that data in multiple registers (for example, under macOS and Linux, the C/C++ compiler will pass a 16-byte structure in two registers). Whether you pass the argument as a pointer or in multiple registers is up to you.</p>&#13;
<p class="TX">For passing parameters to a procedure in registers, the ARM ABI reserves X0 to X7. Of course, in pure assembly language code (that won’t call, or be called by, ARM ABI–compliant code), you can use whichever registers you choose. However, X0 through X7 should probably be your first choice unless you can provide a good reason for using other registers.</p>&#13;
<p class="TX">Eight parameters probably cover 95 percent of the procedures ever written. If you are passing more than eight parameters to a pure assembly procedure, nothing is stopping you from using additional registers (for example, X8 through X15). Likewise, nothing is stopping you from passing large objects in multiple registers, if you really want to do that.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_260" aria-label="260"/>&#13;
<h5 class="H3" id="sec20"><span class="SANS_Futura_Std_Bold_Condensed_B_11">5.6.3.2 Passing Parameters in the Code Stream</span></h5>&#13;
<p class="TNI1">You can also pass parameters in the code stream immediately after the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> instruction. Consider the following <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> routine that prints a literal string constant to the standard output device:</p>&#13;
<pre id="pre-386"><code>bl      print&#13;
.asciz "This parameter is in the code stream..."</code></pre>&#13;
<p class="TX">Normally, a subroutine returns control to the first instruction immediately following the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> instruction. Were that to happen here, the ARM would attempt to interpret the ASCII codes for <span class="SANS_TheSansMonoCd_W5Regular_11">"This..."</span> as an instruction. This would produce undesirable results. Fortunately, you can skip over this string before returning from the subroutine.</p>&#13;
<p class="TX">One big issue arises with the design of the ARM CPU, however: all instructions must be word-aligned in memory. Therefore, the parameter data appearing in the code stream must be a multiple of 4 bytes long (I chose the string in this example to contain 39 characters so that the zero-terminating byte made the whole sequence 40 bytes).</p>&#13;
<p class="TX">So how do you gain access to these parameters? Easy: the return address in LR points at them. Consider the implementation of <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> in Listing 5-9.</p>&#13;
<pre id="pre-387"><code>// Listing5-9.S&#13;
//&#13;
// Demonstrate passing parameters in the code stream&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
            .text&#13;
            .pool&#13;
ttlStr:     .asciz      "Listing 5-9"&#13;
            .align      2&#13;
&#13;
// getTitle&#13;
//&#13;
// Return program title to C++ program:&#13;
&#13;
            proc    getTitle, public&#13;
            lea     x0, ttlStr&#13;
            ret&#13;
            endp    getTitle&#13;
&#13;
// print&#13;
//&#13;
// Here's the print procedure.&#13;
// It expects a zero-terminated string&#13;
// to follow the call to print:&#13;
&#13;
rtnAdrs     =       8           // Offset to rtn adrs from FP.&#13;
&#13;
            proc    print&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_261" aria-label="261"/>          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> locals  print&#13;
            qword   print.x0X1Save   // Register save area.&#13;
            qword   print.x2X3Save&#13;
            qword   print.x4X5Save&#13;
            qword   print.x6X7Save&#13;
            qword   print.x8X9Save&#13;
            qword   print.x10X11Save&#13;
            qword   print.x12X13Save&#13;
            qword   print.x14X15Save&#13;
            endl    print&#13;
&#13;
            enter   print.size&#13;
&#13;
// Assembly language convention--save all the registers&#13;
// whose values we change. Spares caller from having to&#13;
// preserve volatile registers.&#13;
// Note: this code calls ABI function write, so you must&#13;
// preserve all the volatile registers.&#13;
&#13;
            stp     x0, x1, [fp, #print.x0X1Save]&#13;
            stp     x2, x3, [fp, #print.x2X3Save]&#13;
            stp     x4, x5, [fp, #print.x4X5Save]&#13;
            stp     x6, x7, [fp, #print.x6X7Save]&#13;
            stp     x8, x9, [fp, #print.x8X9Save]&#13;
            stp     x10, x11, [fp, #print.x10X11Save]&#13;
            stp     x12, x13, [fp, #print.x12X13Save]&#13;
            stp     x14, x15, [fp, #print.x14X15Save]&#13;
&#13;
// Compute the length of the string immediately following&#13;
// the call to this procedure:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> mov     x1, lr              // Get pointer to string.&#13;
search4_0:  ldrb    w2, [x1], #1        // Get next char.&#13;
            cmp     w2,  #0             // At end of string?&#13;
            bne     search4_0           // If not, keep searching.&#13;
            sub     x2, x1, lr          // Compute string length.&#13;
&#13;
// LR now points just beyond the 0 byte. We need to&#13;
// make sure this address is 4-byte aligned:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> add     x1, x1, #3&#13;
            and     x1, x1, #-4         // 0xfff...fff0&#13;
&#13;
// X1 points just beyond the 0 byte and padding.&#13;
// Save it as the new return address:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> str     x1, [fp, #rtnAdrs]&#13;
&#13;
// Call write to print the string to the console.&#13;
//&#13;
// write(fd, bufAdrs, len);&#13;
//&#13;
// fd in X0 (this will be 1 for stdout)&#13;
// bufAdrs in X1&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_262" aria-label="262"/>// len in X2&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> mov     x0, #1         // stdout = 1&#13;
            mov     x1, lr         // Pointer to string&#13;
            bl      write&#13;
&#13;
// Restore the registers we used:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> ldp     x0, x1, [fp, #print.x0X1Save]&#13;
            ldp     x2, x3, [fp, #print.x2X3Save]&#13;
            ldp     x4, x5, [fp, #print.x4X5Save]&#13;
            ldp     x6, x7, [fp, #print.x6X7Save]&#13;
            ldp     x8, x9, [fp, #print.x8X9Save]&#13;
            ldp     x10, x11, [fp, #print.x10X11Save]&#13;
            ldp     x12, x13, [fp, #print.x12X13Save]&#13;
            ldp     x14, x15, [fp, #print.x14X15Save]&#13;
            leave                  // Return to caller.&#13;
            endp    print&#13;
&#13;
// Here is the asmMain function:&#13;
&#13;
            proc    asmMain, public&#13;
            enter   64&#13;
&#13;
// Demonstrate passing parameters in code stream&#13;
// by calling the print procedure:&#13;
&#13;
            bl      print&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> .asciz  "Hello, world!!\n"&#13;
&#13;
            leave   // Returns to caller&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> procedure <span class="CodeAnnotation" aria-label="annotation1">❶</span> saves all the registers it modifies (even the volatile registers, because the call to <span class="SANS_TheSansMonoCd_W5Regular_11">write()</span> might overwrite them). This is a normal assembly language convention, but it’s especially important for <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> because you want to be able to print (debug) messages without saving register values across your calls.</p>&#13;
<p class="TX">LR points at the string to print upon entry into the <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> procedure <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This code scans through that string to find the zero-terminating byte; this scan produces both the length and the (approximate) return address.</p>&#13;
<p class="TX">Because code must be aligned on a 4-byte boundary, the return address isn’t necessarily the byte after the zero-terminating byte. Instead, the code may need to pad the end of string pointer by 1 to 3 bytes to advance to the next word boundary in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Adding <span class="SANS_TheSansMonoCd_W5Regular_11">3</span> and then ANDing the result with 0xFFFFFFFFFFFFFFFC (<span class="SANS_TheSansMonoCd_W5Regular_11">-4</span>) pads the return address up to the appropriate boundary. The code then stores the return address over the original on the stack <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">Once you have the string length, you can call the C stdlib <span class="SANS_TheSansMonoCd_W5Regular_11">write</span> function to print it <span class="CodeAnnotation" aria-label="annotation5">❺</span> (if the first argument is <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, this prints the string to the standard output device). On exit, the code restores the registers you saved earlier <span class="CodeAnnotation" aria-label="annotation6">❻</span>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_263" aria-label="263"/>For this listing, I included two exclamation marks <span class="CodeAnnotation" aria-label="annotation7">❼</span> so that the length of the string (including the zero-terminating byte) is a multiple of four characters. This ensures that the following instruction is aligned on a 4-byte boundary.</p>&#13;
<p class="TX">To avoid a bus fault, the length of the data following the call to <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> must be a multiple of 4 bytes so that the next instruction is properly aligned on a 4-byte boundary. The length of the string itself doesn’t have to be a multiple of 4 bytes; arbitrary padding after the zero-terminating byte is fine. Rather than counting the number of characters in the string, you could use the Gas <span class="SANS_TheSansMonoCd_W5Regular_11">.p2align</span> directive. This directive will pad the location counter to a boundary that is a multiple of 2<i><sup>n</sup></i> bytes, where <i>n</i> is the (first) value in the <span class="SANS_TheSansMonoCd_W5Regular_11">.p2align</span> operand field. For example</p>&#13;
<pre id="pre-388"><code>.p2align 2</code></pre>&#13;
<p class="Continued1">pads the location counter to the next word boundary.</p>&#13;
<p class="TX">Using the <span class="SANS_TheSansMonoCd_W5Regular_11">.p2align 2</span> directive, you can call the print procedure with an arbitrary-length string as follows:</p>&#13;
<pre id="pre-389"><code>bl        print&#13;
.asciz    "Hello, world!\n"&#13;
.p2align  2</code></pre>&#13;
<p class="TX">Remembering to put the <span class="SANS_TheSansMonoCd_W5Regular_11">.p2align 2</span> directive in the code can be difficult, not to mention that having to type it is a pain, and it clutters up your code. To resolve this, the <i>aoaa.inc</i> include file includes a <span class="SANS_TheSansMonoCd_W5Regular_11">wastr</span> (word-aligned string) macro that automatically adds the padding for you:</p>&#13;
<pre id="pre-390"><code>bl       print&#13;
wastr    "Hello, world!\n"</code></pre>&#13;
<p class="TX">Besides showing how to pass parameters in the code stream, the <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> routine also exhibits another concept: <i>variable-length parameters</i> (the length of the string can be arbitrarily long). The string following the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> can be any practical length. The zero-terminating byte marks the end of the parameter list. You can handle variable-length parameters in two easy ways: either use a special terminating value (like 0) or pass a special length value that tells the subroutine the number of parameters you are passing. Both methods have advantages and disadvantages.</p>&#13;
<p class="TX">Using a special value to terminate a parameter list requires that you choose a value that never appears in the list. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> uses <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> as the terminating value, so it cannot print the NUL character (whose ASCII code is 0). Sometimes this isn’t a limitation. Specifying a length parameter is another mechanism you can use to pass a variable-length parameter list. While this doesn’t require any special codes or limit the range of possible values that can be passed to a subroutine, setting up the length parameter and maintaining the resulting code can be a real nightmare; this is especially true if the parameter list changes frequently.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_264" aria-label="264"/>Despite the convenience afforded by passing parameters in the code stream, this method also has disadvantages. First, if you fail to provide the exact number of parameters the procedure requires, the subroutine will get confused. Consider the <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> example. It prints a string of characters up to a zero-terminating byte and then returns control to the first instruction following that byte. If you leave off the zero-terminating byte, the <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> routine happily prints the following opcode bytes as ASCII characters until it finds a 0 byte. Because 0 bytes often appear in the middle of an instruction, the <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> routine might return control into the middle of another instruction, which will probably crash the machine.</p>&#13;
<p class="TX">On the ARM, you must ensure that the parameters you pass in the code stream are a multiple of 4 bytes long. The instructions following the parameters must lie on a word boundary. Problems notwithstanding, however, the code stream is an efficient place to pass parameters whose values do not change.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h5 class="H3" id="sec21"><span class="SANS_Futura_Std_Bold_Condensed_B_11">5.6.3.3 Passing Parameters on the Stack</span></h5>&#13;
<p class="TNI1">Most HLLs use the stack to pass a large number of parameters because this method is fairly efficient. Although passing parameters on the stack is slightly less efficient than doing so in registers, the register set is limited (especially if you’re limiting yourself to the eight registers the ARM ABI sets aside for this purpose). The stack, on the other hand, allows you to pass a large amount of parameter data without difficulty. This is the reason that most programs pass their parameters on the stack (at least, when passing more than eight parameters).</p>&#13;
<p class="TX">To manually pass parameters on the stack, push them immediately before calling the subroutine (just remember to keep the stack 16-byte aligned). The subroutine then reads this data from the stack memory and operates on it appropriately. Consider the following HLL function call:</p>&#13;
<pre id="pre-391"><code>CallProc(i,j,k);</code></pre>&#13;
<p class="TX">Because keeping SP aligned on a 16-byte boundary is crucial, you can’t simply push one argument at a time with a <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> instruction, nor can you push values smaller than 32 bits. Assuming that <span class="SANS_TheSansMonoCd_W5Regular_11">i</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">j</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> are 32-bit integers, you would need to somehow marshal them together into a 128-bit package (including an extra 32 bits of unused data) and push 16 bytes onto the stack. This is so inconvenient that ARM code almost never pushes individual (or even pairs of) register values onto the stack.</p>&#13;
<p class="TX">The common solution in ARM assembly language is first to drop the stack down by however many bytes you need (plus any padding, to make sure the stack is aligned properly), and then to simply store your parameters into the stack space so allocated. For example, to call <span class="SANS_TheSansMonoCd_W5Regular_11">CallProc</span>, you might use code like the following:</p>&#13;
<pre id="pre-392"><code>sub sp, sp, #16   // Allocate space for parameters.&#13;
str w0, [sp]      // Assume i is in W0,&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_265" aria-label="265"/>str w1, [sp, #4]  // j is in W1, and&#13;
str w2, [sp, #8]  // k is in W2.&#13;
bl  CallProc&#13;
add sp, sp, #16   // Caller must clean up stack.</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">sub</span> instruction allocates 16 bytes on the stack; you need only 12 for the three 32-bit parameters, but you must allocate 16 to keep the stack aligned.</p>&#13;
<p class="TX">The three <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> instructions store the parameter data (which is presumed to be in W0, W1, and W2 by this code) into the 12 bytes from SP + 0 through SP + 11. The <span class="SANS_TheSansMonoCd_W5Regular_11">CallProc</span> will simply ignore the extra 4 bytes allocated on the stack.</p>&#13;
<p class="TX">In this example, the three 32-bit integers are packed into memory, each consuming 4 bytes on the stack. So the <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> parameter is found at SP + 0, the <span class="SANS_TheSansMonoCd_W5Regular_11">j</span> parameter is found at SP + 4, and the <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> parameter is found at SP + 8 upon entry into <span class="SANS_TheSansMonoCd_W5Regular_11">CallProc</span> (see <a href="chapter5.xhtml#fig5-6">Figure 5-6</a>).</p>&#13;
<figure class="IMG"><img class="img7" id="fig5-6" src="../images/Figure5-6.jpg" alt="" width="919" height="425"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-6: Stack layout upon entry into</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">CallProc</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If your procedure includes the standard entry and exit sequences, you may directly access the parameter values in the activation record by indexing off the FP register. Consider the layout of the activation record for <span class="SANS_TheSansMonoCd_W5Regular_11">CallProc</span> that uses the following declaration:</p>&#13;
<pre id="pre-393"><code>proc  CallProc&#13;
enter 0         // No local variables&#13;
  .&#13;
  .&#13;
  .&#13;
leave&#13;
endp  CallProc</code></pre>&#13;
<p class="TX">At this point, <span class="SANS_TheSansMonoCd_W5Regular_11">i</span>’s value can be found at <span class="SANS_TheSansMonoCd_W5Regular_11">[FP, #16]</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">j</span>’s value can be found at <span class="SANS_TheSansMonoCd_W5Regular_11">[FP, #20]</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">k</span>’s value can be found at <span class="SANS_TheSansMonoCd_W5Regular_11">[FP, #24]</span> (see <a href="chapter5.xhtml#fig5-7">Figure 5-7</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_266" aria-label="266"/>&#13;
<figure class="IMG"><img class="img7" id="fig5-7" src="../images/Figure5-7.jpg" alt="" width="961" height="594"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 5-7:</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">CallProc</span> <span class="SANS_Futura_Std_Book_Oblique_11">activation record after standard entry sequence</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Within the <span class="SANS_TheSansMonoCd_W5Regular_11">CallProc</span> procedure, you can access the parameter values with these instructions:</p>&#13;
<pre id="pre-394"><code>ldr w0, [fp, #16]&#13;
ldr w1, [fp, #20]&#13;
ldr w2, [fp, #24]</code></pre>&#13;
<p class="TX">Of course, using magic numbers such as these to reference the parameter offsets is still a bad idea. It would be far better to use equates or, even better, create a declaration macro similar to <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">locals</span> to define the parameters for a procedure. The <i>aoaa.inc</i> file contains just such a macro: <span class="SANS_TheSansMonoCd_W5Regular_11">args</span> (and <span class="SANS_TheSansMonoCd_W5Regular_11">enda</span>). Listing 5-10 demonstrates the use of this macro.</p>&#13;
<pre id="pre-395"><code>// Listing5-10.S&#13;
//&#13;
// Accessing a parameter on the stack&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
            .data&#13;
value1:     .word   20&#13;
value2:     .word   30&#13;
pVar:       .word   .-.&#13;
&#13;
ttlStr:     .asciz  "Listing 5-10"&#13;
fmtStr1:    .asciz  "Value of parameter: %d\n"&#13;
&#13;
            .code&#13;
            .extern printf&#13;
&#13;
// getTitle&#13;
//&#13;
// Return program title to C++ program.&#13;
&#13;
            proc    getTitle, public&#13;
            lea     x0, ttlStr&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_267" aria-label="267"/>            ret&#13;
            endp    getTitle&#13;
&#13;
// valueParm&#13;
//&#13;
// Passed a single parameter (vp.theParm) by value&#13;
&#13;
            proc    valueParm&#13;
&#13;
            args    vp          // Declare the&#13;
            word    vp.theParm  // parameter.&#13;
            enda    vp&#13;
&#13;
            enter   64          // Alloc space for printf.&#13;
&#13;
// vparms macro accepts only global variables.&#13;
// Must copy parameter to that global to print it:&#13;
&#13;
            lea     x0, fmtStr1&#13;
            ldr     w1, [fp, #vp.theParm]&#13;
            lea     x2, pVar&#13;
            str     w1, [x2]&#13;
            vparm2  pVar&#13;
            bl      printf&#13;
&#13;
            leave&#13;
            ret&#13;
            endp    valueParm&#13;
&#13;
// Here is the asmMain function:&#13;
&#13;
            proc    asmMain, public&#13;
            enter   64&#13;
&#13;
            lea     x0, value1&#13;
            ldr     w1, [x0]&#13;
            str     w1, [sp]        // Store parameter on stack.&#13;
            bl      valueParm&#13;
&#13;
            lea     x0, value2&#13;
            ldr     w1, [x0]&#13;
            str     w1, [sp]        // Store parameter on stack.&#13;
            bl      valueParm&#13;
&#13;
            leave&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">args</span> macro requires an argument list name, which can be the procedure name or an abbreviation of it, and an optional second argument with a starting offset. The second argument defaults to 16, which is an appropriate value if the procedure uses the standard entry sequence (pushing the LR and FP registers on the stack). Offsets associated with the parameters you declare are offsets from FP in the procedure.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_268" aria-label="268"/>Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for Listing 5-10:</p>&#13;
<pre id="pre-396"><code>% ./<span class="SANS_TheSansMonoCd_W7Bold_11">build Listing5-10</span>&#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing5-10</span>&#13;
Calling Listing5-10:&#13;
Value of parameter: 20&#13;
Value of parameter: 30&#13;
Listing5-10 terminated</code></pre>&#13;
<p class="TX">If your procedure does not use the standard entry sequence, you can specify an explicit offset as the second argument. For example:</p>&#13;
<pre id="pre-397"><code>args procName, 0</code></pre>&#13;
<p class="TX">If you aren’t pushing anything on the stack in the procedure (or allocating local variables), 0 is a good value to use; then the offsets are SP based rather than FP based.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h5 class="H3" id="sec22"><span class="SANS_Futura_Std_Bold_Condensed_B_11">5.6.3.4 Removing Parameters in Callee vs. Caller Stack Cleanup</span></h5>&#13;
<p class="TNI1">When passing parameters on the stack, ultimately those parameters must be removed from the stack. The ARM ABI specifies that the caller is responsible for removing all parameters it pushes onto the stack. Most of the example programs in this book thus far have (implicitly) done this.</p>&#13;
<p class="TX">Removing the parameters after every procedure call is slow and inefficient. Fortunately, an easy optimization eliminates the need to allocate and deallocate parameter storage for each function call. Upon entry into a procedure, when allocating storage for local variables, include additional storage to be used for parameters the procedure passes to other functions. This, in fact, has been the whole purpose of the “magic stack allocation” instructions at the beginning of most procedures in this book up to this point. The examples thus far have typically reserved 64 or 256 bytes of storage on the stack (enough for between eight and thirty-two 64-bit parameters, respectively).</p>&#13;
<p class="TX">Functions that pass parameters on the stack, such as <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> running on macOS, can store data into this area prior to calling the function. Upon return from the function, your code does not have to worry about cleaning up the parameters. That stack space is now available for the next function you want to call that requires stack parameters.</p>&#13;
<p class="TX">Ultimately, of course, the parameters must be deallocated from the stack. That happens when the procedure executes the <span class="SANS_TheSansMonoCd_W5Regular_11">leave</span> macro (or manually copies FP into SP, which is part of <span class="SANS_TheSansMonoCd_W5Regular_11">leave</span>’s expansion). When using <span class="SANS_TheSansMonoCd_W5Regular_11">enter</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">leave</span> to allocate this stack space for the parameters, along with any local variables a procedure might need, you need to allocate and deallocate the stack space only once, not for each individual procedure call.</p>&#13;
<p class="TX">If your procedure doesn’t have any local variables, you can easily allocate stack space for parameters by using code like the following:</p>&#13;
<pre id="pre-398"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_269" aria-label="269"/>proc  myProc&#13;
enter 64    // Allocate 64 bytes for parameter usage.&#13;
  .&#13;
  .&#13;
  .&#13;
leave       // Deallocate storage and returns.&#13;
endp  myProc</code></pre>&#13;
<p class="TX">If your procedure requires local variable storage, just specify the extra stack space as a dummy local variable at the end of your <span class="SANS_TheSansMonoCd_W5Regular_11">locals</span> declaration:</p>&#13;
<pre id="pre-399"><code>proc   myProc&#13;
&#13;
locals mp&#13;
word   mp.local1&#13;
dword  mp.local2&#13;
byte   mp.local3&#13;
byte   mp.stack, 64 // Allocate 64 bytes for parms.&#13;
endl   mp&#13;
&#13;
enter  mp.size      // Allocate locals and stack space.&#13;
  .&#13;
  .&#13;
  .&#13;
leave               // Deallocate storage and returns.&#13;
endp   myProc</code></pre>&#13;
<p class="TX">Remember that <span class="SANS_TheSansMonoCd_W5Regular_11">enter</span> always allocates a multiple of 16 bytes, so we know that the stack storage will be aligned on a 16-byte boundary.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h5 class="H3" id="sec23"><span class="SANS_Futura_Std_Bold_Condensed_B_11">5.6.3.5 Passing Parameters to the C/C++ printf() Function</span></h5>&#13;
<p class="TNI1">Under Linux, you pass the first eight <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> parameters in registers, just as you would any other nonvariadic function. On macOS, those parameters are always passed on the stack, each occupying a dword. Until now, this book has used the <span class="SANS_TheSansMonoCd_W5Regular_11">vparms</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span> macros to handle the difference in the way parameters are passed (and, of course, to avoid dealing with the stack, which the book hadn’t covered in the earlier chapters).</p>&#13;
<p class="TX">In this book, I strived to write code that is portable between Linux and macOS, resorting to OS-specific code only as necessary; this was part of the motivation for using the <span class="SANS_TheSansMonoCd_W5Regular_11">vparms</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span> macros when calling <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span>. Now that you’ve learned how these two OSes expect you to pass variadic parameters, you’ll probably want to pass parameters in a more flexible manner than using the <span class="SANS_TheSansMonoCd_W5Regular_11">vparms</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span> macros. Nevertheless, there is great benefit (at least for the source code in this book) to writing portable code. Fortunately, with a little sleight of hand, it is possible to directly pass the parameters to <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> without using <span class="SANS_TheSansMonoCd_W5Regular_11">vparms</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span> and still have the code assemble and run on both OSes.</p>&#13;
<p class="TX">The first rule is to load each <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> argument into X0 through X7. This puts the arguments into the locations where Linux expects them. Once the arguments are in these registers, you’ll also store them into the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_270" aria-label="270"/>stack storage area at SP + 0, SP + 8, SP + 16, ..., SP + 56 (which is where macOS expects them). Here’s a typical call to <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> printing the values in X0, X5, and X7:</p>&#13;
<pre id="pre-400"><code>locals mp&#13;
Byte   mp.stack, 24&#13;
endl   mp&#13;
 .&#13;
 .&#13;
 .&#13;
enter mp.size&#13;
 .&#13;
 .&#13;
 .&#13;
mov  x1, x0         // Put data in appropriate registers first.&#13;
mov  x2, x5&#13;
mov  x3, x7&#13;
lea  x0, fmtStr&#13;
str  x1, [sp]       // For macOS, store the arguments&#13;
str  x2, [sp, #8]   // onto the stack in their&#13;
str  x3, [sp, #16]  // appropriate locations.&#13;
bl   printf         // Then call printf.</code></pre>&#13;
<p class="TX">Strictly speaking, the <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> instructions aren’t necessary when running under Linux. To allow the creation of slightly more efficient code, I’ve provided the following <span class="SANS_TheSansMonoCd_W5Regular_11">mstr</span> macro in the <i>aoaa.inc</i> include file:</p>&#13;
<pre id="pre-401"><code>mstr register, memory</code></pre>&#13;
<p class="TX">This macro assembles to nothing under Linux and to the corresponding <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> instruction under macOS. If you rewrite the former code by using <span class="SANS_TheSansMonoCd_W5Regular_11">mstr</span>, it will not generate any excess code under Linux:</p>&#13;
<pre id="pre-402"><code>locals mp&#13;
Byte   mp.stack, 24&#13;
endl   mp&#13;
 .&#13;
 .&#13;
 .&#13;
enter mp.size&#13;
 .&#13;
 .&#13;
 .&#13;
mov  x1, x0         // Put data in appropriate registers first.&#13;
mov  x2, x5&#13;
mov  x3, x7&#13;
lea  x0, fmtStr&#13;
mstr x1, [sp]       // For macOS, store the arguments&#13;
mstr x2, [sp, #8]   // onto the stack in their&#13;
mstr x3, [sp, #16]  // appropriate locations.&#13;
bl   printf         // Then call printf.</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_271" aria-label="271"/>Of course, if you’re writing code only for Linux and don’t care at all about macOS portability, you can drop the <span class="SANS_TheSansMonoCd_W5Regular_11">mstr</span> instructions altogether to remove some clutter.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h4 class="H2" id="sec24"><span id="h2-103"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">5.6.4 Accessing Reference Parameters on the Stack</span></h4>&#13;
<p class="TNI1">Because you pass the addresses of objects as reference parameters, accessing the reference parameters within a procedure is slightly more difficult than accessing value parameters, as you must dereference the pointers to the reference parameters.</p>&#13;
<p class="TX">Consider Listing 5-11, which demonstrates a single pass-by-reference parameter.</p>&#13;
<pre id="pre-403"><code>// Listing5-11.S&#13;
//&#13;
// Accessing a reference parameter on the stack&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
            .data&#13;
value1:     .word   20&#13;
value2:     .word   30&#13;
&#13;
ttlStr:     .asciz  "Listing 5-11"&#13;
fmtStr1:    .asciz  "Value of reference parameter: %d\n"&#13;
&#13;
            .code&#13;
            .extern printf&#13;
&#13;
// getTitle&#13;
//&#13;
// Return program title to C++ program.&#13;
&#13;
            proc    getTitle, public&#13;
            lea     x0, ttlStr&#13;
            ret&#13;
            endp    getTitle&#13;
&#13;
// refParm&#13;
//&#13;
// Expects a pass-by-reference parameter on the stack&#13;
&#13;
            proc    refParm&#13;
&#13;
            args    rp&#13;
            dword   rp.theParm&#13;
            enda    rp&#13;
&#13;
            enter   64              // Alloc space for printf.&#13;
&#13;
            lea     x0, fmtStr1&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> ldr     x1, [fp, #rp.theParm]&#13;
            ldr     w1, [x1]&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_272" aria-label="272"/>          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> mstr    x1, [sp]&#13;
            bl      printf&#13;
&#13;
            leave&#13;
            endp    refParm&#13;
&#13;
// Here is the asmMain function:&#13;
&#13;
            proc    asmMain, public&#13;
            enter   64&#13;
&#13;
// Pass the address of the arguments on the&#13;
// stack to the refParm procedure:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> lea     x0, value1&#13;
            str     x0, [sp]        // Store address on stack.&#13;
            bl      refParm&#13;
&#13;
            lea     x0, value2&#13;
            str     x0, [sp]        // Store address on stack.&#13;
            bl      refParm&#13;
&#13;
            leave&#13;
&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">refParm</span> procedure fetches the reference parameter (a 64-bit pointer) into X1 <span class="CodeAnnotation">1</span> and then immediately dereferences this pointer by fetching the 32-bit word at the address in X1. The <span class="SANS_TheSansMonoCd_W5Regular_11">mstr</span> macro <span class="CodeAnnotation" aria-label="annotation2">❷</span> stores the second parameter onto the stack (under macOS). To pass a variable by reference to <span class="SANS_TheSansMonoCd_W5Regular_11">refParm</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>, you must compute its effective address and pass that.</p>&#13;
<p class="TX">Here is the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for the program in Listing 5-11:</p>&#13;
<pre id="pre-404"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing5-11</span>&#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing5-11</span>&#13;
Calling Listing5-11:&#13;
Value of reference parameter: 20&#13;
Value of reference parameter: 30&#13;
Listing5-11 terminated</code></pre>&#13;
<p class="TX">As you can see, accessing (small) pass-by-reference parameters is a little less efficient than accessing value parameters, because you need an extra instruction to load the address into a 64-bit pointer register (not to mention that you have to reserve a 64-bit register for this purpose). If you access reference parameters frequently, these extra instructions can really begin to add up, reducing the efficiency of your program.</p>&#13;
<p class="TX">Furthermore, it’s easy to forget to dereference a reference parameter and use the address of the value in your calculations. Therefore, unless you really need to affect the value of the actual parameter, you should use pass by value to pass small objects to a procedure.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_273" aria-label="273"/>Passing large objects, like arrays and records, is where using reference parameters becomes efficient. When passing these objects by value, the calling code has to make a copy of the actual parameter; if it is a large object, the copy process can be inefficient. Because computing the address of a large object is just as efficient as computing the address of a small scalar object, no efficiency is lost when passing large objects by reference. Within the procedure, you must still dereference the pointer to access the object, but the efficiency loss due to indirection is minimal when you contrast this with the cost of copying that large object.</p>&#13;
<p class="TX">Listing 5-12 demonstrates how to use pass by reference to initialize an array of structures.</p>&#13;
<pre id="pre-405"><code>// Listing5-12.S&#13;
//&#13;
// Passing a large object by reference&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
NumElements =       24&#13;
&#13;
// Here's the structure type:&#13;
&#13;
            struct  Pt&#13;
            byte    pt.x&#13;
            byte    pt.y&#13;
            ends    Pt&#13;
&#13;
            .data&#13;
&#13;
ttlStr:     .asciz  "Listing 5-12"&#13;
fmtStr1:    .asciz  "refArrayParm[%d].x=%d"&#13;
fmtStr2:    .asciz  "refArrayParm[%d].y=%d\n"&#13;
&#13;
            .code&#13;
            .extern printf&#13;
&#13;
// getTitle&#13;
//&#13;
// Return program title to C++ program.&#13;
&#13;
            proc    getTitle, public&#13;
            lea     x0, ttlStr&#13;
            ret&#13;
            endp    getTitle&#13;
&#13;
// refAryParm&#13;
//&#13;
// Passed the address of an array of Pt structures&#13;
// Initializes each element of that array&#13;
&#13;
            proc    refAryParm&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_274" aria-label="274"/>            args    rap&#13;
            dword   rap.ptArray     // Reference parameter&#13;
            enda    rap&#13;
&#13;
            enter   0               // No stack space needed!&#13;
&#13;
// Get the base address of the array into X1:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> ldr     x1, [fp, #rap.ptArray]&#13;
&#13;
// While X0 &lt; NumElements, initialize each&#13;
// array element. x = X0/8, y = X0 % 8:&#13;
&#13;
            mov     x0, xzr             // Index into array.&#13;
ForEachEl:  cmp     x0, #NumElements    // While we're not done&#13;
            bhs     LoopDone&#13;
&#13;
// Compute address of ptArray[X0].&#13;
// Element adrs = base address (X1) + index (X19) * size (2):&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> add     x3, x1, x0, lsl #1  // X3 = X1 + X0 * 2&#13;
&#13;
// Store index / 8 into x field:&#13;
&#13;
            lsr     x2, x0, #3          // X2 = X0 / 8&#13;
            strb    w2, [x3, #pt.x]     // ptArray[X0].x = X0/8&#13;
&#13;
// Store index % 8 (mod) into y field:&#13;
&#13;
            and     x2, x0, #0b111      // X2 = X0 % 8&#13;
            strb    w2, [x3, #pt.y]     // ptArray[X0].y = X0 % 8&#13;
&#13;
// Increment index and repeat:&#13;
&#13;
            add     x0, x0, #1&#13;
            b.al    ForEachEl&#13;
&#13;
LoopDone:   leave&#13;
            endp    refAryParm&#13;
&#13;
// Here is the asmMain function:&#13;
&#13;
            proc    asmMain, public&#13;
&#13;
// Easier to access local variables than globals, so let's&#13;
// make everything a local variable:&#13;
&#13;
            locals  am&#13;
            word    saveX19&#13;
            byte    Pts, NumElements * (Pt.size)&#13;
            byte    stackSpace, 64&#13;
            endl    am&#13;
&#13;
            enter   am.size             // Reserve space.&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_275" aria-label="275"/>            str     x19, [fp, #saveX19] // Save nonvolatile reg.&#13;
&#13;
// Initialize the array of points:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> add     x0, fp, #Pts    // Compute address of Pts.&#13;
            str     x0, [sp]        // Pass address on stack.&#13;
            bl      refAryParm&#13;
&#13;
// Display the array:&#13;
&#13;
            mov     x19, xzr        // X19 is loop counter.&#13;
dispLp:     cmp     x19, #NumElements&#13;
            bhs     dispDone&#13;
&#13;
// Print the x field:&#13;
&#13;
            lea     x0, fmtStr1&#13;
            mov     x1, x19&#13;
            mstr    x1, [sp]&#13;
            add     x3, fp, #Pts         // Get array base address.&#13;
            add     x3, x3, x19, lsl #1  // Index into array.&#13;
            ldrb    w2, [x3, #pt.x]      // Get ptArray[X0].x.&#13;
            mstr    x2, [sp, #8]&#13;
            bl      printf&#13;
&#13;
// Print the y field:&#13;
&#13;
            lea     x0, fmtStr2&#13;
            mov     x1, x19&#13;
            mstr    x1, [sp]&#13;
            add     x3, fp, #Pts         // Get array base address.&#13;
            add     x3, x3, x19, lsl #1  // Index into array.&#13;
            ldrb    w2, [x3, #pt.y]      // Get ptArray[X0].x.&#13;
            mstr    x2, [sp, #8]&#13;
            bl      printf&#13;
&#13;
// Increment index and repeat:&#13;
&#13;
            add     x19, x19, #1&#13;
            b.al    dispLp&#13;
&#13;
dispDone:&#13;
            ldr     x19, [fp, #saveX19]  // Restore X19.&#13;
            leave&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">The code computes the address of the <span class="SANS_TheSansMonoCd_W5Regular_11">Pts</span> array and passes this array (by reference) to the <span class="SANS_TheSansMonoCd_W5Regular_11">refAryParm</span> procedure <span class="CodeAnnotation" aria-label="annotation3">❸</span>. It loads this address into X1 <span class="CodeAnnotation" aria-label="annotation1">❶</span> and uses this pointer value as the base address of the array that <span class="SANS_TheSansMonoCd_W5Regular_11">refAryParm</span> processes <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output:</p>&#13;
<pre id="pre-406"><code><span class="SANS_TheSansMonoCd_W7Bold_11">$ ./build Listing5-12</span>&#13;
<span class="SANS_TheSansMonoCd_W7Bold_11">$ ./Listing5-12</span>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_276" aria-label="276"/>Calling Listing5-12:&#13;
refArrayParm[0].x=0 refArrayParm[0].y=0&#13;
refArrayParm[1].x=0 refArrayParm[1].y=1&#13;
refArrayParm[2].x=0 refArrayParm[2].y=2&#13;
refArrayParm[3].x=0 refArrayParm[3].y=3&#13;
refArrayParm[4].x=0 refArrayParm[4].y=4&#13;
refArrayParm[5].x=0 refArrayParm[5].y=5&#13;
refArrayParm[6].x=0 refArrayParm[6].y=6&#13;
refArrayParm[7].x=0 refArrayParm[7].y=7&#13;
refArrayParm[8].x=1 refArrayParm[8].y=0&#13;
refArrayParm[9].x=1 refArrayParm[9].y=1&#13;
refArrayParm[10].x=1 refArrayParm[10].y=2&#13;
refArrayParm[11].x=1 refArrayParm[11].y=3&#13;
refArrayParm[12].x=1 refArrayParm[12].y=4&#13;
refArrayParm[13].x=1 refArrayParm[13].y=5&#13;
refArrayParm[14].x=1 refArrayParm[14].y=6&#13;
refArrayParm[15].x=1 refArrayParm[15].y=7&#13;
refArrayParm[16].x=2 refArrayParm[16].y=0&#13;
refArrayParm[17].x=2 refArrayParm[17].y=1&#13;
refArrayParm[18].x=2 refArrayParm[18].y=2&#13;
refArrayParm[19].x=2 refArrayParm[19].y=3&#13;
refArrayParm[20].x=2 refArrayParm[20].y=4&#13;
refArrayParm[21].x=2 refArrayParm[21].y=5&#13;
refArrayParm[22].x=2 refArrayParm[22].y=6&#13;
rRefArrayParm[23].x=2 refArrayParm[23].y=7&#13;
Listing5-12 terminated</code></pre>&#13;
<p class="TX">This output shows how the <span class="SANS_TheSansMonoCd_W5Regular_11">refAryParm</span> procedure initialized the array.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h3 class="H1" id="sec25"><span id="h1-71"/><span class="SANS_Futura_Std_Bold_B_11">5.7 Functions and Function Return Results</span></h3>&#13;
<p class="TNI1"><i>Functions</i> are procedures that return a result to the caller. In assembly language, few syntactical differences exist between a procedure and a function. This is why <i>aoaa.inc</i> doesn’t provide a specific macro declaration for a function. Nevertheless, semantic differences exist; although you can declare them the same way in Gas, you use them differently.</p>&#13;
<p class="TX"><i>Procedures</i> are a sequence of machine instructions that fulfill a task. The end result of the execution of a procedure is the accomplishment of that activity. Functions, on the other hand, execute a sequence of machine instructions specifically to compute a value to return to the caller. Of course, a function can perform an activity as well, and procedures can undoubtedly compute values, but the main difference is that the purpose of a function is to return a computed result; procedures don’t have this requirement.</p>&#13;
<p class="TX">In assembly language, you don’t specifically define a function by using special syntax. In Gas, everything is a procedure. A section of code becomes a function when the programmer explicitly decides to return a function result via the procedure’s execution.</p>&#13;
<p class="TX">The registers are the most common place to return function results. The <span class="SANS_TheSansMonoCd_W5Regular_11">strlen()</span> routine in the C stdlib is a good example of a function that returns a value in one of the CPU’s registers. It returns the length of the string (whose address you pass as a parameter) in the X0 register.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_277" aria-label="277"/>By convention, programmers try to return 8-, 16-, and 32-bit results in the W0 register and 64-bit values in the X0 register. This is where most HLLs return these types of results, and it’s where the ARM ABI states that you should return function results. The exception is floating-point values; I discuss floating-point function results in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>.</p>&#13;
<p class="TX">There is nothing particularly sacred about the W0/X0 register. You can return function results in any register if it’s more convenient to do so. Of course, if you’re calling an ARM ABI–compliant function, such as <span class="SANS_TheSansMonoCd_W5Regular_11">strlen()</span>, you have no choice but to expect the function’s return result in the X0 register. The <span class="SANS_TheSansMonoCd_W5Regular_11">strlen()</span> function returns an integer in X0, for example.</p>&#13;
<p class="TX">If you need to return a function result that is larger than 64 bits, you obviously must return it somewhere other than in X0 (which can hold only 64-bit values). For values slightly larger than 64 bits (for example, 128 bits or maybe even as many as 256 bits), you can split the result into pieces and return those parts in two or more registers. It is not uncommon to see functions returning 128-bit values in the X1:X0 register pair. Just keep in mind that these schemes are not ARM ABI compliant, so they’re practical only when calling code you’ve written.</p>&#13;
<p class="TX">If you need to return a large object as a function result (say, an array of 1,000 elements), you obviously are not going to be able to return the function result in the registers. When returning function results greater than 64 bits, the ARM ABI specifies that the caller allocate storage for the result and pass a pointer to that storage in X8. The function places the result in that storage, and the caller retrieves the data from that location upon return.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h3 class="H1" id="sec26"><span id="h1-72"/><span class="SANS_Futura_Std_Bold_B_11">5.8 Recursion</span></h3>&#13;
<p class="TNI1"><i>Recursion</i> occurs when a procedure calls itself. The following, for example, is a recursive procedure:</p>&#13;
<pre id="pre-407"><code>proc  Recursive&#13;
enter 0&#13;
bl    Recursive&#13;
leave&#13;
endp  Recursive</code></pre>&#13;
<p class="TX">Of course, the CPU will never return from this procedure. Upon entry into <span class="SANS_TheSansMonoCd_W5Regular_11">Recursive</span>, this procedure will immediately call itself again, and control will never pass to the end of the procedure. In this case, runaway recursion results in a logical infinite loop that produces stack overflow, at which point the OS will raise an exception and stop the program.</p>&#13;
<p class="TX">Like a looping structure, recursion requires a termination condition in order to stop infinite recursion. <span class="SANS_TheSansMonoCd_W5Regular_11">Recursive</span> could be rewritten with a termination condition as follows:</p>&#13;
<pre id="pre-408"><code>          proc  Recursive&#13;
          enter 0&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_278" aria-label="278"/>          subs  x0, x0, #1&#13;
          beq   allDone&#13;
          bl    Recursive&#13;
allDone:&#13;
          leave&#13;
          endp  Recursive</code></pre>&#13;
<p class="TX">This modification to the routine causes <span class="SANS_TheSansMonoCd_W5Regular_11">Recursive</span> to call itself the number of times appearing in the X0 register. On each call, <span class="SANS_TheSansMonoCd_W5Regular_11">Recursive</span> decrements the X0 register by 1 and then calls itself again. Eventually, <span class="SANS_TheSansMonoCd_W5Regular_11">Recursive</span> decrements X0 to 0 and returns from each call until it returns to the original caller.</p>&#13;
<p class="TX">So far in this section, there hasn’t been a real need for recursion. After all, you could efficiently code this procedure as follows:</p>&#13;
<pre id="pre-409"><code>          proc  Recursive&#13;
          enter 0&#13;
iterLp:&#13;
          subs  x0, x0, #1&#13;
          bne   iterLp&#13;
          leave&#13;
          endp  Recursive</code></pre>&#13;
<p class="TX">Both of these last two examples would repeat the body of the procedure the number of times passed in the X0 register. (The latter version will do it considerably faster because it doesn’t have the overhead of the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instructions.) As it turns out, you cannot implement only a few recursive algorithms in an iterative fashion. However, many recursively implemented algorithms are more efficient than their iterative counterparts, and most of the time the recursive form of the algorithm is much easier to understand.</p>&#13;
<p class="TX">The <i>quicksort algorithm</i> is probably the most famous algorithm that usually appears in recursive form. Listing 5-13 shows a Gas implementation of this algorithm.</p>&#13;
<pre id="pre-410"><code>// Listing5-13.S&#13;
//&#13;
// Recursive quicksort&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
numElements =       10&#13;
&#13;
            .data&#13;
ttlStr:     .asciz  "Listing 5-13"&#13;
fmtStr1:    .asciz  "Data before sorting: \n"&#13;
fmtStr2:    .ascii  "%d"   // Use nl and 0 from fmtStr3&#13;
fmtStr3:    .asciz  "\n"&#13;
fmtStr4:    .asciz  "Data after sorting: \n"&#13;
fmtStr5:    .asciz  "ary=%p, low=%d, high=%d\n"&#13;
&#13;
theArray:   .word   1,10,2,9,3,8,4,7,5,6&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_279" aria-label="279"/>            .code&#13;
            .extern printf&#13;
&#13;
// getTitle&#13;
//&#13;
// Return program title to C++ program.&#13;
&#13;
            proc    getTitle, public&#13;
            lea     x0, ttlStr&#13;
            ret&#13;
            endp    getTitle&#13;
&#13;
// quicksort&#13;
//&#13;
// Sorts an array using the quicksort algorithm&#13;
//&#13;
// Here's the algorithm in C, so you can follow along:&#13;
//&#13;
// void quicksort(int a[], int low, int high)&#13;
// {&#13;
//     int i,j,Middle;&#13;
//     if(low &lt; high)&#13;
//     {&#13;
//         Middle = a[(low + high)/2];&#13;
//         i = low;&#13;
//         j = high;&#13;
//         do&#13;
//         {&#13;
//             while(a[i] &lt;= Middle) i++;&#13;
//             while(a[j] &gt; Middle) j--;&#13;
//             if(i &lt;= j)&#13;
//             {&#13;
//                 swap(a[i],a[j]);&#13;
//                 i++;&#13;
//                 j--;&#13;
//             }&#13;
//         } while(i &lt;= j);&#13;
//&#13;
//         // Recursively sort the two subarrays:&#13;
//&#13;
//         if(low &lt; j) quicksort(a,low,j);&#13;
//         if(i &lt; high) quicksort(a,i,high);&#13;
//     }&#13;
//}&#13;
//&#13;
// Args:&#13;
//    X19 (_a):       Pointer to array to sort&#13;
//    X20 (_lowBnd):  Index to low bound of array to sort&#13;
//    X21 (_highBnd): Index to high bound of array to sort&#13;
//&#13;
// Within the procedure body, these registers&#13;
// have the following meanings:&#13;
//&#13;
// X19: Pointer to base address of array to sort&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_280" aria-label="280"/>// X20: Lower bound of array (32-bit index)&#13;
// X21: Higher bound of array (32-bit index)&#13;
//&#13;
// X22: index (i) into array&#13;
// X23: index (j) into array&#13;
// X24: Middle element to compare against&#13;
//&#13;
// Create definitions for variable names as registers&#13;
// to make the code more readable:&#13;
&#13;
#define array x19&#13;
#define lowBnd x20&#13;
#define highBnd x21&#13;
#define i x22&#13;
#define j x23&#13;
#define middle w24&#13;
&#13;
            proc    quicksort&#13;
&#13;
            locals  qsl&#13;
            dword   qsl.saveX19&#13;
            dword   qsl.saveX20&#13;
            dword   qsl.saveX21&#13;
            dword   qsl.saveX22&#13;
            dword   qsl.saveX23&#13;
            dword   qsl.saveX24&#13;
            dword   qsl.saveX0&#13;
            byte    qsl.stackSpace, 32&#13;
            endl    qsl&#13;
&#13;
            enter   qsl.size&#13;
&#13;
// Preserve the registers this code uses:&#13;
&#13;
            str     x0, [fp, #qsl.saveX0]&#13;
            str     x19, [fp, #qsl.saveX19]&#13;
            str     x22, [fp, #qsl.saveX22]&#13;
            str     x23, [fp, #qsl.saveX23]&#13;
            str     x24, [fp, #qsl.saveX24]&#13;
&#13;
            cmp     lowBnd, highBnd&#13;
            bge     endif3&#13;
&#13;
            mov     i, lowBnd        // i = low&#13;
            mov     j, highBnd       // j = high&#13;
&#13;
// Compute a pivotal element by selecting the&#13;
// physical middle element of the array:&#13;
//&#13;
// Element address = ((i + j) / 2) * 4 (4 is element size)&#13;
//                 = ((i + j) * 2)&#13;
&#13;
            add     x0, i, j&#13;
            lsr     x0, x0, #1&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_281" aria-label="281"/>// Middle = ary[(i + j) / 2]:&#13;
&#13;
            ldr     middle, [array, x0, lsl #2]&#13;
&#13;
// Repeat until the i and j indices cross each&#13;
// other (i works from the start toward the end&#13;
// of the array, j works from the end toward the&#13;
// start of the array):&#13;
&#13;
rptUntil:&#13;
&#13;
// Scan from the start of the array forward,&#13;
// looking for the first element greater or equal&#13;
// to the middle element:&#13;
&#13;
            sub     i, i, #1        // To counteract add, below&#13;
while1:     add     i, i, #1        // i = i + 1&#13;
            ldr     w1, [array, i, lsl #2]&#13;
            cmp     middle, w1      // While middle &lt;= ary[i]&#13;
            bgt     while1&#13;
&#13;
// Scan from the end of the array backward, looking&#13;
// for the first element that is less than or equal&#13;
// to the middle element:&#13;
&#13;
            add     j, j, #1     // To counteract sub, below&#13;
while2:     sub     j, j, #1     // j = j - 1&#13;
            ldr     w1, [array, j, lsl #2]&#13;
            cmp     middle, w1   // while middle &gt;= a[j]&#13;
            blt     while2&#13;
&#13;
// If you've stopped before the two pointers have&#13;
// passed over each other, you have two&#13;
// elements that are out of order with respect&#13;
// to the middle element, so swap these two elements:&#13;
&#13;
            cmp     i, j        // If i &lt;= j&#13;
            bgt     endif1&#13;
&#13;
            ldr     w0, [array, i, lsl #2]&#13;
            ldr     w1, [array, j, lsl #2]&#13;
            str     w0, [array, j, lsl #2]&#13;
            str     w1, [array, i, lsl #2]&#13;
&#13;
            add     i, i, #1&#13;
            sub     j, j, #1&#13;
&#13;
endif1:     cmp     i, j        // Until i &gt; j&#13;
            ble     rptUntil&#13;
&#13;
// The code has just placed all elements in the array in&#13;
// their correct positions with respect to the middle&#13;
// element of the array. Unfortunately, the&#13;
// two halves of the array on either side of the pivotal&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_282" aria-label="282"/>// element are not yet sorted. Call quicksort recursively&#13;
// to sort these two halves if they have more than one&#13;
// element in them (if they have zero or one elements,&#13;
// they are already sorted).&#13;
&#13;
            cmp     lowBnd, j   // If lowBnd &lt; j&#13;
            bge     endif2&#13;
&#13;
            // Note: a is still in X19,&#13;
            // Low is still in X20.&#13;
&#13;
            str     highBnd, [fp, #qsl.saveX21]&#13;
            mov     highBnd, j&#13;
            bl      quicksort   // (a, low, j)&#13;
            ldr     highBnd, [fp, #qsl.saveX21]&#13;
&#13;
endif2:     cmp     i, highBnd  // If i &lt; high&#13;
            bge     endif3&#13;
&#13;
            // Note: a is still in X19,&#13;
            // High is still in X21.&#13;
&#13;
            str     lowBnd, [fp, #qsl.saveX20]&#13;
            mov     lowBnd, i&#13;
            bl      quicksort   // (a, i + 1, high)&#13;
            ldr     lowBnd, [fp, #qsl.saveX20]&#13;
&#13;
// Restore registers and leave:&#13;
&#13;
endif3:&#13;
            ldr     x0,  [fp, #qsl.saveX0]&#13;
            ldr     x19, [fp, #qsl.saveX19]&#13;
            ldr     x22, [fp, #qsl.saveX22]&#13;
            ldr     x23, [fp, #qsl.saveX23]&#13;
            ldr     x24, [fp, #qsl.saveX24]&#13;
            leave&#13;
            endp    quicksort&#13;
&#13;
// printArray&#13;
//&#13;
// Little utility to print the array elements&#13;
&#13;
            proc    printArray&#13;
&#13;
            locals  pa&#13;
            dword   pa.saveX19&#13;
            dword   pa.saveX20&#13;
            endl    pa&#13;
&#13;
            enter   pa.size&#13;
            str     x19, [fp, #pa.saveX19]&#13;
            str     x20, [fp, #pa.saveX20]&#13;
&#13;
            lea     x19, theArray&#13;
            mov     x20, xzr&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_283" aria-label="283"/>whileLT10:  cmp     x20, #numElements&#13;
            bge     endwhile1&#13;
&#13;
            lea     x0, fmtStr2&#13;
            ldr     w1, [x19, x20, lsl #2]&#13;
            mstr    w1, [sp]&#13;
            bl      printf&#13;
&#13;
            add     x20, x20, #1&#13;
            b.al    whileLT10&#13;
&#13;
endwhile1:  lea     x0, fmtStr3&#13;
            bl      printf&#13;
&#13;
            ldr     x19, [fp, #pa.saveX19]&#13;
            ldr     x20, [fp, #pa.saveX20]&#13;
            leave&#13;
            endp    printArray&#13;
&#13;
// Here is the asmMain function:&#13;
&#13;
            proc    asmMain, public&#13;
&#13;
            locals  am&#13;
            dword   am.savex19&#13;
            dword   am.savex20&#13;
            dword   am.savex21&#13;
            byte    am.stackSpace, 64&#13;
            endl    am&#13;
&#13;
            enter   am.size&#13;
&#13;
            str     array, [fp, #am.saveX19]&#13;
            str     lowBnd, [fp, #am.saveX20]&#13;
            str     highBnd, [fp, #am.saveX21]&#13;
&#13;
// Display unsorted array:&#13;
&#13;
            lea     x0, fmtStr1&#13;
            bl      printf&#13;
            bl      printArray&#13;
&#13;
// Sort the array:&#13;
&#13;
            lea     array, theArray&#13;
            mov     lowBnd, xzr               // low = 0&#13;
            mov     highBnd, #numElements - 1 // high = 9&#13;
            bl      quicksort                 // (theArray, 0, 9)&#13;
&#13;
// Display sorted results:&#13;
&#13;
            lea     x0, fmtStr4&#13;
            bl      printf&#13;
            bl      printArray&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_284" aria-label="284"/>            ldr     array, [fp, #am.saveX19]&#13;
            ldr     lowBnd, [fp, #am.saveX20]&#13;
            ldr     highBnd, [fp, #am.saveX21]&#13;
            leave&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and output for Listing 5-13:</p>&#13;
<pre id="pre-411"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing5-13</span>&#13;
$ ./<span class="SANS_TheSansMonoCd_W7Bold_11">Listing5-13</span>&#13;
Calling Listing5-13:&#13;
Data before sorting:&#13;
1&#13;
10&#13;
2&#13;
9&#13;
3&#13;
8&#13;
4&#13;
7&#13;
5&#13;
6&#13;
&#13;
Data after sorting:&#13;
1&#13;
2&#13;
3&#13;
4&#13;
5&#13;
6&#13;
7&#13;
8&#13;
9&#13;
10&#13;
&#13;
Listing5-13 terminated</code></pre>&#13;
<p class="TX">This output shows the contents of the array prior to sorting and after the quicksort procedure has sorted the array.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h3 class="H1" id="sec27"><span id="h1-73"/><span class="SANS_Futura_Std_Bold_B_11">5.9 Procedure Pointers and Procedural Parameters</span></h3>&#13;
<p class="TNI1">The ARM <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> instruction supports an indirect form: <span class="SANS_TheSansMonoCd_W5Regular_11">blr</span>. This instruction has the following syntax:</p>&#13;
<pre id="pre-412"><code>blr <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">64</span>  // Indirect call through <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">64</span></code></pre>&#13;
<p class="TX">This instruction fetches the address of a procedure’s first instruction from this specified register. It is equivalent to the following pseudo-instructions:</p>&#13;
<pre id="pre-413"><code>add lr, pc, #4  // Set LR to return address (PC is pointing at mov).&#13;
mov pc, <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">64     </span>// Transfer control to specified procedure.</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_285" aria-label="285"/>Gas treats procedure names like static objects. Therefore, you can compute the address of a procedure by using the <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> macro along with the procedure’s name. For example</p>&#13;
<pre id="pre-414"><code>lea x0, procName</code></pre>&#13;
<p class="Continued1">loads the address of the very first instruction of the <span class="SANS_TheSansMonoCd_W5Regular_11">procName</span> procedure into X0. The following code sequence winds up calling the <span class="SANS_TheSansMonoCd_W5Regular_11">procName</span> procedure:</p>&#13;
<pre id="pre-415"><code>lea x0, procName&#13;
blr x0</code></pre>&#13;
<p class="TX">Because the address of a procedure fits in a 64-bit object, you can store such an address into a double-word variable; in fact, you can initialize a double-word variable with the address of a procedure by using code like the following:</p>&#13;
<pre id="pre-416"><code>       proc  p&#13;
        .&#13;
        .&#13;
        .&#13;
       endp  p&#13;
        .&#13;
        .&#13;
        .&#13;
       .data&#13;
ptrToP:&#13;
       .dword  p&#13;
        .&#13;
        .&#13;
        .&#13;
       lea  x0, ptrToP&#13;
       ldr  x0, [x0]&#13;
       blr  x0    // Calls p if ptrToP has not changed</code></pre>&#13;
<p class="TX">Note that although macOS does not allow you to initialize a dword variable in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section with the address of an object outside the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section, it will allow you to initialize a pointer (in any section) with the address of some code within the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section.</p>&#13;
<p class="TX">As with all pointer objects, you should not attempt to indirectly call a procedure through a pointer variable unless you’ve initialized that variable with an appropriate address. You can initialize a procedure pointer variable in two ways: you can create dword variables with initializers in the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> sections, or you can compute the address of a routine (as a 64-bit value) and store that 64-bit address directly into the procedure pointer at runtime. The following code fragment demonstrates both ways to initialize a procedure pointer:</p>&#13;
<pre id="pre-417"><code>             .data&#13;
ProcPointer: .dword  p    // Initialize ProcPointer with&#13;
                          // the address of p.&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_286" aria-label="286"/>              .&#13;
              .&#13;
              .&#13;
             lea  x0, ProcPointer&#13;
             ldr  x0, [x0]&#13;
             blr  x0  // First invocation calls p.&#13;
&#13;
// Reload ProcPointer with the address of q:&#13;
&#13;
             lea  x0, q&#13;
             lea  x1, ProcPointer&#13;
             str  x0, [x1]&#13;
              .&#13;
              .&#13;
              .&#13;
             lea  x0, ProcPointer&#13;
             ldr  x0, [x0]&#13;
             blr  x0  // This invocation calls q.</code></pre>&#13;
<p class="TX">Although all the examples in this section use static variable declarations (<span class="SANS_TheSansMonoCd_W5Regular_11">.data</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span>), you aren’t limited to declaring simple procedure pointers in the static variable declaration sections. You can also declare procedure pointers (which are just dword variables) as local variables, pass them as parameters, or declare them as fields of a record or a union.</p>&#13;
<p class="TX">Procedure pointers are also invaluable in parameter lists. Selecting one of several procedures to call by passing the address of a procedure is a common operation. A <i>procedural parameter</i> is just a double-word parameter containing the address of a procedure, so passing a procedural parameter is really no different from using a local variable to hold a procedure pointer (except, of course, that the caller initializes the parameter with the address of the procedure to call indirectly).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h3 class="H1" id="sec28"><span id="h1-74"/><span class="SANS_Futura_Std_Bold_B_11">5.10 A Program-Defined Stack</span></h3>&#13;
<p class="TNI1">Using the pre- and post-indexed addressing modes, along with one of the ARM’s 64-bit registers, it is possible to create software-controlled stacks that don’t use the SP register. Since the ARM CPU provides a hardware stack pointer register, it may not be obvious why you’d consider using another stack. As you’ve learned, one limitation of the ARM’s hardware stack is that it must be 16-byte aligned at all times. Return addresses and other values you might want to preserve on the stack are generally 8 bytes or smaller. For example, you cannot push the LR register onto the stack by itself without causing a bus error fault. However, if you create your own stack, you won’t have this issue.</p>&#13;
<p class="TX">Perhaps you’re wondering why anyone would ever want to use a second stack in their programs. If the normal hardware stack works fine, why add the complexity of a second stack? Having two stacks is useful in several situations. Particularly, coroutines, generators, and iterators can make use of an extra stack pointer. See section 5.12, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="chapter5.xhtml#pg_290">page 290</a></span> for a Wikipedia link on this subject. Of course, as just pointed out, not having to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_287" aria-label="287"/>16-byte align the stack pointer is another good reason for using a program-defined stack.</p>&#13;
<p class="TX">Creating your own stack has two drawbacks: you must dedicate one of the ARM’s registers for this purpose, and you must explicitly allocate storage for that stack yourself (the OS automatically allocates the hardware stack when it runs your program).</p>&#13;
<p class="TX">You can easily allocate storage in the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> segment. A typical stack will have at least 128 to 256 bytes of storage. The following is a simple example that allocates a 256-byte stack:</p>&#13;
<pre id="pre-418"><code>             .data&#13;
smallStk:    .fill  256&#13;
endSmallStk:</code></pre>&#13;
<p class="TX">You may need more than 256 bytes of storage if you use automatic variables in your procedures; see section 5.4.1, <span class="Xref">“Activation Records,”</span> on <span class="Xref"><a href="chapter5.xhtml#pg_244">page 244</a></span> and section 5.5, <span class="Xref">“Local Variables,”</span> on <span class="Xref"><a href="chapter5.xhtml#pg_250">page 250</a></span>.</p>&#13;
<p class="TX">Normally, stacks start at the end of their allocated space in memory and grow downward toward smaller memory addresses. Having the <span class="SANS_TheSansMonoCd_W5Regular_11">endSmallStk</span> label at the end of the stack in this example gives you a handle with which to initialize your stack pointer.</p>&#13;
<p class="TX">Because the ARM uses SP for its hardware stack pointer, you must use a different register for your program-defined stack pointer. This needs to be a nonvolatile register—you don’t want a function call like <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> to mess with your stack. As X30 is already used for LR and X29 is reserved for FP (see <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>), X28 is a good choice for a user-defined stack pointer (USP). You can initialize it to point at the end of <span class="SANS_TheSansMonoCd_W5Regular_11">smallStk</span> as follows:</p>&#13;
<pre id="pre-419"><code>#define usp  x28   // Use a reasonable name for the user SP.&#13;
         .&#13;
         .&#13;
         .&#13;
        lea usp, endSmallStk</code></pre>&#13;
<p class="TX">This leaves USP pointing just beyond the end of the stack, which is exactly what you want; the stack pointer should point at the current top of the stack, and when the stack is empty, as it is after initialization, the stack pointer isn’t pointing at a valid stack address.</p>&#13;
<p class="TX">To push and pop data on the stack, use the same <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instructions, along with the pre-indexed and post-indexed addressing modes, just as you would with the hardware stack. The only differences are that you specify the USP register (X28) and you don’t have to keep the stack aligned to 16 bytes (in fact, you technically don’t have to keep it aligned to anything, but it will be faster if you keep it word or dword aligned). Here’s how you can push the LR register into the user stack and pop it off:</p>&#13;
<pre id="pre-420"><code>str lr, [usp, #-8]!  // Pre-decrement addressing mode&#13;
 .&#13;
 .&#13;
 .&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_288" aria-label="288"/>ldr lr, [usp], #8    // Post-increment addressing mode&#13;
ret</code></pre>&#13;
<p class="TX">Listing 5-14 is a rewrite of Listing 5-4 using a software stack.</p>&#13;
<pre id="pre-421"><code>// Listing5-14.S&#13;
//&#13;
// Demonstrating a software stack&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
#define usp x28     // Program-defined stack pointer&#13;
&#13;
stackSpace  =           64  // Space on the HW stack&#13;
saveLRUSP   =           48  // 16 bytes to hold LR and USP&#13;
&#13;
            .section    .rodata, ""&#13;
ttlStr:     .asciz      "Listing 5-14"&#13;
space:      .asciz      " "&#13;
asterisk:   .asciz      "*, %ld\n"&#13;
&#13;
            .data&#13;
loopIndex:  .dword       .-.     // Used to print loop index value&#13;
&#13;
// Here's the software-based stack this program will use&#13;
// to store return addresses and the like:&#13;
&#13;
            .align      3&#13;
smallStk:   .fill       256, .-.&#13;
endSmallStk:&#13;
&#13;
            .code&#13;
            .extern     printf&#13;
&#13;
// getTitle&#13;
//&#13;
// Return program title to C++ program.&#13;
&#13;
            proc    getTitle, public&#13;
            lea     x0, ttlStr&#13;
            ret&#13;
            endp    getTitle&#13;
&#13;
// print40Spaces&#13;
//&#13;
// Prints out a sequence of 40 spaces&#13;
// to the console display&#13;
&#13;
            proc    print40Spaces&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> stp     lr, x19, [usp, #-16]! // Preserve LR and X19.&#13;
&#13;
            mov     w19, #40&#13;
printLoop:  lea     x0, space&#13;
            bl      printf&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_289" aria-label="289"/>            subs    w19, w19, #1&#13;
            bne     printLoop // Until w19 == 0&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> ldp     lr, x19, [usp], #16 // Restore LR and X19.&#13;
            ret&#13;
            endp    print40Spaces&#13;
&#13;
// Here is the asmMain function:&#13;
&#13;
            proc    asmMain, public&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> sub     sp, sp, #stackSpace       // HW stack space&#13;
            stp     lr, usp, [sp, #saveLRUSP] // Save on HW stack.&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> lea     usp, endSmallStk   // Initialize USP.&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> str     x19, [usp, #-16]!  // Save X19 on SW stk.&#13;
&#13;
            mov     x19, #20&#13;
astLp:      bl      print40Spaces&#13;
            lea     x0, loopIndex&#13;
            str     x19, [x0]&#13;
            lea     x0, asterisk&#13;
            vparm2  loopIndex&#13;
            bl      printf&#13;
            subs    x19, x19, #1&#13;
            bne     astLp&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> ldr     x19, [usp], #16  // Restore from SW stack.&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> ldp     lr, usp, [sp, #saveLRUSP]&#13;
            add     sp, sp, #stackSpace&#13;
            ret     // Returns to caller&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">Upon entry into <span class="SANS_TheSansMonoCd_W5Regular_11">print40Spaces</span>, the code pushes LR and X19 onto the software stack <span class="CodeAnnotation" aria-label="annotation1">❶</span>, using an <span class="SANS_TheSansMonoCd_W5Regular_11">stp</span> instruction to save both registers at the same time. The pre-indexed addressing mode decrements USP by 16; then this instruction stores the two 8-bit registers on the software stack. Just before returning, <span class="SANS_TheSansMonoCd_W5Regular_11">print40Spaces</span> restores the LR and X19 registers from the software stack <span class="CodeAnnotation" aria-label="annotation2">❷</span>, using an <span class="SANS_TheSansMonoCd_W5Regular_11">lpd</span> instruction and the post-indexed addressing mode.</p>&#13;
<p class="TX">Although this program demonstrates using a software-controlled stack, it must still use the hardware stack for a couple of purposes. In particular, the <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> function will push its return address (and parameters, as it turns out) onto the hardware stack. Therefore, the main program sets up storage space on the hardware stack for this purpose <span class="CodeAnnotation" aria-label="annotation3">❸</span>. The program must also preserve the USP register (X28) before initializing it to point at the end of the <span class="SANS_TheSansMonoCd_W5Regular_11">smallStack</span> data area. The space just allocated on the hardware stack is the perfect place for this. As long as the code is saving USP there, it may as well save LR at the same time, since you must always write 16 bytes to the hardware stack.</p>&#13;
<p class="TX">Once the code has preserved USP’s value (because it is a nonvolatile register), the next step is to initialize USP with the address of the end of the <span class="SANS_TheSansMonoCd_W5Regular_11">smallStack</span> memory buffer <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Loading the address of <span class="SANS_TheSansMonoCd_W5Regular_11">endSmallStk</span> into <span role="doc-pagebreak" epub:type="pagebreak" id="pg_290" aria-label="290"/>USP accomplishes this. Once the stack is initialized, the code can use it; for example, this statement pushes nonvolatile register X19 onto the software stack <span class="CodeAnnotation" aria-label="annotation5">❺</span> (to preserve it for the C++ program).</p>&#13;
<p class="TX">Before leaving, the code pops the X19 nonvolatile register off the software stack to restore its value <span class="CodeAnnotation" aria-label="annotation6">❻</span>. Finally, the main program restores USP and LR from the hardware stack (and cleans up allocated storage) before returning to the C++ code <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<p class="TX">Just to prove it really works, here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for the program in Listing 5-14:</p>&#13;
<pre id="pre-422"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing5-14</span>&#13;
$ ./<span class="SANS_TheSansMonoCd_W7Bold_11">Listing5-14</span>&#13;
Calling Listing5-14:&#13;
                                        *, 20&#13;
                                        *, 19&#13;
                                        *, 18&#13;
                                        *, 17&#13;
                                        *, 16&#13;
                                        *, 15&#13;
                                        *, 14&#13;
                                        *, 13&#13;
                                        *, 12&#13;
                                        *, 11&#13;
                                        *, 10&#13;
                                        *, 9&#13;
                                        *, 8&#13;
                                        *, 7&#13;
                                        *, 6&#13;
                                        *, 5&#13;
                                        *, 4&#13;
                                        *, 3&#13;
                                        *, 2&#13;
                                        *, 1&#13;
Listing5-14 terminated</code></pre>&#13;
<p class="TX">As you can see, Listing 5-14 produces the same output as Listing 5-4.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h3 class="H1" id="sec29"><span id="h1-75"/><span class="SANS_Futura_Std_Bold_B_11">5.11 Moving On</span></h3>&#13;
<p class="TNI1">This chapter covered considerable material, including an introduction to assembly language programming style, basic Gas procedure syntax, local labels, calling and returning from procedures, register preservation, activation records, function results, and more. Armed with this information, you’re ready to learn how to write functions that calculate arithmetic results in the next chapter.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
&#13;
<h3 class="H1" id="sec30"><span id="h1-76"/><span class="SANS_Futura_Std_Bold_B_11">5.12 For More Information</span></h3>&#13;
<ul class="ul">&#13;
<li class="BL">For more details on the Creative Commons 4.0 Attribution license, see <i><a href="https://creativecommons.org/licenses/by/4.0/">https://<wbr/>creativecommons<wbr/>.org<wbr/>/licenses<wbr/>/by<wbr/>/4<wbr/>.0<wbr/>/</a></i>.</li>&#13;
<li class="BL"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_291" aria-label="291"/>The ARM developer site has more on the AARCH64 (ARM64) calling convention and ABI at <i><a href="https://github.com/ARM-software/abi-aa/releases">https://<wbr/>github<wbr/>.com<wbr/>/ARM<wbr/>-software<wbr/>/abi<wbr/>-aa<wbr/>/releases</a></i>.</li>&#13;
<li class="BL">Wikipedia provides a useful entry on coroutines, generators, and iterators at <i><a href="https://en.wikipedia.org/wiki/Coroutine">https://<wbr/>en<wbr/>.wikipedia<wbr/>.org<wbr/>/wiki<wbr/>/Coroutine</a></i>.</li>&#13;
</ul>&#13;
<aside class="box" aria-label="box-20">&#13;
<p class="BH" id="box-20"><span class="SANS_Dogma_OT_Bold_B_11">TEST YOURSELF</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  1.  Explain, step by step, how the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> <span class="SANS_Futura_Std_Book_11">instruction works.</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  2.  Explain, step by step, how the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> <span class="SANS_Futura_Std_Book_11">instruction works.</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  3.  What is the main disadvantage of caller preservation?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  4.  What is the main problem with callee preservation?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  5.  What is an activation record?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  6.  What register usually points at an activation record, providing access to the data in that record?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  7.  What is the standard entry sequence for a procedure (the instructions)?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  8.  What is the standard exit sequence for a procedure (the instructions)?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  9.  What is an automatic variable?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">10.  When does the system allocate storage for an automatic variable?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">11.  What value does a pass-by-value parameter pass to a function?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">12.  What value does a pass-by-reference parameter pass to a function?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">13.  When passing four integer parameters to a function, where does the ARM ABI state those parameters are to be passed?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">14.  When passing more than eight parameters to a function, where does the ARM ABI state the parameters will be passed?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">15.  What is the difference between a volatile and nonvolatile register in the ARM ABI?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">16.  Which registers are volatile in the ARM ABI?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">17.  Which registers are nonvolatile in the ARM ABI?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">18.  When passing parameters in the code stream, how does a function access the parameter data?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">19.  What is the best way to pass a large array to a procedure?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">20.  Where is the most common place to return a function result?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">21.  What is a procedural parameter?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">22.  How would you call a procedure passed as a parameter to a function/procedure?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">23.  If a procedure has local variables, what is the best way to preserve registers within that procedure?</span></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>