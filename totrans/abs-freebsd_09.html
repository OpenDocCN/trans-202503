<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_167"/><strong><span class="big">9</span><br/>SECURING YOUR SYSTEM</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">Securing your system means ensuring that your computer’s resources are used only by authorized people for authorized purposes. Even if you have no important data on your system, you still have valuable CPU time, memory, and bandwidth. Many folks who thought that their systems were too unimportant for anyone to bother breaking into found themselves an unwitting relay for an attack that disabled a major corporation. You don’t want to wake up one morning to the delightful sound of law enforcement agents kicking in your door because your insecure computer broke into a bank.</p>
<p class="indent">Sure, there are things worse than having some punk kid take over your servers—say, having the neighborhood loan shark break both your legs. Discovering that your organization’s web page now says, “Ha ha, you’ve been r00ted!” is a decent competitor for second place. Even more comprehensible intrusions cause huge headaches. Most of the actual intrusions I’ve been involved with (not as an attacker, but as a consultant to the victim) have originated from countries with government censorship, and traffic analysis <span epub:type="pagebreak" id="page_168"/>showed that the intruders were actually just looking for unrestricted access to news sites. While I fully sympathize with these people, when I’m depending upon the stable operation of my servers to run my business, their intrusion is unacceptable.</p>
<p class="indent">Over the last few years, taking over remote computers has become much easier. Point-and-click programs for subverting computers can be found through search engines. When one bright attacker writes an exploit, several thousand bored teenagers with nothing better to do can download it and make life difficult for the rest of us. Even if the data on your system is worthless, you must secure the system’s resources.</p>
<p class="indent">Generally speaking, operating systems are not broken into; the programs running on operating systems are. Even the most paranoiac, secure-by-default operating system in the world can’t protect badly written programs from themselves. Occasionally, one of those programs can interact with the operating system in such a way as to actually compromise the operating system. The most well-known of these are <em>buffer overflows</em>, where an intruder’s program is dumped straight into the CPU’s execution space and the operating system runs it. FreeBSD has undergone extensive auditing to eliminate buffer overflows as well as myriad other well-understood security issues, but that’s no guarantee that they’ve been eradicated. New functions and programs appear continuously, and they can interact with older functions and each other in unexpected ways.</p>
<p class="indent">FreeBSD provides many tools to help you secure your system against attackers, both internal and external. While no one of these tools is sufficient, all are desirable. Treat everything you learn about system security as a tool in a kit, not as the answer to all your problems. For example, while simply raising a system’s securelevel will not make your system secure, it can help when combined with reasonable permissions, file flags, regular patching, password control, and all the other things that make up a good security policy. We’ll cover more advanced security tools in <a href="ch19.xhtml#ch19">Chapter 19</a>, but without the basic protections discussed here, those tools won’t help secure your system.</p>
<h3 class="h3" id="lev267"><strong>Who Is the Enemy?</strong></h3>
<p class="noindent">We’ll arbitrarily lump potential attackers into four groups: script kiddies, disaffected users, botnets, and skilled attackers. You’ll find a more detailed classification in books dedicated to security, but that’s not what you’re here for. These categories are easily explained, easily understood, and include 99 percent of all the attackers you’re likely to encounter.</p>
<h4 class="h4" id="lev268"><strong><em>Script Kiddies</em></strong></h4>
<p class="noindent">The most numerous human attackers, <em>script kiddies</em>, are not sysadmins. They’re not skilled. They download attack programs that work on a point-and-click basis and go looking for vulnerable systems. They’re the equivalent of purse snatchers, preying upon old ladies holding their bags just a little bit too loosely. Fortunately, script kiddies are easy to defend against: just keep your software up-to-date and follow good computing practices. <span epub:type="pagebreak" id="page_169"/>Like locusts, script kiddies are easy to squash, but there are just so darned <em>many</em> of them!</p>
<h4 class="h4" id="lev269"><strong><em>Disaffected Users</em></strong></h4>
<p class="noindent">The second group, your own users, causes the majority of security problems. Your organization’s employees are the people most likely to know where the security gaps are, to feel that the rules don’t apply to them, and to have the time to spend breaking your security. If you tell an employee that company policy forbids him access to a computer resource, and if the employee feels that he should have access to it, he’s likely to search for a way around the restriction. Anyone who feels that he’s so fabulously special that the rules don’t apply to him is a security risk. Worse, when an employee who knows all the dirty laundry gets angry, bad things can happen. You might have all your servers patched and a downright misanthropic firewall installed, but if anyone who knows the password is <em>Current93</em> can dial the back room modem, you’re in trouble.</p>
<p class="indent">The best way to stop people like these is simply not to be sloppy. Don’t leave projects insecurely half-finished or half-documented. When someone leaves the company, disable his account, change all administrative passwords, inform all employees of that person’s departure, and remind them not to share confidential knowledge with that person. Have a computer security policy with real violation penalties and have HR enforce it. And get rid of the unsecured modem, the undocumented telnet server running on an odd port, or whatever hurried hack you put into place thinking that nobody would ever find it.</p>
<h4 class="h4" id="lev270"><strong><em>Botnets</em></strong></h4>
<p class="noindent">Botnets are more numerous than either of the above, but they’re not human. They’re machines compromised by malware and controlled from a central point. Botnets can include millions of machines. The malware authors control the botnets and use them for anything from searching for more vulnerable hosts to sending spam or breaking into secure sites. Most botnets are composed of Windows and Linux machines, but there’s no reason why FreeBSD operating systems can’t be assimilated into botnets.</p>
<p class="indent">Fortunately, botnet defense is much like script kiddie defense; keeping your software patched and following good computing practices goes a long way.</p>
<h4 class="h4" id="lev271"><strong><em>Motivated Skilled Attackers</em></strong></h4>
<p class="noindent">The most dangerous group—skilled attackers—are competent system administrators, security researchers, penetration specialists, and criminals who want access to your specific resources. Computer penetration is a lucrative criminal field these days, especially if the victim has resources that can be used for distributed denial-of-service (DDos) attacks or mass spam transmission. Compromising a web farm and turning it to evil is profitable. <span epub:type="pagebreak" id="page_170"/>If you have valuable company secrets, you might be targeted by one of these intruders. If one of these people <em>really</em> wants to break into your network, he’ll probably get there.</p>
<p class="indent">Still, security measures that stop the first three groups of people change the tactics of the skilled attacker. Instead of breaking into your computers over the network, he’ll have to show up at your door dressed as a telco repairman lugging a packet sniffer, or dumpster-dive searching for old sticky notes with scribbled passwords. This dramatically increases his risk, possibly making an intrusion more trouble than it’s worth. If you can make the intruder’s break-in plan resemble a Hollywood script <em>no matter how much he knows about your network</em>, your security is probably pretty good.</p>
<div class="sidebar">
<p class="sidebart"><strong>Hackers, Intruders, and Related Scum</strong></p>
<p class="spara">You’ll frequently hear the word <em>hacker</em> used to describe people who break into computers. This word has different meanings depending on the speaker. In the technical world, a hacker is someone who’s interested in the inner workings of technology. Some hackers are interested in everything; others have a narrow area of specialization. In the open source community, <em>hacker</em> is a title of respect. The main FreeBSD technical list is <em><a href="mailto:FreeBSD-hackers@FreeBSD.org">FreeBSD-hackers@FreeBSD.org</a></em>. In the popular media, however, a hacker is someone who breaks into computer systems, end of story.</p>
<p class="spara1">To reduce confusion, I recommend completely avoiding the word <em>hacker</em>. In this book, I call people who break into computers <em>intruders</em>.<a href="ch09.xhtml#ch09fn1aa" id="ch09fn1b">*</a> Technical wizards can be called by a variety of names, but they rarely object to “Oh Great and Powerful One.”</p>
<p class="sparaf"><a href="ch09.xhtml#ch09fn1b" id="ch09fn1aa">*</a> Two editions later, and my editor <em>still</em> won’t let me print what I call them in person.</p>
</div>
<h3 class="h3" id="lev272"><strong>FreeBSD Security Announcements</strong></h3>
<p class="noindent">The best defense against any attackers is to keep your system up to date. This means you must know when to patch your system, what to patch, and how. An outdated system is a script kiddie’s best friend.</p>
<p class="indent">The FreeBSD Project includes volunteers who specialize in auditing source code and watching for security issues with both the base operating system and add-on software. These developers maintain a very low-volume mailing list, <em><a href="mailto:FreeBSD-security-notifications@FreeBSD.org">FreeBSD-security-notifications@FreeBSD.org</a></em>, and subscribing is a good idea. While you can monitor other mailing lists for general announcements, the security notifications list is a single source for FreeBSD-specific information. To subscribe to the security notifications mailing list, see the instructions on <em><a href="http://lists.freebsd.org/">http://lists.freebsd.org/</a></em>. The FreeBSD security team releases advisories on that mailing list as soon as they’re available.</p>
<p class="indent"><span epub:type="pagebreak" id="page_171"/>Read advisories carefully and quickly act on those that affect you, as you can be certain that script kiddies are searching for vulnerable machines. FreeBSD makes applying security patches pretty easy, as <a href="ch18.xhtml#ch18">Chapter 18</a> discusses.</p>
<h3 class="h3" id="lev273"><strong>User Security</strong></h3>
<p class="noindent">Remember when I said that your own users are your greatest security risk? Here’s where you learn to keep the little buggers in line. FreeBSD has a variety of ways to allow users to do their work without giving them free rein on the system. We’ll look at the most important tools here, starting with adding users in the first place.</p>
<h4 class="h4" id="lev274"><strong><em>Creating User Accounts</em></strong></h4>
<p class="noindent">FreeBSD uses the standard Unix user management programs such as passwd(1), pw(8), and vipw(8). FreeBSD also includes a friendly interactive user-adding program, adduser(8). Only <em>root</em> may add users, of course. Just type <code>adduser</code> on the command line to enter an interactive shell.</p>
<p class="indent">The first time you run adduser(8), it prompts you to set appropriate defaults for all new user settings. Use the following example session to help you determine appropriate defaults for your system.</p>
<pre>   # <span class="codestrong1">adduser</span><br/><span class="ent">➊</span> Username: <span class="codestrong1">xistence</span><br/><span class="ent">➋</span> Full name: <span class="codestrong1">Bert Reger</span><br/><span class="ent">➌</span> Uid (Leave empty for default):</pre>
<p class="indent">The username <span class="ent">➊</span> is the name of the account. Users on my systems get a username of their first initial, middle initial, and last name. You can assign usernames by whatever scheme you dream up. Here, I let the user pick their own username, an indulgence I always later regret. The full name <span class="ent">➋</span> is the user’s real name. FreeBSD then lets you choose a numerical user ID (UID) <span class="ent">➌</span>. FreeBSD starts numbering UIDs at 1,000; while you can change this, all UIDs below 1,000 are reserved for system use. I recommend just pressing <small>ENTER</small> to take the next available UID.</p>
<pre><span class="ent">➊</span> Login group [xistence]: <br/><span class="ent">➋</span> Login group is xistence. Invite xistence into other groups? []: <span class="codestrong1">www</span><br/><span class="ent">➌</span> Login class [default]: <br/><span class="ent">➍</span> Shell (sh csh tcsh nologin) [sh]: <span class="codestrong1">tcsh</span><br/><span class="ent">➎</span> Home directory [/home/xistence]: <br/><span class="ent">➏</span> Home directory permissions (Leave empty for default):</pre>
<p class="indent">The user’s default group <span class="ent">➊</span> is important—remember, Unix permissions are set by owner and group. The FreeBSD default of having each user in their own group is usually the most sensible way for most setups. Any of the big thick books on system administration offers several grouping schemes—feel free to use whatever matches your needs. You can add this user to other groups <span class="ent">➋</span> in addition to the primary group at this time, if appropriate.</p>
<p class="indent"><span epub:type="pagebreak" id="page_172"/>A login class <span class="ent">➌</span> specifies what level of resources the user has access to. We’ll talk about login classes later in this section.</p>
<p class="indent">The shell <span class="ent">➍</span> is the command line environment. While the system default is <em>/bin/sh</em>, I prefer tcsh.<sup><a href="footnote.xhtml#ch09fn1" id="ch09fn1a">1</a></sup> If you’re deeply attached to another shell, feel free to use it instead. Knowledgeable users can change their own shells.</p>
<p class="indent">The home directory <span class="ent">➎</span> is where the user’s files reside on disk. The user and that user’s primary group own this directory. You can set custom permissions <span class="ent">➏</span> on the directory if you want, probably so that other users can’t view this user’s directory.</p>
<pre><span class="ent">➊</span> Use password-based authentication? [yes]: <br/><span class="ent">➋</span> Use an empty password? (yes/no) [no]: <br/><span class="ent">➌</span> Use a random password? (yes/no) [no]: <span class="codestrong1">y</span><br/><span class="ent">➍</span> Lock out the account after creation? [no]: <span class="codestrong1">n</span></pre>
<p class="indent">The password options give you a certain degree of flexibility. If all of your users are comfortable with key-based SSH authentication, perhaps you can get away without using passwords. In the meantime, the rest of us are stuck with passwords <span class="ent">➊</span>.</p>
<p class="indent">Use an empty password <span class="ent">➋</span> if you want the user to set his or her own password via the console. Whoever connects to that account first gets to set the password. This makes an empty password a good idea right up there with smoking inside a hydrogen dirigible.</p>
<p class="indent">A random password <span class="ent">➌</span>, on the other hand, is a good idea for a new account. The random password generator FreeBSD provides is good enough for day-to-day use. Random passwords are usually hard to remember, which encourages the user to change his password as soon as possible.</p>
<p class="indent">When an account is locked <span class="ent">➍</span>, nobody can use it to log in. This is generally counterproductive.</p>
<p class="indent">After entering all this information, adduser spits everything back at you for review and confirmation or rejection. Once you confirm, adduser verifies the account setup and provides you with the randomly generated password. It then creates the user’s home directory, copies the shell configuration files from <em>/etc/skel</em>, and asks whether you want to set up another user.</p>
<h4 class="h4" id="lev275"><strong><em>Configuring Adduser: /etc/adduser.conf</em></strong></h4>
<p class="noindent">Creating new users on some Unix systems requires you to manually edit <em>/etc/passwd</em>, rebuild the password database, edit <em>/etc/group</em>, create a home directory, set permissions on that home directory, install dotfiles, and so on. This makes handling your local customizations routine—if you set everything by hand, you can manage your local account setup easily. The adduser(8) program provides a set of sensible defaults. For sites with different requirements, <span epub:type="pagebreak" id="page_173"/><em>/etc/adduser.conf</em> lets you set those requirements as defaults while retaining the high degree of automation. To create <em>adduser.conf file</em>, run <code>adduser -C</code> and answer the questions.</p>
<pre><span class="ent">➊</span> Uid (Leave empty for default):<br/><span class="ent">➋</span> Login group []: <br/><span class="ent">➌</span> Enter additional groups []: <span class="codestrong1">staff</span><br/><span class="ent">➍</span> Login class [default]: <span class="codestrong1">staff</span><br/><span class="ent">➎</span> Shell (sh csh tcsh nologin) [sh]: <span class="codestrong1">tcsh</span><br/><span class="ent">➏</span> Home directory [/home/]: <span class="codestrong1">/nfs/u1/home</span> <br/><span class="ent">➐</span> Use password-based authentication? [yes]: <br/><span class="ent">➑</span> Use an empty password? (yes/no) [no]: <br/><span class="ent">➒</span> Use a random password? (yes/no) [no]: <span class="codestrong1">yes</span><br/><span class="ent">➓</span> Lock out the account after creation? [no]: <span class="codestrong1">no</span></pre>
<p class="indent">You might want to start numbering UIDs somewhere other than 1,000. If you want higher initial UIDs, enter it in the <code>Uid</code> space <span class="ent">➊</span>. Don’t start below 1,000.</p>
<p class="indent">The login group <span class="ent">➋</span> is the default user group. An empty login group means the user account defaults to having its own unique user group (the FreeBSD default).</p>
<p class="indent">You can specify any additional user groups <span class="ent">➌</span> that new accounts belong to by default, as well as the login class <span class="ent">➍</span>. I set both of these to <code>staff</code> so that all new users get added to that group and assigned that class.</p>
<p class="indent">Choose a default shell <span class="ent">➎</span> for your users.</p>
<p class="indent">Your home directory location <span class="ent">➏</span> might vary from the standalone FreeBSD standard. In this example, I’ve specified a typical style of NFS-mounted home directories used when many users have accounts on many machines.</p>
<p class="indent">Choose the default password behavior for new users. You can specify whether users should use passwords at all <span class="ent">➐</span> and whether the initial password should be empty <span class="ent">➑</span> or random <span class="ent">➒</span>.</p>
<p class="indent">Finally, dictate whether new accounts should default to being locked or not <span class="ent">➓</span>.</p>
<p class="indent">You’ll find more configuration settings in adduser.conf(5). While you can set account characteristics here, the format of this file is considered internal to adduser(8). The setting names can change with any FreeBSD release. To change <em>adduser.conf</em>, re-run <code>adduser -C</code>.</p>
<h4 class="h4" id="lev276"><strong><em>Editing Users</em></strong></h4>
<p class="noindent">Managing users isn’t just about creating and deleting accounts. You’ll need to change those accounts from time to time. While FreeBSD includes several tools for editing accounts, the simplest are passwd(1), chpass(1), vipw(8), and pw(8). These work on the tightly interrelated files <em>/etc/master.passwd</em>, <em>/etc/passwd</em>, <em>/etc/spwd.db</em>, and <em>/etc/pwd.db</em>. We’ll start with the files and then review the common tools for editing those files.</p>
<p class="indent">The files <em>/etc/master.passwd</em>, <em>/etc/passwd</em>, <em>/etc/spwd.db</em>, and <em>/etc/pwd.db</em> hold user account information. Each file has a slightly different format and purpose. The file <em>/etc/master.passwd</em> is the authoritative source of user account <span epub:type="pagebreak" id="page_174"/>information and includes user passwords in encrypted form. Normal users don’t have permission to view the contents of <em>/etc/master.passwd</em>. Regular users need access to basic account information, however; how else can unprivileged system programs identify users? The file <em>/etc/passwd</em> lists user accounts with all privileged information (such as the encrypted password) removed. Anyone can view the contents of <em>/etc/passwd</em> to get basic account information.</p>
<p class="indent">Many programs need account information, and parsing a text file is notoriously slow. In this day of laptop supercomputers, the word <em>slow</em> isn’t very meaningful, but this was a very real problem back when disco freely roamed the earth. For that reason, BSD-derived systems build a database file out of <em>/etc/master.passwd</em> and <em>/etc/passwd</em>. (Other Unix-like systems have similar functionality in different files.) The file <em>/etc/spwd.db</em> is taken directly from <em>/etc/master.passwd</em> and contains sensitive user information, but it can be read only by root. The file <em>/etc/pwd.db</em> can be read by anyone, but it contains the limited subset of information contained in <em>/etc/passwd</em>.</p>
<p class="indent">Any time any standard user management program changes the account information in <em>/etc/master.passwd</em>, FreeBSD runs pwd_mkdb(8) to update the other three files. For example, the three programs passwd(1), chpass(1), and vipw(8) all allow you to make changes to the master password file, and all three programs trigger pwd_mkdb to update the related files.</p>
<h5 class="h5" id="lev277"><strong>Changing a Password</strong></h5>
<p class="noindent">Use passwd(1) to change passwords. A user can change his own password, and root can change anyone’s password. To change your own password, just enter <code>passwd</code> at the command prompt.</p>
<pre># <span class="codestrong1">passwd</span><br/>Changing local password for mwlucas<br/>Old Password:<br/>New Password:<br/>Retype New Password:</pre>
<p class="indent">When changing your own password, passwd(1) first asks for your current password. This is to ensure that nobody else can change your password without your knowledge. It’s always good to log out when you walk away from your terminal, but when you don’t, this simple check in passwd(1) prevents practical jokers from really annoying you. Then enter your new password twice, and it’s done. When you’re the superuser and want to change another user’s password, just give the username as an argument to passwd.</p>
<pre># <span class="codestrong1">passwd mwlucas</span><br/>Changing local password for mwlucas<br/>New Password:<br/>Retype New Password:</pre>
<p class="indent">Note that root doesn’t need to know the user’s old password; the root user can change any user account on the system in any manner desired.</p>
<div class="sidebar">
<p class="sidebart"><span epub:type="pagebreak" id="page_175"/><strong>USER MANAGEMENT AND $EDITOR</strong></p>
<p class="spara">User management tools such as chpass and vipw (as well as many other system management tools) bring up a text editor window where you make your changes. These tools generally check the environment variable <code>$EDITOR</code> to see which text editor you prefer. <code>$EDITOR</code> lets you default to vi, Emacs, or any other editor installed. I recommend Vigor, a vi(1) clone with an animated-paperclip help system that might make users of older Microsoft Office versions feel more comfortable.</p>
</div>
<h5 class="h5" id="lev278"><strong>Changing Accounts with chpass(1)</strong></h5>
<p class="noindent">The account has more information associated with it than just the password. The chpass(1) utility lets users edit everything they can reach in their account. For example, if I run chpass(1) as a regular user, I get an editor with the following text:</p>
<pre>#Changing user information for mwlucas.<br/>Shell: /bin/tcsh<br/>Full Name: Michael W Lucas<br/>Office Location:<br/>Office Phone:<br/>Home Phone:<br/>Other information:</pre>
<p class="indent">I’m allowed to edit six informational fields in my account. The first, my shell, can be set to any shell listed in <em>/etc/shells</em> (see “<a href="ch09.xhtml#lev282">Shells and <em>/etc/shells</em></a>” on <a href="ch09.xhtml#page_178">page 178</a>). I can change my full name; perhaps I want my full middle name listed, or maybe I wish to be known to other system users as <em>Mr. Scabies</em>. I can update my office location and office phone so my coworkers can find me easily. This is another feature that was very useful on the university campuses where BSD grew up and where system users rarely had an idea of anyone’s physical location. Now that we have extensive online directories and many more computers, it’s less useful. I generally set my home phone number to 911 (999 in the UK), and I put a little bit of personal information in the <code>Other</code> space.</p>
<p class="indent">Also note what I <em>can’t</em> change as a regular user. The sysadmin sets my home directory, and I may not change it even if the system has a new hard drive with lots of empty space for my MP3 collection. My UID and GID numbers, similarly, are assigned by the system or the sysadmin.</p>
<p class="indent">On the other hand, if I run <code>chpass xistence</code>, its heightened privileges give me a very different view.</p>
<pre>   #Changing user information for xistence.<br/>   Login: xistence<br/><span class="ent">➊</span> Password: $6$D9b4FFD0kHK2sPSP$bXUFTQqV/QposXw2KTlswzpvoz4HBo8...<br/>   Uid [#]: 1001<br/><span epub:type="pagebreak" id="page_176"/>   Gid [# or name]: 1001<br/>   Change [month day year]:<br/>   Expire [month day year]:<br/>   Class:<br/>   Home directory: /home/xistence<br/>   Shell: /bin/tcsh<br/>   Full Name: Bert Regeer<br/>   Office Location:<br/>   Office Phone:<br/>   Home Phone:<br/>   Other information:</pre>
<p class="indent">As root, you can do anything you like to the poor user. Changing his login to <em>megaloser</em> is only the start of the havoc you can wreak. You even get access to the user’s hashed password <span class="ent">➊</span>. Don’t alter this field, unless you’re comfortable computing password hashes. Use passwd(1) to more safely and reliably change the user’s password. You can also change the user’s home directory, although chpass(1) doesn’t move the user’s files; you must copy them by hand.</p>
<p class="indent">You can also set a date for password changes and account expiration. Password expiration is useful if you’ve just changed a user’s password and you want him to change it upon his first login. Account expiration is useful when someone asks for an account but insists it’s needed only for a limited time. You can forget to go back to delete that account, but FreeBSD never forgets. Both of these fields take a date in the form <em>month day year</em>, but you need only the first three letters of the month. For example, to make a user’s password expire on June 8, 2028, I would enter <code>Jun 8 2028</code> in the <code>Change</code> space. Once the user changes his password, the password expiration field is blanked out again, but only the system administrator can extend an account expiration date.</p>
<h5 class="h5" id="lev279"><strong>The Big Hammer: vipw(8)</strong></h5>
<p class="noindent">While chpass(1) is fine for editing individual accounts, what happens when you must edit many accounts? Suppose your system has hundreds of users and a brand new hard disk for the home partition. Do you really want to run chpass(1) hundreds of times? That’s where vipw(8) comes in.</p>
<p class="indent">Directly edit <em>/etc/master.passwd</em> with vipw(8). When you finish your edits, vipw(8) checks the password file’s syntax to be sure you haven’t ruined anything. Then, it saves the new password file and runs pwd_mkdb(8). Although vipw(8) can protect your password file from many basic mistakes, if you’re clever, you can still muck things up. You must understand the format of the password file to use vipw(8) properly.</p>
<p class="indent">If the information in <em>/etc/master.passwd</em> conflicts with information in other files, <em>/etc/master.passwd</em> wins. For example, the primary group that appears in <em>/etc/master.passwd</em> is correct, even if <em>/etc/group</em> doesn’t show the user as a member. This “<em>master.passwd</em> is always correct” logic is deeply ingrained throughout user management.</p>
<p class="indent"><span epub:type="pagebreak" id="page_177"/>Each line in <em>/etc/master.passwd</em> is a single account record, containing 10 colon-separated fields. These fields are the following:</p>
<p class="noindentt"><strong>Username</strong></p>
<p class="hang">This field is either an account name created by the sysadmin or a username created at install time to provide some system service. FreeBSD includes users for system administration, such as root, daemon, games, and so on. Each of these users owns a part of the base system. FreeBSD also provides accounts for common services, such as the <em>www</em> user reserved for use by web servers. Add-on software might add its own system accounts as well.</p>
<p class="noindentt"><strong>Encrypted Password</strong></p>
<p class="hang">The second field is the encrypted password. System users don’t have a password, so you can’t log in as one of them. User accounts have a string of random-looking characters here.</p>
<p class="noindentt"><strong>User ID</strong></p>
<p class="hang">The third field is the <em>user ID number</em>, or <em>UID</em>. Every user has a unique UID.</p>
<p class="noindentt"><strong>Group ID</strong></p>
<p class="hang">Similarly, the fourth field is the <em>group ID number</em>, or <em>GID</em>. This is the user’s primary group. Usually this is identical to the UID, and the group has the same name as the username.</p>
<p class="noindentt"><strong>User’s Class</strong></p>
<p class="hang">The next field is the user’s class as defined in <em>/etc/login.conf</em> (see “<a href="ch09.xhtml#lev300">Restricting System Usage</a>” on <a href="ch09.xhtml#page_188">page 188</a>).</p>
<p class="noindentt"><strong>Password Expiration</strong></p>
<p class="hang">This field is the same as the password expiration date set via chpass(1), but here the time gets stored as seconds from the epoch. Use <code>date -j</code> and the <code>+%s</code> output format to generate epochal seconds from a real date. To convert midnight, June 1, 2018, to epochal seconds, run <code>date -j 201806010000 '+%s'</code>.</p>
<p class="noindentt"><strong>Account Expiration</strong></p>
<p class="hang">This field enables you to make the account shut itself off on a certain day. Just set the account expiration date as you would for password expiration.</p>
<p class="noindentt"><strong>Personal Data</strong></p>
<p class="hang">This field is also known as the <em>gecos</em> field for obscure historical reasons. It contains the user’s real name, office number, work phone number, and home phone number, all separated by commas. Do not use colons in this field; <em>/etc/master.passwd</em> reserves colons as a field delimiter.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_178"/><strong>User’s Home Directory</strong></p>
<p class="hang">The ninth field is the user’s home directory. While this defaults to <em>/home/&lt;username&gt;</em>, you can move this anywhere appropriate. You’ll also need to move the actual home directory and its files when you change this field. Users with a nonexistent home directory can’t log in by default, although the <code>requirehome</code> setting in <em>login.conf</em> can change this.</p>
<p class="noindentt"><strong>User’s Shell</strong></p>
<p class="hang">The final field is the user’s shell. If this field is empty, the system assigns the user the boring old <em>/bin/sh</em>.</p>
<p class="indentt">While chpass(1) lets you muck up individual user accounts, vipw(8) unleashes you on the entire userbase. Be careful with it!</p>
<h5 class="h5" id="lev280"><strong>Removing a User</strong></h5>
<p class="noindent">The rmuser(8) program deletes user accounts. You’ll be prompted for the username you want to delete and asked whether you want to remove that user’s home directory. That’s really all you have to do; destruction is much easier than creation, after all.</p>
<h5 class="h5" id="lev281"><strong>Scripting with pw(8)</strong></h5>
<p class="noindent">The pw(8) command provides a powerful command line interface to user accounts. While useradd(8) walks you through setting up an account in a friendly manner, pw(8) lets you specify everything on a single command line. I find pw(8) cumbersome for day-to-day use, but if you manage many user accounts, it’s invaluable.</p>
<p class="indent">One thing I do use pw(8) for is locking accounts. While a locked account is active, nobody can log in to it. I’ve used this to great effect when a client was behind on a bill; users call quite quickly when they can’t log in, and yet their websites continue to come up and their email continues to accumulate.</p>
<pre># <span class="codestrong1">pw lock xistence</span></pre>
<p class="indent">When Bert apologizes, I’ll unlock his account.</p>
<pre># <span class="codestrong1">pw unlock xistence</span></pre>
<p class="indent">If you need scripts to manage your users, definitely read the pw(8) man page.</p>
<h3 class="h3" id="lev282"><strong>Shells and /etc/shells</strong></h3>
<p class="noindent">The <em>shell</em> is the program that provides the user’s command prompt. Different shells behave differently and offer different shortcuts and features. Many people are very attached to particular shells and complain bitterly if their shell isn’t available on a system. The packages collection contains many shells.</p>
<p class="indent"><span epub:type="pagebreak" id="page_179"/>The file <em>/etc/shells</em> contains a list of all legitimate user shells. When you install a shell from a port or a package, it adds an appropriate entry in <em>/etc/shells</em>. If you compile your own shell from source, without using a FreeBSD port, you must list the shell by its complete path in <em>/etc/shells</em>.</p>
<p class="indent">The FTP daemon won’t allow a user to log in via FTP if his shell isn’t listed in <em>/etc/shells</em>. If you use <em>/sbin/nologin</em> as an FTP-only user shell, you must add it to this file, although a better way to handle such users is with login classes, as discussed later in this chapter.</p>
<h3 class="h3" id="lev283"><strong>root, Groups, and Management</strong></h3>
<p class="noindent">Unix security has been considered somewhat coarse because one superuser, <em>root</em>, can do anything. Other users are lowly peons who endure the shackles root places upon them. The problem is, root doesn’t have a wide variety of shackles on hand and can’t individualize them very well. While there’s some truth to this, a decent administrator can combine groups and permissions to handle almost any problem securely.</p>
<h4 class="h4" id="lev284"><strong><em>The root Password</em></strong></h4>
<p class="noindent">Certain actions require absolute control of the system, including manipulating core system files such as the kernel, device drivers, and authentication systems. Such activities are designed to be performed by root.</p>
<p class="indent">To use the root password, you can either log in as root at a console login prompt or, if you’re a member of the group wheel, log in as yourself and use the switch user command su(1). (We’ll discuss groups later in this section.) I recommend su; it logs who uses it and can be used on a remote system. The command is very simple to use:</p>
<pre># <span class="codestrong1">su</span><br/>Password:<br/>#</pre>
<p class="indent">Next, check your current user ID with the id(1) command:</p>
<pre># <span class="codestrong1">id</span><br/>uid=0(root) gid=0(wheel) groups=0(wheel), 5(operator)<br/>#</pre>
<p class="indent">You now own the system—and I do mean <em>own</em> it. Consider every keystroke; carelessness can return your hard drive to the primordial state of unformatted empty wasteland. And share the root password sparingly, if at all, because anyone who has the root password can inflict unlimited damage on the system.</p>
<p class="indent">Remember, only the users in the group <em>wheel</em> can use the root password to become root through su(1). Anyone can use the root password at the system console, which is why physical protection of your system is vital. If you give the root password to a regular user who doesn’t have physical <span epub:type="pagebreak" id="page_180"/>access to the console, they can type <code>su</code> and enter the root password as many times as they want, and it still won’t work.</p>
<p class="indent">This naturally leads to the question, “Who needs root access?” Much of the configuration discussed in this book requires use of the root password. Once you have the system running properly, you can greatly decrease or discontinue use of the root password. For those remaining tasks that absolutely require root privileges, I recommend the sudo package, and probably my book <em>Sudo Mastery</em> (Tilted Windmill Press, 2013). One of the simplest ways to reduce the need for root access is through the proper use of groups.</p>
<h4 class="h4" id="lev285"><strong><em>Groups of Users</em></strong></h4>
<p class="noindent">Unix-like operating systems classify users into <em>groups</em>, each group consisting of people who perform similar administrative functions. A sysadmin can define a group called <em>webmasters</em>, add the accounts of the people editing web pages to that group, and set the privileges on the web-related files so that the members of that group can edit those files. She can also create a group called <em>email</em>, add the email administrators to that group, and set the permissions of mail-related files accordingly. Using groups in this manner is a powerful and oft-neglected tool for system management.</p>
<p class="indent">Any user can identify the groups she belongs to with id(1). The preceding example showed that the user root is in the groups wheel and operator. Root is a special user, however, and can do anything she pleases. Here’s my account, which is a little more realistic for an average user:</p>
<pre># <span class="codestrong1">id</span><br/>uid=1001(mwlucas) gid=1001(mwlucas) groups=1001(mwlucas),0(wheel),68(dialer),1<br/>0001(webmaster)</pre>
<p class="indent">My UID is 1001, and my username is <em>mwlucas</em>. My GID, primary group ID, is 1001, and my primary group is named <em>mwlucas</em> as well. This is all pretty standard for the first user on a system, and even in later users, the only thing that changes is the numbers assigned to the account and primary group. More interesting is what other groups I’m assigned to: in addition to my primary group, I’m in the groups wheel, dialer, and webmaster. Wheel members may use the root password to become root, dialer members may use tip(1) without becoming root, and webmaster members can edit the web files on the local system. Each of these groups has special privileges on my system, and as a member of those groups, I inherit those privileges.</p>
<p class="indent">Group information is defined in <em>/etc/group</em>.</p>
<h5 class="h5" id="lev286"><strong>/etc/group</strong></h5>
<p class="noindent">The file <em>/etc/group</em> contains all group information except for the user’s primary group (which is defined with the user account in <em>/etc/master.passwd</em>). Each line in <em>/etc/group</em> contains four colon-delimited fields: the group name, the group password, the group ID number, and a list of members.</p>
<p class="indent"><span epub:type="pagebreak" id="page_181"/>Here’s a sample entry:</p>
<pre>wheel:*:0:root,mwlucas,xistence</pre>
<p class="indent">The group name is a human-friendly name for the group. This group is named <em>wheel</em>. Group names are arbitrary; you can call a group of users <em>lackeys</em> if you wish. Choose group names that give you an idea of what the groups are for; while you might remember that your lackeys may edit the company web page, will your coworkers understand that?</p>
<p class="indent">The second field, the group password, was a great idea that turned out to be a security nightmare. Modern Unix-like systems don’t do anything with the group password, but the field remains because old programs expect to find something in this space. The asterisk is a placeholder to placate such software.</p>
<p class="indent">The third field gives the group’s unique numeric group ID (GID). Many programs use the GID rather than name to identify a group. The wheel group has a GID of 0, and the maximum GID is 65535.</p>
<p class="indent">Last is a comma-delimited list of all users in the group. The users <em>root</em>, <em>mwlucas</em>, and <em>xistence</em> are members of the group wheel.</p>
<h5 class="h5" id="lev287"><strong>Changing Group Memberships</strong></h5>
<p class="noindent">If you want to add a user to a group, add his username to the end of the line for that group. For example, the wheel group is the list of users that may use the root password. Here, I add <em>rwatson</em> to the wheel group:</p>
<pre>wheel:*:0:root,mwlucas,xistence,rwatson</pre>
<p class="indent">Mind you, the odds of me convincing rwatson (leading security researcher and ex–FreeBSD Foundation President) to assume sysadmin duties on any of my systems range from negligible to nonexistent, but it’s worth a try.</p>
<h5 class="h5" id="lev288"><strong>Creating Groups</strong></h5>
<p class="noindent">To create a new group, you need only a name for the group and a group ID number. Technically, you don’t even need a member for the group; some programs run as members of a group, and FreeBSD uses the group permissions to control those programs just as the users are controlled.</p>
<p class="indent">Traditionally, GIDs are assigned the next number up the list. GID is an arbitrary number between 0 and 65535. Generally speaking, GIDs below 1000 are reserved for operating system usage. Programs that need a dedicated group ID usually use one in this range. User accounts start numbering their GIDs at 1001 and go up. Some special groups might start numbering at 65535 and go down.</p>
<h4 class="h4" id="lev289"><span epub:type="pagebreak" id="page_182"/><strong><em>Using Groups to Avoid Root</em></strong></h4>
<p class="noindent">In addition to being a security concern, the root password distribution policy can cause dissension in any organization. Many sysadmins refuse to share the root password with people who’re responsible for maintaining part of the system but don’t offer an alternative and thereby prevent people from doing their job. Other sysadmins hand out root to dang near anyone who wants it and then complain when the system becomes unstable. Both attitudes are untenable in the long run. Personally, I don’t want root on your system. While having root privileges can be convenient, a lack of responsibility when the system breaks is more convenient.</p>
<p class="indent">One common situation is where a junior sysadmin is responsible for a particular portion of the system. I’ve had many DNS administrators work under me;<sup><a href="footnote.xhtml#ch09fn2" id="ch09fn2a">2</a></sup> these people don’t ever install software, recompile the kernel, or perform other sysadmin tasks. They only answer emails, update zone files, and reload the named daemon. New sysadmins often believe they need root access to do this sort of work. Nope. You can use groups.</p>
<p class="indent">Establishing your own groups, consisting of people who perform similar administrative functions, lets you avoid distributing the root password and still allow people to do their work. In this section, we’ll implement group-level access control over nameserver files. The same principles apply to any files you choose to protect. Mail and web configuration files are other popular choices for group-based management.</p>
<h5 class="h5" id="lev290"><strong>System Accounts</strong></h5>
<p class="noindent">FreeBSD reserves some user account names for integrated programs. We discuss these unprivileged accounts in <a href="ch19.xhtml#ch19">Chapter 19</a>. For example, the nameserver runs under the user account bind and the group bind. If an intruder compromises the nameserver, she can access the system only with the privileges of the user bind.</p>
<p class="indent">Don’t have users log in as these users. They’re not set up as interactive accounts by design. What’s more, do not allow the group of the system account user to own the files created for that function. Create a separate user and group to own program files. That way, our hypothetical intruder can’t even edit the files used by the DNS server, further minimizing potential damage. If the program regularly updates the files (e.g., a database’s backend storage), you must give the program access rights, but chances are that a human being doesn’t ever need to edit that file. Similarly, there’s no reason a database should be able to edit its own configuration file.</p>
<h5 class="h5" id="lev291"><strong>Administrative Group Creation</strong></h5>
<p class="noindent">The simplest way to create a group that owns files is to employ adduser(8) to make a user that owns them and then to utilize that user’s primary group as the group for the files. Because we already have a user called <em>bind</em>, we’ll <span epub:type="pagebreak" id="page_183"/>create an administrative user <em>dns</em>. The username isn’t important, but you should choose a name that everyone will recognize.</p>
<p class="indent">Give your administrative user a shell of <em>nologin</em>, which sets a shell of <em>/sbin/nologin</em>. This prevents anyone from actually logging in as the administrative user.</p>
<p class="indent">If you want, you could specify a particular UID and GID for these sorts of users. I’ve been known to choose UID and GID numbers that resemble those used by their related service accounts. For example, the user bind has a UID and GID of 53. I could give the user dns a UID of 10053 to make it easily recognizable. At other times, I start numbering my administrative groups at 65535 and work my way down. It doesn’t matter as long as I’m completely consistent within an organization.</p>
<p class="indent">Do not add this administrative user to any other groups. Under no circumstances add this user to a privileged group, such as wheel!</p>
<p class="indent">Every user needs a home directory. For an administrative user, a home directory of <em>/nonexistent</em> works well. This user’s files are elsewhere in the system, after all.</p>
<p class="indent">Lastly, let adduser(8) disable the account. While the shell prevents logins, an extra layer of defense won’t hurt.</p>
<p class="indent">Now that you have an administrative user and a group, you can assign ownership of files to that user. A user and a group own every file. You can see existing file ownership and permissions with <code>ls -l</code>. (If you’ve forgotten how Unix permissions work, read ls(1) and chmod(1).) Many sysadmins pay close attention to file owners, somewhat less attention to worldwide permissions, and only glance at the group permissions.</p>
<pre># <span class="codestrong1">ls -l</span><br/>total 3166<br/>-rw-r-----  1 mwlucas  mwlucas    79552 Nov 11 17:58 rndc.key<br/>-rw-rw-r--  1 mwlucas  mwlucas  3131606 Nov 11 17:58 mwl.io.db</pre>
<p class="indent">Here, I’ve created two files. The first file, <em>rndc.key</em>, can be read and written by the user <em>mwlucas</em>. It can be read by anyone in the group <em>mwlucas</em>, but no one else can do anything with it. The file <em>mwl.io.db</em> can be read or written by the user <em>mwlucas</em> or anyone in the group <em>mwlucas</em>, but others can only read the file. If you’re in the group <em>mwlucas</em>, you can edit the file <em>mwl.io.db</em> without becoming root.</p>
<p class="indent">Change a file’s owner and group with chown(1). You must know the name of the user and group whose ownership you want to change. In this case, we want to change both files to be owned by the user dns and the group dns.</p>
<pre># <span class="codestrong1">chown dns:dns rndc.key</span><br/># <span class="codestrong1">chown dns:dns mwl.io.db</span> <br/># <span class="codestrong1">ls -l</span><br/>total 3166<br/>-rw-r-----  1 dns  dns    79552 Nov 11 17:58 rndc.key<br/>-rw-rw-r--  1 dns  dns  3131606 Nov 11 17:58 mwl.io.db</pre>
<p class="indent"><span epub:type="pagebreak" id="page_184"/>These files are now owned by the user dns and the group dns. Anyone who is in the group dns can edit <em>mwl.io.db</em> without using the root password. Finally, this file can be read by the user bind, who runs the nameserver. Add your DNS administrators to the dns group in <em>/etc/group</em>, and abruptly they can do their jobs.</p>
<p class="indent">The DNS administrators might think they need the root password for restarting the nameserver program itself. However, this is easily managed with rndc(8). Other tasks can be managed with cron jobs or with the add-on program sudo(8).</p>
<p class="indent">If you don’t want an administrative user but only a group, use vigr(8) to edit <em>/etc/group</em>.</p>
<h5 class="h5" id="lev292"><strong>Interesting Default Groups</strong></h5>
<p class="noindent">FreeBSD ships with several default groups. Most are used by the system and aren’t of huge concern to a sysadmin—you should know that they’re there, but that’s different than working with them on a day-to-day basis. In <a href="ch09.xhtml#ch09tab1">Table 9-1</a>, I present for your amusement and edification the most useful, interesting, and curious of the default groups. Adding your own groups simplifies system administration, but the groups listed here are available on every FreeBSD system.</p>
<p class="tabcap" id="ch09tab1"><strong>Table 9-1:</strong> FreeBSD System Groups</p>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Group name</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Purpose</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">audit</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Users who can access audit(8) information</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">authpf</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Users who can authenticate to the PF packet filter</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">bin</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Group owner of general system programs</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">bind</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Group for the BIND DNS server software</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">daemon</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Used by various system services, such as the printing system</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">_dhcp</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">DHCP client operations</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">dialer</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Users who can access serial ports; useful for modems and tip(1)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">games</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Owner of game files</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">guest</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">System guests (almost never used)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">hast</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Files used by hastd(8)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">kmem</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Programs that can access kernel memory, such as fstat(1), netstat(1), and so on</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">mail</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Owner of the mail system</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">mailnull</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Default group for sendmail(8) or other mail server</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">man</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Owner of uncompressed man pages</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">network</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Owner of network programs like ppp(8)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">news</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Owner of the Usenet News software (probably not installed)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">nobody</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Primary group for unprivileged user nobody, intended for use by NFS</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">nogroup</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Group with no privileges, intended for use by NFS</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span epub:type="pagebreak" id="page_185"/>operator</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Users that can access drives, generally for backup purposes</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">_pflogd</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Group for PF logging</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">proxy</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Group for FTP proxy in PF packet filter</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">smmsp</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Group for Sendmail submissions</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">sshd</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Owner of the SSH server (see <a href="ch20.xhtml#ch20">Chapter 20</a>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">staff</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">System administrators (from BSD’s college roots, when users were staff, faculty, or students)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">sys</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Another system group</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">tty</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Programs that can write to terminals, like wall(1)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">unbound</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Files and programs related to the unbound(8) DNS server</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">uucp</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Group for programs related to the Unix-to-Unix Copy Protocol</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">video</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Group that can access DRM and DRI video devices</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">wheel</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Users who may use the root password</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">www</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Web server programs (not files)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba">_ypldap</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Files needed by the LDAP-backed YP server ypldap(8)</p></td>
</tr>
</tbody>
</table>
<p class="indent">I know very few people using either internet news or UUCP, and you might think you could reuse those groups for other purposes. You’re really better off creating a new group than risking confusion later, however. Group ID numbers are not in short supply.</p>
<h3 class="h3" id="lev293"><strong>Tweaking User Security</strong></h3>
<p class="noindent">You prevent any single user from utilizing too much memory, processor time, or other system resources by setting limits on the account. Now that even small computers have very fast processors and lots of memory, these limits aren’t as important, but it’s still very useful in systems with dozens or hundreds of users. You can also control where users may log in from.</p>
<h4 class="h4" id="lev294"><strong><em>Restricting Login Ability</em></strong></h4>
<p class="noindent">FreeBSD checks <em>/etc/login.access</em> every time a user tries to log in. If <em>login.access</em> contains rules that forbid logins from that user, the login attempt fails immediately. This file has no rules by default, meaning that anyone who provides a valid username and password has no restrictions.</p>
<p class="indent">The <em>/etc/login.access</em> file has three colon-delimited fields. The first either grants (<code>+</code>) or denies (<code>-</code>) the right to log in; the second is a list of users or groups; and the third is a list of connection sources. You can use an <code>ALL</code> or <code>ALL EXCEPT</code> syntax, which allows you to make simple but expressive rules. Rules are checked on a first-fit basis. When login(1) finds a rule where the user and the connection source match, the connection is immediately accepted or rejected, making rule order vital. The default is to allow logins.</p>
<p class="indent"><span epub:type="pagebreak" id="page_186"/>For example, to allow only members of the wheel group to log in from the system console, you might try this rule:</p>
<pre>+:wheel:console</pre>
<p class="indent">The problem with this rule, however, is that it doesn’t actually deny users login privileges. Since the default is to accept logins, and since all this rule does is explicitly grant login privileges to the users in the wheel group, nothing changes. Bert certainly isn’t in the wheel group, but if he tries to log in, no rule denies him access.</p>
<p class="indent">You could try two rules like this:</p>
<pre>+:wheel: console<br/>-:ALL:console</pre>
<p class="indent">This set of rules would achieve the desired effect but is longer than you need. Use <code>ALL EXCEPT</code> instead.</p>
<pre>-:ALL EXCEPT wheel: console</pre>
<p class="indent">This rule rejects unwanted logins most quickly and runs less risk of administrator error. As a rule, it’s best to build <em>login.access</em> lists by rejecting logins, rather than permitting them. FreeBSD immediately rejects nonwheel users at the console upon hitting this rule.</p>
<p class="indent">Change the default from “allow access” to “deny access” by adding a final rule.</p>
<pre>-:ALL:ALL</pre>
<p class="indent">Any login request that doesn’t match an earlier permit rule gets denied.</p>
<p class="indent">The last field in <em>login.access</em>, the connection source, can use hostnames, host addresses, network numbers, domain names, or the special values <code>LOCAL</code> and <code>ALL</code>. Let’s see how they work.</p>
<h5 class="h5" id="lev295"><strong>Hostnames</strong></h5>
<p class="noindent">Hostnames rely upon DNS or the hosts file. If you suspect that your nameserver might suffer an intrusion or attack, avoid hostnames; intruders can give a hostname any IP address that they like and fool your system into accepting the connection, and a nameserver failure could lock you out completely. Still, it’s possible to use a rule like this:</p>
<pre>-:ALL EXCEPT wheel:fileserver.mycompany.com</pre>
<p class="indent">Users in the wheel group can log in from the fileserver, but nobody else can.</p>
<h5 class="h5" id="lev296"><span epub:type="pagebreak" id="page_187"/><strong>Host Addresses and Networks</strong></h5>
<p class="noindent">Host addresses work like hostnames, but they’re immune to DNS failures or spoofing.</p>
<pre>-:ALL EXCEPT wheel:203.0.113.5</pre>
<p class="indent">A network number is a truncated IP address, like this:</p>
<pre>-:ALL EXCEPT wheel:203.0.113.</pre>
<p class="indent">This network number allows anyone in the wheel group to log in from a machine whose IP address begins with 203.0.113 and denies everyone else access from those IP addresses.</p>
<h5 class="h5" id="lev297"><strong>LOCAL</strong></h5>
<p class="noindent">The most complicated location is <code>LOCAL</code>, which matches any hostname without a dot in it (generally, only hosts in the local domain). For example, <em><a href="http://www.mwl.io">www.mwl.io</a></em> thinks that any machine in the domain <em>mwl.io</em> matches <code>LOCAL</code>. DNS spoofing can easily evade this filter. Although my desktop claims that it has a hostname of <em>storm.mwl.io</em>, its IP address has reverse DNS that claims it’s somewhere in my cable modem provider’s network. The host <em><a href="http://www.mwl.io">www.mwl.io</a></em> thinks that my desktop isn’t in the same domain and hence isn’t local. As such, I can’t use the <code>LOCAL</code> verification method.</p>
<p class="indent">Similarly, anyone who owns a block of IP addresses can give their addresses any desired reverse DNS. The <code>LOCAL</code> restriction is best avoided.</p>
<h5 class="h5" id="lev298"><strong>ALL and ALL EXCEPT</strong></h5>
<p class="noindent"><code>ALL</code> matches everything, and <code>ALL EXCEPT</code> matches everything but what you specify. These are the most useful connection sources, in my opinion. For example, if you had a highly secure machine only accessible from a couple of management workstations, you could have a rule like this:</p>
<pre>-:ALL EXCEPT wheel:ALL EXCEPT 203.0.113.128 203.0.113.44</pre>
<h5 class="h5" id="lev299"><strong>Tie It All Together</strong></h5>
<p class="noindent">The point of these rules is to build a login policy that matches your real-world policies. If you provide generic services but only allow your system administrators to log on remotely, a one-line <em>login.access</em> prevents any other users from logging in:</p>
<pre>-:ALL EXCEPT wheel:ALL</pre>
<p class="indent">This is great if you can live with a restriction this tight. On the other hand, I’ve worked at several internet service providers that used FreeBSD <span epub:type="pagebreak" id="page_188"/>to provide client services. Lowly customers weren’t allowed to log onto the servers unless they had a shell account. System administrators could log in remotely, as could the DNS and web teams (members of the dns and webmasters groups). Only sysadmins could log onto the console, however.</p>
<pre>-:ALL EXCEPT wheel:console<br/>-:ALL EXCEPT wheel dns webmasters:ALL</pre>
<p class="indent">Set this up in <em>login.access</em> once, and let group membership control all of your remote logins forever after.</p>
<h4 class="h4" id="lev300"><strong><em>Restricting System Usage</em></strong></h4>
<p class="noindent">You can provide more specific controls with login classes. Login classes, managed through <em>/etc/login.conf</em>, define the resources and information provided for users. Each user is assigned a class, and each class has limits on the system resources available. When you change the limits on a class, all users get the new limits when they next log in. Set a user’s class when creating the user account, or change it later with chpass(1).</p>
<h5 class="h5" id="lev301"><strong>Class Definitions</strong></h5>
<p class="noindent">The default <em>login.conf</em> starts with the default class, the class used by accounts without any other class. This class gives the user basically unlimited access to system resources and is suitable for application servers with a limited number of users. If this meets your needs, don’t adjust the file at all.</p>
<p class="indent">Each class definition consists of a series of variable assignments that define the user’s resource limits, accounting, and environment. Each variable assignment in the class definition begins and ends with a colon. The backslash character is a continuation character to indicate that the class continues on the next line, which makes the file more readable. Here’s a sample of the beginning of one class:</p>
<pre><span class="ent">➊</span>default:\<br/>      <span class="ent">➋</span>:passwd_format=<span class="ent">➌</span>sha512:\<br/>        :copyright=/etc/COPYRIGHT:\<br/>        :welcome=/etc/motd:\<br/>--<span class="codeitalic1">snip</span>--</pre>
<p class="indent">This class is called <code>default</code> <span class="ent">➊</span>. I’ve shown three of the dozens of variables in this class. The variable <code>passwd_format</code> <span class="ent">➋</span>, for example, is set to <code>sha512</code> <span class="ent">➌</span>. These variable assignments and the class name describe the class, and you can change the user’s experience on the system by assigning the user to another class.</p>
<p class="indent">Some of <em>login.conf</em> ’s variables don’t have a value and instead change account behavior just by being present. For example, the <code>requirehome</code> variable takes effect just by being included in the class. If this value is present, the user must have a valid home directory.</p>
<pre><span epub:type="pagebreak" id="page_189"/>       :requirehome:\</pre>
<p class="indent">After editing <em>login.conf</em>, you must update the login database to make the changes take effect.</p>
<pre># <span class="codestrong1">cap_mkdb /etc/login.conf</span></pre>
<p class="indent">This rebuilds the database file <em>/etc/login.conf.db</em> that’s used for fast lookups, much like <em>/etc/spwd.db</em>.</p>
<p class="indent">The default <em>/etc/login.conf</em> includes several example classes of users. If you want an idea of what sort of restrictions to put on users for various situations, check those examples. The following section offers ideas about what can be set in a login class. For a complete listing of supported settings in your version of FreeBSD, read man login.conf(5).</p>
<h5 class="h5" id="lev302"><strong>Resource Limits</strong></h5>
<p class="noindent">Resource limits allow you to control how much of the system any one user can monopolize at any one time. If you have several hundred users logged in to one machine and one of those users decides to compile LibreOffice, that person will consume far more than his fair share of processor time, memory, and I/O. By limiting the resources one user can monopolize, you can make the system more responsive for all users.</p>
<p class="indent">Table 9-2 defines the resource-limiting <em>login.conf</em> variables.</p>
<p class="tabcap" id="ch09tab2"><strong>Table 9-2:</strong> Some <em>login.conf</em> Variables for Limiting Resource Use</p>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Variable</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>cputime</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">The maximum CPU time any one process may use</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>filesize</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">The maximum size of any one file</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>datasize</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">The maximum memory size of data that can be consumed by one process</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>stacksize</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">The maximum amount of stack memory usable by a process</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>coredumpsize</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">The maximum size of a core dump</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>memoryuse</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">The maximum amount of memory a process can lock</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>maxproc</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">The maximum number of processes the user can have running</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>openfiles</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">The maximum number of open files per process</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>Sbsize</code></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">The maximum socket buffer size a user’s application can set</p></td>
</tr>
</tbody>
</table>
<p class="indent">Note that resource limits are frequently set per process. If you permit each process 200MB of RAM and allow each user 40 processes, you’ve just allowed each user about 8GB of memory. Perhaps your system has a lot of memory, but does it really have that much?</p>
<h5 class="h5" id="lev303"><span epub:type="pagebreak" id="page_190"/><strong>Current and Maximum Resource Limits</strong></h5>
<p class="noindent">In addition to the limits listed previously, you can specify current and maximum resource limits. <em>Current</em> limits are advisory, and the user can override them at will. This works well on a cooperative system, where multiple users willingly share resources but you want to notify those users who exceed the standard resource allocation. Many users want to be good citizens, and readily cooperate when they’re told they’re pushing their limits.<sup><a href="footnote.xhtml#ch09fn3" id="ch09fn3a">3</a></sup> Users cannot exceed <em>maximum</em> limits.</p>
<p class="indent">If you don’t specify a limit as current or maximum, FreeBSD treats it as a maximum limit.</p>
<p class="indent">To specify a current limit, add <code>-cur</code> to the variable name. To make a maximum limit, add <code>-max</code>. For example, to set a current and a maximum limit on the number of processes the user can have, use this input:</p>
<pre>        --<span class="codeitalic1">snip</span>--<br/>        :maxproc-cur: 30:\<br/>        :maxproc-max: 60:\<br/>        --<span class="codeitalic1">snip</span>--</pre>
<p class="indent">One counterpart to resource limits is resource accounting. These days, accounting isn’t as important as it was when today’s inexpensive computers would cost millions of dollars, so we won’t discuss it in this book. It’s more important to restrict a single user from consuming your system than to bill for every CPU cycle someone uses. You should know that the capability exists, however.</p>
<p class="indent">If you need more complicated resource restrictions, investigate rctl(8).</p>
<h5 class="h5" id="lev304"><strong>Class Environment</strong></h5>
<p class="noindent">You can also define environment settings in <em>/etc/login.conf</em>. This can work better than setting them in the default <em>.cshrc</em> or <em>.profile</em> because <em>login.conf</em> settings affect all user accounts immediately upon their next login. Some shells, such as zsh(1), don’t read either of these configuration files, so using a class environment sets the proper environment variables for those users.</p>
<p class="indent">All of the environment fields recognize two special characters. A tilde (<code>~</code>) represents the user’s home directory, while a cash symbol (<code>$</code>) represents the username. Here are a few examples from the default class that illustrate this:</p>
<pre>        :setenv=MAIL=<span class="ent">➊</span>/var/mail/$,BLOCKSIZE=K,FTP_PASSIVE_MODE=YES:\<br/>        :path=/sbin /bin /usr/sbin /usr/bin /usr/games /usr/local/sbin /usr/<br/>local/bin /usr/X11R6/bin <span class="ent">➋</span>~/bin:\</pre>
<p class="indent">By using the <code>$</code> character, the environment variable <code>MAIL</code> is set to <em>/var/mail/&lt;username&gt;</em> <span class="ent">➊</span>. Similarly, the last directory in the <code>PATH</code> variable is the <em>bin</em> subdirectory in the user’s home directory <span class="ent">➋</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_191"/>Table 9-3 lists some common <em>login.conf</em> environment settings.</p>
<p class="tabcap" id="ch09tab3"><strong>Table 9-3:</strong> Common <em>login.conf</em> Environment Settings</p>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Variable</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>hushlogin</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">If present, no system information is given out during login.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>ignorenologin</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">If present, these users can log in even when <em>/var/run/nologin</em> exists.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>manpath</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">A list of directories for the <code>$MANPATH</code> environment variable.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>nologin</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">If present, the user cannot log in.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>path</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">A list of directories for the <code>$PATH</code> environment variable.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>priority</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Priority (nice) for the user’s processes (see <a href="ch21.xhtml#ch21">Chapter 21</a>).</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>requirehome</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">User must have a valid home directory to log in.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>setenv</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">A comma-separated list of environment variables and their values.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>shell</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">The full path of a shell to be executed upon login. This overrides the shell in <em>/etc/master.passwd</em>. The user’s <code>$SHELL</code>, however, contains the shell from the password file, resulting in an inconsistent environment. Playing games with this is an excellent way to annoy your users.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>term</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">The default terminal type. Just about anything that tries to set a terminal type overrides this.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>timezone</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">The default value of the <code>$TZ</code> environment variable.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>umask</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Initial umask setting; should always start with 0, see builtin(1).</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>welcome</code></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Path to the login welcome message, usually <em>/etc/motd</em>.</p></td>
</tr>
</tbody>
</table>
<p class="indent">Remember, changes to a class affect all users in that class. If a user needs a change from the class settings, you’ll need to change their class.</p>
<h5 class="h5" id="lev305"><strong>Password and Login Control</strong></h5>
<p class="noindent">Unlike the environment settings, many of which can be set in places other than the login class, most login and authentication options can be controlled only from the login class. Here are some common authentication options:</p>
<p class="noindentt"><span class="codestrong">passwd_format</span></p>
<p class="hang">This option sets the cryptographic hash used to store passwords in <em>/etc/master.passwd</em>. The default is <code>sha512</code>, for SHA512 hashing. Other permissible options are <code>des</code> (DES), <code>blf</code> (Blowfish), <code>md5</code>, and <code>sha256</code> (SHA256). DES and Blowfish are most useful when you want to share password files between different Unix-like operating systems, but are very weak. SHA256 is for compatibility with older password files, from before SHA512 was the default.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_192"/><span class="codestrong">mixpasswordcase</span></p>
<p class="hang">If present, FreeBSD complains if the user changes his password to an all-lowercase word. Despite the name, all-uppercase passwords satisfy this option.</p>
<p class="noindentt"><span class="codestrong">host.allow</span>, <span class="codestrong">host.deny</span></p>
<p class="hang">These values let users in this class use rlogin and rsh. Avoid them like the fuzzy green meat your creepy roommate tried to feed you that one time.</p>
<p class="noindentt"><span class="codestrong">times.allow</span></p>
<p class="hang">This option allows you to schedule when users may log in with a comma-delimited list of days and times. Days are given as the first two letters of the day’s name (Su, Mo, Tu, We, Th, Fr, and Sa). Time is in standard 24-hour format. For example, if a user can log in only on Wednesdays between 8 <small>AM</small> and 5 <small>PM</small>, you’d use this entry:</p>
<pre>        :times.allow=We8-17:\</pre>
<p class="noindentt"><span class="codestrong">times.deny</span></p>
<p class="hang">This option allows you to specify a time window when the user can’t log in. Note that this does not kick off users who are already logged in. The format is the same as for <code>times.allow</code>. If <code>times.allow</code> and <code>times.deny</code> overlap, <code>times.deny</code> takes precedence.</p>
<p class="indentt">You can’t make that overworking developer go home, but you can keep him from opening another terminal window.</p>
<h3 class="h3" id="lev306"><strong>File Flags</strong></h3>
<p class="noindent">All Unix-like operating systems have the same filesystem permissions, assigning read, write, and execute privileges for a file to the file’s owner, its group, and all others. FreeBSD extends the permissions scheme with <em>file flags</em>, which work with permissions to enhance your system’s security.</p>
<p class="indent">Many flags have different effects depending on the system securelevel, which we’ll cover in the next section. Understanding securelevels requires an understanding of file flags, while file flags rely on securelevels. For the moment, just nod and smile when you encounter a mention of securelevels; all becomes clear in the next few pages.</p>
<p class="indent">A few file flags are useful only in specialized cases. We’ll look only at the most commonly useful flags. See chflags(1) for the complete list.</p>
<p class="indent">Many flags have multiple names; while only one name appears in ls(1) output, you can use any name at the command line. These alternate names exist because people got tired of getting an error when they typed <code>sapp</code><span class="codeitalic1">e</span><code>nd</code> instead of <code>sappnd</code>. Here, I show the flag’s primary name first and then the user-friendly aliases.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_193"/><span class="codestrong">sappnd</span>, <span class="codestrong">sappend</span></p>
<p class="hang">This system-level, append-only flag can be set only by root. Files with this flag can be added to but can’t be removed or otherwise edited. This flag is particularly useful for log files. Setting <code>sappnd</code> on a user’s <em>.history</em> file can be interesting if the account is compromised. Since a common intruder tactic is to remove <em>.history</em> or symlink it to <em>/dev/null</em> so that the admin can’t see what happened, <code>sappnd</code> ensures that script kiddies cannot cover their tracks in this manner. It’s almost funny to review the record of someone trying to remove a <code>sappnd</code> file; you can almost see the attacker’s frustration grow as he tries various methods.<sup><a href="footnote.xhtml#ch09fn4" id="ch09fn4a">4</a></sup> This flag can’t be removed when the system is running at securelevel 1 or higher.</p>
<p class="noindentt"><span class="codestrong">schg</span></p>
<p class="hang">Only root can set the system-level immutable flag. Files with this flag set can’t be changed in any way. They can’t be edited, moved, replaced, or overwritten. Basically, the filesystem itself prevents all attempts to alter this file. The flag can’t be removed when the system is running at securelevel 1 or greater.</p>
<p class="noindentt"><span class="codestrong">sunlnk</span></p>
<p class="hang">Only root can set the system-level undeletable flag on a file. The file can be edited or altered, but it can’t be deleted. This isn’t as secure as the previous two flags because if a file can be edited, it can be emptied. It’s still useful for certain circumstances, however. I’ve used it when a program insisted on deleting its own log files upon a crash. It’s not generally useful to set on any standard system files, however. This flag can’t be removed when the system is running at securelevel 1 or higher.</p>
<p class="noindentt"><span class="codestrong">uappnd</span></p>
<p class="hang">This user-level, append-only flag can be set only by the file owner or root. Like the system-level append-only flag <code>sappnd</code>, a file with this flag set can be added to but not otherwise edited or removed. This flag is most useful for logs from personal programs and the like; it’s primarily a means to let users prevent accidental removal of their own files. The owner or root can remove this flag.</p>
<p class="noindentt"><span class="codestrong">uchg</span></p>
<p class="hang">This user-level, immutable flag can be set only by the owner or root. Like the <code>schg</code> flag, this immutable flag prevents anyone from changing the file. Again, root can override this, and it can be disabled by the user at any securelevel. This flag helps prevent mistakes, but it’s not a way to secure your system.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_194"/><span class="codestrong">uunlnk</span></p>
<p class="hang">This user-level, undeletable flag can be set only by the owner or root. A file with this flag set can’t be deleted by the owner. Root can override that, and the user can turn this flag off at any time, making this mostly useless.</p>
<h4 class="h4" id="lev307"><strong><em>Setting and Viewing File Flags</em></strong></h4>
<p class="noindent">Set flags with chflags(1). For example, to be sure that nothing replaces a server’s kernel, you could do this:</p>
<pre># <span class="codestrong1">chflags schg /boot/kernel/kernel</span></pre>
<p class="indent">You’d need to remove this flag to perform system updates.</p>
<p class="indent">You can recursively change the flags on an entire directory tree with the <code>-R</code> flag. For example, to make all of <em>/bin</em> directory immutable, run this command:</p>
<pre># <span class="codestrong1">chflags -R schg /bin</span></pre>
<p class="indent">And boom! Your basic system binaries can’t be changed.</p>
<p class="indent">To see what flags are set on a file, use <code>ls -lo</code>.</p>
<pre># <span class="codestrong1">ls -lo log</span><br/>-rw-r--r--  1 mwlucas  mwlucas  sappnd 0 Nov 12 12:37 log</pre>
<p class="indent">The <code>sappnd</code> entry tells us that the system append-only flag is set on this log. For comparison, if a file has no flags set, it looks like this:</p>
<pre># <span class="codestrong1">ls -lo log</span><br/>-rw-r--r--  1 mwlucas  mwlucas  - 0 Nov 12 12:37 log</pre>
<p class="indent">The hyphen in place of the flag name tells us that no flag has been set.</p>
<p class="indent">An out-of-the-box FreeBSD install doesn’t have many files marked with flags, but you can flag anything you want. On one system that I fully expected to be hacked, I went berserk with <code>chflags -R schg</code> in various system directories to prevent anyone from replacing system binaries with trojaned versions. It might not stop an attacker from getting in, but imagining their frustration improved my mood.</p>
<p class="indent">To remove a file flag, use <code>chflags</code> and a <code>no</code> in front of the flag name. For example, to unset the <code>schg</code> flag on your kernel, enter this command:</p>
<pre># <span class="codestrong1">chflags noschg /boot/kernel/kernel</span></pre>
<p class="indent">That said, you must be running at securelevel –1 to unset many flags. So, without further ado, let’s discuss securelevels and what they mean to you.</p>
<h3 class="h3" id="lev308"><span epub:type="pagebreak" id="page_195"/><strong>Securelevels</strong></h3>
<p class="noindent">Securelevels are kernel settings that change basic system behavior to disallow certain actions. The kernel behaves slightly differently as you raise the securelevel. For example, at low securelevels, file flags can be removed. A file might be flagged immutable—but you can remove the flag, edit the file, and reflag it. When you increase the securelevel, the file flag can’t be removed. Similar changes take place in other parts of the system. Taken as a whole, the behavior changes that result from increased securelevels either frustrate or stop an intruder. Enable securelevels at boot with the <em>rc.conf</em> option <code>kern_securelevel_enable="YES"</code>.</p>
<p class="indent">Securelevels complicate system maintenance by imposing restrictions on your behavior. After all, many system administration tasks are also things intruders might do to cover their tracks. For example, at certain securelevels, you can’t format or mount new hard drives while the system is running. On the other hand, securelevels hamper intruders even more than they hamper you.</p>
<h4 class="h4" id="lev309"><strong><em>Securelevel Definitions</em></strong></h4>
<p class="noindent">Securelevels come in 5 degrees: –1, 0, 1, 2, and 3, with –1 being the lowest and 3 the highest. Once you enable securelevels with the <code>kern_securelevel_enable</code> <em>rc.conf</em> option, you can set the securelevel at boot with the <code>kern_securelevel</code> <em>rc.conf</em> variable. You can raise the securelevel at any time, not just at boot, but you can’t lower it without rebooting into single-user mode. After all, if you could lower the securelevel at any time, so could your intruder!</p>
<p class="indent">The effects of each securelevel vary depending on your FreeBSD release. To get the latest information, read security(7).</p>
<h5 class="h5" id="lev310"><strong>Securelevel –1</strong></h5>
<p class="noindent">The default provides no additional kernel security whatsoever. If you’re learning FreeBSD and are frequently changing your configuration, remain at securelevel –1 and use the built-in file permissions and other Unix safeguards for security. Flags like <code>sappnd</code> and <code>schg</code> will work, but chflags(1) can easily remove the flags.</p>
<h5 class="h5" id="lev311"><strong>Securelevel 0</strong></h5>
<p class="noindent">Securelevel 0 is used only during booting and offers no special features over securelevel –1. When the system reaches multiuser mode, however, the securelevel is automatically raised to 1. Setting <code>kern_securelevel=0</code> in <em>/etc/rc.conf</em> is effectively the same as setting <code>kern_securelevel=1</code>. Securelevel 0 is helpful if you have startup scripts that perform actions prohibited by securelevel 1.</p>
<h5 class="h5" id="lev312"><span epub:type="pagebreak" id="page_196"/><strong>Securelevel 1</strong></h5>
<p class="noindent">At securelevel 1, the basic secure mode, things become interesting:</p>
<ul>
<li class="noindent">System-level file flags may not be turned off.</li>
<li class="noindent">You can’t load or unload kernel modules (see <a href="ch06.xhtml#ch06">Chapter 6</a>).</li>
<li class="noindent">Programs can’t write directly to system memory via either <em>/dev/mem</em> or <em>/dev/kmem</em>.</li>
<li class="noindent">Nothing can access <em>/dev/io</em>.</li>
<li class="noindent">You can’t enter the kernel debugger with the <code>debug.kdb.enter</code> sysctl.</li>
<li class="noindent">You can’t panic the system with the <code>debug.kdb.panic</code> sysctl.</li>
<li class="noindent">Mounted disks can’t be written to directly. (You can write files to disk; you just can’t address the raw disk devices.)</li>
</ul>
<p class="indent">The most obvious effect of securelevel 1 for ordinary users is that the BSD-specific filesystem flags can’t be altered. If a file is marked system-level immutable, and you want to replace it, too bad.</p>
<h5 class="h5" id="lev313"><strong>Securelevel 2</strong></h5>
<p class="noindent">Securelevel 2 has all the behaviors of securelevel 1, with two additions:</p>
<ul>
<li class="noindent">Disks can’t be opened for writing, whether mounted or not.</li>
<li class="noindent">You can’t alter system time by more than one second.</li>
</ul>
<p class="indent">Both of these seem irrelevant to new sysadmins, but they provide important security protections. Although Unix provides handy tools, like text editors to write files, it’s also possible to bypass both those tools and the actual filesystem to access the underlying ones and zeros on the hard drive. Poking at the hard drive lets you change any file regardless of the file permissions. The only time this commonly happens is when you install a new hard drive and must create a filesystem on it. Normally, only the root user can write directly to the disk in this manner. At securelevel 2, even root can’t use newfs(8), zpool(8), and so on.</p>
<p class="indent">Similarly, another old hacker trick is to change the system time, edit a file, and change the time back. That way, when the administrator looks for files that might be causing trouble, the tampered file appears to have been untouched for months or years and hence doesn’t seem an obvious source of concern.</p>
<h5 class="h5" id="lev314"><strong>Securelevel 3</strong></h5>
<p class="noindent">Securelevel 3 is the <em>network secure mode</em>. In addition to the settings of securelevels 1 and 2, you can’t adjust packet filter rules. The firewall on your host is immutable. If you have a system with packet filtering or bandwidth management enabled and those rules are well tuned and unlikely to change, you can use securelevel 3.</p>
<h4 class="h4" id="lev315"><span epub:type="pagebreak" id="page_197"/><strong><em>Which Securelevel Do You Need?</em></strong></h4>
<p class="noindent">The securelevel appropriate for your environment depends entirely upon your situation. If you’ve just put a FreeBSD machine into production and are still fine-tuning it, leave the securelevel at –1. Once your system is tuned, however, you can raise the securelevel. Most production systems run just fine at securelevel 2.</p>
<p class="indent">If you use one of FreeBSD’s packet filtering or firewall packages, securelevel 3 might look tempting. Be very sure of your firewall rules before you enable this, however! Securelevel 3 makes it impossible to change your firewall without disrupting your connection. Are you 100 percent certain that none of your customers will ever call in to say, “Here’s a check. Now give me more servers!”?</p>
<h4 class="h4" id="lev316"><strong><em>What Won’t Securelevels and File Flags Accomplish?</em></strong></h4>
<p class="noindent">Consider a case where someone compromises a CGI script on your web server, uses that to bootstrap into a shell, and then uses the shell to bootstrap himself into root access.</p>
<p class="indent">If you’ve set the securelevel accordingly, perhaps this attacker will become frustrated because not only can’t she replace your kernel with her specially compiled one, she also can’t even load a kernel module. No problem—she can still replace assorted system programs with trojaned versions so that the next time you log in, your new version of login(1) sends your password to an anonymous web-based mailbox or to an internet newsgroup.</p>
<p class="indent">So, to protect your key files, you run around doing <code>chflags schg -R /bin/*</code>, <code>chflags schg -R /usr/lib</code>, and so on. Fine. If you forget one file—say, something obscure like <em>/etc/rc.bsdextended</em> —your intruder can edit that file to include <code>chflags -R noschg /</code>. She can then reboot your system late at night when you might not notice. How often do you sit down and exhaustively audit your <em>/etc/rc</em> files?</p>
<p class="indent">You think that your system is safe, with every file completely protected. But what about <em>/usr/local/etc/rc.d</em>, the local program startup directory? The system boot process tries to execute any executable file in this directory that contains a line starting with <code>#PROVIDE:</code> (see <a href="ch17.xhtml#ch17">Chapter 17</a> for why). Your intruder could therefore do a lot of damage by placing a simple shell script there. After all, <em>/etc/rc</em> raises the securelevel at the end of the boot process. What if she were to create a shell script that kills the running <em>/etc/rc</em> before it could raise the securelevel and then she turned around and ran his own <em>/var/.hidden/rc.rootkit</em> to finish bringing the system up?</p>
<p class="indent">Of course, these are only a couple of possibilities. There are others, limited only by your intruder’s creativity. Remember that system security is a thorny problem with no easy solution. Once intruders have a command prompt, it’s you against them. And if they’re any good, you won’t even notice the penetration until it’s too late. By following good computing practices and keeping your system up to date, you can stop them from intruding in the first place. Do not allow securelevels to make you lazy!</p>
<h4 class="h4" id="lev317"><span epub:type="pagebreak" id="page_198"/><strong><em>Living with Securelevels</em></strong></h4>
<p class="noindent">If you’ve been liberal with the <code>schg</code> flag, you’ll soon find that you can’t upgrade or patch your system conveniently. The fact is, the same conditions that make intruders’ lives difficult can make yours a living hell if you don’t know how to work with them.</p>
<p class="indent">If you’ve frozen <em>/etc/rc.conf</em> with <code>schg</code>, you must lower the securelevel to change the programs running on your system. Of course, the securelevel setting is in that file, so in order to edit it, you must take control of the system before <em>/etc/rc</em> runs. That means you must boot into single-user mode (as discussed in <a href="ch04.xhtml#ch04">Chapter 4</a>), mount your filesystems, run <code>chflags noschg</code> on the files in question, and continue booting. You can even entirely disable securelevels in <em>/etc/rc.conf</em> and work normally while the system runs or add commands to <em>/etc/rc.local</em> so they take effect before the securelevel is set. You’ll restore service more quickly that way but lose the protections of the file flags.</p>
<p class="indent">After you’ve finished maintenance, you can raise (but not lower) the securelevel by changing the <code>kern.securelevel</code> sysctl to your desired securelevel.</p>
<pre># <span class="codestrong1">sysctl kern.securelevel=3</span></pre>
<p class="indent">Now that you can control file changes, let’s consider controlling access to your system from the network.</p>
<h3 class="h3" id="lev318"><strong>Network Targets</strong></h3>
<p class="noindent">Intruders normally break into applications that listen to the network, not the operating system itself. An operating system may or may not help defend a piece of software against network attacks, but the intrusion itself starts with the application. One way to reduce the number of attacks that can be carried out against your server is to identify all of the programs that are listening to the network and disable any that aren’t strictly necessary. FreeBSD provides sockstat(1) as an easy way to identify programs that are listening to the network.</p>
<p class="indent">We cover sockstat in detail in <a href="ch08.xhtml#ch08">Chapter 8</a>; running <code>sockstat -4</code> shows all open IPv4 TCP/IP ports. Every network port you have open is a potential weakness and a potential target. Shut down unnecessary network services and secure those you must offer.</p>
<p class="indent">It’s a good idea to regularly review which ports are open on your systems because you might learn something that surprises you. You might find that some piece of software you’ve installed has a network component that you weren’t aware of and that it’s been quietly listening to the network.</p>
<p class="indent">Once you know what’s running, how do you turn off what you don’t need? The best way to close these ports is to not start the programs that run them. Network daemons generally start in one of two places: <em>/etc/rc.conf</em> or a startup script in <em>/etc/rc.d</em>. Programs that are integrated with the main FreeBSD system, such as sendmail(8), sshd(8), and rpcbind(8), <span epub:type="pagebreak" id="page_199"/>have flags in <em>rc.conf</em> to enable or disable them, as do many add-on programs. See <a href="ch04.xhtml#ch04">Chapter 4</a> for details on enabling and disabling programs at startup.</p>
<div class="sidebar">
<p class="sidebart"><strong>WORKSTATION VS. SERVER SECURITY</strong></p>
<p class="spara">Many companies I’ve seen have tightly secured servers but pay little attention to workstation security. A prospective intruder doesn’t care whether a system is a server or a workstation, however. Many servers and firewalls have special rules for the sysadmin’s workstation. An intruder will happily penetrate a workstation and try to leverage that into server access. While server security is key, don’t neglect workstations—especially <em>your</em> workstation!</p>
</div>
<p class="indent">Network probes are strange in that you really don’t know when someone pokes at your hosts. To see how much of this goes on, set <code>log_in_vain</code> to 1 in <em>/etc/rc.conf</em> on one of your public servers. This tells the kernel to log all connection attempts to closed ports. When someone checks your host for a nonexistent telnet, Squid, or database listener, the kernel logs the attempt to <em>/var/log/messages</em>. Watch that log only long enough to realize clear down to your marrow that the whole internet really is out to get you—and then disable <code>log_in_vain</code>.</p>
<h3 class="h3" id="lev319"><strong>Putting It All Together</strong></h3>
<p class="noindent">Once you have only the necessary network ports open and you know which programs are using those ports, you know which programs you must be most concerned about securing. If the FreeBSD security team sends out an announcement of a problem with a service you don’t run, you can safely delay implementing a fix until your next maintenance window. If, however, the security team announces a hole in programs you’re using, you know you have to implement a fix as soon as possible. If they announce a serious security problem with a piece of network software you’re using, you know you must act quickly. Simply being able to respond intelligently and quickly to real risks helps protect you against most intruders. Tools such as file flags and securelevels minimize the damage successful intruders can do. Finally, using groups to restrict your own system administrators to particular sections of the system can protect your computers from both accidental and deliberate damage.</p>
<p class="indent">Let’s shift gears now and talk storage.<span epub:type="pagebreak" id="page_200"/></p>
</body></html>