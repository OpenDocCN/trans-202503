- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Discovery
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 发现
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Before you can attack a target’s APIs, you must locate those APIs and validate
    whether they are operational. In the process, you’ll also want to find credential
    information (such as keys, secrets, usernames, and passwords), version information,
    API documentation, and information about the API’s business purpose. The more
    information you gather about a target, the better your odds of discovering and
    exploiting API-related vulnerabilities. This chapter describes passive and active
    reconnaissance processes and the tools to get the job done.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在你攻击目标的 API 之前，必须先定位这些 API，并验证它们是否正常运行。在这个过程中，你还需要寻找凭证信息（如密钥、密码、用户名和密码）、版本信息、API
    文档以及有关 API 商业用途的信息。你收集的关于目标的信息越多，发现和利用与 API 相关漏洞的机会就越大。本章描述了被动和主动侦察过程以及完成这些任务的工具。
- en: When it comes to recognizing an API in the first place, it helps to consider
    its purpose. APIs are meant to be used either internally, by partners and customers,
    or publicly. If an API is intended for public or partner use, it’s likely to have
    developer-friendly documentation that describes the API endpoints and instructions
    for using it. Use this documentation to recognize the API.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别一个 API 时，考虑其用途会有所帮助。API 旨在供内部使用、合作伙伴和客户使用或公开使用。如果一个 API 旨在公开或供合作伙伴使用，它可能会有开发者友好的文档，描述
    API 端点和使用说明。利用这些文档来识别该 API。
- en: 'If the API is for select customers or internal use, you’ll have to rely on
    other clues: naming conventions, HTTP response header information such as `Content-Type:
    application/json`, HTTP responses containing JSON/XML, and information about the
    JavaScript source files that power the application.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 API 是为特定客户或内部使用的，你必须依赖其他线索：命名约定、HTTP 响应头信息，如`Content-Type: application/json`、包含
    JSON/XML 的 HTTP 响应，以及关于应用程序的 JavaScript 源文件的信息。'
- en: Passive Recon
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 被动侦察
- en: '*Passive reconnaissance* is the act of obtaining information about a target
    without directly interacting with the target’s devices. When you take this approach,
    your goal is to find and document your target’s attack surface without making
    the target aware of your investigation. In this case, the *attack surface* is
    the total set of systems exposed over a network from which it may be possible
    to extract data, through which you could gain entry to other systems, or to which
    you could cause an interruption in the availability of systems.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*被动侦察*是指在不直接与目标设备互动的情况下获取有关目标的信息。当你采用这种方法时，你的目标是发现并记录目标的攻击面，而不让目标察觉到你的调查。在这种情况下，*攻击面*是通过网络暴露的所有系统集合，从中可能提取数据、通过它们进入其他系统，或者通过它们对系统的可用性造成干扰。'
- en: Typically, passive reconnaissance leverages *open-source intelligence (OSINT)*,
    which is data collected from publicly available sources. You will be on the hunt
    for API endpoints, credential information, version information, API documentation,
    and information about the API’s business purpose. Any discovered API endpoints
    will become your targets later, during active reconnaissance. Credential-related
    information will help you test as an authenticated user or, better, as an administrator.
    Version information will help inform you about potential improper assets and other
    past vulnerabilities. API documentation will tell you exactly how to test the
    target API. Finally, discovering the API’s business purpose can provide you with
    insight about potential business logic flaws.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，被动侦察利用*开源情报（OSINT）*，即从公开可用的来源收集的数据。你将寻找 API 端点、凭证信息、版本信息、API 文档以及关于 API 商业用途的信息。任何发现的
    API 端点将在主动侦察过程中成为你的目标。凭证相关信息将帮助你作为认证用户，或者更好地，作为管理员进行测试。版本信息将帮助你了解潜在的不当资产和其他过往漏洞。API
    文档将告诉你如何准确地测试目标 API。最后，发现 API 的商业用途可以为你提供有关潜在商业逻辑漏洞的见解。
- en: As you are collecting OSINT, it is entirely possible you will stumble upon a
    critical data exposure, such as API keys, credentials, JSON Web Tokens (JWT),
    and other secrets that would lead to an instant win. Other high-risk findings
    would include leaked PII or sensitive user data such as Social Security numbers,
    full names, email addresses, and credit card information. These sorts of findings
    should be documented and reported immediately because they present a valid critical
    weakness.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在收集开源情报的过程中，你完全有可能会发现一些关键的数据暴露，如API密钥、凭证、JSON Web Tokens（JWT）和其他秘密，这些可能导致一次性成功。其他高风险发现包括泄露的个人身份信息（PII）或敏感的用户数据，如社会安全号码、全名、电子邮件地址和信用卡信息。这些类型的发现应立即记录并报告，因为它们代表了一个有效的关键弱点。
- en: The Passive Recon Process
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 被动侦察过程
- en: When you begin passive recon, you’ll probably know little to nothing about your
    target. Once you’ve gathered some basic information, you can focus your OSINT
    efforts on the different facets of an organization and build a profile of the
    target’s attack surface. API usage will vary between industries and business purposes,
    so you’ll need to adapt as you learn new information. Start by casting a wide
    net using an array of tools to collect data. Then perform more tailored searches
    based on the collected data to obtain more refined information. Repeat this process
    until you’ve mapped out the target’s attack surface.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始进行被动侦察时，可能对目标了解甚少。收集到一些基本信息后，你可以将你的开源情报（OSINT）工作集中在组织的不同方面，建立目标的攻击面资料。API的使用在不同行业和商业目的之间会有所不同，因此在学习新信息时，你需要进行调整。从使用各种工具来收集数据开始，然后根据收集到的数据进行更有针对性的搜索，以获取更精炼的信息。重复这一过程，直到你绘制出目标的攻击面。
- en: 'Phase One: Cast a Wide Net'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第一阶段：撒网
- en: Search the internet for very general terms to learn some fundamental information
    about your target. Search engines such as Google, Shodan, and ProgrammableWeb
    can help you find general information about the API, such as its usage, design
    and architecture, documentation, and business purpose, as well as industry-related
    information and many other potentially significant items.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上搜索一些非常通用的术语，以便了解关于目标的一些基本信息。像Google、Shodan和ProgrammableWeb这样的搜索引擎可以帮助你找到关于API的一般信息，如其使用方法、设计和架构、文档以及商业目的，还可以找到与行业相关的信息和许多其他潜在的重要项目。
- en: Additionally, you need to investigate your target’s attack surface. This can
    be done with tools such as DNS Dumpster and OWASP Amass. DNS Dumpster performs
    DNS mapping by showing all the hosts related to the target’s domain name and how
    they connect to each other. (You may want to attack these hosts later!) We covered
    the use of OWASP Amass in Chapter 4.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还需要调查目标的攻击面。这可以通过使用像DNS Dumpster和OWASP Amass这样的工具来完成。DNS Dumpster通过显示与目标域名相关的所有主机及其相互连接的方式来执行DNS映射。（你可能会在稍后攻击这些主机！）我们在第4章中已经介绍了OWASP
    Amass的使用。
- en: 'Phase Two: Adapt and Focus'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第二阶段：调整与聚焦
- en: Next, take your findings from phase one and adapt your OSINT efforts to the
    information gathered. This might mean increasing the specificity of your search
    queries or combining the information gathered from separate tools to gain new
    insights. In addition to using search engines, you might search GitHub for repositories
    related to your target and use a tool such as Pastehunter to find exposed sensitive
    information.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，基于第一阶段的发现，调整你的开源情报工作，结合收集到的信息。这可能意味着增加搜索查询的具体性，或结合来自不同工具的信息以获得新的见解。除了使用搜索引擎外，你还可以在GitHub上搜索与你的目标相关的代码库，使用Pastehunter等工具查找暴露的敏感信息。
- en: 'Phase Three: Document the Attack Surface'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第三阶段：记录攻击面
- en: Taking notes is crucial to performing an effective attack. Document and take
    screen captures of all interesting findings. Create a task list of the passive
    reconnaissance findings that could prove useful throughout the rest of the attack.
    Later, while you’re actively attempting to exploit the API’s vulnerabilities,
    return to the task list to see if you’ve missed anything.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 做笔记对执行有效攻击至关重要。记录并截图所有有趣的发现。创建一个任务列表，列出可能对攻击过程中的其他阶段有用的被动侦察发现。稍后，当你积极尝试利用API漏洞时，可以回到任务列表，看看是否漏掉了什么。
- en: The following sections go deeper into the tools you’ll use throughout this process.
    Once you begin experimenting with these tools, you’ll notice some crossover between
    the information they return. However, I encourage you to use multiple tools to
    confirm your results. You wouldn’t want to fail to find privileged API keys posted
    on GitHub, for example, especially if a criminal later stumbled upon that low-hanging
    fruit and breached your client.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将深入探讨你在整个过程中使用的工具。一旦你开始使用这些工具进行实验，你会注意到它们返回的信息之间会有所重叠。然而，我鼓励你使用多个工具来确认你的结果。例如，你不希望错过在GitHub上公开发布的特权API密钥，特别是如果某个犯罪分子后来发现了这些易得的信息并突破了你的客户的安全。
- en: Google Hacking
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Google黑客技术
- en: '*Google hacking* (also known as *Google dorking*) involves the clever use of
    advanced search parameters and can reveal all sorts of public API-related information
    about your target, including vulnerabilities, API keys, and usernames, that you
    can leverage during an engagement. In addition, you’ll find information about
    the target organization’s industry and how it leverages its APIs. [Table 6-1](#table6-1)
    lists a selection of useful query parameters (see the “Google Hacking” Wikipedia
    page for a complete list).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*Google黑客技术*（也称为*Google dorking*）涉及巧妙使用高级搜索参数，可以揭示关于目标的各种公开API相关信息，包括漏洞、API密钥和用户名，这些信息你可以在参与中加以利用。此外，你还可以找到目标组织的行业信息以及它如何使用API。[表6-1](#table6-1)列出了有用的查询参数（完整列表请参见“Google黑客技术”维基百科页面）。'
- en: 'Table 6-1: Google Query Parameters'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '表6-1: Google查询参数'
- en: '| **Query operator** | **Purpose** |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **查询操作符** | **目的** |'
- en: '| --- | --- |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `intitle` | Searches page titles |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `intitle` | 搜索页面标题 |'
- en: '| `inurl` | Searches for words in the URL |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `inurl` | 搜索URL中的词语 |'
- en: '| `filetype` | Searches for desired file types |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `filetype` | 搜索所需的文件类型 |'
- en: '| `site` | Limits a search to specific sites |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `site` | 限制搜索范围到特定网站 |'
- en: 'Start with a broad search to see what information is available; then add parameters
    specific to your target to focus the results. For example, a generic search for
    `inurl: /api/` will return over 2,150,000 results—too many to do much of anything
    with. To narrow the search results, include your target’s domain name. A query
    like `intitle:"``<targetname>` `api key"` returns fewer and more relevant results.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '从广泛的搜索开始，查看有哪些信息可用；然后添加特定于目标的参数，以聚焦结果。例如，`inurl: /api/`的通用搜索将返回超过2,150,000条结果——这多得无法做出有效分析。为了缩小搜索结果的范围，可以包括目标的域名。像`intitle:"<targetname>
    api key"`这样的查询会返回更少且更相关的结果。'
- en: In addition to your own carefully crafted Google search queries, you can use
    Offensive Security’s Google Hacking Database (GHDB, [https://www.exploit-db.com/google-hacking-database](https://www.exploit-db.com/google-hacking-database)).
    The GHDB is a repository of queries that reveal publicly exposed vulnerable systems
    and sensitive information. [Table 6-2](#table6-2) lists some useful API queries
    from the GHDB.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你自己精心制作的Google搜索查询，你还可以使用Offensive Security的Google黑客数据库（GHDB，[https://www.exploit-db.com/google-hacking-database](https://www.exploit-db.com/google-hacking-database)）。GHDB是一个包含揭示公开暴露的易受攻击系统和敏感信息的查询库。[表6-2](#table6-2)列出了一些来自GHDB的有用API查询。
- en: 'Table 6-2: GHDB Queries'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '表6-2: GHDB查询'
- en: '| **Google hacking query** | **Expected results** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **Google黑客查询** | **预期结果** |'
- en: '| --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `inurl:"/wp-json/wp/v2/users"` | Finds all publicly available WordPress API
    user directories. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `inurl:"/wp-json/wp/v2/users"` | 查找所有公开可用的WordPress API用户目录。 |'
- en: '| `intitle:"index.of" intext:"api.txt"` | Finds publicly available API key
    files. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `intitle:"index.of" intext:"api.txt"` | 查找公开可用的API密钥文件。 |'
- en: '| `inurl:"/includes/api/" intext:"index of /"` | Finds potentially interesting
    API directories. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `inurl:"/includes/api/" intext:"index of /"` | 查找可能有趣的API目录。 |'
- en: '| `ext:php inurl:"api.php?action="` | Finds all sites with a XenAPI SQL injection
    vulnerability. (This query was posted in 2016; four years later, there were 141,000
    results.) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `ext:php inurl:"api.php?action="` | 查找所有存在XenAPI SQL注入漏洞的网站。（这个查询发布于2016年，四年后，结果达到141,000条。）
    |'
- en: '| `intitle:"index of" api_key OR "api key" OR apiKey -pool` | Lists potentially
    exposed API keys. (This is one of my favorite queries.) |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `intitle:"index of" api_key OR "api key" OR apiKey -pool` | 列出可能暴露的API密钥。（这是我最喜欢的查询之一。）
    |'
- en: As you can see in [Figure 6-1](#figure6-1), the final query returns 2,760 search
    results for websites where API keys are publicly exposed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图6-1](#figure6-1)所示，最终的查询返回了2,760个搜索结果，这些网站公开暴露了API密钥。
- en: '![Screenshot of Google search results with the keyword “apikey” highlighted
    in the endpoints of the returned websites](image_fi/502444c06/F06001.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Google 搜索结果截图，关键词“apikey”在返回网站的端点中高亮显示](image_fi/502444c06/F06001.png)'
- en: 'Figure 6-1: The results of a Google hack for APIs, including several web pages
    with exposed API keys'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-1：Google 对 API 进行黑客攻击的结果，包括几个暴露 API 密钥的网页
- en: ProgrammableWeb’s API Search Directory
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ProgrammableWeb 的 API 搜索目录
- en: ProgrammableWeb ([https://www.programmableweb.com](https://www.programmableweb.com))
    is the go-to source for API-related information. To learn about APIs, you can
    use its API University. To gather information about your target, use the API directory,
    a searchable database of over 23,000 APIs (see [Figure 6-2](#figure6-2)). Expect
    to find API endpoints, version information, business logic information, the status
    of the API, source code, SDKs, articles, API documentation, and a changelog.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ProgrammableWeb ([https://www.programmableweb.com](https://www.programmableweb.com))
    是获取 API 相关信息的首选来源。要了解 API，你可以使用它的 API 大学。要收集目标信息，可以使用 API 目录，这是一个包含超过 23,000 个
    API 的可搜索数据库（见[图 6-2](#figure6-2)）。你可以找到 API 端点、版本信息、业务逻辑信息、API 状态、源代码、SDK、文章、API
    文档和 Changelog。
- en: '![Screenshot of the ProgrammableWeb API directory displaying information about
    the Google Maps and Twitter APIs](image_fi/502444c06/F06002.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![ProgrammableWeb API 目录的截图，显示了有关 Google Maps 和 Twitter API 的信息](image_fi/502444c06/F06002.png)'
- en: 'Figure 6-2: The ProgrammableWeb API directory'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-2：ProgrammableWeb API 目录
- en: Suppose you discover, using a Google query, that your target is using the Medici
    Bank API. You could search the ProgrammableWeb API directory and find the listing
    in [Figure 6-3](#figure6-3).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你通过 Google 查询发现你的目标正在使用 Medici 银行 API，你可以在 ProgrammableWeb API 目录中搜索并找到[图
    6-3](#figure6-3)中的列表。
- en: '![Screenshot of the Medici Bank API page on ProgrammableWeb, which contains
    information about the API’s structure and the various tasks for which it can be
    used](image_fi/502444c06/F06003.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![ProgrammableWeb 上 Medici 银行 API 页面截图，包含 API 结构和各种任务的相关信息](image_fi/502444c06/F06003.png)'
- en: 'Figure 6-3: ProgrammableWeb’s API directory listing for the Medici Bank API'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-3：ProgrammableWeb 的 Medici 银行 API 目录列表
- en: The listing shows that the Medici Bank API interacts with customer data and
    facilitates financial transactions, making it a high-risk API. When you discover
    a sensitive target like this one, you’ll want to find any information that could
    help you attack it, including API documentation, the location of its endpoint
    and portal, its source code, its changelog, and the authentication model it uses.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表显示 Medici 银行 API 与客户数据交互并促进金融交易，因此它是一个高风险 API。当你发现像这样的敏感目标时，你会想找到任何可以帮助你攻击它的信息，包括
    API 文档、端点和门户的位置、源代码、Changelog 以及它使用的认证模型。
- en: Click through the various tabs in the directory listing and note the information
    you find. To see the API endpoint location, portal location, and authentication
    model, shown in [Figure 6-4](#figure6-4), click a specific version under the Versions
    tab. In this case, both the portal and endpoint links lead to API documentation
    as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 点击目录列表中的各个标签并记录你找到的信息。要查看 API 端点位置、门户位置和认证模型，请点击 Versions 标签下的特定版本，如[图 6-4](#figure6-4)所示。在这种情况下，门户和端点链接也会指向
    API 文档。
- en: '![Screenshot of the ProgrammableWeb Versions tab for the Medici Bank API, which
    provides links to relevant resources](image_fi/502444c06/F06004.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![ProgrammableWeb 上 Medici 银行 API 的 Versions 标签截图，提供相关资源的链接](image_fi/502444c06/F06004.png)'
- en: 'Figure 6-4: The Medici Bank API Specs section provides the API endpoint location,
    the API portal location, and the API authentication model.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-4：Medici 银行 API 规格部分提供 API 端点位置、API 门户位置和 API 认证模型。
- en: The Changelog tab will inform you of past vulnerabilities, previous API versions,
    and notable updates to the latest API version, if available. ProgrammableWeb describes
    the Libraries tab as “a platform-specific software tool that, when installed,
    results in provisioning a specific API.” You can use this tab to discover the
    type of software used to support the API, which could include vulnerable software
    libraries.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Changelog 标签会告诉你过去的漏洞、以前的 API 版本以及最新 API 版本的重大更新（如果有的话）。ProgrammableWeb 将 Libraries
    标签描述为“一个特定平台的软件工具，安装后将提供特定的 API。”你可以使用此标签来发现用于支持 API 的软件类型，其中可能包括易受攻击的软件库。
- en: Depending on the API, you may discover source code, tutorials (the How To tab),
    mashups, and news articles, all of which may provide useful OSINT. Other sites
    with API repositories include [https://rapidapi.com](https://rapidapi.com) and
    [https://apis.guru/browse-apis](https://apis.guru/browse-apis).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据不同的API，你可能会发现源代码、教程（How To标签）、拼接应用和新闻文章，所有这些都可能提供有价值的OSINT。其他拥有API资源库的网站包括[https://rapidapi.com](https://rapidapi.com)和[https://apis.guru/browse-apis](https://apis.guru/browse-apis)。
- en: Shodan
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Shodan
- en: Shodan is the go-to search engine for devices accessible from the internet.
    Shodan regularly scans the entire IPv4 address space for systems with open ports
    and makes their collected information public at [https://shodan.io](https://shodan.io).
    You can use Shodan to discover external-facing APIs and get information about
    your target’s open ports, making it useful if you have only an IP address or organization’s
    name to work from.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Shodan是一个用于查找可以从互联网访问的设备的搜索引擎。Shodan定期扫描整个IPv4地址空间，查找具有开放端口的系统，并将收集的信息公开发布在[https://shodan.io](https://shodan.io)。你可以使用Shodan来发现面向外部的API，并获取关于目标开放端口的信息，如果你只有IP地址或组织名称，也能发挥它的作用。
- en: Like with Google dorks, you can search Shodan casually by entering your target’s
    domain name or IP addresses; alternatively, you can use search parameters as you
    would when writing Google queries. [Table 6-3](#table6-3) shows some useful Shodan
    queries.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与Google dork类似，你可以通过输入目标的域名或IP地址在Shodan上进行简单搜索；或者，你可以像编写Google查询一样使用搜索参数。[表6-3](#table6-3)展示了一些有用的Shodan查询。
- en: 'Table 6-3: Shodan Query Parameters'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-3：Shodan查询参数
- en: '| **Shodan queries** | **Purpose** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **Shodan查询** | **目的** |'
- en: '| --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `hostname:"targetname.com"` | Using `hostname` will perform a basic Shodan
    search for your target’s domain name. This should be combined with the following
    queries to get results specific to your target. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `hostname:"targetname.com"` | 使用`hostname`可以对目标的域名进行基本的Shodan搜索。这个查询应该与以下查询结合使用，以获取与目标相关的具体结果。
    |'
- en: '| `"content-type: application/json"` | APIs should have their `content-type`
    set to JSON or XML. This query will filter results that respond with JSON. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `"content-type: application/json"` | API的`content-type`应该设置为JSON或XML。此查询将过滤出响应为JSON的结果。
    |'
- en: '| `"content-type: application/xml"` | This query will filter results that respond
    with XML. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `"content-type: application/xml"` | 这个查询将过滤出响应为XML的结果。 |'
- en: '| `"200 OK"` | You can add `"200 OK"` to your search queries to get results
    that have had successful requests. However, if an API does not accept the format
    of Shodan’s request, it will likely issue a 300 or 400 response. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `"200 OK"` | 你可以在搜索查询中加入`"200 OK"`来获取请求成功的结果。然而，如果一个API不接受Shodan请求的格式，它可能会返回300或400响应。
    |'
- en: '| `"wp-json"` | This will search for web applications using the WordPress API.
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `"wp-json"` | 该查询将搜索使用WordPress API的网页应用程序。 |'
- en: 'You can put together Shodan queries to discover API endpoints, even if the
    APIs do not have standard naming conventions. If, as shown in [Figure 6-5](#figure6-5),
    we were targeting eWise ([https://www.ewise.com](https://www.ewise.com)), a money
    management company, we could use the following query to see if it had API endpoints
    that had been scanned by Shodan:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以组合Shodan查询来发现API端点，即使这些API没有标准的命名约定。如[图6-5](#figure6-5)所示，假设我们的目标是eWise（[https://www.ewise.com](https://www.ewise.com)），一家资金管理公司，我们可以使用以下查询查看Shodan是否扫描过它的API端点：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Screenshot of Shodan’s interface displaying an IP address corresponding to
    the query entered](image_fi/502444c06/F06005.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Shodan界面的截图，显示与输入的查询对应的IP地址](image_fi/502444c06/F06005.png)'
- en: 'Figure 6-5: Shodan search results'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-5：Shodan搜索结果
- en: In [Figure 6-5](#figure6-5), we see that Shodan has provided us with a potential
    target endpoint. Investigating this result further reveals SSL certificate information
    related to eWise—namely, that the web server is Nginx and that the response includes
    an `application/json` header. The server issued a 401 JSON response code commonly
    used in REST APIs. We were able to discover an API endpoint without any API-related
    naming conventions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6-5](#figure6-5)中，我们看到Shodan为我们提供了一个潜在的目标端点。进一步调查这个结果时，揭示了与eWise相关的SSL证书信息——即，网页服务器是Nginx，并且响应包含`application/json`头。该服务器发出了一个常用于REST
    API的401 JSON响应代码。我们能够发现一个没有任何与API相关的命名约定的API端点。
- en: Shodan also has browser extensions that let you conveniently check Shodan scan
    results as you visit sites with your browser.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Shodan还提供了浏览器扩展，可以让你在浏览网站时方便地查看Shodan扫描结果。
- en: OWASP Amass
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OWASP Amass
- en: Introduced in Chapter 4, OWASP Amass is a command line tool that can map a target’s
    external network by collecting OSINT from over 55 different sources. You can set
    it to perform passive or active scans. If you choose the active option, Amass
    will collect information directly from the target by requesting its certificate
    information. Otherwise, it collects data from search engines (such as Google,
    Bing, and HackerOne), SSL certificate sources (such as GoogleCT, Censys, and FacebookCT),
    search APIs (such as Shodan, AlienVault, Cloudflare, and GitHub), and the web
    archive Wayback.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 章中介绍过，OWASP Amass 是一个命令行工具，通过从 55 个不同的来源收集 OSINT 来映射目标的外部网络。你可以设置它执行被动或主动扫描。如果选择主动选项，Amass
    将直接向目标请求证书信息来收集数据。否则，它会从搜索引擎（如 Google、Bing 和 HackerOne）、SSL 证书来源（如 GoogleCT、Censys
    和 FacebookCT）、搜索 API（如 Shodan、AlienVault、Cloudflare 和 GitHub）以及网络档案 Wayback 中收集数据。
- en: 'Visit Chapter 4 for instructions on setting up Amass and adding API keys. The
    following is a passive scan of *twitter.com*, with grep used to show only API-related
    results:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅第 4 章，了解如何设置 Amass 和添加 API 密钥。以下是对 *twitter.com* 进行的被动扫描，使用 grep 仅显示与 API
    相关的结果：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This scan revealed 86 unique API subdomains, including *legacy-api.twitter.com*.
    As we know from the OWASP API Security Top 10, an API named *legacy* could be
    of particular interest because it seems to indicate an improper asset management
    vulnerability.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该扫描显示了 86 个独特的 API 子域名，包括 *legacy-api.twitter.com*。正如我们从 OWASP API 安全十大中得知的，名为
    *legacy* 的 API 可能特别值得关注，因为它似乎表明存在不当的资产管理漏洞。
- en: 'Amass has several useful command line options. Use the `intel` command to collect
    SSL certificates, search reverse Whois records, and find ASN IDs associated with
    your target. Start by providing the command with target IP addresses:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Amass 提供了几个有用的命令行选项。使用 `intel` 命令可以收集 SSL 证书、搜索反向 Whois 记录并查找与目标相关的 ASN ID。首先提供目标的
    IP 地址：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If this scan is successful, it will provide you with domain names. These domains
    can then be passed to `intel` with the `whois` option to perform a reverse Whois
    lookup:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此扫描成功，它将提供域名。这些域名可以传递给 `intel` 命令并使用 `whois` 选项执行反向 Whois 查找：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This could give you a ton of results. Focus on the interesting results that
    relate to your target organization. Once you have a list of interesting domains,
    upgrade to the `enum` subcommand to begin enumerating subdomains. If you specify
    the `-passive` option, Amass will refrain from directly interacting with your
    target:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可能会给你带来大量的结果。聚焦于与目标组织相关的有趣结果。一旦你拥有了有趣的域名列表，就可以切换到 `enum` 子命令开始枚举子域名。如果你指定了
    `-passive` 选项，Amass 将避免直接与目标进行交互：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The active `enum` scan will perform much of the same scan as the passive one,
    but it will add domain name resolution, attempt DNS zone transfers, and grab SSL
    certificate information:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 主动的 `enum` 扫描将执行与被动扫描类似的扫描，但它将添加域名解析、尝试 DNS 区域传输，并抓取 SSL 证书信息：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To up your game, add the `-brute` option to brute-force subdomains, `-w` to
    specify the API_superlist wordlist, and then the `-dir` option to send the output
    to the directory of your choice:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要提升你的技能，可以添加 `-brute` 选项来强行列出子域名，使用 `-w` 来指定 API_superlist 字典，然后使用 `-dir` 选项将输出发送到你选择的目录：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you’d like to visualize relationships between the data Amass returns, use
    the `viz` subcommand, as shown next, to make a cool-looking web page (see [Figure
    6-6](#figure6-6)). This page allows you to zoom in and check out the various related
    domains and hopefully some API endpoints.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要可视化 Amass 返回数据之间的关系，可以使用 `viz` 子命令，如下所示，生成一个外观酷炫的网页（见 [图 6-6](#figure6-6)）。这个页面允许你放大并查看不同的相关域名，并希望能找到一些
    API 端点。
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Screenshot of a visualization of related domains generated by Amass](image_fi/502444c06/F06006.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![Amass 生成的相关域名可视化截图](image_fi/502444c06/F06006.png)'
- en: 'Figure 6-6: OWASP Amass visualization using `-d3` to make an HTML export of
    Amass findings for *t**witter**.com*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-6：使用 `-d3` 选项对 Amass 发现的结果进行 HTML 导出，以可视化 *t**witter**.com* 的数据
- en: You can use this visualization to see the types of DNS records, dependencies
    between different hosts, and the relationships between different nodes. In [Figure
    6-6](#figure6-6), all the nodes on the left are API subdomains, while the large
    circle represents *twitter.com*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用此可视化图来查看 DNS 记录类型、不同主机之间的依赖关系以及不同节点之间的关系。在 [图 6-6](#figure6-6) 中，左侧的所有节点是
    API 子域名，而大圆圈代表 *twitter.com*。
- en: Exposed Information on GitHub
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GitHub 上公开的信息
- en: Regardless of whether your target performs its own development, it’s worth checking
    GitHub ([https://github.com](https://github.com)) for sensitive information disclosure.
    Developers use GitHub to collaborate on software projects. Searching GitHub for
    OSINT could reveal your target’s API capabilities, documentation, and secrets,
    such as admin-level API keys, passwords, and tokens, which could be useful during
    an attack.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的目标是否进行自主开发，检查GitHub（[https://github.com](https://github.com)）以发现敏感信息泄露都是值得的。开发者使用GitHub进行软件项目的协作。在GitHub上搜索开放源情报（OSINT）可能揭示你目标的API能力、文档和秘密，如管理员级别的API密钥、密码和令牌，这些信息可能在攻击过程中非常有用。
- en: Begin by searching GitHub for your target organization’s name paired with potentially
    sensitive types of information, such as “api-key,” “password,” or “token.” Then
    investigate the various GitHub repository tabs to discover API endpoints and potential
    weaknesses. Analyze the source code in the Code tab, find software bugs in the
    Issues tab, and review proposed changes in the Pull requests tab.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在GitHub上搜索你目标组织的名称，并搭配可能敏感的信息类型，如“api-key”、“password”或“token”。然后，调查GitHub上的各种仓库标签，发现API端点和潜在的弱点。分析代码标签中的源代码，在问题标签中查找软件漏洞，并在拉取请求标签中审查提议的更改。
- en: Code
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: Code contains the current source code, readme files, and other files (see [Figure
    6-7](#figure6-7)). This tab will provide you with the name of the last developer
    who committed to the given file, when that commit happened, contributors, and
    the actual source code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 代码标签包含当前的源代码、README文件和其他文件（见[图6-7](#figure6-7)）。此标签将提供最近提交该文件的开发者名称、提交时间、贡献者以及实际源代码。
- en: '![Screenshot of source code in the GitHub code tab](image_fi/502444c06/F06007.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![GitHub代码标签页中源码的截图](image_fi/502444c06/F06007.png)'
- en: 'Figure 6-7: An example of the GitHub Code tab where you can review the source
    code of different files'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-7：GitHub代码标签示例，你可以在这里查看不同文件的源代码
- en: Using the Code tab, you can review the code in its current form or use ctrl-F
    to search for terms that may interest you (such as “API,” “key,” and “secret”).
    Additionally, view historical commits to the code by using the History button
    found at the top-right corner of [Figure 6-7](#figure6-7). If you came across
    an issue or comment that led you to believe there were once vulnerabilities associated
    with the code, you can look for historical commits to see if the vulnerabilities
    are still viewable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码标签，你可以查看当前版本的代码，或者使用ctrl-F搜索你感兴趣的术语（如“API”、“key”和“secret”）。此外，通过使用[图6-7](#figure6-7)右上角的历史按钮，查看代码的历史提交。如果你遇到了一个问题或评论，导致你认为代码中曾经有过漏洞，你可以查看历史提交，看看这些漏洞是否仍然可见。
- en: When looking at a commit, use the Split button to see a side-by-side comparison
    of the file versions to find the exact place where a change to the code was made
    (see [Figure 6-8](#figure6-8)).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 查看提交时，使用分屏按钮查看文件版本的并排对比，找出代码更改的确切位置（见[图6-8](#figure6-8)）。
- en: '![Screenshot of a split window in the GitHub interface that highlights changes
    between two versions of a program](image_fi/502444c06/F06008.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![GitHub界面中展示两个版本之间差异的分屏窗口截图](image_fi/502444c06/F06008.png)'
- en: 'Figure 6-8: The Split button allows you to separate the previous code (left)
    from the updated code (right).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-8：分屏按钮允许你将之前的代码（左侧）与更新后的代码（右侧）分开显示。
- en: Here, you can see a commit to a financial application that removed the SonarQube
    private API key from the code, revealing both the key and the API endpoint it
    was used for.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到对一个金融应用程序的提交，该提交移除了SonarQube私有API密钥，揭示了该密钥及其使用的API端点。
- en: Issues
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问题
- en: The Issues tab is a space where developers can track bugs, tasks, and feature
    requests. If an issue is open, there is a good chance that the vulnerability is
    still live within the code (see [Figure 6-9](#figure6-9)).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 问题标签是开发者跟踪漏洞、任务和功能请求的地方。如果一个问题处于开放状态，那么该漏洞很可能仍然存在于代码中（见[图6-9](#figure6-9)）。
- en: '![Screenshot of a GitHub issues tab that reads “API key is public.” Contains
    a comment recommending that an API key be removed.](image_fi/502444c06/F06009.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![GitHub问题标签页的截图，显示“API密钥是公开的。”并包含一个评论，建议移除API密钥。](image_fi/502444c06/F06009.png)'
- en: 'Figure 6-9: An open GitHub issue that provides the exact location of an exposed
    API key in the code of an application'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-9：一个公开的GitHub问题，提供了暴露的API密钥在应用程序代码中的准确位置
- en: If the issue is closed, note the date of the issue and then search the commit
    history for any changes around that time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题已关闭，请记录该问题的日期，然后查找该时间段内的提交历史，查看是否有相关更改。
- en: Pull Requests
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 拉取请求
- en: The Pull requests tab is a place that allows developers to collaborate on changes
    to the code. If you review these proposed changes, you might sometimes get lucky
    and find an API exposure that is in the process of being resolved. For example,
    in [Figure 6-10](#figure6-10), the developer has performed a pull request to remove
    an exposed API key from the source code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取请求标签是一个允许开发者协作修改代码的地方。如果你审查这些提议的更改，有时你可能会幸运地发现一个正在解决的API泄露问题。例如，在[图6-10](#figure6-10)中，开发者已经提交了一个拉取请求，试图从源代码中移除暴露的API密钥。
- en: '![Screenshot of a GitHub pull request titled “Removed Exposed API_KEY”](image_fi/502444c06/F06010.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![GitHub拉取请求截图，标题为“移除暴露的API_KEY”](image_fi/502444c06/F06010.png)'
- en: 'Figure 6-10: A developer’s comments in the pull request conversation can reveal
    private API keys.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-10：开发者在拉取请求对话中的评论可能会泄露私有API密钥。
- en: As this change has not yet been merged with the code, we can easily see that
    the API key is still exposed under the Files Changed tab (see [Figure 6-11](#figure6-11)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个更改尚未与代码合并，我们可以清楚地看到在文件更改标签下，API密钥仍然暴露（见[图6-11](#figure6-11)）。
- en: '![Screenshot of the GitHub Files changed tab showing code containing the exposed
    API key](image_fi/502444c06/F06011.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![GitHub文件更改标签截图，显示包含暴露的API密钥的代码](image_fi/502444c06/F06011.png)'
- en: 'Figure 6-11: The Files Changed tab demonstrates proposed change to the code.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-11：更改文件标签展示了对代码的提议更改。
- en: The Files Changed tab reveals the section of code the developer is attempting
    to change. As you can see, the API key is on line 25; the following line is the
    proposed change to have the key removed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 文件更改标签揭示了开发者尝试更改的代码部分。正如你所看到的，API密钥在第25行；下一行是提议的更改，旨在移除该密钥。
- en: If you don’t find weaknesses in a GitHub repository, use it instead to develop
    your profile of your target. Take note of programming languages in use, API endpoint
    information, and usage documentation, all of which will prove useful moving forward.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在GitHub仓库中没有发现弱点，可以改为用它来建立你的目标资料。记录使用的编程语言、API端点信息和使用文档，这些都将对你今后的工作大有裨益。
- en: Active Recon
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主动侦察
- en: One shortcoming of performing passive reconnaissance is that you’re collecting
    information from secondhand sources. As an API hacker, the best way to validate
    this information is to obtain information directly from a target by port or vulnerability
    scanning, pinging, sending HTTP requests, making API calls, and other forms of
    interaction with a target’s environment.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 执行被动侦察的一个缺点是，你收集的信息来源于间接渠道。作为API黑客，验证这些信息的最佳方式是通过端口扫描、漏洞扫描、ping、发送HTTP请求、进行API调用以及与目标环境的其他交互形式，直接从目标获取信息。
- en: This section will focus on discovering an organization’s APIs using detection
    scanning, hands-on analysis, and targeted scanning. The lab at the end of the
    chapter will show these techniques in action.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将专注于使用检测扫描、实地分析和定向扫描发现组织的API。章节末的实验将展示这些技术的实际应用。
- en: The Active Recon Process
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主动侦察过程
- en: 'The active recon process discussed in this section should lead to an efficient
    yet thorough investigation of the target and reveal any weaknesses you can use
    to access the system. Each phase narrows your focus using information from the
    previous phase: phase one, detection scanning, uses automated scans to find services
    running HTTP or HTTPS; phase two, hands-on analysis, looks at those services from
    the end user and hacker perspectives to find points of interest; phase three uses
    findings from phase two to increase the focus of scans to thoroughly explore the
    discovered ports and services. This process is time-efficient because it keeps
    you engaging with the target while automated scans are running in the background.
    Whenever you’ve hit a dead end in your analysis, return to your automated scans
    to check for new findings.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的主动侦察过程应能有效且彻底地调查目标，揭示任何可以用来访问系统的弱点。每个阶段都利用前一阶段的信息来聚焦：第一阶段，检测扫描，使用自动化扫描来查找运行HTTP或HTTPS的服务；第二阶段，实地分析，从最终用户和黑客的角度审视这些服务，以找出值得关注的点；第三阶段利用第二阶段的发现，将扫描重点放大，彻底探索已发现的端口和服务。这个过程高效，因为它让你在自动化扫描后台运行的同时，始终与目标进行互动。每当分析遇到瓶颈时，回到自动化扫描中检查是否有新发现。
- en: 'The process is not linear: after each phase of increasingly targeted scanning,
    you’ll analyze the results and then use your findings for further scanning. At
    any point, you might find a vulnerability and attempt to exploit it. If you successfully
    exploit the vulnerability, you can move on to post-exploitation. If you don’t,
    you return to your scans and analysis.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Phase Zero: Opportunistic Exploitation'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you discover a vulnerability at any point in the active recon process, you
    should take the opportunity to attempt exploitation. You might discover the vulnerability
    in the first few seconds of scanning, after stumbling upon a comment left in a
    partially developed web page, or after months of research. As soon as you do,
    dive into exploitation and then return to the phased process as needed. With experience,
    you’ll learn when to avoid getting lost in a potential rabbit hole and when to
    go all in on an exploit.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Phase One: Detection Scanning'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The goal of detection scanning is to reveal potential starting points for your
    investigation. Begin with general scans meant to detect hosts, open ports, services
    running, and operating systems currently in use, as described in the “Baseline
    Scanning with Nmap” section of this chapter. APIs use HTTP or HTTPS, so as soon
    as your scan detects these services, let the scan continue to run and move into
    phase two.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Phase Two: Hands-on Analysis'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hands-on analysis is the act of exploring the web application using a browser
    and API client. Aim to learn about all the potential levers you can interact with
    and test them out. Practically speaking, you’ll examine the web page, intercept
    requests, look for API links and documentation, and develop an understanding of
    the business logic involved.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'You should usually consider the application from three perspectives: guests,
    authenticated users, and site administrators. *Guests* are anonymous users likely
    visiting a site for the first time. If the site hosts public information and does
    not need to authenticate users, it may only have guest users. *Authenticated users*
    have gone through some registration process and have been granted a certain level
    of access. *Administrators* have the privileges to manage and maintain the API.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Your first step is to visit the website in a browser, explore the site, and
    consider it from these perspectives. Here are some considerations for each user
    group:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Guest How would a new user use this site? Can new users interact with the API?
    Is API documentation public? What actions can this group perform?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authenticated User What can you do when authenticated that you couldn’t do as
    a guest? Can you upload files? Can you explore new sections of the web application?
    Can you use the API? How does the web application recognize that a user is authenticated?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Administrator Where would site administrators log in to manage the web app?
    What is in the page source? What comments have been left around various pages?
    What programming languages are in use? What sections of the website are under
    development or experimental?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it’s time to analyze the app as a hacker by intercepting the HTTP traffic
    with Burp Suite. When you use the web app’s search bar or attempt to authenticate,
    the app might be using API requests to perform the requested action, and you’ll
    see those requests in Burp Suite.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run into roadblocks, it’s time to review new results from the phase
    one scans running in the background and kick off phase three: targeted scans.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Phase Three: Targeted Scanning'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the targeted scanning phase, refine your scans and use tools that are specific
    to your target. Whereas detection scanning casts a wide net, targeted scanning
    should focus on the specific type of API, its version, the web application type,
    any service versions discovered, whether the app is on HTTP or HTTPS, any active
    TCP ports, and other information gleaned from understanding the business logic.
    For example, if you discover that an API is running over a nonstandard TCP port,
    you can set your scanners to take a closer look at that port. If you find out
    that the web application was made with WordPress, check whether the WordPress
    API is accessible by visiting */wp-json/wp/v2*. At this point, you should know
    the URLs of the web application and can begin brute-forcing uniform resource identifiers
    to find hidden directories and files (see “Brute-Forcing URIs with Gobuster” later
    in this chapter). Once these tools are up and running, review results as they
    flow in to perform a more targeted hands-on analysis.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The following sections describe the tools and techniques you’ll use throughout
    the phases of active reconnaissance, including detection scanning with Nmap, hands-on
    analysis using DevTools, and targeted scanning with Burp Suite and OWASP ZAP.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Baseline Scanning with Nmap
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nmap is a powerful tool for scanning ports, searching for vulnerabilities, enumerating
    services, and discovering live hosts. It’s my preferred tool for phase one detection
    scanning, but I also return to it for targeted scanning. You’ll find books and
    websites dedicated to the power of Nmap, so I won’t dive too deeply into it here.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'For API discovery, you should run two Nmap scans in particular: general detection
    and all port. The Nmap general detection scan uses default scripts and service
    enumeration against a target and then saves the output in three formats for later
    review (`-oX` for XML, `-oN` for Nmap, `-oG` for greppable, or `-oA` for all three
    formats):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The Nmap all-port scan will quickly check all 65,535 TCP ports for running
    services, application versions, and host operating system in use:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As soon as the general detection scan begins returning results, kick off the
    all-port scan. Then begin your hands-on analysis of the results. You’ll most likely
    discover APIs by looking at the results related to HTTP traffic and other indications
    of web servers. Typically, you’ll find these running on ports 80 and 443, but
    an API can be hosted on all sorts of different ports. Once you discover a web
    server, open a browser and begin analysis.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦常规检测扫描开始返回结果，启动全端口扫描。然后开始对结果进行实际分析。你很可能通过查看与 HTTP 流量和其他 Web 服务器指示相关的结果来发现
    API。通常，你会发现它们运行在端口 80 和 443 上，但 API 可以托管在各种不同的端口上。一旦发现 Web 服务器，打开浏览器并开始分析。
- en: Finding Hidden Paths in Robots.txt
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找隐藏的路径在 robots.txt 文件中
- en: '*Robots.txt* is a common text file that tells web crawlers to omit results
    from the search engine findings. Ironically, it also serves to tell us which paths
    the target wants to keep secret. You can find the *robots.txt* file by navigating
    to the target’s */robots.txt* directory (for example, [https://www.twitter.com/robots.txt](https://www.twitter.com/robots.txt)).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*Robots.txt* 是一个常见的文本文件，告诉网络爬虫忽略搜索引擎的结果。具有讽刺意味的是，它也告诉我们目标网站希望保密的路径。你可以通过导航到目标的
    */robots.txt* 目录来找到 *robots.txt* 文件（例如，[https://www.twitter.com/robots.txt](https://www.twitter.com/robots.txt)）。'
- en: 'The following is an actual *robots.txt* file from an active web server, complete
    with a disallowed */api/* path:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来自一个活跃 Web 服务器的实际 *robots.txt* 文件，其中包含一个被禁止的 */api/* 路径：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finding Sensitive Information with Chrome DevTools
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Chrome DevTools 寻找敏感信息
- en: In Chapter 4, I said that Chrome DevTools contains some highly underrated web
    application hacking tools. The following steps will help you easily and systematically
    filter through thousands of lines of code in order to find sensitive information
    in page sources.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 章中，我提到过 Chrome DevTools 包含一些被严重低估的 Web 应用程序黑客工具。以下步骤将帮助你轻松系统地筛选数千行代码，从而在页面源代码中找到敏感信息。
- en: Begin by opening your target page and then open Chrome DevTools with F12 or
    ctrl-shift-I. Adjust the Chrome DevTools window until you have enough space to
    work with. Select the Network tab and then refresh the page.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先打开你的目标页面，然后按 F12 或 ctrl-shift-I 打开 Chrome DevTools。调整 Chrome DevTools 窗口，直到有足够的空间可以进行操作。选择“网络”选项卡，然后刷新页面。
- en: Now look for interesting files (you may even find one titled “API”). Right-click
    any JavaScript files that interest you and click **Open in Sources Panel** (see
    [Figure 6-12](#figure6-12)) to view their source code. Alternatively, click XHR
    to find see the Ajax requests being made.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，寻找感兴趣的文件（你可能会找到一个名为“API”的文件）。右键点击任何你感兴趣的 JavaScript 文件，并点击 **在源面板中打开**（参见
    [图 6-12](#figure6-12)）来查看其源代码。或者，点击 XHR 查看正在发出的 Ajax 请求。
- en: '![Screenshot of the DevTools Network panel, which shows a list of the files
    that compose the web page](image_fi/502444c06/F06012.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![DevTools 网络面板的截图，显示了构成网页的文件列表](image_fi/502444c06/F06012.png)'
- en: 'Figure 6-12: The Open in Sources panel option from the DevTools Network tab'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-12：DevTools 网络选项卡中的“在源面板中打开”选项
- en: Search for potentially interesting lines of JavaScript. Some key terms to search
    for include “API,” “APIkey,” “secret,” and “password.” For example, [Figure 6-13](#figure6-13)
    illustrates how you could discover an API that is nearly 4,200 lines deep within
    a script.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索可能感兴趣的 JavaScript 行。可以搜索的关键字包括“API”、“APIkey”、“secret”和“password”。例如， [图 6-13](#figure6-13)
    演示了你如何发现一个 API，它深埋在一个脚本的近 4,200 行代码中。
- en: '![Screenshot of a highlighted API endpoint found within a source code file
    in the DevTools interface](image_fi/502444c06/F06013.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![在 DevTools 界面中的源代码文件中，突出显示的 API 端点截图](image_fi/502444c06/F06013.png)'
- en: 'Figure 6-13: On line 4,197 of this page source, an API is in use.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-13：在此页面源代码的第 4,197 行，正在使用一个 API。
- en: You can also make use of the DevTools Memory tab, which allows you to take a
    snapshot of the memory heap distribution. Sometimes the static JavaScript files
    include all sorts of information and thousands of lines of code. In other words,
    it may not be entirely clear exactly how the web app leverages an API. Instead,
    you could use the Memory panel to record how the web application is using resources
    to interact with an API.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以利用 DevTools 的内存选项卡，它可以让你拍摄内存堆分布的快照。有时，静态 JavaScript 文件包含各种信息和数千行代码。换句话说，可能并不完全清楚
    Web 应用程序是如何利用 API 的。相反，你可以使用内存面板来记录 Web 应用程序如何使用资源与 API 交互。
- en: With DevTools open, click the **Memory** tab. Under Select Profiling Type, choose
    **Heap Snapshot**. Then, under Select JavaScript VM Instance, choose the target
    to review. Next, click the **Take Snapshot** button (see [Figure 6-14](#figure6-14)).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the DevTools Memory panel with “Heap snapshot” checked and
    twitter.com selected as the target](image_fi/502444c06/F06014.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-14: The Memory panel within DevTools'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Once the file has been compiled under the Heap Snapshots section on the left,
    select the new snapshot and use ctrl-F to search for potential API paths. Try
    searching for terms using the common API path terms, like “api,” “v1,” “v2,” “swagger,”
    “rest,” and “dev.” If you need additional inspiration, check out the Assetnote
    API wordlists ([http://wordlists.assetnote.io](http://wordlists.assetnote.io)).
    If you’ve built your attack machine according to Chapter 4, these wordlists should
    be available to you under */api/wordlists*. [Figure 6-15](#figure6-15) indicates
    the results you would expect to see when using the Memory panel in DevTools to
    search a snapshot for “api”.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of API paths returned in DevTools after a search for the “api”
    keyword](image_fi/502444c06/F06015.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-15: The search results from a memory snapshot'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the Memory module can help you discover the existence of APIs
    and their paths. Additionally, you can use it to compare different memory snapshots.
    This can help you see the API paths used in authenticated and unauthenticated
    states, in different parts of a web application, and in its different features.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Finally, use the Chrome DevTools Performance tab to record certain actions (such
    as clicking a button) and review them over a timeline broken down into milliseconds.
    This lets you see if any event you initiate on a given web page is making API
    requests in the background. Simply click the circular record button, perform actions
    on a web page, and stop the recording. Then you can review the triggered events
    and investigate the initiated actions. [Figure 6-16](#figure6-16) shows a recording
    of clicking the login button of a web page.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a timeline in the DevTools performance tab highlighting the
    number of milliseconds elapsed after a click of a login button](image_fi/502444c06/F06016.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-16: A performance recording within DevTools'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Under “Main,” you can see that a click event occurred, initiating a POST request
    to the URL */identity/api/auth/login*, a clear indication that you’ve discovered
    an API. To help you spot activity on the timeline, consult the peaks and valleys
    on the graph located near the top. A peak represents an event, such as a click.
    Navigate to a peak and investigate the events by clicking the timeline.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, DevTools is filled with powerful tools that can help you discover
    APIs. Do not underestimate the usefulness of its various modules.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Validating APIs with Burp Suite
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not only will Burp Suite help you find APIs, but it can also be your primary
    mode of validating your discoveries. To validate APIs using Burp, intercept an
    HTTP request sent from your browser and then use the Forward button to send it
    to the server. Next, send the request to the Repeater module, where you can view
    the raw web server response (see [Figure 6-17](#figure6-17)).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in this example,the server returns a 401 Unauthorized status
    code, which means that I am not authorized to use the API. Compare this request
    to one that is for a nonexistent resource, and you will see that your target typically
    responds to nonexistent resources in a certain way. (To request a nonexistent
    resource, simply add various gibberish to the URL path in Repeater, like *GET
    /user/test098765*. Send the request in Repeater and see how the web server responds.
    Typically, you should get a 404 or similar response.)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of an HTTP response in Burp Suite](image_fi/502444c06/F06017.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-17: The web server returns an HTTP 401 Unauthorized error.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The verbose error message found under the `WWW-Authenticate` header reveals
    the path */api/auth*, validating the existence of the API. Return to Chapter 4
    for a crash course on using Burp.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Crawling URIs with OWASP ZAP
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the objectives of active reconnaissance is to discover all of a web
    page’s directories and files, also known as *URIs*, or *uniform resource identifiers*.
    There are two approaches to discovering a site’s URIs: crawling and brute force.
    OWASP ZAP crawls web pages to discover content by scanning each page for references
    and links to other web pages.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: To use ZAP, open it and click past the session pop-up. If it isn’t already selected,
    click the **Quick Start** tab, shown in [Figure 6-18](#figure6-18). Enter the
    target URL and click **Attack**.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the ZAP Quick Start interface, which accepts a URL to attack
    and has “Use traditional spider” checked](image_fi/502444c06/F06018.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-18: An automated scan set up to scan a target with OWASP ZAP'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: After the automated scan commences, you can watch the live results using the
    Spider or Sites tab. You may discover API endpoints in these tabs. If you do not
    find any obvious APIs, use the Search tab, shown in [Figure 6-19](#figure6-19),
    and look for terms like “API,” “GraphQL,” “JSON,” “RPC,” and “XML” to find potential
    API endpoints.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a ZAP interface listing discovered API endpoints and showing
    the code in which they were found](image_fi/502444c06/F06019.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-19: The power of searching the ZAP automated scan results for APIs'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve found a section of the site you want to investigate more thoroughly,
    begin manual exploration using the ZAP HUD to interact with the web application’s
    buttons and user input fields. While you do this, ZAP will perform additional
    scans for vulnerabilities. Navigate to the **Quick Start** tab and select **Manual
    Explore** (you may need to click the back arrow to exit the automated scan). On
    the Manual Explore screen, shown in [Figure 6-20](#figure6-20), select your desired
    browser and then click **Launch Browser**.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the ZAP Manual Explore page, which accepts a URL to test and
    has “Enable HUD” selected](image_fi/502444c06/F06020.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-20: Launching the Manual Explore option of Burp Suite'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The ZAP HUD should now be enabled. Click **Continue to Your Target** in the
    ZAP HUD welcome screen (see [Figure 6-21](#figure6-21)).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the ZAP HUD interface showing a welcome message, as well as
    “Continue to your target” and “Take the HUD tutorial” buttons](image_fi/502444c06/F06021.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-21: This is the first screen you will see when you launch the ZAP
    HUD.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Now you can manually explore the target web application, and ZAP will work in
    the background to automatically scan for vulnerabilities. In addition, ZAP will
    continue to search for additional paths while you navigate around the site. Several
    buttons should now line the left and right borders of the browser. The colored
    flags represent page alerts, which could be vulnerability findings or interesting
    anomalies. These flagged alerts will be updated as you browse around the site.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Brute-Forcing URIs with Gobuster
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gobuster can be used to brute-force URIs and DNS subdomains from the command
    line. (If you prefer a graphical user interface, check out OWASP’s Dirbuster.)
    In Gobuster, you can use wordlists for common directories and subdomains to automatically
    request every item in the wordlist, send the items to a web server, and filter
    the interesting server responses. The results generated from Gobuster will provide
    you with the URL path and the HTTP status response codes. (While you can brute-force
    URIs with Burp Suite’s Intruder, Burp Community Edition is much slower than Gobuster.)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you’re using a brute-force tool, you’ll have to balance the size of
    the wordlist and the length of time needed to achieve results. Kali has directory
    wordlists stored under */usr/share/wordlists/dirbuster* that are thorough but
    will take some time to complete. Instead, you can use the *~/api/wordlists* we
    set up in Chapter 4, which will speed up your Gobuster scans since the wordlist
    is relatively short and contains only directories related to APIs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses an API-specific wordlist to find the directories
    on an IP address:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once you find API directories like the */api* directory shown in this output,
    either by crawling or brute force, you can use Burp to investigate them further.
    Gobuster has additional options, and you can list them using the `-h` option:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you would like to ignore certain response status codes, use the option `-b`.
    If you would like to see additional status codes, use `-x`. You could enhance
    a Gobuster search with the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Gobuster provides a quick way to enumerate active URLs and find API paths.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Discovering API Content with Kiterunner
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Chapter 4, I covered the amazing accomplishments of Assetnote’s Kiterunner,
    the best tool available for discovering API endpoints and resources. Now it’s
    time to put this tool to use.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: While Gobuster works well for a quick scan of a web application to discover
    URL paths, it typically relies on standard HTTP GET requests. Kiterunner will
    not only use all HTTP request methods common with APIs (GET, POST, PUT, and DELETE)
    but also mimic common API path structures. In other words, instead of requesting
    GET */api/v1/user/create*, Kiterunner will try POST *POST /api/v1/user/create*,
    mimicking a more realistic request.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'You can perform a quick scan of your target’s URL or IP address like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, Kiterunner will provide you with a list of interesting paths.
    The fact that the server is responding uniquely to requests to certain */api/*
    paths indicates that the API exists.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Note that we conducted this scan without any authorization headers, which the
    target API likely requires. I will demonstrate how to use Kiterunner with authorization
    headers in Chapter 7.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use a text wordlist rather than a *.kite* file, use the `brute`
    option with the text file of your choice:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you have many targets, you can save a list of line-separated targets as
    a text file and use that file as the target. You can use any of the following
    line-separated URI formats as input:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '*Test.com*'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Test2.com:443*'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*http://test3.com*'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*http://test4.com*'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*http://test5.com:8888/api*'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One of the coolest Kiterunner features is the ability to replay requests. Thus,
    not only will you have an interesting result to investigate, you will also be
    able to dissect exactly why that request is interesting. In order to replay a
    request, copy the entire line of content into Kiterunner, paste it using the `kb
    replay` option, and include the wordlist you used:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Running this will replay the request and provide you with the HTTP response.
    You can then review the contents to see if there is anything worthy of investigation.
    I normally review interesting results and then pivot to testing them using Postman
    and Burp Suite.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we took a practical dive into discovering APIs using passive
    and active reconnaissance. Information gathering is arguably the most important
    part of hacking APIs for a few reasons. First, you cannot attack an API if you
    cannot find it. Passive reconnaissance will provide you with insight into an organization’s
    public exposure and attack surface. You may be able to find some easy wins such
    as passwords, API keys, API tokens, and other information disclosure vulnerabilities.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Next, actively engaging with your client’s environment will uncover the current
    operational context of their API, such as the operating system of the server hosting
    it, the API version, the type of API, what supporting software versions are in
    use, whether the API is vulnerable to known exploits, the intended use of the
    systems, and how they work together.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll begin manipulating and fuzzing APIs to discover
    vulnerabilities.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Lab #3: Performing Active Recon for a Black Box Test'
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your company has been approached by a well-known auto services business, crAPI
    Car Services. The company wants you to perform an API penetration test. In some
    engagements, the customer will provide you with details such as their IP address,
    port number, and maybe API documentation. However, crAPI wants this to be a black
    box test. The company is counting on you to find its API and eventually test whether
    it has any vulnerabilities.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have your crAPI lab instance up and running before you proceed.
    Using your Kali API hacking machine, start by discovering the API’s IP address.
    My crAPI instance is located at *192.168.50.35*. To discover the IP address of
    your locally deployed instance, run `netdiscover` and then confirm your findings
    by entering the IP address in a browser. Once you have your target address, use
    Nmap for general detection scanning.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Begin with a general Nmap scan to find out what you are working with. As discussed
    earlier, `nmap -sC -sV 192.168.50.35 -oA crapi_scan` scans the provided target
    by using service enumeration and default Nmap scripts, and then it saves the results
    in multiple formats for later review.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This Nmap scan result shows that the target has several open ports, including
    1025, 5432, 8000, 8080, 8087, and 8888\. Nmap has provided enough information
    for you to know that port 1025 is running an SMTP mail service, port 5432 is a
    PostgreSQL database, and the remaining ports received HTTP responses. The Nmap
    scans also reveal that the HTTP services are using CPython, WSGIServer, and OpenResty
    web app servers.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the response from port 8080, whose headers suggest an API:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Follow up the general Nmap scan with an all-port scan to see if anything is
    hiding on an uncommon port:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The all-port scan discovers a MailHog web server running on 8025 and MongoDB
    on the uncommon port 27017\. These could prove useful when we attempt to exploit
    the API in later labs.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of your initial Nmap scans reveal a web application running on
    port 8080, which should lead to the next logical step: a hands-on analysis of
    the web app. Visit all ports that sent HTTP responses to Nmap (namely, ports 8000,
    8025, 8080, 8087, and 8888).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'For me, this would mean entering the following addresses in a browser:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '*http://192.168.50.35:8000*'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*http://192.168.50.35:8025*'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*http://192.168.50.35:8080*'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*http://192.168.50.35:8087*'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*http://192.168.50.35:8888*'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Port 8000 issues a blank web page with the message “The requested resource was
    not found on this server.”
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Port 8025 reveals the MailHog web server with a “welcome to crAPI” email. We
    will return to this later in the labs.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Port 8080 returns the `{ "error": "Invalid Token" }` we received in the first
    Nmap scan.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Port 8087 shows a “404 page not found” error.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Finally, port 8888 reveals the crAPI login page, as seen in [Figure 6-22](#figure6-22).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Due to the errors and information related to authorization, the open ports will
    likely be of more use to you as an authenticated user.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the crAPI login interface with a username and password field](image_fi/502444c06/F06022.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-22: The landing page for crAPI'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Now use DevTools to investigate the JavaScript source files on this page. Visit
    the Network tab and refresh the page so the source files populate. Select a source
    file that interests you, right-click it, and send it to the Sources panel.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: You should uncover the */static/js/main.f6a58523.chunk.js* source file. Search
    for “API” within this file, and you’ll find references to crAPI API endpoints
    (see [Figure 6-23](#figure6-23)).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You’ve discovered your first API using Chrome DevTools for
    active reconnaissance. By simply searching through a source file, you found many
    unique API endpoints.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you review the source file, you should notice APIs involved in the signup
    process. As a next step, it would be a good idea to intercept the requests for
    this process to see the API in action. On the crAPI web page, click the **Signup**
    button. Fill in the name, email, phone, and password fields. Then, before clicking
    the Signup button at the bottom of the page, start Burp Suite and use the FoxyProxy
    Hackz proxy to intercept your browser traffic. Once Burp Suite and the Hackz proxy
    are running, click the **Signup** button.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a file in DevTools showing a list of API endpoints](image_fi/502444c06/F06023.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-23: The crAPI main JavaScript source file'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 6-24](#figure6-24), you can see that the crAPI signup page issues
    a POST request to */identity/api/auth/signup* when you register for a new account.
    This request, captured in Burp, validates that you have discovered the existence
    of the crAPI API and confirmed firsthand one of the functions of the identified
    endpoint.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a POST request in Burp Suite](image_fi/502444c06/F06024.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-24: The crAPI registration request intercepted using Burp Suite'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Great job! Not only did you discover an API, but you also found a way to interact
    with it. In our next lab, you’ll interact with this API’s functions and identify
    its weaknesses. I encourage you to continue testing other tools against this target.
    Can you discover APIs in any other ways?
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
