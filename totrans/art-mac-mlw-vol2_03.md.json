["```\n% **file CloudMensis/WindowServer**\nCloudMensis/WindowServer: Mach-O universal binary with 2 architectures:\n[x86_64:Mach-O 64-bit executable x86_64] [arm64:Mach-O 64-bit executable arm64]\n\nCloudMensis/WindowServer (for architecture x86_64): Mach-O 64-bit executable x86_64\nCloudMensis/WindowServer (for architecture arm64):  Mach-O 64-bit executable arm64 \n```", "```\nstruct fat_header {\n    uint32_t    magic;        /* FAT_MAGIC or FAT_MAGIC_64 */\n    uint32_t    nfat_arch;    /* number of structs that follow */\n}; \n```", "```\n% **xxd -e -c 4 -g 0 CloudMensis/WindowServer**\n00000000: bebafeca ...\n... \n```", "```\n% **xxd -c 4 -g 0 CloudMensis/WindowServer**\n...\n00000004: 00000002 ... \n```", "```\nstruct fat_arch {\n    cpu_type_t       cputype;       /* cpu specifier (int) */\n    cpu_subtype_t    cpusubtype;    /* machine specifier (int) */\n    uint32_t         offset;        /* file offset to this object file */\n uint32_t    size;     /* size of this object file */\n    uint32_t    align;    /* alignment as a power of 2 */\n}; \n```", "```\n#import <mach-o/fat.h>\n#import <mach-o/arch.h>\n#import <mach-o/swap.h>\n#import <mach-o/loader.h>\n\nint main(int argc, const char* argv[]) {\n\n    NSData* data = [NSData dataWithContentsOfFile:[NSString stringWithUTF8String:argv[1]]]; ❶\n    struct fat_header* fatHeader = (struct fat_header*)data.bytes; ❷\n\n    if((FAT_MAGIC == fatHeader->magic) || ❸\n        (FAT_CIGAM == fatHeader->magic)) {\n        printf(\"\\nBinary is universal (fat)\\n\");\n        struct fat_arch* bestArch = parseFat(argv[1], fatHeader);\n ...\n    }\n    ...\n} \n```", "```\nstruct fat_arch* parseFat(const char* file, NSData* data) {\n    const NXArchInfo* localArch = NXGetLocalArchInfo(); \n```", "```\nstruct fat_header* header = (struct fat_header*)data.bytes;\n\nif(FAT_CIGAM == header->magic) { ❶\n    swap_fat_header(header, localArch->byteorder); ❷\n    swap_fat_arch((struct fat_arch*)((unsigned char*)header + sizeof(struct fat_header)),\n    header->nfat_arch, localArch->byteorder); ❸\n}\n\nprintf(\"Fat header\\n\");\nprintf(\"fat_magic %#x\\n\", header->magic);\nprintf(\"nfat_arch %d\\n\",  header->nfat_arch); \n```", "```\nstruct fat_arch* arch = (struct fat_arch*)((unsigned char*)header + sizeof(struct fat_header));\n\nfor(uint32_t i = 0; i < header->nfat_arch; i++) { ❶\n    printf(\"architecture %d\\n\", i);\n    printFatArch(&arch[i]);\n}\n\nvoid printFatArch(struct fat_arch* arch) { ❷\n    int32_t cpusubtype = 0;\n    cpusubtype = arch->cpusubtype & ~CPU_SUBTYPE_MASK; ❸\n\n    printf(\" cputype %u (%#x)\\n\", arch->cputype, arch->cputype);\n    printf(\" cpusubtype %u (%#x)\\n\", cpusubtype, cpusubtype);\n    printf(\" capabilities 0x%#x\\n\", (arch->cpusubtype & CPU_SUBTYPE_MASK) >> 24);\n    printf(\" offset %u (%#x)\\n\", arch->offset, arch->offset);\n    printf(\" size %u (%#x)\\n\", arch->size, arch->size);\n    printf(\" align 2^%u (%d)\\n\", arch->align, (int)pow(2, arch->align));\n} \n```", "```\n% **./parseBinary CloudMensis/WindowServer**\nBinary is universal (fat)\nFat header\nfat_magic 0xcafebabe\nnfat_arch 2\narchitecture 0\n    cputype 16777223 (0x1000007)\n    cpusubtype 3 (0x3)\n    capabilities 0x0\n    offset 16384 (0x4000)\n    size 708560 (0xacfd0)\n    align 2^14 (16384)\narchitecture 1\n    cputype 16777228 (0x100000c)\n    cpusubtype 0 (0)\n    capabilities 0x0\n    offset 737280 (0xb4000)\n    size 688176 (0xa8030)\n    align 2^14 (16384) \n```", "```\n% **otool -f CloudMensis/WindowServer**\nFat headers\nfat_magic 0xcafebabe\nnfat_arch 2\narchitecture 0\n    cputype 16777223\n    cpusubtype 3\n    capabilities 0x0\n    offset 16384\n    size 708560\n    align 2^14 (16384)\narchitecture 1\n    cputype 16777228\n    cpusubtype 0\n    capabilities 0x0\n    offset 737280\n    size 688176\n    align 2^14 (16384) \n```", "```\nbestArchitecture = NXFindBestFatArch(localArch->cputype, localArch->\ncpusubtype, arch, header->nfat_arch); \n```", "```\n% **./parseBinary CloudMensis/WindowServer**\n...\nbest architecture match\n    cputype 16777228 (0x100000c)\n    cpusubtype 0 (0)\n    capabilities 0x0\n    offset 737280 (0xb4000)\n    size 688176 (0xa8030)\n    align 2^14 (16384) \n```", "```\n% **./enumerateProcesses**\n...\n(1990):/Library/WebServer/share/httpd/manual/WindowServer\n...\narchitecture: Apple Silicon \n```", "```\nENOENT - path does not exist\nEACCES - path exists but caller does not have permission to access it\nEFTYPE - path exists but it is not a Mach-o or fat file\nEBADMACHO - path is a Mach-o file, but it is malformed \n```", "```\nvoid (^ _Nullable callback)(const struct mach_header* _Nonnull slice,\nuint64_t offset, size_t size, bool* _Nonnull stop) \n```", "```\nstruct fat_arch* parseFat(const char* file, struct fat_header* header) {\n    ...\n    if(@available(macOS 13.0, *)) {\n        __block int count = 0;\n\n        int result = macho_for_each_slice(file,\n        ^(const struct mach_header* slice, uint64_t offset, size_t size, bool* stop) { ❶\n            printf(\"architecture %d\\n\", count++); ❷\n            printf(\"offset %llu (%#llx)\\n\", offset, offset);\n            printf(\"size %zu (%#zx)\\n\", size, size);\n            printf(\"name %s\\n\\n\", macho_arch_name_for_mach_header(slice)); ❸\n        });\n        if(0 != result) {\n            printf(\"ERROR: macho_for_each_slice failed\\n\");\n\n            switch(result) { ❹\n                case EFTYPE:\n                    printf(\"EFTYPE: path exists but it is not a Mach-o or fat file\\n\\n\");\n                    break;\n\n                case EBADMACHO:\n                    printf(\"EBADMACHO: path is a Mach-o file, but it is malformed\\n\\n\");\n                    break;\n\n                ...\n            }\n        }\n    }\n    ...\n} \n```", "```\n% **./parseBinary CloudMensis/WindowServer**\n...\narchitecture 0\n    offset 16384 (0x4000)\n    size 708560 (0xacfd0)\n    name x86_64\n\narchitecture 1\n    offset 737280 (0xb4000)\n    size 688176 (0xa8030)\n    name arm64 \n```", "```\nresult = macho_best_slice(argv[1],\n^(const struct mach_header* _Nonnull slice, uint64_t offset, size_t sliceSize) {\n    printf(\"best architecture\\n\");\n    printf(\"offset %llu (%#llx)\\n\", offset, offset);\n    printf(\"size %zu (%#zx)\\n\", sliceSize, sliceSize);\n    printf(\"name %s\\n\\n\", macho_arch_name_for_mach_header(slice));\n});\nif(0 != result) {\n    printf(\"ERROR: macho_best_slice failed with %d\\n\", result);\n} \n```", "```\n% **./parseBinary CloudMensis/WindowServer**\n...\nERROR: macho_best_slice failed with 86 \n```", "```\nNSData* data = [NSData dataWithContentsOfFile:[NSString stringWithUTF8String:argv[1]]];\n\nstruct mach_header_64* machoHeader = (struct mach_header_64*)data.bytes; ❶\n\nif((FAT_MAGIC == fatHeader->magic) ||\n    (FAT_CIGAM == fatHeader->magic)) {\n    // Removed the code that finds the best architecture, for brevity\n    ...\n    machoHeader = (struct mach_header_64*)(data.bytes + bestArch->offset); ❷\n}\n\nif((MH_MAGIC_64 == machoHeader->magic) || ❸\n    (MH_CIGAM_64 == machoHeader->magic)) {\n    printf(\"binary is Mach-O\\n\");\n    // Add code here to parse the Mach-O.\n} \n```", "```\n#define MH_MAGIC_64 0xfeedfacf\n#define MH_CIGAM_64 0xcffaedfe \n```", "```\nvoid parseMachO(struct mach_header_64* header) {\n    if(MH_CIGAM_64 == machoHeader->magic) {\n        swap_mach_header_64(machoHeader, ((NXArchInfo*)NXGetLocalArchInfo())->byteorder);\n    }\n    ...\n} \n```", "```\nvoid printMachOHeader(struct mach_header_64* header) {\n    int32_t cpusubtype = 0;\n    cpusubtype = header->cpusubtype & ~CPU_SUBTYPE_MASK;\n\n    printf(\"Mach-O header\\n\");\n    printf(\" magic %#x\\n\", header->magic);\n    printf(\" cputype %u (%#x)\\n\", header->cputype, header->cputype);\n    printf(\" cpusubtype %u (%#x)\\n\", cpusubtype, cpusubtype);\n    printf(\" capabilities %#x\\n\", (header->cpusubtype & CPU_SUBTYPE_MASK) >> 24);\n\n    printf(\" filetype %u (%#x)\\n\", header->filetype, header->filetype);\n\n    printf(\" ncmds %u\\n\", header->ncmds);\n    printf(\" sizeofcmds %u\\n\", header->sizeofcmds);\n\n    printf(\" flags %#x\\n\", header->flags);\n} \n```", "```\n% **./parseBinary CloudMensis/WindowServer**\nMach-O header:\n    magic 0xfeedfacf\n    cputype 16777228 (0x100000c)\n    cpusubtype 0 (0)\n    capabilities 0\n    filetype 2 (0x2)\n    ncmds 28\n    sizeofcmds 4192\n    flags 0x200085 \n```", "```\n% **otool -h CloudMensis/WindowServer**\n...\nCloudMensis/WindowServer (architecture arm64):\nMach header\n magic       cputype    cpusubtype   caps   filetype  ncmds  sizeofcmds  flags\n 0xfeedfacf  16777228   0            0x00   2         28     4192        0x00200085 \n```", "```\n% **otool -hv CloudMensis/WindowServer**\n...\nCloudMensis/WindowServer (architecture arm64):\nMach header\nmagic        cputype cpusubtype caps filetype ncmds sizeofcmds flags\nMH_MAGIC_64  ARM64   ALL        0x00 EXECUTE  28    4192       NOUNDEFS DYLDLINK\n                                                               TWOLEVEL PIE \n```", "```\nstruct load_command {\n   uint32_t cmd;        /* type of load command */\n   uint32_t cmdsize;    /* total size of command in bytes */\n}; \n```", "```\nNSMutableArray* findLoadCommand(struct mach_header_64* header, uint32_t type) {\n    NSMutableArray* commands = [NSMutableArray array];\n    struct load_command* command = NULL;\n\n    command = (struct load_command*)((unsigned char*)header + sizeof(struct mach_header_64)); ❶\n\n    for(uint32_t i = 0; i < header->ncmds; i++) { ❷\n        if(type == command->cmd) { ❸\n            [commands addObject:[NSValue valueWithPointer:command]]; ❹\n        }\n        command = (struct load_command*)((unsigned char*)command + command->cmdsize); ❺\n    }\n\n    return commands;\n} \n```", "```\nstruct dylib_command {\n    uint32_t       cmd;          /* LC_ID_DYLIB, LC_LOAD_{,WEAK_}DYLIB, LC_REEXPORT_DYLIB */\n    uint32_t       cmdsize;      /* includes pathname string */\n    struct dylib   dylib;        /* the library identification */\n}; \n```", "```\nNSMutableArray* extractDependencies(struct mach_header_64* header) {\n    ...\n    NSMutableArray* commands = findLoadCommand(header, LC_LOAD_DYLIB);\n\n    for(NSValue* command in commands) {\n        // Add code here to extract each dependency.\n    } \n```", "```\nstruct dylib {\n    union lc_str  name;                  /* library's path name */\n    uint32_t timestamp;                  /* library's build time stamp */\n    uint32_t current_version;            /* library's current version number */\n    uint32_t compatibility_version;      /* library's compatibility vers number*/\n}; \n```", "```\nNSMutableArray* dependencies = [NSMutableArray array];\n\nfor(NSValue* command in commands) {\n    struct dylib_command* dependency = command.pointerValue; ❶\n\n    uint32_t offset = dependency->dylib.name.offset; ❷\n    char* bytes = (char*)dependency + offset;\n    NSUInteger length = dependency->cmdsize-offset;\n\n    NSString* path = [[NSString alloc] initWithBytes:bytes length:length encoding:NSUTF8     StringEncoding]; ❸\n\n    [dependencies addObject:path];\n} \n```", "```\n% **./parseBinary CloudMensis/WindowServer**\n...\nDependencies: (count: 12): (\n    ...\n    \"/usr/lib/libobjc.A.dylib\",\n    \"/usr/lib/libSystem.B.dylib\",\n    ...\n    \"/System/Library/Frameworks/DiskArbitration.framework/Versions/A/DiskArbitration\",\n    \"/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/SystemConfiguration\"\n) \n```", "```\n% **otool -L CloudMensis/WindowServer**\n...\n\"/usr/lib/libobjc.A.dylib\",\n\"/usr/lib/libSystem.B.dylib\",\n...\n\"/System/Library/Frameworks/DiskArbitration.framework/Versions/A/DiskArbitration\",\n\"/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/SystemConfiguration\" \n```", "```\n-(void)loop_usb {\n    rax = DASessionCreate(**_kCFAllocatorDefault);\n  ❶ DARegisterDiskAppearedCallback(rax, 0x0, OnDiskAppeared, 0x0);\n    ...\n}\n\nint OnDiskAppeared() {\n    ...\n  ❷ r13 = DADiskCopyDescription(rdi);\n    rax = CFDictionaryGetValue(r13, **_kDADiskDescriptionVolumeNameKey);\n    r14 = [NSString stringWithFormat:@\"/Volumes/%@\", rax];\n    ...\n\n    rax = [functions alloc];\n    r15 = [rax randPathWithPrefix:0x64 isZip:0x0];\n\n rax = [FileTreeXML alloc];\n    [rax startFileTree:r14 dropPath:r15];\n    ...\n    [rax MoveToFileStore:r15 Copy:0x0];\n    rax = [NSURL fileURLWithPath:r14];\n    r14 = [NSMutableArray arrayWithObject:rax];\n\n    rax = [functions alloc];\n    [rax SearchAndMoveFS:r14 removable:0x1];\n    ...\n} \n```", "```\n% **./parseBinary Mokes/storeuserd**\n...\nDependencies: (count: 25): (\n    \"/System/Library/Frameworks/DiskArbitration.framework/Versions/A/DiskArbitration\",\n    \"/System/Library/Frameworks/IOKit.framework/Versions/A/IOKit\",\n    \"/System/Library/Frameworks/ApplicationServices.framework/Versions/A/ApplicationServices\",\n    \"/System/Library/Frameworks/CoreServices.framework/Versions/A/CoreServices\",\n    \"/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation\",\n    \"/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation\",\n    \"/System/Library/Frameworks/Security.framework/Versions/A/Security\",\n    \"/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/SystemConfiguration\",\n    \"/System/Library/Frameworks/Cocoa.framework/Versions/A/Cocoa\",\n    \"/System/Library/Frameworks/Carbon.framework/Versions/A/Carbon\",\n    \"/System/Library/Frameworks/AudioToolbox.framework/Versions/A/AudioToolbox\",\n    \"/System/Library/Frameworks/CoreAudio.framework/Versions/A/CoreAudio\",\n    \"/System/Library/Frameworks/QuartzCore.framework/Versions/A/QuartzCore\",\n    \"/System/Library/Frameworks/AVFoundation.framework/Versions/A/AVFoundation\",\n    \"/System/Library/Frameworks/CoreMedia.framework/Versions/A/CoreMedia\",\n    \"/System/Library/Frameworks/AppKit.framework/Versions/C/AppKit\",\n    \"/System/Library/Frameworks/AudioUnit.framework/Versions/A/AudioUnit\",\n    \"/System/Library/Frameworks/CoreWLAN.framework/Versions/A/CoreWLAN\",\n    ...\n) \n```", "```\nrax = AVFAudioInputSelectorControl::createCaptureDevice();\n...\nrax = [AVCaptureDeviceInput deviceInputWithDevice:rax error:&var_28];\n...\nQMetaObject::tr(..., \"Could not connect the video recorder\"); \n```", "```\n% **./parseBinary /Applications/iTerm.app/Contents/MacOS/iTerm2**\n...\nDependencies: (count: 33):\n    \"/usr/lib/libaprutil-1.0.dylib\",\n    \"/usr/lib/libicucore.A.dylib\",\n    \"/usr/lib/libc++.1.dylib\",\n    \"@rpath/BetterFontPicker.framework/Versions/A/BetterFontPicker\",\n    \"@rpath/SearchableComboListView.framework/Versions/A/SearchableComboListView\",\n    \"/System/Library/Frameworks/OpenDirectory.framework/Versions/A/OpenDirectory\",\n    ...\n    \"/System/Library/Frameworks/QuartzCore.framework/Versions/A/QuartzCore\",\n    \"/System/Library/Frameworks/WebKit.framework/Versions/A/WebKit\",\n    \"/usr/lib/libsqlite3.dylib\",\n    \"/usr/lib/libz.1.dylib\"\n) \n```", "```\n% **./parseBinary ZuRu/iTerm.app/Contents/MacOS/iTerm2**\n...\nDependencies: (count: 34):\n    \"/usr/lib/libaprutil-1.0.dylib\",\n    \"/usr/lib/libicucore.A.dylib\",\n    \"/usr/lib/libc++.1.dylib\",\n    \"@rpath/BetterFontPicker.framework/Versions/A/BetterFontPicker\",\n    \"@rpath/SearchableComboListView.framework/Versions/A/SearchableComboListView\",\n    \"/System/Library/Frameworks/OpenDirectory.framework/Versions/A/OpenDirectory\",\n    ...\n    \"/System/Library/Frameworks/QuartzCore.framework/Versions/A/QuartzCore\",\n    \"/System/Library/Frameworks/WebKit.framework/Versions/A/WebKit\",\n    \"/usr/lib/libsqlite3.dylib\",\n    \"/usr/lib/libz.1.dylib\",\n    \"@executable_path/../Frameworks/libcrypto.2.dylib\"\n) \n```", "```\n% **nm DazzleSpy/softwareupdate**\n...\n\"+[Exec doShellInCmd:]\",\n\"-[ShellClassObject startPty]\",\n\"-[MethodClass getIPAddress]\",\n\"-[MouseClassObject PostMouseEvent::::]\",\n\"-[KeychainClassObject getPasswordFromSecKeychainItemRef:]\"\n... \n```", "```\n_bind\n_connect\n_AVMediaTypeVideo\n_AVCaptureSessionRuntimeErrorNotification\n_NSFullUserName\n_SecKeychainItemCopyContent \n```", "```\nstruct symtab_command {\n    uint32_t        cmd;            /* LC_SYMTAB */\n    uint32_t        cmdsize;        /* sizeof(struct symtab_command) */\n    uint32_t        symoff;         /* symbol table offset */\n    uint32_t        nsyms;          /* number of symbol table entries */\n    uint32_t        stroff;         /* string table offset */\n    uint32_t        strsize;        /* string table size in bytes */\n}; \n```", "```\nstruct nlist_64 {\n    union {\n        uint32_t  n_strx;  /* index into the string table */\n    } n_un;\n    uint8_t n_type;        /* type flag, see below */\n    uint8_t n_sect;        /* section number or NO_SECT */\n    uint16_t n_desc;       /* see <mach-o/stab.h> */\n    uint64_t n_value;      /* value of this symbol (or stab offset) */\n}; \n```", "```\nNSMutableArray* extractSymbols(struct mach_header_64* header) {\n    NSMutableArray* symbols = [NSMutableArray array];\n\n    NSMutableArray* commands = findLoadCommand(header, LC_SYMTAB);\n    struct symtab_command* symTableCmd = ((NSValue*)commands.firstObject).pointerValue; ❶\n\n    void* symbolTable = (((void*)header) + symTableCmd->symoff); ❷\n    void* stringTable = (((void*)header) + symTableCmd->stroff); ❸\n    struct nlist_64* nlist = (struct nlist_64*)symbolTable; ❹\n    for(uint32_t j = 0; j < symTableCmd->nsyms; j++) { ❺\n        char* symbol = (char*)stringTable + nlist->n_un.n_strx; ❻\n        if(0 != symbol[0]) {\n            [symbols addObject:[NSString stringWithUTF8String:symbol]];\n        }\n        nlist++;\n    }\n    return symbols;\n} \n```", "```\n% **./parseBinary DazzleSpy/softwareupdate**\n...\nSymbols (count: 3101): (\n\n\"-[ShellClassObject startPty]\",\n\"-[ShellClassObject startTask]\",\n\n\"-[MethodClass getDiskSize]\",\n\"-[MethodClass getDiskFreeSize]\",\n\"-[MethodClass getDiskSystemSize]\",\n\"-[MethodClass getAllhardwareports]\",\n\"-[MethodClass getIPAddress]\",\n\n\"-[MouseClassObject PostMouseEvent::::]\",\n\"-[MouseClassObject postScrollEvent:]\",\n\n\"-[KeychainClassObject getPass:cmdTo:]\",\n\"-[KeychainClassObject getPasswordFromSecKeychainItemRef:]\",\n\n\"_bind\",\n\"_connect\",\n...\n\"_AVMediaTypeVideo\",\n\"_AVCaptureSessionRuntimeErrorNotification\",\n) \n```", "```\n% **./parseBinary oRat/darwinx64**\n...\nDependencies: (count: 0): ()\nSymbols: (count: 0): () \n```", "```\n% **otool -L oRat/darwinx64**\noRat/darwinx64:\n\n% **nm oRat/darwinx64**\noRat/darwinx64: no symbols \n```", "```\nif (!strcmp(\"__XHDR\", segptr->segname)) {\n    // PackHeader precedes __LINKEDIT\n    style = 391;  // UPX 3.91\n}\nif (!strcmp(\"__TEXT\", segptr->segname)) {\n    ptrTEXT = segptr;\n    style = 391;  // UPX 3.91\n}\nif (!strcmp(\"UPX_DATA\", segptr->segname)) {\n    // PackHeader follows loader at __LINKEDIT\n    style = 392;  // UPX 3.92\n} \n```", "```\nstruct segment_command_64 {/* for 64-bit architectures */\n    uint32_t        cmd;            /* LC_SEGMENT_64 */\n    uint32_t        cmdsize;        /* includes sizeof section_64 structs */\n    char            segname[16];    /* segment name */\n    ...\n    uint32_t        nsects;         /* number of sections in segment */\n    uint32_t        flags;          /* flags */\n}; \n```", "```\nstruct section_64 {/* for 64-bit architectures */\n    char            sectname[16];   /* name of this section */\n    char            segname[16];    /* segment this section goes in */\n    ...\n}; \n```", "```\nNSMutableArray* extractSegmentsAndSections(struct mach_header_64* header) {\n\n    NSMutableArray* names = [NSMutableArray array];\n    NSCharacterSet* nullCharacterSet = [NSCharacterSet\n    characterSetWithCharactersInString:@\"\\0\"];\n\n    NSMutableArray* commands = findLoadCommand(header, LC_SEGMENT_64);\n    for(NSValue* command in commands) {\n        // Add code here to iterate over each segment and its sections.\n    }\n return names;\n} \n```", "```\nNSMutableArray* extractSegmentsAndSections(struct mach_header_64* header) {\n    NSMutableArray* names = [NSMutableArray array];\n    ...\n\n    for(NSValue* command in commands) {\n        struct segment_command_64* segment = command.pointerValue; ❶\n\n        NSString* name = [[NSString alloc] initWithBytes:segment->segname\n        length:sizeof(segment->segname) encoding:NSASCIIStringEncoding]; ❷\n\n        name = [name stringByTrimmingCharactersInSet:nullCharacterSet];\n        [names addObject:name];\n\n        struct section_64* section = (struct section_64*)((unsigned char*)segment +\n        sizeof(struct segment_command_64)); ❸\n\n        for(uint32_t i = 0; i < segment->nsects; i++) { ❹\n            name = [[NSString alloc] initWithBytes:section->sectname\n            length:sizeof(section->sectname) encoding:NSASCIIStringEncoding]; ❺\n\n            name = [name stringByTrimmingCharactersInSet:nullCharacterSet];\n            [names addObject:name];\n\n            section++;\n        }\n    }\n    return names;\n} \n```", "```\nNSMutableSet* isPacked(NSMutableArray* segsAndSects) {\n    NSSet* packers = [NSSet setWithObjects:@\"__XHDR\", @\"upxTEXT\", @\"__MPRESS__\", nil]; ❶\n\n    NSMutableSet* packedNames = [NSMutableSet setWithArray:segsAndSects]; ❷\n    [packedNames intersectSet:packers]; ❸\n\n    return packedNames;\n} \n```", "```\n% **./parseBinary IPStorm/IPStorm**\nbinary is Mach-O\n...\nsegments and sections: (\n    \"__PAGEZERO\",\n    \"__TEXT\",\n    \"upxTEXT\",\n    \"__LINKEDIT\"\n)\n\nbinary appears to be packed\npacker-related section or segment {(upxTEXT)} detected \n```", "```\n% **./parseBinary OceanLotus.H/flashlightd**\nbinary is Mach-O\n...\nsegments and sections: (\n    \"__PAGEZERO\",\n    \"__TEXT\",\n    \"__cfstring\",\n    \"__LINKEDIT\"\n)\n\nbinary does not appear to be packed\nno packer-related sections or segments detected \n```", "```\n% **./parseBinary OceanLotus.H/flashlightd**\nbinary is Mach-O\n...\nDependencies: (count: 0): ()\nSymbols: (count: 0): () \n```", "```\nfloat calcEntropy(unsigned char* data, NSUInteger length) {\n    float pX = 0.0f;\n    float entropy = 0.0f;\n    unsigned int occurrences[256] = {0};\n\n    for(NSUInteger i = 0; i < length; i++) {\n      ❶ occurrences[0xFF & (int)data[i]]++;\n    }\n\n    for(NSUInteger i = 0; i < sizeof(occurrences)/sizeof(occurrences[0]); i++) {\n ❷ if(0 == occurrences[i]) {\n            continue;\n        }\n\n      ❸ pX = occurrences[i]/(float)length;\n        entropy -= pX*log2(pX);\n    }\n    return entropy;\n} \n```", "```\nBOOL isPackedByEntropy(struct mach_header_64* header, NSUInteger size) {\n    ...\n    BOOL isPacked = NO;\n    float compressedData = 0.0f;\n\n    NSMutableArray* commands = findLoadCommand(header, LC_SEGMENT_64);\n    for(NSValue* command in commands) {\n        ...\n        struct segment_command_64* segment = command.pointerValue;\n\n        float segmentEntropy = calcEntropy(((unsigned char*)header +\n        segment->fileoff), segment->filesize);\n\n      ❶ if(segmentEntropy > 7.0f) {\n            compressedData += segment->filesize;\n        }\n    }\n\n  ❷ if((compressedData/size) > .2) {\n        isPacked = YES;\n    }\n    ...\n    return isPacked;\n} \n```", "```\n% **./parseBinary IPStorm/IPStorm**\nbinary is Mach-O\n...\nsegment (size: 0) __PAGEZERO's entropy: 0.000000\nsegment (size: 8216576) __TEXT's entropy: 7.884009\nsegment (size: 16) __LINKEDIT's entropy: 0.000000\n\ntotal compressed data: 8216576.000000\ntotal compressed data vs. size: 0.999998\n\nbinary appears to be packed\nsignificant amount of high-entropy data detected \n```", "```\n% **./parseBinary IPStorm/IPStorm_unpacked**\nbinary is Mach-O\n...\nsegment (size: 0) __PAGEZERO's entropy: 0.000000\nsegment (size: 17190912) __TEXT's entropy: 6.185554\nsegment (size: 1265664) __DATA's entropy: 5.337738\nsegment (size: 1716348) __LINKEDIT's entropy: 5.618924\n\ntotal compressed data: 0.000000\ntotal compressed data vs. size: 0.000000\n\nbinary does *not* appear to be packed\nno significant amount of high-entropy data detected \n```", "```\n% **./parseBinary OceanLotus.H/flashlightd**\n...\nsegment (size: 0) __PAGEZERO's entropy: 0.000000\nsegment (size: 45056) __TEXT's entropy: 7.527715\nsegment (size: 2888) __LINKEDIT's entropy: 6.201859\n\ntotal compressed data: 45056.000000\ntotal compressed data vs. size: 0.939763\n\nbinary appears to be packed\nsignificant amount of high-entropy data detected \n```", "```\n#define SG_PROTECTED_VERSION_1  0x8 /* This segment is protected.  If the\n                                       segment starts at file offset 0, the\n                                       first page of the segment is not\n                                       protected.  All other pages of the\n                                       segment are protected. */ \n```", "```\n% **otool -l HackingTeam/installer**\n...\nLoad command 1\n      cmd LC_SEGMENT\n cmdsize 328\n  segname __TEXT\n   vmaddr 0x00001000\n   vmsize 0x00004000\n  fileoff 0\n filesize 16384\n  maxprot 0x00000007\n initprot 0x00000005\n   nsects 4\n    **flags 0x8** \n```", "```\nif(SG_PROTECTED_VERSION_1 == (segment->flags & SG_PROTECTED_VERSION_1)) {\n    // Segment is encrypted.\n    // Add code here to report this or to perform further processing.\n} \n```", "```\n% **./parseBinary HackingTeam/installer**\n...\nsegment __TEXT's flags: 'SG_PROTECTED_VERSION_1'\n\nbinary is encrypted \n```"]