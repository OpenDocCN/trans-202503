["```\n$ `cc -g -c prog.c mod1.c mod2.c mod3.c`\n$ `cc -g -o prog_nolib prog.o mod1.o mod2.o mod3.o`\n```", "```\n$ `ar` ``*`options archive object-file`*``...\n```", "```\n    $ `cc -g -c mod1.c mod2.c mod3.c`\n    $ `ar r libdemo.a mod1.o mod2.o mod3.o`\n    $ `rm mod1.o mod2.o mod3.o`\n    ```", "```\n    $ `ar tv libdemo.a`\n    rw-r--r-- 1000/100 1001016 Nov 15 12:26 2009 mod1.o\n    rw-r--r-- 1000/100 406668 Nov 15 12:21 2009 mod2.o\n    rw-r--r-- 1000/100  46672 Nov 15 12:21 2009 mod3.o\n    ```", "```\n    $ `ar d libdemo.a mod3.o`\n    ```", "```\n$ `cc -g -c prog.c`\n$ `cc -g -o prog prog.o libdemo.a`\n```", "```\n$ `cc -g -o prog prog.o -ldemo`\n```", "```\n$ `cc -g -o prog prog.o -L```", "```\n\nAlthough a static library may contain many object modules, the linker includes only those modules that the program requires.\n\nHaving linked the program, we can run it in the usual way:\n\n```", "```\n\n## Overview of Shared Libraries\n\nWhen a program is built by linking against a static library (or, for that matter, without using a library at all), the resulting executable file includes copies of all of the object files that were linked into the program. Thus, when several different executables use the same object modules, each executable has its own copy of the object modules. This redundancy of code has several disadvantages:\n\n*   Disk space is wasted storing multiple copies of the same object modules. Such wastage can be considerable.\n\n*   If several different programs using the same modules are running at the same time, then each holds separate copies of the object modules in virtual memory, thus increasing the overall virtual memory demands on the system.\n\n*   If a change is required (perhaps a security or bug fix) to an object module in a static library, then all executables using that module must be relinked in order to incorporate the change. This disadvantage is further compounded by the fact that the system administrator needs to be aware of which applications were linked against the library.\n\nShared libraries were designed to address these shortcomings. The key idea of a shared library is that a single copy of the object modules is shared by all programs requiring the modules. The object modules are not copied into the linked executable; instead, a single copy of the library is loaded into memory at run time, when the first program requiring modules from the shared library is started. When other programs using the same shared library are later executed, they use the copy of the library that is already loaded into memory. The use of shared libraries means that executable programs require less space on disk and (when running) in virtual memory.\n\n### Note\n\nAlthough the code of a shared library is shared among multiple processes, its variables are not. Each process that uses the library has its own copies of the global and static variables that are defined within the library.\n\nShared libraries provide the following further advantages:\n\n*   Because overall program size is smaller, in some cases, programs can be loaded into memory and started more quickly. This point holds true only for large shared libraries that are already in use by another program. The first program to load a shared library will actually take longer to start, since the shared library must be found and loaded into memory.\n\n*   Since object modules are not copied into the executable files, but instead maintained centrally in the shared library, it is possible (subject to limitations described in [Compatible Versus Incompatible Libraries](ch41.html#compatible_versus_incompatible_libraries \"Compatible Versus Incompatible Libraries\")) to make changes to the object modules without requiring programs to be relinked in order to see the changes. Such changes can be carried out even while running programs are using an existing version of the shared library.\n\nThe principal costs of this added functionality are the following:\n\n*   Shared libraries are more complex than static libraries, both at the conceptual level, and at the practical level of creating shared libraries and building the programs that use them.\n\n*   Shared libraries must be compiled to use position-independent code (described in [Position-Independent Code](ch41.html#position-independent_code \"Position-Independent Code\")), which has a performance overhead on most architectures because it requires the use of an extra register ([Hubicka, 2003]).\n\n*   *Symbol relocation* must be performed at run time. During symbol relocation, references to each symbol (a variable or function) in a shared library need to be modified to correspond to the actual run-time location at which the symbol is placed in virtual memory. Because of this relocation process, a program using a shared library may take a little more time to execute than its statically linked equivalent.\n\n### Note\n\nOne further use of shared libraries is as a building block in the *Java Native Interface* (JNI), which allows Java code to directly access features of the underlying operating system by calling C functions within a shared library. For further information, see [Liang, 1999] and [Rochkind, 2004].\n\n## Creating and Using Shared Libraries—A First Pass\n\nTo begin understanding how shared libraries operate, we look at the minimum sequence of steps required to build and use a shared library. For the moment, we’ll ignore the convention that is normally used to name shared library files. This convention, described in [Shared Library Versions and Naming Conventions](ch41.html#shared_library_versions_and_naming_conve \"Shared Library Versions and Naming Conventions\"), allows programs to automatically load the most up-to-date version of the libraries they require, and also allows multiple incompatible versions (so-called *major versions*) of a library to coexist peacefully.\n\nIn this chapter, we concern ourselves only with Executable and Linking Format (ELF) shared libraries, since ELF is the format employed for executables and shared libraries in modern versions of Linux, as well as in many other UNIX implementations.\n\n### Note\n\nELF supersedes the older *a.out* and *COFF* formats.\n\n### Creating a Shared Library\n\nIn order to build a shared version of the static library we created earlier, we perform the following steps:\n\n```", "```\n\nThe first of these commands creates the three object modules that are to be put into the library. (We explain the *cc -fPIC* option in the next section.) The *cc -shared* command creates a shared library containing the three object modules.\n\nBy convention, shared libraries have the prefix `lib` and the suffix `.so` (for *shared object*).\n\nIn our examples, we use the *gcc* command, rather than the equivalent *cc* command, to emphasize that the command-line options we are using to create shared libraries are compiler-dependent. Using a different C compiler on another UNIX implementation will probably require different options.\n\nNote that it is possible to compile the source files and create the shared library in a single command:\n\n```", "```\n\nHowever, to clearly distinguish the compilation and library building steps, we’ll write the two as separate commands in the examples shown in this chapter.\n\nUnlike static libraries, it is not possible to add or remove individual object modules from a previously built shared library. As with normal executables, the object files within a shared library no longer maintain distinct identities.\n\n### Position-Independent Code\n\nThe *cc -fPIC* option specifies that the compiler should generate *position-independent code*. This changes the way that the compiler generates code for operations such as accessing global, static, and external variables; accessing string constants; and taking the addresses of functions. These changes allow the code to be located at any virtual address at run time. This is necessary for shared libraries, since there is no way of knowing at link time where the shared library code will be located in memory. (The run-time memory location of a shared library depends on various factors, such as the amount of memory already taken up by the program that is loading the library and which other shared libraries the program has already loaded.)\n\nOn Linux/x86-32, it is possible to create a shared library using modules compiled without the *-fPIC* option. However, doing so loses some of the benefits of shared libraries, since pages of program text containing position-dependent memory references are not shared across processes. On some architectures, it is impossible to build shared libraries without the *-fPIC* option.\n\nIn order to determine whether an existing object file has been compiled with the *-fPIC* option, we can check for the presence of the name `_GLOBAL_OFFSET_TABLE_` in the object file’s symbol table, using either of the following commands:\n\n```", "```\n\nConversely, if either of the following equivalent commands yields any output, then the specified shared library includes at least one object module that was not compiled with *-fPIC*:\n\n```", "```\n\nThe string `TEXTREL` indicates the presence of an object module whose text segment contains a reference that requires run-time relocation.\n\nWe say more about the *nm*, *readelf*, and *objdump* commands in Section 41.5.\n\n### Using a Shared Library\n\nIn order to use a shared library, two steps must occur that are not required for programs that use static libraries:\n\n*   Since the executable file no longer contains copies of the object files that it requires, it must have some mechanism for identifying the shared library that it needs at run time. This is done by embedding the name of the shared library inside the executable during the link phase. (In ELF parlance, the library dependency is recorded in a `DT_NEEDED` tag in the executable.) The list of all of a program’s shared library dependencies is referred to as its *dynamic dependency list*.\n\n*   At run time, there must be some mechanism for resolving the embedded library name—that is, for finding the shared library file corresponding to the name specified in the executable file—and then loading the library into memory, if it is not already present.\n\nEmbedding the name of the library inside the executable happens automatically when we link our program with a shared library:\n\n```", "```\n\nIf we now attempt to run our program, we receive the following error message:\n\n```", "```\n\nThis brings us to the second required step: *dynamic linking*, which is the task of resolving the embedded library name at run time. This task is performed by the *dynamic linker* (also called the *dynamic linking loader* or the *run-time linker*). The dynamic linker is itself a shared library, named `/lib/ld-linux.so.2`, which is employed by every ELF executable that uses shared libraries.\n\n### Note\n\nThe pathname `/lib/ld-linux.so.2` is normally a symbolic link pointing to the dynamic linker executable file. This file has the name `ld-`*version*`.so`, where *version* is the *glibc* version installed on the system—for example, `ld-2.11.so`. The pathname of the dynamic linker differs on some architectures. For example, on IA-64, the dynamic linker symbolic link is named `/lib/ld-linux-ia64.so.2`.\n\nThe dynamic linker examines the list of shared libraries required by a program and uses a set of predefined rules in order to find the library files in the file system. Some of these rules specify a set of standard directories in which shared libraries normally reside. For example, many shared libraries reside in `/lib` and `/usr/lib`. The error message above occurs because our library resides in the current working directory, which is not part of the standard list searched by the dynamic linker.\n\n### Note\n\nSome architectures (e.g., zSeries, PowerPC64, and x86-64) support execution of both 32-bit and 64-bit programs. On such systems, the 32-bit libraries reside in `*/lib` subdirectories, and the 64-bit libraries reside in `*/lib64` subdirectories.\n\n#### The `LD_LIBRARY_PATH` environment variable\n\nOne way of informing the dynamic linker that a shared library resides in a nonstandard directory is to specify that directory as part of a colon-separated list of directories in the `LD_LIBRARY_PATH` environment variable. (Semicolons can also be used to separate the directories, in which case the list must be quoted to prevent the shell from interpreting the semicolons.) If `LD_LIBRARY_PATH` is defined, then the dynamic linker searches for the shared library in the directories it lists before looking in the standard library directories. (Later, we’ll see that a production application should never rely on `LD_LIBRARY_PATH`, but for now, this variable provides us with a simple way of getting started with shared libraries.) Thus, we can run our program with the following command:\n\n```", "```\n\nThe (*bash*, Korn, and Bourne) shell syntax used in the above command creates an environment variable definition within the process executing *prog*. This definition tells the dynamic linker to search for shared libraries in `.`, the current working directory.\n\n### Note\n\nAn empty directory specification in the `LD_LIBRARY_PATH` list (e.g., the middle specification in *dirx::diry*) is equivalent to `.`, the current working directory (but note that setting `LD_LIBRARY_PATH` to an empty string does not achieve the same result). We avoid this usage (SUSv3 discourages the corresponding usage in the `PATH` environment variable).\n\n#### Static linking and dynamic linking contrasted\n\nCommonly, the term *linking* is used to describe the use of the linker, *ld*, to combine one or more compiled object files into a single executable file. Sometimes, the term *static* linking is used to distinguish this step from *dynamic* linking, the run-time loading of the shared libraries used by an executable. (Static linking is sometimes also referred to as *link editing*, and a static linker such as *ld* is sometimes referred to as a link editor.) Every program—including those that use shared libraries—goes through a static-linking phase. At run time, a program that employs shared libraries additionally undergoes dynamic linking.\n\n### The Shared Library Soname\n\nIn the example presented so far, the name that was embedded in the executable and sought by the dynamic linker at run time was the actual name of the shared library file. This is referred to as the library’s *real name*. However, it is possible—in fact, usual—to create a shared library with a kind of alias, called a *soname* (the `DT_SONAME` tag in ELF parlance).\n\nIf a shared library has a soname, then, during static linking, the soname is embedded in the executable file instead of the real name, and subsequently used by the dynamic linker when searching for the library at run time. The purpose of the soname is to provide a level of indirection that permits an executable to use, at run time, a version of the shared library that is different from (but compatible with) the library against which it was linked.\n\nIn [Shared Library Versions and Naming Conventions](ch41.html#shared_library_versions_and_naming_conve \"Shared Library Versions and Naming Conventions\"), we’ll look at the conventions used for the shared library real name and soname. For now, we show a simplified example to demonstrate the principles.\n\nThe first step in using a soname is to specify it when the shared library is created:\n\n```", "```\n\nThe *-Wl,-soname,libbar.so* option is an instruction to the linker to mark the shared library `libfoo.so` with the soname `libbar.so`.\n\nIf we want to determine the soname of an existing shared library, we can use either of the following commands:\n\n```", "```\n\nHaving created a shared library with a soname, we then create the executable as usual:\n\n```", "```\n\nHowever, this time, the linker detects that the library `libfoo.so` contains the soname `libbar.so` and embeds the latter name inside the executable.\n\nNow when we attempt to run the program, this is what we see:\n\n```", "```\n\nThe problem here is that the dynamic linker can’t find anything named `libbar.so`. When using a soname, one further step is required: we must create a symbolic link from the soname to the real name of the library. This symbolic link must be created in one of the directories searched by the dynamic linker. Thus, we could run our program as follows:\n\n```", "```\n\n[Figure 41-1](ch41.html#creating_a_shared_library_and_linking_a \"Figure 41-1. Creating a shared library and linking a program against it\") shows the compilation and linking steps involved in producing a shared library with an embedded soname, linking a program against that shared library, and creating the soname symbolic link needed to run the program.\n\n![Creating a shared library and linking a program against it](figs/web/41-1_SHLIBS-A-shlib-create.png.jpg)Figure 41-1. Creating a shared library and linking a program against it\n\n[Figure 41-2](ch41.html#execution_of_a_program_that_loads_a_shar \"Figure 41-2. Execution of a program that loads a shared library\") shows the steps that occur when the program created in [Figure 41-1](ch41.html#creating_a_shared_library_and_linking_a \"Figure 41-1. Creating a shared library and linking a program against it\") is loaded into memory in preparation for execution.\n\n### Note\n\nTo find out which shared libraries a process is currently using, we can list the contents of the corresponding Linux-specific `/proc/`*PID/*`maps` file ([Location of Shared Memory in Virtual Memory](ch48.html#location_of_shared_memory_in_virtual_mem \"Location of Shared Memory in Virtual Memory\")).\n\n![Execution of a program that loads a shared library](figs/web/41-2_SHLIBS-A-shlib-load.png.jpg)Figure 41-2. Execution of a program that loads a shared library\n\n## Useful Tools for Working with Shared Libraries\n\nIn this section, we briefly describe a few tools that are useful for analyzing shared libraries, executable files, and compiled object (`.o`) files.\n\n#### The *ldd* command\n\nThe *ldd(1)* (list dynamic dependencies) command displays the shared libraries that a program (or a shared library) requires to run. Here’s an example:\n\n```", "```\n\nThe *ldd* command resolves each library reference (employing the same search conventions as the dynamic linker) and displays the results in the following form:\n\n```", "```\n\nFor most ELF executables, *ldd* will list entries for at least `ld-linux.so.2`, the dynamic linker, and `libc.so.6`, the standard C library.\n\n### Note\n\nThe name of the C library is different on some architectures. For example, this library is named `libc.so.6.1` on IA-64 and Alpha.\n\n#### The *objdump* and *readelf* commands\n\nThe *objdump* command can be used to obtain various information—including disassembled binary machine code—from an executable file, compiled object, or shared library. It can also be used to display information from the headers of the various ELF sections of these files; in this usage, it resembles *readelf*, which displays similar information, but in a different format. Sources of further information about *objdump* and *readelf* are listed at the end of this chapter.\n\n#### The *nm* command\n\nThe *nm* command lists the set of symbols defined within an object library or executable program. One use of this command is to find out which of several libraries defines a symbol. For example, to find out which library defines the *crypt()* function, we could do the following:\n\n```", "```\n\nThe *-A* option to *nm* specifies that the library name should be listed at the start of each line displaying a symbol. This is necessary because, by default, *nm* lists the library name once, and then, on subsequent lines, all of the symbols it contains, which isn’t useful for the kind of filtering shown in the above example. In addition, we discard standard error output in order to hide error messages about files in formats unrecognized by *nm*. From the above output, we can see that *crypt()* is defined in the *libcrypt* library.\n\n## Shared Library Versions and Naming Conventions\n\nLet’s consider what is entailed by shared library versioning. Typically, successive versions of a shared library are compatible with one another, meaning that the functions in each module present the same calling interface and are semantically equivalent (i.e., they achieve identical results). Such differing but compatible versions are referred to as *minor versions* of a shared library. Occasionally, however, it is necessary to create a new *major version* of a library—one that is incompatible with a previous version. (In [Compatible Versus Incompatible Libraries](ch41.html#compatible_versus_incompatible_libraries \"Compatible Versus Incompatible Libraries\"), we’ll see more precisely what may cause such incompatibilities.) At the same time, it must still be possible to continue running programs that require the older version of the library.\n\nTo deal with these versioning requirements, a standard naming convention is employed for shared library real names and sonames.\n\n#### Real names, sonames, and linker names\n\nEach incompatible version of a shared library is distinguished by a unique *major version identifier*, which forms part of its real name. By convention, the major version identifier takes the form of a number that is sequentially incremented with each incompatible release of the library. In addition to the major version identifier, the real name also includes a *minor version identifier*, which distinguishes compatible minor versions within the library major version. The real name employs the format convention `lib`*name*`.so.`*major-id*`.`*minor-id*.\n\nLike the major version identifier, the minor version identifier can be any string, but, by convention, it is either a number, or two numbers separated by a dot, with the first number identifying the minor version, and the second number indicating a patch level or revision number within the minor version. Some examples of real names of shared libraries are the following:\n\n```", "```\n\nThe soname of the shared library includes the same major version identifier as its corresponding real library name, but excludes the minor version identifier. Thus, the soname has the form `lib`*name*`.so.`*major-id*.\n\nUsually, the soname is created as a relative symbolic link in the directory that contains the real name. The following are some examples of sonames, along with the real names to which they might be symbolically linked:\n\n```", "```\n\nFor a particular major version of a shared library, there may be several library files distinguished by different minor version identifiers. Normally, the soname corresponding to each major library version points to the most recent minor version within the major version (as shown in the above examples for `libdemo.so`). This setup allows for the correct versioning semantics during the run-time operation of shared libraries. Because the static-linking phase embeds a copy of the (minor version-independent) soname in the executable, and the soname symbolic link may subsequently be modified to point to a newer (minor) version of the shared library, it is possible to ensure that an executable loads the most up-to-date minor version of the library at run time. Furthermore, since different major versions of a library have different sonames, they can happily coexist and be accessed by the programs that require them.\n\nIn addition to the real name and soname, a third name is usually defined for each shared library: the *linker name*, which is used when linking an executable against the shared library. The linker name is a symbolic link containing just the library name without the major or minor version identifiers, and thus has the form `lib`*name*.`so`. The linker name allows us to construct version-independent link commands that automatically operate with the correct (i.e., most up-to-date) version of the shared library.\n\nTypically, the linker name is created in the same directory as the file to which it refers. It can be linked either to the real name or to the soname of the most recent major version of the library. Usually, a link to the soname is preferable, so that changes to the soname are automatically reflected in the linker name. (In [Installing Shared Libraries](ch41.html#installing_shared_libraries \"Installing Shared Libraries\"), we’ll see that the *ldconfig* program automates the task of keeping sonames up to date, and thus implicitly maintains linker names if we use the convention just described.)\n\n### Note\n\nIf we want to link a program against an older major version of a shared library, we can’t use the linker name. Instead, as part of the link command, we would need to indicate the required (major) version by specifying a particular real name or soname.\n\nThe following are some examples of linker names:\n\n```", "```\n\n[Table 41-1](ch41.html#summary_of_shared_library_names \"Table 41-1. Summary of shared library names\") summarizes information about the shared library real name, soname, and linker name, and [Figure 41-3](ch41.html#conventional_arrangement_of_shared_libra \"Figure 41-3. Conventional arrangement of shared library names\") portrays the relationship between these names.\n\nTable 41-1. Summary of shared library names\n\n| Name | Format | Description |\n| --- | --- | --- |\n| real name | `lib` *name* `.so.` *maj* `.` *min* | File holding library code; one instance per major-plus-minor version of the library. |\n| soname | `lib` *name* `.so.` *maj* | One instance per major version of library; embedded in executable at link time; used at run time to find library via a symbolic link with same name that points to corresponding (most up-to-date) real name. |\n| linker name | `lib` *name* `.so` | Symbolic link to latest real name or (more usually) latest soname; single instance; allows construction of version-independent link commands. |\n\n![Conventional arrangement of shared library names](figs/web/41-3_SHLIBS-A-shlib-names-scale90.png.jpg)Figure 41-3. Conventional arrangement of shared library names\n\n#### Creating a shared library using standard conventions\n\nPutting all of the above information together, we now show how to build our demonstration library following the standard conventions. First, we create the object files:\n\n```", "```\n\nThen we create the shared library with the real name `libdemo.so.1.0.1` and the soname `libdemo.so.1`.\n\n```", "```\n\nNext, we create appropriate symbolic links for the soname and linker name:\n\n```", "```\n\nWe can employ *ls* to verify the setup (with *awk* used to select the fields of interest):\n\n```", "```\n\nThen we can build our executable using the linker name (note that the link command makes no mention of version numbers), and run the program as usual:\n\n```", "```\n\n## Installing Shared Libraries\n\nIn the examples up to now, we created a shared library in a user-private directory, and then used the `LD_LIBRARY_PATH` environment variable to ensure that the dynamic linker searched that directory. Both privileged and unprivileged users may use this technique. However, this technique should not be employed in production applications. More usually, a shared library and its associated symbolic links are installed in one of a number of standard library directories, in particular, one of the following:\n\n*   `/usr/lib`, the directory in which most standard libraries are installed;\n\n*   `/lib`, the directory into which libraries required during system startup should be installed (since, during system startup, `/usr/lib` may not be mounted yet);\n\n*   `/usr/local/lib`, the directory into which nonstandard or experimental libraries should be installed (placing libraries in this directory is also useful if `/usr/lib` is a network mount shared among multiple systems and we want to install a library just for use on this system); or\n\n*   one of the directories listed in `/etc/ld.so.conf` (described shortly).\n\nIn most cases, copying a file into one of these directories requires superuser privilege.\n\nAfter installation, the symbolic links for the soname and linker name must be created, usually as relative symbolic links in the same directory as the library file. Thus, to install our demonstration library in `/usr/lib` (whose permissions only allow updates by *root*), we would do the following:\n\n```", "```\n\nThe last two lines in this shell session create the soname and linker name symbolic links.\n\n#### *ldconfig*\n\nThe *ldconfig(8)* program addresses two potential problems with shared libraries:\n\n*   Shared libraries can reside in a variety of directories. If the dynamic linker needed to search all of these directories in order to find a library, then loading libraries could be very slow.\n\n*   As new versions of libraries are installed or old versions are removed, the soname symbolic links may become out of date.\n\nThe *ldconfig* program solves these problems by performing two tasks:\n\n1.  It searches a standard set of directories and creates or updates a cache file, `/etc/ld.so.cache`, to contain a list of the (latest minor versions of each of the) major library versions in all of these directories. The dynamic linker in turn uses this cache file when resolving library names at run time. To build the cache, *ldconfig* searches the directories specified in the file `/etc/ld.so.conf` and then `/lib` and `/usr/lib`. The `/etc/ld.so.conf` file consists of a list of directory pathnames (these should be specified as absolute pathnames), separated by newlines, spaces, tabs, commas, or colons. In some distributions, the directory `/usr/local/lib` is included in this list. (If not, we may need to add it manually.)\n\n    ### Note\n\n    The command *ldconfig -p* displays the current contents of `/etc/ld.so.cache`.\n\n2.  It examines the latest minor version (i.e., the version with the highest minor number) of each major version of each library to find the embedded soname and then creates (or updates) relative symbolic links for each soname in the same directory.\n\nIn order to correctly perform these actions, *ldconfig* expects libraries to be named according to the conventions described earlier (i.e., library real names include major and minor identifiers that increase appropriately from one library version to the next).\n\nBy default, *ldconfig* performs both of the above actions. Command-line options can be used to selectively inhibit either action: the *-N* option prevents rebuilding of the cache, and the *-X* option inhibits the creation of the soname symbolic links. In addition, the *-v* (*verbose*) option causes *ldconfig* to display output describing its actions.\n\nWe should run *ldconfig* whenever a new library is installed, an existing library is updated or removed, or the list of directories in `/etc/ld.so.conf` is changed.\n\nAs an example of the operation of *ldconfig*, suppose we wanted to install two different major versions of a library. We would do this as follows:\n\n```", "```\n\nAbove, we filter the output of *ldconfig*, so that we see just the information relating to libraries named `libdemo`.\n\nNext, we list the files named `libdemo` in `/usr/lib` to verify the setup of the soname symbolic links:\n\n```", "```\n\nWe must still create the symbolic link for the linker name, as shown in the next command:\n\n```", "```\n\nHowever, if we install a new 2.*x* minor version of our library, then, since the linker name points to the latest soname, *ldconfig* has the effect of also keeping the linker name up to date, as the following example shows:\n\n```", "```\n\nIf we are building and using a private library (i.e., one that is not installed in one of the standard directories), we can have *ldconfig* create the soname symbolic link for us by using the *-n* option. This specifies that *ldconfig* should process only libraries in the directories on the command line and should not update the cache file. In the following example, we use *ldconfig* to process libraries in the current working directory:\n\n```", "```\n\nIn the above example, we specified the full pathname when running *ldconfig*, because we were using an unprivileged account whose `PATH` environment variable did not include the `/sbin` directory.\n\n## Compatible Versus Incompatible Libraries\n\nOver time, we may need to make changes to the code of a shared library. Such changes result in a new version of the library that is either *compatible* with previous version(s), meaning that we need to change only the minor version identifier of the library’s real name, or *incompatible*, meaning that we must define a new major version of the library.\n\nA change to a library is compatible with an existing library version if *all* of the following conditions hold true:\n\n*   The semantics of each public function and variable in the library remain unchanged. In other words, each function keeps the same argument list, and continues to produce its specified effect on global variables and returned arguments, and returns the same result value. Thus, changes that result in an improvement in performance or fix a bug (resulting in closer conformance to specified behavior) can be regarded as compatible changes.\n\n*   No function or variable in the library’s public API is removed. It is, however, compatible to add new functions and variables to the public API.\n\n*   Structures allocated within and returned by each function remain unchanged. Similarly, public structures exported by the library remain unchanged. One exception to this rule is that, under certain circumstances, new items may be added to the end of an existing structure, though even this may be subject to pitfalls if, for example, the calling program tries to allocate arrays of this structure type. Library designers sometimes circumvent this limitation by defining exported structures to be larger than is required in the initial release of the library, with some extra padding fields being “reserved for future use.”\n\nIf none of these conditions is violated, then the new library name can be updated by adjusting the minor version of the existing name. Otherwise, a new major version of the library should be created.\n\n## Upgrading Shared Libraries\n\nOne of the advantages of shared libraries is that a new major or minor version of a library can be installed even while running programs are using an existing version. All that we need to do is create the new library version, install it in the appropriate directory, and update the soname and linker name symbolic links as required (or, more usually, have *ldconfig* do the job for us). To produce a new minor version (i.e., a compatible upgrade) of the shared library `/usr/lib/libdemo.1.0.1`, we would do the following:\n\n```", "```\n\nAssuming the linker name was already correctly set up (i.e., to point to the library soname), we would not need to modify it.\n\nAlready running programs will continue to use the previous minor version of the shared library. Only when they are terminated and restarted will they too use the new minor version of the shared library.\n\nIf we subsequently wanted to create a new major version (2.0.0) of the shared library, we would do the following:\n\n```", "```\n\nAs can be seen in the above output, *ldconfig* automatically creates a soname symbolic link for the new major version. However, as the last command shows, we must manually update the linker name symbolic link.\n\n## Specifying Library Search Directories in an Object File\n\nWe have already seen two ways of informing the dynamic linker of the location of shared libraries: using the `LD_LIBRARY_PATH` environment variable and installing a shared library into one of the standard library directories (`/lib`, `/usr/lib`, or one of the directories listed in `/etc/ld.so.conf`).\n\nThere is a third way: during the static editing phase, we can insert into the executable a list of directories that should be searched at run time for shared libraries. This is useful if we have libraries that reside in fixed locations that are not among the standard locations searched by the dynamic linker. To do this, we employ the *-rpath* linker option when creating an executable:\n\n```", "```\n\nThe above command copies the string */home/mtk/pdir* into the run-time library path (*rpath*) list of the executable *prog*, so, that when the program is run, the dynamic linker will also search this directory when resolving shared library references.\n\nIf necessary, the *-rpath* option can be specified multiple times; all of the directories are concatenated into a single ordered *rpath* list placed in the executable file. Alternatively, multiple directories can be specified as a colon-separated list within a single *-rpath* option. At run time, the dynamic linker searches the directories in the order they were specified in the *-rpath* option(s).\n\n### Note\n\nAn alternative to the *-rpath* option is the `LD_RUN_PATH` environment variable. This variable can be assigned a string containing a series of colon-separated directories that are to be used as the *rpath* list when building the executable file. `LD_RUN_PATH` is employed only if the *-rpath* option is not specified when building the executable.\n\n#### Using the *-rpath* linker option when building a shared library\n\nThe *-rpath* linker option can also be useful when building a shared library. Suppose we have one shared library, `libx1.so`, that depends on another, `libx2.so`, as shown in [Figure 41-4](ch41.html#a_shared_library_that_depends_on_another \"Figure 41-4. A shared library that depends on another shared library\"). Suppose also that these libraries reside in the nonstandard directories `d1` and `d2`, respectively. We now go through the steps required to build these libraries and the program that uses them.\n\n![A shared library that depends on another shared library](figs/web/41-4_SHLIBS-A-shlib-interdep.png.jpg)Figure 41-4. A shared library that depends on another shared library\n\nFirst, we build `libx2.so`, in the directory `pdir/d2`. (To keep the example simple, we dispense with library version numbering and explicit sonames.)\n\n```", "```\n\nNext, we build `libx1.so`, in the directory `pdir/d1`. Since `libx1.so` depends on `libx2.so`, which is not in a standard directory, we specify the latter’s run-time location with the *-rpath* linker option. This could be different from the link-time location of the library (specified by the *-L* option), although in this case the two locations are the same.\n\n```", "```\n\nFinally, we build the main program, in the `pdir` directory. Since the main program makes use of `libx1.so`, and this library resides in a nonstandard directory, we again employ the *-rpath* linker option:\n\n```", "```\n\nNote that we did not need to mention `libx2.so` when linking the main program. Since the linker is capable of analyzing the *rpath* list in `libx1.so`, it can find `libx2.so`, and thus is able to satisfy the requirement that all symbols can be resolved at static link time.\n\nWe can use the following commands to examine `prog` and `libx1.so` in order to see the contents of their *rpath* lists:\n\n```", "```\n\n### Note\n\nWe can also view the *rpath* lists by grepping the output of the *readelf --dynamic* (or, equivalently, *readelf -d*) command.\n\nWe can use the *ldd* command to show the complete set of dynamic dependencies of `prog`:\n\n```", "```\n\n#### The ELF `DT_RPATH` and `DT_RUNPATH` entries\n\nIn the original ELF specification, only one type of *rpath* list could be embedded in an executable or shared library. This corresponded to the `DT_RPATH` tag in an ELF file. Later ELF specifications deprecated `DT_RPATH`, and introduced a new tag, `DT_RUNPATH`, for representing *rpath* lists. The difference between these two types of *rpath* lists is their relative precedence with respect to the `LD_LIBRARY_PATH` environment variable when the dynamic linker searches for shared libraries at run time: `DT_RPATH` has higher precedence, while `DT_RUNPATH` has lower precedence (refer to [Finding Shared Libraries at Run Time](ch41.html#finding_shared_libraries_at_run_time \"Finding Shared Libraries at Run Time\")).\n\nBy default, the linker creates the *rpath* list as a `DT_RPATH` tag. To have the linker instead create the *rpath* list as a `DT_RUNPATH` entry, we must additionally employ the *—enable-new-dtags (enable new dynamic tags)* linker option. If we rebuild our program using this option, and inspect the resulting executable file with *objdump*, we see the following:\n\n```", "```\n\nAs can be seen, the executable contains both `DT_RPATH` and `DT_RUNPATH` tags. The linker duplicates the *rpath* list in this way for the benefit of older dynamic linkers that may not understand the `DT_RUNPATH` tag. (Support for `DT_RUNPATH` was added in version 2.2 of *glibc*.) Dynamic linkers that understand the `DT_RUNPATH` tag ignore the `DT_RPATH` tag (see [Finding Shared Libraries at Run Time](ch41.html#finding_shared_libraries_at_run_time \"Finding Shared Libraries at Run Time\")).\n\n#### Using `$ORIGIN` in *rpath*\n\nSuppose that we want to distribute an application that uses some of its own shared libraries, but we don’t want to require the user to install the libraries in one of the standard directories. Instead, we would like to allow the user to unpack the application under an arbitrary directory of their choice and then immediately be able to run the application. The problem is that the application has no way of determining where its shared libraries are located, unless it requests the user to set `LD_LIBRARY_PATH` or we require the user to run some sort of installation script that identifies the required directories. Neither of these approaches is desirable.\n\nTo get around this problem, the dynamic linker is built to understand a special string, `$ORIGIN` (or, equivalently, `${ORIGIN}`), in an *rpath* specification. The dynamic linker interprets this string to mean “the directory containing the application.” This means that we can, for example, build an application with the following command:\n\n```", "```\n\nThis presumes that at run time the application’s shared libraries will reside in the subdirectory `lib` under the directory that contains the application executable. We can then provide the user with a simple installation package that contains the application and associated libraries, and the user can install the package in any location and then run the application (i.e., a so-called “turn-key application”).\n\n## Finding Shared Libraries at Run Time\n\nWhen resolving library dependencies, the dynamic linker first inspects each dependency string to see if it contains a slash (`/`), which can occur if we specified an explicit library pathname when linking the executable. If a slash is found, then the dependency string is interpreted as a pathname (either absolute or relative), and the library is loaded using that pathname. Otherwise, the dynamic linker searches for the shared library using the following rules:\n\n1.  If the executable has any directories listed in its `DT_RPATH` run-time library path list (*rpath*) and the executable does *not* contain a `DT_RUNPATH` list, then these directories are searched (in the order that they were supplied when linking the program).\n\n2.  If the `LD_LIBRARY_PATH` environment variable is defined, then each of the colon-separated directories listed in its value is searched in turn. If the executable is a set-user-ID or set-group-ID program, then `LD_LIBRARY_PATH` is ignored. This is a security measure to prevent users from tricking the dynamic linker into loading a private version of a library with the same name as a library required by the executable.\n\n3.  If the executable has any directories listed in its `DT_RUNPATH` run-time library path list, then these directories are searched (in the order that they were supplied when linking the program).\n\n4.  The file `/etc/ld.so.cache` is checked to see if it contains an entry for the library.\n\n5.  The directories `/lib` and `/usr/lib` are searched (in that order).\n\n## Run-Time Symbol Resolution\n\nSuppose that a global symbol (i.e., a function or variable) is defined in multiple locations, such as in an executable and in a shared library, or in multiple shared libraries. How is a reference to that symbol resolved?\n\nFor example, suppose that we have a main program and a shared library, both of which define a global function, *xyz()*, and another function within the shared library calls *xyz()*, as shown in [Figure 41-5](ch41.html#resolving_a_global_symbol_reference \"Figure 41-5. Resolving a global symbol reference\").\n\n![Resolving a global symbol reference](figs/web/41-5_SHLIBS-A-symbol-res.png.jpg)Figure 41-5. Resolving a global symbol reference\n\nWhen we build the shared library and the executable program, and then run the program, this is what we see:\n\n```", "```\n\nFrom the last line of output, we can see that the definition of *xyz()* in the main program overrides (interposes) the one in the shared library.\n\nAlthough this may at first appear surprising, there is a good historical reason why things are done this way. The first shared library implementations were designed so that the default semantics for symbol resolution exactly mirrored those of applications linked against static equivalents of the same libraries. This means that the following semantics apply:\n\n*   A definition of a global symbol in the main program overrides a definition in a library.\n\n*   If a global symbol is defined in multiple libraries, then a reference to that symbol is bound to the first definition found by scanning libraries in the left-to-right order in which they were listed on the static link command line.\n\nAlthough these semantics make the transition from static to shared libraries relatively straightforward, they can cause some problems. The most significant problem is that these semantics conflict with the model of a shared library as implementing a self-contained subsystem. By default, a shared library can’t guarantee that a reference to one of its own global symbols will actually be bound to the library’s definition of that symbol. Consequently, the properties of a shared library can change when it is aggregated into a larger unit. This can lead to applications breaking in unexpected ways, and also makes it difficult to perform divide-and-conquer debugging (i.e., trying to reproduce a problem using fewer or different shared libraries).\n\nIn the above scenario, if we wanted to ensure that the invocation of *xyz()* in the shared library actually called the version of the function defined within the library, then we could use the *-Bsymbolic* linker option when building the shared library:\n\n```"]