<html><head></head><body>
<h2 class="h2a" id="ch01"><span epub:type="pagebreak" id="page_1"/><strong><span class="big">1</span></strong><br/><strong>THE BASICS OF NETWORKING</strong></h2>&#13;
<p class="noindent_first">To attack network protocols, you need to understand the basics of computer networking. The more you understand how common networks are built and function, the easier it will be to apply that knowledge to capturing, analyzing, and exploiting new protocols.</p>&#13;
<p class="indent">Throughout this chapter, I’ll introduce basic network concepts you’ll encounter every day when you’re analyzing network protocols. I’ll also lay the groundwork for a way to think about network protocols, making it easier to find previously unknown security issues during your analysis.</p>&#13;
<h3 class="h3" id="ch00lev1sec7"><strong>Network Architecture and Protocols</strong></h3>&#13;
<p class="noindent">Let’s start by reviewing some basic networking terminology and asking the fundamental question: what is a network? A <em>network</em> is a set of two or more computers connected together to share information. It’s common to refer to each connected device as a <em>node</em> on the network to make the description applicable to a wider range of devices. <a href="../Text/ch01.xhtml#ch1fig1">Figure 1-1</a> shows a very simple example.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_2"/><img alt="image" src="../Images/f01-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch1fig1"/><em>Figure 1-1: A simple network of three nodes</em></p>&#13;
<p class="indent">The figure shows three nodes connected with a common network. Each node might have a different operating system or hardware. But as long as each node follows a set of rules, or <em>network protocol</em>, it can communicate with the other nodes on the network. To communicate correctly, all nodes on a network must understand the same network protocol.</p>&#13;
<p class="indent">A network protocol serves many functions, including one or more of the following:</p>&#13;
<p class="noindent1t"><strong>Maintaining session state</strong> Protocols typically implement mechanisms to create new connections and terminate existing connections.</p>&#13;
<p class="noindent1"><strong>Identifying nodes through addressing</strong> Data must be transmitted to the correct node on a network. Some protocols implement an addressing mechanism to identify specific nodes or groups of nodes.</p>&#13;
<p class="noindent1"><strong>Controlling flow</strong> The amount of data transferred across a network is limited. Protocols can implement ways of managing data flow to increase throughput and reduce latency.</p>&#13;
<p class="noindent1"><strong>Guaranteeing the order of transmitted data</strong> Many networks do not guarantee that the order in which the data is sent will match the order in which it’s received. A protocol can reorder the data to ensure it’s delivered in the correct order.</p>&#13;
<p class="noindent1"><strong>Detecting and correcting errors</strong> Many networks are not 100 percent reliable; data can become corrupted. It’s important to detect corruption and, ideally, correct it.</p>&#13;
<p class="noindent1b"><strong>Formatting and encoding data</strong> Data isn’t always in a format suitable for transmitting on the network. A protocol can specify ways of encoding data, such as encoding English text into binary values.</p>&#13;
<h3 class="h3" id="ch00lev1sec8"><strong>The Internet Protocol Suite</strong></h3>&#13;
<p class="noindent">TCP/IP is the de facto protocol that modern networks use. Although you can think of TCP/IP as a single protocol, it’s actually a combination of two protocols: the <em>Transmission Control Protocol (TCP)</em> and the <em>Internet Protocol (IP)</em>. These <span epub:type="pagebreak" id="page_3"/>two protocols form part of the <em>Internet Protocol Suite (IPS)</em>, a conceptual model of how network protocols send network traffic over the internet that breaks down network communication into four layers, as shown in <a href="../Text/ch01.xhtml#ch1fig2">Figure 1-2</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f01-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch1fig2"/><em>Figure 1-2: Internet Protocol Suite layers</em></p>&#13;
<p class="indent">These four layers form a <em>protocol stack</em>. The following list explains each layer of the IPS:</p>&#13;
<p class="noindent1t"><strong>Link layer (layer 1)</strong> This layer is the lowest level and describes the physical mechanisms used to transfer information between nodes on a local network. Well-known examples include Ethernet (both wired and wireless) and Point-to-Point Protocol (PPP).</p>&#13;
<p class="noindent1"><strong>Internet layer (layer 2)</strong> This layer provides the mechanisms for addressing network nodes. Unlike in layer 1, the nodes don’t have to be located on the local network. This level contains the IP; on modern networks, the actual protocol used could be either version 4 (IPv4) or version 6 (IPv6).</p>&#13;
<p class="noindent1"><strong>Transport layer (layer 3)</strong> This layer is responsible for connections between clients and servers, sometimes ensuring the correct order of packets and providing service multiplexing. Service multiplexing allows a single node to support multiple different services by assigning a different number for each service; this number is called a <em>port</em>. TCP and the User Datagram Protocol (UDP) operate on this layer.</p>&#13;
<p class="noindent1b"><strong>Application layer (layer 4)</strong> This layer contains network protocols, such as the <em>HyperText Transport Protocol (HTTP)</em>, which transfers web page contents; the <em>Simple Mail Transport Protocol (SMTP)</em>, which transfers email; and the <em>Domain Name System (DNS) protocol</em>, which converts a name to a node on the network. Throughout this book, we’ll focus primarily on this layer.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_4"/>Each layer interacts only with the layer above and below it, but there must be some external interactions with the stack. <a href="../Text/ch01.xhtml#ch1fig2">Figure 1-2</a> shows two external connections. The link layer interacts with a physical network connection, transmitting data in a physical medium, such as pulses of electricity or light. The application layer interacts with the user application: an <em>application</em> is a collection of related functionality that provides a service to a user. <a href="../Text/ch01.xhtml#ch1fig3">Figure 1-3</a> shows an example of an application that processes email. The service provided by the mail application is the sending and receiving of messages over a network.</p>&#13;
<div class="image"><img alt="image" src="../Images/f01-03.jpg"/></div>&#13;
<p class="figcap"><a id="ch1fig3"/><em>Figure 1-3: Example mail application</em></p>&#13;
<p class="indent">Typically, applications contain the following components:</p>&#13;
<p class="noindent1t"><strong>Network communication</strong> This component communicates over the network and processes incoming and outgoing data. For a mail application, the network communication is most likely a standard protocol, such as SMTP or POP3.</p>&#13;
<p class="noindent1"><strong>Content parsers</strong> Data transferred over a network usually contains content that must be extracted and processed. Content might include textual data, such as the body of an email, or it might be pictures or video.</p>&#13;
<p class="noindent1b"><strong>User interface (UI)</strong> The UI allows the user to view received emails and to create new emails for transmission. In a mail application, the UI might display emails using HTML in a web browser.</p>&#13;
<p class="indent">Note that the user interacting with the UI doesn’t have to be a human being. It could be another application that automates the sending and receiving of emails through a command line tool.</p>&#13;
<h3 class="h3" id="ch00lev1sec9"><strong>Data Encapsulation</strong></h3>&#13;
<p class="noindent">Each layer in the IPS is built on the one below, and each layer is able to encapsulate the data from the layer above so it can move between the layers. Data transmitted by each layer is called a <em>protocol data unit (PDU)</em>.</p>&#13;
<h4 class="h4" id="ch00lev1sec10"><strong><em>Headers, Footers, and Addresses</em></strong></h4>&#13;
<p class="noindent">The PDU in each layer contains the payload data that is being transmitted. It’s common to prefix a <em>header</em>—which contains information required <span epub:type="pagebreak" id="page_5"/>for the payload data to be transmitted, such as the <em>addresses</em> of the source and destination nodes on the network—to the payload data. Sometimes a PDU also has a <em>footer</em> that is suffixed to the payload data and contains values needed to ensure correct transmission, such as error-checking information. <a href="../Text/ch01.xhtml#ch1fig4">Figure 1-4</a> shows how the PDUs are laid out in the IPS.</p>&#13;
<div class="image"><img alt="image" src="../Images/f01-04.jpg"/></div>&#13;
<p class="figcap"><a id="ch1fig4"/><em>Figure 1-4: IPS data encapsulation</em></p>&#13;
<p class="indent">The TCP header contains a source and destination port number <span class="ent">➊</span>. These port numbers allow a single node to have multiple unique network connections. Port numbers for TCP (and UDP) range from 0 to 65535. Most port numbers are assigned as needed to new connections, but some numbers have been given special assignments, such as port 80 for HTTP. (You can find a current list of assigned port numbers in the <em>/etc/services</em> file on most Unix-like operating systems.) A TCP payload and header are commonly called a <em>segment</em>, whereas a UDP payload and header are commonly called a <em>datagram</em>.</p>&#13;
<p class="indent">The IP protocol uses a source and a destination address <span class="ent">➋</span>. The <em>destination address</em> allows the data to be sent to a specific node on the network. The <em>source address</em> allows the receiver of the data to know which node sent the data and allows the receiver to reply to the sender.</p>&#13;
<p class="indent">IPv4 uses 32-bit addresses, which you’ll typically see written as four numbers separated by dots, such as 192.168.10.1. IPv6 uses 128-bit addresses, because 32-bit addresses aren’t sufficient for the number of nodes on modern networks. IPv6 addresses are usually written as hexadecimal numbers separated by colons, such as fe80:0000:0000:0000:897b:581e:44b0:2057. Long strings of 0000 numbers are collapsed into <span epub:type="pagebreak" id="page_6"/>two colons. For example, the preceding IPv6 address can also be written as fe80::897b:581e:44b0:2057. An IP payload and header are commonly called a <em>packet</em>.</p>&#13;
<p class="indent">Ethernet also contains source and destination addresses <span class="ent">➌</span>. Ethernet uses a 64-bit value called a <em>Media Access Control (MAC)</em> address, which is typically set during manufacture of the Ethernet adapter. You’ll usually see MAC addresses written as a series of hexadecimal numbers separated by dashes or colons, such as 0A-00-27-00-00-0E. The Ethernet payload, including the header and footer, is commonly referred to as a <em>frame</em>.</p>&#13;
<h4 class="h4" id="ch00lev1sec11"><strong><em>Data Transmission</em></strong></h4>&#13;
<p class="noindent">Let’s briefly look at how data is transferred from one node to another using the IPS data encapsulation model. <a href="../Text/ch01.xhtml#ch1fig5">Figure 1-5</a> shows a simple Ethernet network with three nodes.</p>&#13;
<div class="image"><img alt="image" src="../Images/f01-05.jpg"/></div>&#13;
<p class="figcap"><a id="ch1fig5"/><em>Figure 1-5: A simple Ethernet network</em></p>&#13;
<p class="indent">In this example, the node at <span class="ent">➊</span> with the IP address 192.1.1.101 wants to send data using the IP protocol to the node at <span class="ent">➋</span> with the IP address 192.1.1.50. (The <em>switch</em> device <span class="ent">➌</span> forwards Ethernet frames between all nodes on the network. The switch doesn’t need an IP address because it operates only at the link layer.) Here is what takes place to send data between the two nodes:</p>&#13;
<ol>&#13;
<li><p class="noindent">The operating system network stack node <span class="ent">➊</span> encapsulates the application and transport layer data and builds an IP packet with a source address of 192.1.1.101 and a destination address of 192.1.1.50.</p></li>&#13;
<li><p class="noindent">The operating system can at this point encapsulate the IP data as an Ethernet frame, but it might not know the MAC address of the target node. It can request the MAC address for a particular IP address using the Address Resolution Protocol (ARP), which sends a request to all nodes on the network to find the MAC address for the destination IP address.</p></li>&#13;
<li><p class="noindent"><span epub:type="pagebreak" id="page_7"/>Once the node at <span class="ent">➊</span> receives an ARP response, it can build the frame, setting the source address to the local MAC address of 00-11-22-33-44-55 and the destination address to 66-77-88-99-AA-BB. The new frame is transmitted on the network and is received by the switch <span class="ent">➌</span>.</p></li>&#13;
<li><p class="noindent">The switch forwards the frame to the destination node, which unpacks the IP packet and verifies that the destination IP address matches. Then the IP payload data is extracted and passes up the stack to be received by the waiting application.</p></li>&#13;
</ol>&#13;
<h3 class="h3" id="ch00lev1sec12"><strong>Network Routing</strong></h3>&#13;
<p class="noindent">Ethernet requires that all nodes be directly connected to the same local network. This requirement is a major limitation for a truly global network because it’s not practical to physically connect every node to every other node. Rather than require that all nodes be directly connected, the source and destination addresses allow data to be <em>routed</em> over different networks until the data reaches the desired destination node, as shown in <a href="../Text/ch01.xhtml#ch1fig6">Figure 1-6</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f01-06.jpg"/></div>&#13;
<p class="figcap"><a id="ch1fig6"/><em>Figure 1-6: An example of a routed network connecting two Ethernet networks</em></p>&#13;
<p class="indent"><a href="../Text/ch01.xhtml#ch1fig6">Figure 1-6</a> shows two Ethernet networks, each with separate IP network address ranges. The following description explains how the IP uses this model to send data from the node at <span class="ent">➊</span> on network 1 to the node at <span class="ent">➋</span> on network 2.</p>&#13;
<ol>&#13;
<li><p class="noindent">The operating system network stack node <span class="ent">➊</span> encapsulates the application and transport layer data, and it builds an IP packet with a source address of 192.1.1.101 and a destination address of 200.0.1.50.</p></li>&#13;
<li><p class="noindent">The network stack needs to send an Ethernet frame, but because the destination IP address does not exist on any Ethernet network that the node is connected to, the network stack consults its operating system <span epub:type="pagebreak" id="page_8"/><em>routing table</em>. In this example, the routing table contains an entry for the IP address 200.0.1.50. The entry indicates that a router <span class="ent">➌</span> on IP address 192.1.1.1 knows how to get to that destination address.</p></li>&#13;
<li><p class="noindent">The operating system uses ARP to look up the router’s MAC address at 192.1.1.1, and the original IP packet is encapsulated within the Ethernet frame with that MAC address.</p></li>&#13;
<li><p class="noindent">The router receives the Ethernet frame and unpacks the IP packet. When the router checks the destination IP address, it determines that the IP packet is not destined for the router but for a different node on another connected network. The router looks up the MAC address of 200.0.1.50, encapsulates the original IP packet into the new Ethernet frame, and sends it on to network 2.</p></li>&#13;
<li><p class="noindent">The destination node receives the Ethernet frame, unpacks the IP packet, and processes its contents.</p></li>&#13;
</ol>&#13;
<p class="indent">This routing process might be repeated multiple times. For example, if the router was not directly connected to the network containing the node 200.0.1.50, it would consult its own routing table and determine the next router it could send the IP packet to.</p>&#13;
<p class="indent">Clearly, it would be impractical for every node on the network to know how to get to every other node on the internet. If there is no explicit routing entry for a destination, the operating system provides a default routing table entry, called the <em>default gateway</em>, which contains the IP address of a router that can forward IP packets to their destinations.</p>&#13;
<h3 class="h3" id="ch00lev1sec13"><strong>My Model for Network Protocol Analysis</strong></h3>&#13;
<p class="noindent">The IPS describes how network communication works; however, for analysis purposes, most of the IPS model is not relevant. It’s simpler to use my model to understand the behavior of an application network protocol. My model contains three layers, as shown in <a href="../Text/ch01.xhtml#ch1fig7">Figure 1-7</a>, which illustrates how I would analyze an HTTP request.</p>&#13;
<p class="indent">Here are the three layers of my model:</p>&#13;
<p class="noindent1t"><strong>Content layer</strong> Provides the meaning of what is being communicated. In <a href="../Text/ch01.xhtml#ch1fig7">Figure 1-7</a>, the meaning is making an HTTP request for the file <em>image.jpg</em>.</p>&#13;
<p class="noindent1"><strong>Encoding layer</strong> Provides rules to govern how you represent your content. In this example, the HTTP request is encoded as an HTTP GET request, which specifies the file to retrieve.</p>&#13;
<p class="noindent1b"><strong>Transport layer</strong> Provides rules to govern how data is transferred between the nodes. In the example, the HTTP GET request is sent over a TCP/IP connection to port 80 on the remote node.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_9"/><img alt="image" src="../Images/f01-07.jpg"/></div>&#13;
<p class="figcap"><a id="ch1fig7"/><em>Figure 1-7: My conceptual protocol model</em></p>&#13;
<p class="indent">Splitting the model this way reduces complexity with application-specific protocols because it allows us to filter out details of the network protocol that aren’t relevant. For example, because we don’t really care how TCP/IP is sent to the remote node (we take for granted that it will get there somehow), we simply treat the TCP/IP data as a binary transport that just works.</p>&#13;
<p class="indent">To understand why the protocol model is useful, consider this protocol example: imagine you’re inspecting the network traffic from some malware. You find that the malware uses HTTP to receive commands from the operator via the server. For example, the operator might ask the malware to enumerate all files on the infected computer’s hard drive. The list of files can be sent back to the server, at which point the operator can request a specific file to be uploaded.</p>&#13;
<p class="indent">If we analyze the protocol from the perspective of how the operator would interact with the malware, such as by requesting a file to be uploaded, the new protocol breaks down into the layers shown in <a href="../Text/ch01.xhtml#ch1fig8">Figure 1-8</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f01-08.jpg"/></div>&#13;
<p class="figcap"><a id="ch1fig8"/><em>Figure 1-8: The conceptual model for a malware protocol using HTTP</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_10"/>The following list explains each layer of the new protocol model:</p>&#13;
<p class="noindent1t"><strong>Content layer</strong> The malicious application is sending a stolen file called <em>secret.doc</em> to the server.</p>&#13;
<p class="noindent1"><strong>Encoding layer</strong> The encoding of the command to send the stolen file is a simple text string with a command <code>SEND</code> followed by the filename and the file data.</p>&#13;
<p class="noindent1b"><strong>Transport layer</strong> The protocol uses an HTTP request parameter to transport the command. It uses the standard percent-encoding mechanism, making it a legal HTTP request.</p>&#13;
<p class="indent">Notice in this example that we don’t consider the HTTP request being sent over TCP/IP; we’ve combined the encoding and transport layer in <a href="../Text/ch01.xhtml#ch1fig7">Figure 1-7</a> into just the transport layer in <a href="../Text/ch01.xhtml#ch1fig8">Figure 1-8</a>. Although the malware still uses lower-level protocols, such as TCP/IP, these protocols are not important to the analysis of the malware command to send a file. The reason it’s not important is that we can consider HTTP over TCP/IP as a single transport layer that just works and focus specifically on the unique malware commands.</p>&#13;
<p class="indent">By narrowing our scope to the layers of the protocol that we need to analyze, we avoid a lot of work and focus on the unique aspects of the protocol. On the other hand, if we were to analyze this protocol using the layers in <a href="../Text/ch01.xhtml#ch1fig7">Figure 1-7</a>, we might assume that the malware was simply requesting the file <em>image.jpg</em>, because it would appear as though that was all the HTTP request was doing.</p>&#13;
<h3 class="h3" id="ch00lev1sec14"><strong>Final Words</strong></h3>&#13;
<p class="noindent">This chapter provided a quick tour of the networking basics. I discussed the IPS, including some of the protocols you’ll encounter in real networks, and described how data is transmitted between nodes on a local network as well as remote networks through routing. Additionally, I described a way to think about application network protocols that should make it easier for you to focus on the unique features of the protocol to speed up its analysis.</p>&#13;
<p class="indent">In <a href="../Text/ch02.xhtml#ch02">Chapter 2</a>, we’ll use these networking basics to guide us in capturing network traffic for analysis. The goal of capturing network traffic is to access the data you need to start the analysis process, identify what protocols are being used, and ultimately discover security issues that you can exploit to compromise the applications using these protocols.</p>&#13;
</body></html>