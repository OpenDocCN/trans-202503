- en: '**9**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CALLING FUNCTIONS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before you start writing your own functions in R, it’s useful to understand
    how functions are called and interpreted in an R session. First, you’ll look at
    how variable names are compartmentalized in R. You’ll see R’s rules for naming
    arguments and objects, and how R searches for arguments and other variables when
    a function is called. Then you’ll look at some alternative ways to specify arguments
    when calling a function.
  prefs: []
  type: TYPE_NORMAL
- en: '**9.1 Scoping**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To begin with, it’s important to understand R’s *scoping rules*, which determine
    how the language compartmentalizes objects and retrieves them in a given session.
    This framework also defines the situations in which duplicate object names can
    exist at once. For example, you’ve used the argument `data` when calling `matrix`
    ([Section 3.1](ch03.xhtml#ch03lev1sec12)), but `data` is also the name of a ready-to-use
    function that loads data sets from contributed packages ([Section 8.1.2](ch08.xhtml#ch08lev2sec72)).
    In this section, you’ll gain an introductory understanding of how R behaves internally
    in these circumstances, which will help you later on when it comes to programming
    and executing your own functions and those of other packages.
  prefs: []
  type: TYPE_NORMAL
- en: '***9.1.1 Environments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: R enforces scoping rules with virtual *environments*. You can think of environments
    as separate compartments where data structures and functions are stored. They
    allow R to distinguish between identical names that are associated with different
    scopes and therefore stored in different environments. Environments are dynamic
    entities—new environments can be created, and existing environments can be manipulated
    or removed.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Technically speaking, environments don’t actually contain items. Rather, they
    have* pointers *to the location of those items in the computer’s memory. But using
    the “compartment” metaphor and thinking of objects “belonging to” these compartments
    is useful when you’re first getting a general sense of how environments work.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three important kinds of environments: global environments, package
    environments and namespaces, and local or lexical environments.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global Environment**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *global environment* is the compartment set aside for user-defined objects.
    Every object you’ve created or overwritten so far has resided in the global environment
    of your current R session. In [Section 1.3.1](ch01.xhtml#ch01lev2sec12), I mentioned
    that a call to `ls()` lists all the objects, variables, and user-defined functions
    in the active workspace—more precisely, `ls()` prints the names of everything
    in the current global environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with a new R workspace, the following code creates two objects and
    confirms their existence in the global environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: But what about all the ready-to-use objects and functions? Why aren’t those
    printed alongside `foo` and `bar` as members of this environment? In fact, those
    objects and functions belong to package-specific environments, described next.
  prefs: []
  type: TYPE_NORMAL
- en: '**Package Environments and Namespaces**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For simplicity, I’ll use the term *package environment* rather loosely to refer
    to the items made available by each package in R. In fact, the structure of R
    packages in terms of scoping is a bit more complicated. Each package environment
    actually represents several environments that control different aspects of a search
    for a given object. A package *namespace*, for example, essentially defines the
    visibility of its functions. (A package can have visible functions that a user
    is able to use and invisible functions that provide internal support to the visible
    functions.) Another part of the package environment handles *imports* designations,
    dealing with any functions or objects from other libraries that the package needs
    to import for its own functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clarify this, you can think of all the ready-to-use functions and objects
    you’re working with in this book as belonging to specific package environments.
    The same is true for the functions and objects of any contributed packages you’ve
    explicitly loaded with a call to `library`. You can use `ls` to list the items
    in a package environment as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `ls` command lists all of the visible objects contained in the `graphics`
    package environment. Note that this list includes some of the functions you used
    in [Chapter 7](ch07.xhtml#ch07), such as `arrows`, `plot`, and `segments`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Local Environments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Each time a function is called in R, a new environment is created called the
    *local environment*, sometimes referred to as the *lexical environment*. This
    local environment contains all the objects and variables created in and visible
    to the function, including any arguments you’ve supplied to the function upon
    execution. It’s this feature that allows the presence of argument names that are
    identical to other object names accessible in a given workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say you call `matrix` and pass in the argument `data`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Calling this function creates a local environment containing the `data` vector.
    When you execute the function, it begins by looking for `data` in this local environment.
    That means R isn’t confused by other objects or functions named `data` in other
    environments (such as the `data` function automatically loaded from the `utils`
    package environment). If a required item isn’t found in the local environment,
    only then does R begin to widen its search for that item (I’ll discuss this feature
    a little more in [Section 9.1.2](ch09.xhtml#ch09lev2sec80)). Once the function
    has completed, this local environment is automatically removed. The same comments
    apply to the `nrow` and `ncol` arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '***9.1.2 Search Path***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To access data structures and functions from environments other than the immediate
    global environment, R follows a *search path*. The search path lays out all the
    environments that a given R session has available to it.
  prefs: []
  type: TYPE_NORMAL
- en: The search path is basically a list of the environments that R will search when
    an object is requested. If the object isn’t found in one environment, R proceeds
    to the next one. You can view R’s search path at any time using `search()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: From the command prompt, this path will always begin at the global user environment
    (`.GlobalEnv`) and end after the `base` package environment (`package:base`).
    You can think of these as belonging to a hierarchy, with an arrow pointing from
    left to right between each pair of environments. For my current session, if I
    request a certain object at the R prompt, the program will inspect `.GlobalEnv`
    → `tools:RGUI` → `package:stats` → ... → `package:base` in turn, stopping the
    search when the desired object is found and retrieved. Note that, depending on
    your operating system and whether you’re using the built-in GUI, `tools:RGUI`
    might not be included in your search path.
  prefs: []
  type: TYPE_NORMAL
- en: If R doesn’t find what it’s looking for by following the environments in the
    search path, the *empty environment* is reached. The empty environment is not
    explicitly listed in the output from `search()`, but it’s always the final destination
    after `package:base`. This environment is special because it marks the end of
    the search path.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you call the following, a number of things happen internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: R first searches the global environment for a function called `seq`, and when
    this isn’t found, it goes on to search in the enclosing environment, which is
    the next level up in the search path (according to the left-to-right arrows mentioned
    earlier). It doesn’t find it there, so R keeps going through the path to the next
    environment, searching the packages that have been loaded (automatically or otherwise)
    until it finds what it’s looking for. In this example, R locates `seq` in the
    built-in `base` package environment. Then it executes the `seq` function (creating
    a temporary local environment) and assigns the results to a new object, `baz`,
    which resides in the global environment. In the subsequent call to print `baz`,
    R begins by searching the global environment and immediately finds the requested
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can look up the enclosing environment of any function using `environment`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, I’ve identified the package namespace of `base` as the owner of the `seq`
    function and the `graphics` package as the owner of the `arrows` function.
  prefs: []
  type: TYPE_NORMAL
- en: Each environment has a *parent*, to direct the order of the search path. Examining
    the earlier output from the call `search()`, you can see that the parent of `package:stats`,
    for example, is `package:graphics`. The specific parent-child structure is dynamic
    in the sense that the search path changes when additional libraries are loaded
    or data frames are `attach`ed. When you load a contributed package with a call
    to `library`, this essentially just inserts the desired package in the search
    path. For example, in [Exercise 8.1](ch08.xhtml#ch8exc1) on [page 161](ch08.xhtml#page_161),
    you installed the contributed package `car`. After loading this package, your
    search path will include its contents.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note the position of the `car` package environment in the path—inserted directly
    after the global environment. This is where each subsequently loaded package will
    be placed (followed by any additional packages it depends upon for its own functionality).
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, R will stop searching once it has exhausted the entire search
    path and reached the empty environment. If you request a function or object that
    you haven’t defined, that doesn’t exist, or that is perhaps in a contributed package
    that you’ve forgotten to load (this is quite a common little mistake), then an
    error is thrown. These “cannot find” errors are recognizable for both functions
    and other objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Environments help compartmentalize the huge amount of functionality in R. This
    becomes particularly important when there are functions with the same name in
    different packages in the search path. At that point, *masking*, discussed in
    [Section 12.3](ch12.xhtml#ch12lev1sec41), comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: As you get more comfortable with R and want more precise control over how it
    operates, it’s worth investigating in full how R handles environments. For more
    technical details on this, Gupta ([2012](ref.xhtml#ref27)) provides a particularly
    well-written online article.
  prefs: []
  type: TYPE_NORMAL
- en: '***9.1.3 Reserved and Protected Names***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A few key terms are strictly forbidden from being used as object names in R.
    These *reserved* names are necessary in order to protect fundamental operations
    and data types frequently used in the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following identifiers are reserved:'
  prefs: []
  type: TYPE_NORMAL
- en: • `if` and `else`
  prefs: []
  type: TYPE_NORMAL
- en: • `for`, `while`, and `in`
  prefs: []
  type: TYPE_NORMAL
- en: • `function`
  prefs: []
  type: TYPE_NORMAL
- en: • `repeat`, `break`, and `next`
  prefs: []
  type: TYPE_NORMAL
- en: • `TRUE` and `FALSE`
  prefs: []
  type: TYPE_NORMAL
- en: • `Inf` and `-Inf`
  prefs: []
  type: TYPE_NORMAL
- en: • `NA`, `NaN`, and `NULL`
  prefs: []
  type: TYPE_NORMAL
- en: I haven’t yet covered some of the terms on this list. These items represent
    the core tools for programming in the R language, and you’ll begin to explore
    them in the following chapter. The last three bullet points include the familiar
    logical values ([Section 4.1](ch04.xhtml#ch04lev1sec16)) and special terms used
    to represent things like infinity and missing entries ([Section 6.1](ch06.xhtml#ch06lev1sec21)).
  prefs: []
  type: TYPE_NORMAL
- en: If you try to assign a new value to any of these reserved terms, an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Because R is case sensitive, it’s possible to assign values to any case-variant
    of the reserved names, but this can be confusing and is generally not advisable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Also be wary of assigning values to `T` and `F`, the abbreviations of `TRUE`
    and `FALSE`. The full identifiers `TRUE` and `FALSE` are reserved, but the abbreviated
    versions are not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Assigning values to `T` and `F` this way will affect any subsequent code that
    intends to use `T` and `F` to refer to `TRUE` and `FALSE`. The second assignment
    (`F <- TRUE`) is perfectly legal in R’s eyes, but it’s extremely confusing given
    the normal usage of `F` as an abbreviation: the line `F&&TRUE` now represents
    a `TRUE&&TRUE` comparison! It’s best to simply avoid these types of assignments.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve been following along with the examples in your R console, it’s prudent
    at this point to clear the global environment (thereby deleting the objects `False`,
    `nan`, `T`, and `F` from your workspace). To do this, use the `rm` function as
    shown next. Using `ls()`, supply a character vector of all objects in the global
    environment as the argument `list`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now the global environment is empty, and calling `ls()` returns an empty character
    vector (`character(0)`).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 9.1**'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the first 20 items contained in the built-in and automatically loaded
    `methods` package. How many items are there in total?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Determine the environment that owns each of the following functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`read.table`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`data`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`matrix`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`jpeg`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `ls` and a test for character string equality to confirm the function `smoothScatter`
    is part of the `graphics` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**9.2 Argument Matching**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another set of rules that determine how R interprets function calls has to do
    with *argument matching*. Argument matching conditions allow you to provide arguments
    to functions either with abbreviated names or without names at all.
  prefs: []
  type: TYPE_NORMAL
- en: '***9.2.1 Exact***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far, you’ve mostly been using *exact* matching of arguments, where each argument
    tag is written out in full. This is the most exhaustive way to call a function.
    It’s helpful to write out full argument names this way when first getting to know
    R or a new function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other benefits of exact matching include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • Exact matching is less prone to mis-specification of arguments than other
    matching styles.
  prefs: []
  type: TYPE_NORMAL
- en: • The order in which arguments are supplied doesn’t matter.
  prefs: []
  type: TYPE_NORMAL
- en: • Exact matching is useful when a function has many possible arguments but you
    want to specify only a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main drawbacks of exact matching are clear:'
  prefs: []
  type: TYPE_NORMAL
- en: • It can be cumbersome for relatively simple operations.
  prefs: []
  type: TYPE_NORMAL
- en: • Exact matching requires the user to remember or look up the full, case-sensitive
    tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, in [Section 6.2.1](ch06.xhtml#ch06lev2sec59), you used exact
    matching to execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This creates a 3 × 3 matrix object `bar` with a `dimnames` attribute for the
    rows and columns. Since the argument tags are fully specified, the order of the
    arguments doesn’t matter. You could switch around the arguments, and the function
    still has all the information it requires.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This behaves the same way as the previous function call. For the sake of consistency,
    you usually won’t switch around arguments each time you call a function, but this
    example shows a benefit of exact matching: you don’t have to worry about the order
    of any optional arguments or about skipping them.'
  prefs: []
  type: TYPE_NORMAL
- en: '***9.2.2 Partial***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Partial* matching lets you identify arguments with an abbreviated tag. This
    can shorten your code, and it still lets you provide arguments in any order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another way to call `matrix` that takes advantage of partial matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice I’ve shortened the `nrow`, `dimnames`, and `ncol` argument tags to the
    first two letters and shortened the `data` argument to the first three. For partial
    matching, there’s no set number of letters you have to provide, as long as each
    argument is still uniquely identifiable for the function being called. Partial
    matching has the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: • It requires less code than exact matching.
  prefs: []
  type: TYPE_NORMAL
- en: • Argument tags are still visible (which limits the possibility of mis-specification).
  prefs: []
  type: TYPE_NORMAL
- en: • The order of supplied arguments still doesn’t matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'But partial matching also has some limitations. For one, it gets trickier if
    there are multiple arguments whose tags start with the same letters. Here’s an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: An error has occurred. The fourth argument tag is designated simply as `d`,
    which is meant to stand for `data`. This is illegal because another argument,
    namely `dimnames`, also starts with `d`. Even though `dimnames` is specified separately
    as `di` earlier in the same line, the call isn’t valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawbacks of partial matching include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • The user must be aware of other potential arguments that can be matched by
    the shortened tag (even if they aren’t specified in the call or have a default
    value assigned).
  prefs: []
  type: TYPE_NORMAL
- en: • Each tag must have a unique identification, which can be difficult to remember.
  prefs: []
  type: TYPE_NORMAL
- en: '***9.2.3 Positional***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most compact mode of function calling in R is *positional matching*. This
    is when you supply arguments without tags, and R interprets them based solely
    on their order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Positional matching is usually used for relatively simple functions with only
    a few arguments, or functions that are very familiar to the user. For this type
    of matching, you *must* be aware of the precise positions of each argument. You
    can find that information in the “Usage” section of the function’s help file,
    or it can be printed to the console with the `args` function. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows the defined order of arguments of the `matrix` function, as well
    as the default value for each argument. To construct the matrix `bar` with positional
    matching, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The benefits of positional matching are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: • Shorter, cleaner code, particularly for routine tasks
  prefs: []
  type: TYPE_NORMAL
- en: • No need to remember specific argument tags
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that when using exact and partial matching, you didn’t need to supply
    anything for the `byrow` argument, which, by default, is set to `FALSE`. With
    positional matching, you must provide a value (given here as `F`) for `byrow`
    as the fourth argument because R relies on position alone to interpret the function
    call. If you leave out the argument, you get an error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here R has tried to assign the fourth argument (the list you intended for `dimnames`)
    as the value for the logical `byrow` argument. This brings us to the drawbacks
    of positional matching:'
  prefs: []
  type: TYPE_NORMAL
- en: • You must look up and exactly match the defined order of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: • Reading code written by someone else can be more difficult, especially when
    it includes unfamiliar functions.
  prefs: []
  type: TYPE_NORMAL
- en: '***9.2.4 Mixed***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since each matching style has pros and cons, it’s quite common, and perfectly
    legal, to mix these three styles in a single function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you can avoid the type of error shown in the previous example
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here I’ve used positional matching for the first three arguments, which are
    by now familiar to you. At the same time, I’ve used partial matching to explicitly
    tell R that the list is meant as a `dimnames` value, not for `byrow`.
  prefs: []
  type: TYPE_NORMAL
- en: '***9.2.5 Dot-Dot-Dot: Use of Ellipses***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many functions exhibit *variadic* behavior. That is, they can accept any number
    of arguments, and it’s up to the user to decide how many arguments to provide.
    The functions `c`, `data.frame`, and `list` are all like this. When you call a
    function like `data.frame`, you can specify any number of members as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'This flexibility is achieved in R through the special *dot-dot-dot* designation
    (`...`), also called the *ellipsis*. This construct allows the user to supply
    any number of data vectors (these become the columns in the final data frame).
    You can see whether an ellipsis is used in a function on the function’s help page
    or with `args`. Looking at `data.frame`, notice the first argument slot is an
    ellipsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function and supply an argument that can’t be matched with one
    of the function’s defined argument tags, normally this would produce an error.
    But if the function is defined with an ellipsis, any arguments that aren’t matched
    to other argument tags are matched to the ellipsis.
  prefs: []
  type: TYPE_NORMAL
- en: Functions that employ ellipses generally fall into two groups. The first group
    includes functions such as `c`, `data.frame`, and `list`, where the ellipsis always
    represents the “main ingredients” in the function call. That is, the objective
    of the function is to use contents of the ellipsis in the resulting object or
    output. The second group consists of functions where the ellipsis is meant as
    a *supplementary* or *potential* repository of optional arguments. This is common
    when the function of interest calls other *subfunctions* that themselves require
    additional arguments depending upon the originally supplied items. Rather than
    explicitly copy all the arguments desired by the subfunction into the argument
    list of the “parent” function, the parent function can instead be defined including
    an ellipsis that is subsequently provided to the subfunction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of the ellipsis used for supplementary arguments with the
    generic `plot` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: From examining the arguments, it’s clear that optional arguments such as point
    size (argument tag `cex`) or line type (argument tag `lty`), if supplied, are
    matched to the ellipsis. These optional arguments are then passed in to the function
    to be used by various methods that tweak graphical parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Ellipses are a convenient programming tool for writing variadic functions or
    functions where an unknown number of arguments may be supplied. This will become
    clearer when you start writing your own functions in [Chapter 11](ch11.xhtml#ch11).
    However, when writing functions like this, it’s important to properly document
    the intended use of `...` so the potential users of the function know exactly
    which arguments can be passed to it and what those arguments are subsequently
    used for in execution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 9.2**'
  prefs: []
  type: TYPE_NORMAL
- en: Use positional matching with `seq` to create a sequence of values between −4
    and 4 that progresses in steps of 0.2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In each of the following lines of code, identify which style of argument matching
    is being used: exact, partial, positional, or mixed. If mixed, identify which
    arguments are specified in each style.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`array(8:1,dim=c(2,2,2))`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rep(1:2,3)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`seq(from=10,to=8,length=5)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sort(decreasing=T,x=c(2,1,1,2,0.3,3,1.3))`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`which(matrix(c(T,F,T,T),2,2))`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`which(matrix(c(T,F,T,T),2,2),a=T)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Suppose you explicitly ran the plotting function `plot.default` and supplied
    values to arguments tagged `type`, `pch`, `xlab`, `ylab`, `lwd`, `lty`, and `col`.
    Use the function documentation to determine which of these arguments fall under
    the umbrella of the ellipsis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Important Code in This Chapter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ls` | Inspect environment objects | [Section 9.1.1](ch09.xhtml#ch09lev2sec79),
    [p. 167](ch09.xhtml#page_167) |'
  prefs: []
  type: TYPE_TB
- en: '| `search` | Current search path | [Section 9.1.2](ch09.xhtml#ch09lev2sec80),
    [p. 168](ch09.xhtml#page_168) |'
  prefs: []
  type: TYPE_TB
- en: '| `environment` | Function environment properties | [Section 9.1.2](ch09.xhtml#ch09lev2sec80),
    [p. 169](ch09.xhtml#page_169) |'
  prefs: []
  type: TYPE_TB
- en: '| `rm` | Delete objects in workspace | [Section 9.1.3](ch09.xhtml#ch09lev2sec81),
    [p. 171](ch09.xhtml#page_171) |'
  prefs: []
  type: TYPE_TB
- en: '| `args` | Show function arguments | [Section 9.2.3](ch09.xhtml#ch09lev2sec84),
    [p. 174](ch09.xhtml#page_174) |'
  prefs: []
  type: TYPE_TB
