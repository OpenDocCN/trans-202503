- en: Games and Toys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**18'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Digital Drum Set**
  prefs: []
  type: TYPE_NORMAL
- en: In this project you’ll create a button-controlled digital drum set with just
    a breadboard circuit and a few buttons. Pressing different buttons will produce
    different drum sounds, including two drumbeat loops.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0225-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: Breadboard
  prefs: []
  type: TYPE_NORMAL
- en: Eight pushbuttons
  prefs: []
  type: TYPE_NORMAL
- en: Headphones, or monitor with speakers connected to the Pi via HDMI
  prefs: []
  type: TYPE_NORMAL
- en: Jumper wires
  prefs: []
  type: TYPE_NORMAL
- en: '**SOFTWARE REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: avconv
  prefs: []
  type: TYPE_NORMAL
- en: This project uses samples from the Sonic Pi sample library, but you’re free
    to adapt it to use any sounds you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**PREPARING THE AUDIO**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First you’ll need to configure the Raspberry Pi audio properly and get set up
    to use audio samples from Sonic Pi.
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuring the Audio**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, plug your headphones or speakers into the Raspberry Pi audio jack. If
    your monitor has built-in speakers and is connected to the Pi with an HDMI cable,
    you don’t need to connect anything to the audio jack—you can listen to the sound
    through the monitor speakers.
  prefs: []
  type: TYPE_NORMAL
- en: On the top-right corner of your desktop environment, right-click the audio symbol
    and select the audio source as shown in [Figure 18-1](ch18.xhtml#ch18fig1). Select
    Analog if you’re using headphones, or HDMI if you’re using a monitor with speakers.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0226-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 18-1:** Selecting the audio source'
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Audio Sample Files**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We won’t be covering Sonic Pi in this book, but if you want to explore it
    on your own, go to **Programming*** ▸ ***Sonic Pi** in the taskbar main menu to
    open the software and take a look around.*'
  prefs: []
  type: TYPE_NORMAL
- en: The Sonic Pi software comes installed in the Pi’s operating system and allows
    you to create your own digital music using code, but in this project you’ll just
    be using the Sonic Pi’s sample audio files.
  prefs: []
  type: TYPE_NORMAL
- en: In the terminal, enter the following commands to create a new folder called
    *Games_and_Toys* inside the *Projects* folder, and move into the new folder. You’ll
    save the samples here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then enter the following to copy the Sonic Pi’s *samples* folder to the *Games_and_Toys*
    folder (note that there is a space between the final `/` and the period at the
    end):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, enter these commands to list the contents of the *samples* folder to
    check that they transferred correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If all went as planned, you should see a list of files like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice these files have the unusual extension *.flac*. This format
    is used in Sonic Pi, but to use them with Python you need to convert them to *.wav*
    files. For that, you’ll use the avconv software. Enter the following command to
    install avconv:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then enter the following command, which will go through all the files in the
    *samples* folder and convert each *.flac* file into a *.wav* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use the `ls` command to list the items in your *samples* folder and check
    that you now have *.wav* files to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should have both a *.wav* and a *.flac* file for each sample. To remove
    the *.flac* files from your *samples* folder, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can double-check that you have the correct files with the `ls` command again
    if you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can play the sounds with the *omxplayer* software that’s installed on your
    operating system by default. To listen to the sample called *drum_snare_soft.wav*,
    enter the following at your command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you explore the samples files, you’ll see a wide variety of sounds, from
    guitar sounds to cow bell and drums. Choose eight different drum sounds to include
    in your drum set (or any other sounds that strike your fancy).
  prefs: []
  type: TYPE_NORMAL
- en: 'The sounds we’ve chosen are as follows; the last two are drum beats, while
    the others refer to single drum sounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '*drum_cymbal_open.wav*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*drum_heavy_kick.wav*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*drum_snare_hard.wav*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*drum_cymbal_closed.wav*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*drum_roll.wav*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*perc_snap.wav*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*loop_amen_full.wav*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*loop_mika.wav*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WIRING THE CIRCUIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The circuitry for this project simply involves wiring eight pushbuttons to the
    Pi. Each pushbutton is associated with a different sound.
  prefs: []
  type: TYPE_NORMAL
- en: To wire the circuit, follow these instructions, using [Figure 18-2](ch18.xhtml#ch18fig2)
    as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0228-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 18-2:** The digital drum set circuit'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the GND pin to the breadboard GND rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert eight pushbuttons into the breadboard at equal distances over the center
    divide.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the bottom-left pushbutton leads to GND and the bottom-right leads
    to one of the following GPIO pins in turn: GPIO 2, 3, 14, 15, 17, 18, 22, and
    27.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **PUSHBUTTON** | **RASPBERRY PI** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 | GPIO 2 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 2 | GPIO 3 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 3 | GPIO 14 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 4 | GPIO 15 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 5 | GPIO 17 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 6 | GPIO 18 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 7 | GPIO 22 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 8 | GPIO 27 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**WRITING THE SCRIPT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open **Python 3 (IDLE)** and go to **File** ▸ **New File** to create a new
    script. Copy the following code into the Python Editor and save the script as
    *digital_drum_set.py* inside the *Games_and_Toys* folder (remember that you can
    download all the scripts at *[https://www.nostarch.com/RaspberryPiProject/](https://www.nostarch.com/RaspberryPiProject/)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As usual, you start your script by importing the necessary libraries ➊. The
    new library here is the `pygame.mixer`, used for loading and playing sounds. From
    `pygame.mixer` you also import the `Sound` module, used to create sound objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you initialize the Pygame mixer ➋ and create a dictionary that holds sounds
    ➌. In Python, a *dictionary* is a data structure used to store relationships between
    items. In this case, you’re associating a button with a specific sound. The basic
    structure of a dictionary is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The dictionary is enclosed by curly brackets, `{}`, and is composed of key/value
    pairs. You use a colon (`:`) to assign each key to its corresponding value, and
    you use commas (`,`) to separate each key/value pair.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, the keys are the buttons, and the values are the sounds. To
    create a sound object, you pass the sound file path as a string to the `Sound()`
    function. In this case, since the *samples* folder is inside the *Games_and_Toys*
    folder, you don’t need to provide an entire path, just the folder name followed
    by the sound filename. You’ll need to change the sound filenames in this script,
    highlighted in bold, to your chosen sound files.
  prefs: []
  type: TYPE_NORMAL
- en: Next, assign each button to a sound effect ➍; this means that, when a pushbutton
    is pressed, the corresponding sound will play. Finally, the `pause()` function
    ➎ at the end of the script keeps the program running, so events can be detected.
  prefs: []
  type: TYPE_NORMAL
- en: To run the script, press **F5** or go to **Run** ▸ **Run Module**.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations—you’ve just built your own digital drum set! Now, press the
    pushbuttons and compose your own music clips.
  prefs: []
  type: TYPE_NORMAL
- en: '**TAKING IT FURTHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This was a cool project and so simple to build. We encourage you to extend
    this project by trying the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding other sounds to your digital drum set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording your own sounds or searching the web for free sounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a digital piano, a digital guitar, or a hybrid music box with mixed
    sounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**19'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make a Game in Scratch: Hungry Monkey**'
  prefs: []
  type: TYPE_NORMAL
- en: In this project you’ll use the block-based programming language Scratch to create
    a game that can be controlled with two pushbuttons and your Pi.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0233-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: Two pushbuttons
  prefs: []
  type: TYPE_NORMAL
- en: Breadboard
  prefs: []
  type: TYPE_NORMAL
- en: Jumper wires
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll create your own game called Hungry Monkey. The object
    of the game is for the monkey to catch as many ripe bananas as possible in 30
    seconds, while avoiding the rotten ones. You’ll be able to move the monkey left
    and right with two pushbuttons that you’ll wire to your Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: '**INTRODUCING SCRATCH 2**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To find out more about Scratch, visit the official Scratch website at* [http://scratch.mit.edu/](http://scratch.mit.edu/).'
  prefs: []
  type: TYPE_NORMAL
- en: Scratch is a visual programming language you can use to create animations, stories,
    and games using drag-and-drop code blocks. Although Scratch was developed to teach
    kids how to program, it’s suitable for anyone who wants to learn some fundamental
    programming concepts or just wants to have fun building their own games.
  prefs: []
  type: TYPE_NORMAL
- en: Scratch 2 is installed on Raspbian by default. You can open it from the desktop
    main menu by going to **Programming** ▸ **Scratch 2**. When you open Scratch 2,
    you should see a window like the one in [Figure 19-1](ch19.xhtml#ch19fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0234-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 19-1:** The Scratch 2 window'
  prefs: []
  type: TYPE_NORMAL
- en: The Scratch window divides the screen into four main sections. The Stage ➊ is
    where your game or animations will play out. At the top right, you’ll see a green
    flag and a stop sign; you can use these icons to start and stop the game, respectively.
    When you first open Scratch, you should see a cat on your stage by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Sprite List ➋ shows all of your *sprites*, which are your game characters
    or any object that performs an action in your project. In the middle of the window
    is the Blocks Area ➌, which has three tabs: Scripts, Costumes, and Sounds. The
    Scripts tab contains programming blocks you use to build your program. Each block
    is a different programming instruction that you can drag and drop into place in
    your program. You’ll see different categories of blocks organized according to
    what they do. Each category has a specific color; for example, blocks from the
    **Motion** category, which tell your sprites how to move around, are dark blue.'
  prefs: []
  type: TYPE_NORMAL
- en: The Costumes tab ➍ shows options for customizing and creating new costumes for
    your sprites, and the Sounds tab ➎ allows you to add sounds to your sprites. The
    Scripts Area ➏ is where you drag the blocks and put them together to create a
    script.
  prefs: []
  type: TYPE_NORMAL
- en: The menu bar ➐ at the top shows the File and Edit main menus at the left side.
    The icons at the center allow you to duplicate, delete, grow, and shrink your
    sprites, and also get help from Scratch.
  prefs: []
  type: TYPE_NORMAL
- en: '**WIRING THE CIRCUIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The circuit for this project consists of two pushbuttons and the Raspberry Pi.
    Follow these instructions to wire them, using [Figure 19-2](ch19.xhtml#ch19fig2)
    as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: Connect a GND pin to your breadboard’s GND rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert two pushbuttons into the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the bottom-right pushbutton pins to the GND rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the bottom-left pin of one pushbutton to GPIO 2 and the other to GPIO
    3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0235-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 19-2:** Wiring two pushbuttons to the Raspberry Pi'
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’re ready to code the game.
  prefs: []
  type: TYPE_NORMAL
- en: '**BUILDING THE SCRIPT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before creating a game, it’s useful to outline the features you want your game
    to have so you know exactly what you need to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Hungry Monkey game, the player controls a monkey who needs to catch
    as many ripe bananas as possible while avoiding rotten bananas. For each good
    banana caught, the player gets a point; if the player catches a rotten banana,
    the game deducts a point. Here’s a list of the main steps to build the Hungry
    Monkey game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the main character, the monkey, and allow the player to control its
    movement using two pushbuttons: one moves the monkey right and the other moves
    the monkey left. Also allow the player to move the monkey with keyboard keys.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the good and rotten banana sprites and make them fall from the sky.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Program the monkey so that it catches the bananas when it touches them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a score system that adds one point when the monkey catches a good banana
    and subtracts a point when it catches a rotten one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a timer and end the game when the timer hits 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the player’s score when the game is over.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Scratch file for this project is available at *[https://www.nostarch.com/RaspberryPiProject/](https://www.nostarch.com/RaspberryPiProject/)*.
    To upload a saved program to Scratch, go to **File ▸ Load Project**. To build
    the script, follow the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the Sprites and Choosing the Stage Background**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can also create a sprite from scratch using the paintbrush icon, upload
    your own sprite by clicking the folder icon, or take a photo with a webcam for
    your sprite with the camera icon.*'
  prefs: []
  type: TYPE_NORMAL
- en: In the Hungry Monkey Game, you’ll use a monkey sprite, and a banana sprite from
    the Sprite Library. You won’t need to use the cat sprite that appears on the Stage
    by default, so you can delete it by right-clicking the sprite and selecting **Delete**
    to delete this sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Sprite List and click the leftmost icon that looks like a character
    (see [Figure 19-3](ch19.xhtml#ch19fig3)) to open the Sprite Library.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0237-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 19-3:** Icons to create new sprites'
  prefs: []
  type: TYPE_NORMAL
- en: From the Animals category, choose the `Monkey2` sprite and click **OK**. Then,
    open the Sprite Library again, select the `Bananas` sprite from the Things category,
    and then click **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: You can choose a background for your game from the leftmost side of the Sprite
    List. There you’ll find a set of icons for the background. Click the first icon—highlighted
    in [Figure 19-4](ch19.xhtml#ch19fig4)—to choose a background from the backdrop
    library. We’ve chosen the one called *blue sky*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0237-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 19-4:** Selecting the background from the backdrop library'
  prefs: []
  type: TYPE_NORMAL
- en: Now your sprites section should look like [Figure 19-5](ch19.xhtml#ch19fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0237-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 19-5:** Sprite List with the selected sprites and background'
  prefs: []
  type: TYPE_NORMAL
- en: '**Editing the Sprites**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Scratch allows you to increase or decrease the size of a sprite, change its
    color, or edit it as you would do in an image-editing program. Scratch built-in
    image editor is called *Paint Editor*. Here you’ll make some changes to your sprites’
    appearance.
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Monkey2` sprite in the Sprite List; if a sprite is selected, it
    will be outlined in blue, as shown in [Figure 19-5](ch19.xhtml#ch19fig5). Next,
    click the `Monkey2` sprite in the Costumes tab, and edit the first costume, called
    `monkey2-a`. With the mouse pointer drag a corner of the sprite until its size
    matches 98×138 pixels, or use the shrink tool until you get the desired size;
    the sprite size is displayed below the `monkey2-a` costume. Also change the `Bananas`
    sprite’s size to 28×28 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: When adjusting the sprites’ size, make sure they’re at the center of the canvas
    in order to keep the sprite’s reference point.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding Controls to the Monkey Sprite**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ll add controls to the monkey so you can make it go left or right by
    pressing the pushbuttons or the left and right arrows on the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: To allow the Raspberry Pi GPIOs to interface with Scratch so the program will
    react when a pushbutton is pressed, you need to add an extension library to Scratch.
    Select the `Monkey2` sprite in the Scripts tab, select **More Blocks**, and click
    **Add an Extension**. Next select the Pi GPIO icon, as shown in [Figure 19-6](ch19.xhtml#ch19fig6),
    and click **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0238-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 19-6:** Adding the Pi GPIO extension'
  prefs: []
  type: TYPE_NORMAL
- en: The extension library adds new blocks to control the Pi GPIOs, which should
    appear in the More Blocks category.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different ways to make your sprite move in Scratch. You’ll use
    the (x,y) coordinate system, in which the (0,0) position is the middle of the
    Stage. Increasing the x-coordinate moves your sprites to the right, and decreasing
    it moves your sprites to the left. Increasing the y-coordinate moves your sprites
    up, and decreasing it moves your sprites down. The blocks that control movement
    are in the dark blue **Motion** category.
  prefs: []
  type: TYPE_NORMAL
- en: To control the monkey, select the `Monkey2` sprite and drag the blocks in [Figure
    19-7](ch19.xhtml#ch19fig7) into the Script Area. Then change the settings in the
    blocks to match [Figure 19-7](ch19.xhtml#ch19fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0239-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 19-7:** Blocks for controlling the monkey'
  prefs: []
  type: TYPE_NORMAL
- en: You first set the `Monkey2` sprite’s x-position to 0 and y-position to –110\.
    Setting x to 0 centers your sprite horizontally, and setting y to –110 moves your
    sprite to the floor. This way the sprite is always in this position every time
    you start the game.
  prefs: []
  type: TYPE_NORMAL
- en: The next two blocks set GPIO 2 and GPIO 3 to inputs, so the program will be
    able to tell if the pushbuttons have been pressed.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Finding the blocks is easy. Remember that each blocks category has a specific
    color and each block within it is colored accordingly.*'
  prefs: []
  type: TYPE_NORMAL
- en: Then you add a forever loop that continuously checks if the player is pressing
    the pushbuttons or the left and right arrow keys. If the player presses the pushbutton
    connected to GPIO 3, or the right arrow key, the sprite’s x-position is changed
    by 30, moving it to the right; if the player presses the pushbutton connected
    to GPIO 2, or the left arrow key, the sprite’s x-position is changed by –30, moving
    it to the left. You can increase this number to make your monkey move faster,
    or decrease it to make the monkey move slower.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve added the blocks, double-check them against [Figure 19-7](ch19.xhtml#ch19fig7),
    and then you can test it out.
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing Your Script**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To start a script in Scratch, you use the green flag block, ![image](../images/f0239-02.jpg).
    This block will start your game and synchronize all the scripts in your sprites.
    When you click the green flag icon at the top right of the stage section, Scratch
    starts all the scripts that are under this block.
  prefs: []
  type: TYPE_NORMAL
- en: Click the green flag icon ![image](../images/f0239-03.jpg) at the upper-right
    corner of the stage now. Test that the sprite moves appropriately by pressing
    the pushbuttons and arrow keys. When you have everything working, move on to the
    timer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the Countdown Timer**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The player needs to know how much time they have left to catch bananas, so next
    you’ll create a countdown timer.
  prefs: []
  type: TYPE_NORMAL
- en: To add the timer to your game, select the `Monkey2` sprite, and then add the
    blocks in [Figure 19-8](ch19.xhtml#ch19fig8) to the Script Area. You may notice
    you can’t find the show variable block. That’s because you need to create the
    variable to hold the time. To create variables, navigate to the **Data** blocks
    category, and click the **Make a Variable** button. Call the new variable time
    and make it available for all sprites by checking the **For all sprites** box.
    Now drag that block into the Script Area.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0240-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 19-8:** Blocks to create a countdown timer'
  prefs: []
  type: TYPE_NORMAL
- en: To create the countdown timer, you’ll use a block called timer. This block counts
    the time that has passed since the script started. When you click the green flag
    icon, the script resets the timer, so it starts counting from 0 every time you
    start the game. Next you include a block that shows the `time` variable on the
    stage. You can position the `time` variable by dragging it across the stage section;
    move it to the stage’s top-right corner.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the forever loop keeps updating the `time` variable so that it starts
    at 30 and decreases by one every second. You use the round block so the countdown
    time is shown only in integer numbers. If you want to change your game duration,
    you can adjust the number in the round block.
  prefs: []
  type: TYPE_NORMAL
- en: Pay careful attention to the nesting here (see [Figure 19-9](ch19.xhtml#ch19fig9));
    you’ll notice that the set time to block comes first, then the round block. Then,
    on top of that, you need to drop the green - block with two empty circles. Inside
    the first empty circle, enter 30, and inside the second empty circle, drop a timer
    block from the **Sensing** category.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0241-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 19-9:** The nested if block'
  prefs: []
  type: TYPE_NORMAL
- en: The if block at the end (see [Figure 19-8](ch19.xhtml#ch19fig8)) hides the `time`
    variable from the stage when `time` hits 0\. Now try it out!
  prefs: []
  type: TYPE_NORMAL
- en: '**Counting and Displaying the Score**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create the score system, first you need to create a variable to keep track
    of the score. In the **Data** blocks category, create a new variable called `score`
    and make it available for all sprites. Select the `Monkey2` sprite, and then add
    the blocks in [Figure 19-10](ch19.xhtml#ch19fig10) to the scripts area.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0241-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 19-10:** Blocks to display the score and stop the game'
  prefs: []
  type: TYPE_NORMAL
- en: Set the set score to block to `0` so your score will restart when the game starts.
    Then add the show variable block to display the score on the stage.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the game, when the time hits 0, the monkey should say the score
    in a speech bubble and all the scripts will stop, ending the game. To make the
    monkey talk, add some purple **Looks** blocks to show a speech bubble—you can
    enter whatever text you want your monkey to say here.
  prefs: []
  type: TYPE_NORMAL
- en: Again, be careful with the nesting here, and look at [Figure 19-10](ch19.xhtml#ch19fig10)
    carefully.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Bananas Fall from the Sky**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that you’ve created all the `Monkey2` animations and controls, you need
    to set the `Bananas` sprite to fall from the sky. Here’s the to-do list for the
    `Bananas` sprite:'
  prefs: []
  type: TYPE_NORMAL
- en: The bananas should fall from the sky, starting from a random x-position and
    then decreasing in y-position until they hit the floor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bananas should disappear when they hit the floor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the bananas touch the monkey, a sound should play, one point should be
    added to the score, and the bananas should disappear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the bananas should be deleted when the time hits 0, so they don’t continue
    to fall after the game is over.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First you need to add a sound from the Sound Library to the blocks section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding a Sound from the Sound Library**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You’ll add a pop sound to the `Bananas` sprite to play when it hits the `Monkey2`
    sprite. For that, select the `Bananas` sprite, and in the blocks section select
    the **Sounds** tab. Then click the ![image](../images/f0242-01.jpg) icon to choose
    a sound from the Sound Library and choose `pop`. Select the **Scripts** tab to
    add your action blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Bananas Fall**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To accomplish everything in the to-do list, select the `Bananas` sprite, and
    then add the blocks in [Figure 19-11](ch19.xhtml#ch19fig11) to its scripts area.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0242-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 19-11:** Blocks for creating and controlling the `Bananas` sprite'
  prefs: []
  type: TYPE_NORMAL
- en: With the upper-left set of blocks ➊ in [Figure 19-11](ch19.xhtml#ch19fig11),
    you create a clone of the `Bananas` sprite every second. In other words, you make
    a new `Bananas` sprite appear every second.
  prefs: []
  type: TYPE_NORMAL
- en: In the set of blocks to the right ➌, you initialize the values for the `Bananas`
    clones. The show block ensures that the bananas appear on the screen. You set
    the bananas’ y-position to 170, which corresponds to the top of the Stage, and
    set the x-position to a random number between –230 and 230, which is the horizontal
    Stage space from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: Then you initialize a repeat until block, which is like a `while` loop that
    is active until the `time` variable hits 0\. The change y by block inside the
    repeat until block decreases the y-position of the bananas so they look like they’re
    falling from the sky. In this case, we’re decreasing the y-position by 5\. If
    you want to make them fall faster, increase the y-value; if you want them to fall
    more slowly, decrease it.
  prefs: []
  type: TYPE_NORMAL
- en: The first if block inside the repeat until block makes the bananas disappear
    when they reach the bottom of the stage, at y < –160\. The second if block adds
    one point to the `score` variable and plays the `pop` sound when the bananas hit
    the monkey, and makes the bananas disappear. Finally, when the repeat until block
    is over, the `Bananas` clones are hidden from the stage.
  prefs: []
  type: TYPE_NORMAL
- en: The blocks in the lower left ➋ of [Figure 19-11](ch19.xhtml#ch19fig11) stop
    the creation of new `Bananas` clones when the `time` variable hits 0.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding the Rotten Bananas**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You now have the monkey, the good bananas, the timer, and the score. You’re
    just missing the rotten bananas. The script for the rotten bananas is really similar
    to the script in [Figure 19-11](ch19.xhtml#ch19fig11); you just need to make these
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Create rotten bananas every 2 seconds instead of 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decrease the score by one when the rotten bananas touch the monkey.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play a different sound when the monkey touches the rotten bananas. We’ve chosen
    the sound called `F elec bass`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change how the rotten bananas look.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because this script is so similar to the previous one, you’re going to duplicate
    the good bananas and then make the changes. Right-click the `Bananas` sprite and
    select **duplicate**. The sprite and its script should be duplicated and automatically
    named `Bananas2`. Right-click the `Bananas2` sprite and select **info**; a menu
    should appear that allows you to change the sprite’s name. Enter `Rotten` as the
    new name. The changes you need to make to the script are highlighted in [Figure
    19-12](ch19.xhtml#ch19fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0244-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 19-12:** Blocks for controlling the rotten bananas'
  prefs: []
  type: TYPE_NORMAL
- en: Change the wait block value to `2` ➊, so a new `Rotten` clone will fall every
    2 seconds, instead of every second. Also change the sound block to play `F elec
    bass` ➋, and in the set score to block, reduce the score by `1` ➌. Remember that
    you have to add this sound from the library in the Sounds tab first.
  prefs: []
  type: TYPE_NORMAL
- en: With the script for rotten bananas complete, next you’ll change the `Rotten`
    sprite colors so that the bananas look rotten. Select the `Rotten` sprite and
    click the **Costumes** tab. The Paint Editor screen should appear (see [Figure
    19-13](ch19.xhtml#ch19fig13)).
  prefs: []
  type: TYPE_NORMAL
- en: On the right side of the window, select the bucket icon ➊; then, at the bottom,
    select different colors ➋ to fill each individual banana with a different color.
    Choose colors like brown, olive green, and dark green to show that they’re rotten.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0245-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 19-13:** Editing the **Rotten** sprite colors'
  prefs: []
  type: TYPE_NORMAL
- en: '**PLAYING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Congratulations! Your game is ready. To play the game in fullscreen, click the
    fullscreen icon at the top-left corner of the stage, and then click the green
    flag icon. Playing the game in fullscreen makes it run smoother and quicker.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you can use either the pushbuttons or the keyboard keys to play
    the game. When the game is over, just click the green flag icon to restart.
  prefs: []
  type: TYPE_NORMAL
- en: '**TAKING IT FURTHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This project was just a glimpse of what you can do with Scratch. Here are some
    ideas to improve this game:'
  prefs: []
  type: TYPE_NORMAL
- en: Increase the bananas’ falling speed as the game progresses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase the number of rotten bananas as the game progresses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make this game multiplayer by creating another sprite with different controls.
    (You’ll need to add another `score` variable to hold player 2’s score.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add other electronics to your circuit that you can interface with Scratch, like
    buttons, buzzers, or sensors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have fun and create your own games!
  prefs: []
  type: TYPE_NORMAL
- en: '**20'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wi-Fi Remote-Controlled Robot**
  prefs: []
  type: TYPE_NORMAL
- en: In this project you’re going to build a two-wheel, battery-powered robot with
    a Raspberry Pi Zero W and the MotoZero add-on. You can control it over Wi-Fi using
    a web app you’ll make with Node-RED.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0248-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi Zero W (or other 40 GPIO Raspberry Pi)
  prefs: []
  type: TYPE_NORMAL
- en: Smart robot car chassis kit
  prefs: []
  type: TYPE_NORMAL
- en: MotoZero add-on board (or other motor controller add-on)
  prefs: []
  type: TYPE_NORMAL
- en: Four AA batteries
  prefs: []
  type: TYPE_NORMAL
- en: Portable charger
  prefs: []
  type: TYPE_NORMAL
- en: Jumper wires
  prefs: []
  type: TYPE_NORMAL
- en: '**SOFTWARE REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: Node-RED dashboard
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT OUTLINE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than going straight into the project, we’ll highlight the most important
    parts of the robot to give you an idea of how it will all work.
  prefs: []
  type: TYPE_NORMAL
- en: '**Wi-Fi**'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll control the robot with a Node-RED application, so your Raspberry Pi needs
    to have Wi-Fi. Raspberry Pi models 3 and Zero W have built-in Wi-Fi, but if your
    board doesn’t, you can use a Wi-Fi dongle compatible with the Pi.
  prefs: []
  type: TYPE_NORMAL
- en: '**Raspberry Pi Board**'
  prefs: []
  type: TYPE_NORMAL
- en: We’re using the Raspberry Pi Zero W because its small size makes it perfect
    for the small robot chassis. But any Raspberry Pi version with 40 GPIOs is compatible
    with this project as long as it has Wi-Fi.
  prefs: []
  type: TYPE_NORMAL
- en: '**Robot Chassis Kit**'
  prefs: []
  type: TYPE_NORMAL
- en: We’re using a robot chassis kit that comes with everything you need to build
    the robot, including wheels, motors, and screws. You can find the kit in online
    marketplaces like Amazon or eBay by searching for *Smart Car Robot Chassis Kit*.
    You need the kit with two DC motors.
  prefs: []
  type: TYPE_NORMAL
- en: '**MotoZero Add-on**'
  prefs: []
  type: TYPE_NORMAL
- en: The DC motors will make the robot move, and you’ll control them using an add-on
    board called MotoZero. One place to find the board is online at The Pi Hut (*[https://thepihut.com/motozero/](https://thepihut.com/motozero/)*).
    You can also use any other Raspberry Pi–compatible motor driver add-on for this
    project or build a circuit with the LC293D IC chip. We won’t cover how to build
    that circuit here, but there are plenty of tutorials online if you want to make
    your own.
  prefs: []
  type: TYPE_NORMAL
- en: '**Power**'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t want to connect the Pi robot to a wall socket, because we want it to
    be portable, so we need to power the robot with a portable charger, or *power
    bank*. The power bank must be capable of outputting 5 V and 2 A. We tested this
    project with a power bank that has 2,200 mAh capacity and it worked fine; incorporating
    a power bank with more capacity will make the robot run for longer.
  prefs: []
  type: TYPE_NORMAL
- en: The DC motors need to be powered independently from the Pi, meaning you need
    two independent power sources. To power up the motors, we’re using the battery
    holder that comes with the chassis kit along with four AA batteries, not included
    in the kit.
  prefs: []
  type: TYPE_NORMAL
- en: '**Node-RED Application**'
  prefs: []
  type: TYPE_NORMAL
- en: The Node-RED application you’ll use to control your robot should be able to
    make the robot go forward and backward, move right and left, and stop. Since you’re
    not running the Pi as a desktop computer, the Pi needs to automatically start
    Node-RED when it boots. You’ll also add an off button to the application so you
    can turn the Raspberry Pi off remotely.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 20-1](ch20.xhtml#ch20fig1) shows a high-level overview of how your
    robot will work.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0250-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 20-1:** The robot structure'
  prefs: []
  type: TYPE_NORMAL
- en: '**PREPARING THE RASPBERRY PI**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re using the Raspberry Pi Zero W board, shown in [Figure 20-2](ch20.xhtml#ch20fig2),
    which is a variant of Raspberry Pi Zero that has built-in wireless LAN and Bluetooth,
    but remember that you can use another Wi-Fi compatible board or a Wi-Fi dongle.
    The Raspberry Pi Zero W measures only 2.56 inches × 1.18 inches × 0.20 inches
    (65 mm × 30 mm × 5 mm) and costs around $10.
  prefs: []
  type: TYPE_NORMAL
- en: The Pi Zero has 40 GPIO pins with the same pinout as the Pi 3\. As you can see
    in [Figure 20-2](ch20.xhtml#ch20fig2), it features a mini HDMI connector and two
    micro USB connectors, one of which is used exclusively for power. To use the Pi
    Zero as a desktop computer, you need a few extra accessories like a USB hub, a
    USB-to-micro-USB adapter, and an HDMI-to-mini-HDMI adapter to connect the peripherals.
    To save you some money, we’ll prepare everything on our regular Raspberry Pi 3
    and then switch the micro SD card to the Pi Zero W.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0251-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 20-2:** Raspberry Pi Zero W'
  prefs: []
  type: TYPE_NORMAL
- en: We recommend using a new micro SD card for this project. Refer to [“Uploading
    the Operating System”](ch00.xhtml#lev10) on [page 10](ch00.xhtml#page_10) to see
    how to install the latest Raspbian release on your new micro SD card.
  prefs: []
  type: TYPE_NORMAL
- en: After installing the operating system, insert the micro SD card on your regular
    Pi. Power up the Pi and wait a few seconds for the system to start. Then configure
    the Wi-Fi from the desktop’s top-right corner by clicking **Wi-Fi**. Next, enter
    your Wi-Fi password, and wait a few seconds for the Wi-Fi connection to successfully
    establish.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Node-RED software is preinstalled on the Pi’s operating system, but you
    still need to install the Node-RED dashboard. For that, first update the library
    repositories, and then install npm (Node Package Management) by entering the following
    at your command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When prompted, type Y and press ENTER. The installation may take a few minutes.
    Then enter the following commands to upgrade npm to the latest 3.x version, which
    is the version recommended for use with Node-RED:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, enter the following to install the Node-RED dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Again, Node-RED needs to start automatically when the Pi boots. For that, enter
    the following command in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With that done, shut down your Pi and switch the micro SD card to the Raspberry
    Pi Zero W.
  prefs: []
  type: TYPE_NORMAL
- en: '**WIRING THE CIRCUIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To build the robot structure you need a chassis for the robot, two DC motors
    with corresponding wheels, the MotoZero add-on, jumper wires, and your Pi (with
    Wi-Fi). Use [Figure 20-1](ch20.xhtml#ch20fig1) as a reference. We’ll start by
    mounting the MotoZero at the top of the Raspberry Pi and then wire the motors
    to MotoZero.
  prefs: []
  type: TYPE_NORMAL
- en: '**Wiring the DC Motors to MotoZero**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: MotoZero allows you to control four motors independently, but you need to control
    just two DC motors. The MotoZero will come unassembled, so you need to solder
    its parts. The Pi Hut provides an assembly manual on the product’s page, so go
    to *[https://thepihut.com/motozero/](https://thepihut.com/motozero/)* and follow
    the instructions there before continuing. Your MotoZero should look like [Figure
    20-3](ch20.xhtml#ch20fig3) after assembly.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0252-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 20-3:** Assembled MotoZero add-on'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 20-3](ch20.xhtml#ch20fig3) shows the connections you can make to MotoZero:
    positive (+) and negative (–) connections for four DC motors, and a positive (+)
    and negative (–) connection for the power supply. You need an external power source
    for driving the motors. The motors require a big jump in current to move, so using
    a separate power source prevents the Pi from suddenly losing power when this jump
    occurs.'
  prefs: []
  type: TYPE_NORMAL
- en: Follow these instructions and refer to [Figure 20-1](ch20.xhtml#ch20fig1) to
    wire the motors and battery holder.
  prefs: []
  type: TYPE_NORMAL
- en: Connect the right DC motor’s red wire to the Motor 1 positive (+) pin on the
    MotoZero, and its black wire to the Motor 1 negative (–) pin. You’ll need to loosen
    the screws, place the wires in the pin slot, and then tighten the screws again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the previous instruction for the left motor, connecting the power wires
    to the MotoZero Motor 2 connections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Without inserting the batteries, connect the battery holder’s red wire to the
    positive (+) pin on the MotoZero power connector and its black wire to the negative
    (–) pin, shown at the bottom of the board in [Figure 20-3](ch20.xhtml#ch20fig3).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you find the robot’s wheels are spinning in the opposite direction of what
    you intended, you may have to switch the DC motors’ red wires with the black wires
    on the positive (+) and negative (–) Motor 1 or Motor 2 terminals. You’ll know
    if you need to do this when you test the application at the end of the project.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Controlling the Motors with MotoZero**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each DC motor has three GPIO pins associated with it. One pin, known as the
    *enable* pin, enables the motor and is like an on and off switch. The other two
    pins control the power to the positive and negative motor wires. Applying power
    to one wire and GND to the other makes the motor turn in one direction, while
    applying power and GND to the opposite motor wires moves the motor in the opposite
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For information about the Motor 3 and Motor 4 GPIOs, you can check the MotoZero
    manual at The Pi Hut’s product page* ([https://thepihut.com/motozero/](https://thepihut.com/motozero/)).'
  prefs: []
  type: TYPE_NORMAL
- en: We’re just using the Motor 1 and Motor 2 terminals, which are controlled by
    the GPIOs shown in the following table, when you mount the MotoZero on the top
    of the Pi.
  prefs: []
  type: TYPE_NORMAL
- en: '| **MOTOR 1** | **MOTOR 2** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| enable: GPIO 5 | enable: GPIO 6 |'
  prefs: []
  type: TYPE_TB
- en: '| Motor 1 (+): GPIO 27 | Motor 2 (+): GPIO 22 |'
  prefs: []
  type: TYPE_TB
- en: '| Motor 1 (–): GPIO 24 | Motor 2 (–): GPIO 17 |'
  prefs: []
  type: TYPE_TB
- en: 'To make a motor spin, the enable pin must be HIGH to turn the motor on, and
    one—and only one—of the positive or negative pins should be HIGH. For example,
    if you want Motor 1 to spin in one direction, use the following setup:'
  prefs: []
  type: TYPE_NORMAL
- en: 'GPIO 5: HIGH'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GPIO 27: HIGH'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GPIO 24: LOW'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To make the same motor spin in the opposite direction, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'GPIO 5: HIGH'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GPIO 27: LOW'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GPIO 24: HIGH'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To turn off the motor, you’d send a LOW signal to all the GPIOs. The same logic
    applies to the other motors.
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING THE APPLICATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’ve built your hardware, it’s time to create the Node-RED application.
    As your Pi is already in your robot chassis, the most practical way to create
    the robot Node-RED application is to use your regular desktop or laptop computer
    and control it from there.
  prefs: []
  type: TYPE_NORMAL
- en: First you’ll need to find your Raspberry Pi Zero W IP address; you’ll use it
    to access the Pi’s Node-RED application dashboard, where you can create a robot
    application.
  prefs: []
  type: TYPE_NORMAL
- en: You need to make sure the Raspberry Pi is turned on and that your computer and
    Pi are connected to the same network before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding the Raspberry Pi IP Address**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Raspberry Pi Zero W has two mini USB ports, and one of them, labeled*
    PWR IN, *is designated for powering up the Pi.*'
  prefs: []
  type: TYPE_NORMAL
- en: Power up the Raspberry Pi by connecting the 5 V power adapter to a wall socket.
    You’ll only use this power source while creating the Node-RED application; once
    it’s ready, you should change to the portable power source.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find the Pi’s IP address using Angry IP Scanner software. Download it
    onto your regular desktop or laptop computer for free from *[http://angryip.org/download/](http://angryip.org/download/)*,
    and then follow the prompts to install it.
  prefs: []
  type: TYPE_NORMAL
- en: Once the installation is complete, open Angry IP Scanner and click the **Start**
    button. Wait a few seconds until it shows the available IP addresses. Your Pi
    IP address should have *raspberrypi.lan* as a hostname, so jot down the corresponding
    IP address. [Figure 20-4](ch20.xhtml#ch20fig4) highlights our Raspberry Pi IP
    address, which is 192.168.1.122.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0254-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 20-4:** Finding the Raspberry Pi IP address with the Angry IP Scanner
    software'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the Node-RED Flow**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For an introduction to Node-RED, see [Project 17](ch17.xhtml#ch17).*'
  prefs: []
  type: TYPE_NORMAL
- en: On your regular computer, making sure it’s on the same network as your Pi, open
    a web browser tab and go to *http://<Pi IP address>:1880*, replacing *<Pi IP address>*
    with the Raspberry Pi IP address you noted earlier. In our case, we navigated
    to *http://192.168.1.122:1880*. Your Raspberry Pi Node-RED web server should open.
  prefs: []
  type: TYPE_NORMAL
- en: In the top-right corner of the window, select the **dashboard** tab and, inside
    the **Layout** tab, create a tab called **Robot**. Next, create two groups inside
    that Robot tab, called **Main** and **Poweroff**. The Main group is where you’ll
    organize the buttons that control the robot, and the Poweroff group is where you’ll
    add the button to remotely turn off your Raspberry Pi. Once you’ve completed these
    tabs and groups, your layout should look like [Figure 20-5](ch20.xhtml#ch20fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0255-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 20-5:** Node-RED application dashboard layout'
  prefs: []
  type: TYPE_NORMAL
- en: Add five buttons, a function, six rpi gpio output nodes, and an exec node to
    the flow. Wire the nodes and edit their names to match the ones in [Figure 20-6](ch20.xhtml#ch20fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0255-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 20-6:** Node-RED application nodes'
  prefs: []
  type: TYPE_NORMAL
- en: Edit the function’s properties so that it has six outputs, assigning all of
    the nodes’ properties as shown in [Table 20-1](ch20.xhtml#ch20tab1).
  prefs: []
  type: TYPE_NORMAL
- en: '**TABLE 20-1:** Properties assigned to each node'
  prefs: []
  type: TYPE_NORMAL
- en: '| **NODE** | **PROPERTIES** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Forward | Group: Main [Robot] Size: auto'
  prefs: []
  type: TYPE_NORMAL
- en: 'Icon: fa-arrow-up'
  prefs: []
  type: TYPE_NORMAL
- en: 'Label: Forward'
  prefs: []
  type: TYPE_NORMAL
- en: 'Payload: forward |'
  prefs: []
  type: TYPE_NORMAL
- en: '| Left | Group: Main [Robot] Size: auto'
  prefs: []
  type: TYPE_NORMAL
- en: 'Icon: fa-arrow-left'
  prefs: []
  type: TYPE_NORMAL
- en: 'Label: Left'
  prefs: []
  type: TYPE_NORMAL
- en: 'Payload: left |'
  prefs: []
  type: TYPE_NORMAL
- en: '| Right | Group: Main [Robot] Size: auto'
  prefs: []
  type: TYPE_NORMAL
- en: 'Icon: fa-arrow-right'
  prefs: []
  type: TYPE_NORMAL
- en: 'Label: Right'
  prefs: []
  type: TYPE_NORMAL
- en: 'Payload: right |'
  prefs: []
  type: TYPE_NORMAL
- en: '| Reverse | Group: Main [Robot] Size: auto'
  prefs: []
  type: TYPE_NORMAL
- en: 'Icon: fa-arrow-down'
  prefs: []
  type: TYPE_NORMAL
- en: 'Label: Reverse'
  prefs: []
  type: TYPE_NORMAL
- en: 'Payload: reverse |'
  prefs: []
  type: TYPE_NORMAL
- en: '| Stop | Group: Main [Robot] Size: auto'
  prefs: []
  type: TYPE_NORMAL
- en: 'Icon: fa-hand-paper-o'
  prefs: []
  type: TYPE_NORMAL
- en: 'Label: Stop'
  prefs: []
  type: TYPE_NORMAL
- en: 'Payload: stop |'
  prefs: []
  type: TYPE_NORMAL
- en: '| f | Function: enter the code in [Listing 20-1](ch20.xhtml#ch20list1) Outputs:
    6 |'
  prefs: []
  type: TYPE_TB
- en: '| Enable M1 | GPIO: GPIO5 – 29 Type: Digital output |'
  prefs: []
  type: TYPE_TB
- en: '| + M1 | GPIO: GPIO27 – 13 Type: Digital output |'
  prefs: []
  type: TYPE_TB
- en: '| – M1 | GPIO: 18 – GPIO24 Type: Digital output |'
  prefs: []
  type: TYPE_TB
- en: '| Enable M2 | GPIO: GPIO17 – 11 Type: Digital output |'
  prefs: []
  type: TYPE_TB
- en: '| + M2 | GPIO: GPIO6 – 31 Type: Digital output |'
  prefs: []
  type: TYPE_TB
- en: '| – M2 | GPIO: GPIO22 – 15 Type: Digital output |'
  prefs: []
  type: TYPE_TB
- en: '| Poweroff | Group: Poweroff [Robot] Size: auto'
  prefs: []
  type: TYPE_NORMAL
- en: 'Icon: fa-power-off'
  prefs: []
  type: TYPE_NORMAL
- en: 'Label: Poweroff'
  prefs: []
  type: TYPE_NORMAL
- en: 'Background: red |'
  prefs: []
  type: TYPE_NORMAL
- en: '| exec | Command: `/usr/bin/sudo` + Append: not checked'
  prefs: []
  type: TYPE_NORMAL
- en: poweroff
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: Poweroff |'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 20-7](ch20.xhtml#ch20fig7) shows how the exec node is set up.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0257-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 20-7:** exec node properties'
  prefs: []
  type: TYPE_NORMAL
- en: All nodes should be in the Main group, except the Poweroff button, which should
    be part of the Poweroff group.
  prefs: []
  type: TYPE_NORMAL
- en: '**Entering the Script**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Insert the JavaScript code in [Listing 20-1](ch20.xhtml#ch20list1) (also available
    for download from *[https://www.nostarch.com/RaspberryPiProject/](https://www.nostarch.com/RaspberryPiProject/)*)
    into the function node:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTING 20-1:** The remote-controlled robot script'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This function sends messages to the connected rpi gpio output nodes in the order
    they’re connected to the function node. This means that `msg1` is sent to the
    Enable M1 node, `msg2` to + M1, `msg3` to – M1, and so on (see [Figure 20-6](ch20.xhtml#ch20fig6)).
  prefs: []
  type: TYPE_NORMAL
- en: First you initialize all the payload message variable values to `0` ➊. Then
    the series of `if` and `else if` statements checks which button was pressed ➋,
    depending on the payload received by the function, and sets the message values
    according to the action the robot should take. For example, if you press the Forward
    button, the payload received by the function node is `forward`, so the condition
    at ➋ is met and the code changes the `msg1`, `msg2`, `msg4`, and `msg5` payload
    values to `1`, while `msg3` and `msg6` remain `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the function node sends the `msg.payload` values to the corresponding
    nodes ➌. For the robot to go forward, the payloads would need to be:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable M1: `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '+ M1: `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '– M2: `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enable M2: `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '+ M2: `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '– M2: `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, both motors are enabled and moving in the same direction—forward. The
    following table shows the messages the function should send to each node for each
    action.
  prefs: []
  type: TYPE_NORMAL
- en: '| **ACTION** | **ENABLE M1** | **+ M1** | **– M1** | **ENABLE M2** | **+ M2**
    | **– M2** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Forward | 1 | 1 | 0 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Left | 1 | 1 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Right | 0 | 0 | 0 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Reverse | 1 | 0 | 1 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Stop | 0 | 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: When the Stop button is clicked, none of the conditions set in the code is met,
    and the function sends the values initialized at the start ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Outside the function node, when the Poweroff button is clicked, the exec node
    executes the `poweroff` command to turn off the Pi. Remember that you’ve filled
    the `exec` command property with */usr/bin/sudo/poweroff*—see [Table 20-1](ch20.xhtml#ch20tab1).
  prefs: []
  type: TYPE_NORMAL
- en: Once everything is in place, click the **Deploy** button at the top-right corner
    to save the changes and run the flow.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the Application**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now your Node-RED application is ready. Go to *http://<Pi IP address>:1880/ui*
    (replacing *<Pi IP address>* with your own) to see your application dashboard.
    It should look something like [Figure 20-8](ch20.xhtml#ch20fig8).
  prefs: []
  type: TYPE_NORMAL
- en: Test the controls to see if the wheels are moving in the right direction, and
    don’t forget that you need to insert the four AA batteries into the battery holder
    in order to power the motors.
  prefs: []
  type: TYPE_NORMAL
- en: If one or both motors are spinning in the wrong direction, switch the black
    and red wires on the MotoZero for that motor terminal, or change the payload messages
    to match the required directions.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0260-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 20-8:** Node-RED application to remotely control the robot'
  prefs: []
  type: TYPE_NORMAL
- en: '**POWERING UP THE ROBOT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that the application is ready, click the **Poweroff** button to shut down
    the Pi. Then wait a few seconds for it to shut down.
  prefs: []
  type: TYPE_NORMAL
- en: Change the Pi’s power source from the wall socket to the power bank. Wait a
    few minutes for the Pi to power up and autostart Node-RED. On a smartphone or
    other device that’s on the same network as your Pi, open a new browser tab and
    go to *http://<Pi IP address>:1880/ui*. Then click on the buttons to remotely
    control your robot.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations—you now have a Wi-Fi-controlled robot!
  prefs: []
  type: TYPE_NORMAL
- en: '**TAKING IT FURTHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There’s a lot of room for upgrades on your robot. Here are some ideas for upgrades
    that will need both hardware and software changes. You’ll need to experiment a
    bit with Node-RED to get these working:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a robot chassis with four wheels and control four motors instead of two.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add LEDs and buzzers to the robot to make it more interactive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add sensors, like an ultrasonic sensor, so the robot can avoid obstacles by
    itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
