<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="249" id="Page_249"/>15</span><br/>
<span class="ChapterTitle">Command Line Arguments and Raw I/O</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">In this chapter, we explore how command line arguments allow the operating system to pass information to a program when the program is invoked. We also take a look at another feature that’s close to the operating system: the raw input/output (I/O) system. This system lets us precisely control how a program performs I/O. Done right, it can be a tremendous asset to a program.</p>
<p>We’ll use the raw I/O system to perform a high-speed file copy. This program will also use command line arguments to specify the source and destination files, so we don’t need to hardcode them into the program.</p>
<h2 id="h1-501621c15-0001">Command Line Arguments</h2>
<p class="BodyFirst">Operating systems give the user the ability to provide a program with a number of command line options when the program is run:</p>
<pre><code><span epub:type="pagebreak" title="250" id="Page_250"/>$ ./<var>prog</var> <var>argument1</var> <var>argument2</var> <var>argument3</var></code></pre>
<p>C passes in these arguments through two parameters, <code>argc</code> and <code>argv</code>, to <code>main</code>:</p>
<pre><code>int main(const int argc, const char* const argv[])</code></pre>
<p>The first parameter, <code>argc</code>, contains the number of arguments. For historical reasons, it is an integer and not an unsigned integer. The second parameter, <code>argv</code>, is an array of strings representing the actual arguments.</p>
<p>If you run a program with an invocation like this:</p>
<pre><code>./<var>prog</var> <var>first</var> <var>second third</var></code></pre>
<p class="BodyContinued">the <code>argv</code> and <code>argc</code> parameters will contain the following:</p>
<pre><code>argc	4
argv[0]    ./<var>prog</var>
argv[1]    <var>first</var>
argv[2]    <var>second</var>
argv[3]    <var>third</var></code></pre>
<p>The first argument is the name of the program. The next argument is the <var>first</var> parameter on the command line, and so on.</p>
<p><a href="#listing15-1" id="listinganchor15-1">Listing 15-1</a> contains a short program designed to print the command line arguments.</p>
<p class="CodeLabel"><b>echo.c</b></p>
<pre><code>/**
 * Echo the command line arguments.
 */
#include &lt;stdio.h&gt;
  
int main(const int argc, const char* argv[])
{
    for (int i = 0; i &lt; argc; ++i) {
        printf("argv[%d] = %s\n", i, argv[i]);
    }
    return (0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing15-1">Listing 15-1</a>: Printing command line arguments</p>
<p>You don’t have to name the argument count <code>argc</code> and the argument vector <code>argv</code>, nor do you have to declare <code>argv</code> and <code>argc const</code>, but it’s conventional to do so.</p>
<h2 id="h1-501621c15-0002">Raw I/O</h2>
<p class="BodyFirst">The two major file I/O systems available to C programmers are <em>buffered I/O</em> and <em>unbuffered I/O</em>. The standard I/O system (<code>printf</code>), which we discussed in <span class="xref" itemid="xref_target_Chapter 14">Chapter 14</span>, uses buffers. In this chapter, we’ll work with unbuffered I/O. <span epub:type="pagebreak" title="251" id="Page_251"/>To show the differences between the two, let’s consider an example. Say you want to clean out your closet, and you have 500 old power cords to throw away. You could do the following:</p>
<ol class="decimal">
<li value="1">Pick up a power cord.</li>
<li value="2">Walk outside to the trash can.</li>
<li value="3">Throw it away.</li>
<li value="4">Repeat 500 times.</li>
</ol>
<p>This method would be like using unbuffered I/O to get rid of the power cords. The <em>throughput</em> (speed at which you are doing the work) is terrible.</p>
<p>Let’s add a buffer—in this case, a garbage bag. The procedure now looks like this:</p>
<ol class="decimal">
<li value="1">Put a power cord in bag.</li>
<li value="2">Keep putting cords in the bag until it is full. (It holds 100 cords.)</li>
<li value="3">Walk outside to the trash can.</li>
<li value="4">Throw the bag away.</li>
<li value="5">Repeat five times.</li>
</ol>
<p>Buffering makes the repetitive process more efficient, so when would you want to use unbuffered I/O? You would use it in cases where it would be more efficient to walk out to the trash can for each item. Say you had to throw away five refrigerators. You wouldn’t want to put five refrigerators in a trash bag and then throw them away. Instead, you’d throw away each one individually.</p>
<h3 id="h2-501621c15-0001">Using Raw I/O</h3>
<p class="BodyFirst">If we wanted to copy a file, we could use the buffered I/O system to do it, but that would mean we would need to let the buffered I/O system choose the size of the buffer. Instead, we want to set our own buffer size. In this case, we know that a size of 1,024 bytes is optimal for the device we are using, so we create the program shown in <a href="#listing15-2" id="listinganchor15-2">Listing 15-2</a> to use raw I/O to copy a file using a 1,024-byte buffer.</p>
<p class="CodeLabel"><b>copy.c</b></p>
<pre><code>/**
 * Copy one file to another.
 *
 * Usage:
 *     copy &lt;from&gt; &lt;to&gt;
 */

#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;unistd.h&gt;
<span epub:type="pagebreak" title="252" id="Page_252"/>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

#ifndef O_BINARY
#define O_BINARY 0      // Define O_BINARY if not defined.
#endif // O_BINARY
  
int main(int argc, char* argv[])
{
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> if (argc != 3) {
        fprintf(stderr, "Usage is %s &lt;infile&gt; &lt;outfile&gt;\n", argv[0]);
        exit(8);
    }

    // The fd of the input file
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> int inFd = open(argv[1], O_RDONLY|O_BINARY);

  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> if (inFd &lt; 0) {
        fprintf(stderr, "ERROR: Could not open %s for input\n", argv[1]);
        exit(8);
    }

    // The fd of the output file
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> int outFd = open(argv[2], O_WRONLY|O_CREAT|O_BINARY, 0666);
    if (outFd &lt; 0) {
        fprintf(stderr, "ERROR: Could not open %s for writing\n", argv[2]);
        exit(8);
    }

    while (true)
    {
        char buffer[1024];      // Buffer to read and write
        size_t readSize;        // Size of the last read

      <span class="CodeAnnotationCode" aria-label="annotation5">5</span> readSize = read(inFd, buffer, sizeof(buffer));
      <span class="CodeAnnotationCode" aria-label="annotation6">6</span> if (readSize &lt; 0) {
            fprintf(stderr, "ERROR: Read error for file %s\n", argv[1]);
            exit(8);
        }
      <span class="CodeAnnotationCode" aria-label="annotation7">7</span> if (readSize == 0)
            break;

      <span class="CodeAnnotationCode" aria-label="annotation8">8</span> if (write(outFd, buffer, readSize) != readSize) {
            fprintf(stderr, "ERROR: Write error for %s\n", argv[2]);
            exit(8);
        }
    }
  <span class="CodeAnnotationCode" aria-label="annotation9">9</span> close(inFd);
    close(outFd);
    return (0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing15-2">Listing 15-2</a>: A program to copy one file to another using raw I/O</p>
<p><span epub:type="pagebreak" title="253" id="Page_253"/>To use the program in <a href="#listing15-2">Listing 15-2</a>, we must specify an input file and an output file:</p>
<pre><code>$ ./copy <var>input-file output-file</var></code></pre>
<p>The program first checks to see that the proper number of arguments is supplied <span class="CodeAnnotation" aria-label="annotation1">1</span>. Next, it opens the input file <span class="CodeAnnotation" aria-label="annotation2">2</span>. The general form of the <code>open</code> function is <var>file-descriptor</var><code> = open(</code><var>filename</var><code>, </code><var>flags</var><code>)</code>. The flags indicate how the file is to be opened. The <code>O_RDONLY</code> flag opens the file read-only, and the <code>O_BINARY</code> flag indicates that the file is binary. The <code>O_BINARY</code> flag is a funny one (I’ll explain it in the next section).</p>
<p>The <code>open</code> command returns a number called a <em>file descriptor</em>. If there is an error, it returns a negative number, which means the next step in the program is to check for errors <span class="CodeAnnotation" aria-label="annotation3">3</span>.</p>
<p>Then we open the output file using the <code>O_WRONLY</code> (write only) and <code>O_CREAT</code> (create the file if needed) flags <span class="CodeAnnotation" aria-label="annotation4">4</span>.</p>
<p>The additional <code>0666</code> parameter means that if the file is created, it’s in protection mode. It’s an octal number, with each digit representing a protection user set and each bit representing a protection type:</p>
<ol class="none">
<li><span class="RunInHead">4</span>  Read</li>
<li><span class="RunInHead">2</span>  Write</li>
<li><span class="RunInHead">1</span>  Execute</li>
</ol>
<p>The digits are in the following order: <em>&lt;user&gt;</em>, <em>&lt;group&gt;</em>, <em>&lt;other&gt;</em>. The <code>0666</code> parameter tells the system to create the file so that the user can read and write it (<code>6</code>), so that accounts in the same group as the user get read/write access (<code>6</code>), and so that anyone else gets the same read/write permission (<code>6</code>).</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If we had used <code>0640</code>, the user would have read/write access (<code>6</code>), the group would have only read access (<code>4</code>), and everyone else would have no access (<code>0</code>).</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Once the files are open, we do the copy <span class="CodeAnnotation" aria-label="annotation5">5</span>. The <code>read</code> function has the general form:</p>
<pre><code><var>bytes_read</var><code> = read(</code><var>fd</var><code>, </code><var>buffer</var><code>, </code><var>size</var><code>);</code></code></pre>
<p class="BodyContinued">where <var>fd</var> is the file descriptor, <var>buffer</var> is the buffer that receives the data, and <var>size</var> is the maximum number of characters read. The function returns the number of bytes read (<var>bytes read</var>), <code>0</code> to indicate the end of the file (EOF), or a negative number indicating an error.</p>
<p>After reading, we check for an error <span class="CodeAnnotation" aria-label="annotation6">6</span>. Then we check to see whether we have reached the end of the file <span class="CodeAnnotation" aria-label="annotation7">7</span>. If so, we’re done transferring data.</p>
<p>At this point we’re sure to have some data, so we write it <span class="CodeAnnotation" aria-label="annotation8">8</span>. The <code>write</code> function has the general form:</p>
<pre><code><var>bytes_written</var><code> = write(</code><var>fd</var><code>, </code><var>buffer</var><code>, </code><var>size</var><code>);</code></code></pre>
<p class="BodyContinued"><span epub:type="pagebreak" title="254" id="Page_254"/>where <var>fd</var> is the file descriptor, <var>buffer</var> is the buffer that has the data, and <var>size</var> is the number of characters to write. This function returns the number of bytes written or a negative number to indicate an error. Once the write is completed, we close the file descriptors <span class="CodeAnnotation" aria-label="annotation9">9</span>.</p>
<h3 id="h2-501621c15-0002">Using Binary Mode</h3>
<p class="BodyFirst">Unfortunately, text files are not portable across operating systems because different operating systems use different characters to indicate the end of a line. C was originally written for Unix, which inspired Linux. Both operating systems use line feed (character number <code>0x0a</code>) as the line ending.</p>
<p>Say you open a text file with no <code>O_BINARY</code> flag and want to write to it. If you write out a string to a file using:</p>
<pre><code>// Bad style; 3 should be a named constant.
write(fd, "Hi\n", 3);</code></pre>
<p class="BodyContinued">on Linux, you’ll get a file with three characters in it:</p>
<pre><code>48  69  0a
 H   i  \n</code></pre>
<p>Other operating systems have to translate the end-of-line sequence into their native line ending. Table 14-1 lists the various line endings.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table15-1">Table 15-1</a>: File Line Endings</p></figcaption>
<table id="table-501621c15-0001" border="1">
<thead>
<tr>
<td><b>OS</b></td>
<td><b>Line ending</b></td>
<td><b>Characters</b></td>
<td><b>Translation</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>Linux</td>
<td>Line feed</td>
<td><code>\n</code></td>
<td>None</td>
</tr>
<tr>
<td>macOS</td>
<td>Carriage return</td>
<td><code>\r</code></td>
<td>Replace <code>\n</code> with <code>\r</code> on output</td>
</tr>
<tr>
<td>Windows</td>
<td>Carriage return, line feed</td>
<td><code>\r\n</code></td>
<td>Insert <code>\r</code> before each <code>\n</code></td>
</tr>
</tbody>
</table>
</figure>
<p>If you are running a C program on Windows and execute this:</p>
<pre><code>// Bad style; 3 should be a named constant.
write(fd, "Hi\n", 3);</code></pre>
<p class="BodyContinued">which is the same code as before, four characters are written:</p>
<pre><code>48  69  0d  0a
 H   i  \r  \n</code></pre>
<p>There will be times, however, when you’re writing a binary file and want byte <code>0a</code> to be written as <code>0a</code> without translation. On Linux, that’s easy, because Linux never does translation. However, other operating systems do, so they added a new <code>O_BINARY</code> flag to tell the library that a binary file is being used and to skip the file translation.</p>
<p><span epub:type="pagebreak" title="255" id="Page_255"/>Linux does not have the <code>O_BINARY</code> flag since it makes no distinction between binary and text files. In fact, you can have a half-binary/half-text file. (I don’t know why you’d want to do that, but Linux will let you.)</p>
<p>I included the <code>O_BINARY</code> flag in <a href="#listing15-2">Listing 15-2</a> because I wanted the copy program to be portable. We need to supply an <code>O_BINARY</code> mode when using Apple and Microsoft systems, but if we compile the program on a Linux system, <code>O_BINARY</code> is undefined.</p>
<p>Thus, the hack is to define it if it is not already defined by the operating system in the header files:</p>
<pre><code>#ifndef O_BINARY
#define O_BINARY 0      // Define O_BINARY if not defined.
#endif // O_BINARY</code></pre>
<p>If the operating system has an <code>O_BINARY</code> defined, the <code>#define</code> will not be compiled. If we are using a Linux-like operating system with no <code>O_BINARY</code>, <code>#define O_BINARY 0</code> will be compiled, and <code>O_BINARY</code> will be assigned the value of <code>0</code>, which does nothing—and doing nothing is exactly what we need on Linux.</p>
<h2 id="h1-501621c15-0003">ioctl</h2>
<p class="BodyFirst">In addition to reading and writing, the raw I/O system provides a function called <code>ioctl</code> that performs I/O control. Its general form is:</p>
<pre><code><var>result</var><code> = ioctl(</code><var>fd</var><code>, </code><var>request</var><code>, </code><var>parameter</var><code>);</code></code></pre>
<p class="BodyContinued">where <var>fd</var> is the file descriptor, <var>request</var> is the device-specific control request, and <var>parameter</var> is the parameter to the request. For most requests, the function returns <code>0</code> if the request worked and a nonzero value otherwise (some <code>ioctl</code> calls return something different).</p>
<p>You can use <code>ioctl</code> to eject removable media, rewind or fast-forward tape drives, set the speed and other parameters of a serial device, and set the address information for a network device. Because the <code>ioctl</code> specification is open-ended, a lot of functionality has been crammed into this interface.</p>
<h2 id="h1-501621c15-0004">Summary</h2>
<p class="BodyFirst">The raw I/O system provides the best control over what your I/O operations actually do. There is minimal editing or interference from the operating system, but this control comes with a price. The buffered I/O system helps limit your mistakes, whereas the raw I/O system does not. Still, if you know what you’re doing, it can be a tremendous asset.</p>
<h2 id="h1-501621c15-0005"><span epub:type="pagebreak" title="256" id="Page_256"/>Programming Problems</h2>
<ol class="decimal">
<li value="1">Write a program that takes one argument: the name of the person running the program. It then says <code>Hello</code> <var>&lt;name&gt;</var>. Here’s an example:<pre><code>./hello Fred
Hello Fred

./hello
Hello stranger</code></pre></li>
<li value="2">Write a program that scans the argument list and, if <code>-d</code> is an argument, prints <code>Debug mode</code>. If the <code>-d</code> is missing, it prints <code>Release mode</code>. Add other options as well.</li>
<li value="3">Time how long it takes the copy program in <a href="#listing15-2">Listing 15-2</a> to copy a large file. Now change the buffer size to 1. See how fast the program is. Change the buffer size to 16384. See how fast it runs. Try 17000. Note: almost every disk reads and writes in 512-byte blocks. How does this fact explain the timings you are seeing?</li>
<li value="4">Research the <code>getopt</code> function and use it to parse the command line arguments you invented for problem 1.</li>
</ol>
</section>
</body></html>