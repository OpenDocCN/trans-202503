- en: '![](../images/pg242.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg242.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-26.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-26.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">LONG
    INTEGERS</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">长整型</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: 'In this chapter, you’ll add a new type: <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>.
    This is a signed integer type, just like <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>;
    the only difference between the two types is the range of values they hold. You’ll
    also add an explicit cast operation, which converts a value to a different type.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将添加一个新类型：<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>。这是一种有符号整数类型，就像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 一样；这两者之间唯一的区别是它们所能表示的值的范围。你还将添加一个显式类型转换操作，它将一个值转换为不同的类型。
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> is so similar
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type we already
    support, we won’t need to add many new assembly or TACKY instructions or implement
    complicated type casting logic. Instead, we’ll focus on laying the groundwork
    we’ll need for the rest of [Part II](part2.xhtml). We’ll track the types of constants
    and variables, attach type information to the AST, identify implicit casts and
    make them explicit, and determine the operand sizes for assembly instructions.
    We’ll need to make at least a small change to every stage of the compiler except
    for loop labeling. Before we get started, let’s see what operations on <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>s
    look like in assembly.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 类型与我们已经支持的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型非常相似，因此我们无需添加许多新的汇编或 TACKY
    指令，也不需要实现复杂的类型转换逻辑。相反，我们将集中精力为 [第二部分](part2.xhtml) 的其余内容打好基础。我们将跟踪常量和变量的类型，将类型信息附加到抽象语法树（AST）上，识别隐式类型转换并使其显式，并确定汇编指令的操作数大小。我们将需要对编译器的每个阶段（除了循环标记）进行至少一点小改动。在开始之前，让我们看看
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 类型在汇编中的操作表现如何。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Long Integers in Assembly</samp>'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">汇编中的长整型</samp>'
- en: 'The C standard doesn’t specify the sizes of integer types, but the System V
    x64 ABI says that an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    is 4 bytes and a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> is
    8\. To wildly oversimplify things, C expressions with <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    operands are ultimately translated into assembly instructions on quadwords (8-byte
    operands). For example, the following assembly instructions operate on quadwords
    to calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> and produce a quadword
    result:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: C语言标准并未指定整数类型的大小，但 System V x64 ABI 规定 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    是 4 字节，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 是 8 字节。为了极度简化问题，C
    表达式中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 操作数最终会转换为针对 quadwords（8
    字节操作数）的汇编指令。例如，以下汇编指令在 quadwords 上操作来计算 <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>，并生成一个
    quadword 结果：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This looks almost identical to the equivalent code using longwords, which are
    4 bytes:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这与使用 longwords（4 字节）编写的等效代码几乎完全相同：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The only differences are the suffix on the <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> instructions and
    whether we use the whole RAX register or just EAX, its lower 4 bytes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>
    指令的后缀，以及我们是否使用整个 RAX 寄存器或仅使用其下 4 字节的 EAX。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*The terms* word*,* longword*, and* quadword *date back to the era of 16-bit
    processors, when an int was 2 bytes and a long was 4 bytes. To make matters worse,
    4-byte values are often called* doublewords *instead of longwords. I use the term*
    longword *to mirror AT&T assembly syntax, but Intel’s documentation uses* doubleword*.*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*术语* word*、*longword* 和 *quadword* 起源于16位处理器时代，当时 int 是2字节，long 是4字节。更糟糕的是，4字节的值常常被称为
    *doublewords* 而不是 longwords。我使用 *longword* 这一术语来模仿 AT&T 汇编语法，但英特尔的文档使用 *doubleword*。'
- en: Most quadword instructions accept only 8-byte operands and produce 8-byte results,
    just as most longword instructions accept only 4-byte operands and produce 4-byte
    results. Expressions in C, on the other hand, often use several operand types
    at once or assign a value of one type to an object of a different type. During
    compilation, we’ll decompose these expressions into simple instructions that either
    take operands of a single type and produce results of the same type or explicitly
    perform type conversions. Luckily, the C standard tells us exactly where these
    type conversions occur.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数四字指令只接受8字节操作数并生成8字节结果，就像大多数长字指令只接受4字节操作数并生成4字节结果一样。而C语言中的表达式则经常同时使用多种操作数类型，或者将一种类型的值赋给另一种类型的对象。在编译过程中，我们将把这些表达式分解为简单的指令，这些指令要么接受单一类型的操作数并生成相同类型的结果，要么显式地进行类型转换。幸运的是，C标准明确告诉我们这些类型转换发生的位置。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Conversions</samp>
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">类型转换</samp>
- en: 'Section 6.3.1.3, paragraph 1, of the C standard defines how to convert between
    integer types: “If the value can be represented by the new type, it is unchanged.”
    In other words, if some expression evaluates to, say, 3, and then you cast it
    to a different integer type, the result of that cast expression should still be
    3.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C标准第6.3.1.3节第1段定义了如何在整数类型之间进行转换：“如果值可以由新类型表示，则不作更改。”换句话说，如果某个表达式计算结果为3，然后你将其强制转换为另一种整数类型，那么该强制转换表达式的结果应该仍然是3。
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> is larger
    than <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, we can safely cast
    any <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    without changing its value. We’re using a two’s complement representation of signed
    integers, so we’ll cast from <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> using sign extension,
    which you learned about in [Chapter 3](chapter3.xhtml). Specifically, we’ll use
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp> (or “move with
    sign extension”) assembly instruction. This instruction moves a 4-byte source
    into an 8-byte destination, sign extending the value into the destination’s upper
    4 bytes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>大于<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，我们可以安全地将任何<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>转换为<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>而不会改变其值。我们使用的是有符号整数的二进制补码表示法，因此我们将通过符号扩展将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>转换为<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>，这种符号扩展的知识你在[第3章](chapter3.xhtml)中学过。具体来说，我们将使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp>（或“带符号扩展的移动”）汇编指令。这条指令将4字节的源数据移入8字节的目标数据，并将值符号扩展到目标数据的上4字节。
- en: 'Converting a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> to an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is trickier because it
    may be too large or too small to represent as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Paragraph 3 of section 6.3.1.3 goes on to tell us that when “the new type is signed
    and the value cannot be represented in it[,] either the result is implementation-defined
    or an implementation-defined signal is raised.” In other words, it’s up to us
    to decide what to do. Our implementation will handle this conversion in the same
    way as GCC, as specified in its documentation: “For conversion to a type of width
    *N*, the value is reduced modulo 2*^N* to be within range of the type; no signal
    is raised” (*[https://<wbr>gcc<wbr>.gnu<wbr>.org<wbr>/onlinedocs<wbr>/gcc<wbr>/Integers<wbr>-implementation<wbr>.html](https://gcc.gnu.org/onlinedocs/gcc/Integers-implementation.html)*).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>转换为<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>会更棘手，因为它可能太大或太小，无法表示为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。C标准第6.3.1.3节的第3段告诉我们，“当新类型为有符号类型且值无法在其中表示时，[结果]要么由实现定义，要么引发实现定义的信号。”换句话说，我们需要决定如何处理。我们的实现将按照GCC的方式处理这种转换，正如其文档中所述：“对于转换为宽度为*N*的类型，值会对2*^N*取模，从而使其在类型范围内；不会引发信号”
    (*[https://<wbr>gcc<wbr>.gnu<wbr>.org<wbr>/onlinedocs<wbr>/gcc<wbr>/Integers<wbr>-implementation<wbr>.html](https://gcc.gnu.org/onlinedocs/gcc/Integers-implementation.html)*).
- en: Reducing a value modulo 2^(32) means adding or subtracting a multiple of 2^(32)
    to bring it into the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Here’s a quick example. The largest value you can represent as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    is 2^(31) – 1, or 2,147,483,647\. Suppose you need to convert the next largest
    integer value (2^(31), or 2,147,483,648) from a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Subtracting 2^(32)
    from this value gives you –2^(31), or –2,147,483,648, which is the smallest value
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> can represent.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 按模 2^(32) 减少一个值意味着加或减一个 2^(32) 的倍数，使其落入 `<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>`
    的范围内。这里有一个简单的例子。你可以表示的最大 `<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>`
    值是 2^(31) – 1，即 2,147,483,647。假设你需要将下一个最大的整数值 (2^(31)，即 2,147,483,648) 从 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>` 转换为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>`。从该值减去
    2^(32) 会得到 -2^(31)，即 -2,147,483,648，这是 `<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>`
    能表示的最小值。
- en: 'In practice, we’ll convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> by dropping its
    upper 4 bytes. If a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    can be represented as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    dropping those bytes won’t change its value. For example, here’s the 8-byte binary
    representation of –3:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们将通过丢弃 `<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>` 的上4个字节，将其转换为
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>`。如果一个 `<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>`
    可以表示为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>`，那么丢弃这些字节不会改变它的值。例如，这是
    -3 的8字节二进制表示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And here’s the 4-byte representation of the same value:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相同值的4字节表示：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> can’t be represented
    as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, dropping its upper
    4 bytes has the effect of reducing its value modulo 2^(32). To return to our earlier
    example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 2,147,483,648
    has the following binary representation:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 `<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>` 无法表示为 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>`，丢弃其上4个字节的效果是将其值按模 2^(32) 进行减少。以我们之前的例子为例，`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>` 2,147,483,648 的二进制表示如下：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After we convert it to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    the result, with the value –2,147,483,648, has the following binary representation:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转换为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>` 后，结果为值 -2,147,483,648，其二进制表示如下：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To drop a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>’s upper
    bytes, we just copy its lower bytes with a <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    instruction. For example, the following instruction truncates a value stored in
    RCX:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要丢弃一个 `<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>` 的上4个字节，我们只需使用
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>` 指令复制它的下4个字节。例如，以下指令将截断存储在
    RCX 中的值：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When we store a value in a register’s lower 4 bytes, the register’s upper 4
    bytes will be zeroed out.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将值存储在寄存器的下4个字节时，寄存器的上4个字节将被置为零。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Static Long Variables</samp>
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">静态长整型变量</samp>
- en: 'Variables with static storage duration are defined in assembly in basically
    the same way regardless of their type, but there are a few small differences between
    static quadwords and longwords. Consider the following file scope variable declaration:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 静态存储持续时间的变量在汇编中定义方式基本相同，不管其类型如何，但静态四字和长字之间有一些小的差别。考虑以下文件作用域变量声明：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’ll convert this declaration to the assembly in [Listing 11-1](chapter11.xhtml#list11-1).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个声明转换为 [Listing 11-1](chapter11.xhtml#list11-1) 中的汇编代码。
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-1: Initializing
    an 8-byte value in the data section</samp>'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-1: 在数据区初始化一个8字节值</samp>'
- en: 'This differs from the assembly we generate for a static <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    in two ways: the alignment is <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, and we use
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp> directive to initialize
    an 8-byte value instead of using <samp class="SANS_TheSansMonoCd_W5Regular_11">.long</samp>
    to initialize 4 bytes.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们为静态 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 生成的汇编有两点不同：对齐方式是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp> 而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>，并且我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp> 指令初始化 8 字节的值，而不是使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.long</samp> 来初始化 4 字节。
- en: The System V x64 ABI specifies that <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> are 8-byte and 4-byte
    aligned, respectively. The C standard leaves their alignment, like their size,
    unspecified.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: System V x64 ABI 规定 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 分别是 8 字节和 4 字节对齐的。C
    标准未指定它们的对齐方式，像它们的大小一样是未定义的。
- en: 'Now that we have some idea of what assembly we want to generate, let’s get
    to work on the compiler!  ### <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们对要生成的汇编有了大致的了解，接下来让我们开始编写编译器吧！ ### <samp class="SANS_Futura_Std_Bold_B_11">词法分析器</samp>'
- en: 'You’ll add the following two tokens in this chapter:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，您将添加以下两个标记：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">long</samp> A keyword.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">long</samp> 一个关键字。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Long integer constants</samp> These
    differ from our current integer constants because they have an <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> suffix. A long constant
    token matches the regex <samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]+[lL]\b</samp>.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">长整型常量</samp> 这些与我们当前的整型常量不同，因为它们有一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp>
    后缀。长整型常量标记与正则表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]+[lL]\b</samp>
    匹配。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">解析器</samp>
- en: We’ll add long constants, cast expressions, and type information to the AST
    in this chapter. [Listing 11-2](chapter11.xhtml#list11-2) shows the updated AST
    definition.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将向抽象语法树（AST）添加长整型常量、类型信息和类型转换表达式。[列表 11-2](chapter11.xhtml#list11-2)展示了更新后的
    AST 定义。
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-2: The abstract
    syntax tree with long constants, type information, and cast expressions</samp>'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 11-2：包含长整型常量、类型信息和类型转换表达式的抽象语法树</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> AST node can represent
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>,
    and function types ❸. Rather than defining a brand-new data structure here, we
    can extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> structure
    we started using in symbol table entries in [Chapter 9](chapter9.xhtml). From
    now on, we’ll use that data structure in both the symbol table and the AST.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> AST 节点可以表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 和函数类型 ❸。我们并不打算在这里定义全新的数据结构，而是可以扩展我们在[第
    9 章](chapter9.xhtml)中开始使用的 <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    结构，在符号表条目中使用。从现在开始，我们将在符号表和 AST 中都使用该数据结构。
- en: 'In [Chapter 9](chapter9.xhtml), we defined <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 9 章](chapter9.xhtml)中，我们像这样定义了<samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In [Listing 11-2](chapter11.xhtml#list11-2), we modify this definition by adding
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Long</samp> and tracking additional
    information about function types, including the return type and the list of parameter
    types. We didn’t need that information before, because the type of every parameter
    and the return type had to be <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Note that our new, recursive definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    can represent some invalid types, like functions that return functions, but the
    parser will never produce those invalid types.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 11-2](chapter11.xhtml#list11-2)中，我们通过添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">Long</samp>
    和跟踪有关函数类型的附加信息，包括返回类型和参数类型列表，修改了这个定义。之前我们不需要这些信息，因为每个参数和返回类型的类型都必须是 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。请注意，我们新的递归定义的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> 可以表示一些无效类型，比如返回函数的函数，但解析器永远不会生成这些无效类型。
- en: Once we’ve updated how we represent <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>,
    we attach type information to variable ❶ and function declarations ❷. We don’t
    add type information to <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp>
    in function declarations because the function’s type already includes the types
    of its parameters. We also extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    AST node to represent cast expressions ❹ and define a new <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    AST node with distinct constructors for <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> constants ❺. We’ll
    need to distinguish between different types of constants during type checking.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们更新了表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> 的方式，我们将类型信息附加到变量❶和函数声明❷。我们不会在函数声明的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp> 中添加类型信息，因为函数的类型已经包含了其参数的类型。我们还扩展了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST 节点，以表示类型转换表达式❹，并定义了一个新的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> AST 节点，具有区分长整型和整型常量的不同构造函数❺。我们在类型检查过程中需要区分不同类型的常量。
- en: If your implementation language has signed 64-bit and 32-bit integer types and
    supports conversions between those types with the same semantics as conversions
    between <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    in our implementation of C, I recommend using those types to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp> in the AST.
    (Most languages provide fixed-width integer types with these semantics, either
    by default or through a library.) This will make it easier to cast static initializers
    to the correct type at compile time; it will also simplify constant folding, an
    optimization we’ll implement in [Part III](part3.xhtml). If your implementation
    language doesn’t have integer types with the right semantics, you should at least
    make sure the <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp> node
    uses an integer type that can represent all <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    values.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的实现语言支持有符号的 64 位和 32 位整数类型，并且支持这些类型之间的转换，且转换语义与我们在 C 实现中对 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 之间的转换相同，我建议使用这些类型来表示
    AST 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp>。（大多数语言通过默认或库提供这些语义的定长整数类型。）这将使得在编译时更容易将静态初始化器转换为正确的类型；它还将简化常量折叠，这是一种我们将在[第三部分](part3.xhtml)中实现的优化。如果你的实现语言没有具有正确语义的整数类型，你至少应确保
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp> 节点使用能够表示所有 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 值的整数类型。
- en: After updating the AST, we’ll make the corresponding changes to the grammar,
    shown in [Listing 11-3](chapter11.xhtml#list11-3).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 AST 后，我们将对语法进行相应的更改，参见[列表 11-3](chapter11.xhtml#list11-3)。
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-3: The grammar with
    long constants, the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">long</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">type specifier, and cast expressions</samp>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 11-3：包含长常量、长类型说明符和类型转换表达式的语法</samp>
- en: We need to handle two slightly tricky details here. First, whenever we parse
    a list of type specifiers, we need to convert them into a single <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    AST node. A long integer can be declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    specifier or with both <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, in either order.
    [Listing 11-4](chapter11.xhtml#list11-4) illustrates how to turn a list of type
    specifiers into a type.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理两个稍微复杂的细节。首先，每当我们解析类型修饰符列表时，我们需要将它们转换为一个单一的 <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    AST 节点。长整型可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 修饰符来声明，也可以通过同时使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    来声明，顺序可以任意。 [清单 11-4](chapter11.xhtml#list11-4) 说明了如何将类型修饰符列表转换为类型。
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-4: Determining a
    type from a list of type specifiers</samp>'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-4：从类型修饰符列表中确定类型</samp>
- en: This works for types with no storage class, which we’ll find in parameter lists
    or cast expressions. For function and variable declarations, we’ll build on the
    specifier parsing code from [Listing 10-21](chapter10.xhtml#list10-21). [Listing
    11-5](chapter11.xhtml#list11-5) reproduces that code, with changes bolded.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于没有存储类的类型，我们通常会在参数列表或类型转换表达式中找到这些类型。对于函数和变量声明，我们将在 [清单 10-21](chapter10.xhtml#list10-21)
    中的修饰符解析代码的基础上进行扩展。[清单 11-5](chapter11.xhtml#list11-5) 复制了该代码，并用粗体标出了更改部分。
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-5: Determining type
    and storage class from a list of specifiers</samp>'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-5：从修饰符列表中确定类型和存储类</samp>
- en: We still separate type specifiers from storage class specifiers and determine
    storage class just like we did in [Listing 10-21](chapter10.xhtml#list10-21),
    but we’ve made a few small changes here. First, we recognize <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    as a type specifier. Second, we no longer expect the list of type specifiers to
    have exactly one element (this change isn’t bolded because we just deleted some
    existing code). Third, rather than always setting <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp>, we use the new <samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_type</samp> function to determine
    the type.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然将类型修饰符与存储类修饰符分开，并像在 [清单 10-21](chapter10.xhtml#list10-21) 中那样确定存储类，但我们在这里做了一些小的改动。首先，我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 识别为类型修饰符。其次，我们不再要求类型修饰符列表必须恰好包含一个元素（这个更改没有用粗体标出，因为我们只是删除了一些现有代码）。第三，我们不再总是将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> 设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp>，而是使用新的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_type</samp> 函数来确定类型。
- en: The second tricky detail is parsing constant tokens. [Listing 11-6](chapter11.xhtml#list11-6)
    shows how to convert these into <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    AST nodes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个复杂的细节是解析常量标记。[清单 11-6](chapter11.xhtml#list11-6) 展示了如何将这些标记转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    AST 节点。
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-6: Converting a
    constant token to an AST node</samp>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-6：将常量标记转换为 AST 节点</samp>
- en: We parse an integer constant token (without an <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> suffix) into a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp> node unless its value
    is outside the range of the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    type. Similarly, we parse a long constant token (with an <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> suffix) into a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp> node unless its value
    is outside the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>.
    If an integer constant token is outside the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    but in the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>,
    we parse it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp>
    node. If an integer or long constant token is too large for <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    to represent, we throw an error.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个整数常量标记（没有 <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">L</samp> 后缀）解析为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp>
    节点，除非它的值超出了 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型的范围。类似地，我们将一个长整型常量标记（带有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp>
    后缀）解析为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp> 节点，除非它的值超出了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 类型的范围。如果一个整数常量标记超出了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型的范围，但在 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    类型的范围内，我们将其解析为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp>
    节点。如果一个整数或长整型常量标记对于 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    来说过大，我们将抛出一个错误。
- en: An <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is 32 bits, so it
    can hold any value between –2^(31) and 2^(31) – 1, inclusive. By the same logic,
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> can hold any value
    between –2^(63) and 2^(63) – 1\. Your parser should check each constant token
    against the maximum value of the corresponding type. It doesn’t need to check
    against the minimum value, because these tokens can’t represent negative numbers;
    the negative sign is a separate token.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 是 32 位的，因此它可以保存从
    –2^(31) 到 2^(31) – 1 之间的任何值，包括端点。按相同的逻辑，一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    可以保存从 –2^(63) 到 2^(63) – 1 之间的任何值。你的解析器应该检查每个常量标记是否超出了相应类型的最大值。它不需要检查最小值，因为这些标记不能表示负数；负号是一个单独的标记。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp>
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">语义分析</samp>
- en: 'Next, we’ll extend the compiler passes that perform semantic analysis. We’ll
    make one tiny mechanical change to identifier resolution: we’ll extend <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>
    to traverse cast expressions the same way it traverses other kinds of expressions.
    I won’t always explicitly mention this sort of modification in later chapters;
    from now on, whenever we add a new expression that contains subexpressions, go
    ahead and extend the identifier resolution pass to traverse it. Once we’ve made
    this change, we can turn to the more interesting problem of extending the type
    checker.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将扩展执行语义分析的编译器过程。我们将对标识符解析做一个微小的机械性修改：我们将扩展 <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>，使其像遍历其他类型的表达式一样遍历类型转换表达式。我以后在章节中不会每次都明确提到这种修改；从现在开始，只要我们添加一个包含子表达式的新表达式，就可以扩展标识符解析过程来遍历它。做完这个修改后，我们就可以转向更有趣的问题——扩展类型检查器。
- en: Just as every object in a C program has a type, the result of every expression
    has a type too. For example, performing any binary arithmetic operation on two
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> operands results in an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, performing the same
    operation on two <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> operands
    results in a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, and calling
    a function with a particular return type produces a result of that type.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 C 程序中的每个对象都有一个类型一样，每个表达式的结果也有一个类型。例如，对两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    操作数执行任何二元算术运算将得到一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 结果，对两个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 操作数执行相同的操作将得到一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 结果，调用具有特定返回类型的函数将返回该类型的结果。
- en: During the type checking pass, we’ll annotate every expression in the AST with
    the type of its result. We’ll use this type information to determine the types
    of the temporary variables we generate in TACKY to hold intermediate results.
    That, in turn, will tell us the appropriate operand sizes for assembly instructions
    and the amount of stack space we need to allocate for each temporary variable.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型检查过程中，我们将为 AST 中的每个表达式注释其结果的类型。我们将使用这些类型信息来确定我们在 TACKY 中生成的临时变量的类型，以便保存中间结果。这将反过来帮助我们确定汇编指令所需的操作数大小，以及为每个临时变量分配的栈空间大小。
- en: While we’re annotating expressions with type information, we’ll also identify
    any implicit type conversions in the program and make them explicit by inserting
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Cast</samp> expressions in the AST.
    Then, we can easily generate the correct type casting instructions during TACKY
    generation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们给表达式注释类型信息的同时，我们还会识别程序中的任何隐式类型转换，并通过在 AST 中插入 <samp class="SANS_TheSansMonoCd_W5Regular_11">Cast</samp>
    表达式将其显式化。然后，我们可以在 TACKY 生成过程中轻松生成正确的类型转换指令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Type Information
    to the AST</samp>
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将类型信息添加到 AST</samp>
- en: Before we update the type checker, we need a way to attach type information
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST nodes. The obvious
    solution, shown in [Listing 11-7](chapter11.xhtml#list11-7), is to mechanically
    add a <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> field to every
    <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> constructor.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更新类型检查器之前，我们需要一种方法来将类型信息附加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    AST 节点。显而易见的解决方案，如 [Listing 11-7](chapter11.xhtml#list11-7) 所示，是在每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    构造器中机械地添加一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> 字段。
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-7: Adding type information
    to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">nodes</samp>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-7: 向</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">exp</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">节点添加类型信息</samp>'
- en: This is easy enough if you’re using an object-oriented implementation language
    and you have a common base class for every <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>.
    You can just add a <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> field
    to the base class, as shown in [Listing 11-8](chapter11.xhtml#list11-8).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是面向对象的实现语言，并且每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    都有一个公共基类，那么这就非常简单。你可以像 [Listing 11-8](chapter11.xhtml#list11-8) 中所示那样，在基类中添加一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> 字段。
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-8: Adding a type
    to the base class for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">nodes</samp>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-8: 为</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">exp</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">节点添加类型</samp>'
- en: If, on the other hand, you’ve implemented your AST using algebraic data types,
    this approach is deeply annoying. Not only will you have to update every single
    <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> constructor, but you’ll
    also have to pattern match on every constructor whenever you want to get an expression’s
    type. A slightly less tedious approach, shown in [Listing 11-9](chapter11.xhtml#list11-9),
    is to define mutually recursive <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">typed_exp</samp> AST nodes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你使用代数数据类型实现了 AST，那么这种方法会非常令人烦恼。你不仅需要更新每一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    构造器，而且每当你想获取表达式的类型时，还必须在每个构造器上进行模式匹配。一个稍微不那么繁琐的方法，如 [Listing 11-9](chapter11.xhtml#list11-9)
    所示，是定义互相递归的 <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">typed_exp</samp>
    AST 节点。
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-9: Another way to
    add type information to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">nodes</samp>'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-9: 向</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">exp</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">节点添加类型信息的另一种方式</samp>'
- en: 'Whichever option you choose, you’ll need to either define two separate AST
    data structures—one with type information and one without—or initialize every
    <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> with a null or dummy
    type when you build the AST in the parser. There’s no one right answer here; it
    depends on your implementation language and personal taste. Rather than imposing
    a specific approach, the pseudocode in the rest of the book will use two functions
    to handle type information in the AST: <samp class="SANS_TheSansMonoCd_W5Regular_11">set_type(e,
    t)</samp> returns a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>
    annotated with type <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">get_type(e)</samp> returns the type
    annotation from <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种方式，你都需要定义两个独立的AST数据结构——一个包含类型信息，一个不包含类型信息——或者在构建AST时，在解析器中为每个<samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>初始化一个空类型或虚拟类型。这里没有唯一正确的答案，这取决于你的实现语言和个人喜好。为了不强加某种特定方法，本书接下来的伪代码将使用两个函数来处理AST中的类型信息：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">set_type(e, t)</samp>返回带有类型<samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>注解的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">e</samp>的副本，而<samp class="SANS_TheSansMonoCd_W5Regular_11">get_type(e)</samp>返回来自<samp
    class="SANS_TheSansMonoCd_W5Regular_11">e</samp>的类型注解。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Expressions</samp>
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">类型检查表达式</samp>
- en: Once we’ve extended our AST definition, we’ll rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>,
    which we defined in [Chapter 9](chapter9.xhtml), to return a new annotated copy
    of each <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST node it processes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们扩展了AST的定义，我们将重写在[第9章](chapter9.xhtml)中定义的<samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>，使其返回每个处理过的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST节点的新注解副本。
- en: '[Listing 11-10](chapter11.xhtml#list11-10) shows how to type check a variable.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-10](chapter11.xhtml#list11-10)展示了如何进行变量的类型检查。'
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-10: Type checking
    a variable</samp>'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-10：类型检查变量</samp>
- en: First, we look up the variable’s type in the symbol table. Then, we validate
    that we’re not using a function name as a variable, just like we did in earlier
    chapters. Finally, we annotate the expression with the variable’s type and return
    it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在符号表中查找变量的类型。然后，我们验证是否没有将函数名当作变量使用，就像我们在之前的章节中所做的一样。最后，我们为表达式标注上变量的类型并返回。
- en: '[Listing 11-11](chapter11.xhtml#list11-11) shows how to type check a constant.
    This is easy, since different types of constants have different constructors in
    the AST.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-11](chapter11.xhtml#list11-11)展示了如何进行常量的类型检查。这很简单，因为不同类型的常量在抽象语法树（AST）中有不同的构造函数。'
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-11: Type checking
    a constant</samp>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-11：类型检查常量</samp>
- en: For the remaining expressions, we’ll need to traverse any subexpressions and
    annotate them too. The result of a cast expression has whatever type we cast it
    to. We type check these in [Listing 11-12](chapter11.xhtml#list11-12).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于剩下的表达式，我们需要遍历任何子表达式并对它们进行标注。一个强制转换表达式的结果会有我们强制转换的目标类型。我们在[清单 11-12](chapter11.xhtml#list11-12)中进行了类型检查。
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-12: Type checking
    a cast expression</samp>'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-12：类型检查强制转换表达式</samp>
- en: The results of expressions that evaluate to 1 or 0 to indicate true or false,
    including comparisons and logical operations like <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>,
    have type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. The results
    of arithmetic and bitwise expressions have the same type as their operands. This
    is straightforward for unary expressions, which we type check in [Listing 11-13](chapter11.xhtml#list11-13).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 结果为1或0表示真或假的表达式（包括比较和逻辑运算如<samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>）的类型为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。算术和按位运算表达式的结果类型与它们的操作数类型相同。对于一元表达式，这很直接，我们在[清单
    11-13](chapter11.xhtml#list11-13)中进行了类型检查。
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-13: Type checking
    a unary expression</samp>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-13：类型检查一元表达式</samp>
- en: Binary expressions are more complicated because the two operands may have different
    types. This doesn’t matter for logical <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operations, which
    can evaluate the truth value of each operand in turn. It does matter for comparisons
    and arithmetic operations, which need to use both operands at once. The C standard
    defines a set of rules, called the *usual arithmetic conversions*, for implicitly
    converting both operands of an arithmetic expression to the same type, called
    its *common type* or *common real type*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 二元表达式更为复杂，因为两个操作数可能具有不同的类型。对于逻辑 <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> 操作，这并不重要，因为它们可以依次评估每个操作数的真值。对于比较和算术操作，则需要同时使用两个操作数，这就变得重要了。C
    标准定义了一组规则，称为 *通常的算术转换*，用于隐式地将算术表达式的两个操作数转换为相同类型，这个类型被称为 *公共类型* 或 *公共实数类型*。
- en: Given the types of two operands, [Listing 11-14](chapter11.xhtml#list11-14)
    shows how to find their common real type. For now this is simple, since there
    are only two possible types.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个操作数的类型，[清单 11-14](chapter11.xhtml#list11-14)展示了如何找到它们的公共实数类型。目前这很简单，因为只有两种可能的类型。
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-14: Finding the
    common real type</samp>'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-14：找到公共实数类型</samp>
- en: If the two types are already the same, no conversion is necessary. If they’re
    different, we convert the smaller type (which must be <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp>)
    to the larger type (which must be <samp class="SANS_TheSansMonoCd_W5Regular_11">Long</samp>),
    so the common type is <samp class="SANS_TheSansMonoCd_W5Regular_11">Long</samp>.
    Once we add more types, finding the common type won’t be quite this straightforward.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个类型已经相同，则不需要进行转换。如果它们不同，我们将较小的类型（必须是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp>）转换为较大的类型（必须是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Long</samp>），因此公共类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Long</samp>。一旦我们添加更多类型，找到公共类型就不再如此简单。
- en: Once we know the common type that both operands will be converted to, we can
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_to</samp> helper
    function, shown in [Listing 11-15](chapter11.xhtml#list11-15), to make those type
    conversions explicit.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了两个操作数将被转换成的公共类型，我们就可以使用 [清单 11-15](chapter11.xhtml#list11-15) 中展示的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">convert_to</samp> 辅助函数，将这些类型转换显式化。
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-15: Making an implicit
    type conversion explicit</samp>'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-15：将隐式类型转换显式化</samp>
- en: If an expression already has the correct result type, <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_to</samp>
    returns it unchanged. Otherwise, it wraps the expression in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Cast</samp>
    AST node, then annotates the result with the correct type.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个表达式已经具有正确的结果类型，<samp class="SANS_TheSansMonoCd_W5Regular_11">convert_to</samp>
    将返回它，并保持不变。否则，它会将表达式包装在一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Cast</samp>
    AST 节点中，然后用正确的类型对结果进行注解。
- en: With both of these helper functions in place, we can type check binary expressions.
    [Listing 11-16](chapter11.xhtml#list11-16) shows the relevant clause of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个辅助函数，我们就可以对二元表达式进行类型检查。[清单 11-16](chapter11.xhtml#list11-16)展示了 <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>
    的相关部分。
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-16: Type checking
    a binary expression</samp>'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-16：对二元表达式进行类型检查</samp>
- en: We start by type checking both operands ❶. If the operator is <samp class="SANS_TheSansMonoCd_W5Regular_11">And</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Or</samp>, we don’t perform any
    type conversions. Otherwise, we perform the usual arithmetic conversions ❷. We
    first get the common type, then convert both operands to that type. (In practice,
    at least one operand will have the correct type already, so <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_to</samp>
    will return it unchanged.) Next, we construct our new <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    AST node using these converted operands. Finally, we annotate the new AST node
    with the correct result type ❸. If this is an arithmetic operation, the result
    will have the same type as its operands, which is the common type we found earlier.
    Otherwise, it’s a comparison that results in an integer representation of true
    or false, so the result type is <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp>.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从对两个操作数进行类型检查开始❶。如果操作符是 <samp class="SANS_TheSansMonoCd_W5Regular_11">And</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Or</samp>，我们不进行任何类型转换。否则，我们执行常规的算术类型转换❷。我们首先找到共同类型，然后将两个操作数转换为该类型。（实际上，至少有一个操作数已经是正确的类型，因此
    <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_to</samp> 将返回未更改的操作数。）接下来，我们使用这些转换后的操作数构建新的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> AST 节点。最后，我们用正确的结果类型注释新的
    AST 节点❸。如果这是一个算术操作，结果将具有与操作数相同的类型，也就是我们之前找到的共同类型。否则，它是一个比较，结果是整数形式的真或假，因此结果类型是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp>。
- en: In assignment expressions, we convert the value being assigned to the type of
    the object it’s assigned to. [Listing 11-17](chapter11.xhtml#list11-17) gives
    the pseudocode for this case.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在赋值表达式中，我们将赋值的值转换为它所赋给的对象的类型。[清单 11-17](chapter11.xhtml#list11-17)给出了这种情况的伪代码。
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-17: Type checking
    an assignment expression</samp>'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-17：赋值表达式的类型检查</samp>
- en: Remember that the result of an assignment expression is the value of the left-hand
    side after assignment; unsurprisingly, the result has the type of the left-hand
    side as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，赋值表达式的结果是赋值后左侧操作数的值；不出所料，结果的类型也与左侧操作数相同。
- en: 'Conditional expressions work a lot like binary arithmetic expressions: we find
    the common type of both branches, convert both branches to that common type, and
    annotate the result with that type. We’ll type check the controlling condition,
    but we don’t need to convert it to anything. I won’t give you the pseudocode for
    this case.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 条件表达式的工作方式类似于二元算术表达式：我们找到两个分支的共同类型，将两个分支转换为该共同类型，并用该类型标注结果。我们会对控制条件进行类型检查，但不需要将其转换为其他类型。我不会为此提供伪代码。
- en: Last but not least, [Listing 11-18](chapter11.xhtml#list11-18) shows how to
    type check function calls.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，[清单 11-18](chapter11.xhtml#list11-18)展示了如何进行函数调用的类型检查。
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-18: Type checking
    a function call</samp>'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-18：函数调用的类型检查</samp>
- en: We start by looking up the function type in the symbol table. Just like in previous
    chapters, we need to make sure that the identifier we’re trying to call is actually
    a function and that we’re passing it the right number of arguments. Then, we iterate
    over the function’s arguments and parameters together ❶. We type check each argument,
    then convert it to the corresponding parameter type. Finally, we annotate the
    whole expression with the function’s return type ❷.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从符号表中查找函数类型。就像在前几章中一样，我们需要确保我们尝试调用的标识符实际上是一个函数，并且我们传递给它正确数量的参数。然后，我们同时遍历函数的参数和形参❶。我们对每个参数进行类型检查，然后将其转换为对应的形参类型。最后，我们用函数的返回类型注释整个表达式❷。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking return
    Statements</samp>
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">类型检查 return 语句</samp>
- en: When a function returns a value, it’s implicitly converted to the function’s
    return type. The type checker needs to make this implicit conversion explicit.
    To type check a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement,
    we look up the enclosing function’s return type and convert the return value to
    that type. This requires us to keep track of the name, or at least the return
    type, of whatever function we’re currently type checking. I’ll omit the pseudocode
    to type check <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statements,
    since it’s straightforward.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数返回一个值时，它会隐式地转换为该函数的返回类型。类型检查器需要将这种隐式转换显式化。为了进行`return`语句的类型检查，我们需要查找封闭函数的返回类型，并将返回值转换为该类型。这要求我们跟踪当前正在类型检查的函数的名称，或者至少是返回类型。为了简化，我将省略类型检查`return`语句的伪代码，因为它非常直接。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Checking Declarations
    and Updating the Symbol Table</samp>
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">类型检查声明和更新符号表</samp>
- en: Next, we’ll update how we type check function and variable declarations and
    what information we store in the symbol table. First, we’ll need to record the
    correct type for each entry in the symbol table; we can’t just assume that every
    variable, parameter, and return value is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Second, whenever we check for conflicting declarations, we’ll need to validate
    that the current and previous declarations have the same type. It’s not enough
    to check whether a variable was previously declared as a function or a function
    was previously declared with a different number of parameters; the types must
    be identical. For example, if a variable is declared as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and then redeclared as a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>,
    the type checker should throw an error. Third, when we type check an automatic
    variable, we’ll need to convert its initializer to the type of the variable, much
    like we convert the right-hand side of an assignment expression to the type of
    the left-hand side.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新如何类型检查函数和变量声明，并且更新我们在符号表中存储的信息。首先，我们需要为符号表中的每个条目记录正确的类型；我们不能仅仅假设每个变量、参数和返回值都是`int`类型。其次，每当我们检查是否存在冲突的声明时，我们需要验证当前声明和之前的声明是否具有相同的类型。仅仅检查一个变量之前是否被声明为一个函数，或者一个函数是否之前被声明为不同数量的参数是不够的；它们的类型必须完全相同。例如，如果一个变量被声明为`int`类型，之后又被重新声明为`long`类型，类型检查器应该抛出一个错误。第三，当我们进行自动变量的类型检查时，我们需要将它的初始化器转换为该变量的类型，就像我们将赋值表达式右侧的值转换为左侧类型一样。
- en: Finally, we’ll change how we represent static initializers in the symbol table.
    A static initializer, like a constant expression, can now be either an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>. [Listing 11-19](chapter11.xhtml#list11-19)
    gives the updated definition for static initializers.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将改变符号表中静态初始化器的表示方式。静态初始化器，像常量表达式一样，现在可以是`int`类型或`long`类型。[清单 11-19](chapter11.xhtml#list11-19)
    给出了静态初始化器的更新定义。
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-19: Static initializers
    in the symbol table</samp>'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-19：符号表中的静态初始化器</samp>
- en: This definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    may seem redundant, since it’s basically identical to the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    AST node defined in [Listing 11-2](chapter11.xhtml#list11-2), but they’ll diverge
    in later chapters. As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp> AST nodes,
    you should carefully choose what integer types in your implementation language
    you use to represent both initializers. It’s particularly important to make sure
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">LongInit</samp> can accommodate
    any signed 64-bit integer.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> 的定义可能看起来很冗余，因为它与
    [Listing 11-2](chapter11.xhtml#list11-2) 中定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    AST 节点基本相同，但它们将在后续章节中有所不同。像 <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp> AST 节点一样，你应该仔细选择在实现语言中使用什么整数类型来表示这两种初始化器。特别重要的是确保
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LongInit</samp> 能够容纳任何带符号的 64 位整数。
- en: 'You may need to perform type conversions when converting expressions to static
    initializers. For example, suppose a program contains the following declaration:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在将表达式转换为静态初始化器时，你可能需要执行类型转换。例如，假设一个程序包含以下声明：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The constant <samp class="SANS_TheSansMonoCd_W5Regular_11">100L</samp> will
    be parsed as a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp>
    in our AST. Since it’s being assigned to a static <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    we’ll need to cast it from a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> at compile time
    and store it as an <samp class="SANS_TheSansMonoCd_W5Regular_11">IntInit(100)</samp>
    in the symbol table. This sort of conversion is especially tricky when a variable
    with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is initialized
    with a long constant that’s too large to be represented in 32 bits, as in this
    declaration:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 常量 <samp class="SANS_TheSansMonoCd_W5Regular_11">100L</samp> 在我们的抽象语法树（AST）中将被解析为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp>。由于它被赋值给一个静态的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，我们需要在编译时将其从 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    强制转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，并将其作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">IntInit(100)</samp>
    存储在符号表中。这种类型的转换在使用一个太大以至于无法用 32 位表示的 long 常量初始化 int 类型变量时特别棘手，例如在下面的声明中：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: According to the implementation-defined behavior we specified earlier, we need
    to subtract 2^(32) from this value until it’s small enough to fit in an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. That results in –2,147,483,646,
    so the initial value we record in the symbol table should be <samp class="SANS_TheSansMonoCd_W5Regular_11">IntInit(-2147483646)</samp>.
    Ideally, you can use signed integer types that already have the right semantics
    for type conversions so you won’t have to mess with the binary representations
    of these constants yourself.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前指定的实现定义行为，我们需要从该值中减去 2^(32)，直到它足够小，可以适应 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    类型。这样得到的结果是 -2,147,483,646，所以我们在符号表中记录的初始值应该是 <samp class="SANS_TheSansMonoCd_W5Regular_11">IntInit(-2147483646)</samp>。理想情况下，你可以使用已经具有适当语义的带符号整数类型来进行类型转换，这样你就不必自己处理这些常量的二进制表示了。
- en: 'Here are a couple of tips to help you handle static initializers:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些提示可以帮助你处理静态初始化器：
- en: '**Make your constant type conversion code reusable.**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**使你的常量类型转换代码可重用。**'
- en: The type checker isn’t the only place where you’ll convert constants to a different
    type. In [Part III](part3.xhtml), you’ll implement constant folding in TACKY.
    The constant folding pass will evaluate constant expressions, including type conversions.
    You may want to structure your type conversion code as a separate module that
    you can reuse for constant folding later.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器并不是唯一一个会将常量转换为不同类型的地方。在 [Part III](part3.xhtml) 中，你将实现 TACKY 中的常量折叠。常量折叠阶段将会计算常量表达式，包括类型转换。你可能希望将你的类型转换代码构建为一个独立的模块，以便在之后的常量折叠过程中重用。
- en: '**Don’t call typecheck_exp on static initializers.**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要在静态初始化器上调用 typecheck_exp。**'
- en: Convert each static initializer directly to a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>,
    without calling <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>
    first. This will simplify things in later chapters, when <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>
    will transform expressions in more complex ways.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个静态初始化器直接转换为<samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>，而不首先调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>。这样做将简化后续章节中的内容，因为在后面的章节中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>会以更复杂的方式转换表达式。
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">TACKY 生成</samp>
- en: 'We’ll make a few changes to the TACKY AST in this chapter. First, we’ll add
    a type to each top-level <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>
    and represent each static variable’s initial value with our newly defined <samp
    class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> construct:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将对 TACKY AST 做出一些修改。首先，我们将为每个顶级的<samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>添加类型，并用我们新定义的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>构造表示每个静态变量的初始值：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We’ll also reuse the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    construct from the AST in [Listing 11-2](chapter11.xhtml#list11-2) to represent
    constants:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将重新使用来自[列表 11-2](chapter11.xhtml#list11-2)的<samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>构造来表示常量：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we’ll introduce a couple of new instructions to convert values between
    types:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将引入几个新指令，用于在不同类型之间转换值：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp> instructions convert from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    respectively. [Listing 11-20](chapter11.xhtml#list11-20) gives the complete updated
    TACKY IR. This listing uses <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    without defining them, since we’ve defined these three constructs already.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp>指令分别将<int>转换为<long>，并将<long>转换为<int>。[列表
    11-20](chapter11.xhtml#list11-20)给出了完整更新的 TACKY IR。本列表使用了<samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>，但没有定义它们，因为我们已经定义了这三个构造。
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-20: Adding support
    for long integers to TACKY</samp>'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 11-20：为 TACKY 添加对长整型的支持</samp>
- en: We’ll handle the changes to <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>
    by looking up type and initializer information in the symbol table during TACKY
    generation. If a static variable has a tentative definition in the symbol table,
    we’ll initialize it to <samp class="SANS_TheSansMonoCd_W5Regular_11">IntInit(0)</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">LongInit(0)</samp>, depending
    on its type.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在生成 TACKY 时，通过查找符号表中的类型和初始化信息来处理对<samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>的更改。如果符号表中有静态变量的暂定定义，我们将根据其类型初始化为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IntInit(0)</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">LongInit(0)</samp>。
- en: Handling constants is even easier; the logic is essentially unchanged from earlier
    chapters. We’ll convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp>
    AST node directly to a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp>,
    since they both use the same definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 处理常量就更加简单了；其逻辑与前面章节基本相同。我们将直接把<samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp>
    AST节点转换为TACKY的<samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp>，因为它们都使用相同的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">const</samp>定义。
- en: Recall that when we convert a logical <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> expression to TACKY,
    we explicitly assign 1 or 0 to the variable that holds the result of the expression.
    Since these logical expressions both have type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    we represent their results as <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt(1)</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt(0)</samp>.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，当我们将逻辑<samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>表达式转换为
    TACKY 时，我们显式地将1或0赋值给保存表达式结果的变量。由于这些逻辑表达式的类型都是<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，我们将它们的结果表示为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ConstInt(1)</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt(0)</samp>。
- en: '[Listing 11-21](chapter11.xhtml#list11-21) shows how to convert cast expressions
    to TACKY. We’ll use the type information we added in the previous pass to determine
    what type we’re casting from.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-21](chapter11.xhtml#list11-21)展示了如何将类型转换表达式转换为 TACKY。我们将使用在上一个步骤中添加的类型信息来确定我们要转换的类型。'
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-21: Converting a
    cast expression to TACKY</samp>'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 11-21：将类型转换表达式转换为 TACKY</samp>
- en: If the inner expression already has the type we want to cast it to, the cast
    has no effect; we emit TACKY to evaluate the inner expression but don’t do anything
    else ❶. Otherwise, we emit either a <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>
    instruction to cast an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> ❷ or a <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp>
    instruction to cast a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> ❸.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内部表达式已经具有我们要转换到的类型，则转换没有任何效果；我们发出 TACKY 来评估内部表达式，但不执行其他操作 ❶。否则，我们将发出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>指令，将<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> ❷，或者发出<samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp>指令，将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>转换为<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    ❸。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tracking the Types
    of Temporary Variables</samp>
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">跟踪临时变量的类型</samp>
- en: 'When we create the temporary variable <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    in [Listing 11-21](chapter11.xhtml#list11-21), we add it to the symbol table with
    the appropriate type. We need to do this for every temporary variable we create
    so that we can look up their types during assembly generation. The assembly generation
    stage will use this type information in two ways: to determine the operand size
    of each assembly instruction and to figure out how much stack space to allocate
    for each variable.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[列表 11-21](chapter11.xhtml#list11-21)中创建临时变量<samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>时，我们将其与适当的类型一起添加到符号表中。我们需要为每个创建的临时变量执行此操作，以便在汇编生成阶段可以查找它们的类型。汇编生成阶段将以两种方式使用此类型信息：确定每条汇编指令的操作数大小，以及确定为每个变量分配多少栈空间。
- en: Every temporary variable we add holds the result of an expression, so we can
    determine its type by checking the expression’s type annotation. Let’s take another
    look at [Listing 3-9](chapter3.xhtml#list3-9), which demonstrated how to convert
    a binary arithmetic expression to TACKY. [Listing 11-22](chapter11.xhtml#list11-22)
    demonstrates the same conversion, with changes from [Listing 3-9](chapter3.xhtml#list3-9)
    bolded.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的每个临时变量都保存一个表达式的结果，因此我们可以通过检查表达式的类型注解来确定其类型。让我们再看一遍[列表 3-9](chapter3.xhtml#list3-9)，它展示了如何将二元算术表达式转换为
    TACKY。[列表 11-22](chapter11.xhtml#list11-22)演示了相同的转换，其中来自[列表 3-9](chapter3.xhtml#list3-9)的更改已加粗。
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-22: Tracking temporary
    variable types when converting a binary expression to TACKY</samp>'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 11-22：将二元表达式转换为 TACKY 时跟踪临时变量的类型</samp>
- en: The main change here is adding <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    to the symbol table. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    holds the result of expression <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>,
    we look up <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>’s type annotation
    to figure out <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>’s type.
    Like every temporary variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    is a local, automatic variable, so we’ll give it the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalAttr</samp>
    attribute in the symbol table.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要变化是将 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> 添加到符号表中。由于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> 保存了表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>
    的结果，我们查找 <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp> 的类型注释以确定 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> 的类型。像所有临时变量一样，<samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    是一个局部自动变量，因此我们将在符号表中给它添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalAttr</samp>
    属性。
- en: Let’s refactor this into a helper function, shown in [Listing 11-23](chapter11.xhtml#list11-23).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其重构为一个辅助函数，如 [列表 11-23](chapter11.xhtml#list11-23) 所示。
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-23: A helper function
    for generating TACKY variables</samp>'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 11-23：用于生成 TACKY 变量的辅助函数</samp>
- en: From now on, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">make_tacky_variable</samp>
    whenever we generate a new temporary variable in TACKY.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将在生成 TACKY 中的临时变量时使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">make_tacky_variable</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating Extra
    Return Instructions</samp>
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">生成额外的返回指令</samp>
- en: In [Chapter 5](chapter5.xhtml), I mentioned that we add an extra <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction to the end of each TACKY function, in case not every execution path
    in the original C function reaches a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement. This extra instruction can always return <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt(0)</samp>,
    even when the function’s return type isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    When we return from <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>,
    this is the correct return type. When we return from any other function that’s
    missing an explicit <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement, the return value is undefined. We still need to return control to the
    caller, but we aren’t obligated to return any particular value, so it doesn’t
    matter if we get the type wrong.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](chapter5.xhtml)中，我提到过，我们在每个 TACKY 函数的末尾添加了一条额外的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    指令，以防原始 C 函数中的每个执行路径都没有到达 <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    语句。这条额外的指令总是返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt(0)</samp>，即使函数的返回类型不是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。当我们从 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    返回时，这是正确的返回类型。当我们从任何其他没有显式 <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    语句的函数返回时，返回值是未定义的。我们仍然需要将控制权返回给调用者，但我们没有义务返回任何特定的值，因此如果我们把类型弄错了也没关系。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">汇编生成</samp>
- en: We’ll make several changes to the assembly AST in this chapter. [Listing 11-24](chapter11.xhtml#list11-24)
    gives the complete definition, with changes bolded.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将对汇编 AST 做出几处修改。[列表 11-24](chapter11.xhtml#list11-24) 给出了完整的定义，修改部分已加粗。
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-24: The assembly
    AST with support for quadword operands and 8-byte static variables</samp>'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 11-24：支持四字操作数和 8 字节静态变量的汇编
    AST</samp>
- en: 'The biggest change is tagging most instructions with the type of their operands.
    That allows us to choose the correct suffix for each instruction during assembly
    emission. We’ll also add a type to <samp class="SANS_TheSansMonoCd_W5Regular_11">Cdq</samp>,
    since the 32-bit version of <samp class="SANS_TheSansMonoCd_W5Regular_11">Cdq</samp>
    extends EAX into EDX and the 64-bit version extends RAX into RDX. There are just
    three instructions that take an operand but don’t need a type: <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCC</samp>,
    which takes only byte-size operands; <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp>,
    which always pushes quadwords; and the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Movsx</samp>
    instruction, which we’ll cover in a moment.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的变化是为大多数指令标记其操作数的类型。这使得我们可以在汇编发射过程中为每条指令选择正确的后缀。我们还会为<samp class="SANS_TheSansMonoCd_W5Regular_11">Cdq</samp>添加一个类型，因为32位版本的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Cdq</samp>将EAX扩展到EDX，而64位版本将RAX扩展到RDX。只有三条指令需要操作数，但不需要类型：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetCC</samp>，它只接受字节大小的操作数；<samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp>，它总是压入四字（quadword）；以及新的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Movsx</samp>指令，我们稍后会讨论。
- en: Instead of reusing the source-level type we defined earlier, we’ll define a
    new <samp class="SANS_TheSansMonoCd_W5Regular_11">assembly_type</samp> construct.
    This will simplify working with assembly types as we introduce more C types in
    later chapters. For example, we’ll add unsigned integers in [Chapter 12](chapter12.xhtml),
    but assembly doesn’t distinguish between signed and unsigned integers.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不再复用之前定义的源级类型，而是定义一个新的<samp class="SANS_TheSansMonoCd_W5Regular_11">assembly_type</samp>结构。这将简化汇编类型的工作，因为我们将在后续章节中引入更多的C类型。例如，我们将在[第12章](chapter12.xhtml)中添加无符号整数，但汇编语言并不区分有符号和无符号整数。
- en: During assembly generation, we’ll figure out each instruction’s type based on
    the type of its operands. For example, we’ll convert the TACKY instruction
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成汇编时，我们将根据操作数的类型确定每条指令的类型。例如，我们将转换TACKY指令
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'to these assembly instructions:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些汇编指令如下：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Since the first operand is a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp>,
    we know that the resulting <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> instructions should
    use longword operands. We can assume that the second operand and the destination
    have the same type as the first operand, since we inserted the appropriate type
    conversion instructions during TACKY generation. If an operand is a variable instead
    of a constant, we’ll look up its type in the symbol table.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一个操作数是<samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp>，我们知道生成的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>指令应该使用长字（longword）操作数。我们可以假设第二个操作数和目标与第一个操作数具有相同的类型，因为在TACKY生成过程中我们已经插入了适当的类型转换指令。如果操作数是变量而不是常量，我们将查找其在符号表中的类型。
- en: We’ll also figure out how to pass stack arguments based on their type. [Listing
    11-25](chapter11.xhtml#list11-25) reproduces the relevant part of <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_function_call</samp>,
    which we defined back in [Listing 9-31](chapter9.xhtml#list9-31), with this change
    bolded.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将弄清楚如何根据参数的类型传递堆栈参数。[列表 11-25](chapter11.xhtml#list11-25)重现了<samp class="SANS_TheSansMonoCd_W5Regular_11">convert_function_call</samp>的相关部分，该部分我们在[列表
    9-31](chapter9.xhtml#list9-31)中定义过，并且已将此次更改加粗。
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-25: Passing quadwords
    on the stack in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">convert_function_call</samp>'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 11-25：在</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">convert_function_call</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">中传递四字（quadword）数据</samp>
- en: 'In [Chapter 9](chapter9.xhtml), we learned that we could run into trouble if
    we used an 8-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp> instruction
    to push a 4-byte operand from memory onto the stack. To work around this issue,
    we emit two instructions to push a 4-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    onto the stack: we copy it into EAX, then push RAX. An 8-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    doesn’t require this workaround; we pass it on the stack with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp>
    instruction, the same way we pass an immediate value.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 9 章](chapter9.xhtml)中，我们学到，如果我们使用一个 8 字节的 <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp>
    指令将一个 4 字节的操作数从内存推送到栈上，可能会遇到问题。为了解决这个问题，我们发出两个指令来将一个 4 字节的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    推送到栈上：我们将其复制到 EAX 寄存器中，然后推送 RAX 寄存器。8 字节的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    不需要此解决方法；我们通过一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp> 指令将其传递到栈上，方式与传递立即数值相同。
- en: To handle conversions from <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, we’ll use the sign
    extension instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp>.
    At the moment, this instruction doesn’t need type information, since its source
    must be an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and its destination
    must be a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>. We’ll convert
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理从 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    的转换，我们将使用符号扩展指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp>。目前，这个指令不需要类型信息，因为它的源操作数必须是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型，目标操作数必须是 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    类型。我们将转换
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'to:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 到：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To truncate a value, we just move its lowest 4 bytes into the destination using
    a 4-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction.
    We’ll convert
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了截断一个值，我们只需使用 4 字节的 <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    指令将其最低的 4 字节移动到目标位置。我们将转换
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'to:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到：
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We’ve also tweaked the <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>
    construct:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还调整了 <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> 结构：
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We hold onto the <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    construct from TACKY, so we know whether to initialize 4 or 8 bytes for each static
    variable. We add an <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>
    field too, since we’ll need to specify each static variable’s alignment in assembly.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保留了 TACKY 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    结构，因此我们知道是否为每个静态变量初始化 4 或 8 字节。我们还添加了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp>
    字段，因为我们需要在汇编中指定每个静态变量的对齐方式。
- en: 'Finally, we’ve removed the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeallocateStack</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> instructions
    from the assembly AST. These instructions were just placeholders for quadword
    addition and subtraction, which we can now represent with ordinary <samp class="SANS_TheSansMonoCd_W5Regular_11">addq</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">subq</samp> instructions. Since
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DeallocateStack</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> represented adding
    to and subtracting from RSP, we’ve also added the RSP register to the assembly
    AST so we can use it in normal instructions. In earlier chapters, we maintained
    the stack alignment before function calls with the instruction:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已从汇编 AST 中移除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">DeallocateStack</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> 指令。这些指令只是四字节加法和减法的占位符，现在我们可以通过普通的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">addq</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">subq</samp>
    指令表示它们。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">DeallocateStack</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> 代表的是对 RSP
    的加减操作，我们还将 RSP 寄存器添加到汇编 AST 中，以便在正常的指令中使用它。在前面的章节中，我们通过以下指令在函数调用前保持栈对齐：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now we’ll use this instruction instead:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将改用以下指令：
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Similarly, instead of
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，不再使用
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: we’ll use
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用
- en: '[PRE49]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: to restore the stack pointer after function calls.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在函数调用后恢复栈指针。
- en: '[Tables 11-1](chapter11.xhtml#tab11-1) through [11-4](chapter11.xhtml#tab11-4)
    summarize this chapter’s updates to the conversion from TACKY to assembly. New
    constructs and changes to the conversions for existing constructs are bolded.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 11-1](chapter11.xhtml#tab11-1) 至 [11-4](chapter11.xhtml#tab11-4) 总结了本章对从
    TACKY 转换到汇编的更新。新增的结构和对现有结构的转换更改以**粗体**显示。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 11-1:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Top-Level TACKY Constructs to Assembly</samp>
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, global, params,
    instructions)</samp> |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '|'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable(name, global,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">t,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">init)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable(name, global,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><alignment of t></samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">init)</samp>
    |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 11-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><val
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, val, Reg(AX)) Ret</samp>
    |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Not, src, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src
    type></samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(0),
    src) Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><dst type></samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(0),
    dst)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: SetCC(E, dst)</samp> |
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(unary_operator, src,
    dst)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src, dst) Unary(unary_operator,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src type></samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dst)</samp> |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Divide, src1, src2,
    dst)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src1, Reg(AX)) Cdq(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1 type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Idiv(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1 type></samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src2)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Idiv(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1 type></samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src2)
- en: Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1 type></samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(AX),
    dst)</samp> |
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1 type></samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(AX),
    dst)</samp> |
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Remainder, src1, src2,
    dst)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src1, Reg(AX)) Cdq(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1 type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Remainder, src1, src2,
    dst)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src1, Reg(AX)) Cdq(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1 type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)'
- en: Idiv(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1 type></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">, src2)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Idiv(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1 type></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">, src2)
- en: Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1 type></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">, Reg(DX), dst)</samp> |
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1 type></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">, Reg(DX), dst)</samp> |
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(arithmetic_operator,
    src1, src2, dst)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1 type></samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src1, dst) Binary(arithmetic_operator,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1 type>,</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">src2, dst)</samp> |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(arithmetic_operator,
    src1, src2, dst)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1 type></samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src1, dst) Binary(arithmetic_operator,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1 type>,</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">src2, dst)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(relational_operator,
    src1, src2, dst)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1 type></samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src2, src1) Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><dst
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Imm(0), dst)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(relational_operator,
    src1, src2, dst)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src1 type></samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src2, src1) Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><dst
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Imm(0), dst)'
- en: SetCC(relational_operator, dst)</samp> |
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: SetCC(relational_operator, dst)</samp> |
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero(condition, target)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><condition
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Imm(0), condition)
    JmpCC(E, target)</samp> |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero(condition, target)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><condition
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Imm(0), condition)
    JmpCC(E, target)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero(condition, target)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><condition
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Imm(0), condition)
    JmpCC(NE, target)</samp> |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero(condition, target)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><condition
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Imm(0), condition)
    JmpCC(NE, target)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy(src, dst)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src, dst)</samp> |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall(fun_name, args, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><fix stack alignment>
    <set up arguments></samp>'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Call(fun_name)</samp>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><deallocate arguments/padding></samp>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><dst
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Reg(AX), dst)</samp>
    |
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SignExtend(src, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Movsx(src, dst)</samp> |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Truncate(src, dst)</samp> |
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(Longword, src, dst)</samp> |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 11-3:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Operands to Assembly</samp>
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operand</samp> |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ConstInt(int)</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp>
    |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Constant(ConstLong(int))</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Imm(int)</samp> |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 11-4:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Types to Assembly</samp>
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp> |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Int</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Longword</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">4</samp> |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Long</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Quadword</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">8</samp> |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: In [Table 11-3](chapter11.xhtml#tab11-3), we convert both types of TACKY constants
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm</samp> operands. In assembly,
    there’s no distinction between 4-byte and 8-byte immediate values. The assembler
    infers how large an immediate value should be based on the operand size of the
    instruction where it appears.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 11-4](chapter11.xhtml#tab11-4) gives the conversion from source-level
    to assembly types, as well as each type’s alignment. Note that this conversion
    fits into the whole compiler pass a bit differently than the conversions in [Tables
    11-1](chapter11.xhtml#tab11-1) through [11-3](chapter11.xhtml#tab11-3), because
    when we traverse a TACKY program, we won’t encounter <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    AST nodes that we can convert directly to <samp class="SANS_TheSansMonoCd_W5Regular_11">assembly_type</samp>
    nodes in the assembly program. As we’ve seen, we typically need to infer a TACKY
    instruction’s operand type before we can convert it to an assembly type. The one
    TACKY construct with an explicit type is <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>,
    but we don’t need to convert this type to an assembly type; we only need to calculate
    its alignment. We’ll use the conversion shown in [Table 11-4](chapter11.xhtml#tab11-4)
    again in the next step of this compiler pass, where we’ll construct a new symbol
    table to track assembly types.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tracking Assembly
    Types in the Backend Symbol Table</samp>
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After converting the TACKY program to assembly, we’ll convert the symbol table
    to a form that’s better suited to the remaining compiler passes. This new symbol
    table will store variables’ assembly types, rather than their source types. It
    will also store a handful of other properties that we’ll need to look up in the
    pseudoregister replacement, instruction fix-up, and code emission passes. I’ll
    call this new symbol table the *backend symbol table*. I’ll call the existing
    one either the *frontend symbol table* or just the *symbol table*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The backend symbol table maps each identifier to an <samp class="SANS_TheSansMonoCd_W5Regular_11">asm_symtab_entry</samp>
    construct, defined in [Listing 11-26](chapter11.xhtml#list11-26).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-26: The definition
    of an entry in the backend symbol table</samp>'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjEntry</samp> to represent
    variables (and, in later chapters, constants). We’ll track each object’s assembly
    type and whether it has static storage duration. <samp class="SANS_TheSansMonoCd_W5Regular_11">FunEntry</samp>
    represents functions. We don’t need to track the types of functions—which is just
    as well, since <samp class="SANS_TheSansMonoCd_W5Regular_11">assembly_type</samp>
    can’t represent function types—but we do track whether they’re defined in the
    current translation unit. If you’re tracking each function’s stack frame size
    in the symbol table, add an extra <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_frame_size</samp>
    field to the <samp class="SANS_TheSansMonoCd_W5Regular_11">FunEntry</samp> constructor.
    I recommend making the backend symbol table a global variable or singleton, just
    like the existing frontend symbol table.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: At the very end of the TACKY-to-assembly conversion pass, you should iterate
    over the frontend symbol table and convert each entry to an entry in the backend
    symbol table. This process is simple enough that I won’t provide the pseudocode
    for it. You’ll also need to update any spots in the pseudoregister replacement,
    instruction fix-up, and code emission passes that refer to the frontend symbol
    table and have them use the backend symbol table instead.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Longword
    and Quadword Pseudoregisters</samp>'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'The pseudoregister replacement pass requires a couple of changes. First, we’ll
    extend it to replace pseudoregisters in the new <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp>
    instruction. Second, whenever we assign a stack address to a pseudoregister, we’ll
    look up the pseudoregister’s type in the backend symbol table to determine how
    much space to allocate. If it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>,
    we’ll allocate 8 bytes; if it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>,
    we’ll allocate 4 bytes, as before. Finally, we’ll make sure that the address of
    each <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> pseudoregister
    is 8-byte aligned on the stack. Consider the following fragment of assembly:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Suppose we look up the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    in the backend symbol table and see that it’s 4 bytes. We’ll assign it to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>, as usual. Next, we’ll
    look up <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp> and see that
    it’s 8 bytes. We could assign it to <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>,
    which is 8 bytes below <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>.
    But then <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp> would be misaligned,
    since its address wouldn’t be a multiple of 8 bytes. (Remember that the address
    in RBP is always 16-byte aligned.) To maintain the correct alignment, we’ll round
    down to the next multiple of 8 and store <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>
    at <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp> instead. Alignment
    requirements are part of the System V ABI; if you ignore them, your code may not
    interact correctly with code in other translation units.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up Instructions</samp>
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll make several updates to the instruction fix-up pass in this chapter. First,
    we need to specify operand sizes for all the instructions in our existing rewrite
    rules. These should always have the same operand size as the original instruction
    being rewritten.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll rewrite the <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp>
    instruction. It can’t use a memory address as a destination or an immediate value
    as a source. If both operands to <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp>
    are invalid, we’ll need to use both R10 and R11 to fix them. For example, we’ll
    rewrite
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'to:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: It’s important to use the right operand size for each <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction in this rewrite rule. Since the source operand of <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp>
    is 4 bytes, we specify a longword operand size when moving that operand into a
    register. Since the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp>
    is 8 bytes, we specify a quadword operand size when we move the result to its
    final memory location.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The quadword versions of our three binary arithmetic instructions (<samp class="SANS_TheSansMonoCd_W5Regular_11">addq</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">imulq</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">subq</samp>)
    can’t handle immediate values that don’t fit into an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    and neither can <samp class="SANS_TheSansMonoCd_W5Regular_11">cmpq</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp>. If the source of any of
    these instructions is a constant outside the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    we’ll need to copy it into R10 before we can use it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">movq</samp> instruction can
    move these very large immediate values into registers, but not directly into memory,
    so
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'should be rewritten as:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The assembler permits an immediate value in addq, imulq, subq, cmpq, or pushq
    only if it can be represented as a* signed *32-bit integer. That’s because these
    instructions all sign extend their immediate operands from 32 to 64 bits. If an
    immediate value can be represented in 32 bits only as an* unsigned *integer—which
    implies that its upper bit is set—sign extending it will change its value. For
    more details, see this Stack Overflow question:* [https://<wbr>stackoverflow<wbr>.com<wbr>/questions<wbr>/64289590<wbr>/integer<wbr>-overflow<wbr>-in<wbr>-gas](https://stackoverflow.com/questions/64289590/integer-overflow-in-gas)*.*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also fix how we allocate stack space at the start of each function. Instead
    of adding <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack(bytes)</samp>
    to each function to allocate space on the stack, we’ll add the following instruction,
    which does the same thing:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We’ll add one last rewrite rule to placate the assembler, although it isn’t
    strictly necessary. Remember that we convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp>
    TACKY instruction to a 4-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>,
    which means we can generate <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    instructions that move 8-byte immediate values to 4-byte destinations:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Since <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> can’t use 8-byte
    immediate values, the assembler automatically truncates these values to 32 bits.
    When it processes the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">movl
    $4294967299, %r10d</samp>, for example, it will convert the immediate value <samp
    class="SANS_TheSansMonoCd_W5Regular_11">4294967299</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>.
    The GNU assembler issues a warning when it performs this conversion, although
    the LLVM assembler doesn’t. To avoid these warnings, we’ll truncate 8-byte immediate
    values in <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instructions
    ourselves. That means we’ll rewrite the previous instruction as:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Assembler warnings aside, your assembly programs will still work even if you
    don’t include this rewrite rule.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our final task is to extend the code emission stage. We’ll add the appropriate
    suffix to every instruction, emit the correct alignment and initial value for
    static variables, and handle the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Movsx</samp>
    instruction. Whenever an instruction uses a register, we’ll emit the appropriate
    register name for that instruction’s operand size.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Instructions with 4-byte operands have an <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>
    suffix, for longword, and instructions with 8-byte operands have a <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>
    suffix, for quadword, with one exception: the 8-byte version of <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>
    has a completely different mnemonic, <samp class="SANS_TheSansMonoCd_W5Regular_11">cqo</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Movsx</samp> instruction takes
    suffixes for both its source and destination operand sizes. For example, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">movslq</samp> sign extends a longword
    to a quadword. For now, we’ll always emit this instruction with an <samp class="SANS_TheSansMonoCd_W5Regular_11">lq</samp>
    suffix; we’ll need more suffixes as we add more assembly types in later chapters.
    (You may also see this instruction written as <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp>
    when it’s possible for the assembler to infer the size of both operands. For example,
    the assembler will accept the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx
    %r10d, %r11</samp>, since it can infer the source and destination sizes from the
    register names.)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[Tables 11-5](chapter11.xhtml#tab11-5) through [11-10](chapter11.xhtml#tab11-10)
    summarize this chapter’s updates to the code emission pass. New constructs and
    changes to existing constructs are bolded.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 11-5:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Top-Level Assembly Constructs</samp>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |  | <samp class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable(name, global,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">alignment</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">init)</samp> | <samp class="SANS_Futura_Std_Book_11">Initialized
    to zero</samp> |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: '[PRE60]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '|'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Initialized to nonzero value</samp>
    |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
- en: '[PRE61]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '|'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Book_11">Alignment directive</samp> | <samp
    class="SANS_Futura_Std_Book_11">Linux only</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><alignment></samp> |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">macOS or Linux</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">.balign</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><alignment></samp> |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 11-6:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Static Initializers</samp>
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Static initializer</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">IntInit(0)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">.zero
    4</samp> |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">IntInit(i)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">.long</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><i></samp> |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">LongInit(0)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">.zero</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">8</samp> |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">LongInit(i)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">.quad</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><i></samp> |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 11-7:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">t</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">, src, dst)</samp> |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
- en: '[PRE62]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '|'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Movsx(src, dst)</samp> |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
- en: '[PRE63]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '|'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(unary_operator,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">t</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,
    operand)</samp> |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
- en: '[PRE64]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '|'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(binary_operator,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">t</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,
    src, dst)</samp> |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: '[PRE65]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '|'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Idiv(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">t</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">, operand)</samp> |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
- en: '[PRE66]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '|'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Cdq(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Longword</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
- en: '[PRE67]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '|'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Cdq(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Quadword</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
- en: '[PRE68]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '|'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">t</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">, operand, operand)</samp> |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
- en: '[PRE69]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '|'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 11-8:</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    Names for Assembly Operators</samp>
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operator</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Instruction name</samp> |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Neg</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">neg</samp>
    |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">not</samp>
    |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Add</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">add</samp>
    |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Sub</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sub</samp>
    |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Mult</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">imul</samp>
    |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 11-9:</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    Suffixes for Assembly Types</samp>
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Instruction
    suffix</samp> |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Longword</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">l</samp>
    |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Quadword</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">q</samp>
    |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 11-10:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(SP)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rsp</samp>
    |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
- en: '[Table 11-6](chapter11.xhtml#tab11-6) shows how to print out the <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    constructs representing static variable initializers. [Table 11-8](chapter11.xhtml#tab11-8)
    shows the mapping from unary and binary operators to instruction names without
    suffixes; the suffix now depends on the instruction’s type (as shown in [Table
    11-9](chapter11.xhtml#tab11-9)). Aside from the suffix, these instruction names
    are the same as in earlier chapters.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve updated the code emission stage, you’re ready to test out your compiler.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your compiler has a type system now! In this chapter, you annotated the AST
    with type information, used the symbol table to track type information through
    multiple compiler stages, and added support for multiple operand sizes during
    assembly generation. Long integers aren’t the flashiest language feature, so it
    might feel like you’ve done a lot of work and don’t have much to show for it.
    But the infrastructure you created in this chapter is the basis for everything
    you’ll do in the rest of [Part II](part2.xhtml). In the next chapter, you’ll build
    on that work by implementing unsigned integers.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
