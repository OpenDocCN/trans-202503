["```\nPOP RAX  ; pop the next item on the attacker-controlled stack into RAX\n\nRET      ; transfer control to the address contained in the next stack item\n```", "```\n   private int gadgetCount = 0;         // Counts the number of gadgets\n\n   private BufferedWriter outFile;      // Output file\n\n// List of \"interesting\" instructions\n\n   private List<String> usefulInstructions = Arrays.asList(\n\n       \"NOP\", \"POP\", \"PUSH\", \"MOV\", \"ADD\", \"SUB\", \"MUL\", \"DIV\", \"XOR\");\n\n// List of \"interesting\" instructions that don’t have operands\n\n   private List<String> require0Operands = Arrays.asList(\"NOP\");\n\n// List of \"interesting\" instructions that have one operand\n\n   private List<String> require1RegOperand = Arrays.asList(\"POP\", \"PUSH\");\n\n// List of \"interesting\" instructions for which we want the first\n\n// parameter to be a register\n\n   private List<String> requireFirstRegOperand = Arrays.asList(\n\n        \"MOV\", \"ADD\", \"SUB\", \"MUL\", \"DIV\", \"XOR\");\n\n// List of \"start\" instructions that have ZERO operands\n\n   private List<String> startInstr0Params = Arrays.asList(\"RET\");\n\n// List of \"start\" instructions that have ONE register operand\n\n   private List<String> startInstr1RegParam = Arrays.asList(\"JMP\", \"CALL\");\n```", "```\n/**\n\n * TODO: Provide class-level documentation that describes what this\n\n * analyzer does.\n\n */\n```", "```\n/**\n\n * This analyzer searches through a binary for ROP gadgets.\n\n * The address and contents of each gadget are written to a\n\n * file called inputfilename_gadgets.txt in the user’s home directory.\n\n */\n```", "```\n// TODO: Name the analyzer and give it a description.\n\npublic SimpleROPAnalyzer() {\n\n   super(\"My Analyzer\",\n\n         \"Analyzer description goes here\",\n\n          AnalyzerType.BYTE_ANALYZER);\n\n}\n```", "```\npublic SimpleROPAnalyzer() {\n\n   super(\"SimpleROP\",\n\n         \"Search a binary for ROP gadgets\",\n\n          AnalyzerType.INSTRUCTION_ANALYZER);\n\n}\n```", "```\npublic boolean getDefaultEnablement(Program program) {\n\n   // TODO: Return true if analyzer should be enabled by default\n\n   return false;\n\n}\n```", "```\npublic boolean canAnalyze(Program program) {\n\n   // TODO: Examine 'program' to determine of this analyzer\n\n   // should analyze it.\n\n   // Return true if it can.\n\n   return false;\n\n}\n```", "```\npublic boolean canAnalyze(Program program) {\n\n   return true;\n\n}\n```", "```\npublic void registerOptions(Options options, Program program) {\n\n   // TODO: If this analyzer has custom options, register them here\n\n   options.registerOption(\"Option name goes here\", false, null,\n\n                          \"Option description goes here\");\n\n}\n```", "```\npublic void registerOptions(Options options, Program program) {\n\n}\n```", "```\npublic boolean added(Program program, AddressSetView set, TaskMonitor\n\n                     monitor, MessageLog log) throws CancelledException {\n\n   // TODO: Perform analysis when things get added to the 'program'.\n\n   // Return true if the analysis succeeded.\n\n   return false;\n\n}\n```", "```\n  //*************************************************************************\n\n  //  This method is called when the analyzer is invoked.\n\n  //*************************************************************************\n\n➊ public boolean added(Program program, AddressSetView set, TaskMonitor\n\n                       monitor, MessageLog log) throws CancelledException {\n\n      gadgetCount = 0;\n\n      String outFileName = System.getProperty(\"user.home\") + \"/\" +\n\n                           program.getName() + \"_gadgets.txt\";\n\n      monitor.setMessage(\"Searching for ROP Gadgets\");\n\n      try {\n\n         outFile = new BufferedWriter(new FileWriter(outFileName));\n\n      } catch (IOException e) {/* pass */}\n\n      // iterate through each instruction in the binary\n\n      Listing code = program.getListing();\n\n      InstructionIterator instructions = code.getInstructions(set, true);\n\n    ➋ while (instructions.hasNext() && !monitor.isCancelled()) {\n\n         Instruction inst = instructions.next();\n\n      ➌ if (isStartInstruction(inst)) {\n\n            // We found a \"start\" instruction.  This will be the last\n\n            // instruction in the potential ROP gadget so we will try to\n\n            // build the gadget from here\n\n            ArrayList<Instruction> gadgetInstructions =\n\n               new ArrayList<Instruction>();\n\n            gadgetInstructions.add(inst);\n\n            Instruction prevInstr = inst.getPrevious();\n\n         ➍ buildGadget(program, monitor, prevInstr, gadgetInstructions);\n\n         }\n\n      }\n\n      try {\n\n         outFile.close();\n\n      } catch (IOException e) {/* pass */}\n\n      return true;\n\n   }\n\n   //*************************************************************************\n\n   //  This method is called recursively until it finds an instruction that\n\n   //  we don't want in the ROP gadget.\n\n   //*************************************************************************\n\n   private void buildGadget(Program program, TaskMonitor monitor,\n\n                            Instruction inst,\n\n                            ArrayList<Instruction> gadgetInstructions) {\n\n      if (inst == null || !isUsefulInstruction(inst)➎ ||\n\n         monitor.isCancelled()) {\n\n         return;\n\n      }\n\n      gadgetInstructions.add(inst);\n\n   ➏ buildGadget(program, monitor, inst.getPrevious()➐, gadgetInstructions);\n\n      gadgetCount += 1;\n\n ➑ for (int ii = gadgetInstructions.size() - 1; ii >= 0; ii--) {\n\n         try {\n\n            Instruction insn = gadgetInstructions.get(ii);\n\n            if (ii == gadgetInstructions.size() - 1) {\n\n               outFile.write(insn.getMinAddress() + \";\");\n\n            }\n\n            outFile.write(insn.toString() + \";\");\n\n         } catch (IOException e) {/* pass */}\n\n      }\n\n      try {\n\n         outFile.write(\"\\n\");\n\n      } catch (IOException e) {/* pass */}\n\n      // Report count to monitor every 100th gadget\n\n      if (gadgetCount % 100 == 0) {\n\n         monitor.setMessage(\"Found \" + gadgetCount + \" ROP Gadgets\");\n\n      }\n\n      gadgetInstructions.remove(gadgetInstructions.size() - 1);\n\n   }\n\n   //*************************************************************************\n\n   //  This method determines if an instruction is useful in the context of\n\n   //  a ROP gadget\n\n   //*************************************************************************\n\n   private boolean isUsefulInstruction(Instruction inst) {\n\n      if (!usefulInstructions.contains(inst.getMnemonicString())) {\n\n         return false;\n\n      }\n\n      if (require0Operands.contains(inst.getMnemonicString())) {\n\n         return true;\n\n      }\n\n      if (require1RegOperand.contains(inst.getMnemonicString()) &&\n\n         inst.getNumOperands() == 1) {\n\n         Object[] opObjects0 = inst.getOpObjects(0);\n\n         for (int ii = 0; ii < opObjects0.length; ii++) {\n\n            if (opObjects0[ii] instanceof Register) {\n\n               return true;\n\n            }\n\n         }\n\n      }\n\n      if (requireFirstRegOperand.contains(inst.getMnemonicString()) &&\n\n         inst.getNumOperands() >= 1) {\n\n         Object[] opObjects0 = inst.getOpObjects(0);\n\n         for (int ii = 0; ii < opObjects0.length; ii++) {\n\n            if (opObjects0[ii] instanceof Register) {\n\n               return true;\n\n            }\n\n         }\n\n      }\n\n      return false;\n\n   }\n\n   //*************************************************************************\n\n   //  This method determines if an instruction is the \"start\" of a\n\n   //  potential ROP gadget\n\n   //*************************************************************************\n\n private boolean isStartInstruction(Instruction inst) {\n\n      if (startInstr0Params.contains(inst.getMnemonicString())) {\n\n         return true;\n\n      }\n\n      if (startInstr1RegParam.contains(inst.getMnemonicString()) &&\n\n         inst.getNumOperands() >= 1) {\n\n         Object[] opObjects0 = inst.getOpObjects(0);\n\n         for (int ii = 0; ii < opObjects0.length; ii++) {\n\n            if (opObjects0[ii] instanceof Register) {\n\n               return true;\n\n            }\n\n         }\n\n      }\n\n      return false;\n\n   }\n```", "```\n    00400412;ADD RSP,0x8;RET;\n\n    004004ce;NOP;RET;\n\n    00400679;ADD RSP,0x8;POP RBX;POP RBP;POP R12;POP R13;POP R14;POP R15;RET;\n\n    0040067d;POP RBX;POP RBP;POP R12;POP R13;POP R14;POP R15;RET;\n\n    0040067e;POP RBP;POP R12;POP R13;POP R14;POP R15;RET;\n\n    0040067f;POP R12;POP R13;POP R14;POP R15;RET;\n\n    00400681;POP R13;POP R14;POP R15;RET;\n\n    00400683;POP R14;POP R15;RET;\n\n    00400685;POP R15;RET;\n\n    00400a8b;POP RBP;MOV EDI,0x6babd0;JMP RAX;\n\n    00400a8c;MOV EDI,0x6babd0;JMP RAX;\n\n    00400a98;POP RBP;RET;\n    ```"]