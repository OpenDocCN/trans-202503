- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linear Memory
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll examine what linear memory is, how to use it to share
    data between JavaScript and WebAssembly code, and how to create it from within
    JavaScript. We’ll also update linear memory from WebAssembly and then use those
    updates from within the JavaScript code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: One common task in computer games is collision detection, detecting and appropriately
    reacting to two objects touching. The number of computations required grows exponentially
    as you add objects. Collision detection is a great candidate for building in WebAssembly.
    In this chapter, we’ll create a list of circles defined randomly in the JavaScript,
    and then add that circle data to the WebAssembly linear memory. Then we’ll use
    that data to determine whether any of those circles collide.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly shines best when you can pass it tons of data that requires significant
    processing and let it run. A WebAssembly module can perform math faster than JavaScript.
    However, each interaction between JavaScript and the WebAssembly module has an
    associated cost. You can use linear memory to load significant amounts of data
    in JavaScript for processing within a WebAssembly module.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Linear Memory in WebAssembly
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linear memory acts as one giant array of data that can be shared between WebAssembly
    and JavaScript. If you’re familiar with low-level programming, linear memory is
    similar to heap memory in native applications. If you’re familiar with JavaScript,
    think of it as one giant `ArrayBuffer` object. Languages like C and C++ create
    local variables by allocating memory on the computer’s stack. The stack-allocated
    local variables are released from memory as soon as the function finishes executing.
    This efficient process means that allocating and deallocating data on the stack
    is as simple as incrementing and decrementing a stack pointer. Your application
    simply increments the stack pointer, and voilà, you have a new allocated variable,
    as depicted in [Figure 6-1](#figure6-1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![f06001](Images/f06001.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-1: The stack pointer'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The stack works great for local variables. However, one limitation in WAT is
    that local variables that use the stack can only be one of four types, all of
    which are numeric. Sometimes, you might require more sophisticated data structures,
    such as strings, structures, arrays, and objects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Allocation commands, like `malloc` in C and `new`in C++ and JavaScript, allocate
    onto the heap, and the memory management libraries included with those languages
    must look for a free section of memory on the heap large enough to hold the required
    block of memory. Over time that might result in memory fragmentation, where allocated
    memory segments are separated by unallocated memory, as illustrated in [Figure
    6-2](#figure6-2).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'WebAssembly linear memory is allocated in large chunks called *pages*, which,
    once allocated, cannot be deallocated. WebAssembly memory is also a bit more like
    assembly language memory management: once you’ve allocated your chosen number
    of pages to your WebAssembly module, you, as the programmer, must keep track of
    what you’re using memory for and where it is. In the next few sections, we’ll
    look more closely at how to use linear memory by exploring memory pages.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 线性内存以大块叫做*页面*的形式分配，一旦分配后就无法释放。WebAssembly 内存的管理方式也有点像汇编语言的内存管理：一旦您为
    WebAssembly 模块分配了所选数量的页面，您作为程序员必须跟踪您在使用内存时的用途以及它的位置。在接下来的几节中，我们将更仔细地研究如何通过探索内存页面来使用线性内存。
- en: '![f06002](Images/f06002.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![f06002](Images/f06002.png)'
- en: 'Figure 6-2: Linear memory passed data from JavaScript and WebAssembly'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2：JavaScript 和 WebAssembly 传递的线性内存数据
- en: Pages
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 页面
- en: Pages are the smallest chunk of data that can be allocated for a WebAssembly
    module. At the time of this writing, all WebAssembly pages are 64KB in size. In
    the current version, WebAssembly 1.0, you cannot change that size, although the
    WebAssembly Community Group has an ongoing proposal to make the page size variable
    based on the application’s needs. The maximum number of pages that an application
    can allocate at the time of this writing is 32,767, an overall maximum memory
    size of 2GB. This maximum memory allocation is plenty for web apps but is limiting
    for server-based applications. Increasing the page size could allow server apps
    to increase the maximum amount of linear memory they can allocate. For embedded
    WebAssembly applications, 64KB can be too large; for example, the ATmega328 only
    has 32KB of Flash memory. WebAssembly updates might remove this limitation by
    the time you read this.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 页面是 WebAssembly 模块可以分配的最小数据块。在本文写作时，所有 WebAssembly 页面都是 64KB 大小。在当前版本 WebAssembly
    1.0 中，您无法更改该大小，尽管 WebAssembly 社区组正在进行提案，计划根据应用程序的需求使页面大小可变。本文写作时，应用程序可以分配的最大页面数为
    32,767，总内存大小为 2GB。对于 Web 应用程序来说，这种最大内存分配已经足够，但对于基于服务器的应用程序则有限制。增加页面大小可能使服务器应用程序能够增加它们可以分配的最大线性内存。对于嵌入式
    WebAssembly 应用程序来说，64KB 可能过大；例如，ATmega328 只有 32KB 的闪存。WebAssembly 的更新可能会在您阅读本文时消除这一限制。
- en: You can create the number of pages your app will use either inside the WebAssembly
    module or in the embedding environment for import.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 WebAssembly 模块内部或在嵌入环境中为导入创建应用程序将使用的页面数量。
- en: Creating Pages in Your Code
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在代码中创建页面
- en: To allocate a page of linear memory in WAT, use a simple `(memory``)` expression,
    like the one in [Listing 6-1](#listing6-1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 WAT 中分配一个线性内存页面，使用一个简单的`(memory)`表达式，如[列表6-1](#listing6-1)所示。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 6-1: Declaring a page of memory in WAT'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-1：在 WAT 中声明一个内存页面
- en: Passing `1` into the memory expression instructs the module to set aside one
    page of linear memory. To allocate the maximum amount of memory you can currently
    allocate to a WebAssembly module at runtime, use the expression in [Listing 6-2](#listing6-2).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将`1`传入内存表达式指示模块为线性内存预留一个页面。要分配当前可以为 WebAssembly 模块在运行时分配的最大内存，请使用[列表6-2](#listing6-2)中的表达式。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 6-2: Declaring the maximum number of memory pages'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-2：声明最大内存页面数
- en: Attempting to pass `32_767` into the `(memory``)` expression results in a compile
    error. Memory created using the `(memory``)` expression isn’t accessible to the
    embedding environment unless you include an `(export``)` expression.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将 `32_767` 传入`(memory)`表达式会导致编译错误。使用`(memory)`表达式创建的内存对嵌入环境不可访问，除非您包含`(export)`表达式。
- en: Creating Memory in the Embedded Environment
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在嵌入环境中创建内存
- en: The other way to create the linear memory is inside the embedding environment.
    If the embedding environment is JavaScript, the code to create that memory is
    `new WebAssembly.Memory` as in [Listing 6-3](#listing6-3).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 创建线性内存的另一种方式是在嵌入环境内。如果嵌入环境是 JavaScript，则创建该内存的代码是`new WebAssembly.Memory`，如[列表6-3](#listing6-3)所示。
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 6-3: Creating a WebAssembly `Memory` object in JavaScript'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-3：在 JavaScript 中创建 WebAssembly `Memory` 对象
- en: You could then access it from the WebAssembly module using the `(import``)`
    expression in [Listing 6-4](#listing6-4).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用[列表6-4](#listing6-4)中的`(import)`表达式从 WebAssembly 模块访问它。
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 6-4: Importing a page of memory allocated in JavaScript'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-4：在 JavaScript 中导入分配的内存页面
- en: Using `import` requires you to create a `Memory` object in JavaScript using
    the `WebAssembly.Memory` class, and then to pass it into the WebAssembly module
    when you initialize it through an `import` object. Create a file called *pointer.js*
    and add the JavaScript code in [Listing 6-5](#listing6-5), which creates a WebAssembly
    `Memory` object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '**pointer.js**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 6-5: Initialize WebAssembly linear memory and pass it to the WebAssembly
    module.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: On creation, this code passes in an object with two initialization values. The
    `initial` 1 argument is required and by passing it `1`, we instruct the JavaScript
    engine to set aside one page of linear memory (64KB). The second value `maximum`
    2 is optional and lets the browser know that we’re likely to want to increase
    the size of the linear memory later, and we probably won’t want to grow memory
    to more than four pages. You can increase the size of linear memory by calling
    the `memory.grow` method. You don’t need to set a maximum value to grow your memory,
    but passing in a maximum value tells the browser to set aside more memory than
    the initial value because a call to grow is likely. If you attempt to grow your
    linear memory to more than the maximum value you pass in, the application will
    throw an error. After creating the memory object, we pass it to the WebAssembly
    module through the `importObject` in `env.mem` 3. The JavaScript passes `importObject`
    into the module on instantiation 4.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Pointers
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *pointer* is a variable that references a location in memory. Pointers have
    a variety of applications in computer science, but in this context, we’ll use
    them to point to data structures in linear memory. [Figure 6-3](#figure6-3) shows
    a pointer pointing to memory location 5, which has a value of 99.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![f06003](Images/f06003.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-3: Pointer to the fifth byte in memory'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly pointers behave differently from those you might be familiar with
    in C or C++ that can point to local variables or variables on the heap. The C
    code in [Listing 6-6](#listing6-6) creates a pointer called `ptr` that points
    to the address of a local variable `x`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 6-6: Example of setting pointer values in C'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The pointer `ptr` is set to the address of the `x` variable, which is a local
    variable that has an address on the stack. WebAssembly doesn’t have a distinct
    pointer type, such as C’s `int*` integer pointer type. WebAssembly’s linear memory
    is a large array of data. When you represent a pointer in WAT, you must put the
    data in the linear memory; the pointer is then an `i32` index to that data. The
    variable `x` in [Listing 6-6](#listing6-6) receives an address in linear memory
    when compiling the program to WebAssembly. Unlike in C, WAT cannot create a pointer
    to a local or global variable. To get the C kind of pointer functionality in WebAssembly,
    you can set a global variable to a specific location in linear memory and use
    that global variable to set or retrieve the value stored in WebAssembly linear
    memory, as shown in [Listing 6-7](#listing6-7).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '**pointer.wat**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 6-7: Simulating pointers in WAT'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: This module creates a single page of linear memory 1 and a global `$pointer`
    2 that points to the memory location `128`. We create a function `$init` 3 that
    sets the value of the memory location pointed to by `$pointer` to `99` using the
    `(i32.store``)` 4 expression. The first parameter passed to `(i32.store``)` 5
    is the location in memory where the value is stored, and the second parameter
    6 is the value you want to store. To retrieve the value from this pointer location,
    you use the `i32.load` 8 expression passing in the memory location you want to
    retrieve. We create a function `"get_ptr"` 7 to retrieve this value. Then the
    `(start` `$init)` 9 statement calls `$init` 3 as a module initialization function.
    The `start` statement declares a given function to be the initialization function
    for the module. This function will automatically execute when the module is instantiated.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve compiled the *pointer.wasm* file and executed it with `node`, you
    should see the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: JavaScript Memory Object
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have some idea of how linear memory works, we’ll create a WebAssembly
    memory object, initialize the data from within a WebAssembly module, and then
    access that data from JavaScript. When you’re working with linear memory, there’s
    a good chance that you’ll want to access it from WebAssembly and the embedding
    environment. In this case, the embedding environment is JavaScript, so we’ll define
    the linear memory there to have access to it before the WebAssembly module is
    initialized. This WAT module is similar to [Listing 6-7](#listing6-7) but will
    be importing linear memory from JavaScript.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Creating the WebAssembly Memory Object
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create a file named *store_data.wat* and add the code in [Listing 6-8](#listing6-8)
    to it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '**store_data.wat**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 6-8: Creating a linear memory object in WebAssembly'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The module in [Listing 6-8](#listing6-8) imports its linear memory 1 from the
    JavaScript embedding environment, which we’ll define in a moment. From JavaScript
    it imports the address of the data we’ll load in the global variable `$data_addr`
    2. It also imports `$data_count` 3, which contains the number of `i32` integers
    we’ll store when the module initializes. The `$store_data` 4 function takes in
    an index and a value, and sets the data location (`$data_addr` + `$index` * 4)
    to `$value` (we multiply by 4 because the `i32` type is four bytes). Using `$data_addr`,
    an imported global variable, allows the JavaScript to decide the location in the
    memory module to store these values.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: As in [Listing 6-6](#listing6-6), the `$init` 5 function executes on module
    initialization because of the `(start` `$init)` a statement. Unlike the prior
    `$init` function, this function initializes the data in a loop 6. A loop can be
    a useful way to initialize data in certain parts of linear memory to the same
    value or some value that might be calculated in the loop. This loop sets several
    32-bit integers based on the `$data_count` 8 global variable that the module imports
    from JavaScript. When this `loop` calls `$store_data` 7, it passes in an index
    that is the number of times the `loop` has completed and a value that is `$index`
    * 5\. I chose the value `$index` * 5 so when we display the data, you’ll see the
    data values counting up by 5.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: After the `loop`, we add one more call to `$store_data` 9 to set the first data
    value in the array to `1`. If we don’t initialize it with a value, the memory
    buffer begins with all data set to `0`. Because the `loop` sets the first data
    value to `0`, it wouldn’t be clear where the set data begins when we look at the
    data in JavaScript. Setting it to `1` makes the beginning of the data set more
    apparent when we display it from the JavaScript in the next section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve finished creating the *store_data.wat* file, compile it using `wat2wasm`
    to generate a *store_data.wasm* file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Logging to the Console with Colors
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before writing the *store_data.js* portion, let’s briefly look at a node module
    called *colors* that allows you to log lines to the console using your choice
    of colors. In later sections, we’ll use this package to make it easier to see
    different results in our output data. To install colors, use the `npm` command,
    as shown in [Listing 6-9](#listing6-9).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 6-9: Using `npm` to install the colors module'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Now we can require our app to use it, which allows us to modify the string type
    in JavaScript to include attributes that set colors, bold text, and several other
    features. Create a file named *colors.js* and add the code in [Listing 6-10](#listing6-10).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '**colors.js**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 6-10: Log to console in color'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: When you run *colors.js* using `node`, as shown in [Listing 6-11](#listing6-11),
    the logged output will appear with the colors we specified.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 6-11: Run *color.js* and log with colors to the console.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: You should now see the output in [Listing 6-12](#listing6-12) with the first
    line in red and the second in blue.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 6-12: The colors module applied'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the colors module in future apps to improve the output’s appearance
    in the console. In the book, the red output will be black but in bold. Let’s move
    forward by creating a *store_data.js* file in the next section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Creating the JavaScript in store_data.js
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we need a *store_data.js* JavaScript file to execute the *store_data.wasm*
    module. We create that JavaScript file using [Listing 6-13](#listing6-13).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '**store_data.js (part 1 of 2)**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 6-13: A WebAssembly linear memory buffer and `i``mport``Object` with
    global imports'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: We create three constants, the first of which creates a new `WebAssembly.Memory`
    1 object that we’ll use when we initialize the WebAssembly module. The constant
    `mem_i32` 2 provides a 32-bit integer view into the memory buffer. It’s crucial
    to keep in mind that this isn’t a copy of the data in the buffer but instead is
    a specific way to view that buffer as an array of 32-bit unsigned integers. When
    we change the values in the memory buffer from inside the WebAssembly module,
    we can use this `mem_i32` view to look at the changes to those values. The constant
    `data_addr` 3 is the byte location of the data we set in the WebAssembly module.
    This location is the *byte index m*,not the 32-bit integer array number.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Because a 32-bit integer is four bytes, we need a starting data index that is
    the `data_addr` constant divided by 4\. We set that value in `data_i32_index`
    4. Then we have the number of 32-bit integer values set in the module defined
    by `const data_count` 5. The last `const` in this section of code is the `importObject`
    6. The `importObject` contains three imported data objects for the WebAssembly
    module.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The final portion of the JavaScript in [Listing 6-14](#listing6-14) uses an
    IIFE to instantiate the WebAssembly module and output the values in linear memory
    to the console.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '**store_data.js (part 2 of 2)**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 6-14: Outputting the data values inside linear memory after the IIFE
    instantiates the WebAssembly module'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: This final portion of the JavaScript instantiates the *store_data.wasm* 1 module,
    passing in the `importObject` we created in [Listing 6-13](#listing6-13). After
    initializing the WebAssembly module, the data in the memory buffer will change
    because the `$init` function within the WAT code runs during the initialization.
    We then loop 2 over the `mem_i32` array starting at the first address in the memory
    buffer and displaying four integers after the data is set. This loop displays
    the value in `mem_i32` in the browser by logging it to the console in red 3 if
    the value isn’t `0` and in the default console color 4 if it is.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Use `node` to run *store_data.js*; you should see the output in [Listing 6-15](#listing6-15)
    logged to the console.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 6-15: Data output'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The first data element that was set by the WebAssembly module is `data[8]`,
    which is where the red output begins. The value `8` is the value in the `data_i32_index`
    constant, which is one fourth the value in `data_addr`. There are 16 integers
    set in the code, because we’ve set the `const data_count` to a value of `16`.
    In the data in [Listing 6-15](#listing6-15), all data elements that are `0` weren’t
    set in the WebAssembly module. You can see that the first eight numbers as well
    as the last four are `0`, and they all appear in the default console color.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Collision Detection
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, we created the memory buffer object inside JavaScript, but we initialized
    it from the WebAssembly module. This time, we’ll initialize the memory buffer
    inside JavaScript with values generated in the JavaScript. We’ll also create more
    interesting data structures that will handle our collision detection data. When
    modifying the data in the WebAssembly memory buffer, we want to group the data
    into structures to make it manageable. We’ll create a set of random circle definitions
    in JavaScript, defined with an x- and y-coordinate, and a radius. The JavaScript
    will then set those values in the WebAssembly memory buffer. To organize objects
    in linear memory, you use a combination of a base address, a stride, and an offset.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Base Address, Stride, and Offset
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with linear memory inside our WebAssembly module, we need to understand
    our data structures at a low level. In our JavaScript, we work with the data in
    linear memory as a JavaScript typed array. Inside the WebAssembly module, linear
    memory is more like a memory heap, or a large array of bytes. When we want to
    create an array of data structures, we need to know the *starting address* (base
    address) of that array, the *stride*(distance in bytes between each structure),
    and the *offset*of any structure’s attributes (how far into a structure can we
    find our attribute).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll work with a structure in our linear memory that has four attributes:
    an x- and y-coordinate, a radius, and a hit flag. We’ll set the stride as a *unit
    stride*, as shown in [Figure 6-4](#figure6-4), which means that the distance between
    each structure in our array matches the size of the structure.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![f06004](Images/f06004.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-4: Setting a unit stride'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: To get the memory address of the specific data structure we want to access,
    we multiply the structure’s index by the stride and add the base address. The
    *base address* is the starting address of our array of structures.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to unit stride, you could pad your stride. If a developer
    decided to align their structure addresses to power-of-two, they might add unused
    bytes (called *padding*) to the end of their structures. For example, if we wanted
    our structure to align with 16-byte addresses, we could add four bytes of padding
    to the end of our structure, giving it a stride of 16, as shown in [Figure 6-5](#figure6-5).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: However, we have no need for padding in this example. Each attribute of our
    data structure has an offset. For example, say we have two 32-bit integer attributes,
    `x` and `y`, that are the first two attributes in the data structure, respectively.
    The first attribute, `x`, is at the beginning of the data structure and so has
    an offset of `0`. Because the `x` attribute is a 32-bit integer, it takes up the
    first four bytes of the data structure. That means the `y` offset begins on the
    fifth byte with an offset of `4` (bytes 0, 1, 2, and 3). Using a base address
    (the starting address of our data structure), stride, and offset for each attribute,
    we can construct an array of data structures.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![f06005](Images/f06005.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-5: Padding a stride'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Loading Data Structures from JavaScript
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start by creating the JavaScript file for a new example app named *data_structures.js*.
    In this app, we’ll create data structures that represent circles in memory. Later,
    we’ll perform a collision detection check between those circles. Add the code
    in [Listing 6-16](#listing6-16) to *data_structures.js*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**data_structures.js (part 1 of 3)**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 6-16: Setting the constants to define the structure of the collision
    detection program'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a series of `const` values used to create structures in the
    WebAssembly memory buffer. As in [Listing 6-16](#listing6-16), this code creates
    a single 64KB page of WebAssembly memory 1 and a 32-bit unsigned integer view
    into that data. The `obj_base_addr` constant sets the base address of the data
    structures to `0`, the very first byte of memory in the page.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: We set the `obj_count` 2 `const` to the number of structures set in this code.
    The `obj_stride` 3 constant holds the number of bytes in the structure. We set
    this to `16` because we have four 32-bit integers in this structure, which is
    16 bytes. The next group of `const` declarations contains the attribute offsets.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The `x_offset` 4 is the offset of `x` from the start of the structure, so is
    the number of bytes into each structure in the `x` value location. The `y_offset`
    5 is the number of bytes into the structure in the `y` value location, and has
    a value of `4` because the `x` value is a 32-bit integer, pushing the `y` value
    into the fifth byte in the structure. We then set the offset for the `radius`
    6 attribute and `collision` 7 attribute.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: We calculate the integer index and stride by dividing the byte address by 4
    and the stride by 4\. The reason is that the byte address and stride are the number
    of bytes, and the integer index is 32-bit integers (4 bytes). We also need to
    find the indexes into the integer array, which we calculate by dividing the byte
    indexes by 4 6 as well. The `importObject` 7 has been modified to include the
    new `const` values we’ve added.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: With the constants defined, we’ll create a series of randomly sized circles
    for the program to use. As mentioned earlier, a circle is defined by x- and y-coordinates
    and a radius. We’ll randomly define the circles’ x- and y-coordinates with values
    from 0 to 99 and a radius that is between 1 and 11\. The code in [Listing 6-17](#listing6-17)
    loops over the memory object, setting values in the memory buffer to random values
    for each of the structures.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '**data_structures.js (part 2 of 3)**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 6-17: Initializing the circles with random x- and y-coordinates and
    a radius'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The loop gets an index for each of the structures 1 for the collision detection
    circles. The `x`, `y`, and radius `r` values 2 are set to random values. Those
    random values are then used to set the memory values 3 based on the object index
    and the attribute offsets.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the Results
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we need to instantiate the *data_structures.wasm* module, which runs the
    `$init` function, which runs collision detection between each of the circles we
    randomly generated in this data test. [Listing 6-18](#listing6-18) shows the code
    added to *data_structures.js*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '**data_structures.js (part 3 of 3)**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 6-18: After WebAssembly runs, the code loops over linear memory looking
    for circle collisions.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: This IIFE function instantiates the WebAssembly module 1 and then loops over
    the objects in the `mem_i32` array 2. This loop gets an index for the structure
    using the stride, the index, and the base index value 3. We then use this calculated
    index to get the `x`, `y`, radius, and collision values from the `mem_i32` 4 array.
    These values are logged to the console in red 5 if there was a collision or green
    6 if there wasn’t.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: We now have JavaScript that loads a series of structures that define circles
    with x- and y-coordinates randomly chosen with values between 0 and 100\. Each
    circle also has a radius with a value randomly chosen between 1 and 10\. The WebAssembly
    memory buffer is initialized with these values. The JavaScript will set the appropriate
    offset and stride values in the `importObject`. In addition to the `x`, `y`, and
    radius in each structure, there are four bytes set aside to hold a collision value.
    This value is `1` if the circle collides with another circle and `0` if it doesn’t.
    The WebAssembly module’s initialization `(start``)` function calculates the collisions.
    Once the WebAssembly module initializes, the console displays the results of this
    collision check. At this point, we’ve not yet defined the WebAssembly module.
    Let’s do that next.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Collision Detection Function
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In other sections, we’ve defined the WAT code before the JavaScript. In this
    section, the JavaScript initializes the values that define the circles in the
    array of structures. For that reason, we’ll be writing the JavaScript first in
    this section. When you’re doing collision detection between two circles, you use
    the Pythagorean theorem to determine whether the distance between the centers
    of your circles is greater than the sum of the circles’ radii. The WAT code in
    this section loops over each of the circles we’ve defined in the WebAssembly memory,
    comparing it to every other circle to see whether they collide. The details of
    collision detection aren’t the focus of this section, so we won’t go into it too
    deeply. It’s simply a means to demonstrate how you can separate your data into
    structures and use that data to perform computations with your WAT code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The first portion of the WAT code defines the imports from the JavaScript. [Listing
    6-19](#listing6-19) shows the beginning of the WAT module.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '**data_structures.wat (part 1 of 6)**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 6-19: Importing global variables that define the data structure'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The global variables passed into the WebAssembly module define the layout of
    the linear memory and the data structures within it. The `$obj_base_addr` 1 global
    variable is the location in memory where the circle structures are defined. The
    `$obj_count` 2 global variable is the number of circles defined in linear memory.
    The `$obj_stride` 3 global variable is the number of bytes between each of the
    circle definitions. Then we import values for each of the attributes. The `$x_offset`
    4, `$y_offset` 5, `$radius_offset` 6, and `$collision_offset` 7 are the number
    of bytes between the start of the object’s `x`, `y`, radius, and collision flag
    values. These must be set inside this module.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll define the `$collision_check` function. The details of how this
    function works are only valuable if you’re interested in how circle collision
    detection works. But as an overview, it uses the Pythagorean theorem to determine
    whether the distance between two circles is less than the sum of the circle’s
    radii. To briefly explain, let’s label the radius of the first circle R[1], the
    radius of the second circle R[2], and the distance between the circles D, as shown
    in [Figure 6-6](#figure6-6). No collision occurs if R[1] + R[2] is less than D.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![f06007](Images/f06007.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-6: There is no collision if R[1] + R[2] is less than the distance
    between the circles.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: If the distance is less than R[1] + R[2], we have a collision, as shown in [Figure
    6-7](#figure6-7).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![f06008](Images/f06008.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-7: R[1] + R[2] is greater than the distance between the circles.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-20](#listing6-20) shows the code for the `$collision_check` function.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '**data_structures.wat (part 2 of 6)**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 6-20: A WebAssembly collision detection function'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: This function takes in the `x`, `y`, and radius attributes of two circles 1
    and then returns `1` if they overlap and `0` if they don’t. It first finds the
    `x` distance between the two circles by subtracting `$x2` from `$x1`. It then
    squares that value and stores it in `$x_diff_sq` 2; then it finds the `y` distance
    between the two circles by subtracting `$y2` from `$y1`. It squares the result
    of that subtraction and stores it in `$y_diff_sq` 3. What we’re building toward
    is the Pythagorean theorem A² + B² = C² 5. In this scenario, `$x_diff_sq` is A²,
    and `$y_diff_sq` is B². The sum of these two values is C², which is compared with
    the sum of the radii squared 4. If radius² is greater than C², the circles overlap
    and the function returns `1`; otherwise, the function returns `0`. The function
    makes this decision using the `i32.gt_u` 6 expression.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: After the `$collision_check` function, we need a few helper functions. The `$get_attr`
    helper function takes an object base address parameter and an attribute offset
    parameter and returns the value in linear memory at that address location. [Listing
    6-21](#listing6-21) shows that function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '**data_structures.wat (part 3 of 6)**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 6-21: Retrieving an object attribute from linear memory'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: In the function definition 1, the `$obj_base` parameter is the base address
    for the object, and `$attr_offset` is the offset of the specific attribute we
    want to retrieve. The function adds those values together 2. Then it loads the
    value from that address 3 to return it as a result.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The next helper function is `$set_collision`, which sets the collision flag
    for two of the circle objects to true. [Listing 6-22](#listing6-22) shows that
    function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '**data_structures.wat (part 4 of 6)**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 6-22: Set the collision attribute for a given object'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: This function takes in two object base parameters 1 to set the collision flags
    for those objects in memory. It does this by adding `$obj_base_1` to `$collision_offset`
    2 and then setting the value in linear memory at that location to `1` 3. It then
    adds `$obj_base_2` to `$collision_offset` 4 and sets the value at that location
    to `1` 5.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the other functions defined, we can add the `$init` function
    to the WAT code, as shown in [Listing 6-23](#listing6-23).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '**data_structures.wat (part 5 of 6)**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 6-23: A double loop that checks for a collision between every object
    in linear memory'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The function begins with two groups of local variables. One group contains a
    counter, the address of the objects, and the `x`, `y`, and `r` local variables
    for use with the outer loop 1. The second batch of local variables is for use
    within the inner `loop` 2. The meat of this function is a double loop that compares
    every circle with every other circle in the linear memory looking for circles
    that collide with each other. The beginning of the inner loop checks whether `$i`
    is the same value as `$j` 3. If it is, the code skips the check on this particular
    `$j` object, because otherwise, every circle would collide with itself.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code calculates the linear memory address of the `i`th object
    4 as `$obj_base_addr` + `$i` * `$obj_stride`. It then sets the value of `$i_obj`
    using the `local.tee` expression in the `(call` `$get_attr)` 5 expression in the
    next line. This call to `$getattr` 5 retrieves the value for `x` from the `i`th
    object and then sets `$xi`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The next four lines load values into `$yi` and `$ri` in the same way. Then `$xj`,
    `$yj`, and `$rj` 6 are set using a call to `$get_attr` as well. These values are
    passed into a call to `$collision_check` 7, which returns `1` if the `$i` and
    `$j` circles collide and `0` if they don’t. The `if` statement that follows executes
    a `call` to `$set_collision` 8 if there was a collision, which then sets the collision
    flags on those two objects to `1`. The end of the loop increments `$j` 9 and branches
    back to the top of the inner `loop` if `$j` is less than `$obj_count`. The end
    of the outer `loop` increments `$i` a and branches back to the top of the outer
    `loop` if `$i` is less than `$obj_count`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The last item we call in this module is the `(start` `$init)` statement, as
    shown in [Listing 6-24](#listing6-24), which executes the `$init` function when
    the module is initialized.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '**data_structures.wat (part 6 of 6)**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 6-24: The `start` indicates the function that will execute when the
    module is initialized.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all the code in the *data_structures.wat* file, we can compile
    the WebAssembly file using `wat2wasm`, as shown in [Listing 6-25](#listing6-25).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 6-25: Compile *data_structures.wat*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a compiled *data_structures.wasm* file, we can run *data_structures.js*
    using `node`, as shown in [Listing 6-26](#listing6-26).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 6-26: Run *data_structures.js*.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The output will look something like [Listing 6-27](#listing6-27).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 6-27: Output from *data_structures.js*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: In the actual output, any circle that collides with another circle should be
    in red text, and any circle that collides with no other circles should be in green
    text. We now have an application that uses JavaScript to load randomly generated
    data for circles into WebAssembly linear memory. The initialization function in
    the WebAssembly module then loops over all of that data and updates the linear
    memory wherever one of those circles collides with another circle. Collision detection
    is a great use case for WebAssembly because it allows you to load a lot of data
    into linear memory and let your WebAssembly module work in a fast and efficient
    way.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned what WebAssembly linear memory is and how to create
    it from within the WebAssembly module or JavaScript. Next, we initialized the
    linear data from within the WebAssembly module and accessed it from JavaScript.
    Then we created data structures within linear memory using a base address, stride,
    and attribute offsets, and initialized these data structures from within JavaScript
    using random data.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The final project was an array of circle data structures with x- and y-coordinates
    and a radius. These were passed into a WebAssembly module, which used a double
    loop to loop over the circle data structures looking for circles that overlap
    with each other. If two circles were found to overlap, the WebAssembly module
    set a collision flag inside the linear memory for both circles. JavaScript then
    looped over all of those circles, displaying their x- and y-coordinates, their
    radius, and whether they collided with any other circles.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should understand how to manipulate and set linear memory
    from within WAT and JavaScript. You should also be able to use linear memory from
    within your applications to create data structures and process large quantities
    of data in WebAssembly that you can then display using JavaScript. In the next
    chapter, we’ll look at how to manipulate the Document Object Model (DOM) from
    WebAssembly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
