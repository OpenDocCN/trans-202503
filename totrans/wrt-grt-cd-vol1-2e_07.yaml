- en: '**8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BOOLEAN LOGIC AND DIGITAL DESIGN**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/comm1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Boolean logic is the basis of computation in modern computer systems. You can
    represent any algorithm, or any electronic computer circuit, using a system of
    Boolean equations. To fully understand how software operates, then, you need to
    understand basic Boolean logic and digital design.
  prefs: []
  type: TYPE_NORMAL
- en: This material is especially important to those who want to design electronic
    circuits or write software that controls them. Even if you don’t plan to do this,
    you can use your knowledge of Boolean logic to optimize your software. Many high-level
    languages process Boolean expressions, such as those that control an `if` statement
    or `while` loop. Understanding Boolean logic provides the tools you need to optimize
    your Boolean expressions and improve the performance of HLL code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following subjects, which will aid you when you attempt
    to optimize Boolean expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean algebra, Boolean operators, and Boolean functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to Boolean postulates and theorems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Truth tables and Boolean function optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canonical forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Electronic circuits and their Boolean function counterparts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although a detailed knowledge of Boolean algebra and digital circuit design
    isn’t necessary if you simply want to write typical programs, familiarity with
    these topics will help answer why CPU manufacturers implement instructions in
    certain ways—questions that will undoubtedly arise as we begin looking at the
    CPU’s low-level implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1 Boolean Algebra**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boolean algebra is a deductive mathematical system. A *binary operator* (°)
    accepts a pair of Boolean inputs and produces a single Boolean value. For example,
    the Boolean AND operator accepts two Boolean inputs and produces a single Boolean
    output (the logical AND of the two inputs).
  prefs: []
  type: TYPE_NORMAL
- en: '***8.1.1 The Boolean Operators***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For our purposes, we will base Boolean algebra on the following set of values
    and operators:'
  prefs: []
  type: TYPE_NORMAL
- en: The two possible values in the Boolean system are 0 and 1\. Often, we call these
    values `false` and `true`, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The • symbol represents the logical AND operation. *A* • *B* is the operation
    of logically ANDing the Boolean values *A* and *B*, also known as the *product*
    of *A* and *B*. For single-letter variable names, this text drops the • symbol;
    therefore, *AB* also represents the logical AND of the variables *A* and *B*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The + (plus sign) represents the logical OR operation. *A* + *B* is the result
    of logically ORing the Boolean values *A* and *B*. We also call this the *sum*
    of *A* and *B*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical complement, logical negation, and NOT are all names for the same unary
    operator. This chapter will use the ' (prime symbol) to denote logical negation.
    *A'* denotes the logical NOT of *A*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***8.1.2 Boolean Postulates***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Every algebraic system follows a certain set of initial assumptions, or *[postulates](gloss01.xhtml#gloss01_198)*.
    You can deduce additional rules, theorems, and other properties of the system
    from this basic set of postulates. Boolean algebra employs the following postulates:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Closure** A Boolean system is *closed* with respect to a particular binary
    operator if, for every pair of Boolean values, it produces only a Boolean result.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Commutativity** A binary operator ° is *commutative* if *A* ° *B* = *B* °
    *A* for all possible Boolean values *A* and *B*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Associativity** A binary operator ° is *associative* if (*A* ° *B*) ° *C*
    = *A* ° (*B* ° *C*) for all Boolean values *A*, *B*, and *C*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distribution** Two binary operators ° and % are *[distributive](gloss01.xhtml#gloss01_77)*
    if *A* ° (*B* % *C*) = (*A* ° *B*) % (*A* ° *C*) for all Boolean values *A*, *B*,
    and *C*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identity** A Boolean value *I* is said to be the *identity element* with
    respect to some binary operator ° if *A* ° *I* = *A* for all Boolean values *A*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inverse** A Boolean value *I* is said to be the *inverse element* with respect
    to some binary operator ° if *A* ° *I* = *B* and *B* ° *A* (that is, *B* is the
    opposite value of *A* in a Boolean system) for all Boolean values *A* and *B*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When applied to the Boolean operators, the preceding postulates produce the
    following set of *Boolean postulates*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**P1**   Boolean algebra is closed under the AND, OR, and NOT operations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**P2**   The identity element of AND (•) is 1, and the identity element of
    OR (+) is 0\. There’s no identity element for logical NOT ('').'
  prefs: []
  type: TYPE_NORMAL
- en: '**P3**   The • and + operators are commutative.'
  prefs: []
  type: TYPE_NORMAL
- en: '**P4**   • and + are distributive with respect to each other. That is, *A*
    • (*B* + *C*) = (*A* • *B*) + (*A* • *C*) and *A* + (*B* • *C*) = (*A* + *B*)
    • (*A* + *C*).'
  prefs: []
  type: TYPE_NORMAL
- en: '**P5**   • and + are both associative. That is, (*A* • *B*) • *C* = *A* • (*B*
    • *C*) and (*A* + *B*) + *C* = *A* + (*B* + *C*).'
  prefs: []
  type: TYPE_NORMAL
- en: '**P6**   For every value *A* there exists a value *A''* such that *A* • *A''*
    = 0 and *A* + *A''* = 1\. This value is the logical complement (or NOT) of *A*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can prove all other theorems in Boolean algebra using this set of Boolean
    postulates. This chapter won’t go into the formal proofs of the following theorems,
    but familiarity with them will be useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Th1**   *A* + *A* = *A*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Th2**   *A* • *A* = *A*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Th3**   *A* + 0 = *A*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Th4**   *A* • 1 = *A*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Th5**   *A* • 0 = 0'
  prefs: []
  type: TYPE_NORMAL
- en: '**Th6**   *A* + 1 = 1'
  prefs: []
  type: TYPE_NORMAL
- en: '**Th7**   (*A* + *B*)*'' = A''* • *B''*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Th8**   (*A* • *B*)*''* = *A''* + *B''*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Th9**   *A* + *A* • *B* = *A*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Th10**   *A* • (*A* + *B* ) = *A*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Th11**   *A* + *A''B* = *A* + *B*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Th12**   *A''* • (*A* + *B''*) = *A''B''*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Th13**   *AB* + *AB''* = *A*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Th14**   (*A''* + *B''* ) • (*A''* + *B*) = *A''*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Th15**   *A* + *A''* = 1'
  prefs: []
  type: TYPE_NORMAL
- en: '**Th16**   *A* • *A''* = 0'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Theorems 7 and 8 are called* DeMorgan’s Theorems *after the mathematician
    who discovered them.*'
  prefs: []
  type: TYPE_NORMAL
- en: An important principle in the Boolean algebra system is *duality*. Each pair,
    theorems 1 and 2, theorems 3 and 4, and so on, forms a *dual*. Any valid expression
    you can create using the postulates and theorems of Boolean algebra remains valid
    if you interchange the operators and constants appearing in the expression. Specifically,
    if you exchange the • and + operators and swap the 0 and 1 values in an expression,
    the resulting expression will obey all the rules of Boolean algebra. *This does
    not mean the dual expression computes the same values*, only that both expressions
    are legal in the Boolean algebra system.
  prefs: []
  type: TYPE_NORMAL
- en: '***8.1.3 Boolean Operator Precedence***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If several different Boolean operators appear within a single Boolean expression,
    the result of the expression depends on the *[precedence](gloss01.xhtml#gloss01_201)*
    of the operators. The following Boolean operators are ordered from highest precedence
    to lowest:'
  prefs: []
  type: TYPE_NORMAL
- en: Parentheses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical NOT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical AND
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical OR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logical AND and OR operators are *left associative*. This means that if
    two operators with the same precedence appear between three operands, you must
    evaluate the expressions from left to right. The logical NOT operation is *right
    associative*, although it would produce the same result using either left or right
    associativity because it is a unary operator having only a single operand.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.2 Boolean Functions and Truth Tables**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Boolean *expression* is a sequence of 0s, 1s, and literals separated by Boolean
    operators. A Boolean *literal* is a primed (negated) or unprimed variable name,
    and all variable names are a single alphabetic character. A Boolean function is
    a specific Boolean expression; we generally give Boolean functions the name *F*
    with a possible subscript. For example, consider the following Boolean function:'
  prefs: []
  type: TYPE_NORMAL
- en: '*F*[0] = *AB* + *C*'
  prefs: []
  type: TYPE_NORMAL
- en: This function computes the logical AND of *A* and *B* and then logically ORs
    this result with *C*. If *A* = 1, *B* = 0, and *C* = 1, then *F*[0] returns 1
    (1 • 0 + 1 = 1).
  prefs: []
  type: TYPE_NORMAL
- en: You can also represent a Boolean function with a *truth table*. The truth tables
    for the logical AND and OR functions are shown in [Tables 8-1](ch08.xhtml#ch08tab01)
    and [8-2](ch08.xhtml#ch08tab02), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-1:** AND Truth Table'
  prefs: []
  type: TYPE_NORMAL
- en: '| **AND** | **0** | **1** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '**Table 8-2:** OR Truth Table'
  prefs: []
  type: TYPE_NORMAL
- en: '| **OR** | **0** | **1** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: For binary operators and two input variables, this truth table format is very
    intuitive and convenient. However, for functions involving more than two variables,
    it doesn’t work well.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-3](ch08.xhtml#ch08tab03) shows another way to represent truth tables.
    This format has several advantages—it is easier to fill in the table, it supports
    three or more variables, and it provides a compact representation for two or more
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-3:** Truth Table Format for a Function of Three Variables'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***C*** | ***B*** | ***A*** | ***F = ABC*** | ***F = AB + C*** | ***F = A
    + BC*** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: Although you can create an infinite variety of Boolean functions, they are not
    all unique. For example, *F* = *A* and *F* = *AA* are two different functions.
    By theorem 2, however, it’s easy to show that these two functions produce exactly
    the same result no matter what input value you supply for *A*. As it turns out,
    if you fix the number of input variables, there’s a finite number of unique Boolean
    functions possible. For example, there are 16 unique Boolean functions with two
    input variables, and there are 256 possible Boolean functions with three input
    variables. Given *n* input variables, there are 2^(2^(*n*)) unique Boolean functions
    (2 raised to 2 raised to the *n*th power). With two input variables, there are
    2²² or 16 different functions. With three input variables, there are 2²³ or 256
    possible functions. Four input variables have 2²⁴ or 2^(16) or 65,536 unique Boolean
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: When working with only 16 Boolean functions (two input variables), we can name
    each unique function (see [Table 8-4](ch08.xhtml#ch08tab04)).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-4:** Common Names for Boolean Functions of Two Variables'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function number^([1](footnotes.xhtml#fn8_1a)) | **Function name** | **Description**
    |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Zero (clear) | Always returns 0 regardless of *A* and *B* input values.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Logical NOR | (NOT (*A* OR *B*)) = (*A* + *B*)*''* |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Inhibition (*AB*'') | Inhibition = *AB**''* (*A* AND not *B*). Also equivalent
    to *A* > *B* or *B* < *A*. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | NOT *B* | Ignores *A* and returns *B**''*. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Inhibition (*BA**''*) | Inhibition = *BA**''* (*B* AND not *A*). Also
    equivalent to *B* > *A* or *A* < *B*. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | NOT *A* | Returns *A**''* and ignores *B*. |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Exclusive-OR (XOR) | *A* ⊕ *B*. Equivalent to *A* ≠ *B*. |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Logical NAND | (NOT (*A* AND *B*)) = (*A* • *B*)*''* |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Logical AND | *A* • *B* = (*A* AND *B*) |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | Equivalence (exclusive-NOR) | (*A* = *B*). Also known as exclusive-NOR
    (not exclusive-OR). |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | *A* | Copy *A*. Returns the value of *A* and ignores *B*’s value. |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | Implication, *B* implies *A* | *A* + *B**''*. (If *B* then *A*.) Equivalent
    to *B* ≥ *A*. |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | *B* | Copy *B*. Returns the value of *B* and ignores *A*’s value. |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | Implication, *A* implies *B* | *B* + *A**''*. (If *A* then *B*.) Equivalent
    to *A* ≥ *B*. |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | Logical OR | *A* + *B*. Returns *A* OR *B*. |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | One (set) | Always returns 1 regardless of *A* and *B* input values.
    |'
  prefs: []
  type: TYPE_TB
- en: '**8.3 Function Numbers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Beyond two input variables, there are too many functions to provide a specific
    name for each. Even when referring to functions with two input variables, we’ll
    refer to the function’s number rather than its name. For example, *F*[8] denotes
    the logical AND of *A* and *B* for a two-input function, and *F*[14] denotes the
    logical OR operation. Of course, for functions with more than two input variables,
    the question is, “How do we determine a function’s number?” For example, what
    is the corresponding number for the function *F* = *AB* + *C* ? We compute the
    answer by looking at the function’s truth table. If we treat the values for *A*,
    *B*, and *C* as bits in a binary number with *C* being the HO bit and *A* being
    the LO bit, they produce the binary strings that correspond to numbers in the
    range 0 through 7\. Associated with each of these binary strings is the function
    result, either 0 or 1\. If we construct a binary number by placing the function
    result of each combination of the *A*, *B*, and *C* input values into the bit
    position specified by the binary string of the *A*, *B*, and *C* bits, the resulting
    binary number will be the corresponding function number. If this doesn’t make
    sense, an example will help clear it up. Consider the truth table for *F* = *AB*
    + *C* (see [Table 8-5](ch08.xhtml#ch08tab05)).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-5:** Truth Table for *F* = *AB* + *C*'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***C*** | ***B*** | ***A*** | ***F = AB + C*** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'The input variables *C*, *B*, and *A* combine to form binary number sequences
    in the range `%000` through `%111` (0 through 7). If we use these values to denote
    bit numbers in an 8-bit value (*CBA* = `%111` specifies bit 7, *CBA* = `%110`
    specifies bit 6, and so on), we can determine the function number by placing at
    each of these bit positions the result of *F* = *AB* + *C*, for the corresponding
    combination of *C*, *B*, and *A* values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we treat this bit string as a binary number, it produces the function
    number `$F8`, or 248\. We usually denote function numbers in decimal. This also
    provides insight into why there are 2^(2^(*n*)) different functions given *n*
    input variables: if you have *n* input variables, there are 2^(*n*) different
    variable value combinations, and thus 2^(*n*) bits in the function’s binary number.
    If you have *m* bits, there are 2^(*m*) different possible arrangements of those
    bits. Therefore, for *n* input variables there are *m* = 2^(*n*) possible bits
    and 2^(*m*) or 2^(2^(*n*)) possible functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.4 Algebraic Manipulation of Boolean Expressions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can transform one Boolean expression into an equivalent expression by applying
    the postulates and theorems of Boolean algebra. This is important if you want
    to convert a given expression to a canonical form (see the next section) or if
    you want to minimize the number of literals or terms in an expression. (A *literal*
    is a primed or unprimed variable, and a *term* is a variable or a product—logical
    AND—of several different literals.) Electrical circuits often consist of individual
    components that implement each literal or term, so minimizing the number of literals
    and terms in an expression allows a circuit designer to use fewer electrical components
    and, therefore, to reduce the monetary cost of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, there are no fixed rules you can apply to optimize a given expression.
    Much like constructing mathematical proofs, an individual’s ability to easily
    do these transformations is usually a matter of experience. Nevertheless, a few
    examples show the possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**8.5 Canonical Forms**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each Boolean function has an infinite number of equivalent logic expressions.
    To help eliminate confusion, logic designers generally specify a Boolean function
    using a *canonical*, or standardized, form. For each different Boolean function,
    we can choose a single canonical representation from a defined set.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to define a set of canonical representations for all
    the possible Boolean functions of *n* variables. Within each canonical set, a
    single expression describes each Boolean function in the system so all of the
    functions in the set are unique. We’ll discuss two canonical systems in this chapter—the
    *sum of minterms* and the *product of maxterms*—but we’ll employ only the first.
    Using the duality principle, we can convert between these two systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, a term is either a single literal or a product (logical
    AND) of several different literals. For example, if you have two variables, *A*
    and *B*, there are eight possible terms: *A*, *B*, *A''*, *B''*, *A''B''*, *A''B*,
    *AB''*, and *AB*. For three variables, we have 26 different terms: *A*, *B*, *C*,
    *A''*, *B''*, *C''*, *A''B''*, *A''B*, *AB''*, *AB*, *A''C''*, *A''C*, *AC''*,
    *AC*, *B''C''*, *B''C*, *BC''*, *BC*, *A''B''C''*, *AB''C''*, *A''BC''*, *ABC''*,
    *A''B''C*, *AB''C*, *A''BC*, and *ABC*. As the number of variables increases,
    the number of terms increases dramatically. A *minterm* is a product containing
    exactly *n* literals, where *n* is the number of input variables. For example,
    the minterms for the two variables *A* and *B* are *A''B''*, *AB''*, *A''B*, and
    *AB*. Likewise, the minterms for three variables *A*, *B*, and *C* are *A''B''C''*,
    *AB''C''*, *A''BC''*, *ABC''*, *A''B''C*, *AB''C*, *A''BC*, and *ABC*. In general,
    there are 2^(*n*) minterms for *n* variables. The set of possible minterms is
    easy to generate because they correspond to the sequence of binary numbers (see
    [Table 8-6](ch08.xhtml#ch08tab06)).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-6:** Generating Minterms from Binary Numbers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Binary equivalent (**CBA**)** | **Minterm** |'
  prefs: []
  type: TYPE_TB
- en: '| 000 | *A''B''C''* |'
  prefs: []
  type: TYPE_TB
- en: '| 001 | *AB''C''* |'
  prefs: []
  type: TYPE_TB
- en: '| 010 | *A''BC''* |'
  prefs: []
  type: TYPE_TB
- en: '| 011 | *ABC''* |'
  prefs: []
  type: TYPE_TB
- en: '| 100 | *A''B''C* |'
  prefs: []
  type: TYPE_TB
- en: '| 101 | *AB''C* |'
  prefs: []
  type: TYPE_TB
- en: '| 110 | *A''BC* |'
  prefs: []
  type: TYPE_TB
- en: '| 111 | *ABC* |'
  prefs: []
  type: TYPE_TB
- en: 'We can derive the canonical form for *any* Boolean function using a sum (logical
    OR) of minterms. Given *F*[248] = *AB* + *C*, the equivalent canonical form is
    *ABC* + *A''BC* + *AB''C* + *A''B''C* + *ABC''*. Algebraically, we can show that
    the canonical form is equivalent to *AB* + *C* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, the canonical form is not optimal. However, it’s very easy to generate
    the truth table for a function from the canonical form. It’s also very easy to
    generate the sum-of-minterms canonical form equation from the truth table.
  prefs: []
  type: TYPE_NORMAL
- en: '***8.5.1 Sum-of-Minterms Canonical Form and Truth Tables***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To build the truth table from the sum-of-minterms canonical form, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert minterms to binary equivalents by substituting a 1 for unprimed variables
    and a 0 for primed variables, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Place a 1 in the function column for the appropriate minterm entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ***C*** | ***B*** | ***A*** | ***F = AB +* *C*** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 0 | 0 | 0 |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 0 | 0 | 1 |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 0 | 1 | 0 |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 1 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 1 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 1 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 1 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'Finally, place the number 0 in the function column for the remaining entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ***C*** | ***B*** | ***A*** | ***F =* *AB + C*** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 0 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 1 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 1 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 1 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 1 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'Going in the other direction, to generate a logic function from a truth table,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate all the entries in the truth table with a function result of 1\. In this
    table, these are the last five entries. The number of table entries containing
    1s determines the number of minterms in the canonical equation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate the individual minterms by substituting *A*, *B*, or *C* for 1s and
    *A'*, *B'*, or *C'* for 0s. In this example, the result of *F*[248] is 1 when
    *CBA* equals 111, 110, 101, 100, or 011\. Therefore, *F*[248] *= CBA* + *CBA'*
    + *CB'A* + *CB'A'* + *C'AB*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally rearrange the terms within the minterms, and rearrange the minterms
    within the overall function. This works because the logical OR and logical AND
    operations are both commutative.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This process works equally well for any number of variables, as with the truth
    table in [Table 8-7](ch08.xhtml#ch08tab07) for the function *F*[53,504] = *ABCD*
    + *A'BCD* + *A'B'CD* + *A'B'C'D*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-7:** Truth Table for F[53,504]'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***D*** | ***C*** | ***B*** | ***A*** | ***F = ABCD + A''BCD + A''B''CD +
    A''B''C''D*** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: Perhaps the easiest way to generate the canonical form of a Boolean function
    is to first generate the truth table for it and then build the canonical form
    from the truth table. In fact, we’ll use this technique when converting between
    the two canonical forms.
  prefs: []
  type: TYPE_NORMAL
- en: '***8.5.2 Algebraically Derived Sum-of-Minterms Canonical Form***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To generate the sum-of-minterms canonical form algebraically, we use the distributive
    law and theorem 15 (*A* + *A''* = 1). Consider *F*[248] = *AB* + *C*. This function
    contains two terms, *AB* and *C*, but they are not minterms. We can convert the
    first term to a sum of minterms as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can convert the second term in *F*[248] to a sum of minterms
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step (rearranging the terms) in these two conversions is optional.
    To obtain the final canonical form for *F*[248], we sum the results from these
    two conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '***8.5.3 Product-of-Maxterms Canonical Form***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another canonical form is the *products of maxterms*. A maxterm is the sum
    (logical OR) of all input variables, primed or unprimed. For example, consider
    the following logic function, *G*, of three variables in product-of-maxterms form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the sum-of-minterms form, there’s exactly one product of maxterms for
    each possible logic function. For every product-of-maxterms form, there’s an equivalent
    sum-of-minterms form. In fact, the function *G* in this example is equivalent
    to the earlier sum-of-minterms form of *F*[248]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate a truth table from the product of maxterms, you use the duality
    principle; that is, swap AND for OR and 0s for 1s (and vice versa). Therefore,
    to build the truth table, you’d first swap primed and nonprimed literals. In *G*,
    this would yield:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to swap the logical OR and logical AND operators, which produces
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you need to swap all 0s and 1s. This means that for each of the minterms
    listed previously, you need to store 0s into the function column of the truth
    table, and then fill in the rest of the truth table’s function column with 1s.
    This will place a 0 in rows 0, 1, and 2 in the truth table. Filling the remaining
    entries with 1s produces *F*[248].
  prefs: []
  type: TYPE_NORMAL
- en: You can easily convert between these two canonical forms by generating the truth
    table for one form and working backward to produce the other form. Consider the
    function of two variables, *F*[7] = *A* + *B*. The sum-of-minterms form is *F*[7]
    = *A'B* + *AB'* + *AB*. The truth table is shown in [Table 8-8](ch08.xhtml#ch08tab08).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-8:** OR Truth Table for Two Variables'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***A*** | ***B*** | ***F***7 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: Working backward to get the product of maxterms, we first locate all entries
    in the truth table that have a 0 result. The entry with *A* and *B* both equal
    to 0 is the only entry with a 0 result. This gives us the first step of *G* =
    *A' B'*. However, we still need to invert all the variables to obtain *G* = *AB*.
    By the duality principle, we also need to swap the logical OR and logical AND
    operators, obtaining *G* = *A* + *B*. This is the canonical *product of maxterms*
    form.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.6 Simplification of Boolean Functions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because there’s an infinite variety of Boolean functions of *n* variables, but
    a finite number of unique ones, you might wonder if there is some method that
    will simplify a given Boolean function to produce the optimal form—that is, the
    expression containing the fewest number of operators. An optimal form must exist
    for all logic functions, but we don’t use it for the canonical form for two reasons.
    First, although it’s easy to convert between the truth table forms and the canonical
    form, it’s not as easy to generate the optimal form from a truth table. Second,
    there may be several optimal forms for a single function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can attempt to produce the optimal form using algebraic transformations,
    but there’s no guarantee you’ll arrive at the best result. There are two methods
    that will *always* reduce a given Boolean function to its optimal form: the *mapping*
    method and the *prime implicants* method. This book covers the mapping method.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the mapping method to manually optimize Boolean functions is practical
    only for functions of two, three, or four variables. It’s doable but cumbersome
    for functions of five or six variables. For more than six variables, you should
    write a program.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in the mapping method is to build a special two-dimensional truth
    table for the function (see [Figure 8-1](ch08.xhtml#ch08fig01)). *Take a careful
    look at these truth tables*. They do not use the same forms shown earlier in this
    chapter. In particular, the progression of the 2-bit values is 00, 01, 11, 10,
    not 00, 01, 10, 11\. This is very important! If you organize the truth tables
    in a binary sequence, the mapping optimization method will not work properly.
    We’ll call this a *truth map* to distinguish it from the standard truth table.^([2](footnotes.xhtml#fn8_2a))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: Two-, three-, and four-variable truth maps*'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming your Boolean function is already in sum-of-minterms canonical form,
    insert 1s for each of the truth map cells corresponding to one of the minterms
    in the function. Place 0s everywhere else. For example, consider the function
    of three variables *F* = *C'B'A* + *C'BA'* + *C'BA* + *CB'A'* + *CB'A* + *CBA'*
    + *CBA*. [Figure 8-2](ch08.xhtml#ch08fig02) shows the truth map for this function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-2: A truth map for* F = C''B''A + C''BA'' + C''BA + CB''A'' + CB''A
    + CBA'' + CBA'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to draw outlines around rectangular groups of 1s. The rectangles
    you enclose must have sides whose lengths are powers of 2\. For functions with
    three variables, the rectangles can have sides whose lengths are 1, 2, and 4\.
    The set of rectangles you draw must surround all cells containing 1s in the truth
    map. The trick is to draw all possible rectangles unless a rectangle would be
    completely enclosed within another, but also draw the fewest number of rectangles.
    Note that the rectangles may overlap as long as one rectangle does not completely
    enclose the other. In the truth map in [Figure 8-3](ch08.xhtml#ch08fig03), there
    are three such rectangles.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-3: Surrounding rectangular groups of 1s in a truth map*'
  prefs: []
  type: TYPE_NORMAL
- en: Each rectangle represents a term in the simplified Boolean function. Therefore,
    the simplified Boolean function will contain only three terms. You build each
    term by eliminating any variables whose primed and unprimed forms both appear
    within the rectangle (because the positive and negative variants cancel each other
    out). The long skinny rectangle in [Figure 8-3](ch08.xhtml#ch08fig03) is sitting
    in the row where *C* = 1 contains both *A* and *B* in primed and unprimed forms.
    Therefore, we can eliminate both *A* and *B* from the term. Because the rectangle
    sits in the *C* = 1 region, this rectangle represents the single literal *C*.
  prefs: []
  type: TYPE_NORMAL
- en: The light gray square in [Figure 8-3](ch08.xhtml#ch08fig03) includes *C*, *C'*,
    *B*, *B'*, and *A*. Therefore, it represents the single term *A*. Likewise, the
    dark gray square in [Figure 8-3](ch08.xhtml#ch08fig03) contains *C*, *C'*, *A*,
    *A'*, and *B*, so it represents the single term *B*.
  prefs: []
  type: TYPE_NORMAL
- en: The final, optimal, function is the sum (logical OR) of the terms represented
    by the three squares, or *F* = *A* + *B* + *C*. You do not have to consider the
    remaining squares containing 0s.
  prefs: []
  type: TYPE_NORMAL
- en: A truth map forms a *torus* (a doughnut shape). The right edge of the map wraps
    around to the left edge, and vice versa. Likewise, the top edge wraps around to
    the bottom edge. This introduces additional possibilities for drawing rectangles
    around groups of 1s in a map. Consider the Boolean function *F* = *C'B'A'* + *C'BA'*
    + *CB'A'* + *CBA'*. [Figure 8-4](ch08.xhtml#ch08fig04) shows the truth map for
    this function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-4: Truth map for F = C''B''A'' + C''BA'' + CB''A + CBA''*'
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, you might think that the minimum number of rectangles is two,
    as shown in [Figure 8-5](ch08.xhtml#ch08fig05).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: First attempt at surrounding rectangles formed by 1s*'
  prefs: []
  type: TYPE_NORMAL
- en: However, because the truth map is a continuous object with the right side and
    left sides connected, we can actually form a single, square rectangle, as [Figure
    8-6](ch08.xhtml#ch08fig06) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-6: Correct rectangle for the function*'
  prefs: []
  type: TYPE_NORMAL
- en: Why does it matter if we have one rectangle or two in the truth map? The larger
    the rectangles are, the more terms they will eliminate. The fewer rectangles that
    we have, then, the fewer terms will appear in the final Boolean function.
  prefs: []
  type: TYPE_NORMAL
- en: The example in [Figure 8-5](ch08.xhtml#ch08fig05) with two rectangles generates
    a function with two terms. The rectangle on the left eliminates the *C* variable,
    leaving *A'B'* as its term. The rectangle on the right also eliminates the *C*
    variable, leaving the term *BA'*. Therefore, this truth map would produce the
    equation *F* = *A'B'* + *A'B*. We know this is not optimal (see theorem 13).
  prefs: []
  type: TYPE_NORMAL
- en: Now consider the truth map in [Figure 8-6](ch08.xhtml#ch08fig06). Here we have
    a single rectangle, so our Boolean function will have only a single term. Because
    this rectangle includes both *C* and *C'*, and also *B* and *B'*, the only term
    left is *A'*. This Boolean function, therefore, reduces to *F = A'*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are only two types of truth maps that the mapping method cannot handle
    properly: a truth map that contains all 0s or a truth map that contains all 1s.
    These two cases correspond to the Boolean functions *F* = 0 and *F* = 1 (that
    is, the function number is 0 or 2^(*n*) – 1). When you see either of these truth
    maps, you’ll know how to optimally represent the function.'
  prefs: []
  type: TYPE_NORMAL
- en: When optimizing Boolean functions using the mapping method, remember that you
    always want to pick the largest rectangles whose sides’ lengths are powers of
    2\. You must do this even for overlapping rectangles (unless one rectangle encloses
    another). Consider the Boolean function *F* = *C'B'A'* + *C'BA'* + *CB'A'* + *C'AB*
    + *CBA'* + *CBA*. This produces the truth map in [Figure 8-7](ch08.xhtml#ch08fig07).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-7: Truth map for F = C''B''A'' + C''BA'' + CB''A'' + C''AB + CBA''
    + CBA*'
  prefs: []
  type: TYPE_NORMAL
- en: The initial temptation is to create one of the sets of rectangles found in [Figure
    8-8](ch08.xhtml#ch08fig08). However, the correct mapping appears in [Figure 8-9](ch08.xhtml#ch08fig09).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-8: Obvious choices for rectangles*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-9: Correct set of rectangles for F = C''B''A'' + C''BA'' + CB''A''
    + C''AB + CBA'' + CBA*'
  prefs: []
  type: TYPE_NORMAL
- en: All three mappings will produce a Boolean function with two terms. However,
    the first two will produce the expressions *F* = *B* + *A'B'* and *F* = *AB* +
    *A'*. The third form produces *F* = *B* + *A'*. This last form is the optimized
    one (see theorems 11 and 12).
  prefs: []
  type: TYPE_NORMAL
- en: Truth maps you create for functions of four variables are even trickier; there
    are many places rectangles can hide from you along the edges, as you can see in
    [Figure 8-10](ch08.xhtml#ch08fig10). This list of patterns doesn’t even begin
    to cover all of them! For example, the diagrams in [Figure 8-10](ch08.xhtml#ch08fig10)
    show none of the 1×2 rectangles.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-10: Partial pattern list for a 4×4 truth map*'
  prefs: []
  type: TYPE_NORMAL
- en: This final example demonstrates optimizing a function of four variables. The
    function is *F* = *D'C'B'A'* + *D'C'B'A* + *D'C'BA* + *D'C'BA'* + *D'CB'A* + *D'CBA*
    + *DCB'A* + *DCBA* + *DC'B'A'* + *DC'BA'*, and its truth map appears in [Figure
    8-11](ch08.xhtml#ch08fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-11: Truth map for F = D''C''B''A'' + D''C''B''A + D''C''BA + D''C''BA''
    + D''CB''A + D''CBA + DCB''A + DCBA + DC''B''A'' + DC''BA''*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-12](ch08.xhtml#ch08fig12) shows the two possible sets of maximal
    rectangles for this function, each producing three terms.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-12: Two combinations yielding three terms*'
  prefs: []
  type: TYPE_NORMAL
- en: The rectangle formed by the four corners, common to both maps in [Figure 8-12](ch08.xhtml#ch08fig12),
    contains *B*, *B'*, *D*, and *D'*, so we can eliminate those terms. The remaining
    terms contained within the rectangle are *C'* and *A'*, so this rectangle represents
    the term *C'A'*.
  prefs: []
  type: TYPE_NORMAL
- en: The rectangle formed by the middle four squares, also in both combinations,
    includes the terms *A*, *B*, *B'*, *C*, *D*, and *D'*. Eliminating *B*, *B'*,
    *D*, and *D'*, we obtain *CA*.
  prefs: []
  type: TYPE_NORMAL
- en: Combination 1 has a third term represented by the top row. This term includes
    the variables *A*, *A'*, *B*, *B'*, *C',* and *D'*. We can eliminate *A*, *A'*,
    *B*, and *B'*. This leaves the term *C'D'*. Therefore, the function represented
    by the upper truth map is *F* = *C'A'* + *CA* + *C'D'*.
  prefs: []
  type: TYPE_NORMAL
- en: Combination 2 has a third term represented by the top/middle four squares. This
    rectangle subsumes the variables *A*, *B*, *B'*, *C*, *C'*, and *D'*. We can eliminate
    *B*, *B'*, *C*, and *C'*, leaving the term *AD*. Therefore, the function represented
    by the lower truth map is *F* = *C'A'* + *CA* + *AD'*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both functions are equivalent; both are optimal (remember, there’s no guarantee
    of a unique optimal solution). Either will suffice for our purposes: implementing
    Boolean functions using the fewest circuit components.'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.7 What Does This Have to Do with Computers, Anyway?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any program you can write, you can also specify as a sequence of Boolean equations.
    This means that any algorithm you can implement in software, you can also implement
    directly in hardware—there is a one-to-one relationship between the set of all
    Boolean functions and the set of all electronic circuits. Electrical engineers,
    who design CPUs and other computer-related circuits, have to be intimately familiar
    with this material.
  prefs: []
  type: TYPE_NORMAL
- en: Because it’s easier to specify a solution to a programming problem using languages
    like Pascal, C, or even assembly language than it is to specify the solution using
    Boolean equations, it’s unlikely that you would ever implement an entire program
    using a set of state machines and other logic circuitry. However, a hardware solution
    can be orders of magnitude faster than an equivalent software solution, and some
    time-critical operations require a hardware solution.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to implement all hardware functions in software. This is
    important, because many operations you’d normally implement in hardware are much
    cheaper to implement using software on a microprocessor. Indeed, one of the primary
    uses of assembly language on modern systems is to inexpensively replace a complex
    electronic circuit. Often, you can replace many tens or hundreds of dollars of
    electronic components with a single $2 microcomputer chip programmed to perform
    the equivalent function.
  prefs: []
  type: TYPE_NORMAL
- en: The whole field of *embedded systems* (computer systems embedded in other products)
    deals with this problem. For example, most microwave ovens, TV sets, video games,
    CD players, and other consumer devices contain one or more complete computer systems
    whose sole purpose is to replace a complex hardware design. Engineers use computers
    for this purpose because they are less expensive and easier to design with than
    traditional electronic circuitry.
  prefs: []
  type: TYPE_NORMAL
- en: To write software that reads switches (input variables) and turns on motors,
    LEDs, or lights, or that locks or unlocks a door, you need to understand Boolean
    functions and how to implement them in software.
  prefs: []
  type: TYPE_NORMAL
- en: '***8.7.1 Correspondence Between Electronic Circuits and Boolean Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For any Boolean function, you can design an equivalent electronic circuit and
    vice versa. We can construct any electronic circuit using the AND, OR, and NOT
    Boolean operators, which correspond to the AND, OR, and inverter (NOT) circuits
    (see [Figure 8-13](ch08.xhtml#ch08fig13)). These symbols are standard electronic
    symbols appearing in *schematic diagrams*. (To learn more about electronic schematic
    diagrams, check out any book on electronic design.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-13: AND, OR, and inverter (NOT) gates*'
  prefs: []
  type: TYPE_NORMAL
- en: The lines to the left of each gate, with the *A* and *B* labels, correspond
    to a logic function input; the line to the right of each diagram corresponds to
    the function’s output.
  prefs: []
  type: TYPE_NORMAL
- en: An *electronic circuit* is a combination of gates that implement some set of
    Boolean functions. Consider the Boolean function *F* = *AB* + *B*. You can implement
    this function using an AND gate and an OR gate. Simply connect the two input variables
    (*A* and *B*) to the inputs of the AND gate, connect the output of the AND gate
    to one of the inputs of the OR gate, and connect the *B* input variable to the
    other OR input. Now you have an electronic (hardware) circuit that implements
    this function.
  prefs: []
  type: TYPE_NORMAL
- en: However, you actually need only a single gate type—the NAND (NOT AND) gate—to
    implement *any* electronic circuit (see [Figure 8-14](ch08.xhtml#ch08fig14)).
    The NAND gate tests its two inputs (*A* and *B*) and outputs `false` if both inputs
    are `true`; it outputs `true` if both inputs are `false`. You could construct
    the NAND circuit from an AND gate and an inverter. However, from a transistor/hardware
    perspective, the NAND gate is actually simpler to construct than an AND gate;
    therefore, NAND gates (such as the 7400 IC) are very common.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-14: The NAND gate*'
  prefs: []
  type: TYPE_NORMAL
- en: We can construct any Boolean function using only NAND gates because we can build
    an inverter (NOT), an AND gate, and an OR gate from NAND gates.^([3](footnotes.xhtml#fn8_3a))
    Building an inverter is easy; just connect the two inputs together (see [Figure
    8-15](ch08.xhtml#ch08fig15)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-15: Inverter built from a NAND gate*'
  prefs: []
  type: TYPE_NORMAL
- en: After building an inverter, we can build an AND gate by inverting the output
    of a NAND gate, because NOT (NOT (*A* AND *B*)) is equivalent to *A* AND *B* (see
    [Figure 8-16](ch08.xhtml#ch08fig16)). It takes two NAND gates to construct a single
    AND gate (no one said that circuits constructed only with NAND gates are optimal,
    only that they’re possible).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-16: Constructing an AND gate from two NAND gates*'
  prefs: []
  type: TYPE_NORMAL
- en: The remaining gate is the logical-OR gate. We can construct an OR gate from
    NAND gates by applying DeMorgan’s Theorems.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Applying these transformations produces the circuit shown in [Figure 8-17](ch08.xhtml#ch08fig17).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-17: Constructing an OR gate from NAND gates*'
  prefs: []
  type: TYPE_NORMAL
- en: NAND gates are generally less expensive to build than other gates, and it’s
    much easier to build up complex circuits from the same basic building blocks than
    it is to construct an integrated circuit using different basic gates.
  prefs: []
  type: TYPE_NORMAL
- en: '***8.7.2 Combinatorial Circuits***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A computer’s CPU is built from *combinatorial circuits*, which are systems containing
    basic Boolean operations (AND, OR, NOT), some inputs, and a set of outputs. A
    combinatorial circuit often implements several different Boolean functions, with
    each output corresponding to an individual logic function.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*It is very important that you remember that* each output represents a different
    Boolean function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.7.2.1 Combining Addition Circuits**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can implement addition using Boolean functions. Suppose you have two 1-bit
    numbers, *A* and *B*. You can produce the 1-bit sum and the 1-bit carry of this
    addition using these two Boolean functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These two Boolean functions implement a *half adder*, so called because it adds
    2 bits together but cannot add in a carry from a previous operation. Note that
    *S* = 1 if *A* or *B* is 1, *S* = 0 if *A* and *B* are both 0 or 1 (both 1 produces
    a carry, which is what the *C* = *AB* expression produces).
  prefs: []
  type: TYPE_NORMAL
- en: 'A *full adder* adds three 1-bit inputs (2 bits plus a carry from a previous
    addition) and produces two outputs: the sum and the carry. These are the two logic
    equations for a full adder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Although these equations produce only a single-bit result (plus a carry), it’s
    easy to construct an *n*-bit sum by combining adder circuits (see [Figure 8-18](ch08.xhtml#ch08fig18)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-18: Building an n-bit adder using half and full adders*'
  prefs: []
  type: TYPE_NORMAL
- en: The two *n*-bit inputs, *A* and *B*, are passed into the adder bit-by-bit, with
    the LO bits input as *A*[0] and *B*[0], and so on up to HO bits *A*[*n*][–1] and
    *B*[*n*][–1]. *S*[0] is the LO bit of the sum, up to *S*[*n*][–1], and the final
    carry indicates whether the addition overflowed *n* bits.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.7.2.2 Using Seven-Segment LED Decoders**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another common combinatorial circuit is the *seven-segment decoder*. Among the
    more important circuits in computer system design, decoder circuits enable the
    computer to recognize (or *decode*) a string of bits.
  prefs: []
  type: TYPE_NORMAL
- en: The seven-segment decoder circuit accepts an input of 4 bits and determines
    which segments to illuminate on a seven-segment LED display. Because a seven-segment
    display contains seven output values (one for each segment), there are seven logic
    functions associated with it (segments 0 through 6). See [Figure 8-19](ch08.xhtml#ch08fig19)
    for the segment assignments. [Figure 8-20](ch08.xhtml#ch08fig20) shows the active
    segments for each of the 10 decimal values.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-19: Seven-segment display*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-20: Seven-segment values for 0 through 9*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The four inputs to each of these seven Boolean functions are the 4 bits from
    a binary number in the range 0 through 9\. Let *D* be the HO bit of this number
    and *A* be the LO bit. Each segment’s logic function should produce a `1` (segment
    on) for all binary number inputs that have that segment illuminated in [Figure
    8-20](ch08.xhtml#ch08fig20). For example, *S*[4] (segment 4) should be illuminated
    for numbers 0, 2, 6, and 8, which correspond to the binary values 0000, 0010,
    0110, and 1000\. For each of the binary values that illuminates a segment, you
    will have one minterm in the logic equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*S*[0] (segment 0), as a second example, is on for the numbers 0, 2, 3, 5,
    6, 7, 8, and 9, which correspond to the binary values 0000, 0010, 0011, 0101,
    0110, 0111, 1000, and 1001\. Therefore, the logic function for *S*[0] is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**8.7.2.3 Decoding Memory Addresses**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A decoder is also commonly used in memory expansion. For example, suppose a
    system designer wishes to install four (identical) 256MB memory modules in a system
    to bring the total to 1GB of RAM. Each of these 256MB memory modules has 28 address
    lines (*A*[0]..*A*[27]), assuming each memory module is 8 bits wide (2^(28) ×
    8 bits is 256MB).^([4](footnotes.xhtml#fn8_4a))
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, if the system designer hooked up those four memory modules to
    the CPU’s address bus, each module would respond to the same addresses on the
    bus. Pandemonium would result. To correct this problem, each memory module needs
    to respond to a different set of addresses appearing on the full address bus (with
    a module address appearing on the LO 28 bits of the address bus). By adding a
    chip-select line to each of the memory modules, and using a two-input, four-output
    decoder circuit, we can use the chip select lines *A*[28] and *A*[29] to specify
    the HO 2 bits of the (now effectively 30-bit) memory address. See [Figure 8-21](ch08.xhtml#ch08fig21)
    for the details.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-21: Adding four 256MB memory modules to a system*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two- to four-line decoder circuit in [Figure 8-21](ch08.xhtml#ch08fig21)
    incorporates four different logic functions: one function for each of the outputs.
    Each combination of the input bits will activate a single chip-select line, and
    deactivate the other three. Assuming the inputs are *A* and *B* (*A* = *A*[28]
    and *B* = *A*[29]), the four output functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Following standard electronic circuit notation, these equations use *Q* to denote
    an output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that most circuit designers use *active low logic* for decoders and chip
    enables. This means that they enable a circuit when a low-input value (`0`) is
    supplied and disable the circuit when a high-input value (`1`) is supplied. Real-world
    decoding circuits would likely use the following sums of maxterms functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**8.7.2.4 Decoding Machine Instructions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Decoding circuits are also used to decode machine instructions. We’ll cover
    this subject in much greater depth in [Chapters 9](ch09.xhtml#ch09) and [10](ch10.xhtml#ch10),
    but a simple example is in order here.
  prefs: []
  type: TYPE_NORMAL
- en: Most modern computer systems represent machine instructions using binary values
    in memory. To execute an instruction, the CPU fetches the instruction’s binary
    value from memory, decodes it using decoder circuitry, and then does the appropriate
    work. To see how this is done, let’s create a fictional CPU with a very simple
    instruction set. [Figure 8-22](ch08.xhtml#ch08fig22) provides the instruction
    format (all the numeric codes that correspond to the various instructions) for
    our CPU. Within the 1-byte operation code (opcode), 3 bits (`iii`) represent the
    instruction, 2 bits (`ss`) the source operand, and 2 bits the destination operand
    (`dd`).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-22: Instruction (opcode) format for a very simple CPU*'
  prefs: []
  type: TYPE_NORMAL
- en: To determine the 8-bit opcode for a given instruction, look up each component
    of the instruction in the tables in [Figure 8-22](ch08.xhtml#ch08fig22) and substitute
    the corresponding bit values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s pick `mov(eax, ebx);` as our simple example. To convert this instruction
    to its numeric equivalent, `mov` is encoded as `000`, `eax` is encoded as `00`,
    and `ebx` is encoded as `01`. Assemble these three fields into the opcode byte
    (a packed data type), to obtain the bit value: `%00000001`. Therefore, the numeric
    value `$1` is the value for the `mov(eax, ebx);` instruction (see [Figure 8-23](ch08.xhtml#ch08fig23)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-23: Encoding the `mov(eax, ebx);` instruction*'
  prefs: []
  type: TYPE_NORMAL
- en: A typical decoder circuit for this example appears in [Figure 8-24](ch08.xhtml#ch08fig24).
    The circuit uses three separate decoders to decode the individual fields of the
    opcode. This is much less complex than creating a single 7- to 128-line decoder
    to decode the entire opcode.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-24: Decoding simple machine instructions*'
  prefs: []
  type: TYPE_NORMAL
- en: The circuit in [Figure 8-24](ch08.xhtml#ch08fig24) tells you which instruction
    and what operands a given opcode specifies. To actually execute this instruction,
    you must supply additional circuitry to select the source and destination operands
    from an array of registers and act accordingly upon those operands. Such circuitry
    is beyond the scope of this chapter, so we’ll save the juicy details for later.
  prefs: []
  type: TYPE_NORMAL
- en: '***8.7.3 Sequential and Clocked Logic***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One major problem with combinatorial logic is that it is *memoryless*. In theory,
    all logic function outputs depend only on the current inputs. Any change in the
    input values immediately appears on the outputs.^([5](footnotes.xhtml#fn8_5a))
    Unfortunately, computers need the ability to *remember* the results of past computations.
    This is the domain of sequential, or clocked, logic.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.7.3.1 The Set/Reset Flip-Flop**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *memory cell* is an electronic circuit that remembers an input value after
    the removal of that input value. The most basic memory unit is the *set/reset
    (S/R) flip-flop*. You can construct an S/R flip-flop memory cell using two NAND
    gates, as shown in [Figure 8-25](ch08.xhtml#ch08fig25). In this diagram, the outputs
    of the two NAND gates are recirculated to one of the inputs of the other NAND
    gate.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-25: Set/reset flip-flop constructed from NAND gates*'
  prefs: []
  type: TYPE_NORMAL
- en: The *S* and *R* inputs are normally high, or `1`. If you toggle the *S* input
    by *temporarily* setting its value to `0` and then bringing it back to `1`, the
    *Q* output is set to `1`. Likewise, if you toggle the *R* input from `1` to `0`
    and back to `1`, this resets the *Q* output to `0`. *Q'* outputs the opposite
    of *Q*.
  prefs: []
  type: TYPE_NORMAL
- en: If both *S* and *R* are `1`, then the *Q* output depends upon the original value
    of *Q* itself. That is, whatever *Q* happens to be, the top NAND gate continues
    to output that same value. If *Q* was originally `1`, then the bottom NAND gate
    receives two inputs of `1` (both *Q* and *R*), and the bottom NAND gate produces
    an output of `0` (*Q'*). As a result, the two inputs to the top NAND gate are
    `0` and `1`, and the top NAND gate produces an output of `1`, matching the original
    value for *Q*.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the original value of *Q* was `0`, then the inputs to
    the bottom NAND gate are *Q* = `0` and *R* = `1`, and the output of this bottom
    NAND gate is `1`. As a result, the inputs to the top NAND gate are *S =* `1` and
    *Q' =* `1`. This produces a `0` output, the original value of *Q*.
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose *Q* is `0`, *S* is `0`, and *R* is `1`. This sets the two inputs
    to the top NAND gate to `1` and `0`, forcing the output (*Q*) to `1`. Returning
    *S* to the high state does not change the output at all, because the value of
    *Q'* is `1`. You will obtain this same result if *Q* is `1`, *S* is `0`, and *R*
    is `1`. Again, this produces a *Q* output value of `1`, and again this value remains
    `1` even when *S* switches from `0` to `1`. To overcome this and produce a *Q*
    output of `1`, you must toggle the *S* input. The same idea applies to the *R*
    input, except that toggling it forces the *Q* output to `0` rather than to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: There is one catch to this circuit. It does not operate properly if you set
    both the *S* and *R* inputs to `0` simultaneously. This forces both the *Q* and
    *Q'* outputs to `1` (which is logically inconsistent). Whichever input remains
    `0` the longest determines the final state of the flip-flop. A flip-flop operating
    in this mode is said to be *unstable*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-9](ch08.xhtml#ch08tab09) lists all the output configurations for an
    S/R flip-flop based on the current inputs and the previous output values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-9:** S/R Flip-Flop Output States Based on Current Inputs and Previous
    Outputs'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Previous Q** | **Previous Q’** | **S input** | **R input** | **Q output**
    | **Q’ output** |'
  prefs: []
  type: TYPE_TB
- en: '| x^([6](footnotes.xhtml#fn8_6a)) | x | `0` (`1` > `0` > `1`) | `1` | `1` |
    `0` |'
  prefs: []
  type: TYPE_TB
- en: '| x | x | `1` | `0` (`1` > `0` > `1`) | `0` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| x | x | `0` | `0` | `1` | `1`^([7](footnotes.xhtml#fn8_7a)) |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` | `1` | `0` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `1` | `1` | `1` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '**8.7.3.2 The D Flip-Flop**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The only problem with the S/R flip-flop is that to be able to remember either
    a `0` or a `1` value, you must have two different inputs. A memory cell would
    be more valuable to us if we could specify the data value to remember with one
    input value and supply a second *clock input* value to *latch* the data input
    value.^([8](footnotes.xhtml#fn8_8a)) This type of flip-flop, the D flip-flop (*D*
    stands for *data*), uses the circuit in [Figure 8-26](ch08.xhtml#ch08fig26).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-26: Implementing a D flip-flop with NAND gates*'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming you fix the *Q* and *Q'* outputs to either `0`/`1` or `1`/`0`, sending
    a *clock pulse* that goes from `0` to `1` and back to `0` will copy the *D* input
    to the *Q* output (and set *Q'* to the inverse of *Q*). To see how this works,
    note that the right half of the circuit diagram in [Figure 8-26](ch08.xhtml#ch08fig26)
    is an S/R flip-flop. If the data input is `1` while the clock line is high, this
    places a `0` on the *S* input of the S/R flip-flop (and a `1` on the *R* input).
    Conversely, if the data input is `0` while the clock line is high, this places
    a `0` on the *R* input (and a `1` on the *S* input) of the S/R flip-flop, thus
    clearing the S/R flip-flop’s output. Whenever the clock input is low, both the
    *S* and *R* input are high, and the outputs of the S/R flip-flop do not change.
  prefs: []
  type: TYPE_NORMAL
- en: Although remembering a single bit is often important, in most computer systems
    you want to remember a *group* of bits. You can do this by combining several D
    flip-flops in parallel. Concatenating flip-flops to store an *n*-bit value forms
    a *register.* The electronic schematic in [Figure 8-27](ch08.xhtml#ch08fig27)
    shows how to build an 8-bit register from a set of D flip-flops.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-27: An 8-bit register implemented with eight D flip-flops*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the eight D flip-flops in [Figure 8-27](ch08.xhtml#ch08fig27) use
    a common clock line. This diagram does not show the *Q'* outputs on the flip-flops
    because they are rarely required in a register.
  prefs: []
  type: TYPE_NORMAL
- en: D flip-flops are useful for building many sequential circuits beyond simple
    registers. For example, you can build a *shift register* that shifts the bits
    one position to the left on each clock pulse. A 4-bit shift register appears in
    [Figure 8-28](ch08.xhtml#ch08fig28).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-28: A 4-bit shift register built from D flip-flops*'
  prefs: []
  type: TYPE_NORMAL
- en: You can even build a *counter* that counts the number of times the clock toggles
    from `1` to `0` and back to `1` using flip-flops. The circuit in [Figure 8-29](ch08.xhtml#ch08fig29)
    implements a 4-bit counter using D flip-flops.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-29: A 4-bit counter built from D flip-flops*'
  prefs: []
  type: TYPE_NORMAL
- en: Surprisingly, you can build an entire CPU with combinatorial circuits and only
    a few additional sequential circuits. For example, you can build a simple state
    machine known as a *sequencer* by combining a counter and a decoder, as shown
    in [Figure 8-30](ch08.xhtml#ch08fig30).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-30: A simple 16-state sequencer*'
  prefs: []
  type: TYPE_NORMAL
- en: For each cycle of the clock in [Figure 8-30](ch08.xhtml#ch08fig30), this sequencer
    activates one of its output lines. Those lines, in turn, may control other circuits.
    By “firing” those other circuits on each of the 16 output lines of the decoder,
    we can control the order in which the circuits accomplish their tasks. This is
    essential in a CPU, as we often need to control the sequence of various operations.
    For example, it wouldn’t be a good thing if the `add(eax, ebx);` instruction stored
    the result into EBX before fetching the source operand from EAX (or EBX). A simple
    sequencer can tell the CPU when to fetch the first operand, when to fetch the
    second operand, when to add them together, and when to store the result. However,
    we’re getting a little ahead of ourselves—we’ll discuss this in detail in the
    next two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.8 For More Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Horowitz, Paul, and Winfield Hill. *The Art of Electronics*. 3rd ed. Cambridge,
    UK: Cambridge University Press, 2015.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This chapter is not, by any means, a complete treatment of Boolean algebra
    and digital design. If you’re interested in learning more, consult one of the
    dozens of books on this subject.*'
  prefs: []
  type: TYPE_NORMAL
