- en: '**Smart Machines**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**22'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ultrasonic Robot**
  prefs: []
  type: TYPE_NORMAL
- en: In this project we’ll combine an ultrasonic sensor with two DC motors and a
    servomotor to create a simple object-avoiding robot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0190-01.jpg)![Image](../images/p0191-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jumper wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**L293d motor shield**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2 DC motors and wheels[*](ch22.xhtml#note01)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HC-SR04 ultrasonic sensor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**9V AA battery pack**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Robot base with fittings[*](ch22.xhtml#note01)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Center wheel[*](ch22.xhtml#note01)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tower Pro SG90 9g servomotor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LIBRARIES REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Servo**'
  prefs: []
  type: TYPE_NORMAL
- en: '**NewPing**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adafruit Motor Shield V1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[*](ch22.xhtml#note_01) These items can be purchased as part of a kit**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The key parts of the ultrasonic robot are the HC-SR04 ultrasonic sensor, L293d
    motor shield, and the motors. The motors I used were purchased as part of a kit;
    if you search online for “Arduino robot kit,” you too should be able to find a
    kit that contains the motors and wheels, base, battery pack, center wheel, and
    fittings needed. The one I bought is called the “2WD Smart Motor Robot Car Chassis
    Kit for Arduino 1:48,” so try a few of those keywords until you find something
    similar to the kit in [Figure 22-1](ch22.xhtml#ch22fig1). Also try the suppliers
    listed in the “[Retailer List](app02.xhtml#ch00lev1sec170)” on [page 249](app02.xhtml#page_249).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 22-1:** Robot motor kit'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f22-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ultrasonic sensor sends and receives a signal to determine the distance
    of an object. If there is an object less than 15 centimeters away, the robot will
    stop, look around, turn toward a direction in which it doesn’t sense anything,
    and move in that direction. The ultrasonic sensor is mounted on a servomotor so
    that the robot can move and search for a clear route. For more on how the HC-SR04
    ultrasonic sensor works, see Project 13\. The L293d motor shield fits on top of
    the Arduino and controls the DC motors using the Adafruit Motor Shield library.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need to solder wires to the DC motors as shown in [Figure 22-2](ch22.xhtml#ch22fig2).
    See the “[Quick Soldering Guide](pref02.xhtml#ch00lev1sec123)” on [page 12](pref02.xhtml#page_12)
    if you need a refresher on how to do this. Solder the red, positive power wire
    to the left pin of one DC motor and the black ground wire to the right pin; reverse
    this order for the other motor. DC motors do not have polarity, so it doesn’t
    matter which way you hold the motors to determine which is left and right, but
    power and GND need to be in opposite positions on the motors so the direction
    of the revolution will be the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 22-2:** Solder the red, positive power wire to the left pin of one
    DC motor, and the black ground wire to the right pin. Reverse this order for the
    other motor.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f22-02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Attach the single wheel to the front of the robot base and the two rear wheels
    to the back using the screws and fittings provided. The underside of the robot
    should resemble [Figure 22-3](ch22.xhtml#ch22fig3).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 22-3:** Assemble the base of the Arduino robot.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f22-03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now you need the L293d motor shield ([Figure 22-4](ch22.xhtml#ch22fig4)); we’ll
    solder some wires to it to control the ultrasonic sensor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 22-4:** The L293d motor shield. We’ll solder four wires to the pins
    highlighted in the image.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f22-04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Take four female jumper wires and strip about 5 millimeters from one end of
    each, as shown in [Figure 22-5](ch22.xhtml#ch22fig5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 22-5:** Strip the ends of four female jumper wires to solder onto
    the motor shield.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f22-05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Solder the stripped ends to the highlighted pins on the motor shield, as shown
    in [Figure 22-6](ch22.xhtml#ch22fig6). This can be tricky, so take your time to
    create the best connection you can.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 22-6:** Solder the jumper wires to the motor shield (shown in [Figure
    22-4](ch22.xhtml#ch22fig4)). The two pins below the power connections should connect
    to analog A4 and A5 to control the sensor.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f22-06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Once you’ve soldered the wires to the motor shield, place the shield on top
    of the Arduino so that the pins of the shield line up with the holders in the
    Arduino below. The shield should fit exactly, but take care to align the pins
    to the holes and gently lower it in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, connect the ultrasonic sensor to the female ends of the jumper wires you
    soldered to the motor shield. Connect VCC on the sensor to +5V on the motor shield,
    Trig to A4, Echo to A5, and GND to GND (see the following table).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **ULTRASONIC SENSOR** | **MOTOR SHIELD** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| VCC | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Trig | Pin A4 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Echo | Pin A5 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Connect the wires from the DC motors to the motor shield as shown in the following
    tables and [Figure 22-7](ch22.xhtml#ch22fig7). You connect the wires by feeding
    them through the pin and using the screws to grip the wires in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **LEFT MOTOR** | **MOTOR SHIELD** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Red wire | M1 | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Black wire | M1 | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| **RIGHT MOTOR** | **MOTOR SHIELD** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Red wire | M3 | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Black wire | M3 | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**FIGURE 22-7:** Connect the power wires of the DC motors as shown.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f22-07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Next attach the servomotor to the shield, as shown in the following table and
    [Figure 22-8](ch22.xhtml#ch22fig8).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **SERVOMOTOR** | **MOTOR SHIELD** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Brown wire | Servo_2 - | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Red wire | Servo_2 + | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Yellow wire | Servo_2 s | Signal |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**FIGURE 22-8:** Connect the servomotor to the shield as shown.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f22-08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Attach the servomotor to the front of the robot using glue or tape. Then attach
    the ultrasonic sensor to the horn of the servomotor so it moves with the servo
    arm and your robot can look around. At this stage the robot should look something
    like [Figure 22-9](ch22.xhtml#ch22fig9).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 22-9:** The completed robot with ultrasonic sensor attached to the
    servomotor'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f22-09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Make sure you’ve downloaded the NewPing and Adafruit Motor Shield libraries
    and added them to your IDE. The Servo library is already included in the IDE,
    so you don’t need to install it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you’ve confirmed that your setup matches the circuit diagram in [Figure
    22-10](ch22.xhtml#ch22fig10), upload the code in “[The Sketch](ch22.xhtml#ch00lev1sec93)”
    on [page 198](ch22.xhtml#page_198) and connect the 9V battery pack to your Arduino
    to see your robot in action!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 22-10:** The circuit diagram for the ultrasonic robot'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f22-10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sketch starts by calling on the Adafruit Motor Shield, NewPing, and Servo
    libraries. The Trig pin of the ultrasonic sensor is defined as Arduino A4 and
    the Echo pin as Arduino A5\. The maximum distance of the ultrasonic sensor is
    set at 200 centimeters and the speed of the DC motors is set at a medium speed
    of 190 (out of 255). The DC motors are defined to use connections M1 and M3 of
    the motor shield.
  prefs: []
  type: TYPE_NORMAL
- en: The servo is given a name and attached to pin 9 on the Arduino (via the connection
    on the motor shield). The loops after that take a reading from the ultrasonic
    sensor and, if it detects that an object is less than 15 centimeters away, the
    motors stop and reverse slightly, the servo moves left and right once to look
    around, and the robot turns to the left and continues to move forward until it
    discovers another object.
  prefs: []
  type: TYPE_NORMAL
- en: // Reproduced with kind permission from Nick Koumaris
  prefs: []
  type: TYPE_NORMAL
- en: // [http://www.educ8s.tv](http://www.educ8s.tv)
  prefs: []
  type: TYPE_NORMAL
- en: '#include <AFMotor.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <NewPing.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <Servo.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#define TRIG_PIN A4'
  prefs: []
  type: TYPE_NORMAL
- en: '#define ECHO_PIN A5'
  prefs: []
  type: TYPE_NORMAL
- en: '#define MAX_DISTANCE 200'
  prefs: []
  type: TYPE_NORMAL
- en: '#define MAX_SPEED 190 // Sets speed of DC motors'
  prefs: []
  type: TYPE_NORMAL
- en: '#define MAX_SPEED_OFFSET 20'
  prefs: []
  type: TYPE_NORMAL
- en: NewPing sonar(TRIG_PIN, ECHO_PIN, MAX_DISTANCE);
  prefs: []
  type: TYPE_NORMAL
- en: AF_DCMotor motor1(1, MOTOR12_1KHZ); // First motor to connection 1
  prefs: []
  type: TYPE_NORMAL
- en: AF_DCMotor motor2(3, MOTOR12_1KHZ); // Second motor to connection 3
  prefs: []
  type: TYPE_NORMAL
- en: Servo myservo; // Give the servo a name
  prefs: []
  type: TYPE_NORMAL
- en: boolean goesForward = false;
  prefs: []
  type: TYPE_NORMAL
- en: int distance = 100; // Define an int for distance and speed
  prefs: []
  type: TYPE_NORMAL
- en: int speedSet = 0;
  prefs: []
  type: TYPE_NORMAL
- en: void setup() {
  prefs: []
  type: TYPE_NORMAL
- en: myservo.attach(9); // Servo attached to pin 9
  prefs: []
  type: TYPE_NORMAL
- en: myservo.write(115); // Set servo at 115 degrees
  prefs: []
  type: TYPE_NORMAL
- en: delay(2000);
  prefs: []
  type: TYPE_NORMAL
- en: distance = readPing(); // Read the distance from the sensor
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: distance = readPing();
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: distance = readPing();
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: distance = readPing();
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void loop() {
  prefs: []
  type: TYPE_NORMAL
- en: int distanceR = 0;
  prefs: []
  type: TYPE_NORMAL
- en: int distanceL = 0;
  prefs: []
  type: TYPE_NORMAL
- en: delay(40);
  prefs: []
  type: TYPE_NORMAL
- en: // If distance is less than 15 cm, carry out this function
  prefs: []
  type: TYPE_NORMAL
- en: if (distance <= 15) {
  prefs: []
  type: TYPE_NORMAL
- en: moveStop();
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: moveBackward();
  prefs: []
  type: TYPE_NORMAL
- en: delay(300);
  prefs: []
  type: TYPE_NORMAL
- en: moveStop();
  prefs: []
  type: TYPE_NORMAL
- en: delay(200);
  prefs: []
  type: TYPE_NORMAL
- en: distanceR = lookRight();
  prefs: []
  type: TYPE_NORMAL
- en: delay(200);
  prefs: []
  type: TYPE_NORMAL
- en: distanceL = lookLeft();
  prefs: []
  type: TYPE_NORMAL
- en: delay(200);
  prefs: []
  type: TYPE_NORMAL
- en: if (distanceR >= distanceL) {
  prefs: []
  type: TYPE_NORMAL
- en: turnRight();
  prefs: []
  type: TYPE_NORMAL
- en: moveStop();
  prefs: []
  type: TYPE_NORMAL
- en: '} else { // Or else carry on'
  prefs: []
  type: TYPE_NORMAL
- en: turnLeft();
  prefs: []
  type: TYPE_NORMAL
- en: moveStop();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: moveForward();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: distance = readPing();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: int lookRight() { // The servo looks to the right
  prefs: []
  type: TYPE_NORMAL
- en: myservo.write(50);
  prefs: []
  type: TYPE_NORMAL
- en: delay(500);
  prefs: []
  type: TYPE_NORMAL
- en: int distance = readPing();
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: myservo.write(115);
  prefs: []
  type: TYPE_NORMAL
- en: return distance;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: int lookLeft() { // The servo looks to the left
  prefs: []
  type: TYPE_NORMAL
- en: myservo.write(170);
  prefs: []
  type: TYPE_NORMAL
- en: delay(500);
  prefs: []
  type: TYPE_NORMAL
- en: int distance = readPing();
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: myservo.write(115);
  prefs: []
  type: TYPE_NORMAL
- en: return distance;
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: int readPing() {
  prefs: []
  type: TYPE_NORMAL
- en: delay(70);
  prefs: []
  type: TYPE_NORMAL
- en: int cm = sonar.ping_cm();
  prefs: []
  type: TYPE_NORMAL
- en: if (cm == 0) {
  prefs: []
  type: TYPE_NORMAL
- en: cm = 250;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return cm;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void moveStop() {
  prefs: []
  type: TYPE_NORMAL
- en: motor1.run(RELEASE);
  prefs: []
  type: TYPE_NORMAL
- en: motor2.run(RELEASE);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void moveForward() {
  prefs: []
  type: TYPE_NORMAL
- en: if (!goesForward) { // If area is clear, motors move forward
  prefs: []
  type: TYPE_NORMAL
- en: goesForward = true;
  prefs: []
  type: TYPE_NORMAL
- en: motor1.run(FORWARD);
  prefs: []
  type: TYPE_NORMAL
- en: motor2.run(FORWARD);
  prefs: []
  type: TYPE_NORMAL
- en: // Slowly bring up speed to avoid loading down
  prefs: []
  type: TYPE_NORMAL
- en: // batteries too quickly
  prefs: []
  type: TYPE_NORMAL
- en: for (speedSet = 0; speedSet < MAX_SPEED; speedSet += 2) {
  prefs: []
  type: TYPE_NORMAL
- en: motor1.setSpeed(speedSet);
  prefs: []
  type: TYPE_NORMAL
- en: motor2.setSpeed(speedSet + MAX_SPEED_OFFSET);
  prefs: []
  type: TYPE_NORMAL
- en: delay(5);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void moveBackward() {
  prefs: []
  type: TYPE_NORMAL
- en: goesForward = false;
  prefs: []
  type: TYPE_NORMAL
- en: motor1.run(BACKWARD);
  prefs: []
  type: TYPE_NORMAL
- en: motor2.run(BACKWARD);
  prefs: []
  type: TYPE_NORMAL
- en: // Slowly bring up speed to avoid loading down
  prefs: []
  type: TYPE_NORMAL
- en: // batteries too quickly
  prefs: []
  type: TYPE_NORMAL
- en: for (speedSet = 0; speedSet < MAX_SPEED; speedSet += 2) {
  prefs: []
  type: TYPE_NORMAL
- en: motor1.setSpeed(speedSet);
  prefs: []
  type: TYPE_NORMAL
- en: motor2.setSpeed(speedSet + MAX_SPEED_OFFSET);
  prefs: []
  type: TYPE_NORMAL
- en: delay(5);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void turnRight() { // Movement for turning right
  prefs: []
  type: TYPE_NORMAL
- en: motor1.run(FORWARD);
  prefs: []
  type: TYPE_NORMAL
- en: motor2.run(BACKWARD);
  prefs: []
  type: TYPE_NORMAL
- en: delay(300);
  prefs: []
  type: TYPE_NORMAL
- en: motor1.run(FORWARD);
  prefs: []
  type: TYPE_NORMAL
- en: motor2.run(FORWARD);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void turnLeft() { // Movement for turning left
  prefs: []
  type: TYPE_NORMAL
- en: motor1.run(BACKWARD);
  prefs: []
  type: TYPE_NORMAL
- en: motor2.run(FORWARD);
  prefs: []
  type: TYPE_NORMAL
- en: delay(300);
  prefs: []
  type: TYPE_NORMAL
- en: motor1.run(FORWARD);
  prefs: []
  type: TYPE_NORMAL
- en: motor2.run(FORWARD);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *The code compiles, but the Arduino robot does not function as expected.*'
  prefs: []
  type: TYPE_NORMAL
- en: • Make sure that your wiring matches the tables in steps 7, 8, and 9 and the
    circuit diagram in [Figure 22-10](ch22.xhtml#ch22fig10).
  prefs: []
  type: TYPE_NORMAL
- en: • If your robot spins around rather than moving forward, reverse the wiring
    on one of the DC motors—as mentioned earlier, they don’t have polarity but changing
    the power connections will reverse the motor’s rotation.
  prefs: []
  type: TYPE_NORMAL
- en: • Power the robot with a pack of 1.5V AA batteries in series rather than a 9V
    battery, which has less amperage and will drain quicker.
  prefs: []
  type: TYPE_NORMAL
- en: '**23'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Internet-Controlled LED**
  prefs: []
  type: TYPE_NORMAL
- en: In this project we’ll use an ethernet shield to connect our Arduino to the internet
    and control an LED from a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0202-01.jpg)![Image](../images/p0203-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Breadboard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jumper wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ethernet shield W5100 LAN expansion board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ethernet cable**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**220-ohm resistor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LIBRARIES REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**SPI**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ethernet**'
  prefs: []
  type: TYPE_NORMAL
- en: The *Internet of Things (IoT)* is revolutionizing our use of everyday items.
    The term refers to objects or smart devices connected through a network, usually
    involving the internet. This allows us to control devices remotely, from inside
    or outside the house! Amazon Echo and Google Home are taking things further by
    allowing a multitude of devices to be connected and controlled via a central hub,
    even if you aren’t at home. We’ll create our own IoT project in its most basic
    form to demonstrate the principles involved.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Ethernet shield W5100 LAN expansion board, shown in [Figure 23-1](ch23.xhtml#ch23fig1),
    fits directly on top of the Arduino to provide additional functionality to the
    board. We’ll use the Ethernet library built into the Arduino IDE to connect our
    board to the internet via an Ethernet cable, as shown in [Figure 23-2](ch23.xhtml#ch23fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 23-1:** Ethernet shield'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f23-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 23-2:** Ethernet cable'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f23-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The library allows the Arduino to act as a server to accept incoming commands,
    a client to send them out, or both. The shield communicates with the Arduino using
    the *Serial Peripheral Interface (SPI)* connections. On the Arduino Uno the SPI
    connections are on digital pins 10, 11, 12, and 13\. In our project the Arduino
    will use both functions to send information to the internet in the form of a simple
    web page and accept commands from this page to control an LED. Buttons on the
    web page will allow us to switch the LED on or off as long as the Arduino is powered
    and connected to the internet.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP YOUR ETHERNET CONNECTION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You need to know the MAC address of your shield for this project to work. A
    *MAC address* is a unique number assigned to devices for communication and is
    used as a network address for Ethernet and Wi-Fi. If you have a newer shield,
    the MAC address will be printed on a product sticker. If you have an older generic
    Ethernet shield like the one we are using, you can use the MAC address 0xDE, 0xAD,
    0xBE, 0xEF, 0xFE, 0xED for this project.
  prefs: []
  type: TYPE_NORMAL
- en: For communication, we’ll use port 80, the default for HTTP. Short for HyperText
    Transfer Protocol, HTTP is the set of rules for transferring data over the internet.
    In this instance port 80 handles the transfer of data to a web page.
  prefs: []
  type: TYPE_NORMAL
- en: Our sketch includes some HTML (HyperText Markup Language) code, which tells
    a web browser how to display an internet page. If you right-click on any web page
    and select Inspect, you can see some of the HTML code behind that page.
  prefs: []
  type: TYPE_NORMAL
- en: The section of our sketch that includes HTML code is as follows and produces
    the web page displayed in [Figure 23-3](ch23.xhtml#ch23fig3).
  prefs: []
  type: TYPE_NORMAL
- en: client.println("HTTP/1.1 200 OK");
  prefs: []
  type: TYPE_NORMAL
- en: 'client.println("Content-Type: text/html");'
  prefs: []
  type: TYPE_NORMAL
- en: client.println();
  prefs: []
  type: TYPE_NORMAL
- en: client.print("<center><br><h1>Internet Controlled LED</h1><br><br><br><FORM>");
  prefs: []
  type: TYPE_NORMAL
- en: client.print("<P> <INPUT type=\"submit\" name=\"status\"value=\"ON\">");
  prefs: []
  type: TYPE_NORMAL
- en: client.print("<P> <INPUT type=\"submit\" name=\"status\"value=\"OFF\">");
  prefs: []
  type: TYPE_NORMAL
- en: client.print("</FORM></center>");
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 23-3:** Our simple web page to control the LED'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f23-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Attach the Ethernet shield on top of the Arduino board as shown in [Figure 23-4](ch23.xhtml#ch23fig4).
    The board fits directly on top of the Arduino, so gently press the legs of the
    shield in place with the holes of the Arduino beneath.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 23-4:** Attach the Ethernet shield on top of the Arduino board.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f23-04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Insert the LED into the breadboard with the legs straddling the center break
    of the board. Then, as shown in the following table, connect the shorter, negative
    leg of the LED to the GND rail of the breadboard via a 220-ohm resistor, and connect
    the longer, positive leg of the LED to pin 7 on the Arduino/Ethernet shield. Connect
    the GND rail of the breadboard to Arduino GND.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|  **LED**  | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Negative leg | GND via 220-ohm resistor |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Positive leg | Pin 7 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: With the Ethernet shield attached on top of the Arduino, connect the shield
    to your router with the Ethernet cable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Take note of your IP address; it will be different from mine shown in [Figure
    23-5](ch23.xhtml#ch23fig5).*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Attach the Arduino to your PC and upload the code at the end of the project
    using the IDE. Once the code is uploaded, open the IDE Serial Monitor in order
    to ascertain the *IP address*—a unique string of numbers to identify a device
    attached to the internet—of the Arduino, which is acting as our server. You should
    see something similar to [Figure 23-5](ch23.xhtml#ch23fig5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 23-5:** The IP address of the Arduino shield will be shown in the
    Serial Monitor.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f23-05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Open any web browser and enter your IP address. You should see a web page with
    an On and an Off button, as shown earlier in [Figure 23-3](ch23.xhtml#ch23fig3).
    Press the On button to light the LED and press the Off button to switch it off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This project will also work when you are not connected to your local network,
    as long as you have port 80 open on your internet router. Many internet service
    providers (ISPs) have this port blocked for security reasons, so follow the instructions
    from your ISP to change this if required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Carry out this function only if you are aware of the security risks and how
    to minimize them.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Confirm that your setup matches the circuit diagram in [Figure 23-6](ch23.xhtml#ch23fig6),
    and then upload the code in “[The Sketch](ch23.xhtml#ch00lev1sec98)” on [page
    208](ch23.xhtml#page_208).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 23-6:** The circuit diagram for the internet-controlled LED'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f23-06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sketch calls on the SPI and Ethernet libraries to control communication
    with the internet. We define the MAC address for the shield. This is the line
    you need to change if your shield came with its own MAC address; if not, the address
    given earlier in this project and shown in the code should work for you. We then
    set the server to use port 80 and define pin 7 on the Arduino as the LED pin.
  prefs: []
  type: TYPE_NORMAL
- en: The setup defines the LED pin as an output, begins the Ethernet shield, and
    starts serial communication so we can see the IP address of our server. The loop
    sets up our web page to the browser once it is called and waits for an input on
    the browser task bar. When the On button is pressed, the server tells the Arduino
    to set the LED pin as `HIGH` and the LED will light. When the Off button is pressed,
    the power to the LED is `LOW` and the LED will turn off.
  prefs: []
  type: TYPE_NORMAL
- en: You could easily change the LED for a relay switch such as the one used in Project
    12 to control a larger-voltage device.
  prefs: []
  type: TYPE_NORMAL
- en: '#include <SPI.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <Ethernet.h>'
  prefs: []
  type: TYPE_NORMAL
- en: // MAC address for shield
  prefs: []
  type: TYPE_NORMAL
- en: byte mac[] = {0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED};
  prefs: []
  type: TYPE_NORMAL
- en: EthernetServer server(80);  // Using port 80
  prefs: []
  type: TYPE_NORMAL
- en: int led = 7;  // LED attached to pin 7
  prefs: []
  type: TYPE_NORMAL
- en: void setup() {
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(led, OUTPUT); // LED set as an output
  prefs: []
  type: TYPE_NORMAL
- en: Ethernet.begin(mac);  // Start the Ethernet shield
  prefs: []
  type: TYPE_NORMAL
- en: server.begin();
  prefs: []
  type: TYPE_NORMAL
- en: Serial.begin(9600);  // Start serial communication
  prefs: []
  type: TYPE_NORMAL
- en: Serial.println("Server address:");  // Print server address
  prefs: []
  type: TYPE_NORMAL
- en: // (Arduino shield)
  prefs: []
  type: TYPE_NORMAL
- en: Serial.println(Ethernet.localIP());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void loop() {
  prefs: []
  type: TYPE_NORMAL
- en: EthernetClient client = server.available();
  prefs: []
  type: TYPE_NORMAL
- en: if (client) {
  prefs: []
  type: TYPE_NORMAL
- en: boolean currentLineIsBlank = true;
  prefs: []
  type: TYPE_NORMAL
- en: String buffer = "";
  prefs: []
  type: TYPE_NORMAL
- en: while (client.connected()) {
  prefs: []
  type: TYPE_NORMAL
- en: if (client.available()) {
  prefs: []
  type: TYPE_NORMAL
- en: char c = client.read(); // Read from the Ethernet shield
  prefs: []
  type: TYPE_NORMAL
- en: buffer += c; // Add character to string buffer
  prefs: []
  type: TYPE_NORMAL
- en: // Client sent request, now waiting for response
  prefs: []
  type: TYPE_NORMAL
- en: if (c == '\n' && currentLineIsBlank) {
  prefs: []
  type: TYPE_NORMAL
- en: client.println("HTTP/1.1 200 OK"); // HTTP response
  prefs: []
  type: TYPE_NORMAL
- en: 'client.println("Content-Type: text/html");'
  prefs: []
  type: TYPE_NORMAL
- en: client.println(); // HTML code
  prefs: []
  type: TYPE_NORMAL
- en: client.print("<center><br><h1>Internet Controlled LED</h1><br><br><br><FORM>");
  prefs: []
  type: TYPE_NORMAL
- en: client.print("<P> <INPUT type=\"submit\" name=\"status\"value=\"ON\">");
  prefs: []
  type: TYPE_NORMAL
- en: client.print("<P> <INPUT type=\"submit\" name=\"status\"value=\"OFF\">");
  prefs: []
  type: TYPE_NORMAL
- en: client.print("</FORM></center>");
  prefs: []
  type: TYPE_NORMAL
- en: break;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (c == '\n') {
  prefs: []
  type: TYPE_NORMAL
- en: currentLineIsBlank = true;
  prefs: []
  type: TYPE_NORMAL
- en: buffer = "";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else if (c == '\r') { // Command from webpage
  prefs: []
  type: TYPE_NORMAL
- en: // Did the on button get pressed
  prefs: []
  type: TYPE_NORMAL
- en: if (buffer.indexOf("GET /?status=ON") >= 0)
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(led, HIGH);
  prefs: []
  type: TYPE_NORMAL
- en: // Did the off button get pressed
  prefs: []
  type: TYPE_NORMAL
- en: if (buffer.indexOf("GET /?status=OFF") >= 0)
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(led, LOW);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else {
  prefs: []
  type: TYPE_NORMAL
- en: currentLineIsBlank = false;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: client.stop(); // End server
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *The code compiles, but the LED does not light as expected.*'
  prefs: []
  type: TYPE_NORMAL
- en: • First, make sure you’ve connected the GND wire from the Arduino to the correct
    breadboard power rail and that the Arduino has power connected.
  prefs: []
  type: TYPE_NORMAL
- en: • Check that the resistor is inserted fully and lines up with the corresponding
    LED leg.
  prefs: []
  type: TYPE_NORMAL
- en: • Try checking that the project is working by connecting to your local area
    network and using that PC to connect to the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** *You receive an error when calling the web page.*'
  prefs: []
  type: TYPE_NORMAL
- en: • Make sure you have entered the IP address of the server exactly as you read
    it in the steps given earlier.
  prefs: []
  type: TYPE_NORMAL
- en: • It is best to check the project is working by connecting to your local area
    network and using that PC to connect to the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: '• If the project worked when you connected it to your local area network, but
    you receive an HTTP 403 error when connecting to the internet externally, then
    your ISP is blocking incoming traffic. You could add *port forwarding* to your
    router for port 80\. This will differ for every device, so check with your ISP
    for detailed instructions. Do a quick internet search with your ISP and “port
    forwarding” as terms and follow the instructions, but be aware: this can compromise
    the security of your PC and should be done only if you understand the risks and
    are able to protect your network.'
  prefs: []
  type: TYPE_NORMAL
- en: '**24'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Voice-Controlled LED**
  prefs: []
  type: TYPE_NORMAL
- en: In this project we’ll use a bluetooth module, a smartphone, and a voice recognition
    app to control an LED with vocal commands.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0211-01.jpg)![Image](../images/p0212-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Breadboard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jumper wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HC-06 Bluetooth module**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**220-ohm resistor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Android smartphone**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bluetooth wireless technology uses radio waves to transmit and exchange data
    over short distances. Smartphones, laptops, and multimedia devices such as speakers
    use Bluetooth as a common standard. We’ll use the inexpensive HC-06 Bluetooth
    module ([Figure 24-1](ch24.xhtml#ch24fig1)) to pair (connect) our Arduino to a
    smartphone so we can turn an LED on and off remotely using a voice recognition
    app. This module has six pins, but we’ll just use the middle four. The pins should
    be labeled on the front.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 24-1:** The HC-06 Bluetooth module'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f24-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The app we’ll use is Arduino Bluetooth Control from BroxCode, available to download
    for free on the Google Play store for Android devices. There are many other similar
    free apps available for both Android and Apple devices and the principles of use
    should be the same for each, but the BroxCode app has some additional features
    that we’re using in this project, such as voice recognition through Google Assistant.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you build the Bluetooth controller, you need to upload the code to the
    Arduino. This is because the serial communication from your PC to the Arduino
    uses the same pins that we’ll be connecting to the Bluetooth module.
  prefs: []
  type: TYPE_NORMAL
- en: Upload the code in “[The Sketch](ch24.xhtml#ch00lev1sec103)” on [page 220](ch24.xhtml#page_220),
    and then insert the Bluetooth module into the breadboard and connect VCC to the
    positive power rail of the breadboard, GND to the GND power rail, TXD to Arduino
    pin 0 (RX), and RXD to Arduino pin 1 (TX), as shown in the following table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **HC-06 BLUETOOTH MODULE** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| VCC | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| TXD | Pin 0 (RX) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| RXD | Pin 1 (TX) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Insert the LED into the breadboard with the legs straddling the center break.
    Use a 220-ohm resistor to connect the shorter, negative leg of the LED to the
    GND rail of the breadboard. Connect the longer, positive leg of the LED to pin
    9 of the Arduino using a jumper wire, as outlined in the following table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **LED** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Positive leg | Pin 9 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Negative leg | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Connect the GND rail of the breadboard to Arduino GND and the positive rail
    to Arduino +5V.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that your build matches the diagram in [Figure 24-2](ch24.xhtml#ch24fig2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 24-2:** The circuit diagram for the Bluetooth voice-controlled LED'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f24-02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**ARDUINO BLUETOOTH CONTROL**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Arduino Bluetooth Control app offers six control options, all of which send
    data to the Arduino via different methods ([Figure 24-3](ch24.xhtml#ch24fig3)).
    You can customize each to your own preferences.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 24-3:** The menu screen on the Arduino Bluetooth Control app'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f24-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • **Arrow Keys:** Here you’ll find customizable arrow buttons.
  prefs: []
  type: TYPE_NORMAL
- en: • **Terminal:** This is a classic terminal for sending and receiving data, displayed
    with a timestamp corresponding to each action.
  prefs: []
  type: TYPE_NORMAL
- en: • **Accelerometer:** This tool reads movement using the gesture sensor of your
    phone.
  prefs: []
  type: TYPE_NORMAL
- en: • **Buttons and Slider:** Here you’ll find six fully customizable buttons and
    a slider view that shows up when you rotate your device. You can set the range
    of the data for this slider.
  prefs: []
  type: TYPE_NORMAL
- en: • **Metrics:** This tool is optimized to receive data via the `println()` function
    of the Arduino, which allows your paired phone to receive notifications by SMS
    from another phone. You only need to specify the number in the Settings section.
    This function is explained further shortly.
  prefs: []
  type: TYPE_NORMAL
- en: • **Voice Control:** This great tool uses the Google voice command on your Android
    device to let you customize your own vocal commands and use them to control the
    Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Now you need to download the Arduino Bluetooth Control app from the Google Play
    app store and set it up.
  prefs: []
  type: TYPE_NORMAL
- en: Go to *[https://play.google.com/store/](https://play.google.com/store/)* and
    search for “[Arduino Bluetooth Control](ch24.xhtml#ch00lev1sec102).” You’ll probably
    get several apps in your results, but the one you want is precisely named “[Arduino
    Bluetooth Control](ch24.xhtml#ch00lev1sec102),” as shown in [Figure 24-4](ch24.xhtml#ch24fig4).
    Click **Install** to download it to your device. The app is free but does include
    some ads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 24-4:** Arduino Bluetooth Control from BroxCode on Google Play'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f24-04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Once you’ve downloaded the app, power your Arduino to start the Bluetooth module.
    Go to your Bluetooth settings on your smartphone, turn on Bluetooth, and select
    **MORE SETTINGS** to view visible devices. You should see the HC-06 module as
    an available device. Select it to pair with your phone. You’ll be asked for a
    password to connect: the default for the module is 1234 or in some instances 0000,
    so try both if the first doesn’t work.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When your device is paired, open the Arduino Bluetooth Control app. From the
    window that appears showing all available devices, select the HC-06 module, as
    shown in [Figure 24-5](ch24.xhtml#ch24fig5). You won’t need to choose the device
    every time you power up—the app will remember it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 24-5:** Pairing your device'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f24-05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: You’re going to use the Voice Control function to turn the LED off and on when
    you speak certain commands into the smartphone. Select the Voice Control function,
    and you’ll be taken to the Settings menu, shown in [Figure 24-6](ch24.xhtml#ch24fig6).
    Choose **Vocal commands configuration**. We’ll use this to define our input and
    output functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 24-6:** Selecting the Vocal commands configuration setting'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f24-06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Select **Vocal command n°1**, as shown in [Figure 24-7](ch24.xhtml#ch24fig7).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 24-7:** Setting your first voice command'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f24-07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Here you give the input that will trigger the first function. Enter `light on`
    as text, as shown in the screen on the left in [Figure 24-8](ch24.xhtml#ch24fig8).
    The app will then ask for the output data to send to the Arduino when you give
    the input command. On this screen, enter `1` for on or `HIGH`, as we’ve seen in
    previous LED projects (shown in the screen on the right in [Figure 24-8](ch24.xhtml#ch24fig8)).
    When the app hears the vocal command “light on” through the phone, the number
    `1` will be sent to the Arduino as an input, and power will be sent to the LED
    to light it up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Carry out the same steps to define Vocal command n°2 with the input `light off`
    and the output data `0`, as shown in [Figure 24-9](ch24.xhtml#ch24fig9). This
    command will switch the LED off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you’ve configured your commands so that when you press the voice command
    function and tap the microphone button on the screen, the app will listen for
    your command and, depending on the input, switch the LED on or off.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 24-8:** Configuring our LED to turn on with the voice command “light
    on”'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f24-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 24-9:** Configuring the “light off” function'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f24-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The app also has a function to let you control the Arduino using SMS. Once the
    app is launched and connected to the Arduino, you can send data to the Arduino
    by sending an SMS text to the phone paired with the Bluetooth module, as long
    as the paired phone is in range of the module. Simply text `Arduino 1` to the
    phone connected to the Arduino, and that phone will send `1` to the module to
    light your LED. Text `Arduino 0`, and a `0` will be sent to switch your LED off.
    This way you can have control through Bluetooth from anywhere in the world!
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sketch for this project is quite simple. It starts by creating a variable
    to hold the data from the Bluetooth module. It sets the data rate for serial communication
    to `9600` and sets pin 9 as an output for our LED. In the loop, it checks for
    data to be sent to the Arduino from the Bluetooth module. The loop reads the data,
    and also sends it to the Serial Monitor so we can check that it’s working correctly.
    If the Arduino receives a `1` from the app, pin 9 will be set to `HIGH`, which
    will turn on the LED. If the Arduino receives a `0`, pin 9 is set as `LOW` and
    the LED is turned off.
  prefs: []
  type: TYPE_NORMAL
- en: Using these principles, you could add numerous relays in place of the LED and
    begin to automate your home from anywhere. You could set it up to turn on your
    living room lights before you enter your house, set the thermostat when you’re
    on your way home, or have your favorite music already playing as you walk in the
    door.
  prefs: []
  type: TYPE_NORMAL
- en: char data = 0; // Create a variable for data
  prefs: []
  type: TYPE_NORMAL
- en: void setup() {
  prefs: []
  type: TYPE_NORMAL
- en: Serial.begin(9600); // Data rate for serial communication
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(9, OUTPUT); // Set pin 9 as an output
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void loop() {
  prefs: []
  type: TYPE_NORMAL
- en: if (Serial.available() > 0) { // Send data
  prefs: []
  type: TYPE_NORMAL
- en: data = Serial.read(); // Read incoming data and
  prefs: []
  type: TYPE_NORMAL
- en: // store it into variable data
  prefs: []
  type: TYPE_NORMAL
- en: Serial.print(data); // Print data value to the Serial Monitor
  prefs: []
  type: TYPE_NORMAL
- en: Serial.print("\n"); // Start a new line
  prefs: []
  type: TYPE_NORMAL
- en: if (data == '1') // If value is 1, turn on LED
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(9, HIGH);
  prefs: []
  type: TYPE_NORMAL
- en: else if (data == '0') // If value is 0, turn off LED
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(9, LOW);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *The code compiles, but the LED does not light.*'
  prefs: []
  type: TYPE_NORMAL
- en: • Make sure you’ve connected the GND and power pins from the Arduino to the
    correct breadboard power rails and that the Arduino has power connected.
  prefs: []
  type: TYPE_NORMAL
- en: • Check that the LED is inserted the correct way, with the longer leg connected
    to the positive power and the shorter leg to GND. Check that the resistors are
    inserted fully and line up with the corresponding LED leg.
  prefs: []
  type: TYPE_NORMAL
- en: • With the project powered and connected to your PC, open the Arduino IDE Serial
    Monitor to see if the Arduino is receiving data from the app. If you don’t see
    data streaming in the Serial Monitor, double-check that the TXD of the module
    is connected to RX of the Arduino and the RXD of the module to Arduino TX.
  prefs: []
  type: TYPE_NORMAL
- en: • If the app does not work when opened on your smartphone, check the compatibility
    of your phone with the app on the developer’s site. You may need to use an alternative
    app.
  prefs: []
  type: TYPE_NORMAL
- en: • The data set in your app must match the data expected in the sketch, so make
    sure you’ve used `1` for on and `0` for off.
  prefs: []
  type: TYPE_NORMAL
- en: '**25'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GPS Speedometer**
  prefs: []
  type: TYPE_NORMAL
- en: In this project we’ll connect an OLED screen and GPS module to our Arduino to
    create a simple GPS speedometer that can track your speed from satellites.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0222-01.jpg)![Image](../images/p0223-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Female-to-male jumper wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**OLED monochrome screen (128×64)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ublox NEO-6M GPS module aircraft flight controller and antenna**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LIBRARY REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**U8glib**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Ublox NEO-6M GPS module ([Figure 25-1](ch25.xhtml#ch25fig1)) we’re using
    in this project is an inexpensive device generally used to track the position
    of model aircraft or drones. The module is widely available from the suppliers
    listed in the “[Retailer List](app02.xhtml#ch00lev1sec170)” on [page 249](app02.xhtml#page_249),
    or you can search online for “Ublox NEO-6M GPS module.” Make sure to buy a module
    that also comes with a GPS antenna, as shown in [Figure 25-2](ch25.xhtml#ch25fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 25-1:** The Ublox NEO-6M GPS module'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f25-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 25-2:** The GPS antenna'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f25-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The module uses *GPS (Global Positioning System)* technology to determine the
    exact location of the Arduino and display its speed in kilometers per hour on
    the OLED screen (see Project 19 for more on OLED screens). GPS consists of 32
    satellites orbiting the earth, and it’s used across the globe in everyday technology
    such as car satellite navigation systems, smartphones, and trackers.
  prefs: []
  type: TYPE_NORMAL
- en: The Navstar Global Positioning System was created in the 1970s by the United
    States government initially for military purposes, but it’s now freely accessible
    for anyone with GPS receiver equipment, which probably includes you if you have
    a smartphone. To pinpoint the location of a receiver, the system uses the satellites,
    control stations on the ground, and your equipment to calculate distance, speed,
    and time for signals to be sent and received—with these, it can determine your
    location.
  prefs: []
  type: TYPE_NORMAL
- en: The Ublox NEO-6M GPS module receives satellite signals continuously and sends
    them to the Arduino to pinpoint your location. As soon as you move, your speed
    is sent to the OLED screen in kilometers per hour, serving as our speedometer.
  prefs: []
  type: TYPE_NORMAL
- en: While the functionality of this project is quite complex, the build is very
    simple. The board comes with the header pins separate, so you need to solder these
    in place before beginning. See the “[Quick Soldering Guide](pref02.xhtml#ch00lev1sec123)”
    on [page 12](pref02.xhtml#page_12) if you need soldering guidance. The board has
    all the GPS circuitry built in, but you’ll need to clip the GPS antenna in place;
    I’ll show you how in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take the OLED monochrome screen shown in [Figure 25-3](ch25.xhtml#ch25fig3)
    and, using female-to-male jumper wires, make the connections in the following
    table. The OLED screen uses 3.3V, so make sure you connect it to Arduino 3.3V,
    not 5V, or you could damage the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 25-3:** The OLED monochrome screen displays the speed of movement
    in kilometers per hour (digit on the right).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f25-03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '|  **OLED SCREEN**  | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| VCC | +3.3V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| SCL | Pin A5 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| SDA | Pin A4 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: The GPS module uses the RX and TX pins of the Arduino for communication, but
    you also need these pins when uploading a sketch from your PC. Upload the code
    in “[The Sketch](ch25.xhtml#ch00lev1sec107)” on [page 227](ch25.xhtml#page_227)
    now so those pins will be free. Connect the Arduino to your PC. Remember to first
    download the U8glib library and add it to the relevant folder in the Arduino IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the sketch uploaded, disconnect the Arduino from your PC and attach the
    GPS VCC to Arduino +5V, GND to GND, GPS TX to Arduino pin 0 (RX), and GPS RX to
    Arduino pin 1 (TX), as indicated in the following table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **GPS MODULE** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| VCC | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| TX | Pin 0 (RX) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| RX | Pin 1 (TX) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Clip the end of the antenna onto the module, as shown in [Figure 25-4](ch25.xhtml#ch25fig4).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 25-4:** Clip the end of the antenna to the socket on the GPS module.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f25-04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Confirm your setup matches the circuit diagram in [Figure 25-5](ch25.xhtml#ch25fig5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 25-5:** The circuit diagram for the GPS speedometer'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f25-05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Connect power to your Arduino, and the GPS speedometer is ready to use. The
    antenna needs to be facing upward to work, as shown in [Figure 25-4](ch25.xhtml#ch25fig4),
    and works best outdoors because the GPS module requires line of sight with the
    orbiting satellites in order to function properly (though I’ve also had success
    when close to a window indoors, so experiment to see what works for you).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The GPS module will take about 30 seconds or so to connect to the satellites.
    When the connection is successful, the module LED will blink and the symbol at
    the top left of the OLED screen will spin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sketch first calls on the U8glib library and then defines the OLED so we
    can control our screen. We define the GPS module as a serial connection, and tell
    it what information we want to receive from the satellites.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember to disconnect the Arduino 0 (RX) pin of your build before uploading
    the sketch and then reconnect when running.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section of code contains a long list of data. This section is quite
    complex, and the data sheet for the Ublox NEO-6M details all the information that
    can be received by the module if you’re interested. For the purposes of our project,
    the code at ➊ contains the relevant data: the NAV-PVT data that includes the number
    of satellites the module is connecting to and the ground speed at which your GPS
    speedometer is moving. The remaining information requests are not used and are
    set as `off`.'
  prefs: []
  type: TYPE_NORMAL
- en: The section that follows defines the NAV-PVT settings with a number of calculations
    to check that the data being received from the satellites is valid.
  prefs: []
  type: TYPE_NORMAL
- en: The loop at the end of the sketch checks to see if data is being received, and
    if so, animates the symbols at the top left of the OLED. The first symbol shows
    that the screen is refreshing correctly, and the second shows that the GPS data
    packet is being received from the satellites. The screen also displays the number
    of satellites it’s connected to at the top left.
  prefs: []
  type: TYPE_NORMAL
- en: If all the data is being received as expected, the ground speed will be shown
    at the top right of the screen in kilometers per hour.
  prefs: []
  type: TYPE_NORMAL
- en: // Sketch reproduced with kind permission from Chris Campbell
  prefs: []
  type: TYPE_NORMAL
- en: /*
  prefs: []
  type: TYPE_NORMAL
- en: 'Connections:'
  prefs: []
  type: TYPE_NORMAL
- en: GPS TX -> Arduino 0 // Disconnect Arduino 0 to upload this sketch
  prefs: []
  type: TYPE_NORMAL
- en: GPS RX -> Arduino 1
  prefs: []
  type: TYPE_NORMAL
- en: Screen SDA -> Arduino A4
  prefs: []
  type: TYPE_NORMAL
- en: Screen SCL -> Arduino A5
  prefs: []
  type: TYPE_NORMAL
- en: '*/'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "U8glib.h" // Call U8glib library to control OLED screen'
  prefs: []
  type: TYPE_NORMAL
- en: U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_DEV_0|U8G_I2C_OPT_NO_ACK|U8G_I2C_OPT_FAST);
    // Fast I2C/TWI
  prefs: []
  type: TYPE_NORMAL
- en: '#define GPS Serial // Define the serial connection as the GPS module'
  prefs: []
  type: TYPE_NORMAL
- en: const unsigned char UBLOX_INIT[] PROGMEM = {
  prefs: []
  type: TYPE_NORMAL
- en: // These lines of code request data from the satellites. Most are disabled and
    turned off.
  prefs: []
  type: TYPE_NORMAL
- en: // Disable NMEA
  prefs: []
  type: TYPE_NORMAL
- en: 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x24,
    // GxGGA off
  prefs: []
  type: TYPE_NORMAL
- en: 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x2B,
    // GxGLL off
  prefs: []
  type: TYPE_NORMAL
- en: 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x02,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x32,
    // GxGSA off
  prefs: []
  type: TYPE_NORMAL
- en: 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x39,
    // GxGSV off
  prefs: []
  type: TYPE_NORMAL
- en: 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x04,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x40,
    // GxRMC off
  prefs: []
  type: TYPE_NORMAL
- en: 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x05,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x47,
    // GxVTG off
  prefs: []
  type: TYPE_NORMAL
- en: // Disable UBX
  prefs: []
  type: TYPE_NORMAL
- en: 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0xDC,
    // NAV-PVT off
  prefs: []
  type: TYPE_NORMAL
- en: 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0xB9,
    // NAV-POSLLH off
  prefs: []
  type: TYPE_NORMAL
- en: 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x13,0xC0,
    // NAV-STATUS off
  prefs: []
  type: TYPE_NORMAL
- en: // Enable UBX—this is the key information we require
  prefs: []
  type: TYPE_NORMAL
- en: ➊   0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x18,0xE1,
    //NAV-PVT on
  prefs: []
  type: TYPE_NORMAL
- en: //0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x01,0x00,0x00,0x00,0x00,0x13,0xBE,
    //NAV-POSLLH on
  prefs: []
  type: TYPE_NORMAL
- en: //0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x03,0x00,0x01,0x00,0x00,0x00,0x00,0x14,0xC5,
    //NAV-STATUS on
  prefs: []
  type: TYPE_NORMAL
- en: // Rate
  prefs: []
  type: TYPE_NORMAL
- en: 0xB5,0x62,0x06,0x08,0x06,0x00,0x64,0x00,0x01,0x00,0x01,0x00,0x7A,0x12,    //
    (10Hz)
  prefs: []
  type: TYPE_NORMAL
- en: // 0xB5,0x62,0x06,0x08,0x06,0x00,0xC8,0x00,0x01,0x00,0x01,0x00,0xDE,0x6A, //
    (5Hz)
  prefs: []
  type: TYPE_NORMAL
- en: // 0xB5,0x62,0x06,0x08,0x06,0x00,0xE8,0x03,0x01,0x00,0x01,0x00,0x01,0x39  //
    (1Hz)
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: const unsigned char UBX_HEADER[] = { 0xB5, 0x62 };
  prefs: []
  type: TYPE_NORMAL
- en: struct NAV_PVT { // This sets the GPS navigation data
  prefs: []
  type: TYPE_NORMAL
- en: unsigned char cls;
  prefs: []
  type: TYPE_NORMAL
- en: unsigned char id;
  prefs: []
  type: TYPE_NORMAL
- en: unsigned short len;
  prefs: []
  type: TYPE_NORMAL
- en: unsigned long iTOW; // GPS time of week of the navigation epoch (ms)
  prefs: []
  type: TYPE_NORMAL
- en: unsigned short year;     // Year (UTC)
  prefs: []
  type: TYPE_NORMAL
- en: unsigned char month;     // Month, range 1..12 (UTC)
  prefs: []
  type: TYPE_NORMAL
- en: unsigned char day;       // Day of month, range 1..31 (UTC)
  prefs: []
  type: TYPE_NORMAL
- en: unsigned char hour;      // Hour of day, range 0..23 (UTC)
  prefs: []
  type: TYPE_NORMAL
- en: unsigned char minute;    // Minute of hour, range 0..59 (UTC)
  prefs: []
  type: TYPE_NORMAL
- en: unsigned char second;    // Seconds of minute, range 0..60 (UTC)
  prefs: []
  type: TYPE_NORMAL
- en: char valid;              // Validity Flags (see graphic below)
  prefs: []
  type: TYPE_NORMAL
- en: unsigned long tAcc;      // Time accuracy estimate (UTC) (ns)
  prefs: []
  type: TYPE_NORMAL
- en: long nano;               // Fraction of second, range -1e9 .. 1e9 (UTC) (ns)
  prefs: []
  type: TYPE_NORMAL
- en: unsigned char fixType;   // GNSSfix Type, range 0..5
  prefs: []
  type: TYPE_NORMAL
- en: char flags;              // Fix Status Flags
  prefs: []
  type: TYPE_NORMAL
- en: unsigned char reserved1; // Reserved
  prefs: []
  type: TYPE_NORMAL
- en: unsigned char numSV;     // Number of satellites used in Nav Solution
  prefs: []
  type: TYPE_NORMAL
- en: long lon;           // Longitude (deg)
  prefs: []
  type: TYPE_NORMAL
- en: long lat;           // Latitude (deg)
  prefs: []
  type: TYPE_NORMAL
- en: long height;        // Height above Ellipsoid (mm)
  prefs: []
  type: TYPE_NORMAL
- en: long hMSL;          // Height above mean sea level (mm)
  prefs: []
  type: TYPE_NORMAL
- en: unsigned long hAcc; // Horizontal Accuracy Estimate (mm)
  prefs: []
  type: TYPE_NORMAL
- en: unsigned long vAcc; // Vertical Accuracy Estimate (mm)
  prefs: []
  type: TYPE_NORMAL
- en: long velN;                // NED north velocity (mm/s)
  prefs: []
  type: TYPE_NORMAL
- en: long velE;                // NED east velocity (mm/s)
  prefs: []
  type: TYPE_NORMAL
- en: long velD;                // NED down velocity (mm/s)
  prefs: []
  type: TYPE_NORMAL
- en: long gSpeed;              // Ground Speed (2-D) (mm/s)
  prefs: []
  type: TYPE_NORMAL
- en: long heading;             // Heading of motion 2-D (deg)
  prefs: []
  type: TYPE_NORMAL
- en: unsigned long sAcc;       // Speed accuracy estimate
  prefs: []
  type: TYPE_NORMAL
- en: unsigned long headingAcc; // Heading accuracy estimate
  prefs: []
  type: TYPE_NORMAL
- en: unsigned short pDOP;      // Position dilution of precision
  prefs: []
  type: TYPE_NORMAL
- en: short reserved2;          // Reserved
  prefs: []
  type: TYPE_NORMAL
- en: unsigned long reserved3;  // Reserved
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: NAV_PVT pvt;
  prefs: []
  type: TYPE_NORMAL
- en: void calcChecksum(unsigned char* CK) {
  prefs: []
  type: TYPE_NORMAL
- en: memset(CK, 0, 2);
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < (int)sizeof(NAV_PVT); i++) {
  prefs: []
  type: TYPE_NORMAL
- en: CK[0] += ((unsigned char*)(&pvt))[i];
  prefs: []
  type: TYPE_NORMAL
- en: CK[1] += CK[0];
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: long numGPSMessagesReceived = 0;
  prefs: []
  type: TYPE_NORMAL
- en: bool processGPS() {
  prefs: []
  type: TYPE_NORMAL
- en: static int fpos = 0;
  prefs: []
  type: TYPE_NORMAL
- en: static unsigned char checksum[2];
  prefs: []
  type: TYPE_NORMAL
- en: const int payloadSize = sizeof(NAV_PVT);
  prefs: []
  type: TYPE_NORMAL
- en: while ( GPS.available() ) {
  prefs: []
  type: TYPE_NORMAL
- en: byte c = GPS.read();
  prefs: []
  type: TYPE_NORMAL
- en: if ( fpos < 2 ) {
  prefs: []
  type: TYPE_NORMAL
- en: if ( c == UBX_HEADER[fpos] )
  prefs: []
  type: TYPE_NORMAL
- en: fpos++;
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: fpos = 0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else {
  prefs: []
  type: TYPE_NORMAL
- en: if ( (fpos-2) < payloadSize )
  prefs: []
  type: TYPE_NORMAL
- en: ((unsigned char*)(&pvt))[fpos-2] = c;
  prefs: []
  type: TYPE_NORMAL
- en: fpos++;
  prefs: []
  type: TYPE_NORMAL
- en: if ( fpos == (payloadSize+2) ) {
  prefs: []
  type: TYPE_NORMAL
- en: calcChecksum(checksum);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else if ( fpos == (payloadSize+3) ) {
  prefs: []
  type: TYPE_NORMAL
- en: if ( c != checksum[0] )
  prefs: []
  type: TYPE_NORMAL
- en: fpos = 0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else if ( fpos == (payloadSize+4) ) {
  prefs: []
  type: TYPE_NORMAL
- en: fpos = 0;
  prefs: []
  type: TYPE_NORMAL
- en: if ( c == checksum[1] ) {
  prefs: []
  type: TYPE_NORMAL
- en: return true;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else if ( fpos > (payloadSize+4) ) {
  prefs: []
  type: TYPE_NORMAL
- en: fpos = 0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return false;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void setup() {
  prefs: []
  type: TYPE_NORMAL
- en: GPS.begin(9600);
  prefs: []
  type: TYPE_NORMAL
- en: u8g.setColorIndex(1);
  prefs: []
  type: TYPE_NORMAL
- en: // Send configuration data in UBX protocol
  prefs: []
  type: TYPE_NORMAL
- en: for (unsigned int i = 0; i < sizeof(UBLOX_INIT); i++) {
  prefs: []
  type: TYPE_NORMAL
- en: GPS.write( pgm_read_byte(UBLOX_INIT+i) );
  prefs: []
  type: TYPE_NORMAL
- en: delay(5); // Simulate a 38400baud pace (or less),
  prefs: []
  type: TYPE_NORMAL
- en: // or otherwise commands are not accepted by the device
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: long gSpeed = 0;
  prefs: []
  type: TYPE_NORMAL
- en: int numSV = 0;
  prefs: []
  type: TYPE_NORMAL
- en: unsigned long lastScreenUpdate = 0;
  prefs: []
  type: TYPE_NORMAL
- en: char speedBuf[16];
  prefs: []
  type: TYPE_NORMAL
- en: char satsBuf[16];
  prefs: []
  type: TYPE_NORMAL
- en: char* spinner = "/-\\|"; // Symbol for the spinner on screen to
  prefs: []
  type: TYPE_NORMAL
- en: // show communication
  prefs: []
  type: TYPE_NORMAL
- en: byte screenRefreshSpinnerPos = 0;
  prefs: []
  type: TYPE_NORMAL
- en: byte gpsUpdateSpinnerPos = 0;
  prefs: []
  type: TYPE_NORMAL
- en: void loop() {
  prefs: []
  type: TYPE_NORMAL
- en: if (processGPS()) {
  prefs: []
  type: TYPE_NORMAL
- en: numSV = pvt.numSV;
  prefs: []
  type: TYPE_NORMAL
- en: gSpeed = pvt.gSpeed;
  prefs: []
  type: TYPE_NORMAL
- en: gpsUpdateSpinnerPos = (gpsUpdateSpinnerPos + 1) % 4;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: unsigned long now = millis();
  prefs: []
  type: TYPE_NORMAL
- en: if (now - lastScreenUpdate > 100) {
  prefs: []
  type: TYPE_NORMAL
- en: updateScreen();
  prefs: []
  type: TYPE_NORMAL
- en: lastScreenUpdate = now;
  prefs: []
  type: TYPE_NORMAL
- en: screenRefreshSpinnerPos = (screenRefreshSpinnerPos + 1) % 4;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void draw() {
  prefs: []
  type: TYPE_NORMAL
- en: u8g.setFont(u8g_font_courB24);
  prefs: []
  type: TYPE_NORMAL
- en: u8g.drawStr( 36, 45, speedBuf);
  prefs: []
  type: TYPE_NORMAL
- en: u8g.setFont(u8g_font_fur11);
  prefs: []
  type: TYPE_NORMAL
- en: u8g.drawStr( 2, 12, satsBuf);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void updateScreen() {
  prefs: []
  type: TYPE_NORMAL
- en: int kmh = gSpeed * 0.0036;
  prefs: []
  type: TYPE_NORMAL
- en: sprintf(speedBuf, "%3d", kmh);
  prefs: []
  type: TYPE_NORMAL
- en: sprintf(satsBuf, "%c %c %d", spinner[screenRefreshSpinnerPos], spinner[gpsUpdateSpinnerPos],
    numSV);
  prefs: []
  type: TYPE_NORMAL
- en: u8g.firstPage();
  prefs: []
  type: TYPE_NORMAL
- en: do {
  prefs: []
  type: TYPE_NORMAL
- en: draw();
  prefs: []
  type: TYPE_NORMAL
- en: '} while( u8g.nextPage() );'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *The code compiles, but the expected information is not shown onscreen.*'
  prefs: []
  type: TYPE_NORMAL
- en: • If nothing shows on the OLED screen, recheck that your wiring matches [Figure
    25-5](ch25.xhtml#ch25fig5); it’s quite easy to reverse the TX and RX wires accidentally.
  prefs: []
  type: TYPE_NORMAL
- en: • The symbols at the top left of the screen will rotate to show the screen is
    working correctly and that the GPS module is receiving data. If the far-left symbol
    spins but not the GPS symbol, you have your TX and RX wires crossed; recheck the
    wiring for the module.
  prefs: []
  type: TYPE_NORMAL
- en: • The GPS module works best outdoors and should have line of sight to the satellites
    orbiting the earth, so try repositioning the module until you get a reading. It
    can take 30–60 seconds to get a stable reading.
  prefs: []
  type: TYPE_NORMAL
- en: • Remember that the OLED screen should be connected to 3.3V and not 5V.
  prefs: []
  type: TYPE_NORMAL
