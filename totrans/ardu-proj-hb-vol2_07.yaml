- en: '**Smart Machines**'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**智能机器**'
- en: '**22'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**22**'
- en: Ultrasonic Robot**
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 超声波机器人**
- en: In this project we’ll combine an ultrasonic sensor with two DC motors and a
    servomotor to create a simple object-avoiding robot.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，我们将结合超声波传感器、两台直流电机和一台伺服电机，创建一个简单的避障机器人。
- en: '![Image](../images/p0190-01.jpg)![Image](../images/p0191-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/p0190-01.jpg)![图片](../images/p0191-01.jpg)'
- en: '**PARTS REQUIRED**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**所需零件**'
- en: '**Arduino board**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**Arduino 主板**'
- en: '**Jumper wires**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**跳线**'
- en: '**L293d motor shield**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**L293d 电机驱动板**'
- en: '**2 DC motors and wheels[*](ch22.xhtml#note01)**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**2 个直流电机和车轮[*](ch22.xhtml#note01)**'
- en: '**HC-SR04 ultrasonic sensor**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**HC-SR04 超声波传感器**'
- en: '**9V AA battery pack**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**9V AA 电池包**'
- en: '**Robot base with fittings[*](ch22.xhtml#note01)**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**带配件的机器人底座[*](ch22.xhtml#note01)**'
- en: '**Center wheel[*](ch22.xhtml#note01)**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**中心轮[*](ch22.xhtml#note01)**'
- en: '**Tower Pro SG90 9g servomotor**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tower Pro SG90 9g 伺服电机**'
- en: '**LIBRARIES REQUIRED**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**所需库**'
- en: '**Servo**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**伺服电机**'
- en: '**NewPing**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**NewPing**'
- en: '**Adafruit Motor Shield V1**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**Adafruit 电机驱动板 V1**'
- en: '**[*](ch22.xhtml#note_01) These items can be purchased as part of a kit**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**[*](ch22.xhtml#note_01) 这些物品可以作为套件的一部分购买**'
- en: '**HOW IT WORKS**'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**工作原理**'
- en: The key parts of the ultrasonic robot are the HC-SR04 ultrasonic sensor, L293d
    motor shield, and the motors. The motors I used were purchased as part of a kit;
    if you search online for “Arduino robot kit,” you too should be able to find a
    kit that contains the motors and wheels, base, battery pack, center wheel, and
    fittings needed. The one I bought is called the “2WD Smart Motor Robot Car Chassis
    Kit for Arduino 1:48,” so try a few of those keywords until you find something
    similar to the kit in [Figure 22-1](ch22.xhtml#ch22fig1). Also try the suppliers
    listed in the “[Retailer List](app02.xhtml#ch00lev1sec170)” on [page 249](app02.xhtml#page_249).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 超声波机器人的关键部件是 HC-SR04 超声波传感器、L293d 电机驱动板和电机。我使用的电机是作为一个套件购买的；如果你在网上搜索“Arduino
    机器人套件”，你也应该能够找到包含电机和车轮、底座、电池包、中心轮及所需配件的套件。我购买的套件名为“2WD 智能电机机器人车底盘套件，适用于 Arduino
    1:48”，因此尝试几个类似的关键词，直到找到与 [图 22-1](ch22.xhtml#ch22fig1) 中的套件相似的东西。还可以尝试 [第 249
    页](app02.xhtml#page_249) 上的 “[零售商列表](app02.xhtml#ch00lev1sec170)” 中列出的供应商。
- en: '**FIGURE 22-1:** Robot motor kit'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 22-1：** 机器人电机套件'
- en: '![Image](../images/f22-01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f22-01.jpg)'
- en: The ultrasonic sensor sends and receives a signal to determine the distance
    of an object. If there is an object less than 15 centimeters away, the robot will
    stop, look around, turn toward a direction in which it doesn’t sense anything,
    and move in that direction. The ultrasonic sensor is mounted on a servomotor so
    that the robot can move and search for a clear route. For more on how the HC-SR04
    ultrasonic sensor works, see Project 13\. The L293d motor shield fits on top of
    the Arduino and controls the DC motors using the Adafruit Motor Shield library.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 超声波传感器发送和接收信号以测定物体的距离。如果物体距离小于 15 厘米，机器人将停止，四处查看，转向没有感知到任何物体的方向，并朝该方向移动。超声波传感器安装在伺服电机上，使机器人能够移动并寻找清晰的路线。有关
    HC-SR04 超声波传感器工作原理的更多信息，请参见第 13 项工程。L293d 电机驱动板安装在 Arduino 上，使用 Adafruit 电机驱动库控制直流电机。
- en: '**THE BUILD**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**制作过程**'
- en: You will need to solder wires to the DC motors as shown in [Figure 22-2](ch22.xhtml#ch22fig2).
    See the “[Quick Soldering Guide](pref02.xhtml#ch00lev1sec123)” on [page 12](pref02.xhtml#page_12)
    if you need a refresher on how to do this. Solder the red, positive power wire
    to the left pin of one DC motor and the black ground wire to the right pin; reverse
    this order for the other motor. DC motors do not have polarity, so it doesn’t
    matter which way you hold the motors to determine which is left and right, but
    power and GND need to be in opposite positions on the motors so the direction
    of the revolution will be the same.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要像在 [图 22-2](ch22.xhtml#ch22fig2) 中所示那样给直流电机焊接电线。如果你需要复习如何操作，请参阅 [第 12 页](pref02.xhtml#page_12)
    中的 “[快速焊接指南](pref02.xhtml#ch00lev1sec123)”。将红色正极电源线焊接到一个直流电机的左引脚，将黑色地线焊接到右引脚；另一台电机则反转此顺序。直流电机没有极性，因此不管你如何拿电机确定左右，都无妨，但电源和地线必须放置在电机的相反位置，这样电机旋转的方向才会一致。
- en: '**FIGURE 22-2:** Solder the red, positive power wire to the left pin of one
    DC motor, and the black ground wire to the right pin. Reverse this order for the
    other motor.'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 22-2：** 将红色正极电源线焊接到一个直流电机的左引脚，将黑色地线焊接到右引脚。另一台电机则反转此顺序。'
- en: '![Image](../images/f22-02.jpg)'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](../images/f22-02.jpg)'
- en: Attach the single wheel to the front of the robot base and the two rear wheels
    to the back using the screws and fittings provided. The underside of the robot
    should resemble [Figure 22-3](ch22.xhtml#ch22fig3).
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将单轮固定到机器人底座前部，使用提供的螺丝和配件将两个后轮固定到背面。机器人的底部应与[图 22-3](ch22.xhtml#ch22fig3)相似。
- en: '**FIGURE 22-3:** Assemble the base of the Arduino robot.'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 22-3：** 组装Arduino机器人底座。'
- en: '![Image](../images/f22-03.jpg)'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](../images/f22-03.jpg)'
- en: Now you need the L293d motor shield ([Figure 22-4](ch22.xhtml#ch22fig4)); we’ll
    solder some wires to it to control the ultrasonic sensor.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你需要L293d电机电路板（[图 22-4](ch22.xhtml#ch22fig4)）；我们将给它焊接一些导线来控制超声波传感器。
- en: '**FIGURE 22-4:** The L293d motor shield. We’ll solder four wires to the pins
    highlighted in the image.'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 22-4：** L293d电机电路板。我们将焊接四根导线到图中高亮的引脚。'
- en: '![Image](../images/f22-04.jpg)'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](../images/f22-04.jpg)'
- en: Take four female jumper wires and strip about 5 millimeters from one end of
    each, as shown in [Figure 22-5](ch22.xhtml#ch22fig5).
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取四根母跳线，并将每根跳线的一端去皮约5毫米，如[图 22-5](ch22.xhtml#ch22fig5)所示。
- en: '**FIGURE 22-5:** Strip the ends of four female jumper wires to solder onto
    the motor shield.'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 22-5：** 去皮四根母跳线的末端，以便焊接到电机电路板。'
- en: '![Image](../images/f22-05.jpg)'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](../images/f22-05.jpg)'
- en: Solder the stripped ends to the highlighted pins on the motor shield, as shown
    in [Figure 22-6](ch22.xhtml#ch22fig6). This can be tricky, so take your time to
    create the best connection you can.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照[图 22-6](ch22.xhtml#ch22fig6)所示，将去皮的导线焊接到电机电路板上的高亮引脚。这可能比较棘手，所以请花时间确保焊接连接最好。
- en: '**FIGURE 22-6:** Solder the jumper wires to the motor shield (shown in [Figure
    22-4](ch22.xhtml#ch22fig4)). The two pins below the power connections should connect
    to analog A4 and A5 to control the sensor.'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 22-6：** 如[图 22-4](ch22.xhtml#ch22fig4)所示，将跳线焊接到电机电路板。电源连接下方的两个引脚应连接到模拟A4和A5，以控制传感器。'
- en: '![Image](../images/f22-06.jpg)'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](../images/f22-06.jpg)'
- en: Once you’ve soldered the wires to the motor shield, place the shield on top
    of the Arduino so that the pins of the shield line up with the holders in the
    Arduino below. The shield should fit exactly, but take care to align the pins
    to the holes and gently lower it in place.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你将导线焊接到电机电路板，将电路板放在Arduino上，使电路板的引脚与下面Arduino上的插座对齐。电路板应精确贴合，但要小心对齐引脚与孔位，轻轻放置到位。
- en: Next, connect the ultrasonic sensor to the female ends of the jumper wires you
    soldered to the motor shield. Connect VCC on the sensor to +5V on the motor shield,
    Trig to A4, Echo to A5, and GND to GND (see the following table).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，将超声波传感器连接到你焊接到电机电路板的母端跳线。将传感器上的VCC连接到电机电路板上的+5V，Trig连接到A4，Echo连接到A5，GND连接到GND（见下表）。
- en: '| **ULTRASONIC SENSOR** | **MOTOR SHIELD** |'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **超声波传感器** | **电机电路板** |'
- en: '| --- | --- |'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| VCC | +5V |'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| VCC | +5V |'
- en: '| Trig | Pin A4 |'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| Trig | 引脚 A4 |'
- en: '| Echo | Pin A5 |'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| Echo | 引脚 A5 |'
- en: '| GND | GND |'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| GND | GND |'
- en: Connect the wires from the DC motors to the motor shield as shown in the following
    tables and [Figure 22-7](ch22.xhtml#ch22fig7). You connect the wires by feeding
    them through the pin and using the screws to grip the wires in place.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照下表和[图 22-7](ch22.xhtml#ch22fig7)所示，将直流电机的导线连接到电机电路板。你可以通过将导线穿过插针并使用螺丝将导线固定在适当位置来连接导线。
- en: '| **LEFT MOTOR** | **MOTOR SHIELD** | **ARDUINO** |'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **左电机** | **电机电路板** | **Arduino** |'
- en: '| --- | --- | --- |'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Red wire | M1 | +5V |'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 红色导线 | M1 | +5V |'
- en: '| Black wire | M1 | GND |'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 黑色导线 | M1 | GND |'
- en: '| **RIGHT MOTOR** | **MOTOR SHIELD** | **ARDUINO** |'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **右电机** | **电机电路板** | **Arduino** |'
- en: '| --- | --- | --- |'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Red wire | M3 | +5V |'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 红色导线 | M3 | +5V |'
- en: '| Black wire | M3 | GND |'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 黑色导线 | M3 | GND |'
- en: '**FIGURE 22-7:** Connect the power wires of the DC motors as shown.'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 22-7：** 如图所示，连接直流电机的电源导线。'
- en: '![Image](../images/f22-07.jpg)'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](../images/f22-07.jpg)'
- en: Next attach the servomotor to the shield, as shown in the following table and
    [Figure 22-8](ch22.xhtml#ch22fig8).
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将伺服电机安装到电路板上，如下表和[图 22-8](ch22.xhtml#ch22fig8)所示。
- en: '| **SERVOMOTOR** | **MOTOR SHIELD** | **ARDUINO** |'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **伺服电机** | **电机电路板** | **Arduino** |'
- en: '| --- | --- | --- |'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Brown wire | Servo_2 - | GND |'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 棕色导线 | Servo_2 - | GND |'
- en: '| Red wire | Servo_2 + | +5V |'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 红色导线 | Servo_2 + | +5V |'
- en: '| Yellow wire | Servo_2 s | Signal |'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 黄色导线 | Servo_2 s | 信号 |'
- en: '**FIGURE 22-8:** Connect the servomotor to the shield as shown.'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 22-8：** 如图所示，将伺服电机连接到电路板。'
- en: '![Image](../images/f22-08.jpg)'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](../images/f22-08.jpg)'
- en: Attach the servomotor to the front of the robot using glue or tape. Then attach
    the ultrasonic sensor to the horn of the servomotor so it moves with the servo
    arm and your robot can look around. At this stage the robot should look something
    like [Figure 22-9](ch22.xhtml#ch22fig9).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用胶水或胶带将伺服电机固定在机器人的前方。然后将超声波传感器固定在伺服电机的舵上，这样它就可以随着伺服臂一起移动，你的机器人也能环顾四周。在此阶段，机器人应该看起来像
    [图 22-9](ch22.xhtml#ch22fig9) 中的样子。
- en: '**FIGURE 22-9:** The completed robot with ultrasonic sensor attached to the
    servomotor'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 22-9：** 完成的机器人，超声波传感器附加在伺服电机上'
- en: '![Image](../images/f22-09.jpg)'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Image](../images/f22-09.jpg)'
- en: Make sure you’ve downloaded the NewPing and Adafruit Motor Shield libraries
    and added them to your IDE. The Servo library is already included in the IDE,
    so you don’t need to install it.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已经下载了 NewPing 和 Adafruit Motor Shield 库，并将它们添加到 IDE 中。Servo 库已包含在 IDE 中，因此无需安装。
- en: Once you’ve confirmed that your setup matches the circuit diagram in [Figure
    22-10](ch22.xhtml#ch22fig10), upload the code in “[The Sketch](ch22.xhtml#ch00lev1sec93)”
    on [page 198](ch22.xhtml#page_198) and connect the 9V battery pack to your Arduino
    to see your robot in action!
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦确认你的设置与 [图 22-10](ch22.xhtml#ch22fig10) 中的电路图相匹配，上传 “[The Sketch](ch22.xhtml#ch00lev1sec93)”
    代码至 [第 198 页](ch22.xhtml#page_198)，并将 9V 电池包连接到你的 Arduino，看看你的机器人如何运作！
- en: '**FIGURE 22-10:** The circuit diagram for the ultrasonic robot'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 22-10：** 超声波机器人电路图'
- en: '![Image](../images/f22-10.jpg)'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Image](../images/f22-10.jpg)'
- en: '**THE SKETCH**'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**草图**'
- en: The sketch starts by calling on the Adafruit Motor Shield, NewPing, and Servo
    libraries. The Trig pin of the ultrasonic sensor is defined as Arduino A4 and
    the Echo pin as Arduino A5\. The maximum distance of the ultrasonic sensor is
    set at 200 centimeters and the speed of the DC motors is set at a medium speed
    of 190 (out of 255). The DC motors are defined to use connections M1 and M3 of
    the motor shield.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 草图开始时调用了 Adafruit Motor Shield、NewPing 和 Servo 库。超声波传感器的 Trig 引脚被定义为 Arduino
    A4，Echo 引脚为 Arduino A5。超声波传感器的最大距离设置为 200 厘米，直流电机的速度设置为 190（满分 255）为中速。直流电机被定义为使用电机屏蔽板的
    M1 和 M3 接口。
- en: The servo is given a name and attached to pin 9 on the Arduino (via the connection
    on the motor shield). The loops after that take a reading from the ultrasonic
    sensor and, if it detects that an object is less than 15 centimeters away, the
    motors stop and reverse slightly, the servo moves left and right once to look
    around, and the robot turns to the left and continues to move forward until it
    discovers another object.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机被命名并连接到 Arduino 的 9 号引脚（通过电机屏蔽板的连接）。接下来的循环从超声波传感器读取数据，如果检测到物体距离小于 15 厘米，电机会停止并略微反转，伺服电机会左右移动一次以环顾四周，机器人会转向左侧并继续向前移动，直到发现另一个物体。
- en: // Reproduced with kind permission from Nick Koumaris
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: // 由 Nick Koumaris 特别授权转载
- en: // [http://www.educ8s.tv](http://www.educ8s.tv)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: // [http://www.educ8s.tv](http://www.educ8s.tv)
- en: '#include <AFMotor.h>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <AFMotor.h>'
- en: '#include <NewPing.h>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <NewPing.h>'
- en: '#include <Servo.h>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <Servo.h>'
- en: '#define TRIG_PIN A4'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '#define TRIG_PIN A4'
- en: '#define ECHO_PIN A5'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '#define ECHO_PIN A5'
- en: '#define MAX_DISTANCE 200'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '#define MAX_DISTANCE 200'
- en: '#define MAX_SPEED 190 // Sets speed of DC motors'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '#define MAX_SPEED 190 // 设置直流电机的速度'
- en: '#define MAX_SPEED_OFFSET 20'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '#define MAX_SPEED_OFFSET 20'
- en: NewPing sonar(TRIG_PIN, ECHO_PIN, MAX_DISTANCE);
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: NewPing sonar(TRIG_PIN, ECHO_PIN, MAX_DISTANCE);
- en: AF_DCMotor motor1(1, MOTOR12_1KHZ); // First motor to connection 1
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: AF_DCMotor motor1(1, MOTOR12_1KHZ); // 第一个电机连接到 1 号接口
- en: AF_DCMotor motor2(3, MOTOR12_1KHZ); // Second motor to connection 3
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: AF_DCMotor motor2(3, MOTOR12_1KHZ); // 第二个电机连接到 3 号接口
- en: Servo myservo; // Give the servo a name
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Servo myservo; // 给伺服电机命名
- en: boolean goesForward = false;
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: boolean goesForward = false;
- en: int distance = 100; // Define an int for distance and speed
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: int distance = 100; // 定义一个用于距离和速度的 int 类型变量
- en: int speedSet = 0;
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: int speedSet = 0;
- en: void setup() {
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: void setup() {
- en: myservo.attach(9); // Servo attached to pin 9
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: myservo.attach(9); // 伺服电机连接到 9 号引脚
- en: myservo.write(115); // Set servo at 115 degrees
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: myservo.write(115); // 设置伺服电机为 115 度
- en: delay(2000);
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: delay(2000);
- en: distance = readPing(); // Read the distance from the sensor
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: distance = readPing(); // 读取传感器的距离
- en: delay(100);
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: delay(100);
- en: distance = readPing();
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: distance = readPing();
- en: delay(100);
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: delay(100);
- en: distance = readPing();
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: distance = readPing();
- en: delay(100);
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: delay(100);
- en: distance = readPing();
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: distance = readPing();
- en: delay(100);
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: delay(100);
- en: '}'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void loop() {
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: void loop() {
- en: int distanceR = 0;
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: int distanceR = 0;
- en: int distanceL = 0;
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: int distanceL = 0;
- en: delay(40);
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: delay(40);
- en: // If distance is less than 15 cm, carry out this function
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: // 如果距离小于 15 厘米，执行此功能
- en: if (distance <= 15) {
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: if (distance <= 15) {
- en: moveStop();
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: moveStop();
- en: delay(100);
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: delay(100);
- en: moveBackward();
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: moveBackward();
- en: delay(300);
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: delay(300);
- en: moveStop();
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: moveStop();
- en: delay(200);
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: delay(200);
- en: distanceR = lookRight();
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: distanceR = lookRight();
- en: delay(200);
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: delay(200);
- en: distanceL = lookLeft();
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: distanceL = lookLeft();
- en: delay(200);
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: delay(200);
- en: if (distanceR >= distanceL) {
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: if (distanceR >= distanceL) {
- en: turnRight();
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: turnRight();
- en: moveStop();
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: moveStop();
- en: '} else { // Or else carry on'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '} else { // 否则继续'
- en: turnLeft();
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: turnLeft();
- en: moveStop();
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: moveStop();
- en: '}'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '} else {'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: moveForward();
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: moveForward();
- en: '}'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: distance = readPing();
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: distance = readPing();
- en: '}'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: int lookRight() { // The servo looks to the right
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: int lookRight() { // 伺服电机向右看
- en: myservo.write(50);
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: myservo.write(50);
- en: delay(500);
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: delay(500);
- en: int distance = readPing();
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: int distance = readPing();
- en: delay(100);
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: delay(100);
- en: myservo.write(115);
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: myservo.write(115);
- en: return distance;
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: return distance;
- en: '}'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: int lookLeft() { // The servo looks to the left
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: int lookLeft() { // 伺服电机向左看
- en: myservo.write(170);
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: myservo.write(170);
- en: delay(500);
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: delay(500);
- en: int distance = readPing();
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: int distance = readPing();
- en: delay(100);
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: delay(100);
- en: myservo.write(115);
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: myservo.write(115);
- en: return distance;
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: return distance;
- en: delay(100);
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: delay(100);
- en: '}'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: int readPing() {
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: int readPing() {
- en: delay(70);
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: delay(70);
- en: int cm = sonar.ping_cm();
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: int cm = sonar.ping_cm();
- en: if (cm == 0) {
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: if (cm == 0) {
- en: cm = 250;
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: cm = 250;
- en: '}'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return cm;
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: return cm;
- en: '}'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void moveStop() {
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: void moveStop() {
- en: motor1.run(RELEASE);
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: motor1.run(RELEASE);
- en: motor2.run(RELEASE);
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: motor2.run(RELEASE);
- en: '}'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void moveForward() {
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: void moveForward() {
- en: if (!goesForward) { // If area is clear, motors move forward
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: if (!goesForward) { // 如果区域清空，电机向前移动
- en: goesForward = true;
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: goesForward = true;
- en: motor1.run(FORWARD);
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: motor1.run(FORWARD);
- en: motor2.run(FORWARD);
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: motor2.run(FORWARD);
- en: // Slowly bring up speed to avoid loading down
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: // 缓慢加速以避免负载过重
- en: // batteries too quickly
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: // 电池消耗过快
- en: for (speedSet = 0; speedSet < MAX_SPEED; speedSet += 2) {
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: for (speedSet = 0; speedSet < MAX_SPEED; speedSet += 2) {
- en: motor1.setSpeed(speedSet);
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: motor1.setSpeed(speedSet);
- en: motor2.setSpeed(speedSet + MAX_SPEED_OFFSET);
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: motor2.setSpeed(speedSet + MAX_SPEED_OFFSET);
- en: delay(5);
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: delay(5);
- en: '}'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void moveBackward() {
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: void moveBackward() {
- en: goesForward = false;
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: goesForward = false;
- en: motor1.run(BACKWARD);
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: motor1.run(BACKWARD);
- en: motor2.run(BACKWARD);
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: motor2.run(BACKWARD);
- en: // Slowly bring up speed to avoid loading down
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: // 缓慢加速以避免负载过重
- en: // batteries too quickly
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: // 电池消耗过快
- en: for (speedSet = 0; speedSet < MAX_SPEED; speedSet += 2) {
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: for (speedSet = 0; speedSet < MAX_SPEED; speedSet += 2) {
- en: motor1.setSpeed(speedSet);
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: motor1.setSpeed(speedSet);
- en: motor2.setSpeed(speedSet + MAX_SPEED_OFFSET);
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: motor2.setSpeed(speedSet + MAX_SPEED_OFFSET);
- en: delay(5);
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: delay(5);
- en: '}'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void turnRight() { // Movement for turning right
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: void turnRight() { // 向右转动的动作
- en: motor1.run(FORWARD);
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: motor1.run(FORWARD);
- en: motor2.run(BACKWARD);
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: motor2.run(BACKWARD);
- en: delay(300);
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: delay(300);
- en: motor1.run(FORWARD);
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: motor1.run(FORWARD);
- en: motor2.run(FORWARD);
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: motor2.run(FORWARD);
- en: '}'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void turnLeft() { // Movement for turning left
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: void turnLeft() { // 向左转动的动作
- en: motor1.run(BACKWARD);
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: motor1.run(BACKWARD);
- en: motor2.run(FORWARD);
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: motor2.run(FORWARD);
- en: delay(300);
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: delay(300);
- en: motor1.run(FORWARD);
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: motor1.run(FORWARD);
- en: motor2.run(FORWARD);
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: motor2.run(FORWARD);
- en: '}'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**TROUBLESHOOTING**'
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**故障排除**'
- en: '**Q.** *The code compiles, but the Arduino robot does not function as expected.*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** *代码已编译，但 Arduino 机器人未按预期工作。*'
- en: • Make sure that your wiring matches the tables in steps 7, 8, and 9 and the
    circuit diagram in [Figure 22-10](ch22.xhtml#ch22fig10).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: • 确保您的接线与步骤 7、8 和 9 中的表格以及[图 22-10](ch22.xhtml#ch22fig10)中的电路图匹配。
- en: • If your robot spins around rather than moving forward, reverse the wiring
    on one of the DC motors—as mentioned earlier, they don’t have polarity but changing
    the power connections will reverse the motor’s rotation.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果您的机器人转圈而不是向前移动，请反接其中一个直流电机的接线——如前所述，直流电机没有极性，但更改电源连接将反转电机的旋转方向。
- en: • Power the robot with a pack of 1.5V AA batteries in series rather than a 9V
    battery, which has less amperage and will drain quicker.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用一组 1.5V AA 电池串联为机器人供电，而不是使用 9V 电池，后者电流较小，且更容易耗尽。
- en: '**23'
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**23'
- en: Internet-Controlled LED**
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**互联网控制的 LED**'
- en: In this project we’ll use an ethernet shield to connect our Arduino to the internet
    and control an LED from a web browser.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，我们将使用以太网扩展板将我们的 Arduino 连接到互联网，并通过网页浏览器控制一个 LED。
- en: '![Image](../images/p0202-01.jpg)![Image](../images/p0203-01.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0202-01.jpg)![Image](../images/p0203-01.jpg)'
- en: '**PARTS REQUIRED**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**所需部件**'
- en: '**Arduino board**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**Arduino 主板**'
- en: '**Breadboard**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**面包板**'
- en: '**Jumper wires**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**跳线**'
- en: '**Ethernet shield W5100 LAN expansion board**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**W5100 以太网扩展板**'
- en: '**Ethernet cable**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**以太网电缆**'
- en: '**LED**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**LED**'
- en: '**220-ohm resistor**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**220 欧姆电阻**'
- en: '**LIBRARIES REQUIRED**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**所需库**'
- en: '**SPI**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**SPI**'
- en: '**Ethernet**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**以太网**'
- en: The *Internet of Things (IoT)* is revolutionizing our use of everyday items.
    The term refers to objects or smart devices connected through a network, usually
    involving the internet. This allows us to control devices remotely, from inside
    or outside the house! Amazon Echo and Google Home are taking things further by
    allowing a multitude of devices to be connected and controlled via a central hub,
    even if you aren’t at home. We’ll create our own IoT project in its most basic
    form to demonstrate the principles involved.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*物联网（IoT）*正在彻底改变我们使用日常物品的方式。这个术语指的是通过网络连接的物体或智能设备，通常涉及互联网。这使我们能够远程控制设备，无论是在家里还是在外面！亚马逊Echo和谷歌Home通过允许多个设备通过中央控制中心连接和控制，即使您不在家里，也能进一步推动这一进程。我们将以物联网项目的最基本形式来展示相关原理。'
- en: '**HOW IT WORKS**'
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**工作原理**'
- en: The Ethernet shield W5100 LAN expansion board, shown in [Figure 23-1](ch23.xhtml#ch23fig1),
    fits directly on top of the Arduino to provide additional functionality to the
    board. We’ll use the Ethernet library built into the Arduino IDE to connect our
    board to the internet via an Ethernet cable, as shown in [Figure 23-2](ch23.xhtml#ch23fig2).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以太网扩展板W5100 LAN扩展板，如[图23-1](ch23.xhtml#ch23fig1)所示，直接安装在Arduino上，为板子提供额外的功能。我们将使用内置于Arduino
    IDE中的以太网库，通过以太网线将我们的板子连接到互联网，如[图23-2](ch23.xhtml#ch23fig2)所示。
- en: '**FIGURE 23-1:** Ethernet shield'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**图23-1：** 以太网扩展板'
- en: '![Image](../images/f23-01.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f23-01.jpg)'
- en: '**FIGURE 23-2:** Ethernet cable'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**图23-2：** 以太网电缆'
- en: '![Image](../images/f23-02.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f23-02.jpg)'
- en: The library allows the Arduino to act as a server to accept incoming commands,
    a client to send them out, or both. The shield communicates with the Arduino using
    the *Serial Peripheral Interface (SPI)* connections. On the Arduino Uno the SPI
    connections are on digital pins 10, 11, 12, and 13\. In our project the Arduino
    will use both functions to send information to the internet in the form of a simple
    web page and accept commands from this page to control an LED. Buttons on the
    web page will allow us to switch the LED on or off as long as the Arduino is powered
    and connected to the internet.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 该库允许Arduino充当服务器以接收传入命令，充当客户端发送命令，或同时充当两者。该扩展板通过*串行外设接口（SPI）*连接与Arduino进行通信。在Arduino
    Uno上，SPI连接位于数字引脚10、11、12和13上。在我们的项目中，Arduino将同时使用这两种功能，将信息以简单网页的形式发送到互联网，并从该页面接收命令以控制LED。网页上的按钮将允许我们开启或关闭LED，只要Arduino处于通电状态并连接到互联网。
- en: '**SETTING UP YOUR ETHERNET CONNECTION**'
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**设置您的以太网连接**'
- en: You need to know the MAC address of your shield for this project to work. A
    *MAC address* is a unique number assigned to devices for communication and is
    used as a network address for Ethernet and Wi-Fi. If you have a newer shield,
    the MAC address will be printed on a product sticker. If you have an older generic
    Ethernet shield like the one we are using, you can use the MAC address 0xDE, 0xAD,
    0xBE, 0xEF, 0xFE, 0xED for this project.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要知道您扩展板的MAC地址，以使该项目正常工作。*MAC地址*是分配给设备的唯一编号，用于通信，并作为以太网和Wi-Fi的网络地址。如果您的扩展板较新，MAC地址将打印在产品标签上。如果您使用的是较旧的通用以太网扩展板，如我们正在使用的这款，您可以使用MAC地址0xDE,
    0xAD, 0xBE, 0xEF, 0xFE, 0xED来完成本项目。
- en: For communication, we’ll use port 80, the default for HTTP. Short for HyperText
    Transfer Protocol, HTTP is the set of rules for transferring data over the internet.
    In this instance port 80 handles the transfer of data to a web page.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用端口80进行通信，这是HTTP的默认端口。HTTP是超文本传输协议的缩写，是通过互联网传输数据的一套规则。在本例中，端口80负责将数据传输到网页。
- en: Our sketch includes some HTML (HyperText Markup Language) code, which tells
    a web browser how to display an internet page. If you right-click on any web page
    and select Inspect, you can see some of the HTML code behind that page.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的草图中包含一些HTML（超文本标记语言）代码，告诉网页浏览器如何显示互联网页面。如果您右键单击任何网页并选择“检查”，您可以看到该页面背后的部分HTML代码。
- en: The section of our sketch that includes HTML code is as follows and produces
    the web page displayed in [Figure 23-3](ch23.xhtml#ch23fig3).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们草图中包含的HTML代码部分如下，并生成了[图23-3](ch23.xhtml#ch23fig3)中显示的网页。
- en: client.println("HTTP/1.1 200 OK");
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: client.println("HTTP/1.1 200 OK");
- en: 'client.println("Content-Type: text/html");'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 'client.println("Content-Type: text/html");'
- en: client.println();
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: client.println();
- en: client.print("<center><br><h1>Internet Controlled LED</h1><br><br><br><FORM>");
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: client.print("<center><br><h1>互联网控制LED</h1><br><br><br><FORM>");
- en: client.print("<P> <INPUT type=\"submit\" name=\"status\"value=\"ON\">");
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: client.print("<P> <INPUT type=\"submit\" name=\"status\"value=\"ON\">");
- en: client.print("<P> <INPUT type=\"submit\" name=\"status\"value=\"OFF\">");
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: client.print("<P> <INPUT type=\"submit\" name=\"status\"value=\"OFF\">");
- en: client.print("</FORM></center>");
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: client.print("</FORM></center>");
- en: '**FIGURE 23-3:** Our simple web page to control the LED'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**图23-3：** 我们控制LED的简单网页'
- en: '![Image](../images/f23-03.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f23-03.jpg)'
- en: '**THE BUILD**'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**搭建过程**'
- en: Attach the Ethernet shield on top of the Arduino board as shown in [Figure 23-4](ch23.xhtml#ch23fig4).
    The board fits directly on top of the Arduino, so gently press the legs of the
    shield in place with the holes of the Arduino beneath.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以太网扩展板按照[图23-4](ch23.xhtml#ch23fig4)所示安装在Arduino板上。该扩展板直接与Arduino连接，所以轻轻按压扩展板的插针，使其与Arduino下方的孔对接。
- en: '**FIGURE 23-4:** Attach the Ethernet shield on top of the Arduino board.'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图23-4：** 将以太网扩展板安装在Arduino板上。'
- en: '![Image](../images/f23-04.jpg)'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Image](../images/f23-04.jpg)'
- en: Insert the LED into the breadboard with the legs straddling the center break
    of the board. Then, as shown in the following table, connect the shorter, negative
    leg of the LED to the GND rail of the breadboard via a 220-ohm resistor, and connect
    the longer, positive leg of the LED to pin 7 on the Arduino/Ethernet shield. Connect
    the GND rail of the breadboard to Arduino GND.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将LED插入面包板，使其两脚跨过面包板的中间断点。然后，如下表所示，将LED的较短负极脚通过220欧姆电阻连接到面包板的GND轨道，将LED的较长正极脚连接到Arduino/以太网扩展板的引脚7。将面包板的GND轨道连接到Arduino的GND。
- en: '|  **LED**  | **ARDUINO** |'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **LED** | **Arduino** |'
- en: '| --- | --- |'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Negative leg | GND via 220-ohm resistor |'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 负极 | 通过220欧姆电阻连接到GND |'
- en: '| Positive leg | Pin 7 |'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 正极 | 引脚7 |'
- en: With the Ethernet shield attached on top of the Arduino, connect the shield
    to your router with the Ethernet cable.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以太网扩展板安装在Arduino上后，通过以太网电缆将扩展板连接到路由器。
- en: '**NOTE**'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Take note of your IP address; it will be different from mine shown in [Figure
    23-5](ch23.xhtml#ch23fig5).*'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*请注意你的IP地址，它将不同于[图23-5](ch23.xhtml#ch23fig5)中显示的我的地址。*'
- en: Attach the Arduino to your PC and upload the code at the end of the project
    using the IDE. Once the code is uploaded, open the IDE Serial Monitor in order
    to ascertain the *IP address*—a unique string of numbers to identify a device
    attached to the internet—of the Arduino, which is acting as our server. You should
    see something similar to [Figure 23-5](ch23.xhtml#ch23fig5).
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Arduino连接到PC，并使用IDE上传项目末尾的代码。上传代码后，打开IDE的串口监视器，以确定Arduino的*IP地址*（一个用于识别连接到互联网设备的唯一数字字符串），它作为我们的服务器运行。你应该看到类似于[图23-5](ch23.xhtml#ch23fig5)的内容。
- en: '**FIGURE 23-5:** The IP address of the Arduino shield will be shown in the
    Serial Monitor.'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图23-5：** Arduino扩展板的IP地址将在串口监视器中显示。'
- en: '![Image](../images/f23-05.jpg)'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Image](../images/f23-05.jpg)'
- en: Open any web browser and enter your IP address. You should see a web page with
    an On and an Off button, as shown earlier in [Figure 23-3](ch23.xhtml#ch23fig3).
    Press the On button to light the LED and press the Off button to switch it off.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开任意网页浏览器，输入你的IP地址。你应该能看到一个网页，其中有一个开（On）和一个关（Off）按钮，如[图23-3](ch23.xhtml#ch23fig3)中所示。按下开按钮点亮LED，按下关按钮则关闭LED。
- en: This project will also work when you are not connected to your local network,
    as long as you have port 80 open on your internet router. Many internet service
    providers (ISPs) have this port blocked for security reasons, so follow the instructions
    from your ISP to change this if required.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个项目即使在没有连接本地网络时也可以运行，只要你在互联网路由器上开放了80端口。许多互联网服务提供商（ISP）出于安全原因会屏蔽此端口，因此如有需要，请按照ISP的指示修改设置。
- en: '**WARNING**'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Carry out this function only if you are aware of the security risks and how
    to minimize them.*'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*仅在你了解安全风险并且知道如何最小化这些风险的情况下执行此操作。*'
- en: Confirm that your setup matches the circuit diagram in [Figure 23-6](ch23.xhtml#ch23fig6),
    and then upload the code in “[The Sketch](ch23.xhtml#ch00lev1sec98)” on [page
    208](ch23.xhtml#page_208).
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认你的连接与[图23-6](ch23.xhtml#ch23fig6)中的电路图一致，然后在[第208页](ch23.xhtml#page_208)上传
    “[程序代码](ch23.xhtml#ch00lev1sec98)” 中的代码。
- en: '**FIGURE 23-6:** The circuit diagram for the internet-controlled LED'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图23-6：** 用于互联网控制LED的电路图'
- en: '![Image](../images/f23-06.jpg)'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Image](../images/f23-06.jpg)'
- en: '**THE SKETCH**'
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**程序代码**'
- en: The sketch calls on the SPI and Ethernet libraries to control communication
    with the internet. We define the MAC address for the shield. This is the line
    you need to change if your shield came with its own MAC address; if not, the address
    given earlier in this project and shown in the code should work for you. We then
    set the server to use port 80 and define pin 7 on the Arduino as the LED pin.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 该草图调用了 SPI 和以太网库来控制与互联网的通信。我们为扩展板定义了 MAC 地址。如果您的扩展板自带 MAC 地址，您需要修改这一行；如果没有，则本项目中早些时候提供的地址和代码中显示的地址应该能正常工作。然后，我们将服务器设置为使用
    80 端口，并将 Arduino 的 7 号引脚定义为 LED 引脚。
- en: The setup defines the LED pin as an output, begins the Ethernet shield, and
    starts serial communication so we can see the IP address of our server. The loop
    sets up our web page to the browser once it is called and waits for an input on
    the browser task bar. When the On button is pressed, the server tells the Arduino
    to set the LED pin as `HIGH` and the LED will light. When the Off button is pressed,
    the power to the LED is `LOW` and the LED will turn off.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: setup 定义了 LED 引脚为输出，启动了以太网扩展板，并启动了串行通信，以便我们可以看到服务器的 IP 地址。loop 函数设置了网页，当它被调用时会传送给浏览器，并等待浏览器的输入。按下打开按钮时，服务器指示
    Arduino 将 LED 引脚设置为 `HIGH`，LED 会亮起。按下关闭按钮时，LED 的电源被设置为 `LOW`，LED 会关闭。
- en: You could easily change the LED for a relay switch such as the one used in Project
    12 to control a larger-voltage device.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地将 LED 替换为继电器开关，例如第 12 项项目中使用的那种，用来控制更大电压的设备。
- en: '#include <SPI.h>'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <SPI.h>'
- en: '#include <Ethernet.h>'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <Ethernet.h>'
- en: // MAC address for shield
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: // 扩展板的 MAC 地址
- en: byte mac[] = {0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED};
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: byte mac[] = {0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED};
- en: EthernetServer server(80);  // Using port 80
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: EthernetServer server(80);  // 使用端口 80
- en: int led = 7;  // LED attached to pin 7
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: int led = 7;  // LED 连接到引脚 7
- en: void setup() {
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: void setup() {
- en: pinMode(led, OUTPUT); // LED set as an output
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: pinMode(led, OUTPUT); // 设置 LED 为输出模式
- en: Ethernet.begin(mac);  // Start the Ethernet shield
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Ethernet.begin(mac);  // 启动以太网扩展板
- en: server.begin();
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: server.begin();
- en: Serial.begin(9600);  // Start serial communication
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Serial.begin(9600);  // 启动串行通信
- en: Serial.println("Server address:");  // Print server address
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Serial.println("服务器地址：");  // 打印服务器地址
- en: // (Arduino shield)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: // （Arduino 扩展板）
- en: Serial.println(Ethernet.localIP());
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Serial.println(Ethernet.localIP());
- en: '}'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void loop() {
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: void loop() {
- en: EthernetClient client = server.available();
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: EthernetClient client = server.available();
- en: if (client) {
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: if (client) {
- en: boolean currentLineIsBlank = true;
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: boolean currentLineIsBlank = true;
- en: String buffer = "";
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: String buffer = "";
- en: while (client.connected()) {
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: while (client.connected()) {
- en: if (client.available()) {
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: if (client.available()) {
- en: char c = client.read(); // Read from the Ethernet shield
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: char c = client.read(); // 从以太网扩展板读取数据
- en: buffer += c; // Add character to string buffer
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: buffer += c; // 将字符添加到字符串缓冲区
- en: // Client sent request, now waiting for response
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: // 客户端发送请求，现在等待响应
- en: if (c == '\n' && currentLineIsBlank) {
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: if (c == '\n' && currentLineIsBlank) {
- en: client.println("HTTP/1.1 200 OK"); // HTTP response
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: client.println("HTTP/1.1 200 OK"); // HTTP 响应
- en: 'client.println("Content-Type: text/html");'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 'client.println("Content-Type: text/html");'
- en: client.println(); // HTML code
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: client.println(); // HTML 代码
- en: client.print("<center><br><h1>Internet Controlled LED</h1><br><br><br><FORM>");
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: client.print("<center><br><h1>互联网控制 LED</h1><br><br><br><FORM>");
- en: client.print("<P> <INPUT type=\"submit\" name=\"status\"value=\"ON\">");
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: client.print("<P> <INPUT type=\"submit\" name=\"status\"value=\"ON\">");
- en: client.print("<P> <INPUT type=\"submit\" name=\"status\"value=\"OFF\">");
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: client.print("<P> <INPUT type=\"submit\" name=\"status\"value=\"OFF\">");
- en: client.print("</FORM></center>");
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: client.print("</FORM></center>");
- en: break;
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: break;
- en: '}'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if (c == '\n') {
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: if (c == '\n') {
- en: currentLineIsBlank = true;
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: currentLineIsBlank = true;
- en: buffer = "";
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: buffer = "";
- en: '}'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else if (c == '\r') { // Command from webpage
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: else if (c == '\r') { // 来自网页的命令
- en: // Did the on button get pressed
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: // 按下了打开按钮吗
- en: if (buffer.indexOf("GET /?status=ON") >= 0)
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: if (buffer.indexOf("GET /?status=ON") >= 0)
- en: digitalWrite(led, HIGH);
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: digitalWrite(led, HIGH);
- en: // Did the off button get pressed
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: // 按下了关闭按钮吗
- en: if (buffer.indexOf("GET /?status=OFF") >= 0)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: if (buffer.indexOf("GET /?status=OFF") >= 0)
- en: digitalWrite(led, LOW);
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: digitalWrite(led, LOW);
- en: '}'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else {
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: else {
- en: currentLineIsBlank = false;
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: currentLineIsBlank = false;
- en: '}'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: client.stop(); // End server
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: client.stop(); // 结束服务器
- en: '}'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**TROUBLESHOOTING**'
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**故障排除**'
- en: '**Q.** *The code compiles, but the LED does not light as expected.*'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**问。** *代码已编译，但 LED 没有按预期点亮。*'
- en: • First, make sure you’ve connected the GND wire from the Arduino to the correct
    breadboard power rail and that the Arduino has power connected.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: • 首先，确保你已经将 Arduino 的 GND 线连接到正确的面包板电源轨，并且 Arduino 已连接电源。
- en: • Check that the resistor is inserted fully and lines up with the corresponding
    LED leg.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: • 检查电阻是否完全插入并与对应的 LED 引脚对齐。
- en: • Try checking that the project is working by connecting to your local area
    network and using that PC to connect to the Arduino.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: • 尝试通过连接到局域网并使用该PC连接Arduino来检查项目是否正常工作。
- en: '**Q.** *You receive an error when calling the web page.*'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** *你在调用网页时收到错误。*'
- en: • Make sure you have entered the IP address of the server exactly as you read
    it in the steps given earlier.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: • 确保你按照之前给出的步骤准确输入了服务器的IP地址。
- en: • It is best to check the project is working by connecting to your local area
    network and using that PC to connect to the Arduino.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: • 最好通过连接到局域网并使用该PC连接Arduino来检查项目是否正常工作。
- en: '• If the project worked when you connected it to your local area network, but
    you receive an HTTP 403 error when connecting to the internet externally, then
    your ISP is blocking incoming traffic. You could add *port forwarding* to your
    router for port 80\. This will differ for every device, so check with your ISP
    for detailed instructions. Do a quick internet search with your ISP and “port
    forwarding” as terms and follow the instructions, but be aware: this can compromise
    the security of your PC and should be done only if you understand the risks and
    are able to protect your network.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果项目在你将其连接到局域网时能正常工作，但在连接到外部互联网时收到HTTP 403错误，则可能是你的ISP阻止了传入的流量。你可以在路由器上为端口80添加*端口转发*。这对每个设备来说都不同，所以请与ISP联系，获取详细的说明。你可以快速搜索你的ISP和“端口转发”作为关键词，按照说明进行操作，但要注意：这可能会危及你PC的安全，仅在你理解风险并能够保护你的网络时进行。
- en: '**24'
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**24**'
- en: Voice-Controlled LED**
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 语音控制LED**
- en: In this project we’ll use a bluetooth module, a smartphone, and a voice recognition
    app to control an LED with vocal commands.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用蓝牙模块、智能手机和语音识别应用程序来通过语音命令控制LED。
- en: '![Image](../images/p0211-01.jpg)![Image](../images/p0212-01.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0211-01.jpg)![Image](../images/p0212-01.jpg)'
- en: '**PARTS REQUIRED**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**所需组件**'
- en: '**Arduino board**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**Arduino板**'
- en: '**Breadboard**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**面包板**'
- en: '**Jumper wires**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**跳线**'
- en: '**HC-06 Bluetooth module**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**HC-06蓝牙模块**'
- en: '**LED**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**LED**'
- en: '**220-ohm resistor**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**220欧姆电阻**'
- en: '**Android smartphone**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**安卓智能手机**'
- en: '**HOW IT WORKS**'
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**工作原理**'
- en: Bluetooth wireless technology uses radio waves to transmit and exchange data
    over short distances. Smartphones, laptops, and multimedia devices such as speakers
    use Bluetooth as a common standard. We’ll use the inexpensive HC-06 Bluetooth
    module ([Figure 24-1](ch24.xhtml#ch24fig1)) to pair (connect) our Arduino to a
    smartphone so we can turn an LED on and off remotely using a voice recognition
    app. This module has six pins, but we’ll just use the middle four. The pins should
    be labeled on the front.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙无线技术利用无线电波在短距离内传输和交换数据。智能手机、笔记本电脑和多媒体设备（如扬声器）使用蓝牙作为常见标准。我们将使用廉价的HC-06蓝牙模块（[图24-1](ch24.xhtml#ch24fig1)）将Arduino与智能手机配对（连接），这样我们就可以通过语音识别应用程序远程开关LED。该模块有六个引脚，但我们只使用中间的四个。引脚应在前面标注。
- en: '**FIGURE 24-1:** The HC-06 Bluetooth module'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**图24-1：** HC-06蓝牙模块'
- en: '![Image](../images/f24-01.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f24-01.jpg)'
- en: The app we’ll use is Arduino Bluetooth Control from BroxCode, available to download
    for free on the Google Play store for Android devices. There are many other similar
    free apps available for both Android and Apple devices and the principles of use
    should be the same for each, but the BroxCode app has some additional features
    that we’re using in this project, such as voice recognition through Google Assistant.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的应用程序是BroxCode的Arduino Bluetooth Control，安卓设备可以在Google Play商店免费下载。还有许多其他类似的免费应用程序适用于安卓和苹果设备，使用原理应该相同，但BroxCode应用程序具有一些额外功能，我们在这个项目中使用了这些功能，例如通过Google助手进行语音识别。
- en: '**THE BUILD**'
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建**'
- en: Before you build the Bluetooth controller, you need to upload the code to the
    Arduino. This is because the serial communication from your PC to the Arduino
    uses the same pins that we’ll be connecting to the Bluetooth module.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建蓝牙控制器之前，你需要将代码上传到Arduino。这是因为从PC到Arduino的串行通信使用了与我们将连接到蓝牙模块的相同引脚。
- en: Upload the code in “[The Sketch](ch24.xhtml#ch00lev1sec103)” on [page 220](ch24.xhtml#page_220),
    and then insert the Bluetooth module into the breadboard and connect VCC to the
    positive power rail of the breadboard, GND to the GND power rail, TXD to Arduino
    pin 0 (RX), and RXD to Arduino pin 1 (TX), as shown in the following table.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传[“草图”](ch24.xhtml#ch00lev1sec103)中的代码，见[第220页](ch24.xhtml#page_220)，然后将蓝牙模块插入面包板，并将VCC连接到面包板的正电源轨，GND连接到GND电源轨，TXD连接到Arduino的0号引脚（RX），RXD连接到Arduino的1号引脚（TX），如下面的表格所示。
- en: '| **HC-06 BLUETOOTH MODULE** | **ARDUINO** |'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **HC-06蓝牙模块** | **ARDUINO** |'
- en: '| --- | --- |'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| VCC | +5V |'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| VCC | +5V |'
- en: '| GND | GND |'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| GND | GND |'
- en: '| TXD | Pin 0 (RX) |'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| TXD | 引脚0 (RX) |'
- en: '| RXD | Pin 1 (TX) |'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| RXD | 引脚1 (TX) |'
- en: Insert the LED into the breadboard with the legs straddling the center break.
    Use a 220-ohm resistor to connect the shorter, negative leg of the LED to the
    GND rail of the breadboard. Connect the longer, positive leg of the LED to pin
    9 of the Arduino using a jumper wire, as outlined in the following table.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将LED插入面包板，确保其引脚跨越中心断开。使用220欧姆电阻将LED的较短负极引脚连接到面包板的GND轨道。使用跳线将LED的较长正极引脚连接到Arduino的引脚9，具体如下面的表格所示。
- en: '| **LED** | **ARDUINO** |'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **LED** | **ARDUINO** |'
- en: '| --- | --- |'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Positive leg | Pin 9 |'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 正极腿 | 引脚9 |'
- en: '| Negative leg | GND |'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 负极腿 | GND |'
- en: Connect the GND rail of the breadboard to Arduino GND and the positive rail
    to Arduino +5V.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将面包板的GND轨道连接到Arduino的GND，正极轨道连接到Arduino的+5V。
- en: Check that your build matches the diagram in [Figure 24-2](ch24.xhtml#ch24fig2).
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查你的电路图是否与[图24-2](ch24.xhtml#ch24fig2)一致。
- en: '**FIGURE 24-2:** The circuit diagram for the Bluetooth voice-controlled LED'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图24-2：** 蓝牙语音控制LED的电路图'
- en: '![Image](../images/f24-02.jpg)'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Image](../images/f24-02.jpg)'
- en: '**ARDUINO BLUETOOTH CONTROL**'
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**ARDUINO蓝牙控制**'
- en: The Arduino Bluetooth Control app offers six control options, all of which send
    data to the Arduino via different methods ([Figure 24-3](ch24.xhtml#ch24fig3)).
    You can customize each to your own preferences.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino蓝牙控制应用程序提供了六种控制选项，所有选项都通过不同的方式将数据发送到Arduino（见[图24-3](ch24.xhtml#ch24fig3)）。你可以根据自己的偏好定制每个选项。
- en: '**FIGURE 24-3:** The menu screen on the Arduino Bluetooth Control app'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**图24-3：** Arduino蓝牙控制应用程序的菜单屏幕'
- en: '![Image](../images/f24-03.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f24-03.jpg)'
- en: • **Arrow Keys:** Here you’ll find customizable arrow buttons.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: • **方向键：** 这里你可以找到可定制的箭头按钮。
- en: • **Terminal:** This is a classic terminal for sending and receiving data, displayed
    with a timestamp corresponding to each action.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: • **终端：** 这是一个经典的终端，用于发送和接收数据，每个操作都有时间戳。
- en: • **Accelerometer:** This tool reads movement using the gesture sensor of your
    phone.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: • **加速度计：** 这个工具通过手机的手势传感器读取运动。
- en: • **Buttons and Slider:** Here you’ll find six fully customizable buttons and
    a slider view that shows up when you rotate your device. You can set the range
    of the data for this slider.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: • **按钮和滑块：** 这里你可以找到六个完全可定制的按钮以及一个在旋转设备时显示的滑块视图。你可以设置该滑块的数据范围。
- en: • **Metrics:** This tool is optimized to receive data via the `println()` function
    of the Arduino, which allows your paired phone to receive notifications by SMS
    from another phone. You only need to specify the number in the Settings section.
    This function is explained further shortly.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: • **度量标准：** 该工具已优化，能够通过Arduino的`println()`函数接收数据，这使得你配对的手机可以通过短信从另一部手机接收通知。你只需在设置部分指定号码即可。此功能稍后会进一步解释。
- en: • **Voice Control:** This great tool uses the Google voice command on your Android
    device to let you customize your own vocal commands and use them to control the
    Arduino.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: • **语音控制：** 这个强大的工具利用你的Android设备上的Google语音命令，让你定制自己的语音命令，并用它们控制Arduino。
- en: Now you need to download the Arduino Bluetooth Control app from the Google Play
    app store and set it up.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要从Google Play应用商店下载Arduino蓝牙控制应用程序并进行设置。
- en: Go to *[https://play.google.com/store/](https://play.google.com/store/)* and
    search for “[Arduino Bluetooth Control](ch24.xhtml#ch00lev1sec102).” You’ll probably
    get several apps in your results, but the one you want is precisely named “[Arduino
    Bluetooth Control](ch24.xhtml#ch00lev1sec102),” as shown in [Figure 24-4](ch24.xhtml#ch24fig4).
    Click **Install** to download it to your device. The app is free but does include
    some ads.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 *[https://play.google.com/store/](https://play.google.com/store/)* 并搜索 “[Arduino
    Bluetooth Control](ch24.xhtml#ch00lev1sec102)”。你可能会在搜索结果中找到多个应用程序，但你需要的正是名为 “[Arduino
    Bluetooth Control](ch24.xhtml#ch00lev1sec102)” 的那个，正如[图24-4](ch24.xhtml#ch24fig4)所示。点击
    **安装** 将其下载到你的设备。该应用程序是免费的，但包含一些广告。
- en: '**FIGURE 24-4:** Arduino Bluetooth Control from BroxCode on Google Play'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图24-4：** 来自BroxCode的Arduino蓝牙控制应用程序，来自Google Play'
- en: '![Image](../images/f24-04.jpg)'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Image](../images/f24-04.jpg)'
- en: 'Once you’ve downloaded the app, power your Arduino to start the Bluetooth module.
    Go to your Bluetooth settings on your smartphone, turn on Bluetooth, and select
    **MORE SETTINGS** to view visible devices. You should see the HC-06 module as
    an available device. Select it to pair with your phone. You’ll be asked for a
    password to connect: the default for the module is 1234 or in some instances 0000,
    so try both if the first doesn’t work.'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载应用程序后，给 Arduino 供电以启动蓝牙模块。进入手机的蓝牙设置，打开蓝牙，选择**更多设置**以查看可见设备。你应该看到 HC-06 模块作为可用设备，选择它与手机配对。系统会要求输入密码：默认密码为
    1234，有时是 0000，如果第一个密码不行，可以尝试第二个。
- en: When your device is paired, open the Arduino Bluetooth Control app. From the
    window that appears showing all available devices, select the HC-06 module, as
    shown in [Figure 24-5](ch24.xhtml#ch24fig5). You won’t need to choose the device
    every time you power up—the app will remember it.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当设备配对完成后，打开 Arduino 蓝牙控制应用程序。在出现的窗口中显示所有可用设备，选择 HC-06 模块，如[图 24-5](ch24.xhtml#ch24fig5)所示。你不需要每次开机时都选择设备——应用程序会记住它。
- en: '**FIGURE 24-5:** Pairing your device'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 24-5：** 配对你的设备'
- en: '![Image](../images/f24-05.jpg)'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Image](../images/f24-05.jpg)'
- en: You’re going to use the Voice Control function to turn the LED off and on when
    you speak certain commands into the smartphone. Select the Voice Control function,
    and you’ll be taken to the Settings menu, shown in [Figure 24-6](ch24.xhtml#ch24fig6).
    Choose **Vocal commands configuration**. We’ll use this to define our input and
    output functions.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将使用语音控制功能，通过对智能手机说出特定命令来打开和关闭 LED。选择语音控制功能，系统将带你进入设置菜单，如[图 24-6](ch24.xhtml#ch24fig6)所示。选择**语音命令配置**。我们将使用这个来定义输入和输出功能。
- en: '**FIGURE 24-6:** Selecting the Vocal commands configuration setting'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 24-6：** 选择语音命令配置设置'
- en: '![Image](../images/f24-06.jpg)'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Image](../images/f24-06.jpg)'
- en: Select **Vocal command n°1**, as shown in [Figure 24-7](ch24.xhtml#ch24fig7).
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**语音命令 n°1**，如[图 24-7](ch24.xhtml#ch24fig7)所示。
- en: '**FIGURE 24-7:** Setting your first voice command'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 24-7：** 设置你的第一个语音命令'
- en: '![Image](../images/f24-07.jpg)'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Image](../images/f24-07.jpg)'
- en: Here you give the input that will trigger the first function. Enter `light on`
    as text, as shown in the screen on the left in [Figure 24-8](ch24.xhtml#ch24fig8).
    The app will then ask for the output data to send to the Arduino when you give
    the input command. On this screen, enter `1` for on or `HIGH`, as we’ve seen in
    previous LED projects (shown in the screen on the right in [Figure 24-8](ch24.xhtml#ch24fig8)).
    When the app hears the vocal command “light on” through the phone, the number
    `1` will be sent to the Arduino as an input, and power will be sent to the LED
    to light it up.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你提供触发第一个功能的输入。输入 `light on` 作为文本，如[图 24-8](ch24.xhtml#ch24fig8)左侧屏幕所示。应用程序将询问你在输入命令时要发送到
    Arduino 的输出数据。在这个屏幕上，输入 `1` 来开启 LED 或输入 `HIGH`，正如我们在之前的 LED 项目中看到的那样（如[图 24-8](ch24.xhtml#ch24fig8)右侧屏幕所示）。当应用程序通过手机接收到语音命令“light
    on”时，数字 `1` 将作为输入发送到 Arduino，电源将供应给 LED，从而点亮它。
- en: Carry out the same steps to define Vocal command n°2 with the input `light off`
    and the output data `0`, as shown in [Figure 24-9](ch24.xhtml#ch24fig9). This
    command will switch the LED off.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行相同的步骤，定义语音命令 n°2，输入为 `light off`，输出数据为 `0`，如[图 24-9](ch24.xhtml#ch24fig9)所示。此命令将关闭
    LED。
- en: Now you’ve configured your commands so that when you press the voice command
    function and tap the microphone button on the screen, the app will listen for
    your command and, depending on the input, switch the LED on or off.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经配置了命令，按下语音命令功能并点击屏幕上的麦克风按钮后，应用程序将监听你的命令，并根据输入内容切换 LED 的开关。
- en: '**FIGURE 24-8:** Configuring our LED to turn on with the voice command “light
    on”'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 24-8：** 配置我们通过语音命令“light on”打开 LED'
- en: '![Image](../images/f24-08.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f24-08.jpg)'
- en: '**FIGURE 24-9:** Configuring the “light off” function'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 24-9：** 配置“light off”功能'
- en: '![Image](../images/f24-09.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f24-09.jpg)'
- en: The app also has a function to let you control the Arduino using SMS. Once the
    app is launched and connected to the Arduino, you can send data to the Arduino
    by sending an SMS text to the phone paired with the Bluetooth module, as long
    as the paired phone is in range of the module. Simply text `Arduino 1` to the
    phone connected to the Arduino, and that phone will send `1` to the module to
    light your LED. Text `Arduino 0`, and a `0` will be sent to switch your LED off.
    This way you can have control through Bluetooth from anywhere in the world!
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序还有一个功能，可以让你通过短信控制Arduino。一旦应用程序启动并连接到Arduino，你可以通过向与蓝牙模块配对的手机发送短信，将数据发送到Arduino，只要配对的手机在模块的范围内。只需向连接到Arduino的手机发送`Arduino
    1`，该手机将发送`1`到模块以点亮LED。发送`Arduino 0`，则会发送`0`来关闭LED。通过这种方式，你可以在全球任何地方通过蓝牙进行控制！
- en: '**THE SKETCH**'
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**草图**'
- en: The sketch for this project is quite simple. It starts by creating a variable
    to hold the data from the Bluetooth module. It sets the data rate for serial communication
    to `9600` and sets pin 9 as an output for our LED. In the loop, it checks for
    data to be sent to the Arduino from the Bluetooth module. The loop reads the data,
    and also sends it to the Serial Monitor so we can check that it’s working correctly.
    If the Arduino receives a `1` from the app, pin 9 will be set to `HIGH`, which
    will turn on the LED. If the Arduino receives a `0`, pin 9 is set as `LOW` and
    the LED is turned off.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的草图非常简单。它首先创建一个变量来保存来自蓝牙模块的数据。它将串口通信的数据传输速率设置为`9600`，并将9号引脚设置为输出，以控制我们的LED。在循环中，它检查是否有数据从蓝牙模块发送到Arduino。循环读取数据，并将其发送到串口监视器，以便我们检查它是否正常工作。如果Arduino从应用程序接收到`1`，9号引脚将被设置为`HIGH`，这将点亮LED。如果Arduino接收到`0`，9号引脚将设置为`LOW`，LED将关闭。
- en: Using these principles, you could add numerous relays in place of the LED and
    begin to automate your home from anywhere. You could set it up to turn on your
    living room lights before you enter your house, set the thermostat when you’re
    on your way home, or have your favorite music already playing as you walk in the
    door.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些原理，你可以在LED的位置添加多个继电器，并开始从任何地方自动化你的家。你可以设置它，在你进入家之前打开客厅的灯，回家时设置恒温器，或者在你走进门时已经播放你最喜欢的音乐。
- en: char data = 0; // Create a variable for data
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: char data = 0; // 创建一个用于存储数据的变量
- en: void setup() {
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: void setup() {
- en: Serial.begin(9600); // Data rate for serial communication
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Serial.begin(9600); // 串口通信的数据传输速率
- en: pinMode(9, OUTPUT); // Set pin 9 as an output
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: pinMode(9, OUTPUT); // 设置9号引脚为输出
- en: '}'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void loop() {
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: void loop() {
- en: if (Serial.available() > 0) { // Send data
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: if (Serial.available() > 0) { // 发送数据
- en: data = Serial.read(); // Read incoming data and
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: data = Serial.read(); // 读取传入的数据并
- en: // store it into variable data
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: // 将其存储到变量data中
- en: Serial.print(data); // Print data value to the Serial Monitor
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: Serial.print(data); // 将数据值打印到串口监视器
- en: Serial.print("\n"); // Start a new line
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: Serial.print("\n"); // 开始新的一行
- en: if (data == '1') // If value is 1, turn on LED
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: if (data == '1') // 如果值为1，点亮LED
- en: digitalWrite(9, HIGH);
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: digitalWrite(9, HIGH);
- en: else if (data == '0') // If value is 0, turn off LED
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: else if (data == '0') // 如果值为0，关闭LED
- en: digitalWrite(9, LOW);
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: digitalWrite(9, LOW);
- en: '}'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**TROUBLESHOOTING**'
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**故障排除**'
- en: '**Q.** *The code compiles, but the LED does not light.*'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：** *代码编译通过，但LED没有亮。*'
- en: • Make sure you’ve connected the GND and power pins from the Arduino to the
    correct breadboard power rails and that the Arduino has power connected.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: • 确保你已经将Arduino的GND和电源引脚连接到正确的面包板电源轨，并且Arduino已连接电源。
- en: • Check that the LED is inserted the correct way, with the longer leg connected
    to the positive power and the shorter leg to GND. Check that the resistors are
    inserted fully and line up with the corresponding LED leg.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: • 确保LED插入正确，较长的引脚连接到正电源，较短的引脚连接到GND。检查电阻是否完全插入并与相应的LED引脚对齐。
- en: • With the project powered and connected to your PC, open the Arduino IDE Serial
    Monitor to see if the Arduino is receiving data from the app. If you don’t see
    data streaming in the Serial Monitor, double-check that the TXD of the module
    is connected to RX of the Arduino and the RXD of the module to Arduino TX.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: • 在项目通电并连接到PC后，打开Arduino IDE的串口监视器，查看Arduino是否从应用程序接收数据。如果在串口监视器中没有看到数据流，检查模块的TXD是否连接到Arduino的RX，模块的RXD是否连接到Arduino的TX。
- en: • If the app does not work when opened on your smartphone, check the compatibility
    of your phone with the app on the developer’s site. You may need to use an alternative
    app.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果应用程序在智能手机上打开时无法正常工作，请检查手机与开发者网站上的应用程序的兼容性。你可能需要使用替代应用程序。
- en: • The data set in your app must match the data expected in the sketch, so make
    sure you’ve used `1` for on and `0` for off.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: • 你应用中的数据集必须与草图中预期的数据匹配，因此确保使用`1`表示开启，`0`表示关闭。
- en: '**25'
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**25'
- en: GPS Speedometer**
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: GPS速度计**
- en: In this project we’ll connect an OLED screen and GPS module to our Arduino to
    create a simple GPS speedometer that can track your speed from satellites.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将连接一个OLED屏幕和GPS模块到Arduino上，创建一个简单的GPS速度计，用于通过卫星跟踪你的速度。
- en: '![Image](../images/p0222-01.jpg)![Image](../images/p0223-01.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/p0222-01.jpg)![图片](../images/p0223-01.jpg)'
- en: '**PARTS REQUIRED**'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '**所需零件**'
- en: '**Arduino board**'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '**Arduino板**'
- en: '**Female-to-male jumper wires**'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '**母对公跳线**'
- en: '**OLED monochrome screen (128×64)**'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**OLED单色屏（128×64）**'
- en: '**Ublox NEO-6M GPS module aircraft flight controller and antenna**'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ublox NEO-6M GPS模块 航空器飞行控制器与天线**'
- en: '**LIBRARY REQUIRED**'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '**所需库**'
- en: '**U8glib**'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '**U8glib**'
- en: '**HOW IT WORKS**'
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**工作原理**'
- en: The Ublox NEO-6M GPS module ([Figure 25-1](ch25.xhtml#ch25fig1)) we’re using
    in this project is an inexpensive device generally used to track the position
    of model aircraft or drones. The module is widely available from the suppliers
    listed in the “[Retailer List](app02.xhtml#ch00lev1sec170)” on [page 249](app02.xhtml#page_249),
    or you can search online for “Ublox NEO-6M GPS module.” Make sure to buy a module
    that also comes with a GPS antenna, as shown in [Figure 25-2](ch25.xhtml#ch25fig2).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目中使用的Ublox NEO-6M GPS模块（[图25-1](ch25.xhtml#ch25fig1)）是一款廉价的设备，通常用于跟踪模型飞机或无人机的位置。该模块在供应商列表中有广泛的供应，供应商列表可以在[《零售商列表》](app02.xhtml#ch00lev1sec170)中找到，或你可以在网上搜索“Ublox
    NEO-6M GPS模块”。请确保购买的模块也附带GPS天线，如[图25-2](ch25.xhtml#ch25fig2)所示。
- en: '**FIGURE 25-1:** The Ublox NEO-6M GPS module'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**图25-1：** Ublox NEO-6M GPS模块'
- en: '![Image](../images/f25-01.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f25-01.jpg)'
- en: '**FIGURE 25-2:** The GPS antenna'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**图25-2：** GPS天线'
- en: '![Image](../images/f25-02.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f25-02.jpg)'
- en: The module uses *GPS (Global Positioning System)* technology to determine the
    exact location of the Arduino and display its speed in kilometers per hour on
    the OLED screen (see Project 19 for more on OLED screens). GPS consists of 32
    satellites orbiting the earth, and it’s used across the globe in everyday technology
    such as car satellite navigation systems, smartphones, and trackers.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块使用*GPS（全球定位系统）*技术来确定Arduino的精确位置，并在OLED屏幕上以公里每小时为单位显示其速度（有关OLED屏幕的更多内容，请参见项目19）。GPS由32颗卫星组成，这些卫星环绕地球运转，并被广泛应用于日常技术中，如汽车卫星导航系统、智能手机和追踪器。
- en: The Navstar Global Positioning System was created in the 1970s by the United
    States government initially for military purposes, but it’s now freely accessible
    for anyone with GPS receiver equipment, which probably includes you if you have
    a smartphone. To pinpoint the location of a receiver, the system uses the satellites,
    control stations on the ground, and your equipment to calculate distance, speed,
    and time for signals to be sent and received—with these, it can determine your
    location.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: Navstar全球定位系统最初由美国政府在1970年代创建，最初用于军事目的，但现在任何拥有GPS接收设备的人都可以自由使用该系统，如果你拥有智能手机，可能也包括你。为了定位接收器的位置，该系统使用卫星、地面控制站和你的设备来计算信号传送和接收的距离、速度和时间——通过这些，它可以确定你的位置信息。
- en: The Ublox NEO-6M GPS module receives satellite signals continuously and sends
    them to the Arduino to pinpoint your location. As soon as you move, your speed
    is sent to the OLED screen in kilometers per hour, serving as our speedometer.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: Ublox NEO-6M GPS模块持续接收卫星信号并将其发送到Arduino，以确定你的位置信息。一旦你开始移动，你的速度将以公里每小时的单位发送到OLED屏幕，作为我们的速度计。
- en: While the functionality of this project is quite complex, the build is very
    simple. The board comes with the header pins separate, so you need to solder these
    in place before beginning. See the “[Quick Soldering Guide](pref02.xhtml#ch00lev1sec123)”
    on [page 12](pref02.xhtml#page_12) if you need soldering guidance. The board has
    all the GPS circuitry built in, but you’ll need to clip the GPS antenna in place;
    I’ll show you how in a moment.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个项目的功能相当复杂，但构建过程非常简单。板子附带的针脚是分开的，因此在开始之前需要将它们焊接到位。如果你需要焊接指导，请参阅[《快速焊接指南》](pref02.xhtml#ch00lev1sec123)中的内容，该指南位于[第12页](pref02.xhtml#page_12)。该板已内置所有GPS电路，但你需要将GPS天线夹到板子上；我稍后会向你展示如何操作。
- en: '**THE BUILD**'
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建过程**'
- en: Take the OLED monochrome screen shown in [Figure 25-3](ch25.xhtml#ch25fig3)
    and, using female-to-male jumper wires, make the connections in the following
    table. The OLED screen uses 3.3V, so make sure you connect it to Arduino 3.3V,
    not 5V, or you could damage the screen.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请使用[图 25-3](ch25.xhtml#ch25fig3)中显示的 OLED 单色屏，并使用母对公跳线连接以下表格中的内容。由于 OLED 屏幕使用
    3.3V 电压，请确保将其连接到 Arduino 的 3.3V，而不是 5V，否则可能会损坏屏幕。
- en: '**FIGURE 25-3:** The OLED monochrome screen displays the speed of movement
    in kilometers per hour (digit on the right).'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 25-3：** OLED 单色屏显示运动速度（右侧数字为时速，单位为公里/小时）。'
- en: '![Image](../images/f25-03.jpg)'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](../images/f25-03.jpg)'
- en: '|  **OLED SCREEN**  | **ARDUINO** |'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **OLED 屏幕** | **Arduino** |'
- en: '| --- | --- |'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| VCC | +3.3V |'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| VCC | +3.3V |'
- en: '| GND | GND |'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| GND | GND |'
- en: '| SCL | Pin A5 |'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| SCL | 引脚 A5 |'
- en: '| SDA | Pin A4 |'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| SDA | 引脚 A4 |'
- en: The GPS module uses the RX and TX pins of the Arduino for communication, but
    you also need these pins when uploading a sketch from your PC. Upload the code
    in “[The Sketch](ch25.xhtml#ch00lev1sec107)” on [page 227](ch25.xhtml#page_227)
    now so those pins will be free. Connect the Arduino to your PC. Remember to first
    download the U8glib library and add it to the relevant folder in the Arduino IDE.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GPS 模块使用 Arduino 的 RX 和 TX 引脚进行通信，但在从 PC 上传草图时，你也需要这些引脚。现在上传[“草图”](ch25.xhtml#ch00lev1sec107)中的代码，该代码位于[第
    227 页](ch25.xhtml#page_227)，这样这些引脚就能空闲出来。将 Arduino 连接到你的 PC。记得首先下载 U8glib 库并将其添加到
    Arduino IDE 的相关文件夹中。
- en: With the sketch uploaded, disconnect the Arduino from your PC and attach the
    GPS VCC to Arduino +5V, GND to GND, GPS TX to Arduino pin 0 (RX), and GPS RX to
    Arduino pin 1 (TX), as indicated in the following table.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传草图后，断开 Arduino 与电脑的连接，并将 GPS 的 VCC 连接到 Arduino 的 +5V，GND 连接到 GND，GPS 的 TX
    连接到 Arduino 引脚 0 (RX)，GPS 的 RX 连接到 Arduino 引脚 1 (TX)，如下表所示。
- en: '| **GPS MODULE** | **ARDUINO** |'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **GPS 模块** | **Arduino** |'
- en: '| --- | --- |'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| VCC | +5V |'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| VCC | +5V |'
- en: '| GND | GND |'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| GND | GND |'
- en: '| TX | Pin 0 (RX) |'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| TX | 引脚 0 (RX) |'
- en: '| RX | Pin 1 (TX) |'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| RX | 引脚 1 (TX) |'
- en: Clip the end of the antenna onto the module, as shown in [Figure 25-4](ch25.xhtml#ch25fig4).
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如[图 25-4](ch25.xhtml#ch25fig4)所示，将天线的末端夹入模块的插座中。
- en: '**FIGURE 25-4:** Clip the end of the antenna to the socket on the GPS module.'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 25-4：** 将天线的末端夹到 GPS 模块的插座上。'
- en: '![Image](../images/f25-04.jpg)'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](../images/f25-04.jpg)'
- en: Confirm your setup matches the circuit diagram in [Figure 25-5](ch25.xhtml#ch25fig5).
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认你的连接与[图 25-5](ch25.xhtml#ch25fig5)中的电路图一致。
- en: '**FIGURE 25-5:** The circuit diagram for the GPS speedometer'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 25-5：** GPS 车速计的电路图'
- en: '![Image](../images/f25-05.jpg)'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](../images/f25-05.jpg)'
- en: Connect power to your Arduino, and the GPS speedometer is ready to use. The
    antenna needs to be facing upward to work, as shown in [Figure 25-4](ch25.xhtml#ch25fig4),
    and works best outdoors because the GPS module requires line of sight with the
    orbiting satellites in order to function properly (though I’ve also had success
    when close to a window indoors, so experiment to see what works for you).
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给 Arduino 供电，GPS 车速计就可以开始使用了。天线需要朝上才能工作，如[图 25-4](ch25.xhtml#ch25fig4)所示，最好在户外使用，因为
    GPS 模块需要与轨道上的卫星保持视距才能正常工作（尽管我也在室内靠近窗户时成功过，所以可以试试看哪种方式适合你）。
- en: The GPS module will take about 30 seconds or so to connect to the satellites.
    When the connection is successful, the module LED will blink and the symbol at
    the top left of the OLED screen will spin.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GPS 模块大约需要 30 秒左右连接卫星。当连接成功时，模块的 LED 灯会闪烁，OLED 屏幕左上角的符号会旋转。
- en: '**THE SKETCH**'
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**草图**'
- en: The sketch first calls on the U8glib library and then defines the OLED so we
    can control our screen. We define the GPS module as a serial connection, and tell
    it what information we want to receive from the satellites.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 草图首先调用 U8glib 库，然后定义 OLED，以便我们可以控制屏幕。我们将 GPS 模块定义为串行连接，并告诉它我们希望从卫星接收哪些信息。
- en: '**NOTE**'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Remember to disconnect the Arduino 0 (RX) pin of your build before uploading
    the sketch and then reconnect when running.*'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '*记得在上传草图之前断开 Arduino 0 (RX) 引脚连接，上传完成后再重新连接。*'
- en: 'The next section of code contains a long list of data. This section is quite
    complex, and the data sheet for the Ublox NEO-6M details all the information that
    can be received by the module if you’re interested. For the purposes of our project,
    the code at ➊ contains the relevant data: the NAV-PVT data that includes the number
    of satellites the module is connecting to and the ground speed at which your GPS
    speedometer is moving. The remaining information requests are not used and are
    set as `off`.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一部分包含一个长列表的数据。这部分相当复杂，Ublox NEO-6M的数据手册详细列出了模块可以接收到的所有信息，如果你感兴趣的话。对于我们的项目，➊处的代码包含相关数据：NAV-PVT数据，包括模块连接的卫星数量和GPS测速仪的地面速度。其余的请求信息未被使用，设置为`关闭`。
- en: The section that follows defines the NAV-PVT settings with a number of calculations
    to check that the data being received from the satellites is valid.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分定义了NAV-PVT设置，并通过一些计算检查从卫星接收到的数据是否有效。
- en: The loop at the end of the sketch checks to see if data is being received, and
    if so, animates the symbols at the top left of the OLED. The first symbol shows
    that the screen is refreshing correctly, and the second shows that the GPS data
    packet is being received from the satellites. The screen also displays the number
    of satellites it’s connected to at the top left.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 草图结尾的循环检查是否接收到数据，如果有，则会在OLED的左上角动画化符号。第一个符号显示屏幕是否正确刷新，第二个符号显示是否从卫星接收到GPS数据包。屏幕还会显示连接到的卫星数量，位于左上方。
- en: If all the data is being received as expected, the ground speed will be shown
    at the top right of the screen in kilometers per hour.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有数据都按预期接收，地面速度将显示在屏幕右上方，以公里每小时为单位。
- en: // Sketch reproduced with kind permission from Chris Campbell
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: // 草图由Chris Campbell的友好许可复制作
- en: /*
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: /*
- en: 'Connections:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 连接：
- en: GPS TX -> Arduino 0 // Disconnect Arduino 0 to upload this sketch
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: GPS TX -> Arduino 0 // 断开Arduino 0以上传此草图
- en: GPS RX -> Arduino 1
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: GPS RX -> Arduino 1
- en: Screen SDA -> Arduino A4
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕SDA -> Arduino A4
- en: Screen SCL -> Arduino A5
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕SCL -> Arduino A5
- en: '*/'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '*/'
- en: '#include "U8glib.h" // Call U8glib library to control OLED screen'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "U8glib.h" // 调用U8glib库以控制OLED屏幕'
- en: U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_DEV_0|U8G_I2C_OPT_NO_ACK|U8G_I2C_OPT_FAST);
    // Fast I2C/TWI
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_DEV_0|U8G_I2C_OPT_NO_ACK|U8G_I2C_OPT_FAST);
    // 快速I2C/TWI
- en: '#define GPS Serial // Define the serial connection as the GPS module'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '#define GPS Serial // 将串口连接定义为GPS模块'
- en: const unsigned char UBLOX_INIT[] PROGMEM = {
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: const unsigned char UBLOX_INIT[] PROGMEM = {
- en: // These lines of code request data from the satellites. Most are disabled and
    turned off.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: // 这些代码行请求来自卫星的数据。大多数已禁用并关闭。
- en: // Disable NMEA
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: // 禁用NMEA
- en: 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x24,
    // GxGGA off
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x24,
    // GxGGA 关闭
- en: 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x2B,
    // GxGLL off
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x2B,
    // GxGLL 关闭
- en: 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x02,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x32,
    // GxGSA off
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x02,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x32,
    // GxGSA 关闭
- en: 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x39,
    // GxGSV off
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x39,
    // GxGSV 关闭
- en: 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x04,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x40,
    // GxRMC off
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x04,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x40,
    // GxRMC 关闭
- en: 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x05,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x47,
    // GxVTG off
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 0xB5,0x62,0x06,0x01,0x08,0x00,0xF0,0x05,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x47,
    // GxVTG 关闭
- en: // Disable UBX
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: // 禁用UBX
- en: 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0xDC,
    // NAV-PVT off
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0xDC,
    // NAV-PVT 关闭
- en: 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0xB9,
    // NAV-POSLLH off
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0xB9,
    // NAV-POSLLH 关闭
- en: 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x13,0xC0,
    // NAV-STATUS off
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x13,0xC0,
    // NAV-STATUS 关闭
- en: // Enable UBX—this is the key information we require
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: // 启用UBX——这是我们需要的关键信息
- en: ➊   0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x18,0xE1,
    //NAV-PVT on
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: ➊   0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x07,0x00,0x01,0x00,0x00,0x00,0x00,0x18,0xE1,
    //NAV-PVT 开启
- en: //0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x01,0x00,0x00,0x00,0x00,0x13,0xBE,
    //NAV-POSLLH on
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: //0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x02,0x00,0x01,0x00,0x00,0x00,0x00,0x13,0xBE,
    //NAV-POSLLH 开启
- en: //0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x03,0x00,0x01,0x00,0x00,0x00,0x00,0x14,0xC5,
    //NAV-STATUS on
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: //0xB5,0x62,0x06,0x01,0x08,0x00,0x01,0x03,0x00,0x01,0x00,0x00,0x00,0x00,0x14,0xC5,
    //NAV-STATUS 开启
- en: // Rate
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: // 频率
- en: 0xB5,0x62,0x06,0x08,0x06,0x00,0x64,0x00,0x01,0x00,0x01,0x00,0x7A,0x12,    //
    (10Hz)
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 0xB5,0x62,0x06,0x08,0x06,0x00,0x64,0x00,0x01,0x00,0x01,0x00,0x7A,0x12,    //
    （10Hz）
- en: // 0xB5,0x62,0x06,0x08,0x06,0x00,0xC8,0x00,0x01,0x00,0x01,0x00,0xDE,0x6A, //
    (5Hz)
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: // 0xB5,0x62,0x06,0x08,0x06,0x00,0xC8,0x00,0x01,0x00,0x01,0x00,0xDE,0x6A, //
    （5Hz）
- en: // 0xB5,0x62,0x06,0x08,0x06,0x00,0xE8,0x03,0x01,0x00,0x01,0x00,0x01,0x39  //
    (1Hz)
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: // 0xB5,0x62,0x06,0x08,0x06,0x00,0xE8,0x03,0x01,0x00,0x01,0x00,0x01,0x39  //
    （1Hz）
- en: '};'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: const unsigned char UBX_HEADER[] = { 0xB5, 0x62 };
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 常量无符号字符 UBX_HEADER[] = { 0xB5, 0x62 };
- en: struct NAV_PVT { // This sets the GPS navigation data
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体 NAV_PVT { // 设定 GPS 导航数据
- en: unsigned char cls;
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号字符 cls;
- en: unsigned char id;
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号字符 id;
- en: unsigned short len;
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号短整型 len;
- en: unsigned long iTOW; // GPS time of week of the navigation epoch (ms)
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号长整型 iTOW; // 导航周期的GPS时间周（毫秒）
- en: unsigned short year;     // Year (UTC)
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号短整型 year;     // 年份 (UTC)
- en: unsigned char month;     // Month, range 1..12 (UTC)
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号字符 month;     // 月份，范围 1..12 (UTC)
- en: unsigned char day;       // Day of month, range 1..31 (UTC)
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号字符 day;        // 月日，范围 1..31 (UTC)
- en: unsigned char hour;      // Hour of day, range 0..23 (UTC)
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号字符 hour;      // 小时，范围 0..23 (UTC)
- en: unsigned char minute;    // Minute of hour, range 0..59 (UTC)
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号字符 minute;    // 分钟，范围 0..59 (UTC)
- en: unsigned char second;    // Seconds of minute, range 0..60 (UTC)
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号字符 second;    // 分钟中的秒数，范围 0..60 (UTC)
- en: char valid;              // Validity Flags (see graphic below)
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 字符 valid;            // 有效性标志（见下图）
- en: unsigned long tAcc;      // Time accuracy estimate (UTC) (ns)
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号长整型 tAcc;      // 时间精度估计（UTC）（纳秒）
- en: long nano;               // Fraction of second, range -1e9 .. 1e9 (UTC) (ns)
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 长整型 nano;               // 秒的小数部分，范围 -1e9 .. 1e9 (UTC)（纳秒）
- en: unsigned char fixType;   // GNSSfix Type, range 0..5
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号字符 fixType;   // GNSS修复类型，范围 0..5
- en: char flags;              // Fix Status Flags
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 字符 flags;            // 修复状态标志
- en: unsigned char reserved1; // Reserved
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号字符 reserved1; // 保留
- en: unsigned char numSV;     // Number of satellites used in Nav Solution
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号字符 numSV;     // 导航解算中使用的卫星数量
- en: long lon;           // Longitude (deg)
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 长整型 lon;           // 经度（度）
- en: long lat;           // Latitude (deg)
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 长整型 lat;           // 纬度（度）
- en: long height;        // Height above Ellipsoid (mm)
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 长整型 height;        // 椭球体以上的高度（毫米）
- en: long hMSL;          // Height above mean sea level (mm)
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 长整型 hMSL;          // 平均海平面以上的高度（毫米）
- en: unsigned long hAcc; // Horizontal Accuracy Estimate (mm)
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号长整型 hAcc; // 水平精度估计（毫米）
- en: unsigned long vAcc; // Vertical Accuracy Estimate (mm)
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号长整型 vAcc; // 垂直精度估计（毫米）
- en: long velN;                // NED north velocity (mm/s)
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 长整型 velN;            // NED 北向速度（毫米/秒）
- en: long velE;                // NED east velocity (mm/s)
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 长整型 velE;            // NED 东向速度（毫米/秒）
- en: long velD;                // NED down velocity (mm/s)
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 长整型 velD;            // NED 向下速度（毫米/秒）
- en: long gSpeed;              // Ground Speed (2-D) (mm/s)
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 长整型 gSpeed;            // 地面速度（2-D）（毫米/秒）
- en: long heading;             // Heading of motion 2-D (deg)
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 长整型 heading;            // 运动的航向 2-D（度）
- en: unsigned long sAcc;       // Speed accuracy estimate
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号长整型 sAcc;       // 速度精度估计
- en: unsigned long headingAcc; // Heading accuracy estimate
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号长整型 headingAcc; // 航向精度估计
- en: unsigned short pDOP;      // Position dilution of precision
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号短整型 pDOP;      // 位置精度衰减
- en: short reserved2;          // Reserved
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 短整型 reserved2;          // 保留
- en: unsigned long reserved3;  // Reserved
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号长整型 reserved3;  // 保留
- en: '};'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: NAV_PVT pvt;
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: NAV_PVT pvt;
- en: void calcChecksum(unsigned char* CK) {
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 无返回类型 calcChecksum(无符号字符* CK) {
- en: memset(CK, 0, 2);
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: memset(CK, 0, 2);
- en: for (int i = 0; i < (int)sizeof(NAV_PVT); i++) {
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 (int i = 0; i < (int)sizeof(NAV_PVT); i++) {
- en: CK[0] += ((unsigned char*)(&pvt))[i];
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: CK[0] += ((无符号字符*)(&pvt))[i];
- en: CK[1] += CK[0];
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: CK[1] += CK[0];
- en: '}'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: long numGPSMessagesReceived = 0;
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 长整型 numGPSMessagesReceived = 0;
- en: bool processGPS() {
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔类型 processGPS() {
- en: static int fpos = 0;
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 静态整型 fpos = 0;
- en: static unsigned char checksum[2];
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 静态无符号字符 checksum[2];
- en: const int payloadSize = sizeof(NAV_PVT);
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 常量整型 payloadSize = sizeof(NAV_PVT);
- en: while ( GPS.available() ) {
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 当 GPS.available() 时 {
- en: byte c = GPS.read();
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 字节 c = GPS.read();
- en: if ( fpos < 2 ) {
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ( fpos < 2 ) {
- en: if ( c == UBX_HEADER[fpos] )
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ( c == UBX_HEADER[fpos] )
- en: fpos++;
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: fpos++;
- en: else
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 否则
- en: fpos = 0;
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: fpos = 0;
- en: '}'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else {
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 否则 {
- en: if ( (fpos-2) < payloadSize )
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ( (fpos-2) < payloadSize )
- en: ((unsigned char*)(&pvt))[fpos-2] = c;
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: ((无符号字符*)(&pvt))[fpos-2] = c;
- en: fpos++;
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: fpos++;
- en: if ( fpos == (payloadSize+2) ) {
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ( fpos == (payloadSize+2) ) {
- en: calcChecksum(checksum);
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: calcChecksum(checksum);
- en: '}'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else if ( fpos == (payloadSize+3) ) {
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 否则如果 ( fpos == (payloadSize+3) ) {
- en: if ( c != checksum[0] )
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ( c != checksum[0] )
- en: fpos = 0;
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: fpos = 0;
- en: '}'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else if ( fpos == (payloadSize+4) ) {
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 否则如果 ( fpos == (payloadSize+4) ) {
- en: fpos = 0;
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: fpos = 0;
- en: if ( c == checksum[1] ) {
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ( c == checksum[1] ) {
- en: return true;
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 true;
- en: '}'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else if ( fpos > (payloadSize+4) ) {
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 否则如果 ( fpos > (payloadSize+4) ) {
- en: fpos = 0;
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: fpos = 0;
- en: '}'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return false;
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 false;
- en: '}'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void setup() {
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 无返回类型 setup() {
- en: GPS.begin(9600);
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: GPS.begin(9600);
- en: u8g.setColorIndex(1);
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: u8g.setColorIndex(1);
- en: // Send configuration data in UBX protocol
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: // 通过 UBX 协议发送配置数据
- en: for (unsigned int i = 0; i < sizeof(UBLOX_INIT); i++) {
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: for (unsigned int i = 0; i < sizeof(UBLOX_INIT); i++) {
- en: GPS.write( pgm_read_byte(UBLOX_INIT+i) );
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: GPS.write( pgm_read_byte(UBLOX_INIT+i) );
- en: delay(5); // Simulate a 38400baud pace (or less),
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: delay(5); // 模拟38400波特率的速度（或更低）
- en: // or otherwise commands are not accepted by the device
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: // 或者设备未接受命令
- en: '}'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: long gSpeed = 0;
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: long gSpeed = 0;
- en: int numSV = 0;
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: int numSV = 0;
- en: unsigned long lastScreenUpdate = 0;
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: unsigned long lastScreenUpdate = 0;
- en: char speedBuf[16];
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: char speedBuf[16];
- en: char satsBuf[16];
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: char satsBuf[16];
- en: char* spinner = "/-\\|"; // Symbol for the spinner on screen to
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: char* spinner = "/-\\|"; // 屏幕上的旋转符号
- en: // show communication
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: // 显示通信状态
- en: byte screenRefreshSpinnerPos = 0;
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: byte screenRefreshSpinnerPos = 0;
- en: byte gpsUpdateSpinnerPos = 0;
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: byte gpsUpdateSpinnerPos = 0;
- en: void loop() {
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: void loop() {
- en: if (processGPS()) {
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: if (processGPS()) {
- en: numSV = pvt.numSV;
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: numSV = pvt.numSV;
- en: gSpeed = pvt.gSpeed;
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: gSpeed = pvt.gSpeed;
- en: gpsUpdateSpinnerPos = (gpsUpdateSpinnerPos + 1) % 4;
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: gpsUpdateSpinnerPos = (gpsUpdateSpinnerPos + 1) % 4;
- en: '}'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: unsigned long now = millis();
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: unsigned long now = millis();
- en: if (now - lastScreenUpdate > 100) {
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: if (now - lastScreenUpdate > 100) {
- en: updateScreen();
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: updateScreen();
- en: lastScreenUpdate = now;
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: lastScreenUpdate = now;
- en: screenRefreshSpinnerPos = (screenRefreshSpinnerPos + 1) % 4;
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: screenRefreshSpinnerPos = (screenRefreshSpinnerPos + 1) % 4;
- en: '}'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void draw() {
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: void draw() {
- en: u8g.setFont(u8g_font_courB24);
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: u8g.setFont(u8g_font_courB24);
- en: u8g.drawStr( 36, 45, speedBuf);
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: u8g.drawStr( 36, 45, speedBuf);
- en: u8g.setFont(u8g_font_fur11);
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: u8g.setFont(u8g_font_fur11);
- en: u8g.drawStr( 2, 12, satsBuf);
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: u8g.drawStr( 2, 12, satsBuf);
- en: '}'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void updateScreen() {
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: void updateScreen() {
- en: int kmh = gSpeed * 0.0036;
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: int kmh = gSpeed * 0.0036;
- en: sprintf(speedBuf, "%3d", kmh);
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: sprintf(speedBuf, "%3d", kmh);
- en: sprintf(satsBuf, "%c %c %d", spinner[screenRefreshSpinnerPos], spinner[gpsUpdateSpinnerPos],
    numSV);
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: sprintf(satsBuf, "%c %c %d", spinner[screenRefreshSpinnerPos], spinner[gpsUpdateSpinnerPos],
    numSV);
- en: u8g.firstPage();
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: u8g.firstPage();
- en: do {
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: do {
- en: draw();
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: draw();
- en: '} while( u8g.nextPage() );'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '} while( u8g.nextPage() );'
- en: '}'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**TROUBLESHOOTING**'
  id: totrans-647
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**故障排除**'
- en: '**Q.** *The code compiles, but the expected information is not shown onscreen.*'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q.** *代码编译通过，但预期信息未显示在屏幕上。*'
- en: • If nothing shows on the OLED screen, recheck that your wiring matches [Figure
    25-5](ch25.xhtml#ch25fig5); it’s quite easy to reverse the TX and RX wires accidentally.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果OLED屏幕上什么都没有显示，请重新检查接线是否与[图25-5](ch25.xhtml#ch25fig5)一致；TX和RX线很容易接错。
- en: • The symbols at the top left of the screen will rotate to show the screen is
    working correctly and that the GPS module is receiving data. If the far-left symbol
    spins but not the GPS symbol, you have your TX and RX wires crossed; recheck the
    wiring for the module.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: • 屏幕左上角的符号会旋转，表示屏幕工作正常并且GPS模块正在接收数据。如果最左边的符号旋转而GPS符号没有旋转，说明你的TX和RX线接错了；请重新检查模块的接线。
- en: • The GPS module works best outdoors and should have line of sight to the satellites
    orbiting the earth, so try repositioning the module until you get a reading. It
    can take 30–60 seconds to get a stable reading.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: • GPS模块在户外效果最佳，应该能看到绕地球轨道的卫星，所以请尝试重新放置模块，直到获得信号读取。稳定信号的获取可能需要30到60秒。
- en: • Remember that the OLED screen should be connected to 3.3V and not 5V.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: • 请记住，OLED屏幕应连接到3.3V，而不是5V。
