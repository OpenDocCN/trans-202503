<html><head></head><body>
<h2 class="h2c" id="ch12"><span epub:type="pagebreak" id="page_245"/><span class="big1"><strong>12</strong></span><br/><strong>STAYING HIDDEN</strong></h2>&#13;
<div class="image"><img src="../images/common.jpg" alt="image"/></div>&#13;
<p class="noindent">Game hacking is an ever-evolving practice, a game of cat and mouse between hackers and game developers where each party works to subvert the other. As long as people make bots, game companies will find ways to hinder bot advances and ban players who use bots. Rather than making their games inherently harder to hack, though, game companies focus on <em>detection</em>.</p>&#13;
<p class="indent">The largest game companies have very sophisticated detection suites called <em>anti-cheat software</em>. In the beginning of this chapter, I’ll discuss the capabilities of the most common anti-cheat suites. After revealing how these suites detect bots, I’ll teach you some powerful ways to evade them.</p>&#13;
<h3 class="h3" id="ch00lev1sec244"><span epub:type="pagebreak" id="page_246"/><strong>Prominent Anti-Cheat Software</strong></h3>&#13;
<p class="noindent">The best-known anti-cheat suites use the same methods as most antivirus software to scan for bots and flag them as threats. Some anti-cheat suites are also dynamic, meaning their inner workings and capabilities can change based on the game they’re protecting. Anti-cheat software developers also track down and patch their suites against bypass software, so always do your own in-depth research of any anti-cheat software that you might face.</p>&#13;
<p class="indent">When these suites detect a botter, they flag the botter’s account for banishment. Every few weeks, game company administrators ban the flagged players in a <em>ban wave</em>. Game companies use ban waves instead of instantaneous bans because banning in waves is more profitable. If botters are banned after a few weeks of playing, their familiarity with the game will make them more likely to buy a new account than if they were banned the moment their bot started running.</p>&#13;
<p class="indent">There are dozens of anti-cheat suites, but I’ll focus on the five packages that are the most common and thoroughly understood: <em>PunkBuster</em>, <em>ESEA Anti-Cheat</em>, <em>Valve Anti-Cheat (VAC)</em>, <em>GameGuard</em>, and <em>Warden</em>.</p>&#13;
<h3 class="h3" id="ch00lev1sec245"><strong>The PunkBuster Toolkit</strong></h3>&#13;
<p class="noindent">PunkBuster, made by Even Balance Inc., is the original anti-cheat toolkit. Many games use PunkBuster, but it’s most common in first-person shooter games like <em>Medal of Honor</em>, <em>Far Cry 3</em>, and several installments of the <em>Battlefield</em> series.</p>&#13;
<p class="indent">The toolkit uses a myriad of detection methods, the most formidable of which are signature-based detection (SBD), screenshots, and hash validation. PunkBuster is also known for imposing hardware bans that permanently ban a cheater’s computer, rather than just their game account, by saving a fingerprint of the hardware’s serial numbers and blocking logins from a machine that matches it.</p>&#13;
<h4 class="h4" id="ch00lev1sec246"><strong><em>Signature-Based Detection</em></strong></h4>&#13;
<p class="noindent">PunkBuster scans the memory of all processes on a system running a game that employs it, searching for byte patterns unique to known cheat software, called <em>signatures</em>. If PunkBuster detects a signature, the player is flagged for a ban. PunkBuster carries out memory scans from user mode using the <span class="literal">NtQueryVirtualMemory()</span> Windows API function, and it sometimes runs scans from multiple hidden processes.</p>&#13;
<p class="indent">Signature-based detection is blind to context by design, and it ultimately suffers from a fatal flaw: false positives. On March 23, 2008, a team of hackers set out to prove the existence of this flaw by spamming public chatrooms with a text string that PunkBuster would identify as a bot signature. Since SBD blindly scans process memory for matching patterns, any and all legitimate players inside these public chatrooms were flagged as botters.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_247"/>This caused thousands of fair players to be banned with no justification. A similar situation happened again in November 2013: PunkBuster falsely banned thousands of players on <em>Battlefield 4</em>. That time, no one was trying to prove a point; the company had just added a bad signature to its software.</p>&#13;
<p class="indent">PunkBuster resolved both of these issues by restoring the players’ accounts, but these incidents show just how aggressive its flavor of SBD is. In the time since these attacks, though, PunkBuster’s SBD has reduced the number of false positives by checking only for signatures at predefined binary offsets.</p>&#13;
<h4 class="h4" id="ch00lev1sec247"><strong><em>Screenshots</em></strong></h4>&#13;
<p class="noindent">As another method of bot detection, PunkBuster also periodically takes screenshots of a player’s screen and sends them to the central game server. This form of detection is a nuisance, and it’s weak compared to SDB. Game-hacking communities speculate that PunkBuster implemented this feature to give game admins proof against botters who dispute bans.</p>&#13;
<h4 class="h4" id="ch00lev1sec248"><strong><em>Hash Validation</em></strong></h4>&#13;
<p class="noindent">In addition to employing SBD and screenshots, PunkBuster detects bots by creating cryptographic hashes of a game’s executable binaries on a player’s system and comparing them to hashes stored on a central server. If the hashes do not match, the player is flagged for a ban. This check is carried out only on the binaries on the filesystem, not on in-memory binaries.</p>&#13;
<h3 class="h3" id="ch00lev1sec249"><strong>The ESEA Anti-Cheat Toolkit</strong></h3>&#13;
<p class="noindent">The ESEA Anti-Cheat toolkit is used by the <em>E-Sports Entertainment Association (ESEA)</em>, primarily for its <em>Counter-Strike: Global Offensive</em> league. Unlike PunkBuster, this suite is known for generating very few false positives and being highly effective at catching cheaters.</p>&#13;
<p class="indent">ESEA Anti-Cheat’s detection capabilities resemble those of PunkBuster, with one noteworthy difference. ESEA Anti-Cheat’s SBD algorithm is carried out from a kernel-mode driver using three different Windows Kernel functions: the <span class="literal">MmGetPhysicalMemoryRanges()</span> function, the <span class="literal">ZwOpenSection()</span> function, and the <span class="literal">ZwMapViewOfSection()</span> function. This implementation makes the anti-cheat system nearly immune to memory spoofing (a common way to defeat SBD), as the functions used by the scan are much harder to hook when they’re called from a driver.</p>&#13;
<h3 class="h3" id="ch00lev1sec250"><strong>The VAC Toolkit</strong></h3>&#13;
<p class="noindent">VAC is the toolkit Valve Corporation applies to its own games and many of the third-party games available on its Steam gaming platform. VAC uses SDB and hash validation methods that resemble PunkBuster’s detection techniques, and it also uses Domain Name System (DNS) cache scans and binary validation.</p>&#13;
<h4 class="h4" id="ch00lev1sec251"><span epub:type="pagebreak" id="page_248"/><strong><em>DNS Cache Scans</em></strong></h4>&#13;
<p class="noindent">DNS is a protocol that converts between domain names and IP addresses smoothly, and the DNS cache is where that information gets stored on a computer. When VAC’s SBD algorithm detects cheat software, VAC scans the player’s DNS cache for any domain names associated with cheating websites. It’s not certain whether a positive DNS cache scan is required for VAC’s SBD algorithm to flag a player for banishment, or if the DNS cache scan simply acts as another nail in the coffin for players who are already flagged by SBD.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>To see your DNS cache, enter <strong><span class="literal">ipconfig /displaydns</span></strong> at a command prompt. Yes, VAC looks at all of that.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec252"><strong><em>Binary Validation</em></strong></h4>&#13;
<p class="noindent">VAC also uses binary validation to prevent in-memory tampering of executable binaries. It scans for modifications like IAT, jump, and code hooking by comparing hashes of in-memory binary code to hashes of the same code in the binaries on the filesystem. If it finds a mismatch, VAC flags the player for a ban.</p>&#13;
<p class="indent">This detection method is formidable, but Valve’s initial implementation of the algorithm was flawed. In July 2010, VAC’s binary validation falsely banned 12,000 <em>Call of Duty</em> players. The binary validation module failed to account for a Steam update, and it banned the players when their in-memory code did not match the updated binaries on the filesystem.</p>&#13;
<h4 class="h4" id="ch00lev1sec253"><strong><em>False Positives</em></strong></h4>&#13;
<p class="noindent">VAC has had other issues with false positives. Its initial release routinely banned fair players for “faulty memory.” This same early version banned players for using <em>Cedega</em>, a platform that ran Windows games on Linux. And on April 1, 2004, Valve falsely banned a couple thousand players due to a server-side glitch. On two separate occasions, one in June 2011 and one in February 2014, VAC also falsely banned thousands of <em>Team Fortress 2</em> and <em>Counter-Strike</em> players due to bugs that the company refuses to disclose. As with PunkBuster, these incidents show that VAC is very aggressive.</p>&#13;
<h3 class="h3" id="ch00lev1sec254"><strong>The GameGuard Toolkit</strong></h3>&#13;
<p class="noindent">GameGuard is an anti-cheat toolkit made by INCA Internet Co. Ltd. and used by many MMORPGs, including <em>Lineage II</em>, <em>Cabal Online</em>, and <em>Ragnarok Online</em>. In addition to some mildly aggressive SBD, GameGuard uses rootkits to proactively prevent cheat software from running.</p>&#13;
<h4 class="h4" id="ch00lev1sec255"><strong><em>User-Mode Rootkit</em></strong></h4>&#13;
<p class="noindentb">GameGuard utilizes a user-mode rootkit to deny bots access to the Windows API functions they use to operate. The rootkit hooks the functions at their <span epub:type="pagebreak" id="page_249"/>lowest-level entry point, often inside undocumented functions in <em>ntdll.dll</em>, <em>user32.dll</em>, and <em>kernel32.dll</em>. These are the most notable API functions GameGuard hooks, and here’s what GameGuard does from inside each hooked function:</p>&#13;
<p class="noindenth"><span class="literal"><span class="codestrong">NtOpenProcess()</span></span> Blocks any <span class="literal">OpenProcess()</span> attempts on the game being protected.</p>&#13;
<p class="noindenth"><span class="literal"><span class="codestrong">NtProtectVirtualMemory()</span></span> Blocks any <span class="literal">VirtualProtect()</span> or <span class="literal">VirtualProtectEx()</span> attempts on the game.</p>&#13;
<p class="noindenth"><span class="literal"><span class="codestrong">NtReadVirtualMemory()</span></span> <strong>and</strong> <span class="literal"><span class="codestrong">NtWriteVirtualMemory()</span></span> Block any <span class="literal">ReadProcessMemory()</span> and <span class="literal">WriteProcessMemory()</span> attempts on the game.</p>&#13;
<p class="noindenth"><span class="literal"><span class="codestrong">NtSuspendProcess()</span></span> <strong>and</strong> <span class="literal"><span class="codestrong">NtSuspendThread()</span></span> Block any attempts to suspend GameGuard.</p>&#13;
<p class="noindenth"><span class="literal"><span class="codestrong">NtTerminateProcess()</span></span> <strong>and</strong> <span class="literal"><span class="codestrong">NtTerminateThread()</span></span> Block any attempts to terminate GameGuard.</p>&#13;
<p class="noindenth"><span class="literal"><span class="codestrong">PostMessage()</span></span>, <span class="literal"><span class="codestrong">SendMessage()</span></span><strong>, and</strong> <span class="literal"><span class="codestrong">SendInput()</span></span> Block any attempts to send programmatic input to the game.</p>&#13;
<p class="noindenth"><span class="literal"><span class="codestrong">SetWindowsHookEx()</span></span> Prevents bots from globally intercepting mouse and keyboard input.</p>&#13;
<p class="noindenth"><span class="literal"><span class="codestrong">CreateProcessInternal()</span></span> Automatically detects and hooks into new processes.</p>&#13;
<p class="noindenth"><span class="literal"><span class="codestrong">GetProcAddress()</span></span>, <span class="literal"><span class="codestrong">LoadLibraryEx()</span></span><strong>, and</strong> <span class="literal"><span class="codestrong">MapViewOfFileEx()</span></span> Prevent any attempt to inject libraries into the game or GameGuard.</p>&#13;
<h4 class="h4" id="ch00lev1sec256"><strong><em>Kernel-Mode Rootkit</em></strong></h4>&#13;
<p class="noindent">GameGuard also uses a driver-based rootkit to prevent bots that work in the kernel. This rootkit has the same abilities as its user-mode counterpart, and it works by hooking <span class="literal">ZwProtectVirtualMemory()</span>, <span class="literal">ZwReadVirtualMemory()</span>, <span class="literal">ZwWriteVirtualMemory()</span>, <span class="literal">SendInput()</span>, and similar functions.</p>&#13;
<h3 class="h3" id="ch00lev1sec257"><strong>The Warden Toolkit</strong></h3>&#13;
<p class="noindentb">Warden, made exclusively for Blizzard’s games, is by far the most advanced anti-bot toolkit I’ve encountered. It’s hard to say what exactly Warden does, because it downloads dynamic code at runtime. This code, delivered as compiled shellcode, typically has two responsibilities:</p>&#13;
<p class="bull">• Detect bots.</p>&#13;
<p class="bull">• Periodically send a heartbeat signal to the game server. The value sent is not predefined but instead is generated by some subset of the detection code.</p>&#13;
<p class="indentt">If Warden fails to complete the second task or sends the wrong value, the game server will know that it’s been disabled or tampered with. Furthermore, a bot can’t disable the detection code and leave the heartbeat code running.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><span epub:type="pagebreak" id="page_250"/><strong>THE HALTING PROBLEM</strong></p>&#13;
<p class="noindent">A bot that could disable Warden’s detection code and still send the heartbeat signal would solve the <em>halting problem</em>, which Alan Turing proved to be impossible in 1936. The halting problem is the problem of determining, with a generic algorithm, whether a program will finish running or continue forever. Because Warden does two tasks using the same shellcode, writing a generic algorithm that can disable just one task is a variation of the halting problem: the algorithm can’t be sure which parts of the code will definitely execute, which parts won’t, and which parts are responsible for each task.</p>&#13;
</div>&#13;
<p class="indent">Warden is formidable because you not only have no way to know what you’re hiding from but also have no way to disable the toolkit. Even if you manage to avoid detection today, a new detection method might be used tomorrow.</p>&#13;
<p class="indent">If you plan on publicly distributing bots, you will eventually meet one of the anti-cheat solutions described in the previous sections—and you’ll have to beat it. Depending on your bot’s footprint, the type of detection in the game you’re botting, and your implementation, the difficulty of evading one of these toolkits can range from trivial to extremely hard.</p>&#13;
<h3 class="h3" id="ch00lev1sec258"><strong>Carefully Managing a Bot’s Footprint</strong></h3>&#13;
<p class="noindent">A bot’s <em>footprint</em> is how many unique, detectable characteristics it has. For example, a bot that hooks 100 functions will typically be easier to detect than a bot that hooks only 10 functions because the former makes an order of magnitude more changes to a game’s code than the latter. Since a targeted detection system needs to detect only one hook, the developer of the former bot needs to spend much more time making sure all of the bot’s hooks are as stealthy as possible.</p>&#13;
<p class="indent">Another footprint characteristic is how detailed a bot’s user interface is. If a known bot has many dialog boxes that all have specific titles, a game company can just have its anti-cheat software detect the bot by searching for windows that have those titles. This same basic reasoning can be used with process names and filenames.</p>&#13;
<h4 class="h4" id="ch00lev1sec259"><strong><em>Minimizing a Bot’s Footprint</em></strong></h4>&#13;
<p class="noindent">Depending on how your bot works, there are many ways to minimize its footprint. If your bot relies heavily on hooks, for instance, you can avoid directly hooking a game’s code and instead focus on hooking Windows API functions. Windows API hooking is surprisingly common, so developers can’t assume a program that hooks the Windows API is a bot.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_251"/>If your bot has a well-defined user interface, you can mask the interface by removing all strings from window bars, buttons, and so on. Instead, display images that show text. If you’re worried about specific process names or filenames being detected by the anti-cheat software, use generic filenames and make your bot copy itself to a new, randomized directory every time it launches.</p>&#13;
<h4 class="h4" id="ch00lev1sec260"><strong><em>Masking Your Footprint</em></strong></h4>&#13;
<p class="noindent">Minimizing your footprint is a preferred way to avoid detection, but it’s not necessary. You can also obfuscate your bot, making it harder for anyone to figure out how it works. Obfuscation can prevent both anti-bot developers from trying to detect your bot and other bot developers from analyzing your bot to steal proprietary functionality. If you sell your bot, obfuscation prevents people from cracking it to bypass your purchase verification, too.</p>&#13;
<p class="indent">One common type of obfuscation is called <em>packing</em>. Packing an executable encrypts it and hides it inside another executable. When the container executable is launched, the packed executable is decrypted and executed in-memory. When a bot is packed, analyzing the binary to learn what the bot does is impossible, and debugging the bot process is much harder. Some common packer programs are <em>UPX</em>, <em>Armadillo</em>, <em>Themida</em>, and <em>ASPack</em>.</p>&#13;
<h4 class="h4" id="ch00lev1sec261"><strong><em>Teaching a Bot to Detect Debuggers</em></strong></h4>&#13;
<p class="noindent">When anti-bot developers (or other bot creators) can debug a bot, they can figure out how it works and thus how to stop it. If someone is actively trying to pick apart a bot, packing the executable may not be enough to evade them. To protect against this, bots often employ <em>anti-debugging</em> techniques, which obfuscate control flow by changing the bot’s behavior when a debugger is detected. In this section, I’ll quickly cover some well-known methods for detecting when a debugger is attached to your bot, and in the next, I’ll show you some tricks for obfuscation.</p>&#13;
<h5 class="h5" id="ch00lev1sec262"><strong>Calling CheckRemoteDebuggerPresent()</strong></h5>&#13;
<p class="noindent"><span class="literal">CheckRemoteDebuggerPresent()</span> is a Windows API function that can tell you if a debugger is attached to the current process. Code to check for a debugger might look like this:</p>&#13;
<p class="programs">bool IsRemoteDebuggerPresent() {<br/>    BOOL dbg = false;<br/>    CheckRemoteDebuggerPresent(GetCurrentProcess(), &amp;dbg);<br/>    return dbg;<br/>}</p>&#13;
<p class="indent">This check is pretty straightforward—it calls <span class="literal">CheckRemoteDebuggerPresent()</span> with the current process and a pointer to the <span class="literal">dbg</span> Boolean. Calling this function is the easiest way to detect a debugger, but it’s also very easy for a debugger to evade.</p>&#13;
<h5 class="h5" id="ch00lev1sec263"><span epub:type="pagebreak" id="page_252"/><strong>Checking for Interrupt Handlers</strong></h5>&#13;
<p class="noindent"><em>Interrupts</em> are signals the processor sends to trigger a corresponding handler in the Windows kernel. Interrupts are typically generated by hardware events, but they can also be generated in software using the INT assembly instruction. The kernel allows some interrupts—namely, interrupts 0x2D and 0x03—to trigger user-mode interrupt handlers in the form of exception handlers. You can take advantage of these interrupts to detect debuggers.</p>&#13;
<p class="indent">When a debugger sets a breakpoint on an instruction, it replaces that instruction with a breakpoint instruction, such as INT 0x03. When the interrupt is executed, the debugger is notified via an exception handler, where it handles the breakpoint, replaces the original code, and allows the application to resume execution seamlessly. When faced with an unrecognized interrupt, some debuggers even silently step over that interrupt and allow execution to continue normally, without triggering any other exception handlers.</p>&#13;
<p class="indent">You can detect this behavior by purposely generating interrupts within exception handlers in your code, as shown in <a href="ch12.xhtml#ch12exe1">Listing 12-1</a>.</p>&#13;
<p class="programs">inline bool Has2DBreakpointHandler() {<br/>    __try { __asm INT 0x2D }<br/>    __except (EXCEPTION_EXECUTE_HANDLER){ return false; }<br/>    return true;<br/>}<br/><br/>inline bool Has03BreakpointHandler() {<br/>    __try { __asm INT 0x03 }<br/>    __except (EXCEPTION_EXECUTE_HANDLER){ return false; }<br/>    return true;<br/>}</p>&#13;
<p class="listt"><a id="ch12exe1"/><em>Listing 12-1: Detecting interrupt handlers</em></p>&#13;
<p class="indent">During normal execution, these interrupts trigger the exception handlers surrounding them in the code. During a debugging session, some debuggers might intercept the exceptions generated by these interrupts and silently ignore them, preventing the surrounding exception handlers from executing. Thus, if the interrupts don’t trigger your exception handler, then a debugger is present.</p>&#13;
<h5 class="h5" id="ch00lev1sec264"><strong>Checking for Hardware Breakpoints</strong></h5>&#13;
<p class="noindent">Debuggers can also set breakpoints using the processor’s debug registers; these are called <em>hardware breakpoints</em>. A debugger can set a hardware breakpoint on an instruction by writing the address of the instruction to one of the four debug registers.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_253"/>When an address present on a debug register is executed, the debugger is notified. To detect hardware breakpoints (and thus, the presence of a debugger), you can check for nonzero values on any of the four debug registers like this:</p>&#13;
<p class="programs">bool HasHardwareBreakpoints() {<br/>    CONTEXT ctx = {0};<br/>    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;<br/>    auto hThread = GetCurrentThread();<br/>    if(GetThreadContext(hThread, &amp;ctx) == 0)<br/>        return false;<br/>    return (ctx.Dr0 != 0 || ctx.Dr1 != 0 || ctx.Dr2 != 0 || ctx.Dr3 != 0);<br/>}</p>&#13;
<h5 class="h5" id="ch00lev1sec265"><strong>Printing Debug Strings</strong></h5>&#13;
<p class="noindent"><span class="literal">OutputDebugString()</span> is a Windows API function that can be used to print log messages to a debugger console. If no debugger is present, the function will return with an error code. If a debugger is present, however, the function will return with no error code. Here’s how you can use this function as a trivial debugger check:</p>&#13;
<p class="programs">inline bool CanCallOutputDebugString() {<br/>    SetLastError(0);<br/>    OutputDebugStringA("test");<br/>    return (GetLastError() == 0);<br/>}</p>&#13;
<p class="indent">Like the <span class="literal">CheckRemoteDebuggerPresent()</span> method, this method is very straightforward but also very easy for a debugger to evade.</p>&#13;
<h5 class="h5" id="ch00lev1sec266"><strong>Checking for DBG_RIPEXCEPTION Handlers</strong></h5>&#13;
<p class="noindent">Debuggers typically have exception handlers that blindly catch exceptions with Windows’ <span class="literal">DBG_RIPEXCEPTION</span> exception code, making that code a clear way to spot a debugger. You can detect these exception handlers in much the same way <a href="ch12.xhtml#ch12exe1">Listing 12-1</a> detects interrupt handlers:</p>&#13;
<p class="programs">#define DBG_RIPEXCEPTION 0x40010007<br/>inline bool hasRIPExceptionHandler() {<br/>    __try { RaiseException(DBG_RIPEXCEPTION, 0, 0, 0); }<br/>    __except(EXCEPTION_EXECUTE_HANDLER){ return false; }<br/>    return true;<br/>}</p>&#13;
<h5 class="h5" id="ch00lev1sec267"><span epub:type="pagebreak" id="page_254"/><strong>Timing Control-Critical Routines</strong></h5>&#13;
<p class="noindent">If an anti-bot developer is debugging your bot, the developer will likely place breakpoints on and single-step through parts of your code that are critical to the bot’s behavior. You can detect this activity by measuring code execution times; when someone steps through code, execution takes a lot longer than usual.</p>&#13;
<p class="indent">For example, if a function only places some hooks, you can be sure that the code shouldn’t take more than a tenth of a second to do the memory protection. You could check the execution time for memory protection with help from the <span class="literal">GetTickCount()</span> Windows API function, as follows:</p>&#13;
<p class="programs">--<span class="codeitalic">snip</span>--<br/>auto startTime = GetTickCount();<br/>protectMemory&lt;&gt;(...);<br/>if (GetTickCount() - startTime &gt;= 100)<br/>    debuggerDetectedGoConfuseIt();<br/>--<span class="codeitalic">snip</span>--</p>&#13;
<h5 class="h5" id="ch00lev1sec268"><strong>Checking for Debug Drivers</strong></h5>&#13;
<p class="noindent">Some debuggers load kernel-mode drivers to assist their operation. You can detect these debuggers by attempting to get a handle to their kernel-mode drivers, like this:</p>&#13;
<p class="programs">bool DebuggerDriversPresent() {<br/>    // an array of common debugger driver device names<br/>    const char drivers[9][20] = {<br/>        "\\\\.\\EXTREM", "\\\\.\\ICEEXT",<br/>        "\\\\.\\NDBGMSG.VXD", "\\\\.\\RING0",<br/>        "\\\\.\\SIWVID", "\\\\.\\SYSER",<br/>        "\\\\.\\TRW", "\\\\.\\SYSERBOOT",<br/>        "\0"<br/>    };<br/>    for (int i = 0; drivers[i][0] != '\0'; i++) {<br/>        auto h = CreateFileA(drivers[i], 0, 0, 0, OPEN_EXISTING, 0, 0);<br/>        if (h != INVALID_HANDLE_VALUE) {<br/>            CloseHandle(h);<br/>            return true;<br/>        }<br/>    }<br/>    return false;<br/>}</p>&#13;
<p class="indent">There are a few common kernel-mode driver device names to check for, like <span class="literal">\\\\.\\EXTREM</span> and the others shown in the <span class="literal">drivers</span> array. If this handle-fetching code succeeds, then there’s a debugger running on the system. Unlike with the previous methods, though, obtaining a handle to one of those drivers doesn’t always mean the debugger is attached to your bot.</p>&#13;
<h4 class="h4" id="ch00lev1sec269"><span epub:type="pagebreak" id="page_255"/><strong><em>Anti-Debugging Techniques</em></strong></h4>&#13;
<p class="noindent">Once you detect a debugger, there are multiple ways to obfuscate your control flow. For instance, you might try to crash the debugger. The following code crashes OllyDbg v1.10:</p>&#13;
<p class="programs">OutputDebugString("%s%s%s%s");</p>&#13;
<p class="indent">The string <span class="literal">"%s%s%s%s"</span> contains format specifiers, and OllyDbg passes it to <span class="literal">printf()</span> without any extra parameters, which is why the debugger crashes. You could place this code in a function that gets called in response to detecting a debugger, but this option works only against OllyDbg.</p>&#13;
<h5 class="h5" id="ch00lev1sec270"><strong>Causing an Unavoidable Infinite Loop</strong></h5>&#13;
<p class="noindent">Another obfuscation method to try is overloading the system until the person debugging your bot is forced to close the bot and debugger. This function does the trick:</p>&#13;
<p class="programs">void SelfDestruct() {<br/>    std::vector&lt;char*&gt; explosion;<br/>    while (true)<br/>        explosion.push_back(new char[10000]);<br/>}</p>&#13;
<p class="indent">The infinite <span class="literal">while</span> loop just keeps adding elements to <span class="literal">explosion</span> until the process runs out of memory or someone pulls the plug.</p>&#13;
<h5 class="h5" id="ch00lev1sec271"><strong>Overflowing the Stack</strong></h5>&#13;
<p class="noindent">If you want to really confuse the analyst, you can make a chain of functions that eventually cause a stack overflow, but in an indirect way:</p>&#13;
<p class="programs">#include &lt;random&gt;<br/>typedef void (* _recurse)();<br/>void recurse1(); void recurse2();<br/>void recurse3(); void recurse4();<br/>void recurse5();<br/>_recurse recfuncs[5] = {<br/>    &amp;recurse1, &amp;recurse2, &amp;recurse3,<br/>    &amp;recurse4, &amp;recurse5<br/>};<br/>void recurse1() { recfuncs[rand() % 5](); }<br/>void recurse2() { recfuncs[(rand() % 3) + 2](); }<br/>void recurse3() {<br/>    if (rand() % 100 &lt; 50) recurse1();<br/>    else recfuncs[(rand() % 3) + 1]();<br/>}<br/>void recurse4() { recfuncs[rand() % 2](); }<br/>void recurse5() {<br/>    for (int i = 0; i &lt; 100; i++)<br/>        if (rand() % 50 == 1)<br/>            recfuncs[i % 5]();<br/>    recurse5();<br/>}<br/>// call any of the above functions to trigger a stack overflow</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_256"/>In a nutshell, these functions randomly and infinitely recurse until there’s no room left on the call stack. Causing the overflow indirectly makes it hard for the analyst to pause and examine previous calls before they realize what’s happened.</p>&#13;
<h5 class="h5" id="ch00lev1sec272"><strong>Causing a BSOD</strong></h5>&#13;
<p class="noindent">If you’re serious about obfuscation, you can even trigger a Blue Screen of Death (BSOD) when you detect a debugger. One way to do that is to set your bot’s process as critical using the <span class="literal">SetProcessIsCritical()</span> Windows API function and then call <span class="literal">exit()</span>, since Windows will trigger a BSOD when a critical process is killed. Here’s how you might do that:</p>&#13;
<p class="programs">void BSODBaby() {<br/>    typedef long (WINAPI *RtlSetProcessIsCritical)<br/>        (BOOLEAN New, BOOLEAN *Old, BOOLEAN NeedScb);<br/>    auto ntdll = LoadLibraryA("ntdll.dll");<br/>    if (ntdll) {<br/>        auto SetProcessIsCritical = (RtlSetProcessIsCritical)<br/>            GetProcAddress(ntdll, "RtlSetProcessIsCritical");<br/>        if (SetProcessIsCritical)<br/>            SetProcessIsCritical(1, 0, 0);<br/>    }<br/>}<br/><br/>BSODBaby();<br/>exit(1);</p>&#13;
<p class="indent">Or maybe you’re evil, in which case you can do this:</p>&#13;
<p class="programs">BSODBaby();<br/>OutputDebugString("%s%s%s%s");<br/>recurse1();<br/>exit(1);</p>&#13;
<p class="indent">Assuming you’ve implemented all of the techniques described in this section, this code would cause a BSOD, crash the debugger (if it’s OllyDbg v1.10), overflow the stack, and exit the running program. If any one of the methods fails or gets patched, the analyst still has to deal with the remaining ones before they can continue debugging.</p>&#13;
<h3 class="h3" id="ch00lev1sec273"><strong>Defeating Signature-Based Detection</strong></h3>&#13;
<p class="noindent">Even with amazing obfuscation, you won’t easily beat signature detection. Engineers who analyze bots and write signatures are very skilled, and obfuscation is, at best, a nuisance that makes their job marginally harder.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_257"/>To completely evade SBD, you need to subvert the detection code. This requires knowing exactly how the SBD works. PunkBuster, for instance, uses <span class="literal">NtQueryVirtualMemory()</span> to scan the memory of all running processes for any signatures. If you want to bypass this, you can inject code into all PunkBuster processes with a hook on the <span class="literal">NtQueryVirtualMemory()</span> function.</p>&#13;
<p class="indent">When the function tries to query memory from your bot process, you can give it whatever data you want, like this:</p>&#13;
<p class="programs">   NTSTATUS onNtQueryVirtualMemory(<br/>       HANDLE process, PVOID baseAddress,<br/>       MEMORY_INFORMATION_CLASS memoryInformationClass,<br/>       PVOID buffer, ULONG numberOfBytes, PULONG numberOfBytesRead) {<br/><br/>       // if the scan is on this process, make sure it can't see the hook DLL<br/>       if ((process == INVALID_HANDLE_VALUE ||<br/>           process == GetCurrentProcess()) &amp;&amp;<br/>           baseAddress &gt;= MY_HOOK_DLL_BASE &amp;&amp;<br/>           baseAddress &lt;= MY_HOOK_DLL_BASE_PLUS_SIZE)<br/><span class="ent">➊</span>             return STATUS_ACCESS_DENIED;<br/><br/>       // if the scan is on the bot, zero the returned memory<br/>       auto ret = origNtQueryVirtualMemory(<br/>           process, baseAddress,<br/>           memoryInformationClass,<br/>           buffer, numberOfBytes, numberOfBytesRead);<br/>       if(GetProcessId(process) == MY_BOT_PROCESS)<br/><span class="ent">➋</span>         ZeroMemory(buffer, numberOfBytesRead);<br/>       return ret;<br/>   }</p>&#13;
<p class="indent">This <span class="literal">onNtQueryVirtualMemory()</span> hook returns <span class="literal">STATUS_ACCESS_DENIED</span> <span class="ent">➊</span> when <span class="literal">NtQueryVirtualMemory()</span> tries to query the hook DLL’s memory, but it gives zeroed memory <span class="ent">➋</span> when <span class="literal">NtQueryVirtualMemory()</span> tries to query the bot’s memory. The difference isn’t for any specific reason; I’m just showing two ways you can hide from the <span class="literal">NtQueryVirtualMemory()</span> function call. If you’re really paranoid, you can even replace the entire buffer with a random byte sequence.</p>&#13;
<p class="indent">Of course, this method works only for SBD that happens from user mode, like the SBD in PunkBuster or VAC. SBD that happens from the driver, like ESEA’s, or that isn’t predictable, like Warden’s, isn’t as easy to bypass.</p>&#13;
<p class="indentb">In those cases, you can take precautions to eliminate unique signatures in your bot. If you’re distributing the bot to more than a dozen or so people, however, removing all distinguishing properties is tricky. To throw analysts off the scent, each time you give somebody a copy of the bot, you could try some combination of the following:</p>&#13;
<p class="bull">• Compiling the bot using a different compiler</p>&#13;
<p class="bull">• Changing the compiler optimization settings</p>&#13;
<p class="bull">• Toggling between using <span class="literal">__fastcall</span> and <span class="literal">__cdecl</span></p>&#13;
<p class="bull"><span epub:type="pagebreak" id="page_258"/>• Packing the binaries using a different packer</p>&#13;
<p class="bull">• Switching between static and dynamic linking of runtime libraries</p>&#13;
<p class="indentt">Varying these elements creates a different assembly for each user, but there’s a limit on how many unique versions of the bot you can produce that way. Past some point, this method doesn’t scale to demand, and eventually, game companies will have signatures for every incarnation of your bot.</p>&#13;
<p class="indent">Apart from obfuscation and code mutation, there aren’t many ways to defeat advanced SBD mechanisms. You could implement your bot in a driver or create a kernel-mode rootkit to hide your bot, but even those methods aren’t foolproof.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>This book doesn’t cover implementing a bot in a driver or creating a rootkit to hide a bot, as both topics are pretty complex. Rootkit development alone is a subject that dozens of books have covered already. I’d recommend Bill Blunden’s</em> The Rootkit Arsenal: Escape and Evasion in The Dark Corners of The System <em>(Jones &amp; Bartlett Learning, 2009).</em></p>&#13;
</div>&#13;
<p class="indent">Some game hackers try to cover every single base, hooking every memory-reading function and the entire filesystem API, but still get caught by determined systems like Warden. In fact, I recommend staying away from Warden and Blizzard at all costs.</p>&#13;
<h3 class="h3" id="ch00lev1sec274"><strong>Defeating Screenshots</strong></h3>&#13;
<p class="noindent">If you encounter a detection mechanism that uses screenshots as additional proof to nail botters, you’re in luck. Bypassing screenshot mechanisms is easy: don’t let your bot be seen.</p>&#13;
<p class="indent">You can subvert this type of detection by keeping a minimal UI and making no visibly distinguishable changes to the game client. If your bot requires a HUD or other distinctive UI displays, though, don’t fret—you can have your cake and eat it, too. As long as you can intercept the screenshot code, you can hide your fingerprints while a screenshot is taken.</p>&#13;
<p class="indent">In some versions of PunkBuster, for example, the Windows API function <span class="literal">GetSystemTimeAsFileTime()</span> is called just before a screenshot is taken. You can use a hook on this function to quickly hide your UI for a few seconds to ensure it’s not seen:</p>&#13;
<p class="programs">void onGetSystemTimeAsFileTime(LPFILETIME systemTimeAsFileTime) {<br/>    myBot-&gt;hideUI(2000); // hide UI for 2 seconds<br/>    origGetSystemTimeAsFileTime(systemTimeAsFileTime);<br/>}</p>&#13;
<p class="indent">Just hook <span class="literal">GetSystemTimeAsFileTime()</span> using the techniques described in “<a href="ch08.xhtml#ch00lev1sec151">Hooking to Redirect Game Execution</a>” on <a href="ch08.xhtml#page_153">page 153</a>, write a <span class="literal">hideUI()</span> function, and call the <span class="literal">hideUI()</span> function before execution resumes.</p>&#13;
<h3 class="h3" id="ch00lev1sec275"><span epub:type="pagebreak" id="page_259"/><strong>Defeating Binary Validation</strong></h3>&#13;
<p class="noindent">Defeating binary validation is as simple as not placing hooks inside game-specific binaries. Jump hooks and IAT hooks on Windows API functions are extremely common, so wherever you can, try to get away with using those methods instead of using jump or near-call hooks in a game binary. In cases where you must directly hook a game’s code, you can trick the anti-cheat software’s binary validation routines by intercepting the binary scan and spoofing the data to match what the software expects to see.</p>&#13;
<p class="indent">Like SBD, binary validation often uses <span class="literal">NtQueryVirtualMemory()</span> to scan memory. To trick the validation code, start with a hook on that function. Then, write a function like this one to spoof the data when <span class="literal">NtQueryVirtualMemory()</span> is called:</p>&#13;
<p class="programs">NTSTATUS onNtQueryVirtualMemory(<br/>    HANDLE process, PVOID baseAddress,<br/>    MEMORY_INFORMATION_CLASS memoryInformationClass,<br/>    PVOID buffer, ULONG numberOfBytes, PULONG numberOfBytesRead) {<br/><br/>    auto ret = origNtQueryVirtualMemory(<br/>        process, baseAddress,<br/>        memoryInformationClass,<br/>        buffer, numberOfBytes, numberOfBytesRead);<br/>    // place tricky code somewhere in here<br/>    return ret;<br/>}</p>&#13;
<p class="indent">Inside this hook, you’ll need to watch for any memory scans over memory that has been modified by one of your hooks.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>This example assumes the bot has only one hook and that variables prefixed with <span class="literal"><span class="codeitalic">HOOK_</span></span> already exist and describe the code the hook replaces.</em></p>&#13;
</div>&#13;
<p class="indent"><a href="ch12.xhtml#ch12exe2">Listing 12-2</a> shows some scan-monitoring code.</p>&#13;
<p class="programs">   // is the scan on the current process?<br/>   bool currentProcess =<br/>       process == INVALID_HANDLE_VALUE ||<br/>       process == GetCurrentProcess();<br/><br/>   // is the hook in the memory range being scanned?<br/>   auto endAddress = baseAddress + numberOfBytesRead - 1;<br/>   bool containsHook =<br/>       (HOOK_START_ADDRESS &gt;= baseAddress &amp;&amp;<br/>        HOOK_START_ADDRESS &lt;= endAddress) ||<br/>       (HOOK_END_ADDRESS &gt;= baseAddress &amp;&amp;<br/>        HOOK_END_ADDRESS &lt;= endAddress);<br/><span class="ent">➊</span> if (currentProcess &amp;&amp; containsHook) {<br/>       // hide the hook<br/>   }</p>&#13;
<p class="listt"><a id="ch12exe2"/><em>Listing 12-2: Checking whether hooked memory is being scanned</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_260"/>When a memory scan over the hooked code happens (which makes <span class="literal">currentProcess</span> and <span class="literal">containsHook</span> become <span class="literal">true</span> at the same time), code inside the <span class="literal">if()</span> statement <span class="ent">➊</span> updates the output buffer to reflect the original code. This means you must know where the hooked code is within the scanned block, taking into account the fact that the block may span only a subset of the hooked code.</p>&#13;
<p class="indent">So if <span class="literal">baseAddress</span> marks the address where the scan starts, <span class="literal">HOOK_START_ ADDRESS</span> marks the spot where the modified code starts, <span class="literal">endAddress</span> marks the address where the scan ends, and <span class="literal">HOOK_END_ADDRESS</span> marks the address where the modified code ends, you can use some simple math to calculate which parts of the modified code are present in which parts of the buffer. You do so as follows, using <span class="literal">writeStart</span> to store the offset of the modified code in the scan buffer and <span class="literal">readStart</span> to store the offset of the scan buffer relative to the modified code, in case the scan buffer starts in the middle of the modified code:</p>&#13;
<p class="programs">int readStart, writeStart;<br/>if (HOOK_START_ADDRESS &gt;= baseAddress) {<br/>    readStart = 0;<br/>    writeStart = HOOK_START_ADDRESS - baseAddress;<br/>} else {<br/>    readStart = baseAddress - HOOK_START_ADDRESS;<br/>    writeStart = baseAddress;<br/>}<br/><br/>int readEnd;<br/>if (HOOK_END_ADDRESS &lt;= endAddress)<br/>    readEnd = HOOK_LENGTH - readStart - 1;<br/>else<br/>    readEnd = endAddress – HOOK_START_ADDRESS;</p>&#13;
<p class="indent">Once you know how many bytes you need to replace, where to put them, and where to get them, you can do the spoof with three lines of code:</p>&#13;
<p class="programs">char* replaceBuffer = (char*)buffer;<br/>for ( ; readStart &lt;= readEnd; readStart++, writeStart++)<br/>    replaceBuffer[writeStart] = HOOK_ORIG_DATA[readStart];</p>&#13;
<p class="indent">Completely assembled, the code looks like this:</p>&#13;
<p class="programs">NTSTATUS onNtQueryVirtualMemory(<br/>    HANDLE process, PVOID baseAddress,<br/>    MEMORY_INFORMATION_CLASS memoryInformationClass,<br/>    PVOID buffer, ULONG numberOfBytes, PULONG numberOfBytesRead) {<br/>    auto ret = origNtQueryVirtualMemory(<br/>        process, baseAddress,<br/>        memoryInformationClass,<br/>        buffer, numberOfBytes, numberOfBytesRead);<br/>    bool currentProcess =<br/>        process == INVALID_HANDLE_VALUE ||<br/>        process == GetCurrentProcess();<br/>    auto endAddress = baseAddress + numberOfBytesRead - 1;<br/>    bool containsHook =<br/>        (HOOK_START_ADDRESS &gt;= baseAddress &amp;&amp;<br/>         HOOK_START_ADDRESS &lt;= endAddress) ||<br/>        (HOOK_END_ADDRESS &gt;= baseAddress &amp;&amp;<br/>         HOOK_END_ADDRESS &lt;= endAddress);<br/>    if (currentProcess &amp;&amp; containsHook) {<br/>        int readStart, writeStart;<br/>        if (HOOK_START_ADDRESS &gt;= baseAddress) {<br/>            readStart = 0;<br/>            writeStart = HOOK_START_ADDRESS - baseAddress;<br/>        } else {<br/>            readStart = baseAddress - HOOK_START_ADDRESS;<br/>            writeStart = baseAddress;<br/>        }<br/><br/>        int readEnd;<br/>        if (HOOK_END_ADDRESS &lt;= endAddress)<br/>            readEnd = HOOK_LENGTH - readStart - 1;<br/>        else<br/>            readEnd = endAddress – HOOK_START_ADDRESS;<br/><br/>        char* replaceBuffer = (char*)buffer;<br/>        for ( ; readStart &lt;= readEnd; readStart++, writeStart++)<br/>            replaceBuffer[writeStart] = HOOK_ORIG_DATA[readStart];<br/>    }<br/>    return ret;<br/>}</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_261"/>Of course, if you had multiple hooks that you needed to hide from binary validation scans, you would need to implement this functionality in a more robust way that would allow it to track multiple modified code regions accordingly.</p>&#13;
<h3 class="h3" id="ch00lev1sec276"><strong>Defeating an Anti-Cheat Rootkit</strong></h3>&#13;
<p class="noindent">GameGuard and some other anti-cheat suites come with user-mode rootkits that not only detect bots but also proactively prevent them from running. To defeat this type of protection, rather than think outside the box, you can completely copy the box and work inside that copy.</p>&#13;
<p class="indent">For example, if you want to write memory to a game, you must call the <span class="literal">WriteProcessMemory()</span> function, which is exported by <em>kernel32.dll</em>. When you call this function, it directly calls <span class="literal">NtWriteVirtualMemory()</span> from <em>ntdll.dll</em>. GameGuard hooks <span class="literal">ntdll.NtWriteVirtualMemory()</span> to prevent you from writing memory. But if <span class="literal">NtWriteVirtualMemory()</span> is exported from, say, <em>ntdll_copy.dll</em>, GameGuard won’t hook that function.</p>&#13;
<p class="indent">That means you can copy <em>ntdll.dll</em> and dynamically import all of the functions you need, as follows:</p>&#13;
<p class="programs">// copy and load ntdll<br/>copyFile("ntdll.dll", "ntdll_copy.dll");<br/>auto module = LoadLibrary("ntdll_copy.dll");<br/><br/>// dynamically import NtWriteVirtualMemory<br/>typedef NTSTATUS (WINAPI* _NtWriteVirtualMemory)<br/>    (HANDLE, PVOID, PVOID, ULONG, PULONG);<br/>auto myWriteVirtualMemory = (_NtWriteVirtualMemory)<br/>    GetProcAddress(module, "NtWriteVirtualMemory");<br/><br/>// call NtWriteVirtualMemory<br/>myWriteVirtualMemory(process, address, data, length, &amp;writtenlength);</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_262"/>After copying <em>ntdll.dll</em>, this code imports the <span class="literal">NtWriteVirtualMemory()</span> from the copy with the name <span class="literal">myWriteVirtualMemory()</span>. From there, the bot can use this function in place of the <span class="literal">NtWriteVirtualMemory()</span> function. They’re effectively the same code in the same library, just loaded under different names.</p>&#13;
<p class="indent">Copying a function that anti-cheat software hooks works only if you call that function at its lowest-level entry point, though. If this code copied <em>kernel32.dll</em> and dynamically imported the <span class="literal">WriteProcessMemory()</span> function, an anti-cheat rootkit would still stop the bot, because <em>kernel32_copy.dll</em> would still rely on <span class="literal">ntdll.NtWriteVirtualMemory()</span> when calling the <span class="literal">WriteProcessMemory()</span> function.</p>&#13;
<h3 class="h3" id="ch00lev1sec277"><strong>Defeating Heuristics</strong></h3>&#13;
<p class="noindent">In addition to all of the advanced client-side detection mechanisms we’ve just discussed, game companies will employ server-side heuristics that can detect bots simply by monitoring a player’s behavior. These systems learn to distinguish between human and autonomous player behavior through machine-learning algorithms. Their decision-making process is often internal and incomprehensible to humans, so it’s difficult to pinpoint exactly what features of gameplay lead to detection.</p>&#13;
<p class="indent">You don’t need to know how such algorithms work to trick them; your bot just needs to act human. Here are some common behaviors that are distinguishably different between humans and bots:</p>&#13;
<p class="term"><strong>Intervals between actions</strong></p>&#13;
<p class="termp">Many bots perform actions unreasonably fast or at consistent intervals. Bots will seem more human-like if they have a reasonable cooldown period between actions. They should also have some form of randomization to prevent them from repeating an action at a constant rate.</p>&#13;
<p class="term"><strong>Path repetition</strong></p>&#13;
<p class="termp">Bots that farm enemies automatically visit a preprogrammed list of locations to kill creatures. These waypoint lists are often extremely accurate, indicating each location as an exact pixel. Humans, conversely, move in less predictable ways and visit more unique locations along the way to a familiar area. To replicate this behavior, a bot might walk to a <span epub:type="pagebreak" id="page_263"/>random location within a certain range of a target location, rather than to the target location itself. Also, if the bot randomizes the order in which it visits target locations, the variety of paths it takes will increase further.</p>&#13;
<p class="term"><strong>Unrealistic play</strong></p>&#13;
<p class="termp">Some botters run their bots in the same location for hundreds of consecutive hours, but humans can’t play a game that long. Encourage your users to refrain from botting for more than eight hours at a time and warn them that doing the same thing for seven straight days will definitely trigger alarms in a heuristic system.</p>&#13;
<p class="term"><strong>Perfect accuracy</strong></p>&#13;
<p class="termp">Bots can hit a thousand head shots in a row without firing a single extra bullet, and they can hit every skill shot with consistent precision. But it’s virtually impossible for a human to do the same, so a smart bot should be intentionally inaccurate at times.</p>&#13;
<p class="indentt">These are just a few examples, but in general, you can sneak past heuristic checks if you just use common sense. Don’t try to have a bot do something a human can’t, and don’t have the bot do any single thing for too long.</p>&#13;
<h3 class="h3" id="ch00lev1sec278"><strong>Closing Thoughts</strong></h3>&#13;
<p class="noindent">Game hackers and game developers are engaged in a constant battle of wits. Hackers will keep finding ways to subvert detection, and developers will keep finding better ways to detect them. If you’re determined, however, the knowledge in this chapter should help you defeat any anti-cheat software you encounter.<span epub:type="pagebreak" id="page_264"/></p>&#13;
</body></html>