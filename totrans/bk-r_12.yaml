- en: '**10**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CONDITIONS AND LOOPS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To write more sophisticated programs with R, you’ll need to control the flow
    and order of execution in your code. One fundamental way to do this is to make
    the execution of certain sections of code dependent on a *condition*. Another
    basic control mechanism is the *loop*, which repeats a block of code a certain
    number of times. In this chapter, we’ll explore these core programming techniques
    using `if`-`else` statements, `for` and `while` loops, and other control structures.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.1 if Statements**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `if` statement is the key to controlling exactly which operations are carried
    out in a given chunk of code. An `if` statement runs a block of code only if a
    certain condition is true. These constructs allow a program to respond differently
    depending on whether a condition is `TRUE` or `FALSE`.
  prefs: []
  type: TYPE_NORMAL
- en: '***10.1.1 Stand-Alone Statement***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s start with the stand-alone `if` statement, which looks something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `condition` is placed in parentheses after the `if` keyword. This condition
    must be an expression that yields a single logical value (`TRUE` or `FALSE`).
    If it’s `TRUE`, the code in the braces, `{}`, will be executed. If the condition
    isn’t satisfied, the code in the braces is skipped, and R does nothing (or continues
    on to execute any code after the closing brace).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple example. In the console, store the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the R editor, write the following code chunk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When this chunk is executed, what will the value of `a` be? It depends on the
    condition defining the `if` statement, as well as what’s actually specified in
    the braced area. In this case, when the condition `a<=mynumber` is evaluated,
    the result is `TRUE` since 3 is indeed less than or equal to 4\. That means the
    code inside the braces is executed, which sets `a` to `a^2`, or 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now highlight the entire chunk of code in the editor and send it to the console
    for evaluation. Remember, you can do this in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: • Copy and paste the selected text from the editor directly into the console.
  prefs: []
  type: TYPE_NORMAL
- en: • From the menu, select **Edit** → **Run line or selection** in Windows or select
    **Edit** → **Execute** in OS X.
  prefs: []
  type: TYPE_NORMAL
- en: • Use the keystroke shortcut such as CTRL-R in Windows or -RETURN on a Mac.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you execute the code in the console, you’ll see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, look at the object `a`, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Next, suppose you execute the same `if` statement again right away. Will `a`
    be squared once more, giving 81? Nope! Since `a` is now 9 and `mynumber` is still
    4, the condition `a<=mynumber` will be `FALSE`, and the code in the braces will
    not be executed; `a` will remain at 9.
  prefs: []
  type: TYPE_NORMAL
- en: Note that after you send the `if` statement to the console, each line after
    the first is prefaced by a `+`. These `+` signs do not represent any kind of arithmetic
    addition; rather, they indicate that R is expecting more input before it begins
    execution. For example, when a left brace is opened, R will not begin any kind
    of execution until that section is closed with a right brace. To avoid redundancy,
    in future examples I won’t show this repetition of code sent from the editor to
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can change the* `+` *symbol by assigning a different character string
    to the* `continue` *component of R’s* `options` *command, in the way you reset
    the prompt in [Section 1.2.1](ch01.xhtml#ch01lev2sec06).*'
  prefs: []
  type: TYPE_NORMAL
- en: The `if` statement offers a huge amount of flexibility—you can place any kind
    of code in the braced area, including more `if` statements (see the upcoming discussion
    of nesting in [Section 10.1.4](ch10.xhtml#ch10lev2sec90)), enabling your program
    to make a sequence of decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate a more complicated `if` statement, consider the following two
    new objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Use these two objects in the code chunk given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Send this to the console, and it produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, an object `mylist` has been created that you can examine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the condition consists of two parts separated by an OR statement
    using `||`, which produces a single logical result. Let’s walk through it.
  prefs: []
  type: TYPE_NORMAL
- en: • The first part of the condition looks at `myvec`, takes `1` away from each
    element, and checks whether any of the results are greater than 9\. If you run
    this part on its own, it yields `FALSE`.
  prefs: []
  type: TYPE_NORMAL
- en: R> myvec-1
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 1.73 4.40 1.15 4.29 0.36 1.16 0.41 5.97 6.99 8.52'
  prefs: []
  type: TYPE_NORMAL
- en: R> (myvec-1)>9
  prefs: []
  type: TYPE_NORMAL
- en: '[1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE'
  prefs: []
  type: TYPE_NORMAL
- en: R> any((myvec-1)>9)
  prefs: []
  type: TYPE_NORMAL
- en: '[1] FALSE'
  prefs: []
  type: TYPE_NORMAL
- en: • The second part of the condition uses positional matching in a call to `matrix`
    to construct a two-row, five-column, column-filled matrix using entries of the
    original `myvec`. Then, the number in the second row of the first column of that
    result is checked to see whether it’s less than or equal to 6, which it is.
  prefs: []
  type: TYPE_NORMAL
- en: R> matrix(myvec,2,5)
  prefs: []
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3] [,4] [,5]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 2.73 2.15 1.36 1.41 7.99'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 5.40 5.29 2.16 6.97 9.52'
  prefs: []
  type: TYPE_NORMAL
- en: R> matrix(myvec,2,5)[2,1]
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 5.4'
  prefs: []
  type: TYPE_NORMAL
- en: R> matrix(myvec,2,5)[2,1]<=6
  prefs: []
  type: TYPE_NORMAL
- en: '[1] TRUE'
  prefs: []
  type: TYPE_NORMAL
- en: This means the overall condition being checked by the `if` statement will be
    `FALSE||TRUE`, which evaluates as `TRUE`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As a result, the code inside the braces is accessed and executed. First, it
    prints the `"Condition satisfied"` string and copies `myvec` to `new.myvec`. Using
    `seq`, it then accesses the odd-numbered indexes of `new.myvec` and overwrites
    them with `NA`. Next, it creates `mylist`. In this list, `new.myvec` is stored
    in a member named `aa`, and then it takes the original `mymat`, increases all
    its elements by 0.5, and stores the result in `bb`. Lastly, it prints the length
    of the resulting list.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `if` statements don’t have to match the exact style I’m using here.
    Some programmers, for example, prefer to open the left brace on a new line after
    the condition, or some may prefer a different amount of indentation.
  prefs: []
  type: TYPE_NORMAL
- en: '***10.1.2 else Statements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `if` statement executes a chunk of code if and only if a defined condition
    is `TRUE`. If you want something different to happen when the condition is `FALSE`,
    you can add an `else` declaration. Here’s an example in pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You set the condition, then in the first set of braces you place the code to
    run if the condition is `TRUE`. After this, you declare `else` followed by a new
    set of braces where you can place code to run if the condition is `FALSE`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s return to the first example in [Section 10.1.1](ch10.xhtml#ch10lev2sec87),
    once more storing these values at the console prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the editor, create a new version of the earlier `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you again square `a` if the condition `a<=mynumber` is `TRUE`, but if
    `FALSE`, `a` is overwritten by the result of itself minus 3.5\. You also print
    text to the console stating whether the condition was met. After resetting `a`
    and `mynumber` to their original values, the first run of the `if` loop computes
    `a` as 9, just as earlier, outputting the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, immediately highlight and execute the entire statement again. This time
    around, `a<=mynumber` will evaluate to `FALSE` and execute the code after `else`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '***10.1.3 Using ifelse for Element-wise Checks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An `if` statement can check the condition of only a single logical value. If
    you pass in, for example, a vector of logicals for the condition, the `if` statement
    will only check (and operate based on) the very first element. It will issue a
    warning saying as much, as the following dummy example shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There is, however, a shortcut function available, `ifelse`, which can perform
    this kind of vector-oriented check in relatively simple cases. To demonstrate
    how it works, consider the objects `x` and `y` defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, suppose you want to produce the result of `x/y` but with any instance of
    `Inf` (that is, any instance where `x` is divided by zero) replaced with `NA`.
    In other words, for each element in `y`, you want to check whether `y` is zero.
    If so, you want the code to output `NA`, and if not, it should output the result
    of `x/y`.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve just seen, a simple `if` statement won’t work here. Since it accepts
    only a single logical value, it can’t run through the entire logical vector produced
    by `y==0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Instead, you can use the element-wise `ifelse` function for this kind of scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Using exact matching, this command creates the desired `result` vector in one
    line. Three arguments must be specified: `test` takes a logical-valued data structure,
    `yes` provides the element to return if the condition is satisfied, and `no` gives
    the element to return if the condition is `FALSE`. As noted in the function documentation
    (which you can access with `?ifelse`), the returned structure will be of “the
    same length and attributes as `test`.”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.1**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following two vectors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Without executing them, determine which of the following `if` statements would
    result in the string being printed to the console. Then confirm your answers in
    R.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: Using `vec1` and `vec2` from (a), write and execute a line of code that multiplies
    the corresponding elements of the two vectors together *if* their sum is greater
    than 3\. Otherwise, the code should simply sum the two elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, write R code that takes a square character matrix and checks
    *if* any of the character strings on the diagonal (top left to bottom right) begin
    with the letter *g*, lowercase or uppercase. If satisfied, these specific entries
    should be overwritten with the string `"HERE"`. Otherwise, the entire matrix should
    be replaced with an identity matrix of the same dimensions. Then, try your code
    on the following matrices, checking the result each time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
- en: 'Hint: This requires some thought—you will find the functions `diag` from [Section
    3.2.1](ch03.xhtml#ch03lev2sec27) and `substr` from [Section 4.2.4](ch04.xhtml#ch04lev2sec45)
    useful.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '***10.1.4 Nesting and Stacking Statements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An `if` statement can itself be placed within the outcome of another `if` statement.
    By *nesting* or *stacking* several statements, you can weave intricate paths of
    decision-making by checking a number of conditions at various stages during execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the editor, modify the `mynumber` example once more as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here you see the same initial decision being made as earlier. The value `a`
    is squared if it’s less than or equal to `mynumber`; if not, it has 3.5 subtracted
    from it. But now there’s another `if` statement within each braced area. If the
    first condition is satisfied and `a` is squared, you then check whether `mynumber`
    is greater than 3\. If `TRUE`, `b` is assigned `seq(1,a,length=mynumber)`. If
    `FALSE`, `b` is assigned `a*mynumber`.
  prefs: []
  type: TYPE_NORMAL
- en: If the first condition fails and you subtract 3.5 from `a`, then you check a
    second condition to see whether `mynumber` is greater than or equal to 4\. If
    it is, then `b` becomes `a^(3-mynumber)`. If it’s not, `b` becomes `rep(a+mynumber,times=3)`.
    Note that I’ve indented the code within each subsequent braced area to make it
    easier to see which lines are relevant to each possible decision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, reset `a <- 3` and `mynumber <- 4` either directly in the console or from
    the editor. When you run the `mynumber` example code, you’ll get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The result indicates exactly which code was invoked—the first condition and
    second condition were both `TRUE`. Trying another run of the same code, after
    first setting
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'you see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This time the first condition fails, but the second condition checked inside
    the `else` statement is `TRUE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you could accomplish the same thing by sequentially *stacking*
    `if` statements and using a combination of logical expressions in each condition.
    In the following example, you check for the same four situations, but this time
    you stack `if` statements by placing a new `if` declaration immediately following
    an `else` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Just as before, only one of the four braced areas will end up being executed.
    Comparing this to the nested version, the first two braced areas correspond to
    what was originally the first condition (`a<=mynumber`) being satisfied, but this
    time you use `&&` to check two expressions at once. If neither of those two situations
    is met, this means the first condition is false, so in the third statement, you
    just have to check whether `mynumber>=4`. For the final `else` statement, you
    don’t need to check any conditions because that statement will be executed only
    if all the previous conditions were not met.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you again reset `a` and `mynumber` to 3 and 4, respectively, and execute
    the stacked statements shown earlier, you get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the same values for `a` and `b` as earlier. If you execute the
    code again using the second set of initial values (`a` as 6 and `mynumber` as
    4), you get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This again matches the results of using the nested version of the code.
  prefs: []
  type: TYPE_NORMAL
- en: '***10.1.5 The switch Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s say you need to choose which code to run based on the value of a single
    object (a common scenario). One option is to use a series of `if` statements,
    where you compare the object with various possible values to produce a logical
    value for each condition. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The goal of this code is simply to assign a numeric value to an object `foo`,
    where the exact number depends on the value of `mystring`. The `mystring` object
    can take one of the five possibilities shown, or if `mystring` doesn’t match any
    of these, `foo` is assigned `NA`.
  prefs: []
  type: TYPE_NORMAL
- en: This code works just fine as it is. For example, setting
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'and executing the chunk, you’ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Setting the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'and executing the chunk again, you’ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This setup using `if`-`else` statements is quite cumbersome for such a basic
    operation, though. R can handle this type of multiple-choice decision in a far
    more compact form via the `switch` function. For example, you could rewrite the
    stacked `if` statements as a much shorter `switch` statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The first argument, `EXPR`, is the object of interest and can be either a numeric
    or a character string. The remaining arguments provide the values or operations
    to carry out based on the value of `EXPR`. If `EXPR` is a string, these argument
    tags must *exactly* match the possible results of `EXPR`. Here, the `switch` statement
    evaluates to 12 if `mystring` is `"Homer"`, 34 if `mystring` is `"Marge"`, and
    so on. The final, untagged value, `NA`, indicates the result if `mystring` doesn’t
    match any of the preceding items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The integer version of `switch` works in a slightly different way. Instead
    of using tags, the outcome is determined purely with positional matching. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you provide an integer `mynum` as the first argument, and it’s positionally
    matched to `EXPR`. The example code then shows five untagged arguments: `12` to
    `NA`. The `switch` function simply returns the value in the specific position
    requested by `mynum`. Since `mynum` is 3, the statement assigns 56 to `foo`. Had
    `mynum` been 1, 2, 4, or 5, `foo` would’ve been assigned 12, 34, 78, or `NA`,
    respectively. Any other value of `mynum` (less than 1 or greater than 5) will
    return `NULL`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In these types of situations, the `switch` function behaves the same way as
    a set of stacked `if` statements, so it can serve as a convenient shortcut. However,
    if you need to examine multiple conditions at once or you need to execute a more
    complicated set of operations based on this decision, you’ll need to use the explicit
    `if` and `else` control structures.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.2**'
  prefs: []
  type: TYPE_NORMAL
- en: Write an explicit stacked set of `if` statements that does the same thing as
    the integer version of the `switch` function illustrated earlier. Test it with
    `mynum <- 3` and `mynum <- 0`, as in the text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Suppose you are tasked with computing the precise dosage amounts of a certain
    drug in a collection of hypothetical scientific experiments. These amounts depend
    upon some predetermined set of “dosage thresholds” (`lowdose`, `meddose`, and
    `highdose`), as well as a predetermined dose level factor vector named `doselevel`.
    Look at the following items (i–iv) to see the intended form of these objects.
    Then write a set of nested `if` statements that produce a new numeric vector called
    `dosage`, according to the following rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '– First, *if* there are any instances of `"High"` in `doselevel`, perform the
    following operations:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* Check *if* `lowdose` is greater than or equal to 10\. If so, overwrite `lowdose`
    with 10; *otherwise*, overwrite `lowdose` by itself divided by 2.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* Check *if* `meddose` is greater than or equal to 26\. If so, overwrite `meddose`
    by 26.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* Check *if* `highdose` is less than 60\. If so, overwrite `highdose` with
    60; *otherwise*, overwrite `highdose` by itself multiplied by 1.5.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* Create a vector named `dosage` with the value of `lowdose` repeated (`rep`)
    to match the `length` of `doselevel`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* Overwrite the elements in `dosage` corresponding to the index positions of
    instances of `"Med"` in `doselevel` by `meddose`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* Overwrite the elements in `dosage` corresponding to the index positions of
    instances of `"High"` in `doselevel` by `highdose`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '– *Otherwise* (in other words, if there are no instances of `"High"` in `doselevel`),
    perform the following operations:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* Create a new version of `doselevel`, a factor vector with levels `"Low"`
    and `"Med"` only, and label these with `"Small"` and `"Large"`, respectively (refer
    to [Section 4.3](ch04.xhtml#ch04lev1sec18) for details or see `?factor`).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* Check to see *if* `lowdose` is less than 15 AND `meddose` is less than 35\.
    If so, overwrite `lowdose` by itself multiplied by 2 and overwrite `meddose` by
    itself plus `highdose`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* Create a vector named `dosage`, which is the value of `lowdose` repeated
    (`rep`) to match the `length` of `doselevel`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* Overwrite the elements in `dosage` corresponding to the index positions of
    instances of `"Large"` in `doselevel` by `meddose`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, confirm the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Given
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'the result of `dosage` after running the nested `if` statements is as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Using the same `lowdose`, `meddose`, and `highdose` thresholds as in (i), given
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'the result of `dosage` after running the nested `if` statements is as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, `doselevel` has been overwritten as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Given
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'the result of `dosage` after running the nested `if` statements is as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, `doselevel` has been overwritten as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the same `lowdose`, `meddose`, and `highdose` thresholds as (iii), as
    well as the same `doselevel` as (i), the result of `dosage` after running the
    nested `if` statements is as follows:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Assume the object `mynum` will only ever be a single integer between 0 and 9\.
    Use `ifelse` and `switch` to produce a command that takes in `mynum` and returns
    a matching character string for all possible values 0, 1, ..., 9\. Supplied with
    `3`, for example, it should return `"three"`; supplied with `0`, it should return
    `"zero"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**10.2 Coding Loops**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another core programming mechanism is the *loop*, which repeats a specified
    section of code, often while incrementing an index or counter. There are two styles
    of looping: the `for` loop repeats code as it works its way through a vector,
    element by element; the `while` loop simply repeats code until a specific condition
    evaluates to `FALSE`. Looplike behavior can also be achieved with R’s suite of
    `apply` functions, which are discussed in [Section 10.2.3](ch10.xhtml#ch10lev2sec94).'
  prefs: []
  type: TYPE_NORMAL
- en: '***10.2.1 for Loops***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The R `for` loop always takes the following general form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `loopindex` is a placeholder that represents an element in the `loopvector`—it
    starts off as the first element in the vector and moves to the next element with
    each loop repetition. When the `for` loop begins, it runs the code in the braced
    area, replacing any occurrence of the `loopindex` with the first element of the
    `loopvector`. When the loop reaches the closing brace, the `loopindex` is incremented,
    taking on the second element of the `loopvector`, and the braced area is repeated.
    This continues until the loop reaches the final element of the `loopvector`, at
    which point the braced code is executed for the final time, and the loop exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple example written in the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This loop prints the current value of the `loopindex` (which I’ve named `myitem`
    here) as it increments from 5 to 7\. Here’s the output after sending to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use loops to manipulate objects that exist outside the loop. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, I’ve initially defined an object, `counter`, and set it to zero in the
    workspace. Then, inside the loop, `counter` is overwritten by itself plus 1\.
    Each time the loop repeats, `counter` increases, and the current value is printed
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**Looping via Index or Value**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Note the difference between using the `loopindex` to directly represent elements
    in the `loopvector` and using it to represent *indexes* of a vector. The following
    two loops use these two different approaches to `print` double each number in
    `myvec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The first loop uses the `loopindex` i to directly represent the elements in
    `myvec`, printing the value of each element times 2\. In the second loop, on the
    other hand, you use `i` to represent integers in the sequence `1:length(myvec)`.
    These integers form all the possible index positions of `myvec`, and you use these
    indexes to extract `myvec`’s elements (once again multiplying each element by
    2 and printing the result). Though it takes a slightly longer form, using vector
    index positions provides more flexibility in terms of how you can use the `loopindex`.
    This will become clearer when your needs demand more complicated `for` loops,
    such as in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to write some code that will inspect any list object and gather
    information about any matrix objects stored as members in the list. Consider the
    following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here you’ve created `foo`, which contains three matrices of varying dimensions
    and data types. You’ll write a `for` loop that goes through each member of a list
    like this one and checks whether the member is a matrix. If it is, the loop will
    retrieve the number of rows and columns and the data type of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you write the `for` loop, you should create some vectors that will store
    information about the list members: `name` for the list member names, `is.mat`
    to indicate whether each member is a matrix (with `"Yes"` or `"No"`), `nc` and
    `nr` to store the number of rows and columns for each matrix, and `data.type`
    to store the data type of each matrix.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you store the names of the members of `foo` as `name`. You also set up
    `is.mat`, `nr`, `nc`, and `data.type`, which are all assigned vectors of length
    `length(foo)` filled with `NA`s. These values will be updated as appropriate by
    your `for` loop, which you’re now ready to write. Enter the following code in
    the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, set up the `loopindex` i so that it will increment through the index
    positions of `foo` (the sequence `1:length(foo)`). In the braced code, the first
    command is to write the member of `foo` at position `i` to an object `member`.
    Next, you can check whether that member is a matrix using `is.matrix` (refer to
    [Section 6.2.3](ch06.xhtml#ch06lev2sec61)). If `TRUE`, you do the following: the
    `i`th position of `is.mat` vector is set as `"Yes"`; the `i`th element of `nr`
    and `nc` is set as the number of rows and number of columns of `member`, respectively;
    and the `i`th element of `data.type` is set as the result of `class(as.vector(member))`.
    This final command first coerces the matrix into a vector with `as.vector` and
    then uses the `class` function (covered in [Section 6.2.2](ch06.xhtml#ch06lev2sec60))
    to find the data type of the elements.'
  prefs: []
  type: TYPE_NORMAL
- en: If `member` isn’t a matrix and the `if` condition fails, the corresponding entry
    in `is.mat` is set to `"No"`, and the entries in the other vectors aren’t changed
    (so they will remain `NA`).
  prefs: []
  type: TYPE_NORMAL
- en: 'After the loop is run, a data frame `bar` is created from the vectors (note
    the use of `stringsAsFactors=FALSE` in order to prevent the character string vectors
    in `bar` being automatically converted to factors; see [Section 5.2.1](ch05.xhtml#ch05lev2sec52)).
    After executing the code, `bar` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this matches the nature of the matrices present in the list
    `foo`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Nesting for Loops**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can also nest `for` loops, just like `if` statements. When a `for` loop
    is nested in another `for` loop, the inner loop is executed in full before the
    outer loop `loopindex` is incremented, at which point the inner loop is executed
    all over again. Create the following objects in your R console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The following nested loop fills `foo` with the result of multiplying each integer
    in `loopvec1` by each integer in `loopvec2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Note that nested loops require a unique `loopindex` for each use of `for`. In
    this case, the `loopindex` is `i` for the outer loop and `j` for the inner loop.
    When the code is executed, `i` is first assigned `1`, the inner loop begins, and
    then `j` is also assigned `1`. The only command in the inner loop is to take the
    product of the `i`th element of `loopvec1` and the `j`th element of `loopvec2`
    and assign it to row `i`, column `j` of `foo`. The inner loop repeats until `j`
    reaches `length(loopvec2)` and fills the first row of `foo`; then `i` increments,
    and the inner loop is started up again. The entire procedure is complete after
    `i` reaches `length(loopvec1)` and the matrix is filled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inner `loopvector`s can even be defined to match the current value of the `loopindex`
    of the outer loop. Using `loopvec1` and `loopvec2` from earlier, here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `i`th row, `j`th column element of `foo` is filled with the sum of
    `loopvec1[i]` and `loopvec2[j]`. However, the inner loop values for `j` are now
    decided based on the value of `i`. For example, when `i` is `1`, the inner `loopvector`
    is `1:1`, so the inner loop executes only once before returning to the outer loop.
    With `i` as `2`, the inner `loopvector` is then `1:2`, and so on. This makes it
    so each row of `foo` is only partially filled. Extra care must be taken when programming
    loops this way. Here, for example, the values for `j` depend on the length of
    `loopvec1`, so an error will occur if `length(loopvec1)` is greater than `length(loopvec2)`.
  prefs: []
  type: TYPE_NORMAL
- en: Any number of `for` loops can be nested, but the computational expense can become
    a problem if nested loops are used unwisely. Loops in general add some computational
    cost, so to produce more efficient code in R, you should always ask “Can I do
    this in a vector-oriented fashion?” Only when the individual operations are not
    possible or straightforward to achieve en masse should you explore an iterative,
    looped approach. You can find some relevant and valuable comments on R loops and
    associated best-practice coding in the “R Help Desk” article by Ligges and Fox
    ([2008](ref.xhtml#ref41)).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.3**'
  prefs: []
  type: TYPE_NORMAL
- en: In the interests of efficient coding, rewrite the nested loop example from this
    section, where the matrix `foo` was filled with the multiples of the elements
    of `loopvec1` and `loopvec2`, using only a single `for` loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In [Section 10.1.5](ch10.xhtml#ch10lev2sec91), you used the command
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'to return a number based on the supplied value of a single character string.
    This line won’t work if `mystring` is a character vector. Write some code that
    will take a character vector and return a vector of the appropriate numeric values.
    Test it on the following vector:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Suppose you have a list named `mylist` that can contain other lists as members,
    but assume those “member lists” cannot themselves contain lists. Write nested
    loops that can search any possible `mylist` defined in this way and count how
    many matrices are present. Hint: Simply set up a counter before commencing the
    loops that is incremented each time a matrix is found, regardless of whether it
    is a straightforward member of `mylist` or it is a member of a member list of
    `mylist`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then confirm the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'That the answer is 4 if you have the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'That the answer is 0 if you have the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'That the answer is 2 if you have the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '***10.2.2 while Loops***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use `for` loops, you must know, or be able to easily calculate, the number
    of times the loop should repeat. In situations where you don’t know how many times
    the desired operations need to be run, you can turn to the `while` loop. A `while`
    loop runs and repeats while a specified condition returns `TRUE`, and takes the
    following general form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: A `while` loop uses a single logical-valued `loopcondition` to control how many
    times it repeats. Upon execution, the `loopcondition` is evaluated. If the condition
    is found to be `TRUE`, the braced area code is executed line by line as usual
    until complete, at which point the `loopcondition` is checked again. The loop
    terminates only when the condition evaluates to `FALSE`, and it does so immediately—the
    braced code is *not* run one last time.
  prefs: []
  type: TYPE_NORMAL
- en: This means the operations carried out in the braced area must somehow cause
    the loop to exit, either by affecting the `loopcondition` somehow or by declaring
    `break`, which you’ll see a little later. If not, the loop will keep repeating
    forever, creating an *infinite loop*, which will freeze the console (and, depending
    on the operations specified inside the braced area, R can crash because of memory
    constraints). If that occurs, you can terminate the loop in the R user interface
    by clicking the Stop button in the top menu or by pressing ESC.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a simple example of a `while` loop, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you set a new object `myval` to `5`. Then you start a `while` loop with
    the condition `myval<10`. Since this is `TRUE` to begin with, you enter the braced
    area. Inside the loop you increment `myval` by 1, print its current value, and
    print the logical value of the condition `myval<5`. The loop continues until the
    condition `myval<10` is `FALSE` at the next evaluation. Execute the code chunk,
    and you see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the loop repeats until `myval` is set to `10`, at which point `myval<10`
    returns `FALSE`, causing the loop to exit because the initial condition is no
    longer `TRUE`.
  prefs: []
  type: TYPE_NORMAL
- en: In more complicated settings, it’s often useful to set the `loopcondition` to
    be a separate object so that you can modify it as necessary within the braced
    area. For the next example, you’ll use a `while` loop to iterate through an integer
    vector and create an identity matrix (see [Section 3.3.2](ch03.xhtml#ch03lev2sec30))
    with the dimension matching the current integer. This loop should stop when it
    reaches a number in the vector that’s greater than 5 or when it reaches the end
    of the integer vector.
  prefs: []
  type: TYPE_NORMAL
- en: In the editor, define some initial objects, followed by the loop itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The first object, `mylist`, will store all the matrices that the loop creates.
    You’ll use the vector `mynumbers` to provide the matrix sizes, and you’ll use
    `counter` and `mycondition` to control the loop.
  prefs: []
  type: TYPE_NORMAL
- en: The `loopcondition`, `mycondition`, is initially set to `TRUE` since the first
    element of `mynumbers` is less than or equal to 5\. Inside the loop beginning
    at `while`, the first line uses double square brackets and the value of `counter`
    to dynamically create a new entry at that position in `mylist` (you did this earlier
    with named lists in [Section 5.1.3](ch05.xhtml#ch05lev2sec51)). This entry is
    assigned an identity matrix whose size matches the corresponding element of `mynumbers`.
    Next, the `counter` is incremented, and now you have to update `mycondition`.
    Here you want to check whether `mynumbers[counter]<=5`, but you also need to check
    whether you’ve reached the end of the integer vector (otherwise, you can end up
    with an error by trying to retrieve an index position outside the range of `mynumbers`).
    So, you can use an `if` statement to first check the condition `counter<=length(mynumbers)`.
    If `TRUE`, then set `mycondition` to the outcome of `mynumbers[counter]<=5`. If
    not, this means you’ve reached the end of `mynumbers`, so you make sure the loop
    exits by setting `mycondition <- FALSE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the loop with those predefined objects, and it will produce the `mylist`
    object shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: As expected, you have a list with four members—identity matrices of size 4 ×
    4, 5 × 5, 1 × 1, and 2 × 2—matching the first four elements of `mynumbers`. The
    loop stopped executing when it reached the fifth element of `mynumbers`(`6`) since
    that’s greater than 5.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.4**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the most recent example of storing identity matrices in a list, determine
    what the resulting `mylist` would look like for each of the following possible
    `mynumbers` vectors, without executing anything:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mynumbers <- c(2,2,2,2,5,2)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mynumbers <- 2:20`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mynumbers <- c(10,1,10,1,2)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, confirm your answers in R (note you’ll also have to reset the initial
    values of `mylist`, `counter`, and `mycondition` each time, just as in the text).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For this problem, I’ll introduce the *factorial* operator. The factorial of
    a non-negative integer *x*, expressed as *x*!, refers to *x* multiplied by the
    product of all integers less than *x*, down to 1\. Formally, it is written like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “*x* factorial” = *x*! = *x* × (*x* − 1) × (*x* − 2) × ... × 1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that there is a special case of *zero factorial*, which is always 1\.
    That is:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 0! = 1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, to work out 3 factorial, you compute the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 3 × 2 × 1 = 6
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To work out 7 factorial, you compute the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 7 × 6 × 5 × 4 × 3 × 2 × 1 = 5040
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write a `while` loop that computes and stores as a new object the factorial
    of any non-negative integer `mynum` by decrementing `mynum` by `1` at each repetition
    of the braced code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using your loop, confirm the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That the result of using `mynum <- 5` is `120`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: That using `mynum <- 12` yields `479001600`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: That having `mynum <- 0` correctly returns `1`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider the following code, where the operations in the braced area of the
    `while` loop have been omitted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your task is to complete the code in the braced area so it inspects `mystring`
    character by character until it reaches the second instance of the letter *e*
    or the end of the string, whichever comes first. The `result` object should be
    the entire character string if there is no second *e* or the character string
    made up of all the characters up to, but not including, the second *e* if there
    is one. For example, `mystring <- "R fever"` should provide `result` as `"R fev"`.
    This must be achieved by following these operations in the braces:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use `substr` ([Section 4.2.4](ch04.xhtml#ch04lev2sec45)) to extract the single
    character of `mystring` at position `index`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a check for equality to determine whether this single-character string is
    either `"e"` OR `"E"`. If so, increase `ecount` by `1`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, perform a separate check to see whether `ecount` is equal to `2`. If so,
    use `substr` to set `result` equal to the characters between `1` and `index-1`
    inclusive.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment `index` by `1`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test your code—ensure the previous `result` for `mystring <- "R fever"`. Furthermore,
    confirm the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Using `mystring <- "beautiful"` provides `result` as `"beautiful"`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Using `mystring <- "ECCENTRIC"` provides `result` as `"ECC"`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Using `mystring <- "ElAbOrAte"` provides `result` as `"ElAbOrAt"`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Using `mystring <- "eeeeek!"` provides `result` as `"e"`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '***10.2.3 Implicit Looping with apply***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some situations, especially for relatively routine `for` loops (such as executing
    some function on each member of a list), you can avoid some of the details associated
    with explicit looping by using the `apply` function. The `apply` function is the
    most basic form of implicit looping—it takes a function and applies it to each
    *margin* of an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a simple illustrative example, let’s say you have the following matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Say you want to find the sum of each row. If you call the following, you just
    get the grand total of all elements, which is not what you want.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, you could use a `for` loop like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This cycles through each row and stores the sum in `row.totals`. But you can
    use `apply` to get the same result in a more compact form. To call `apply`, you
    have to specify at least three arguments. The first argument, `X`, is the object
    you want to cycle through. The next argument, `MARGIN`, takes an integer that
    flags which margin of `X` to operate on (rows, columns, etc.). Finally, `FUN`
    provides the function you want to perform on each margin. With the following call,
    you get the same result as the earlier `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The `MARGIN` index follows the positional order of the dimension for matrices
    and arrays, as discussed in [Chapter 3](ch03.xhtml#ch03)—`1` always refers to
    rows, `2` to columns, `3` to layers, `4` to blocks, and so on. To instruct R to
    sum each column of `foo` instead, simply change the `MARGIN` argument to `2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The operations supplied to `FUN` should be appropriate for the `MARGIN` selected.
    So, if you select rows or columns with `MARGIN=1` or `MARGIN=2`, make sure the
    `FUN` function is appropriate for vectors. Or if you have a three-dimensional
    array and use `apply` with `MARGIN=3`, be sure to set `FUN` to a function appropriate
    for matrices. Here’s an example for you to enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, make the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This extracts the diagonal elements of each of the matrix layers of `bar`. Each
    call to `diag` on a matrix returns a vector, and these vectors are returned as
    columns of a new matrix. The `FUN` argument can also be any appropriate user-defined
    function, and you’ll look at some examples of using `apply` with your own functions
    in [Chapter 11](ch11.xhtml#ch11).
  prefs: []
  type: TYPE_NORMAL
- en: '**Other apply Functions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are different flavors of the basic `apply` function. The `tapply` function,
    for example, performs operations on subsets of the object of interest, where those
    subsets are defined in terms of one or more factor vectors. As an example, let’s
    return to the code from [Section 8.2.3](ch08.xhtml#ch08lev2sec75), which reads
    in a web-based data file on diamond pricing, sets appropriate variable names of
    the data frame, and displays the first five records.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'To add up the total value of the diamonds present for the full data set but
    separated according to `Color`, you can use `tapply` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This sums the relevant elements of the target vector `diamonds$Price`. The corresponding
    factor vector `diamonds$Color` is passed to `INDEX`, and the function of interest
    is specified with `FUN=sum` exactly as earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another particularly useful alternative is `lapply`, which can operate member
    by member on a list. In [Section 10.2.1](ch10.xhtml#ch10lev2sec92), recall you
    wrote a `for` loop to inspect matrices in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Using `lapply`, you can check for matrices in the list with a single short line
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Note that no margin or index information is required for `lapply`; R knows to
    apply `FUN` to each member of the specified list. The returned value is itself
    a list. Another variant, `sapply`, returns the same results as `lapply` but in
    an array form.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Here, the result is provided as a vector. In this example, `baz` has a `names`
    attribute that is copied to the corresponding entries of the returned object.
  prefs: []
  type: TYPE_NORMAL
- en: Other variants of `apply` include `vapply`, which is similar to `sapply` albeit
    with some relatively subtle differences, and `mapply`, which can operate on multiple
    vectors or lists at once. To learn more about `mapply`, see the `?mapply` help
    file; `vapply` and `sapply` are both covered in the `?lapply` help file.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of R’s `apply` functions allow for additional arguments to be passed to
    `FUN`; most of them do this via an ellipsis. For example, take another look at
    the matrix `foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Here you’ve applied `sort` to each row of the matrix and supplied the additional
    argument `decreasing=TRUE` to sort the rows from largest to smallest.
  prefs: []
  type: TYPE_NORMAL
- en: Some programmers prefer using the suite of `apply` functions wherever possible
    to improve the compactness and neatness of their code. However, note that these
    functions generally do not offer any substantial improvement in terms of computational
    speed or efficiency over an explicit loop (this is particularly the case with
    more recent versions of R). Plus, when you’re first learning the R language, explicit
    loops can be easier to read and follow since the operations are laid out clearly
    line by line.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.5**'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing on from the most recent example in the text, write an implicit loop
    that calculates the product of all the column elements of the matrix returned
    by the call to `apply(foo,1,sort,decreasing=TRUE)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Convert the following `for` loop to an implicit loop that does exactly the
    same thing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In R, store the following 4 × 4 × 2 × 3 array as the object `qux`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That is, it is a four-dimensional array comprised of three blocks, with each
    block being an array made up of two layers of 4 × 4 matrices. Then, do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write an implicit loop that obtains the diagonal elements of all second-layer
    matrices only to produce the following matrix:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Write an implicit loop that will return the `dim`ensions of each of the three
    matrices formed by accessing the fourth column of every matrix in `qux`, regardless
    of layer or block, wrapped by another implicit loop that finds the row sums of
    that returned structure, resulting simply in the following vector:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '**10.3 Other Control Flow Mechanisms**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To round off this chapter, you’ll look at three more control flow mechanisms:
    `break`, `next`, and `repeat`. These mechanisms are often used in conjunction
    with the loops and `if` statements you’ve seen already.'
  prefs: []
  type: TYPE_NORMAL
- en: '***10.3.1 Declaring break or next***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Normally a `for` loop will exit only when the `loopindex` exhausts the `loopvector`,
    and a `while` loop will exit only when the `loopcondition` evaluates to `FALSE`.
    But you can also preemptively terminate a loop by declaring `break`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you have a number, `foo`, that you want to divide by each element
    in a numeric vector `bar`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, let’s say you want to divide `foo` by `bar` element by element
    but want to halt execution if one of the results evaluates to `Inf` (which will
    result if dividing by zero). To do this, you can check each iteration with the
    `is.finite` function ([Section 6.1.1](ch06.xhtml#ch06lev2sec55)), and you can
    issue a `break` command to terminate the loop if it returns `FALSE`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Here, the loop divides the numbers normally until it reaches the fifth element
    of `bar` and divides by zero, resulting in `Inf`. Upon the resulting conditional
    check, the loop ends immediately, leaving the remaining entries of `loop1.result`
    as they were originally set—`NA`s.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking `break` is a fairly drastic move. Often, a programmer will include
    it only as a safety catch that’s meant to highlight or prevent unintended calculations.
    For more routine operations, it’s best to use another method. For instance, the
    example loop could easily be replicated as a `while` loop or the vector-oriented
    `ifelse` function, rather than relying on a `break`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of `break`ing and completely ending a loop, you can use `next` to simply
    advance to the next iteration and continue execution. Consider the following,
    where using `next` avoids division by zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: First, the loop checks to see whether the `i`th element of `bar` is zero. If
    it is, `next` is declared, and as a result, R ignores any subsequent lines of
    code in the braced area of the loop and returns to the top, automatically advancing
    to the next value of the `loopindex`. In the current example, the loop skips the
    fifth entry of `bar` (leaving the original `NA` value for that place) and continues
    through the rest of `bar`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you use either `break` or `next` in a nested loop, the command
    will apply only to the innermost loop. Only that inner loop will exit or advance
    to the next iteration, and any outer loops will continue as normal. For example,
    let’s return to the nested `for` loops from [Section 10.2.1](ch10.xhtml#ch10lev2sec92)
    that you used to fill a matrix with multiples of two vectors. This time you’ll
    use `next` in the inner loop to skip certain values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The inner loop skips to the `next` iteration if the product of the current elements
    is greater than or equal to 54\. Note the effect applies *only to that innermost
    loop*—that is, only the `j loopindex` is preemptively incremented, while `i` is
    left untouched, and the outer loop continues normally.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve been using `for` loops to illustrate `next` and `break`, but they behave
    the same way inside `while` loops.
  prefs: []
  type: TYPE_NORMAL
- en: '***10.3.2 The repeat Statement***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another option for repeating a set of operations is the `repeat` statement.
    The general definition is simple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Notice that a `repeat` statement doesn’t include any kind of `loopindex` or
    `loopcondition`. To stop repeating the code inside the braces, you must use a
    `break` declaration inside the braced area (usually within an `if` statement);
    without it, the braced code will repeat without end, creating an infinite loop.
    To avoid this, you must make sure the operations will at some point cause the
    loop to reach a `break`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see `repeat` in action, you’ll use it to calculate the famous mathematical
    series the *Fibonacci sequence*. The Fibonacci sequence is an infinite series
    of integers beginning with 1,1,2,3,5,8,13,. . . where each term in the series
    is determined by the sum of the two previous terms. Formally, if *F[n]* represents
    the *n*th Fibonacci number, then you have:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *F*[n][+][1] = *F[n]* + *F*[n][−][1]; | *n* = 2,3,4,5,. . . , |'
  prefs: []
  type: TYPE_TB
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: '*F*[1] = *F[2]* = 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `repeat` statement computes and prints the Fibonacci sequence,
    ending when it reaches a term greater than 150:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: First, the sequence is initialized by storing the first two terms, both 1, as
    `fib.a` and `fib.b`. Then, the `repeat` statement is entered, and it uses `fib.a`
    and `fib.b` to compute the next term in the sequence, stored as `temp`. Next,
    `fib.a` is overwritten to be `fib.b`, and `fib.b` is overwritten to be `temp`
    so that the two variables move forward through the series. That is, `fib.b` becomes
    the newly calculated Fibonacci number, and `fib.a` becomes the second-to-last
    number in the series so far. Use of `cat` then prints the new value of `fib.b`
    to the console. Finally, a check is made to see whether the latest term is greater
    than 150, and if it is, `break` is declared.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the code, the braced area is repeated over and over until `fib.b`
    reaches the first number that is greater than 150, namely, 89 + 144 = 233\. Once
    that happens, the `if` statement condition evaluates as `TRUE`, and R runs into
    `break`, terminating the loop.
  prefs: []
  type: TYPE_NORMAL
- en: The `repeat` statement is not as commonly used as the standard `while` or `for`
    loops, but it’s useful if you don’t want to be bound by formally specifying the
    `loopindex` and `loopvector` of a `for` loop or the `loopcondition` of a `while`
    loop. However, with `repeat`, you have to take a bit more caution to prevent infinite
    loops.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.6**'
  prefs: []
  type: TYPE_NORMAL
- en: Using the same objects from [Section 10.3.1](ch10.xhtml#ch10lev2sec95),
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write a `while` loop—*without* using `break` or `next`—that will reach exactly
    the same result as the `break` example in [Section 10.3.1](ch10.xhtml#ch10lev2sec95).
    That is, produce the same vector as `loop2.result` in the text.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtain the same result as `loop3.result`, the example concerning `next`, using
    an `ifelse` function instead of a loop.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To demonstrate `while` loops in [Section 10.2.2](ch10.xhtml#ch10lev2sec93),
    you used the vector
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: to progressively fill `mylist` with identity matrices whose dimensions matched
    the values in `mynumbers`. The loop was instructed to stop when it reached the
    end of the numeric vector or a number that was greater than 5.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write a `for` loop using a `break` declaration that does the same thing.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a `repeat` statement that does the same thing.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Suppose you have two lists, `matlist1` and `matlist2`, both filled with numeric
    matrices as their members. Assume that all members have finite, nonmissing values,
    but *do not* assume that the dimensions of the matrices are the same throughout.
    Write a nested pair of `for` loops that aim to create a result list, `reslist`,
    of all possible *matrix products* (refer to [Section 3.3.5](ch03.xhtml#ch03lev2sec33))
    of the members of the two lists according to the following guidelines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – The `matlist1` object should be indexed/searched in the outer loop, and the
    `matlist2` object should be indexed/searched in the inner loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – You’re interested only in the possible matrix products of the members of `matlist1`
    with the members of `matlist2` in that order.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – If a particular multiple isn’t possible (that is, if the `ncol` of a member
    of `matlist1` doesn’t match the `nrow` of a member of `matlist2`), then you should
    skip that multiplication, store the string `"not possible"` at the relevant position
    in `reslist`, and proceed directly to the `next` matrix multiplication.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – You can define a `counter` that is incremented at each comparison (inside
    the inner loop) to keep track of the current position of `reslist`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note, therefore, that the `length` of `reslist` will be equal to `length(matlist1)*length(matlist2)`.
    Now, confirm the following results:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you have
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: then all members of `reslist` should be `"not possible"` apart from members
    `[[1]]` and `[[7]]`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: If you have
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: then only the `"not possible"` members of `reslist` should be `[[3]]`, `[[6]]`,
    and `[[9]]`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Important Code in This Chapter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `if( ){ }` | Conditional check | [Section 10.1.1](ch10.xhtml#ch10lev2sec87),
    [p. 180](ch10.xhtml#page_180) |'
  prefs: []
  type: TYPE_TB
- en: '| `if( ){ } else { }` | Check and alternative | [Section 10.1.2](ch10.xhtml#ch10lev2sec88),
    [p. 183](ch10.xhtml#page_183) |'
  prefs: []
  type: TYPE_TB
- en: '| `ifelse` | Element-wise `if-else` check | [Section 10.1.3](ch10.xhtml#ch10lev2sec89),
    [p. 185](ch10.xhtml#page_185) |'
  prefs: []
  type: TYPE_TB
- en: '| `switch` | Multiple `if` choices | [Section 10.1.5](ch10.xhtml#ch10lev2sec91),
    [p. 190](ch10.xhtml#page_190) |'
  prefs: []
  type: TYPE_TB
- en: '| `for( ){ }` | Iterative loop | [Section 10.2.1](ch10.xhtml#ch10lev2sec92),
    [p. 194](ch10.xhtml#page_194) |'
  prefs: []
  type: TYPE_TB
- en: '| `while( ){ }` | Conditional loop | [Section 10.2.2](ch10.xhtml#ch10lev2sec93),
    [p. 200](ch10.xhtml#page_200) |'
  prefs: []
  type: TYPE_TB
- en: '| `apply` | Implicit loop by margin | [Section 10.2.3](ch10.xhtml#ch10lev2sec94),
    [p. 205](ch10.xhtml#page_205) |'
  prefs: []
  type: TYPE_TB
- en: '| `tapply` | Implicit loop by factor | [Section 10.2.3](ch10.xhtml#ch10lev2sec94),
    [p. 207](ch10.xhtml#page_207) |'
  prefs: []
  type: TYPE_TB
- en: '| `lapply` | Implicit loop by member | [Section 10.2.3](ch10.xhtml#ch10lev2sec94),
    [p. 207](ch10.xhtml#page_207) |'
  prefs: []
  type: TYPE_TB
- en: '| `sapply` | As `lapply`, array returned | [Section 10.2.3](ch10.xhtml#ch10lev2sec94),
    [p. 207](ch10.xhtml#page_207) |'
  prefs: []
  type: TYPE_TB
- en: '| `break` | Exit explicit loop | [Section 10.3.1](ch10.xhtml#ch10lev2sec95),
    [p. 210](ch10.xhtml#page_210) |'
  prefs: []
  type: TYPE_TB
- en: '| `next` | Skip to next loop iteration | [Section 10.3.1](ch10.xhtml#ch10lev2sec95),
    [p. 210](ch10.xhtml#page_210) |'
  prefs: []
  type: TYPE_TB
- en: '| `repeat{ }` | Repeat code until `break` | [Section 10.3.2](ch10.xhtml#ch10lev2sec96),
    [p. 212](ch10.xhtml#page_212) |'
  prefs: []
  type: TYPE_TB
