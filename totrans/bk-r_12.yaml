- en: '**10**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10**'
- en: '**CONDITIONS AND LOOPS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件与循环**'
- en: '![image](../images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common-01.jpg)'
- en: To write more sophisticated programs with R, you’ll need to control the flow
    and order of execution in your code. One fundamental way to do this is to make
    the execution of certain sections of code dependent on a *condition*. Another
    basic control mechanism is the *loop*, which repeats a block of code a certain
    number of times. In this chapter, we’ll explore these core programming techniques
    using `if`-`else` statements, `for` and `while` loops, and other control structures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要用 R 编写更复杂的程序，你需要控制代码的执行流程和顺序。实现这一点的一种基本方法是使某些代码段的执行依赖于一个*条件*。另一种基本控制机制是*循环*，它会将一段代码重复执行指定的次数。在本章中，我们将使用
    `if`-`else` 语句、`for` 和 `while` 循环以及其他控制结构，来探讨这些核心编程技巧。
- en: '**10.1 if Statements**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**10.1 if 语句**'
- en: The `if` statement is the key to controlling exactly which operations are carried
    out in a given chunk of code. An `if` statement runs a block of code only if a
    certain condition is true. These constructs allow a program to respond differently
    depending on whether a condition is `TRUE` or `FALSE`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句是控制在特定代码块中到底执行哪些操作的关键。`if` 语句只有在某个条件为真时，才会执行代码块中的内容。这些构造使得程序可以根据条件是否为
    `TRUE` 或 `FALSE` 做出不同的反应。'
- en: '***10.1.1 Stand-Alone Statement***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.1.1 独立语句***'
- en: 'Let’s start with the stand-alone `if` statement, which looks something like
    this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从独立的 `if` 语句开始，它看起来大概是这样的：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `condition` is placed in parentheses after the `if` keyword. This condition
    must be an expression that yields a single logical value (`TRUE` or `FALSE`).
    If it’s `TRUE`, the code in the braces, `{}`, will be executed. If the condition
    isn’t satisfied, the code in the braces is skipped, and R does nothing (or continues
    on to execute any code after the closing brace).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`condition` 放在 `if` 关键字后面的括号内。这个条件必须是一个表达式，它返回一个单一的逻辑值（`TRUE` 或 `FALSE`）。如果条件为
    `TRUE`，大括号 `{}` 中的代码将会被执行。如果条件不成立，大括号中的代码将被跳过，R 将什么都不做（或继续执行在闭合大括号后面的代码）。'
- en: 'Here’s a simple example. In the console, store the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例。在控制台中，存储以下内容：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, in the R editor, write the following code chunk:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 R 编辑器中，写下以下代码块：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When this chunk is executed, what will the value of `a` be? It depends on the
    condition defining the `if` statement, as well as what’s actually specified in
    the braced area. In this case, when the condition `a<=mynumber` is evaluated,
    the result is `TRUE` since 3 is indeed less than or equal to 4\. That means the
    code inside the braces is executed, which sets `a` to `a^2`, or 9.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行这段代码时，`a` 的值会是多少？这取决于定义 `if` 语句的条件，以及大括号内实际指定的内容。在这个例子中，当条件 `a<=mynumber`
    被评估时，结果是 `TRUE`，因为 3 确实小于或等于 4。这意味着大括号内的代码会被执行，`a` 被设为 `a^2`，即 9。
- en: 'Now highlight the entire chunk of code in the editor and send it to the console
    for evaluation. Remember, you can do this in several ways:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，高亮显示编辑器中的整个代码块，并将其发送到控制台进行评估。记住，你可以通过几种方式做到这一点：
- en: • Copy and paste the selected text from the editor directly into the console.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: • 直接将选中的文本从编辑器复制并粘贴到控制台中。
- en: • From the menu, select **Edit** → **Run line or selection** in Windows or select
    **Edit** → **Execute** in OS X.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: • 在菜单中，选择 **编辑** → **运行行或选择**（Windows）或选择 **编辑** → **执行**（OS X）。
- en: • Use the keystroke shortcut such as CTRL-R in Windows or -RETURN on a Mac.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用快捷键，例如在 Windows 中按 CTRL-R，或在 Mac 上按 -RETURN。
- en: 'Once you execute the code in the console, you’ll see something like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在控制台中执行代码，你将看到类似下面的结果：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, look at the object `a`, shown here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，查看对象 `a`，如图所示：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, suppose you execute the same `if` statement again right away. Will `a`
    be squared once more, giving 81? Nope! Since `a` is now 9 and `mynumber` is still
    4, the condition `a<=mynumber` will be `FALSE`, and the code in the braces will
    not be executed; `a` will remain at 9.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设你立刻再次执行相同的 `if` 语句。`a` 会再次被平方，变为 81 吗？不会！因为 `a` 现在是 9，而 `mynumber` 依然是
    4，条件 `a<=mynumber` 将是 `FALSE`，因此大括号内的代码不会被执行；`a` 将保持为 9。
- en: Note that after you send the `if` statement to the console, each line after
    the first is prefaced by a `+`. These `+` signs do not represent any kind of arithmetic
    addition; rather, they indicate that R is expecting more input before it begins
    execution. For example, when a left brace is opened, R will not begin any kind
    of execution until that section is closed with a right brace. To avoid redundancy,
    in future examples I won’t show this repetition of code sent from the editor to
    the console.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在你将`if`语句发送到控制台后，每一行的前面都会有一个`+`。这些`+`符号并不表示任何形式的算术加法；相反，它们表示R在开始执行之前，期望更多的输入。例如，当左花括号被打开时，R不会开始执行，直到该部分以右花括号关闭。为了避免重复，今后的示例中，我不会展示从编辑器发送到控制台的这部分代码的重复。
- en: '**NOTE**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can change the* `+` *symbol by assigning a different character string
    to the* `continue` *component of R’s* `options` *command, in the way you reset
    the prompt in [Section 1.2.1](ch01.xhtml#ch01lev2sec06).*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以通过将不同的字符字符串分配给R的`options`命令中的`continue`组件来改变`+`符号，就像在[第1.2.1节](ch01.xhtml#ch01lev2sec06)中重置提示符一样。*'
- en: The `if` statement offers a huge amount of flexibility—you can place any kind
    of code in the braced area, including more `if` statements (see the upcoming discussion
    of nesting in [Section 10.1.4](ch10.xhtml#ch10lev2sec90)), enabling your program
    to make a sequence of decisions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句提供了极大的灵活性——你可以在花括号区域内放置任何类型的代码，包括更多的`if`语句（参见即将讨论的嵌套部分，见[第10.1.4节](ch10.xhtml#ch10lev2sec90)），这样可以使你的程序做出一系列的决策。'
- en: 'To illustrate a more complicated `if` statement, consider the following two
    new objects:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明一个更复杂的`if`语句，考虑以下两个新对象：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Use these two objects in the code chunk given here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用这两个对象的代码块：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Send this to the console, and it produces the following output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到控制台，会产生以下输出：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Indeed, an object `mylist` has been created that you can examine.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，已经创建了一个名为`mylist`的对象，你可以检查它。
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, the condition consists of two parts separated by an OR statement
    using `||`, which produces a single logical result. Let’s walk through it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，条件由两部分组成，通过使用`||`的OR语句连接，产生一个单一的逻辑结果。我们来逐步分析它。
- en: • The first part of the condition looks at `myvec`, takes `1` away from each
    element, and checks whether any of the results are greater than 9\. If you run
    this part on its own, it yields `FALSE`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: • 条件的第一部分查看`myvec`，从每个元素中减去`1`，并检查结果是否有任何值大于9。如果单独运行这一部分，结果是`FALSE`。
- en: R> myvec-1
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: R> myvec-1
- en: '[1] 1.73 4.40 1.15 4.29 0.36 1.16 0.41 5.97 6.99 8.52'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1.73 4.40 1.15 4.29 0.36 1.16 0.41 5.97 6.99 8.52'
- en: R> (myvec-1)>9
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: R> (myvec-1)>9
- en: '[1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE'
- en: R> any((myvec-1)>9)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: R> any((myvec-1)>9)
- en: '[1] FALSE'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] FALSE'
- en: • The second part of the condition uses positional matching in a call to `matrix`
    to construct a two-row, five-column, column-filled matrix using entries of the
    original `myvec`. Then, the number in the second row of the first column of that
    result is checked to see whether it’s less than or equal to 6, which it is.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: • 条件的第二部分在调用`matrix`时使用位置匹配，构造了一个由原始`myvec`的条目填充的两行五列的矩阵。然后，检查该结果的第一列第二行的数字，看看它是否小于或等于6，结果是符合的。
- en: R> matrix(myvec,2,5)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: R> matrix(myvec,2,5)
- en: '[,1] [,2] [,3] [,4] [,5]'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2] [,3] [,4] [,5]'
- en: '[1,] 2.73 2.15 1.36 1.41 7.99'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,] 2.73 2.15 1.36 1.41 7.99'
- en: '[2,] 5.40 5.29 2.16 6.97 9.52'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,] 5.40 5.29 2.16 6.97 9.52'
- en: R> matrix(myvec,2,5)[2,1]
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: R> matrix(myvec,2,5)[2,1]
- en: '[1] 5.4'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 5.4'
- en: R> matrix(myvec,2,5)[2,1]<=6
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: R> matrix(myvec,2,5)[2,1]<=6
- en: '[1] TRUE'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] TRUE'
- en: This means the overall condition being checked by the `if` statement will be
    `FALSE||TRUE`, which evaluates as `TRUE`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`if`语句检查的整体条件将是`FALSE||TRUE`，其结果为`TRUE`。
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As a result, the code inside the braces is accessed and executed. First, it
    prints the `"Condition satisfied"` string and copies `myvec` to `new.myvec`. Using
    `seq`, it then accesses the odd-numbered indexes of `new.myvec` and overwrites
    them with `NA`. Next, it creates `mylist`. In this list, `new.myvec` is stored
    in a member named `aa`, and then it takes the original `mymat`, increases all
    its elements by 0.5, and stores the result in `bb`. Lastly, it prints the length
    of the resulting list.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，花括号内的代码被访问并执行。首先，它打印出`"Condition satisfied"`字符串，并将`myvec`复制到`new.myvec`。接着，使用`seq`访问`new.myvec`中的奇数索引，并将其值覆盖为`NA`。然后，它创建了`mylist`，在这个列表中，`new.myvec`被存储在一个名为`aa`的成员中，接着将原始的`mymat`的所有元素增加0.5，并将结果存储在`bb`中。最后，打印出生成的列表的长度。
- en: Note that `if` statements don’t have to match the exact style I’m using here.
    Some programmers, for example, prefer to open the left brace on a new line after
    the condition, or some may prefer a different amount of indentation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`if`语句不必完全按照我在这里使用的样式。有些程序员，例如，喜欢在条件后面将左大括号放在新的一行，或者有些人可能喜欢不同的缩进方式。
- en: '***10.1.2 else Statements***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.1.2 else 语句***'
- en: 'The `if` statement executes a chunk of code if and only if a defined condition
    is `TRUE`. If you want something different to happen when the condition is `FALSE`,
    you can add an `else` declaration. Here’s an example in pseudocode:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句只有在定义的条件为`TRUE`时才会执行一段代码。如果你希望在条件为`FALSE`时发生不同的事情，你可以添加一个`else`声明。这里是一个伪代码示例：'
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You set the condition, then in the first set of braces you place the code to
    run if the condition is `TRUE`. After this, you declare `else` followed by a new
    set of braces where you can place code to run if the condition is `FALSE`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你设置条件，然后在第一组大括号中放置当条件为`TRUE`时要执行的代码。在此之后，你声明`else`，后面跟着一个新的大括号，你可以在其中放置当条件为`FALSE`时要执行的代码。
- en: Let’s return to the first example in [Section 10.1.1](ch10.xhtml#ch10lev2sec87),
    once more storing these values at the console prompt.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到[第10.1.1节](ch10.xhtml#ch10lev2sec87)中的第一个例子，再次将这些值存储在控制台提示符下。
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the editor, create a new version of the earlier `if` statement.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中，创建一个新的版本的早期`if`语句。
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, you again square `a` if the condition `a<=mynumber` is `TRUE`, but if
    `FALSE`, `a` is overwritten by the result of itself minus 3.5\. You also print
    text to the console stating whether the condition was met. After resetting `a`
    and `mynumber` to their original values, the first run of the `if` loop computes
    `a` as 9, just as earlier, outputting the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果条件`a<=mynumber`为`TRUE`，你再次将`a`平方；但如果为`FALSE`，则将`a`覆盖为自身减去3.5的结果。你还会打印文本到控制台，说明条件是否满足。在将`a`和`mynumber`重置为它们的原始值后，`if`循环的第一次运行将`a`计算为9，就像之前一样，并输出以下内容：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, immediately highlight and execute the entire statement again. This time
    around, `a<=mynumber` will evaluate to `FALSE` and execute the code after `else`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，立即高亮并再次执行整个语句。这一次，`a<=mynumber`将计算为`FALSE`并执行`else`之后的代码。
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***10.1.3 Using ifelse for Element-wise Checks***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.1.3 使用ifelse进行逐元素检查***'
- en: 'An `if` statement can check the condition of only a single logical value. If
    you pass in, for example, a vector of logicals for the condition, the `if` statement
    will only check (and operate based on) the very first element. It will issue a
    warning saying as much, as the following dummy example shows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句只能检查单一的逻辑值。如果你传入一个逻辑向量作为条件，例如，`if`语句将只检查（并基于）第一个元素。它会发出警告，正如下面的虚拟示例所示：'
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There is, however, a shortcut function available, `ifelse`, which can perform
    this kind of vector-oriented check in relatively simple cases. To demonstrate
    how it works, consider the objects `x` and `y` defined as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个可用的快捷函数`ifelse`，它可以在相对简单的情况下执行这种向量化检查。为了演示它是如何工作的，考虑以下定义的对象`x`和`y`：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, suppose you want to produce the result of `x/y` but with any instance of
    `Inf` (that is, any instance where `x` is divided by zero) replaced with `NA`.
    In other words, for each element in `y`, you want to check whether `y` is zero.
    If so, you want the code to output `NA`, and if not, it should output the result
    of `x/y`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想得到`x/y`的结果，但将任何`Inf`（即`x`除以零的任何实例）替换为`NA`。换句话说，对于`y`中的每个元素，你想检查`y`是否为零。如果是，那么你希望代码输出`NA`，如果不是，它应该输出`x/y`的结果。
- en: As you’ve just seen, a simple `if` statement won’t work here. Since it accepts
    only a single logical value, it can’t run through the entire logical vector produced
    by `y==0`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚看到的，简单的`if`语句在这里不起作用。由于它只接受单一的逻辑值，它不能遍历`y==0`生成的整个逻辑向量。
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Instead, you can use the element-wise `ifelse` function for this kind of scenario.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以在这种情况下使用逐元素的`ifelse`函数。
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using exact matching, this command creates the desired `result` vector in one
    line. Three arguments must be specified: `test` takes a logical-valued data structure,
    `yes` provides the element to return if the condition is satisfied, and `no` gives
    the element to return if the condition is `FALSE`. As noted in the function documentation
    (which you can access with `?ifelse`), the returned structure will be of “the
    same length and attributes as `test`.”'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用精确匹配，这个命令在一行中创建了期望的 `result` 向量。必须指定三个参数：`test` 接受一个逻辑值数据结构，`yes` 提供满足条件时返回的元素，`no`
    提供条件为 `FALSE` 时返回的元素。正如函数文档中所指出的（你可以通过 `?ifelse` 访问它），返回的结构将具有与 `test` 相同的长度和属性。
- en: '**Exercise 10.1**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 10.1**'
- en: 'Create the following two vectors:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下两个向量：
- en: '[PRE19]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Without executing them, determine which of the following `if` statements would
    result in the string being printed to the console. Then confirm your answers in
    R.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在不执行它们的情况下，确定以下哪个 `if` 语句会导致字符串被打印到控制台。然后在 R 中确认你的答案。
- en: '[PRE20]'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using `vec1` and `vec2` from (a), write and execute a line of code that multiplies
    the corresponding elements of the two vectors together *if* their sum is greater
    than 3\. Otherwise, the code should simply sum the two elements.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用（a）中的 `vec1` 和 `vec2`，编写并执行一行代码，只有当它们的和大于 3 时，才将两个向量的对应元素相乘。否则，代码应简单地将两个元素相加。
- en: 'In the editor, write R code that takes a square character matrix and checks
    *if* any of the character strings on the diagonal (top left to bottom right) begin
    with the letter *g*, lowercase or uppercase. If satisfied, these specific entries
    should be overwritten with the string `"HERE"`. Otherwise, the entire matrix should
    be replaced with an identity matrix of the same dimensions. Then, try your code
    on the following matrices, checking the result each time:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中编写 R 代码，该代码接受一个方形字符矩阵，并检查对角线上的任何字符字符串（从左上角到右下角）是否以字母 *g*（无论是小写还是大写）开头。如果满足条件，这些特定条目应该被字符串
    `"HERE"` 覆盖。否则，整个矩阵应该被同样维度的单位矩阵替换。然后，在以下矩阵上尝试你的代码，并每次检查结果：
- en: '[PRE24]'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Hint: This requires some thought—you will find the functions `diag` from [Section
    3.2.1](ch03.xhtml#ch03lev2sec27) and `substr` from [Section 4.2.4](ch04.xhtml#ch04lev2sec45)
    useful.'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示：这需要一些思考——你会发现 [第 3.2.1 节](ch03.xhtml#ch03lev2sec27) 中的 `diag` 函数和 [第 4.2.4
    节](ch04.xhtml#ch04lev2sec45) 中的 `substr` 函数会很有用。
- en: '***10.1.4 Nesting and Stacking Statements***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.1.4 嵌套和堆叠语句***'
- en: An `if` statement can itself be placed within the outcome of another `if` statement.
    By *nesting* or *stacking* several statements, you can weave intricate paths of
    decision-making by checking a number of conditions at various stages during execution.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `if` 语句可以被放置在另一个 `if` 语句的结果中。通过 *嵌套* 或 *堆叠* 多个语句，你可以在执行过程中检查多个条件，从而编织出复杂的决策路径。
- en: 'In the editor, modify the `mynumber` example once more as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中再次修改 `mynumber` 示例，如下所示：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here you see the same initial decision being made as earlier. The value `a`
    is squared if it’s less than or equal to `mynumber`; if not, it has 3.5 subtracted
    from it. But now there’s another `if` statement within each braced area. If the
    first condition is satisfied and `a` is squared, you then check whether `mynumber`
    is greater than 3\. If `TRUE`, `b` is assigned `seq(1,a,length=mynumber)`. If
    `FALSE`, `b` is assigned `a*mynumber`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你会看到与之前相同的初始决策。如果 `a` 小于或等于 `mynumber`，则将其平方；否则，将其减去 3.5。但是现在每个大括号区域内有另一个
    `if` 语句。如果第一个条件满足且 `a` 被平方，则继续检查 `mynumber` 是否大于 3。如果是 `TRUE`，则将 `b` 赋值为 `seq(1,a,length=mynumber)`；如果是
    `FALSE`，则将 `b` 赋值为 `a*mynumber`。
- en: If the first condition fails and you subtract 3.5 from `a`, then you check a
    second condition to see whether `mynumber` is greater than or equal to 4\. If
    it is, then `b` becomes `a^(3-mynumber)`. If it’s not, `b` becomes `rep(a+mynumber,times=3)`.
    Note that I’ve indented the code within each subsequent braced area to make it
    easier to see which lines are relevant to each possible decision.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个条件失败并且你从 `a` 中减去 3.5，然后检查第二个条件，查看 `mynumber` 是否大于或等于 4。如果是，那么 `b` 变为 `a^(3-mynumber)`。如果不是，`b`
    变为 `rep(a+mynumber,times=3)`。请注意，我已经缩进了每个大括号内的代码，以便更容易看到哪些行与每个可能的决策相关。
- en: 'Now, reset `a <- 3` and `mynumber <- 4` either directly in the console or from
    the editor. When you run the `mynumber` example code, you’ll get the following
    output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在控制台中直接或通过编辑器重置 `a <- 3` 和 `mynumber <- 4`。当你运行 `mynumber` 示例代码时，你将得到以下输出：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The result indicates exactly which code was invoked—the first condition and
    second condition were both `TRUE`. Trying another run of the same code, after
    first setting
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示了究竟是哪个代码被调用——第一个条件和第二个条件都为`TRUE`。在再次运行相同代码之前，首先设置
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'you see this output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到这个输出：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This time the first condition fails, but the second condition checked inside
    the `else` statement is `TRUE`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这次第一个条件失败了，但在`else`语句内检查的第二个条件是`TRUE`。
- en: 'Alternatively, you could accomplish the same thing by sequentially *stacking*
    `if` statements and using a combination of logical expressions in each condition.
    In the following example, you check for the same four situations, but this time
    you stack `if` statements by placing a new `if` declaration immediately following
    an `else` declaration:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以通过依次*堆叠*`if`语句并在每个条件中使用逻辑表达式的组合来实现相同的效果。在下面的示例中，你检查了相同的四种情况，但这次你通过将新的`if`声明直接跟在`else`声明后面来堆叠`if`语句：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Just as before, only one of the four braced areas will end up being executed.
    Comparing this to the nested version, the first two braced areas correspond to
    what was originally the first condition (`a<=mynumber`) being satisfied, but this
    time you use `&&` to check two expressions at once. If neither of those two situations
    is met, this means the first condition is false, so in the third statement, you
    just have to check whether `mynumber>=4`. For the final `else` statement, you
    don’t need to check any conditions because that statement will be executed only
    if all the previous conditions were not met.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，四个括起来的区域中只有一个最终会被执行。与嵌套版本相比，前两个括起来的区域对应于最初的第一个条件（`a<=mynumber`）被满足，但这次你使用`&&`同时检查两个表达式。如果这两个情况都不满足，那么第一个条件就是假，因此在第三个语句中，你只需要检查`mynumber>=4`。对于最终的`else`语句，你无需检查任何条件，因为该语句仅在所有之前的条件未满足时才会执行。
- en: 'If you again reset `a` and `mynumber` to 3 and 4, respectively, and execute
    the stacked statements shown earlier, you get the following result:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次将`a`和`mynumber`分别重置为3和4，并执行之前展示的堆叠语句，你将得到以下结果：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This produces the same values for `a` and `b` as earlier. If you execute the
    code again using the second set of initial values (`a` as 6 and `mynumber` as
    4), you get the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生与之前相同的`a`和`b`的值。如果你使用第二组初始值（`a`为6，`mynumber`为4）再次执行代码，你将得到以下结果：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This again matches the results of using the nested version of the code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这再次与使用嵌套版本代码的结果相匹配。
- en: '***10.1.5 The switch Function***'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.1.5 switch函数***'
- en: 'Let’s say you need to choose which code to run based on the value of a single
    object (a common scenario). One option is to use a series of `if` statements,
    where you compare the object with various possible values to produce a logical
    value for each condition. Here’s an example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要根据一个对象的值来选择运行的代码（这是一个常见场景）。一种选择是使用一系列的`if`语句，通过将对象与各种可能的值进行比较，为每个条件生成一个逻辑值。下面是一个示例：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The goal of this code is simply to assign a numeric value to an object `foo`,
    where the exact number depends on the value of `mystring`. The `mystring` object
    can take one of the five possibilities shown, or if `mystring` doesn’t match any
    of these, `foo` is assigned `NA`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的目标是简单地为对象`foo`赋一个数值，其中具体的数字取决于`mystring`的值。`mystring`对象可以有五种可能的值，或者如果`mystring`与这些值都不匹配，则`foo`被赋值为`NA`。
- en: This code works just fine as it is. For example, setting
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码按原样运行得很好。例如，设置
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'and executing the chunk, you’ll see this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 并执行代码块，你会看到这个结果：
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Setting the following
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 设置以下
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'and executing the chunk again, you’ll see this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 并再次执行代码块，你会看到这个结果：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This setup using `if`-`else` statements is quite cumbersome for such a basic
    operation, though. R can handle this type of multiple-choice decision in a far
    more compact form via the `switch` function. For example, you could rewrite the
    stacked `if` statements as a much shorter `switch` statement as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`if`-`else`语句来设置这种基础操作显得相当繁琐。R可以通过`switch`函数以更紧凑的形式处理这种多选决策。例如，你可以将堆叠的`if`语句改写为一个更简洁的`switch`语句，如下所示：
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: and
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以及
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The first argument, `EXPR`, is the object of interest and can be either a numeric
    or a character string. The remaining arguments provide the values or operations
    to carry out based on the value of `EXPR`. If `EXPR` is a string, these argument
    tags must *exactly* match the possible results of `EXPR`. Here, the `switch` statement
    evaluates to 12 if `mystring` is `"Homer"`, 34 if `mystring` is `"Marge"`, and
    so on. The final, untagged value, `NA`, indicates the result if `mystring` doesn’t
    match any of the preceding items.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The integer version of `switch` works in a slightly different way. Instead
    of using tags, the outcome is determined purely with positional matching. Consider
    the following example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, you provide an integer `mynum` as the first argument, and it’s positionally
    matched to `EXPR`. The example code then shows five untagged arguments: `12` to
    `NA`. The `switch` function simply returns the value in the specific position
    requested by `mynum`. Since `mynum` is 3, the statement assigns 56 to `foo`. Had
    `mynum` been 1, 2, 4, or 5, `foo` would’ve been assigned 12, 34, 78, or `NA`,
    respectively. Any other value of `mynum` (less than 1 or greater than 5) will
    return `NULL`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In these types of situations, the `switch` function behaves the same way as
    a set of stacked `if` statements, so it can serve as a convenient shortcut. However,
    if you need to examine multiple conditions at once or you need to execute a more
    complicated set of operations based on this decision, you’ll need to use the explicit
    `if` and `else` control structures.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.2**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Write an explicit stacked set of `if` statements that does the same thing as
    the integer version of the `switch` function illustrated earlier. Test it with
    `mynum <- 3` and `mynum <- 0`, as in the text.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Suppose you are tasked with computing the precise dosage amounts of a certain
    drug in a collection of hypothetical scientific experiments. These amounts depend
    upon some predetermined set of “dosage thresholds” (`lowdose`, `meddose`, and
    `highdose`), as well as a predetermined dose level factor vector named `doselevel`.
    Look at the following items (i–iv) to see the intended form of these objects.
    Then write a set of nested `if` statements that produce a new numeric vector called
    `dosage`, according to the following rules:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '– First, *if* there are any instances of `"High"` in `doselevel`, perform the
    following operations:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* Check *if* `lowdose` is greater than or equal to 10\. If so, overwrite `lowdose`
    with 10; *otherwise*, overwrite `lowdose` by itself divided by 2.'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* Check *if* `meddose` is greater than or equal to 26\. If so, overwrite `meddose`
    by 26.'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* Check *if* `highdose` is less than 60\. If so, overwrite `highdose` with
    60; *otherwise*, overwrite `highdose` by itself multiplied by 1.5.'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* Create a vector named `dosage` with the value of `lowdose` repeated (`rep`)
    to match the `length` of `doselevel`.'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* Overwrite the elements in `dosage` corresponding to the index positions of
    instances of `"Med"` in `doselevel` by `meddose`.'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* 将`dosage`中对应于`doselevel`中`"Med"`实例索引位置的元素覆盖为`meddose`。'
- en: '* Overwrite the elements in `dosage` corresponding to the index positions of
    instances of `"High"` in `doselevel` by `highdose`.'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* 将`dosage`中对应于`doselevel`中`"High"`实例索引位置的元素覆盖为`highdose`。'
- en: '– *Otherwise* (in other words, if there are no instances of `"High"` in `doselevel`),
    perform the following operations:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – *否则*（换句话说，如果`doselevel`中没有`"High"`实例），执行以下操作：
- en: '* Create a new version of `doselevel`, a factor vector with levels `"Low"`
    and `"Med"` only, and label these with `"Small"` and `"Large"`, respectively (refer
    to [Section 4.3](ch04.xhtml#ch04lev1sec18) for details or see `?factor`).'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* 创建`doselevel`的新版本，一个仅具有级别`"Low"`和`"Med"`的因子向量，并将这些级别分别标记为`"Small"`和`"Large"`（有关详细信息，请参见[第4.3节](ch04.xhtml#ch04lev1sec18)，或查看`?factor`）。'
- en: '* Check to see *if* `lowdose` is less than 15 AND `meddose` is less than 35\.
    If so, overwrite `lowdose` by itself multiplied by 2 and overwrite `meddose` by
    itself plus `highdose`.'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* 检查`lowdose`是否小于15，并且`meddose`是否小于35。如果是，单独将`lowdose`乘以2，并将`meddose`覆盖为其本身加上`highdose`。'
- en: '* Create a vector named `dosage`, which is the value of `lowdose` repeated
    (`rep`) to match the `length` of `doselevel`.'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* 创建一个名为`dosage`的向量，其值为`lowdose`重复（`rep`）至与`doselevel`的`length`匹配。'
- en: '* Overwrite the elements in `dosage` corresponding to the index positions of
    instances of `"Large"` in `doselevel` by `meddose`.'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* 将`dosage`中对应于`doselevel`中`"Large"`实例索引位置的元素覆盖为`meddose`。'
- en: 'Now, confirm the following:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，确认以下内容：
- en: Given
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定
- en: '[PRE43]'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'the result of `dosage` after running the nested `if` statements is as follows:'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行嵌套`if`语句后，`dosage`的结果如下：
- en: '[PRE44]'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Using the same `lowdose`, `meddose`, and `highdose` thresholds as in (i), given
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与（i）中相同的`lowdose`、`meddose`和`highdose`阈值，给定
- en: '[PRE45]'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'the result of `dosage` after running the nested `if` statements is as follows:'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行嵌套`if`语句后，`dosage`的结果如下：
- en: '[PRE46]'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Also, `doselevel` has been overwritten as follows:'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，`doselevel`已被如下覆盖：
- en: '[PRE47]'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Given
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定
- en: '[PRE48]'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'the result of `dosage` after running the nested `if` statements is as follows:'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行嵌套`if`语句后，`dosage`的结果如下：
- en: '[PRE49]'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Also, `doselevel` has been overwritten as follows:'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，`doselevel`已被如下覆盖：
- en: '[PRE50]'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Using the same `lowdose`, `meddose`, and `highdose` thresholds as (iii), as
    well as the same `doselevel` as (i), the result of `dosage` after running the
    nested `if` statements is as follows:'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与（iii）中相同的`lowdose`、`meddose`和`highdose`阈值，以及与（i）中相同的`doselevel`，运行嵌套`if`语句后，`dosage`的结果如下：
- en: '[PRE51]'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Assume the object `mynum` will only ever be a single integer between 0 and 9\.
    Use `ifelse` and `switch` to produce a command that takes in `mynum` and returns
    a matching character string for all possible values 0, 1, ..., 9\. Supplied with
    `3`, for example, it should return `"three"`; supplied with `0`, it should return
    `"zero"`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设对象`mynum`始终是介于0和9之间的单个整数。使用`ifelse`和`switch`来生成一个命令，该命令接受`mynum`并返回与所有可能值0,
    1, ..., 9对应的字符字符串。例如，传入`3`时应返回`"three"`；传入`0`时应返回`"zero"`。
- en: '**10.2 Coding Loops**'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**10.2 编码循环**'
- en: 'Another core programming mechanism is the *loop*, which repeats a specified
    section of code, often while incrementing an index or counter. There are two styles
    of looping: the `for` loop repeats code as it works its way through a vector,
    element by element; the `while` loop simply repeats code until a specific condition
    evaluates to `FALSE`. Looplike behavior can also be achieved with R’s suite of
    `apply` functions, which are discussed in [Section 10.2.3](ch10.xhtml#ch10lev2sec94).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种核心编程机制是*循环*，它会重复指定的代码段，通常是通过递增索引或计数器来实现。有两种循环方式：`for`循环会在向量中逐个元素地执行代码；`while`循环则会在某个特定条件评估为`FALSE`时停止。循环行为还可以通过R的`apply`函数系列来实现，相关内容讨论见[第10.2.3节](ch10.xhtml#ch10lev2sec94)。
- en: '***10.2.1 for Loops***'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.2.1 for循环***'
- en: 'The R `for` loop always takes the following general form:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: R的`for`循环始终采用以下通用形式：
- en: '[PRE52]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, the `loopindex` is a placeholder that represents an element in the `loopvector`—it
    starts off as the first element in the vector and moves to the next element with
    each loop repetition. When the `for` loop begins, it runs the code in the braced
    area, replacing any occurrence of the `loopindex` with the first element of the
    `loopvector`. When the loop reaches the closing brace, the `loopindex` is incremented,
    taking on the second element of the `loopvector`, and the braced area is repeated.
    This continues until the loop reaches the final element of the `loopvector`, at
    which point the braced code is executed for the final time, and the loop exits.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`loopindex`是一个占位符，代表`loopvector`中的一个元素——它从向量中的第一个元素开始，并在每次循环重复时移动到下一个元素。当`for`循环开始时，它运行大括号区域中的代码，将`loopindex`的任何出现替换为`loopvector`中的第一个元素。当循环达到闭合大括号时，`loopindex`会增加，取`loopvector`中的第二个元素，并重复大括号中的区域。这个过程一直持续到循环到达`loopvector`的最后一个元素，此时大括号代码被执行最后一次，循环退出。
- en: 'Here’s a simple example written in the editor:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在编辑器中编写的简单示例：
- en: '[PRE53]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This loop prints the current value of the `loopindex` (which I’ve named `myitem`
    here) as it increments from 5 to 7\. Here’s the output after sending to the console:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环打印了`loopindex`（在这里我将其命名为`myitem`）的当前值，它从5递增到7。以下是将结果输出到控制台后的输出：
- en: '[PRE54]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can use loops to manipulate objects that exist outside the loop. Consider
    the following example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用循环来操作循环外部存在的对象。考虑以下示例：
- en: '[PRE55]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, I’ve initially defined an object, `counter`, and set it to zero in the
    workspace. Then, inside the loop, `counter` is overwritten by itself plus 1\.
    Each time the loop repeats, `counter` increases, and the current value is printed
    to the console.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我首先定义了一个对象`counter`，并在工作空间中将其设置为零。然后，在循环内部，`counter`被其自身加1所覆盖。每次循环重复时，`counter`增加，并将当前值打印到控制台。
- en: '**Looping via Index or Value**'
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**通过索引或值进行循环**'
- en: 'Note the difference between using the `loopindex` to directly represent elements
    in the `loopvector` and using it to represent *indexes* of a vector. The following
    two loops use these two different approaches to `print` double each number in
    `myvec`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`loopindex`直接表示`loopvector`中的元素与使用它表示向量的*索引*之间的区别。以下两个循环使用这两种不同的方法来`print`每个`myvec`中的数字的双倍：
- en: '[PRE56]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first loop uses the `loopindex` i to directly represent the elements in
    `myvec`, printing the value of each element times 2\. In the second loop, on the
    other hand, you use `i` to represent integers in the sequence `1:length(myvec)`.
    These integers form all the possible index positions of `myvec`, and you use these
    indexes to extract `myvec`’s elements (once again multiplying each element by
    2 and printing the result). Though it takes a slightly longer form, using vector
    index positions provides more flexibility in terms of how you can use the `loopindex`.
    This will become clearer when your needs demand more complicated `for` loops,
    such as in the next example.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个循环使用`loopindex` i直接表示`myvec`中的元素，打印每个元素乘以2的值。另一方面，在第二个循环中，你使用`i`表示`1:length(myvec)`中的整数。这些整数构成了`myvec`所有可能的索引位置，你可以使用这些索引来提取`myvec`的元素（再次将每个元素乘以2并打印结果）。虽然这种方式稍显冗长，但使用向量索引位置在你如何使用`loopindex`时提供了更多灵活性。当你需要更复杂的`for`循环时，这一点会更加清晰，正如下一个例子所展示的。
- en: 'Suppose you want to write some code that will inspect any list object and gather
    information about any matrix objects stored as members in the list. Consider the
    following list:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想编写一些代码，检查任何列表对象，并收集列表中作为成员存储的任何矩阵对象的信息。请考虑以下列表：
- en: '[PRE57]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here you’ve created `foo`, which contains three matrices of varying dimensions
    and data types. You’ll write a `for` loop that goes through each member of a list
    like this one and checks whether the member is a matrix. If it is, the loop will
    retrieve the number of rows and columns and the data type of the matrix.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建了`foo`，它包含三个不同维度和数据类型的矩阵。你将编写一个`for`循环，遍历像这样的列表的每个成员，并检查该成员是否为矩阵。如果是，循环将获取矩阵的行数、列数以及数据类型。
- en: 'Before you write the `for` loop, you should create some vectors that will store
    information about the list members: `name` for the list member names, `is.mat`
    to indicate whether each member is a matrix (with `"Yes"` or `"No"`), `nc` and
    `nr` to store the number of rows and columns for each matrix, and `data.type`
    to store the data type of each matrix.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here, you store the names of the members of `foo` as `name`. You also set up
    `is.mat`, `nr`, `nc`, and `data.type`, which are all assigned vectors of length
    `length(foo)` filled with `NA`s. These values will be updated as appropriate by
    your `for` loop, which you’re now ready to write. Enter the following code in
    the editor:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Initially, set up the `loopindex` i so that it will increment through the index
    positions of `foo` (the sequence `1:length(foo)`). In the braced code, the first
    command is to write the member of `foo` at position `i` to an object `member`.
    Next, you can check whether that member is a matrix using `is.matrix` (refer to
    [Section 6.2.3](ch06.xhtml#ch06lev2sec61)). If `TRUE`, you do the following: the
    `i`th position of `is.mat` vector is set as `"Yes"`; the `i`th element of `nr`
    and `nc` is set as the number of rows and number of columns of `member`, respectively;
    and the `i`th element of `data.type` is set as the result of `class(as.vector(member))`.
    This final command first coerces the matrix into a vector with `as.vector` and
    then uses the `class` function (covered in [Section 6.2.2](ch06.xhtml#ch06lev2sec60))
    to find the data type of the elements.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: If `member` isn’t a matrix and the `if` condition fails, the corresponding entry
    in `is.mat` is set to `"No"`, and the entries in the other vectors aren’t changed
    (so they will remain `NA`).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'After the loop is run, a data frame `bar` is created from the vectors (note
    the use of `stringsAsFactors=FALSE` in order to prevent the character string vectors
    in `bar` being automatically converted to factors; see [Section 5.2.1](ch05.xhtml#ch05lev2sec52)).
    After executing the code, `bar` looks like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see, this matches the nature of the matrices present in the list
    `foo`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '**Nesting for Loops**'
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can also nest `for` loops, just like `if` statements. When a `for` loop
    is nested in another `for` loop, the inner loop is executed in full before the
    outer loop `loopindex` is incremented, at which point the inner loop is executed
    all over again. Create the following objects in your R console:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following nested loop fills `foo` with the result of multiplying each integer
    in `loopvec1` by each integer in `loopvec2`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note that nested loops require a unique `loopindex` for each use of `for`. In
    this case, the `loopindex` is `i` for the outer loop and `j` for the inner loop.
    When the code is executed, `i` is first assigned `1`, the inner loop begins, and
    then `j` is also assigned `1`. The only command in the inner loop is to take the
    product of the `i`th element of `loopvec1` and the `j`th element of `loopvec2`
    and assign it to row `i`, column `j` of `foo`. The inner loop repeats until `j`
    reaches `length(loopvec2)` and fills the first row of `foo`; then `i` increments,
    and the inner loop is started up again. The entire procedure is complete after
    `i` reaches `length(loopvec1)` and the matrix is filled.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Inner `loopvector`s can even be defined to match the current value of the `loopindex`
    of the outer loop. Using `loopvec1` and `loopvec2` from earlier, here’s an example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here, the `i`th row, `j`th column element of `foo` is filled with the sum of
    `loopvec1[i]` and `loopvec2[j]`. However, the inner loop values for `j` are now
    decided based on the value of `i`. For example, when `i` is `1`, the inner `loopvector`
    is `1:1`, so the inner loop executes only once before returning to the outer loop.
    With `i` as `2`, the inner `loopvector` is then `1:2`, and so on. This makes it
    so each row of `foo` is only partially filled. Extra care must be taken when programming
    loops this way. Here, for example, the values for `j` depend on the length of
    `loopvec1`, so an error will occur if `length(loopvec1)` is greater than `length(loopvec2)`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Any number of `for` loops can be nested, but the computational expense can become
    a problem if nested loops are used unwisely. Loops in general add some computational
    cost, so to produce more efficient code in R, you should always ask “Can I do
    this in a vector-oriented fashion?” Only when the individual operations are not
    possible or straightforward to achieve en masse should you explore an iterative,
    looped approach. You can find some relevant and valuable comments on R loops and
    associated best-practice coding in the “R Help Desk” article by Ligges and Fox
    ([2008](ref.xhtml#ref41)).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.3**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: In the interests of efficient coding, rewrite the nested loop example from this
    section, where the matrix `foo` was filled with the multiples of the elements
    of `loopvec1` and `loopvec2`, using only a single `for` loop.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In [Section 10.1.5](ch10.xhtml#ch10lev2sec91), you used the command
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'to return a number based on the supplied value of a single character string.
    This line won’t work if `mystring` is a character vector. Write some code that
    will take a character vector and return a vector of the appropriate numeric values.
    Test it on the following vector:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Suppose you have a list named `mylist` that can contain other lists as members,
    but assume those “member lists” cannot themselves contain lists. Write nested
    loops that can search any possible `mylist` defined in this way and count how
    many matrices are present. Hint: Simply set up a counter before commencing the
    loops that is incremented each time a matrix is found, regardless of whether it
    is a straightforward member of `mylist` or it is a member of a member list of
    `mylist`.'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then confirm the following:'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'That the answer is 4 if you have the following:'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'That the answer is 0 if you have the following:'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'That the answer is 2 if you have the following:'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '***10.2.2 while Loops***'
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use `for` loops, you must know, or be able to easily calculate, the number
    of times the loop should repeat. In situations where you don’t know how many times
    the desired operations need to be run, you can turn to the `while` loop. A `while`
    loop runs and repeats while a specified condition returns `TRUE`, and takes the
    following general form:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: A `while` loop uses a single logical-valued `loopcondition` to control how many
    times it repeats. Upon execution, the `loopcondition` is evaluated. If the condition
    is found to be `TRUE`, the braced area code is executed line by line as usual
    until complete, at which point the `loopcondition` is checked again. The loop
    terminates only when the condition evaluates to `FALSE`, and it does so immediately—the
    braced code is *not* run one last time.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: This means the operations carried out in the braced area must somehow cause
    the loop to exit, either by affecting the `loopcondition` somehow or by declaring
    `break`, which you’ll see a little later. If not, the loop will keep repeating
    forever, creating an *infinite loop*, which will freeze the console (and, depending
    on the operations specified inside the braced area, R can crash because of memory
    constraints). If that occurs, you can terminate the loop in the R user interface
    by clicking the Stop button in the top menu or by pressing ESC.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'As a simple example of a `while` loop, consider the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here, you set a new object `myval` to `5`. Then you start a `while` loop with
    the condition `myval<10`. Since this is `TRUE` to begin with, you enter the braced
    area. Inside the loop you increment `myval` by 1, print its current value, and
    print the logical value of the condition `myval<5`. The loop continues until the
    condition `myval<10` is `FALSE` at the next evaluation. Execute the code chunk,
    and you see the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: As expected, the loop repeats until `myval` is set to `10`, at which point `myval<10`
    returns `FALSE`, causing the loop to exit because the initial condition is no
    longer `TRUE`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: In more complicated settings, it’s often useful to set the `loopcondition` to
    be a separate object so that you can modify it as necessary within the braced
    area. For the next example, you’ll use a `while` loop to iterate through an integer
    vector and create an identity matrix (see [Section 3.3.2](ch03.xhtml#ch03lev2sec30))
    with the dimension matching the current integer. This loop should stop when it
    reaches a number in the vector that’s greater than 5 or when it reaches the end
    of the integer vector.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的设置中，通常将 `loopcondition` 设置为一个独立的对象是非常有用的，这样你可以在大括号内根据需要修改它。在下一个示例中，你将使用
    `while` 循环迭代一个整数向量，并创建一个单位矩阵（参见 [第 3.3.2 节](ch03.xhtml#ch03lev2sec30)），其维度与当前整数匹配。这个循环应该在遇到向量中的一个大于
    5 的数字时停止，或者当它到达整数向量的末尾时停止。
- en: In the editor, define some initial objects, followed by the loop itself.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中，定义一些初始对象，然后是循环本身。
- en: '[PRE72]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The first object, `mylist`, will store all the matrices that the loop creates.
    You’ll use the vector `mynumbers` to provide the matrix sizes, and you’ll use
    `counter` and `mycondition` to control the loop.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个对象 `mylist` 将存储循环创建的所有矩阵。你将使用向量 `mynumbers` 提供矩阵的大小，并使用 `counter` 和 `mycondition`
    来控制循环。
- en: The `loopcondition`, `mycondition`, is initially set to `TRUE` since the first
    element of `mynumbers` is less than or equal to 5\. Inside the loop beginning
    at `while`, the first line uses double square brackets and the value of `counter`
    to dynamically create a new entry at that position in `mylist` (you did this earlier
    with named lists in [Section 5.1.3](ch05.xhtml#ch05lev2sec51)). This entry is
    assigned an identity matrix whose size matches the corresponding element of `mynumbers`.
    Next, the `counter` is incremented, and now you have to update `mycondition`.
    Here you want to check whether `mynumbers[counter]<=5`, but you also need to check
    whether you’ve reached the end of the integer vector (otherwise, you can end up
    with an error by trying to retrieve an index position outside the range of `mynumbers`).
    So, you can use an `if` statement to first check the condition `counter<=length(mynumbers)`.
    If `TRUE`, then set `mycondition` to the outcome of `mynumbers[counter]<=5`. If
    not, this means you’ve reached the end of `mynumbers`, so you make sure the loop
    exits by setting `mycondition <- FALSE`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`loopcondition`，即 `mycondition`，最初设置为 `TRUE`，因为 `mynumbers` 的第一个元素小于或等于 5。在从
    `while` 开始的循环内，第一行使用双重方括号和 `counter` 的值动态创建 `mylist` 中该位置的新条目（你之前在 [第 5.1.3 节](ch05.xhtml#ch05lev2sec51)
    中使用命名列表做过类似的操作）。该条目被分配一个单位矩阵，其大小与 `mynumbers` 中相应元素的大小匹配。接着，`counter` 增加，你需要更新
    `mycondition`。在这里，你要检查 `mynumbers[counter] <= 5`，但还需要检查是否已经到达整数向量的末尾（否则，试图访问 `mynumbers`
    范围外的索引位置会导致错误）。因此，可以使用 `if` 语句首先检查条件 `counter <= length(mynumbers)`。如果条件为 `TRUE`，则将
    `mycondition` 设置为 `mynumbers[counter] <= 5` 的结果。如果条件不成立，意味着你已到达 `mynumbers` 的末尾，因此需要通过设置
    `mycondition <- FALSE` 来确保循环退出。'
- en: 'Execute the loop with those predefined objects, and it will produce the `mylist`
    object shown here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用那些预定义的对象执行循环，它将生成如下所示的 `mylist` 对象：
- en: '[PRE73]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As expected, you have a list with four members—identity matrices of size 4 ×
    4, 5 × 5, 1 × 1, and 2 × 2—matching the first four elements of `mynumbers`. The
    loop stopped executing when it reached the fifth element of `mynumbers`(`6`) since
    that’s greater than 5.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，你有一个包含四个元素的列表——大小分别为 4 × 4、5 × 5、1 × 1 和 2 × 2 的单位矩阵——与 `mynumbers`
    的前四个元素相匹配。当循环执行到 `mynumbers` 的第五个元素（`6`）时停止，因为它大于 5。
- en: '**Exercise 10.4**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 10.4**'
- en: 'Based on the most recent example of storing identity matrices in a list, determine
    what the resulting `mylist` would look like for each of the following possible
    `mynumbers` vectors, without executing anything:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于最近一个将单位矩阵存储在列表中的示例，确定在不执行任何操作的情况下，对于以下每个可能的 `mynumbers` 向量，结果 `mylist` 会是什么样子：
- en: '`mynumbers <- c(2,2,2,2,5,2)`'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mynumbers <- c(2,2,2,2,5,2)`'
- en: '`mynumbers <- 2:20`'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mynumbers <- 2:20`'
- en: '`mynumbers <- c(10,1,10,1,2)`'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mynumbers <- c(10,1,10,1,2)`'
- en: Then, confirm your answers in R (note you’ll also have to reset the initial
    values of `mylist`, `counter`, and `mycondition` each time, just as in the text).
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，在 R 中确认你的答案（注意，每次你还需要像文本中所示的那样重置 `mylist`、`counter` 和 `mycondition` 的初始值）。
- en: 'For this problem, I’ll introduce the *factorial* operator. The factorial of
    a non-negative integer *x*, expressed as *x*!, refers to *x* multiplied by the
    product of all integers less than *x*, down to 1\. Formally, it is written like
    this:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个问题，我将介绍 *阶乘* 运算符。一个非负整数 *x* 的阶乘，表示为 *x*!，是 *x* 乘以所有小于 *x* 的整数的积，一直到 1。形式上，它可以这样表示：
- en: “*x* factorial” = *x*! = *x* × (*x* − 1) × (*x* − 2) × ... × 1
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that there is a special case of *zero factorial*, which is always 1\.
    That is:'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 0! = 1
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, to work out 3 factorial, you compute the following:'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 3 × 2 × 1 = 6
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To work out 7 factorial, you compute the following:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 7 × 6 × 5 × 4 × 3 × 2 × 1 = 5040
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write a `while` loop that computes and stores as a new object the factorial
    of any non-negative integer `mynum` by decrementing `mynum` by `1` at each repetition
    of the braced code.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using your loop, confirm the following:'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That the result of using `mynum <- 5` is `120`
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: That using `mynum <- 12` yields `479001600`
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: That having `mynum <- 0` correctly returns `1`
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider the following code, where the operations in the braced area of the
    `while` loop have been omitted:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Your task is to complete the code in the braced area so it inspects `mystring`
    character by character until it reaches the second instance of the letter *e*
    or the end of the string, whichever comes first. The `result` object should be
    the entire character string if there is no second *e* or the character string
    made up of all the characters up to, but not including, the second *e* if there
    is one. For example, `mystring <- "R fever"` should provide `result` as `"R fev"`.
    This must be achieved by following these operations in the braces:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use `substr` ([Section 4.2.4](ch04.xhtml#ch04lev2sec45)) to extract the single
    character of `mystring` at position `index`.
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a check for equality to determine whether this single-character string is
    either `"e"` OR `"E"`. If so, increase `ecount` by `1`.
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, perform a separate check to see whether `ecount` is equal to `2`. If so,
    use `substr` to set `result` equal to the characters between `1` and `index-1`
    inclusive.
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment `index` by `1`.
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test your code—ensure the previous `result` for `mystring <- "R fever"`. Furthermore,
    confirm the following:'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Using `mystring <- "beautiful"` provides `result` as `"beautiful"`
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Using `mystring <- "ECCENTRIC"` provides `result` as `"ECC"`
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Using `mystring <- "ElAbOrAte"` provides `result` as `"ElAbOrAt"`
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Using `mystring <- "eeeeek!"` provides `result` as `"e"`
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '***10.2.3 Implicit Looping with apply***'
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some situations, especially for relatively routine `for` loops (such as executing
    some function on each member of a list), you can avoid some of the details associated
    with explicit looping by using the `apply` function. The `apply` function is the
    most basic form of implicit looping—it takes a function and applies it to each
    *margin* of an array.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'For a simple illustrative example, let’s say you have the following matrix:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Say you want to find the sum of each row. If you call the following, you just
    get the grand total of all elements, which is not what you want.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Instead, you could use a `for` loop like this one:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This cycles through each row and stores the sum in `row.totals`. But you can
    use `apply` to get the same result in a more compact form. To call `apply`, you
    have to specify at least three arguments. The first argument, `X`, is the object
    you want to cycle through. The next argument, `MARGIN`, takes an integer that
    flags which margin of `X` to operate on (rows, columns, etc.). Finally, `FUN`
    provides the function you want to perform on each margin. With the following call,
    you get the same result as the earlier `for` loop.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `MARGIN` index follows the positional order of the dimension for matrices
    and arrays, as discussed in [Chapter 3](ch03.xhtml#ch03)—`1` always refers to
    rows, `2` to columns, `3` to layers, `4` to blocks, and so on. To instruct R to
    sum each column of `foo` instead, simply change the `MARGIN` argument to `2`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The operations supplied to `FUN` should be appropriate for the `MARGIN` selected.
    So, if you select rows or columns with `MARGIN=1` or `MARGIN=2`, make sure the
    `FUN` function is appropriate for vectors. Or if you have a three-dimensional
    array and use `apply` with `MARGIN=3`, be sure to set `FUN` to a function appropriate
    for matrices. Here’s an example for you to enter:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then, make the following call:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This extracts the diagonal elements of each of the matrix layers of `bar`. Each
    call to `diag` on a matrix returns a vector, and these vectors are returned as
    columns of a new matrix. The `FUN` argument can also be any appropriate user-defined
    function, and you’ll look at some examples of using `apply` with your own functions
    in [Chapter 11](ch11.xhtml#ch11).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '**Other apply Functions**'
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are different flavors of the basic `apply` function. The `tapply` function,
    for example, performs operations on subsets of the object of interest, where those
    subsets are defined in terms of one or more factor vectors. As an example, let’s
    return to the code from [Section 8.2.3](ch08.xhtml#ch08lev2sec75), which reads
    in a web-based data file on diamond pricing, sets appropriate variable names of
    the data frame, and displays the first five records.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'To add up the total value of the diamonds present for the full data set but
    separated according to `Color`, you can use `tapply` like this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This sums the relevant elements of the target vector `diamonds$Price`. The corresponding
    factor vector `diamonds$Color` is passed to `INDEX`, and the function of interest
    is specified with `FUN=sum` exactly as earlier.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Another particularly useful alternative is `lapply`, which can operate member
    by member on a list. In [Section 10.2.1](ch10.xhtml#ch10lev2sec92), recall you
    wrote a `for` loop to inspect matrices in the following list:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Using `lapply`, you can check for matrices in the list with a single short line
    of code.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Note that no margin or index information is required for `lapply`; R knows to
    apply `FUN` to each member of the specified list. The returned value is itself
    a list. Another variant, `sapply`, returns the same results as `lapply` but in
    an array form.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Here, the result is provided as a vector. In this example, `baz` has a `names`
    attribute that is copied to the corresponding entries of the returned object.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Other variants of `apply` include `vapply`, which is similar to `sapply` albeit
    with some relatively subtle differences, and `mapply`, which can operate on multiple
    vectors or lists at once. To learn more about `mapply`, see the `?mapply` help
    file; `vapply` and `sapply` are both covered in the `?lapply` help file.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'All of R’s `apply` functions allow for additional arguments to be passed to
    `FUN`; most of them do this via an ellipsis. For example, take another look at
    the matrix `foo`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Here you’ve applied `sort` to each row of the matrix and supplied the additional
    argument `decreasing=TRUE` to sort the rows from largest to smallest.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Some programmers prefer using the suite of `apply` functions wherever possible
    to improve the compactness and neatness of their code. However, note that these
    functions generally do not offer any substantial improvement in terms of computational
    speed or efficiency over an explicit loop (this is particularly the case with
    more recent versions of R). Plus, when you’re first learning the R language, explicit
    loops can be easier to read and follow since the operations are laid out clearly
    line by line.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.5**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Continuing on from the most recent example in the text, write an implicit loop
    that calculates the product of all the column elements of the matrix returned
    by the call to `apply(foo,1,sort,decreasing=TRUE)`.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Convert the following `for` loop to an implicit loop that does exactly the
    same thing:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In R, store the following 4 × 4 × 2 × 3 array as the object `qux`:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'That is, it is a four-dimensional array comprised of three blocks, with each
    block being an array made up of two layers of 4 × 4 matrices. Then, do the following:'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write an implicit loop that obtains the diagonal elements of all second-layer
    matrices only to produce the following matrix:'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Write an implicit loop that will return the `dim`ensions of each of the three
    matrices formed by accessing the fourth column of every matrix in `qux`, regardless
    of layer or block, wrapped by another implicit loop that finds the row sums of
    that returned structure, resulting simply in the following vector:'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '**10.3 Other Control Flow Mechanisms**'
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To round off this chapter, you’ll look at three more control flow mechanisms:
    `break`, `next`, and `repeat`. These mechanisms are often used in conjunction
    with the loops and `if` statements you’ve seen already.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '***10.3.1 Declaring break or next***'
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Normally a `for` loop will exit only when the `loopindex` exhausts the `loopvector`,
    and a `while` loop will exit only when the `loopcondition` evaluates to `FALSE`.
    But you can also preemptively terminate a loop by declaring `break`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you have a number, `foo`, that you want to divide by each element
    in a numeric vector `bar`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Furthermore, let’s say you want to divide `foo` by `bar` element by element
    but want to halt execution if one of the results evaluates to `Inf` (which will
    result if dividing by zero). To do this, you can check each iteration with the
    `is.finite` function ([Section 6.1.1](ch06.xhtml#ch06lev2sec55)), and you can
    issue a `break` command to terminate the loop if it returns `FALSE`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Here, the loop divides the numbers normally until it reaches the fifth element
    of `bar` and divides by zero, resulting in `Inf`. Upon the resulting conditional
    check, the loop ends immediately, leaving the remaining entries of `loop1.result`
    as they were originally set—`NA`s.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Invoking `break` is a fairly drastic move. Often, a programmer will include
    it only as a safety catch that’s meant to highlight or prevent unintended calculations.
    For more routine operations, it’s best to use another method. For instance, the
    example loop could easily be replicated as a `while` loop or the vector-oriented
    `ifelse` function, rather than relying on a `break`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of `break`ing and completely ending a loop, you can use `next` to simply
    advance to the next iteration and continue execution. Consider the following,
    where using `next` avoids division by zero:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: First, the loop checks to see whether the `i`th element of `bar` is zero. If
    it is, `next` is declared, and as a result, R ignores any subsequent lines of
    code in the braced area of the loop and returns to the top, automatically advancing
    to the next value of the `loopindex`. In the current example, the loop skips the
    fifth entry of `bar` (leaving the original `NA` value for that place) and continues
    through the rest of `bar`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you use either `break` or `next` in a nested loop, the command
    will apply only to the innermost loop. Only that inner loop will exit or advance
    to the next iteration, and any outer loops will continue as normal. For example,
    let’s return to the nested `for` loops from [Section 10.2.1](ch10.xhtml#ch10lev2sec92)
    that you used to fill a matrix with multiples of two vectors. This time you’ll
    use `next` in the inner loop to skip certain values.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The inner loop skips to the `next` iteration if the product of the current elements
    is greater than or equal to 54\. Note the effect applies *only to that innermost
    loop*—that is, only the `j loopindex` is preemptively incremented, while `i` is
    left untouched, and the outer loop continues normally.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: I’ve been using `for` loops to illustrate `next` and `break`, but they behave
    the same way inside `while` loops.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '***10.3.2 The repeat Statement***'
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another option for repeating a set of operations is the `repeat` statement.
    The general definition is simple.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Notice that a `repeat` statement doesn’t include any kind of `loopindex` or
    `loopcondition`. To stop repeating the code inside the braces, you must use a
    `break` declaration inside the braced area (usually within an `if` statement);
    without it, the braced code will repeat without end, creating an infinite loop.
    To avoid this, you must make sure the operations will at some point cause the
    loop to reach a `break`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'To see `repeat` in action, you’ll use it to calculate the famous mathematical
    series the *Fibonacci sequence*. The Fibonacci sequence is an infinite series
    of integers beginning with 1,1,2,3,5,8,13,. . . where each term in the series
    is determined by the sum of the two previous terms. Formally, if *F[n]* represents
    the *n*th Fibonacci number, then you have:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '| *F*[n][+][1] = *F[n]* + *F*[n][−][1]; | *n* = 2,3,4,5,. . . , |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: where
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '*F*[1] = *F[2]* = 1.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `repeat` statement computes and prints the Fibonacci sequence,
    ending when it reaches a term greater than 150:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: First, the sequence is initialized by storing the first two terms, both 1, as
    `fib.a` and `fib.b`. Then, the `repeat` statement is entered, and it uses `fib.a`
    and `fib.b` to compute the next term in the sequence, stored as `temp`. Next,
    `fib.a` is overwritten to be `fib.b`, and `fib.b` is overwritten to be `temp`
    so that the two variables move forward through the series. That is, `fib.b` becomes
    the newly calculated Fibonacci number, and `fib.a` becomes the second-to-last
    number in the series so far. Use of `cat` then prints the new value of `fib.b`
    to the console. Finally, a check is made to see whether the latest term is greater
    than 150, and if it is, `break` is declared.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: When you run the code, the braced area is repeated over and over until `fib.b`
    reaches the first number that is greater than 150, namely, 89 + 144 = 233\. Once
    that happens, the `if` statement condition evaluates as `TRUE`, and R runs into
    `break`, terminating the loop.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: The `repeat` statement is not as commonly used as the standard `while` or `for`
    loops, but it’s useful if you don’t want to be bound by formally specifying the
    `loopindex` and `loopvector` of a `for` loop or the `loopcondition` of a `while`
    loop. However, with `repeat`, you have to take a bit more caution to prevent infinite
    loops.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 10.6**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Using the same objects from [Section 10.3.1](ch10.xhtml#ch10lev2sec95),
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'do the following:'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write a `while` loop—*without* using `break` or `next`—that will reach exactly
    the same result as the `break` example in [Section 10.3.1](ch10.xhtml#ch10lev2sec95).
    That is, produce the same vector as `loop2.result` in the text.
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtain the same result as `loop3.result`, the example concerning `next`, using
    an `ifelse` function instead of a loop.
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To demonstrate `while` loops in [Section 10.2.2](ch10.xhtml#ch10lev2sec93),
    you used the vector
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: to progressively fill `mylist` with identity matrices whose dimensions matched
    the values in `mynumbers`. The loop was instructed to stop when it reached the
    end of the numeric vector or a number that was greater than 5.
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write a `for` loop using a `break` declaration that does the same thing.
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a `repeat` statement that does the same thing.
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Suppose you have two lists, `matlist1` and `matlist2`, both filled with numeric
    matrices as their members. Assume that all members have finite, nonmissing values,
    but *do not* assume that the dimensions of the matrices are the same throughout.
    Write a nested pair of `for` loops that aim to create a result list, `reslist`,
    of all possible *matrix products* (refer to [Section 3.3.5](ch03.xhtml#ch03lev2sec33))
    of the members of the two lists according to the following guidelines:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: – The `matlist1` object should be indexed/searched in the outer loop, and the
    `matlist2` object should be indexed/searched in the inner loop.
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – You’re interested only in the possible matrix products of the members of `matlist1`
    with the members of `matlist2` in that order.
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – If a particular multiple isn’t possible (that is, if the `ncol` of a member
    of `matlist1` doesn’t match the `nrow` of a member of `matlist2`), then you should
    skip that multiplication, store the string `"not possible"` at the relevant position
    in `reslist`, and proceed directly to the `next` matrix multiplication.
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – You can define a `counter` that is incremented at each comparison (inside
    the inner loop) to keep track of the current position of `reslist`.
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note, therefore, that the `length` of `reslist` will be equal to `length(matlist1)*length(matlist2)`.
    Now, confirm the following results:'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you have
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: then all members of `reslist` should be `"not possible"` apart from members
    `[[1]]` and `[[7]]`.
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: If you have
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: then only the `"not possible"` members of `reslist` should be `[[3]]`, `[[6]]`,
    and `[[9]]`.
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Important Code in This Chapter**'
  id: totrans-373
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
- en: '| `if( ){ }` | Conditional check | [Section 10.1.1](ch10.xhtml#ch10lev2sec87),
    [p. 180](ch10.xhtml#page_180) |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
- en: '| `if( ){ } else { }` | Check and alternative | [Section 10.1.2](ch10.xhtml#ch10lev2sec88),
    [p. 183](ch10.xhtml#page_183) |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
- en: '| `ifelse` | Element-wise `if-else` check | [Section 10.1.3](ch10.xhtml#ch10lev2sec89),
    [p. 185](ch10.xhtml#page_185) |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
- en: '| `switch` | Multiple `if` choices | [Section 10.1.5](ch10.xhtml#ch10lev2sec91),
    [p. 190](ch10.xhtml#page_190) |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
- en: '| `for( ){ }` | Iterative loop | [Section 10.2.1](ch10.xhtml#ch10lev2sec92),
    [p. 194](ch10.xhtml#page_194) |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
- en: '| `while( ){ }` | Conditional loop | [Section 10.2.2](ch10.xhtml#ch10lev2sec93),
    [p. 200](ch10.xhtml#page_200) |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
- en: '| `apply` | Implicit loop by margin | [Section 10.2.3](ch10.xhtml#ch10lev2sec94),
    [p. 205](ch10.xhtml#page_205) |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
- en: '| `tapply` | Implicit loop by factor | [Section 10.2.3](ch10.xhtml#ch10lev2sec94),
    [p. 207](ch10.xhtml#page_207) |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
- en: '| `lapply` | Implicit loop by member | [Section 10.2.3](ch10.xhtml#ch10lev2sec94),
    [p. 207](ch10.xhtml#page_207) |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
- en: '| `sapply` | As `lapply`, array returned | [Section 10.2.3](ch10.xhtml#ch10lev2sec94),
    [p. 207](ch10.xhtml#page_207) |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
- en: '| `break` | Exit explicit loop | [Section 10.3.1](ch10.xhtml#ch10lev2sec95),
    [p. 210](ch10.xhtml#page_210) |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
- en: '| `next` | Skip to next loop iteration | [Section 10.3.1](ch10.xhtml#ch10lev2sec95),
    [p. 210](ch10.xhtml#page_210) |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
- en: '| `repeat{ }` | Repeat code until `break` | [Section 10.3.2](ch10.xhtml#ch10lev2sec96),
    [p. 212](ch10.xhtml#page_212) |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
