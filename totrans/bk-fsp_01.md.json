["```\nnamespace TheBookOfFSharp\n```", "```\nnamespace TheBookOfFSharp.Chapter1\n```", "```\nnamespace global\n```", "```\n// Fully qualified name\nlet now = System.DateTime.Now\n\n// Imported namespace\nopen System\nlet today = DateTime.Now.Date\n```", "```\nmodule TheBookOfFSharp\n```", "```\nmodule OuterModule\n  module NestedModule =\n    do ()\n```", "```\nmodule TheBookOfFSharp.Chapter1.QualifiedModule\n```", "```\nopen TheBookOfFSharp.Chapter1.QualifiedModule\n```", "```\n[<AutoOpen>]\nmodule TheBookOfFSharp.Chapter1.QualifiedModule\n```", "```\n// C#\nvar testNumber = 10;\nstring evenOrOdd;\n\nif (testNumber % 2 == 0)\n      evenOrOdd = \"even\";\nelse\n      evenOrOdd = \"odd\";\n\nConsole.WriteLine(evenOrOdd);\n```", "```\n// F#\nlet testNumber = 10\nlet evenOrOdd = if testNumber % 2 = 0 then \"even\" else \"odd\"\nConsole.WriteLine evenOrOdd\n```", "```\n**[<EntryPoint>]**\nlet main argv =\n  // initialization code\n  0\n```", "```\nlet add x y = x + y\n```", "```\nmodule TheBookOfFSharp.RpnCalculator\n\nopen System\n\nlet evalRpnExpr (s : string) =\n  let solve items current =\n    match (current, items) with\n    | \"+\", y::x::t -> (x + y)::t\n    | \"-\", y::x::t -> (x - y)::t\n    | \"*\", y::x::t -> (x * y)::t\n    | \"/\", y::x::t -> (x / y)::t\n    | _ -> (float current)::items\n  (s.Split(' ') |> Seq.fold solve []).Head\n\n[<EntryPoint>]\nlet main argv =\n  [ \"4 2 5 * + 1 3 2 * + /\"\n    \"5 4 6 + /\"\n    \"10 4 3 + 2 * -\"\n    \"2 3 +\"\n    \"90 34 12 33 55 66 + * - + -\"\n    \"90 3 -\" ]\n  |> List.map (fun expr -> expr, evalRpnExpr expr)\n  |> List.iter (fun (expr, result) -> printfn \"(%s) = %A\" expr result)\n  Console.ReadLine() |> ignore\n  0\n```"]