- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command Line Arguments and Raw I/O
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, we explore how command line arguments allow the operating
    system to pass information to a program when the program is invoked. We also take
    a look at another feature that’s close to the operating system: the raw input/output
    (I/O) system. This system lets us precisely control how a program performs I/O.
    Done right, it can be a tremendous asset to a program.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the raw I/O system to perform a high-speed file copy. This program
    will also use command line arguments to specify the source and destination files,
    so we don’t need to hardcode them into the program.
  prefs: []
  type: TYPE_NORMAL
- en: Command Line Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Operating systems give the user the ability to provide a program with a number
    of command line options when the program is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'C passes in these arguments through two parameters, `argc` and `argv`, to `main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter, `argc`, contains the number of arguments. For historical
    reasons, it is an integer and not an unsigned integer. The second parameter, `argv`,
    is an array of strings representing the actual arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run a program with an invocation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'the `argv` and `argc` parameters will contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is the name of the program. The next argument is the `first`
    parameter on the command line, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-1](#listing15-1) contains a short program designed to print the
    command line arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '**echo.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-1: Printing command line arguments'
  prefs: []
  type: TYPE_NORMAL
- en: You don’t have to name the argument count `argc` and the argument vector `argv`,
    nor do you have to declare `argv` and `argc const`, but it’s conventional to do
    so.
  prefs: []
  type: TYPE_NORMAL
- en: Raw I/O
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The two major file I/O systems available to C programmers are *buffered I/O*
    and *unbuffered I/O*. The standard I/O system (`printf`), which we discussed in
    Chapter 14, uses buffers. In this chapter, we’ll work with unbuffered I/O. To
    show the differences between the two, let’s consider an example. Say you want
    to clean out your closet, and you have 500 old power cords to throw away. You
    could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Pick up a power cord.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Walk outside to the trash can.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Throw it away.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat 500 times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This method would be like using unbuffered I/O to get rid of the power cords.
    The *throughput* (speed at which you are doing the work) is terrible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a buffer—in this case, a garbage bag. The procedure now looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: Put a power cord in bag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep putting cords in the bag until it is full. (It holds 100 cords.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Walk outside to the trash can.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Throw the bag away.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat five times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Buffering makes the repetitive process more efficient, so when would you want
    to use unbuffered I/O? You would use it in cases where it would be more efficient
    to walk out to the trash can for each item. Say you had to throw away five refrigerators.
    You wouldn’t want to put five refrigerators in a trash bag and then throw them
    away. Instead, you’d throw away each one individually.
  prefs: []
  type: TYPE_NORMAL
- en: Using Raw I/O
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we wanted to copy a file, we could use the buffered I/O system to do it,
    but that would mean we would need to let the buffered I/O system choose the size
    of the buffer. Instead, we want to set our own buffer size. In this case, we know
    that a size of 1,024 bytes is optimal for the device we are using, so we create
    the program shown in [Listing 15-2](#listing15-2) to use raw I/O to copy a file
    using a 1,024-byte buffer.
  prefs: []
  type: TYPE_NORMAL
- en: '**copy.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-2: A program to copy one file to another using raw I/O'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the program in [Listing 15-2](#listing15-2), we must specify an input
    file and an output file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The program first checks to see that the proper number of arguments is supplied
    1. Next, it opens the input file 2. The general form of the `open` function is
    `file-descriptor` `= open(``filename``,` `flags``)`. The flags indicate how the
    file is to be opened. The `O_RDONLY` flag opens the file read-only, and the `O_BINARY`
    flag indicates that the file is binary. The `O_BINARY` flag is a funny one (I’ll
    explain it in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: The `open` command returns a number called a *file descriptor*. If there is
    an error, it returns a negative number, which means the next step in the program
    is to check for errors 3.
  prefs: []
  type: TYPE_NORMAL
- en: Then we open the output file using the `O_WRONLY` (write only) and `O_CREAT`
    (create the file if needed) flags 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'The additional `0666` parameter means that if the file is created, it’s in
    protection mode. It’s an octal number, with each digit representing a protection
    user set and each bit representing a protection type:'
  prefs: []
  type: TYPE_NORMAL
- en: 4 Read
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2 Write
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1 Execute
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The digits are in the following order: *<user>*, *<group>*, *<other>*. The
    `0666` parameter tells the system to create the file so that the user can read
    and write it (`6`), so that accounts in the same group as the user get read/write
    access (`6`), and so that anyone else gets the same read/write permission (`6`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the files are open, we do the copy 5. The `read` function has the general
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: where `fd` is the file descriptor, `buffer` is the buffer that receives the
    data, and `size` is the maximum number of characters read. The function returns
    the number of bytes read (`bytes read`), `0` to indicate the end of the file (EOF),
    or a negative number indicating an error.
  prefs: []
  type: TYPE_NORMAL
- en: After reading, we check for an error 6. Then we check to see whether we have
    reached the end of the file 7. If so, we’re done transferring data.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point we’re sure to have some data, so we write it 8. The `write` function
    has the general form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: where `fd` is the file descriptor, `buffer` is the buffer that has the data,
    and `size` is the number of characters to write. This function returns the number
    of bytes written or a negative number to indicate an error. Once the write is
    completed, we close the file descriptors 9.
  prefs: []
  type: TYPE_NORMAL
- en: Using Binary Mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, text files are not portable across operating systems because
    different operating systems use different characters to indicate the end of a
    line. C was originally written for Unix, which inspired Linux. Both operating
    systems use line feed (character number `0x0a`) as the line ending.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you open a text file with no `O_BINARY` flag and want to write to it. If
    you write out a string to a file using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'on Linux, you’ll get a file with three characters in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Other operating systems have to translate the end-of-line sequence into their
    native line ending. Table 14-1 lists the various line endings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 15-1: File Line Endings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **OS** | **Line ending** | **Characters** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Linux | Line feed | `\n` | None |'
  prefs: []
  type: TYPE_TB
- en: '| macOS | Carriage return | `\r` | Replace `\n` with `\r` on output |'
  prefs: []
  type: TYPE_TB
- en: '| Windows | Carriage return, line feed | `\r\n` | Insert `\r` before each `\n`
    |'
  prefs: []
  type: TYPE_TB
- en: 'If you are running a C program on Windows and execute this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'which is the same code as before, four characters are written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There will be times, however, when you’re writing a binary file and want byte
    `0a` to be written as `0a` without translation. On Linux, that’s easy, because
    Linux never does translation. However, other operating systems do, so they added
    a new `O_BINARY` flag to tell the library that a binary file is being used and
    to skip the file translation.
  prefs: []
  type: TYPE_NORMAL
- en: Linux does not have the `O_BINARY` flag since it makes no distinction between
    binary and text files. In fact, you can have a half-binary/half-text file. (I
    don’t know why you’d want to do that, but Linux will let you.)
  prefs: []
  type: TYPE_NORMAL
- en: I included the `O_BINARY` flag in [Listing 15-2](#listing15-2) because I wanted
    the copy program to be portable. We need to supply an `O_BINARY` mode when using
    Apple and Microsoft systems, but if we compile the program on a Linux system,
    `O_BINARY` is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the hack is to define it if it is not already defined by the operating
    system in the header files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If the operating system has an `O_BINARY` defined, the `#define` will not be
    compiled. If we are using a Linux-like operating system with no `O_BINARY`, `#define
    O_BINARY 0` will be compiled, and `O_BINARY` will be assigned the value of `0`,
    which does nothing—and doing nothing is exactly what we need on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: ioctl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to reading and writing, the raw I/O system provides a function
    called `ioctl` that performs I/O control. Its general form is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: where `fd` is the file descriptor, `request` is the device-specific control
    request, and `parameter` is the parameter to the request. For most requests, the
    function returns `0` if the request worked and a nonzero value otherwise (some
    `ioctl` calls return something different).
  prefs: []
  type: TYPE_NORMAL
- en: You can use `ioctl` to eject removable media, rewind or fast-forward tape drives,
    set the speed and other parameters of a serial device, and set the address information
    for a network device. Because the `ioctl` specification is open-ended, a lot of
    functionality has been crammed into this interface.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The raw I/O system provides the best control over what your I/O operations actually
    do. There is minimal editing or interference from the operating system, but this
    control comes with a price. The buffered I/O system helps limit your mistakes,
    whereas the raw I/O system does not. Still, if you know what you’re doing, it
    can be a tremendous asset.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write a program that takes one argument: the name of the person running the
    program. It then says `Hello` `<name>`. Here’s an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write a program that scans the argument list and, if `-d` is an argument, prints
    `Debug mode`. If the `-d` is missing, it prints `Release mode`. Add other options
    as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Time how long it takes the copy program in [Listing 15-2](#listing15-2) to
    copy a large file. Now change the buffer size to 1\. See how fast the program
    is. Change the buffer size to 16384\. See how fast it runs. Try 17000\. Note:
    almost every disk reads and writes in 512-byte blocks. How does this fact explain
    the timings you are seeing?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Research the `getopt` function and use it to parse the command line arguments
    you invented for problem 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
