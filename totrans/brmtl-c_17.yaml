- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command Line Arguments and Raw I/O
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, we explore how command line arguments allow the operating
    system to pass information to a program when the program is invoked. We also take
    a look at another feature that’s close to the operating system: the raw input/output
    (I/O) system. This system lets us precisely control how a program performs I/O.
    Done right, it can be a tremendous asset to a program.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the raw I/O system to perform a high-speed file copy. This program
    will also use command line arguments to specify the source and destination files,
    so we don’t need to hardcode them into the program.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Command Line Arguments
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Operating systems give the user the ability to provide a program with a number
    of command line options when the program is run:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'C passes in these arguments through two parameters, `argc` and `argv`, to `main`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first parameter, `argc`, contains the number of arguments. For historical
    reasons, it is an integer and not an unsigned integer. The second parameter, `argv`,
    is an array of strings representing the actual arguments.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run a program with an invocation like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'the `argv` and `argc` parameters will contain the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first argument is the name of the program. The next argument is the `first`
    parameter on the command line, and so on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-1](#listing15-1) contains a short program designed to print the
    command line arguments.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**echo.c**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 15-1: Printing command line arguments'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: You don’t have to name the argument count `argc` and the argument vector `argv`,
    nor do you have to declare `argv` and `argc const`, but it’s conventional to do
    so.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Raw I/O
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The two major file I/O systems available to C programmers are *buffered I/O*
    and *unbuffered I/O*. The standard I/O system (`printf`), which we discussed in
    Chapter 14, uses buffers. In this chapter, we’ll work with unbuffered I/O. To
    show the differences between the two, let’s consider an example. Say you want
    to clean out your closet, and you have 500 old power cords to throw away. You
    could do the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Pick up a power cord.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Walk outside to the trash can.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Throw it away.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat 500 times.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This method would be like using unbuffered I/O to get rid of the power cords.
    The *throughput* (speed at which you are doing the work) is terrible.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a buffer—in this case, a garbage bag. The procedure now looks like
    this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Put a power cord in bag.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep putting cords in the bag until it is full. (It holds 100 cords.)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Walk outside to the trash can.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Throw the bag away.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat five times.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Buffering makes the repetitive process more efficient, so when would you want
    to use unbuffered I/O? You would use it in cases where it would be more efficient
    to walk out to the trash can for each item. Say you had to throw away five refrigerators.
    You wouldn’t want to put five refrigerators in a trash bag and then throw them
    away. Instead, you’d throw away each one individually.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Using Raw I/O
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we wanted to copy a file, we could use the buffered I/O system to do it,
    but that would mean we would need to let the buffered I/O system choose the size
    of the buffer. Instead, we want to set our own buffer size. In this case, we know
    that a size of 1,024 bytes is optimal for the device we are using, so we create
    the program shown in [Listing 15-2](#listing15-2) to use raw I/O to copy a file
    using a 1,024-byte buffer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '**copy.c**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 15-2: A program to copy one file to another using raw I/O'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the program in [Listing 15-2](#listing15-2), we must specify an input
    file and an output file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The program first checks to see that the proper number of arguments is supplied
    1. Next, it opens the input file 2. The general form of the `open` function is
    `file-descriptor` `= open(``filename``,` `flags``)`. The flags indicate how the
    file is to be opened. The `O_RDONLY` flag opens the file read-only, and the `O_BINARY`
    flag indicates that the file is binary. The `O_BINARY` flag is a funny one (I’ll
    explain it in the next section).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The `open` command returns a number called a *file descriptor*. If there is
    an error, it returns a negative number, which means the next step in the program
    is to check for errors 3.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Then we open the output file using the `O_WRONLY` (write only) and `O_CREAT`
    (create the file if needed) flags 4.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'The additional `0666` parameter means that if the file is created, it’s in
    protection mode. It’s an octal number, with each digit representing a protection
    user set and each bit representing a protection type:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 4 Read
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2 Write
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1 Execute
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The digits are in the following order: *<user>*, *<group>*, *<other>*. The
    `0666` parameter tells the system to create the file so that the user can read
    and write it (`6`), so that accounts in the same group as the user get read/write
    access (`6`), and so that anyone else gets the same read/write permission (`6`).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the files are open, we do the copy 5. The `read` function has the general
    form:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: where `fd` is the file descriptor, `buffer` is the buffer that receives the
    data, and `size` is the maximum number of characters read. The function returns
    the number of bytes read (`bytes read`), `0` to indicate the end of the file (EOF),
    or a negative number indicating an error.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: After reading, we check for an error 6. Then we check to see whether we have
    reached the end of the file 7. If so, we’re done transferring data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point we’re sure to have some data, so we write it 8. The `write` function
    has the general form:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: where `fd` is the file descriptor, `buffer` is the buffer that has the data,
    and `size` is the number of characters to write. This function returns the number
    of bytes written or a negative number to indicate an error. Once the write is
    completed, we close the file descriptors 9.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Using Binary Mode
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, text files are not portable across operating systems because
    different operating systems use different characters to indicate the end of a
    line. C was originally written for Unix, which inspired Linux. Both operating
    systems use line feed (character number `0x0a`) as the line ending.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you open a text file with no `O_BINARY` flag and want to write to it. If
    you write out a string to a file using:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'on Linux, you’ll get a file with three characters in it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Other operating systems have to translate the end-of-line sequence into their
    native line ending. Table 14-1 lists the various line endings.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 15-1: File Line Endings'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '| **OS** | **Line ending** | **Characters** | **Translation** |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| Linux | Line feed | `\n` | None |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| macOS | Carriage return | `\r` | Replace `\n` with `\r` on output |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| Windows | Carriage return, line feed | `\r\n` | Insert `\r` before each `\n`
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: 'If you are running a C program on Windows and execute this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'which is the same code as before, four characters are written:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There will be times, however, when you’re writing a binary file and want byte
    `0a` to be written as `0a` without translation. On Linux, that’s easy, because
    Linux never does translation. However, other operating systems do, so they added
    a new `O_BINARY` flag to tell the library that a binary file is being used and
    to skip the file translation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Linux does not have the `O_BINARY` flag since it makes no distinction between
    binary and text files. In fact, you can have a half-binary/half-text file. (I
    don’t know why you’d want to do that, but Linux will let you.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: I included the `O_BINARY` flag in [Listing 15-2](#listing15-2) because I wanted
    the copy program to be portable. We need to supply an `O_BINARY` mode when using
    Apple and Microsoft systems, but if we compile the program on a Linux system,
    `O_BINARY` is undefined.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the hack is to define it if it is not already defined by the operating
    system in the header files:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the operating system has an `O_BINARY` defined, the `#define` will not be
    compiled. If we are using a Linux-like operating system with no `O_BINARY`, `#define
    O_BINARY 0` will be compiled, and `O_BINARY` will be assigned the value of `0`,
    which does nothing—and doing nothing is exactly what we need on Linux.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: ioctl
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to reading and writing, the raw I/O system provides a function
    called `ioctl` that performs I/O control. Its general form is:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: where `fd` is the file descriptor, `request` is the device-specific control
    request, and `parameter` is the parameter to the request. For most requests, the
    function returns `0` if the request worked and a nonzero value otherwise (some
    `ioctl` calls return something different).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: You can use `ioctl` to eject removable media, rewind or fast-forward tape drives,
    set the speed and other parameters of a serial device, and set the address information
    for a network device. Because the `ioctl` specification is open-ended, a lot of
    functionality has been crammed into this interface.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`ioctl`来弹出可移动媒体、倒带或快进磁带驱动器、设置串口设备的速度和其他参数，以及设置网络设备的地址信息。由于`ioctl`规范是开放式的，许多功能已经被压缩到这个接口中。
- en: Summary
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The raw I/O system provides the best control over what your I/O operations actually
    do. There is minimal editing or interference from the operating system, but this
    control comes with a price. The buffered I/O system helps limit your mistakes,
    whereas the raw I/O system does not. Still, if you know what you’re doing, it
    can be a tremendous asset.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 原始I/O系统提供了对I/O操作的最佳控制。操作系统的编辑或干预最小，但这种控制是有代价的。缓冲I/O系统有助于限制你的错误，而原始I/O系统则没有。不过，如果你知道自己在做什么，它可以成为一个巨大的资产。
- en: Programming Problems
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程问题
- en: 'Write a program that takes one argument: the name of the person running the
    program. It then says `Hello` `<name>`. Here’s an example:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，接受一个参数：运行该程序的人的名字。然后打印`Hello` `<name>`。例如：
- en: '[PRE15]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Write a program that scans the argument list and, if `-d` is an argument, prints
    `Debug mode`. If the `-d` is missing, it prints `Release mode`. Add other options
    as well.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，扫描参数列表，如果`-d`是一个参数，则打印`调试模式`。如果`-d`缺失，则打印`发布模式`。还可以添加其他选项。
- en: 'Time how long it takes the copy program in [Listing 15-2](#listing15-2) to
    copy a large file. Now change the buffer size to 1\. See how fast the program
    is. Change the buffer size to 16384\. See how fast it runs. Try 17000\. Note:
    almost every disk reads and writes in 512-byte blocks. How does this fact explain
    the timings you are seeing?'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量[列表 15-2](#listing15-2)中的复制程序复制大文件所花费的时间。现在将缓冲区大小更改为1。查看程序运行速度。将缓冲区大小更改为16384。查看程序运行速度。尝试17000。注意：几乎每个磁盘都是以512字节块进行读写的。这个事实如何解释你所看到的时间？
- en: Research the `getopt` function and use it to parse the command line arguments
    you invented for problem 1.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 研究`getopt`函数并使用它解析你为问题1发明的命令行参数。
