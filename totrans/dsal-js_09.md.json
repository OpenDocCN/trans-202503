["```\n❶ const bitmapSelect = (arr, k, from = 0, to = arr.length - 1) => {\n❷ const copy = arr.slice(from, to + 1);\n  const minKey = Math.min(...copy);\n  const maxKey = Math.max(...copy);\n\n  const bitmap = new Array(maxKey - minKey + 1).fill(false);\n  copy.forEach((v) => {\n    if (bitmap[v - minKey]) {\n      throw new Error(\"Cannot select... duplicate values\");\n    } else {\n      bitmap[v - minKey] = true;\n    }\n  });\n\n❸ **for (let i = minKey, j = from; i <= maxKey; i++) {**\n❹ **if (bitmap[i - minKey]) {**\n❺ **if (j === k) {**\n❻ **return i;**\n **}**\n❼ **j++;**\n **}**\n **}**\n};\n```", "```\n❶ const countingSelect = (arr, k, from = 0, to = arr.length - 1) => {\n❷ const copy = arr.slice(from, to + 1);\n  const minKey = Math.min(...copy);\n  const maxKey = Math.max(...copy);\n\n  const count = new Array(maxKey - minKey + 1).fill(0);\n  copy.forEach((v) => count[v - minKey]++);\n\n❸ **for (let i = minKey, j = from; i <= maxKey; i++) {**\n❹ **if (count[i - minKey]) {**\n❺ **j += count[i – minKey];**\n❻ **if (j > k) {**\n **return i;**\n **}**\n **}**\n **}**\n};\n```", "```\n❶ const sortingSelect = (arr, k, from = 0, to = arr.length - 1) => {\n❷ for (let i = from; i <= k; i++) {\n    let m = i;\n    for (let j = i + 1; j <= to; j++) {\n      if (arr[m] > arr[j]) {\n        m = j;\n      }\n    }\n    if (m !== i) {\n      [arr[i], arr[m]] = [arr[m], arr[i]];\n    }\n  }\n\n❸ return arr[k];\n};\n```", "```\n❶ const quickSelect = (arr, k, left = 0, right = arr.length - 1) => {\n  if (left < right) {\n **const pick = left + Math.floor((right + 1 - left) * Math.random());**\n **if (pick !== right) {**\n **[arr[pick], arr[right]] = [arr[right], arr[pick]];**\n **}**\n const pivot = arr[right];\n\n    let p = left;\n    for (let j = left; j < right; j++) {\n      if (pivot > arr[j]) {\n        [arr[p], arr[j]] = [arr[j], arr[p]];\n        p++;\n      }\n    }\n  ❷ [arr[p], arr[right]] = [arr[right], arr[p]];\n\n  ❸ if (p === k) {\n     return;\n  ❹} else if (p > k) {\n     return quickSelect(arr, k, left, p - 1);\n  ❺} else {\n     return quickSelect(arr, k, p + 1, right);\n   }\n }\n};\n```", "```\nconst qSelect = (arr, k, left = 0, right = arr.length - 1) => {\n❶ quickSelect(arr, k, left, right);\n❷ return arr[k];\n};\n```", "```\nconst quickSelect = (arr, k, left = 0, right = arr.length - 1) => {\n  if (left < right) {\n **let mom;**\n❶ **if (right - left < 5) {**\n **mom = simpleMedian(arr, left, right);**\n **} else {**\n❷ **let j = left – 1;**\n **for (let i = left; i <= right; i += 5) {**\n❸ **const med = simpleMedian(arr, i, Math.min(i + 4, right));**\n **j++;**\n❹ **[arr[j], arr[med]] = [arr[med], arr[j]];**\n **}**\n❺ **mom = Math.floor((left + j) / 2);**\n❻ **quickSelect(arr, mom, left, j);**\n **}**\n❼ **[arr[right], arr[mom]] = [arr[mom], arr[right]];**\n\n    const pivot = arr[right];\n\n    let p = left;\n    for (let j = left; j < right; j++) {\n      if (pivot > arr[j]) {\n        [arr[p], arr[j]] = [arr[j], arr[p]];\n        p++;\n      }\n    }\n    [arr[p], arr[right]] = [arr[right], arr[p]];\n\n    if (p === k) {\n      return;\n    } else if (p > k) {\n      return quickSelect(arr, k, left, p - 1);\n    } else {\n      return quickSelect(arr, k, p + 1, right);\n    }\n  }\n};\n```", "```\nconst simpleMedian = (arr, left, right) => {\n❶ insertionSort(arr, left, right);\n❷ return Math.floor((left + right) / 2);\n};\n```", "```\nconst simpleMedian = (arr, left, right) => {\n  insertionSort(arr, left, right);\n  return Math.floor((left + right) / 2);\n};\n\nconst quickSelect = (arr, k, left = 0, right = arr.length - 1) => {\n  if (left < right) {\n❶ **let mom;**\n❷ **if (right - left < 9) {**\n **mom = simpleMedian(arr, left, right);**\n **} else {**\n❸ **let j1 = left - 1;**\n❹ **for (let i = left; i <= right; i += 3) {**\n **const med = simpleMedian(arr, i, Math.min(i + 2, right));**\n **j1++;**\n **[arr[j1], arr[med]] = [arr[med], arr[j1]];**\n **}**\n\n❺ **let j2 = left - 1;**\n❻ **for (let i = left; i <= j1; i += 3) {**\n **const med = simpleMedian(arr, i, Math.min(i + 2, j1));**\n **j2++;**\n **[arr[j2], arr[med]] = [arr[med], arr[j2]];**\n **}**\n\n❼ **mom = Math.floor((left + j2) / 2);**\n **quickSelect(arr, mom, left, j2);**\n **}**\n❽ **[arr[right], arr[mom]] = [arr[mom], arr[right]];**\n\n    const pivot = arr[right];\n\n    let p = left;\n    for (let j = left; j < right; j++) {\n      if (pivot > arr[j]) {\n        [arr[p], arr[j]] = [arr[j], arr[p]];\n        p++;\n      }\n    }\n    [arr[p], arr[right]] = [arr[right], arr[p]];\n\n    if (p === k) {\n      return;\n    } else if (p > k) {\n      quickSelect(arr, k, left, p - 1);\n    } else {\n      quickSelect(arr, k, p + 1, right);\n    }\n  }\n};\n```", "```\n❶ const sort = require(\"../sorting/mergesort\");\n\nconst lazySelectMedian = (arr, left = 0, right = arr.length - 1) => {\n❷ const len = right - left + 1;\n❸ const sR = Math.floor(len ** 0.75);\n❹ const dIndex = Math.max(0, Math.floor(sR / 2 – Math.sqrt(len)));\n  const uIndex = Math.min(sR - 1, Math.ceil(sR / 2 + Math.sqrt(len)));\n❺ let dSize, uSize, m;\n  do {\n  ❻ const r = [];\n    for (let i = 0; i < sR; i++) {\n      r.push(arr[left + Math.floor((right - left) * Math.random())]);\n    }\n  ❼ sort(r);\n\n    dSize = uSize = 0;\n    m = [];\n    for (let i = left; i <= right; i++) {\n      if (r[dIndex] > arr[i]) {\n        dSize++;\n      } else if (arr[i] > r[uIndex]) {\n        uSize++;\n      } else {\n        m.push(arr[i]);\n      }\n    }\n❽} while (dSize > len / 2 || uSize > len / 2 || m.length > 4 * sR);\n\n❾ sort(m);\n  return m[Math.floor(len / 2) - dSize];\n};\n```"]