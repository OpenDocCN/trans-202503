- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_11">APPENDIX</samp> <samp class="SANS_Dogma_OT_Bold_B_11">THE
    FIFTH EDITION OF THE C STANDARD (C23)</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '*with Aaron Ballman*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: The latest (fifth) edition of the C standard (ISO/IEC 9899:2024) is nicknamed
    C23\. C23 maintains the *spirit of C*, while adding new features and functions
    to improve the safety, security, and capabilities of the language.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Attributes</samp>
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">[[attributes]]</samp> syntax
    was added to C23 to specify additional information for various source constructs
    such as types, objects, identifiers, or blocks (Ballman 2019). Prior to C23, similar
    features were provided in an implementation-defined (nonportable) manner:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Starting with C23, attributes can be specified as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Like C++, syntactic location determines apportionment. Attributes include <samp
    class="SANS_TheSansMonoCd_W5Regular_11">deprecated</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">fallthrough</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">maybe_unused</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">nodiscard</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsequenced</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">reproducible</samp>.
    The attribute syntax supports both standard attributes and vendor-specific attributes.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_c_attribute</samp> conditional
    inclusion operator can be used for feature testing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Keywords</samp>
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C language is often ridiculed for having ugly keywords. C typically defines
    new keywords using reserved identifiers that begin with an underscore character
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp>) followed by a capital
    letter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: C23 introduced more natural spellings for these keywords (Gustedt 2022). In
    Table A-1, C11 keywords using this convention are shown on the left, and the more
    natural spellings introduced in C23 are shown on the right.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table A-1:</samp> <samp class="SANS_Futura_Std_Book_11">Keyword
    Spellings</samp>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Value</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Type</samp>
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">_Bool</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">_Static_assert</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">_Thread_local</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">thread_local</samp> |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">_Alignof</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp>
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">_Alignas</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">alignas</samp>
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: Another update is the introduction of the <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp>
    constant. The well-worn <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>
    macro has a pointer type or maybe an integer type. It will implicitly convert
    to any scalar type, so it’s not particularly type safe. The <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp>
    constant has type <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr_t</samp>
    and will implicitly convert only to a pointer type, <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Integer Constant Expressions</samp>
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Integer constant expressions are not a portable construct; vendors can extend
    them. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">func</samp> may or may not be
    a variable-length array (VLA):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'C23 adds <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> variables
    (which imply the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> qualifier)
    when you really want something to be a constant (Gilding and Gustedt 2022a):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: C23 doesn’t support <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    functions yet, only objects. Structure members cannot be <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Enumeration Types</samp>
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C enumeration types seem normal through C17 but have some strange behaviors.
    For example, the underlying integer type is implementation defined and could be
    either a signed or unsigned integer type. C23 now allows the programmer to specify
    the underlying type for enumerations (Meneide and Pygott 2022):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also declare enumeration constants larger than <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Type Inference</samp>
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C23 enhanced the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    type specifier for single object definitions using type inference (Gilding and
    Gustedt 2022b). It’s basically the same idea as in C++, but <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    cannot appear in function signatures:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">typeof Operators</samp>'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: C23 adds support for <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp> operators.
    These are like <samp class="SANS_TheSansMonoCd_W5Regular_11">decltype</samp> in
    C++ and are used to specify a type based on another type or the type of an expression.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator retains
    qualifiers, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    strips qualifiers, including <samp class="SANS_TheSansMonoCd_W5Regular_11">_Atomic</samp>.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">K&R C Functions</samp>
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">K&R C 函数</samp>
- en: 'K&R C allowed functions to be declared without prototypes:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: K&R C 允许声明没有原型的函数：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'K&R C functions were deprecated 35 years ago and are finally being removed
    from the standard. All functions now have prototypes. An empty parameter list
    used to mean “takes any number of arguments” and now means “takes zero arguments,”
    the same as C++. It is possible to emulate “accepts zero or more args” via a variadic
    function signature: <samp class="SANS_TheSansMonoCd_W5Regular_11">int f(...);</samp>
    which is now possible because <samp class="SANS_TheSansMonoCd_W5Regular_11">va_start</samp>
    no longer requires passing the parameter before the <samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp>
    to the call.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: K&R C 函数在35年前已被弃用，并最终将从标准中移除。所有函数现在都有原型。空参数列表曾意味着“接受任意数量的参数”，现在意味着“接受零个参数”，与
    C++ 一致。通过变参函数签名可以模拟“接受零个或多个参数”的情况：<samp class="SANS_TheSansMonoCd_W5Regular_11">int
    f(...);</samp>，这现在是可能的，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">va_start</samp>
    不再要求在 <samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp> 前传递参数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Preprocessor</samp>
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">预处理器</samp>
- en: New features have been added to C23 to improve preprocessing. The <samp class="SANS_TheSansMonoCd_W5Regular_11">#elifdef</samp>
    directive complements <samp class="SANS_TheSansMonoCd_W5Regular_11">#ifdef</samp>
    and also has an <samp class="SANS_TheSansMonoCd_W5Regular_11">#elifndef</samp>
    form. The <samp class="SANS_TheSansMonoCd_W5Regular_11">#warning</samp> directive
    complements <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp> but does
    not halt translation. The <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp>
    operator tests for the existence of a header file, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_c_attribute</samp>
    operator tests for the existence of a standard or vendor attribute.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: C23新增了一些功能来改进预处理。<samp class="SANS_TheSansMonoCd_W5Regular_11">#elifdef</samp>
    指令是 <samp class="SANS_TheSansMonoCd_W5Regular_11">#ifdef</samp> 的补充，还包括 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">#elifndef</samp> 形式。<samp class="SANS_TheSansMonoCd_W5Regular_11">#warning</samp>
    指令是 <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp> 的补充，但不会停止翻译过程。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp> 操作符用于检测头文件的存在，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">__has_c_attribute</samp> 操作符用于检测标准或供应商属性的存在。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">#embed</samp> directive embeds
    external data directly into the source code via the preprocessor:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">#embed</samp> 指令通过预处理器将外部数据直接嵌入源代码中：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integer Types
    and Representations</samp>'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">整数类型与表示</samp>'
- en: Starting in C23, two’s complement is the only allowed integer representation
    (Bastien and Gustedt 2019). Signed integer overflow remains undefined behavior.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">int8_t</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">int16_t</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int32_t</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">int64_t</samp>
    types are now portably available everywhere. The <samp class="SANS_TheSansMonoCd_W5Regular_11">[u]intmax_t</samp>
    types are no longer maximal and are only required to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    long</samp> values, not extended or bit-precise integer values.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从C23开始，二进制补码是唯一允许的整数表示方式（Bastien 和 Gustedt 2019）。有符号整数溢出仍然是未定义行为。<samp class="SANS_TheSansMonoCd_W5Regular_11">int8_t</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int16_t</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">int32_t</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">int64_t</samp> 类型现在可以在所有平台上便捷使用。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">[u]intmax_t</samp> 类型不再是最大类型，仅要求表示 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long long</samp> 值，而非扩展或位精确的整数值。
- en: C23 also introduces bit-precise integer types (Blower et al. 2020). These are
    signed and unsigned types that allow you to specify the bit-width. These integers
    do not undergo integer promotions, so they remain the size you requested. Bit-width
    includes the sign bit, so <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(2)</samp>
    is the smallest signed bit-precise integer. <samp class="SANS_TheSansMonoCd_W5Regular_11">BITINT_MAXWIDTH</samp>
    specifies the maximum width of a bit-precise integer. It must be at least <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ULLONG_WIDTH</samp> but can be much larger
    (Clang supports > 2M bits).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'In C17, adding two nibbles required some bit twiddling:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is much simpler with <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp>:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'C23 also added binary literals. The integer literals 0b00101010101, 0x155,
    341, and 0525 all express the same value. You can also now use digit separators
    for improved readability, for example: <samp class="SANS_TheSansMonoCd_W5Regular_11">0b0000''1111''0000''1100</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0xF''0C</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">3''852</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">07''414</samp>.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'C23 finally has checked integer operations that will detect overflow and wraparound
    in addition, subtraction, and multiplication operations (Svoboda 2021):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Division is not supported, and it only works with integer types other than plain
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>,
    or bit-precise integers. <samp class="SANS_TheSansMonoCd_W5Regular_11">Type1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Type2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Type3</samp>
    can be different types. These functions return <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>
    if the mathematical result of the operation can be represented by <samp class="SANS_TheSansMonoCd_W5Regular_11">Type1</samp>;
    otherwise, they return <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.
    These functions make it easier to comply with the CERT C Coding Standard and MISRA
    C guidelines, but it is still awkward to compose operations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">unreachable Function-Like Macro</samp>
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">unreachable</samp> function-like
    macro is provided in <samp class="SANS_TheSansMonoCd_W5Regular_11"><stddef.h></samp>.
    It expands to a void expression; reaching the expression during execution is undefined
    behavior. This allows you to give hints to the optimizer about flow control that
    is impossible to reach (Gustedt 2021).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'As with anything you tell the optimizer to assume, use it with caution, because
    the optimizer will believe you even if you’re wrong. The following is a typical
    example of how <samp class="SANS_TheSansMonoCd_W5Regular_11">unreachable</samp>
    might be used in practice:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bit and Byte Utilities</samp>
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Bold_B_11">位与字节工具</samp>  '
- en: 'C23 introduces a collection of bit and byte utilities in the <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdbit.h></samp>
    header (Meneide 2023). These include functions to:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'C23在<samp class="SANS_TheSansMonoCd_W5Regular_11"><stdbit.h></samp>头文件中引入了一组位和字节工具（Meneide
    2023）。这些包括以下函数：  '
- en: Count the number of 1s or 0s in a bit pattern
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算位模式中1或0的数量
- en: Count the number of leading or trailing 1s or 0s
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '计算领先或尾随的1或0的数量  '
- en: Find the first leading or trailing 1 or 0
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '查找第一个领先或尾随的1或0  '
- en: Test whether a single bit is set
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '测试是否设置了单个比特位  '
- en: Determine the smallest number of bits required to represent a value
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '确定表示一个值所需的最小比特数  '
- en: Determine the next smallest or largest power of two based on a value
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '根据一个值确定下一个最小或最大二的幂  '
- en: 'For example, the following code can be used to count the number of consecutive
    0 bits in a value, starting from the most significant bit:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，以下代码可以用于统计值中连续0的位数，从最高有效位开始：  '
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Prior to C23, this operation is considerably more involved:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '在C23之前，这个操作要复杂得多：  '
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <samp class="SANS_Futura_Std_Bold_B_11">IEEE Floating-Point Support</samp>
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Bold_B_11">IEEE 浮动点支持</samp>  '
- en: 'C23 updates IEEE floating-point support by integrating TS 18661-1, 2, and 3
    (ISO/IEC TS 18661-1 2014, ISO/IEC TS 18661-2 2015, ISO/IEC TS 18661-3 2015). Annex
    F now has parity with the IEEE standard for floating-point arithmetic (IEEE 754-2019).
    Annex F also applies to decimal floats: <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal32</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal64</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal128</samp>.
    You cannot mix decimal operations with binary, complex, or imaginary floats, however.
    Annex H (previously the language-independent arithmetic annex) supports interchange,
    extended floating types, and nonarithmetic interchange formats. It allows for
    binary16, graphics processing unit (GPU) data, binary, or decimal representations.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: C23通过集成TS 18661-1、2和3（ISO/IEC TS 18661-1 2014，ISO/IEC TS 18661-2 2015，ISO/IEC
    TS 18661-3 2015）更新了IEEE浮动点支持。附录F现在与IEEE浮动点运算标准（IEEE 754-2019）保持一致。附录F还适用于十进制浮动点：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">_Decimal32</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal64</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">_Decimal128</samp>。但是，十进制运算不能与二进制、复数或虚数浮动点混合使用。附录H（之前是与语言无关的算术附录）支持交换、扩展浮动类型和非算术交换格式。它允许使用binary16、图形处理单元（GPU）数据、二进制或十进制表示。
- en: Math library changes support <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp>
    operations on <samp class="SANS_TheSansMonoCd_W5Regular_11">_DecimalN</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_FloatN</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">_FloatNx</samp>
    types. Special variants of exponents, logarithms, powers, and π-based trig functions;
    improved functions for min/max, total ordering, and testing for numerical properties;
    and functions allowing fine-grained control of conversions between floating-point
    values and integers or strings have been added.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 数学库更改支持对<samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp>操作于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">_DecimalN</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">_FloatN</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">_FloatNx</samp>类型的支持。增加了对指数、对数、幂运算以及基于π的三角函数的特殊变体；对最小值/最大值、总排序和数值属性测试的改进函数；以及支持在浮动点值与整数或字符串之间的转换进行精细控制的函数。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_explicit</samp> function
    has been added for when you really need to clear memory. It’s the same as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>, except the optimizer cannot
    remove a call to it. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> functions have
    been adopted from POSIX.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 已新增<samp class="SANS_TheSansMonoCd_W5Regular_11">memset_explicit</samp>函数，适用于你真的需要清除内存的情况。它与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>相同，但优化器无法删除对它的调用。<samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp>函数已从POSIX中采纳。
