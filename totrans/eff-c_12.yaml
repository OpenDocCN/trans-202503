- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_11">APPENDIX</samp> <samp class="SANS_Dogma_OT_Bold_B_11">THE
    FIFTH EDITION OF THE C STANDARD (C23)</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '*with Aaron Ballman*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The latest (fifth) edition of the C standard (ISO/IEC 9899:2024) is nicknamed
    C23\. C23 maintains the *spirit of C*, while adding new features and functions
    to improve the safety, security, and capabilities of the language.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Attributes</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">[[attributes]]</samp> syntax
    was added to C23 to specify additional information for various source constructs
    such as types, objects, identifiers, or blocks (Ballman 2019). Prior to C23, similar
    features were provided in an implementation-defined (nonportable) manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with C23, attributes can be specified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Like C++, syntactic location determines apportionment. Attributes include <samp
    class="SANS_TheSansMonoCd_W5Regular_11">deprecated</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">fallthrough</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">maybe_unused</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">nodiscard</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsequenced</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">reproducible</samp>.
    The attribute syntax supports both standard attributes and vendor-specific attributes.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_c_attribute</samp> conditional
    inclusion operator can be used for feature testing.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Keywords</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C language is often ridiculed for having ugly keywords. C typically defines
    new keywords using reserved identifiers that begin with an underscore character
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp>) followed by a capital
    letter.
  prefs: []
  type: TYPE_NORMAL
- en: C23 introduced more natural spellings for these keywords (Gustedt 2022). In
    Table A-1, C11 keywords using this convention are shown on the left, and the more
    natural spellings introduced in C23 are shown on the right.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table A-1:</samp> <samp class="SANS_Futura_Std_Book_11">Keyword
    Spellings</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Value</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Type</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">_Bool</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">_Static_assert</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">_Thread_local</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">thread_local</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">_Alignof</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">_Alignas</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">alignas</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Another update is the introduction of the <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp>
    constant. The well-worn <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>
    macro has a pointer type or maybe an integer type. It will implicitly convert
    to any scalar type, so it’s not particularly type safe. The <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp>
    constant has type <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr_t</samp>
    and will implicitly convert only to a pointer type, <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Integer Constant Expressions</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Integer constant expressions are not a portable construct; vendors can extend
    them. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">func</samp> may or may not be
    a variable-length array (VLA):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'C23 adds <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> variables
    (which imply the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> qualifier)
    when you really want something to be a constant (Gilding and Gustedt 2022a):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: C23 doesn’t support <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    functions yet, only objects. Structure members cannot be <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Enumeration Types</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C enumeration types seem normal through C17 but have some strange behaviors.
    For example, the underlying integer type is implementation defined and could be
    either a signed or unsigned integer type. C23 now allows the programmer to specify
    the underlying type for enumerations (Meneide and Pygott 2022):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also declare enumeration constants larger than <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_B_11">Type Inference</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C23 enhanced the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    type specifier for single object definitions using type inference (Gilding and
    Gustedt 2022b). It’s basically the same idea as in C++, but <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    cannot appear in function signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">typeof Operators</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: C23 adds support for <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp> operators.
    These are like <samp class="SANS_TheSansMonoCd_W5Regular_11">decltype</samp> in
    C++ and are used to specify a type based on another type or the type of an expression.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator retains
    qualifiers, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    strips qualifiers, including <samp class="SANS_TheSansMonoCd_W5Regular_11">_Atomic</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">K&R C Functions</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'K&R C allowed functions to be declared without prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'K&R C functions were deprecated 35 years ago and are finally being removed
    from the standard. All functions now have prototypes. An empty parameter list
    used to mean “takes any number of arguments” and now means “takes zero arguments,”
    the same as C++. It is possible to emulate “accepts zero or more args” via a variadic
    function signature: <samp class="SANS_TheSansMonoCd_W5Regular_11">int f(...);</samp>
    which is now possible because <samp class="SANS_TheSansMonoCd_W5Regular_11">va_start</samp>
    no longer requires passing the parameter before the <samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp>
    to the call.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Preprocessor</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: New features have been added to C23 to improve preprocessing. The <samp class="SANS_TheSansMonoCd_W5Regular_11">#elifdef</samp>
    directive complements <samp class="SANS_TheSansMonoCd_W5Regular_11">#ifdef</samp>
    and also has an <samp class="SANS_TheSansMonoCd_W5Regular_11">#elifndef</samp>
    form. The <samp class="SANS_TheSansMonoCd_W5Regular_11">#warning</samp> directive
    complements <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp> but does
    not halt translation. The <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp>
    operator tests for the existence of a header file, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_c_attribute</samp>
    operator tests for the existence of a standard or vendor attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">#embed</samp> directive embeds
    external data directly into the source code via the preprocessor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integer Types
    and Representations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Starting in C23, two’s complement is the only allowed integer representation
    (Bastien and Gustedt 2019). Signed integer overflow remains undefined behavior.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">int8_t</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">int16_t</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int32_t</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">int64_t</samp>
    types are now portably available everywhere. The <samp class="SANS_TheSansMonoCd_W5Regular_11">[u]intmax_t</samp>
    types are no longer maximal and are only required to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    long</samp> values, not extended or bit-precise integer values.
  prefs: []
  type: TYPE_NORMAL
- en: C23 also introduces bit-precise integer types (Blower et al. 2020). These are
    signed and unsigned types that allow you to specify the bit-width. These integers
    do not undergo integer promotions, so they remain the size you requested. Bit-width
    includes the sign bit, so <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(2)</samp>
    is the smallest signed bit-precise integer. <samp class="SANS_TheSansMonoCd_W5Regular_11">BITINT_MAXWIDTH</samp>
    specifies the maximum width of a bit-precise integer. It must be at least <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ULLONG_WIDTH</samp> but can be much larger
    (Clang supports > 2M bits).
  prefs: []
  type: TYPE_NORMAL
- en: 'In C17, adding two nibbles required some bit twiddling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is much simpler with <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'C23 also added binary literals. The integer literals 0b00101010101, 0x155,
    341, and 0525 all express the same value. You can also now use digit separators
    for improved readability, for example: <samp class="SANS_TheSansMonoCd_W5Regular_11">0b0000''1111''0000''1100</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0xF''0C</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">3''852</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">07''414</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: 'C23 finally has checked integer operations that will detect overflow and wraparound
    in addition, subtraction, and multiplication operations (Svoboda 2021):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Division is not supported, and it only works with integer types other than plain
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>,
    or bit-precise integers. <samp class="SANS_TheSansMonoCd_W5Regular_11">Type1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Type2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Type3</samp>
    can be different types. These functions return <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>
    if the mathematical result of the operation can be represented by <samp class="SANS_TheSansMonoCd_W5Regular_11">Type1</samp>;
    otherwise, they return <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.
    These functions make it easier to comply with the CERT C Coding Standard and MISRA
    C guidelines, but it is still awkward to compose operations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">unreachable Function-Like Macro</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">unreachable</samp> function-like
    macro is provided in <samp class="SANS_TheSansMonoCd_W5Regular_11"><stddef.h></samp>.
    It expands to a void expression; reaching the expression during execution is undefined
    behavior. This allows you to give hints to the optimizer about flow control that
    is impossible to reach (Gustedt 2021).
  prefs: []
  type: TYPE_NORMAL
- en: 'As with anything you tell the optimizer to assume, use it with caution, because
    the optimizer will believe you even if you’re wrong. The following is a typical
    example of how <samp class="SANS_TheSansMonoCd_W5Regular_11">unreachable</samp>
    might be used in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bit and Byte Utilities</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C23 introduces a collection of bit and byte utilities in the <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdbit.h></samp>
    header (Meneide 2023). These include functions to:'
  prefs: []
  type: TYPE_NORMAL
- en: Count the number of 1s or 0s in a bit pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Count the number of leading or trailing 1s or 0s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the first leading or trailing 1 or 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test whether a single bit is set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine the smallest number of bits required to represent a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine the next smallest or largest power of two based on a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following code can be used to count the number of consecutive
    0 bits in a value, starting from the most significant bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Prior to C23, this operation is considerably more involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_B_11">IEEE Floating-Point Support</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C23 updates IEEE floating-point support by integrating TS 18661-1, 2, and 3
    (ISO/IEC TS 18661-1 2014, ISO/IEC TS 18661-2 2015, ISO/IEC TS 18661-3 2015). Annex
    F now has parity with the IEEE standard for floating-point arithmetic (IEEE 754-2019).
    Annex F also applies to decimal floats: <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal32</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal64</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal128</samp>.
    You cannot mix decimal operations with binary, complex, or imaginary floats, however.
    Annex H (previously the language-independent arithmetic annex) supports interchange,
    extended floating types, and nonarithmetic interchange formats. It allows for
    binary16, graphics processing unit (GPU) data, binary, or decimal representations.'
  prefs: []
  type: TYPE_NORMAL
- en: Math library changes support <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp>
    operations on <samp class="SANS_TheSansMonoCd_W5Regular_11">_DecimalN</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_FloatN</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">_FloatNx</samp>
    types. Special variants of exponents, logarithms, powers, and π-based trig functions;
    improved functions for min/max, total ordering, and testing for numerical properties;
    and functions allowing fine-grained control of conversions between floating-point
    values and integers or strings have been added.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_explicit</samp> function
    has been added for when you really need to clear memory. It’s the same as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>, except the optimizer cannot
    remove a call to it. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> functions have
    been adopted from POSIX.
  prefs: []
  type: TYPE_NORMAL
