- en: Chapter 2. PF Configuration Basics
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 2 章：PF 配置基础
- en: '![PF Configuration Basics](httpatomoreillycomsourcenostarchimages2127149.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![PF 配置基础](httpatomoreillycomsourcenostarchimages2127149.png.jpg)'
- en: 'In this chapter, we’ll create a very simple setup with PF. We’ll begin with
    the simplest configuration possible: a single machine configured to communicate
    with a single network. This network could very well be the Internet.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个非常简单的 PF 配置。我们将从最简单的配置开始：一台配置为与单一网络通信的机器。这个网络很可能就是互联网。
- en: Your two main tools for configuring PF are your favorite text editor and the
    `pfctl` command-line administration tool. PF configurations, usually stored in
    */etc/pf.conf*, are called *rule sets* because each line in the configuration
    file is a *rule* that helps determine what the packet-filtering subsystem should
    do with the network traffic it sees. In ordinary, day-to-day administration, you
    edit your configuration in the */etc/pf*.*conf* file and then load your changes
    using `pfctl`. There are Web interfaces for PF administration tasks, but they’re
    not part of the base system. The PF developers aren’t hostile toward these options,
    but they’ve yet to see a graphical interface for configuring PF that’s clearly
    preferable to editing *pf.conf* and using `pfctl` commands.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 PF 的两大工具是你最喜欢的文本编辑器和 `pfctl` 命令行管理工具。PF 配置文件通常存储在 */etc/pf.conf* 中，称为 *规则集*，因为配置文件中的每一行都是一个
    *规则*，帮助确定数据包过滤子系统应该如何处理它看到的网络流量。在日常管理中，你编辑 */etc/pf*.*conf* 文件中的配置，然后使用 `pfctl`
    加载更改。虽然有 Web 界面可用于 PF 管理任务，但它们并不是系统的基础部分。PF 的开发者对这些选项并不排斥，但他们至今尚未见到一个显著优于编辑 *pf.conf*
    文件并使用 `pfctl` 命令的图形界面。
- en: 'The First Step: Enabling PF'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一步：启用 PF
- en: 'Before you can get started on the fun parts of shaping your network with PF
    and related tools, you need to make sure that PF is available and enabled. The
    details depend on your specific operating system: OpenBSD, FreeBSD, or NetBSD.
    Check your setup by following the instructions for your operating system and then
    move on to [A Simple PF Rule Set: A Single, Stand-Alone Machine](ch02.html#simple_pf_rule_set_a_singlecomma_stand-a
    "A Simple PF Rule Set: A Single, Stand-Alone Machine").'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '在你开始使用 PF 和相关工具进行网络配置的有趣部分之前，你需要确保 PF 可用并已启用。具体的操作细节取决于你使用的操作系统：OpenBSD、FreeBSD
    或 NetBSD。根据你的操作系统，按照相应的说明检查设置，然后继续阅读 [简单的 PF 规则集：单一独立机器](ch02.html#simple_pf_rule_set_a_singlecomma_stand-a
    "A Simple PF Rule Set: A Single, Stand-Alone Machine")。'
- en: The `pfctl` command is a program that requires higher privilege than the default
    for ordinary users. In the rest of this book, you’ll see commands that require
    extra privilege prefixed with `sudo`. If you haven’t started using `sudo` yet,
    you should. `sudo` is in the base system on OpenBSD. On FreeBSD, DragonFly BSD,
    and NetBSD, it’s within easy reach via the ports system or pkgsrc system, respectively,
    as *security/sudo*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`pfctl` 命令是一个需要比普通用户默认权限更高的程序。在本书的其余部分，你将看到需要额外权限的命令，这些命令前面会加上 `sudo`。如果你还没有开始使用
    `sudo`，应该开始使用它。OpenBSD 系统中自带了 `sudo`。在 FreeBSD、DragonFly BSD 和 NetBSD 中，也可以通过端口系统或
    pkgsrc 系统轻松获取，并作为 *security/sudo* 提供。'
- en: 'Here are a couple general notes regarding using `pfctl`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于使用 `pfctl` 的一般说明：
- en: The command to disable PF is `pfctl -d`. Once you’ve entered that command, all
    PF-based filtering that may have been in place will be disabled, and all traffic
    will be allowed to pass.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用 PF 的命令是 `pfctl -d`。输入该命令后，所有可能已启用的基于 PF 的过滤规则将被禁用，所有流量将被允许通过。
- en: 'For convenience, `pfctl` can handle several operations on a single command
    line. To enable PF and load the rule set in a single command, enter the following:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了方便，`pfctl` 可以在单行命令中执行多个操作。要启用 PF 并加载规则集，可以输入以下命令：
- en: '[PRE0]'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Setting Up PF on OpenBSD
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 OpenBSD 上设置 PF
- en: In OpenBSD 4.6 and later, you don’t need to enable PF because it’s enabled by
    default with a minimal configuration in place.^([[9](#ftn.ch02fn01)]) If you were
    watching the system console closely while the system was starting up, you may
    have noticed the `pf enabled` message appear soon after the kernel messages completed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenBSD 4.6 及之后的版本中，你无需手动启用 PF，因为它默认启用并且已有基本配置。如果你在系统启动时密切关注系统控制台，可能会注意到在内核消息完成后不久，`pf
    enabled` 消息就会出现。
- en: 'If you didn’t see the `pf enabled` message on the console at startup, you have
    several options to check that PF is indeed enabled. One simple way to check is
    to enter the command you would otherwise use to enable PF from the command line:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在启动时没有在控制台看到 `pf enabled` 消息，你有几个选项可以检查 PF 是否已经启用。一种简单的方法是输入你通常用来从命令行启用 PF
    的命令：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If PF is already enabled, the system responds with this message:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 PF 已经启用，系统会返回以下消息：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If PF isn’t enabled, the `pfctl -e` command will enable PF and display this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 PF 没有启用，`pfctl -e` 命令会启用 PF 并显示如下信息：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In versions prior to OpenBSD 4.6, PF wasn’t enabled by default. You can override
    the default by editing your */etc/rc.conf.local* file (or creating the file, if
    it doesn’t exist). Although it isn’t necessary on recent OpenBSD versions, it
    doesn’t hurt to add this line to your */etc/rc.conf.local* file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenBSD 4.6 版本之前，PF 默认并未启用。你可以通过编辑 */etc/rc.conf.local* 文件（如果该文件不存在，可以创建该文件）来覆盖默认设置。虽然在较新的
    OpenBSD 版本中不再需要这么做，但在你的 */etc/rc.conf.local* 文件中添加这一行并不会有害：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you take a look at the */etc/pf.conf* file in a fresh OpenBSD installation,
    you get your first exposure to a working rule set.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看在全新 OpenBSD 安装中的 */etc/pf.conf* 文件，你会第一次接触到一个有效的规则集。
- en: The default OpenBSD *pf.conf* file starts off with a `set skip on lo` rule to
    make sure traffic on the loopback interface group isn’t filtered in any way. The
    next active line is a simple `pass` default to let your network traffic pass by
    default. Finally, an explicit `block` rule blocks remote X11 traffic to your machine.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 OpenBSD *pf.conf* 文件从 `set skip on lo` 规则开始，确保环回接口组上的流量不会受到任何过滤。接下来的有效行是一个简单的
    `pass` 默认规则，允许网络流量默认通过。最后，一个显式的 `block` 规则阻止远程的 X11 流量访问你的机器。
- en: As you probably noticed, the default *pf.conf* file also contains a few comment
    lines starting with a hash mark (`#`). In those comments, you’ll find suggested
    rules that hint at useful configurations, such as FTP passthrough via `ftp-proxy`
    (see [Chapter 3](ch03.html "Chapter 3. Into the Real World")) and `spamd`, the
    OpenBSD spam-deferral daemon (see [Chapter 6](ch06.html "Chapter 6. Turning the
    Tables for Proactive Defense")). These items are potentially useful in various
    real-world scenarios, but because they may not be relevant in all configurations,
    they are commented out in the file by default.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，默认的 *pf.conf* 文件中也包含了一些以井号（`#`）开头的注释行。在这些注释中，你会找到一些建议的规则，这些规则提示了有用的配置，比如通过
    `ftp-proxy` 实现的 FTP 透传（见 [第 3 章](ch03.html "第 3 章：走向现实世界")）和 OpenBSD 的垃圾邮件延迟守护进程
    `spamd`（见 [第 6 章](ch06.html "第 6 章：主动防御的新视角")）。这些项在各种实际场景中可能有用，但由于它们在所有配置中并不总是相关，因此默认情况下被注释掉了。
- en: If you look for PF-related settings in your */etc/rc.conf* file, you’ll find
    the setting `pf_rules=`. In principle, this lets you specify that your configuration
    is in a file other than the default */etc/pf.conf*. However, changing this setting
    is probably not worth the trouble. Using the default setting lets you take advantage
    of a number of automatic housekeeping features, such as automatic nightly backup
    of your configuration to */var/backups*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 */etc/rc.conf* 文件中的与 PF 相关的设置，你会找到 `pf_rules=` 设置。原则上，这让你可以指定你的配置文件位于默认的
    */etc/pf.conf* 之外。然而，改变这个设置可能不值得麻烦。使用默认设置可以让你利用一些自动化管理功能，比如将配置文件自动备份到 */var/backups*。
- en: 'On OpenBSD, the */etc/rc* script has a built-in mechanism to help you out if
    you reboot with either no *pf.conf* file or one that contains an invalid rule
    set. Before enabling any network interfaces, the *rc* script loads a rule set
    that allows a few basic services: SSH from anywhere, basic name resolution, and
    NFS mounts. This allows you to log in and correct any errors in your rule set,
    load the corrected rule set, and then go on working from there.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenBSD 中，*/etc/rc* 脚本内置了一种机制，如果你在没有 *pf.conf* 文件或文件中包含无效规则集的情况下重启，它可以帮助你。在启用任何网络接口之前，*rc*
    脚本加载一个规则集，允许一些基本服务：从任何地方的 SSH 连接、基本的名称解析和 NFS 挂载。这使得你可以登录并修正规则集中的任何错误，加载修正后的规则集，然后继续工作。
- en: Setting Up PF on FreeBSD
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 FreeBSD 上设置 PF
- en: Good code travels well, and FreeBSD users will tell you that good code from
    elsewhere tends to find its way into FreeBSD sooner or later. PF is no exception,
    and from FreeBSD 5.2.1 and the 4.*x* series onward, PF and related tools became
    part of FreeBSD.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 好的代码传播得很快，FreeBSD 用户会告诉你，其他地方的好代码最终都会找到通向 FreeBSD 的路。PF 也不例外，从 FreeBSD 5.2.1
    和 4.*x* 系列版本开始，PF 和相关工具成为了 FreeBSD 的一部分。
- en: 'If you read through the previous section on setting up PF on OpenBSD, you saw
    that on OpenBSD, PF is enabled by default. That isn’t the case on FreeBSD, where
    PF is one of three possible packet-filtering options. Here, you need to take explicit
    steps to enable PF, and compared to OpenBSD, it seems that you need a little more
    magic in your */etc/rc.conf*. A look at your */etc/defaults/rc.conf* file shows
    that the FreeBSD default values for PF-related settings are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了关于在OpenBSD上设置PF的前一节，你会发现，在OpenBSD上PF默认是启用的。但在FreeBSD上情况不同，PF是三种可能的包过滤选项之一。在这里，你需要采取明确的步骤来启用PF，与OpenBSD相比，你似乎需要在*/etc/rc.conf*中做更多的配置。从*/etc/defaults/rc.conf*文件来看，FreeBSD中PF相关设置的默认值如下：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Fortunately, you can safely ignore most of these—at least for now. The following
    are the only options that you need to add to your */etc/rc.conf* configuration:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以安全地忽略其中的大部分内容——至少目前是这样。以下是你需要添加到*/etc/rc.conf*配置中的唯一选项：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are some differences between FreeBSD releases with respect to PF. Refer
    to the *FreeBSD Handbook* available from *[http://www.freebsd.org/](http://www.freebsd.org/)*—specifically
    the PF section of the “Firewalls” chapter—to see which information applies in
    your case. The PF code in FreeBSD 9 and 10 is equivalent to the code in OpenBSD
    4.5 with some bug fixes. The instructions in this book assume that you’re running
    FreeBSD 9.0 or newer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在FreeBSD的不同版本中，PF有一些差异。请参阅*FreeBSD手册*，该手册可从*[http://www.freebsd.org/](http://www.freebsd.org/)*获取——特别是“防火墙”章节中的PF部分——以查看哪些信息适用于你的情况。FreeBSD
    9和10中的PF代码与OpenBSD 4.5中的代码等效，只有一些bug修复。本书中的说明假设你正在运行FreeBSD 9.0或更新版本。
- en: 'On FreeBSD, PF is compiled as a kernel-loadable module by default. If your
    FreeBSD setup runs with a GENERIC kernel, you should be able to start PF with
    the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在FreeBSD上，PF默认是作为内核可加载模块编译的。如果你的FreeBSD系统使用GENERIC内核，你应该能够使用以下命令启动PF：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Assuming you have put the lines just mentioned in your */etc/rc.conf* and created
    an */etc/pf.conf* file, you could also use the PF *rc* script to run PF. The following
    enables PF:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经在*/etc/rc.conf*中添加了刚才提到的行，并创建了*/etc/pf.conf*文件，你也可以使用PF的*rc*脚本来运行PF。以下命令启用PF：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And this disables the packet filter:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这将禁用包过滤：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*On FreeBSD, the* /etc/rc.d/pf *script requires at least a line in* /etc/rc.conf
    *that reads `pf_enable="YES"` and a valid* /etc/pf.conf *file. If either of these
    requirements isn’t met, the script will exit with an error message. There is no*
    /etc/pf.conf *file in a default FreeBSD installation, so you’ll need to create
    one before you reboot the system with PF enabled. For our purposes, creating an
    empty* /etc/pf.conf *with `touch` will do, but you could also work from a copy
    of the* /usr/share/examples/pf/pf.conf *file supplied by the system.*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*在FreeBSD上，* /etc/rc.d/pf *脚本至少需要在* /etc/rc.conf *中有一行`pf_enable="YES"`，并且需要一个有效的*
    /etc/pf.conf *文件。如果这两个要求中的任何一个没有满足，脚本将会退出并显示错误信息。在默认的FreeBSD安装中没有* /etc/pf.conf
    *文件，因此你需要在启用PF后重新启动系统之前创建一个。为了我们的目的，使用`touch`创建一个空的* /etc/pf.conf *文件就足够了，但你也可以从系统提供的*
    /usr/share/examples/pf/pf.conf *文件的副本开始。'
- en: The supplied sample file */usr/share/examples/pf/pf.conf* contains no active
    settings. It has only comment lines starting with a `#` character and commented-out
    rules, but it does give you a preview of what a working rule set will look like.
    For example, if you remove the `#` sign before the line that says `set skip on
    lo` to uncomment the line and then save the file as your */etc/pf.conf*, your
    loopback interface group will not be filtered once you enable PF and load the
    rule set. However, even if PF is enabled on your FreeBSD system, we haven’t gotten
    around to writing an actual rule set, so PF isn’t doing much of anything and all
    packets will pass.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的示例文件* /usr/share/examples/pf/pf.conf *没有任何活动的设置。它只有以`#`字符开头的注释行和被注释掉的规则，但它确实给你展示了一个工作规则集的预览。例如，如果你删除位于`set
    skip on lo`前面的`#`符号来取消注释该行，然后将文件保存为你的*/etc/pf.conf*，一旦启用PF并加载规则集，你的回环接口组将不会被过滤。然而，即使PF在你的FreeBSD系统上被启用，由于我们还没有编写实际的规则集，PF也没有做什么，所有数据包都会通过。
- en: As of this writing (August 2014), the FreeBSD *rc* scripts don’t set up a default
    rule set as a fallback if the configuration read from */etc/pf.conf* fails to
    load. This means that enabling PF with no rule set or with *pf.conf* content that
    is syntactically invalid will leave the packet filter enabled with a default `pass
    all` rule set.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文撰写时（2014年8月），FreeBSD的*rc*脚本未设置默认规则集作为回退选项，如果从*/etc/pf.conf*读取的配置无法加载。这意味着，如果启用PF时没有规则集，或者*pf.conf*文件的内容在语法上无效，PF将启用并应用默认的`pass
    all`规则集。
- en: Setting Up PF on NetBSD
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在NetBSD上设置PF
- en: On NetBSD 2.0, PF became available as a loadable kernel module that could be
    installed via packages (*security/pflkm*) or compiled into a static kernel configuration.
    In NetBSD 3.0 and later, PF is part of the base system. On NetBSD, PF is one of
    several possible packet-filtering systems, and you need to take explicit action
    to enable it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在NetBSD 2.0中，PF作为一个可加载的内核模块提供，可以通过软件包（*security/pflkm*）安装，或者编译到静态内核配置中。在NetBSD
    3.0及更高版本中，PF是系统的基础部分。在NetBSD中，PF是多种数据包过滤系统之一，你需要采取明确的措施来启用它。
- en: Some details of PF configuration have changed between NetBSD releases. This
    book assumes you are using NetBSD 6.0 or later.^([[10](#ftn.ch02fn02)])
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一些PF配置的细节在NetBSD的不同版本之间发生了变化。本书假设你使用的是NetBSD 6.0或更高版本。^([[10](#ftn.ch02fn02)])
- en: To use the loadable PF module for NetBSD, add the following lines to your */etc/rc.conf*
    to enable loadable kernel modules, PF, and the PF log interface, respectively.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要在NetBSD上使用可加载的PF模块，请将以下行添加到*/etc/rc.conf*中，以分别启用可加载的内核模块、PF和PF日志接口。
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To load the *pf* module manually and enable PF, enter this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 若要手动加载*pf*模块并启用PF，请输入以下命令：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Alternatively, you can run the *rc.d* scripts to enable PF and logging, as
    follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以运行*rc.d*脚本来启用PF和日志记录，方法如下：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To load the module automatically at startup, add the following line to */etc/lkm.conf*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在启动时自动加载模块，请将以下行添加到*/etc/lkm.conf*文件中：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If your */usr* filesystem is on a separate partition, add this line to your
    */etc/rc.conf*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的*/usr*文件系统位于单独的分区上，请将以下行添加到*/etc/rc.conf*中：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If there are no errors at this point, you have enabled PF on your system, and
    you’re ready to move on to creating a complete configuration.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时没有错误，说明你已在系统上启用了PF，并且可以继续创建完整的配置。
- en: The supplied */etc/pf.conf* file contains no active settings; it has only comment
    lines starting with a hash mark (`#`) and commented-out rules. However, it does
    give you a preview of what a working rule set will look like. For example, if
    you remove the hash mark before the line that says `set skip on lo` to uncomment
    it and then save the file, your loopback interface will not be filtered once you
    enable PF and load the rule set. However, even if PF is enabled on your NetBSD
    system, we haven’t gotten around to writing an actual rule set, so PF isn’t doing
    much of anything but passing packets.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的*/etc/pf.conf*文件不包含任何活动设置；它只有以井号（`#`）开头的注释行和被注释掉的规则。不过，它确实给你提供了一个工作规则集的预览。例如，如果你去掉`set
    skip on lo`那一行前的井号以取消注释，并保存文件，那么在启用PF并加载规则集后，你的回环接口将不会被过滤。然而，即使在你的NetBSD系统上启用了PF，我们还没有编写实际的规则集，所以PF实际上并没有做任何事情，只是传递数据包。
- en: NetBSD implements a default or fallback rule set via the file */etc/defaults/
    pf.boot.conf*. This rule set is intended only to let your system complete its
    boot process in case the */etc/pf.conf* file doesn’t exist or contains an invalid
    rule set. You can override the default rules by putting your own customizations
    in */etc/pf.boot.conf*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: NetBSD通过文件*/etc/defaults/pf.boot.conf*实现了默认或回退规则集。此规则集仅用于在*/etc/pf.conf*文件不存在或包含无效规则集时，帮助系统完成启动过程。你可以通过在*/etc/pf.boot.conf*中添加自定义规则来覆盖默认规则。
- en: 'A Simple PF Rule Set: A Single, Stand-Alone Machine'
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的PF规则集：单台独立机器
- en: Mainly to have a common, minimal baseline, we will start building rule sets
    from the simplest possible configuration.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 主要为了提供一个通用的、最小的基准，我们将从最简单的配置开始构建规则集。
- en: A Minimal Rule Set
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小规则集
- en: The simplest possible PF setup is on a single machine that will not run any
    services and talks to only one network, which may be the Internet.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的PF设置是在一台不会运行任何服务、只与一个网络（可能是互联网）通信的单一计算机上。
- en: 'We’ll begin with an */etc/pf.conf* file that looks like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个类似下面的*/etc/pf.conf*文件开始：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This rule set denies all incoming traffic, allows traffic we send, and retains
    state information on our connections. PF reads rules from top to bottom; the *last*
    rule in a rule set that matches a packet or connection is the one that is applied.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则集拒绝所有进入流量，允许我们发送的流量，并保持我们连接的状态信息。PF从上到下读取规则；规则集中与数据包或连接匹配的*最后*一条规则是被应用的规则。
- en: Here, any connection coming into our system from anywhere else will match the
    `block in all` rule. Even with this tentative result, the rule evaluation will
    continue to the next rule (`pass out all keep state`), but the traffic will not
    even match the first criterion (the `out` direction) in this rule. With no more
    rules to evaluate, the status will not change, and the traffic will be blocked.
    In a similar manner, any connection initiated from the machine with this rule
    set will not match the first rule (once again, the wrong direction) but will match
    the second rule, which is a `pass` rule, and the connection is allowed to pass.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，来自任何其他地方进入我们系统的任何连接都会匹配`block in all`规则。即使有了这个初步结果，规则评估将继续进行到下一条规则（`pass
    out all keep state`），但流量不会匹配到这条规则中的第一个标准（即`out`方向）。由于没有更多的规则可以评估，状态不会发生变化，流量将被阻塞。以类似的方式，任何从具有此规则集的机器发起的连接都不会匹配第一条规则（再次是错误的方向），但会匹配第二条规则，这是一条`pass`规则，连接将被允许通过。
- en: We’ll examine the way that PF evaluates rules and how ordering matters in a
    bit more detail in [Chapter 3](ch03.html "Chapter 3. Into the Real World"), in
    the context of a slightly longer rule set.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](ch03.html "第3章 进入现实世界")中，结合一个稍长的规则集，更详细地探讨PF如何评估规则以及规则顺序的重要性。
- en: For any rule that has a `keep state` part, PF keeps information about the connection,
    including various counters and sequence numbers, as an entry in the *state table*.
    The state table is where PF keeps information about existing connections that
    have already matched a rule, and new packets that arrive are compared to existing
    state table entries to find a match first. Only when a packet doesn’t match any
    existing state will PF move on to a full *rule set evaluation*, checking whether
    the packet matches a rule in the loaded rule set. We can also instruct PF to act
    on state information in various ways, but in a simple case like this, our main
    goal is to allow return traffic for connections we initiate to return to us.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何包含`keep state`部分的规则，PF会保持有关连接的信息，包括各种计数器和序列号，作为*状态表*中的一项条目。状态表是PF保存已匹配规则的现有连接的信息的地方，新的到达数据包会首先与现有的状态表条目进行比较以查找匹配。只有当数据包与任何现有状态不匹配时，PF才会进行完整的*规则集评估*，检查数据包是否与加载的规则集中的某条规则匹配。我们还可以指示PF以各种方式处理状态信息，但在这种简单的情况下，我们的主要目标是允许我们发起的连接的返回流量返回给我们。
- en: 'Note that on OpenBSD 4.1 and later, the default for `pass` rules is to keep
    state information,^([[11](#ftn.ch02fn03)]) and we no longer need to specify `keep
    state` explicitly in a simple case like this. This means the rule set could be
    written like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在OpenBSD 4.1及更高版本中，`pass`规则的默认行为是保持状态信息，^([[11](#ftn.ch02fn03)])，我们在这种简单情况下不再需要显式地指定`keep
    state`。这意味着规则集可以写成这样：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In fact, you could even leave out the `all` keyword here if you like.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果你愿意，甚至可以省略这里的`all`关键字。
- en: The other BSDs have mostly caught up with this change by now, and for the rest
    of this book, we’ll stick to the newer rules, with an occasional reminder in case
    you are using an older system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其他BSD系统现在大多数已经跟上了这个变化，接下来的部分我们将坚持使用较新的规则，如果你正在使用旧系统，偶尔会提醒你。
- en: It goes pretty much without saying that passing all traffic generated by a specific
    host implies that the host in question is, in fact, trustworthy. This is something
    you do only if this is a machine you know you can trust.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，允许来自特定主机的所有流量通过意味着该主机是可信任的。只有在你确信可以信任该机器时，才会这么做。
- en: 'When you’re ready to use this rule set, load it with the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好使用此规则集时，使用以下命令加载：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The rule set should load without any error messages or warnings. On all but
    the slowest systems, you should be returned to the `$` prompt immediately.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 规则集应该能够加载而不显示任何错误消息或警告。在除最慢的系统外，应该会立即返回到`$`提示符。
- en: Testing the Rule Set
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试规则集
- en: It’s always a good idea to test your rule sets to make sure they work as expected.
    Proper testing will become essential once you move on to more complicated configurations.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 测试规则集以确保它们按预期工作始终是一个好主意。当你转向更复杂的配置时，适当的测试变得至关重要。
- en: To test the simple rule set, see whether it can perform domain name resolution.
    For example, you could see whether `$ host nostarch.com` returns information,
    such as the IP address of the host *nostarch.com* and the host-names of that domain’s
    mail exchangers. Or just see whether you can surf the Web. If you can connect
    to external websites by name, the rule set allows your system to perform domain
    name resolution. Basically, any service you try to access from your own system
    should work, and any service you try to access on your system from another machine
    should produce a `Connection refused` message.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个简单的规则集，看看它是否能够执行域名解析。例如，你可以检查`$ host nostarch.com`是否返回信息，如主机*nostarch.com*的IP地址和该域名邮件交换器的主机名。或者直接看看你是否能上网。如果你能够通过域名连接到外部网站，那么这个规则集就允许你的系统执行域名解析。基本上，你尝试从自己的系统访问的任何服务都应该能正常工作，而你尝试从另一台机器访问系统中的任何服务则应该产生`Connection
    refused`消息。
- en: 'Slightly Stricter: Using Lists and Macros for Readability'
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稍微严格一点：使用列表和宏来提高可读性
- en: The rule set in the previous section is an extremely simple one—probably too
    simplistic for practical use. But it’s a useful starting point to build from to
    create a slightly more structured and complete setup. We’ll start by denying all
    services and protocols and then allow only those we know that we need,^([[12](#ftn.ch02fn04)])
    using lists and macros for better readability and control.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的规则集是一个极其简单的规则集——可能对于实际使用来说太过简化。但它是一个很好的起点，可以在此基础上构建出稍微更有结构和完整的配置。我们将从拒绝所有服务和协议开始，然后只允许我们知道需要的那些，^([[12](#ftn.ch02fn04)])，并使用列表和宏来提高可读性和控制性。
- en: 'A *list* is simply two or more objects of the same type that you can refer
    to in a rule set, such as this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表*只是指两个或更多相同类型的对象，你可以在规则集中引用它们，如下所示：'
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `{ 22 80 443 }` is a list.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`{ 22 80 443 }`就是一个列表。
- en: 'A *macro* is a pure readability tool. If you have objects that you’ll refer
    to more than once in your configuration, such as an IP address for an important
    host, it could be useful to define a macro instead. For example, you might define
    this macro early in your rule set:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*宏*是一个纯粹的可读性工具。如果你在配置中有多次引用的对象，例如一个重要主机的IP地址，那么定义一个宏可能会很有用。例如，你可以在规则集中早期定义这个宏：'
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then you could refer to that host as `$external_mail` later in the rule set:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在规则集中稍后引用这个主机，写成`$external_mail`：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These two techniques have great potential for keeping your rule sets readable,
    and as such, they are important factors that contribute to the overall goal of
    keeping you in control of your network.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种技术在保持规则集的可读性方面具有巨大潜力，因此，它们是有助于实现保持对网络控制的总体目标的重要因素。
- en: A Stricter Baseline Rule Set
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个更严格的基础规则集
- en: Up to this point, we’ve been rather permissive with regard to any traffic we
    generate ourselves. A permissive rule set can be very useful while we check that
    basic connectivity is in place or we check whether filtering is part of a problem
    we’re seeing. Once the “Do we have connectivity?” phase is over, it’s time to
    start tightening up to create a baseline that keeps us in control.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在处理我们自己生成的任何流量时相对宽松。宽松的规则集在检查基本连通性是否正常或检查过滤是否是我们遇到的问题的一部分时非常有用。一旦“我们有连通性吗？”的阶段结束，就该开始收紧规则，创建一个我们能够掌控的基础规则集。
- en: 'To begin, add the following rule to */etc/pf.conf*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将以下规则添加到*/etc/pf.conf*：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This rule is completely restrictive and will block all traffic in all directions.
    This is the initial baseline filtering rule that we’ll use in all complete rule
    sets over the next few chapters. We basically start from zero, with a configuration
    where *nothing* is allowed to pass. Later on, we’ll add rules that cut our traffic
    more slack, but we’ll do so incrementally and in a way that keeps us firmly in
    control.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则是完全限制性的，它将阻止所有方向的流量。这是我们将在接下来几章中使用的所有完整规则集的初始基础过滤规则。我们基本上是从零开始，配置一个*不允许*任何流量通过的规则。稍后，我们将添加一些规则，放宽流量限制，但我们会逐步进行，并确保始终保持对系统的控制。
- en: 'Next, we’ll define a few macros for later use in the rule set:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一些宏，以便在规则集中后续使用：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, you can see how the combination of lists and macros can be turned to our
    advantage. Macros can be lists, and as demonstrated in the example, PF understands
    rules that use the names of services as well as port numbers, as listed in your
    */etc/services* file. We’ll take care to use all these elements and some further
    readability tricks as we tackle complex situations that require more elaborate
    rule sets.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到列表和宏的结合如何对我们有利。宏可以是列表，正如示例中所演示的，PF 理解使用服务名称和端口号的规则，这些服务名称和端口号列在你的 */etc/services*
    文件中。我们将小心使用所有这些元素以及一些进一步提高可读性的技巧，来处理那些需要更复杂规则集的复杂情况。
- en: 'Having defined these macros, we can use them in our rules, which we’ll now
    edit slightly to look like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这些宏之后，我们可以在规则中使用它们，接下来我们将稍微编辑规则，使其如下所示：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The strings `$tcp_services` and `$udp_services` are macro references. Macros
    that appear in a rule set are expanded in place when the rule set loads, and the
    running rule set will have the full lists inserted where the macros are referenced.
    Depending on the exact nature of the macros, they may cause single rules with
    macro references to expand into several rules. Even in a small rule set like this,
    the use of macros makes the rules easier to grasp and maintain. The amount of
    information that needs to appear in the rule set shrinks, and with sensible macro
    names, the logic becomes clearer. To follow the logic in a typical rule set, more
    often than not, we don’t need to see full lists of IP addresses or port numbers
    in place of every macro reference.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 `$tcp_services` 和 `$udp_services` 是宏引用。规则集中出现的宏会在规则集加载时展开，运行中的规则集会在引用宏的地方插入完整的列表。根据宏的具体性质，它们可能导致带有宏引用的单一规则展开为多个规则。即使在像这样的小规则集中，使用宏也使得规则更易于理解和维护。规则集中需要显示的信息量减少，且通过合理的宏名称，逻辑变得更清晰。在典型规则集的逻辑中，大多数时候我们不需要在每个宏引用的位置看到完整的
    IP 地址或端口号列表。
- en: From a practical rule set maintenance perspective, it’s important to keep in
    mind which services to allow on which protocol in order to keep a comfortably
    tight regime. Keeping separate lists of allowed services according to protocol
    is likely to be useful in keeping your rule set both functional and readable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际的规则集维护角度来看，重要的是要记住允许哪些服务使用哪些协议，以保持一个适当的控制状态。根据协议将允许的服务分开列出，很可能有助于保持规则集既功能完备又易于阅读。
- en: TCP vs. UDP
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 与 UDP
- en: We’ve taken care to separate out UDP services from TCP services. Several services
    run primarily on well-known port numbers on either TCP or UDP, and a few alternate
    between using TCP and UDP according to specific conditions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经小心地将 UDP 服务与 TCP 服务分开。几个服务主要运行在 TCP 或 UDP 上的知名端口号上，一些服务则根据特定条件在 TCP 和 UDP
    之间切换。
- en: The two protocols are quite different in several respects. TCP is connection
    oriented and reliable, a perfect candidate for stateful filtering. In contrast,
    UDP is stateless and connectionless, but PF creates and maintains data equivalent
    to state information for UDP traffic in order to ensure UDP return traffic is
    allowed back if it matches an existing state.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种协议在多个方面有所不同。TCP 是面向连接的，并且可靠，是进行有状态过滤的完美候选。而 UDP 是无状态的、无连接的，但 PF 会为 UDP 流量创建并维护等同于状态信息的数据，以确保如果返回的
    UDP 流量与现有状态匹配，则允许其通过。
- en: One common example where state information for UDP is useful is when handling
    name resolution. When you ask a name server to resolve a domain name to an IP
    address or to resolve an IP address back to a hostname, it’s reasonable to assume
    that you want to receive the answer. Retaining state information, or the functional
    equivalent about your UDP traffic, makes this possible.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的 UDP 状态信息有用的例子是处理名称解析。当你请求一个名称服务器将域名解析为 IP 地址，或将 IP 地址解析回主机名时，合理的假设是你希望收到答案。保留
    UDP 流量的状态信息，或其功能等效物，可以实现这一点。
- en: Reloading the Rule Set and Looking for Errors
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新加载规则集并查找错误
- en: 'After we’ve changed our *pf.conf* file, we need to load the new rules as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们修改了 *pf.conf* 文件之后，需要按如下方式加载新规则：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If there are no syntax errors, `pfctl` shouldn’t display any messages during
    the rule load.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有语法错误，`pfctl` 在加载规则时不应显示任何消息。
- en: 'If you prefer to display verbose output, use the `-v` flag:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢显示详细输出，可以使用 `-v` 标志：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When you use verbose mode, `pfctl` should expand your macros into their separate
    rules before returning you to the command-line prompt, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用详细模式时，`pfctl` 应该会在返回命令行提示符之前，将你的宏展开为各自的规则，如下所示：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Compare this output to the content of the */etc/pf.conf* file you actually
    wrote. Our single TCP services rule is expanded into eight different ones: one
    for each service in the list. The single UDP rule takes care of only one service,
    and it expands from what we wrote to include the default options. Notice that
    the rules are displayed in full, with default values such as `flags S/SA keep
    state` applied in place of any options you do not specify explicitly. This is
    the configuration as it’s actually loaded.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将此输出与您实际编写的*/etc/pf.conf*文件的内容进行比较。我们的单个 TCP 服务规则扩展为八个不同的规则：每个服务都有一个对应的规则。单个
    UDP 规则只处理一个服务，并且它从我们写的内容扩展到包括默认选项。请注意，规则被完整地显示出来，默认值如`flags S/SA keep state`已应用到你未明确指定的任何选项。这就是实际加载的配置。
- en: Checking Your Rules
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查你的规则
- en: 'If you’ve made extensive changes to your rule set, check them before attempting
    to load the rule set by using the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对规则集做了大量更改，在尝试加载规则集之前，使用以下命令检查它们：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `-n` option tells PF to parse the rules only, without loading them—more
    or less as a dry run and to allow you to review and correct any errors. If `pfctl`
    finds any syntax errors in your rule set, it’ll exit with an error message that
    points to the line number where the error occurred.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`-n`选项告诉 PF 仅解析规则，而不加载它们——这基本上是一次模拟运行，可以让你检查和纠正任何错误。如果`pfctl`在规则集中发现任何语法错误，它将退出并显示错误信息，指明错误发生的行号。'
- en: Some firewall guides advise you to make sure that your old configuration is
    truly gone, or you’ll run into trouble—your firewall might be in some kind of
    intermediate state that doesn’t match either the before or after state. That’s
    simply not true when you’re using PF. The last valid rule set loaded is active
    until you either disable PF or load a new rule set. `pfctl` checks the syntax
    and then loads your new rule set completely before switching over to the new one.
    This is often referred to as *atomic rule set load* and means that once a valid
    rule set has been loaded, there’s no intermediate state with a partial rule set
    or no rules loaded. One consequence is that traffic that matches states that are
    valid in both the old and new rule set will not be disrupted.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一些防火墙指南建议你确保旧的配置已被完全删除，否则你可能会遇到问题——你的防火墙可能处于某种中间状态，这种状态既不符合之前的状态，也不符合之后的状态。使用
    PF 时，这种情况完全不成立。最后加载的有效规则集会一直处于活动状态，直到你禁用 PF 或加载新的规则集。`pfctl` 会检查语法，然后在切换到新规则集之前完全加载新的规则集。这通常被称为*原子规则集加载*，意味着一旦有效的规则集加载完毕，就不会有部分规则集或没有加载规则的中间状态。一个后果是，匹配旧规则集和新规则集中都有效的状态的流量不会被中断。
- en: Unless you’ve actually followed the advice from some of those old guides and
    *flushed* your existing rules (that *is* possible, using `pfctl -F all` or similar)
    before attempting to load a new one from your configuration file, the last valid
    configuration will remain loaded. In fact, flushing the rule set is rarely a good
    idea because it effectively puts your packet filter in a `pass all` mode, which
    in turn both opens the door to any comers and runs the risk of disrupting useful
    traffic while you’re getting ready to load your rules.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你真的按照一些旧指南的建议，*刷新*了现有的规则（这确实可以通过使用`pfctl -F all`或类似命令实现），然后再尝试从配置文件加载新的规则，否则最后有效的配置将继续保持加载。实际上，刷新规则集通常不是一个好主意，因为它实际上将你的数据包过滤器置于`pass
    all`模式，这样既会为任何流量打开大门，又可能在你准备加载新规则时中断有用的流量。
- en: Testing the Changed Rule Set
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试已更改的规则集
- en: Once you have a rule set that `pfctl` loads without any errors, it’s time to
    see whether the rules you’ve written behave as expected. Testing name resolution
    with a command such as `$ host nostarch.com`, as we did earlier, should still
    work. However, it’s better to choose a domain you haven’t accessed recently, such
    as one for a political party you wouldn’t consider voting for, to be sure that
    you’re not pulling DNS information from the cache.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个`pfctl`能加载且没有任何错误的规则集，就该检查你编写的规则是否按预期工作了。像我们之前做的那样，使用命令`$ host nostarch.com`测试名称解析应该仍然能正常工作。不过，最好选择一个你最近没有访问过的域名，比如你不会考虑投票给的某个政党，这样可以确保你没有从缓存中拉取
    DNS 信息。
- en: You should be able to surf the Web and use several mail-related services, but
    due to the nature of this updated rule set, attempts to access TCP services other
    than the ones defined—SSH, SMTP, and so forth—on any remote system should fail.
    And, as with our simple rule set, your system should refuse all connections that
    don’t match existing state table entries; only return traffic for connections
    initiated by this machine will be allowed in.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够浏览网页并使用几个与邮件相关的服务，但由于这个更新的规则集的性质，任何尝试访问除已定义的TCP服务（如SSH、SMTP等）以外的远程系统服务应该会失败。就像我们简单的规则集一样，系统应拒绝所有不匹配现有状态表条目的连接；只有由本机发起的连接的返回流量才会被允许进入。
- en: Displaying Information About Your System
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示有关系统的信息
- en: The tests you’ve performed on your rule sets should have shown that PF is running
    and that your rules are behaving as expected. There are several ways to keep track
    of what happens in your running system. One of the more straightforward ways of
    extracting information about PF is to use the already familiar `pfctl` program.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你对规则集进行的测试应该已经显示PF正在运行，并且规则行为符合预期。有几种方法可以跟踪运行中的系统中发生的事情。提取PF信息的其中一种更直接的方式是使用已经熟悉的`pfctl`程序。
- en: Once PF is enabled and running, the system updates various counters and statistics
    in response to network activity. To confirm that PF is running and to view statistics
    about its activity, you can use `pfctl -s`, followed by the type of information
    you want to display. A long list of information types is available (see `man 8
    pfctl` and look for the `-s` options). We’ll get back to some of those display
    options in [Chapter 9](ch09.html "Chapter 9. Logging, Monitoring, and Statistics")
    and go into further detail about some of the statistics they provide in [Chapter 10](ch10.html
    "Chapter 10. Getting Your Setup Just Right"), when we use the data to optimize
    the configuration we’re building.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦PF启用并运行，系统会根据网络活动更新各种计数器和统计信息。要确认PF是否正在运行并查看其活动的统计信息，可以使用`pfctl -s`，后面跟上你想显示的信息类型。可以显示的信息类型有很多种（请参阅`man
    8 pfctl`并查找`-s`选项）。我们将在[第9章](ch09.html "第9章：日志记录、监控和统计")中回到这些显示选项，并在[第10章](ch10.html
    "第10章：优化配置的细节")中更详细地讨论它们提供的一些统计信息，我们将利用这些数据来优化我们正在构建的配置。
- en: The following shows an example of just the top part of the output of `pfctl
    -s info` (taken from my home gateway). The high-level information that indicates
    the system actually passes traffic can be found in this upper part.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`pfctl -s info`输出的一个例子（摘自我的家庭网关）。显示系统实际传输流量的高层信息可以在这部分找到。
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first line of the `pfctl` output indicates that PF is enabled and has been
    running for a little more than three weeks, which is equal to the time since I
    last performed a system upgrade that required a reboot.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`pfctl`输出的第一行表明PF已经启用，并且运行了稍多于三周的时间，这与我上次进行需要重启的系统升级的时间相等。'
- en: The `Interface Stats` part of the display is an indication that the system’s
    administrator has chosen one interface (here, `nfe0`) as the log interface for
    the system and shows the bytes in and out handled by the interface. If no log
    interface has been chosen, the display is slightly different. Now would be a good
    time to check what output your system produces. The next few items are likely
    to be more interesting in our context, showing the number of packets blocked or
    passed in each direction. This is where we find an early indication of whether
    the filtering rules we wrote are catching any traffic. In this case, either the
    rule set matches expected traffic well, or we have fairly well-behaved users and
    guests, with the number of packets passed being overwhelmingly larger than the
    number of packets blocked in both directions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 显示中的`Interface Stats`部分表明系统管理员选择了一个接口（此处为`nfe0`）作为系统的日志接口，并显示该接口处理的进出字节。如果没有选择日志接口，则显示会稍有不同。现在是检查系统输出的好时机。接下来的几项可能会更引人兴趣，在我们的上下文中，它们显示了每个方向上被阻止或通过的数据包数量。在这里，我们可以看到过滤规则是否有效的初步迹象。在这个例子中，规则集要么很好地匹配了预期的流量，要么我们有相当守规矩的用户和访客，在两个方向上，通过的数据包数量远大于被阻止的数据包数量。
- en: The next important indicator of a working system that’s processing traffic is
    the block of `State Table` statistics. The state table `current entries` line
    shows that there are 319 active states or connections, while the state table has
    been searched (`searches`) for matches to existing states on average a little
    more than 84 times per second, for a total of just over 178 million times since
    the counters were reset. The `inserts` and `removals` counters show the number
    of times states have been created and removed, respectively. As expected, the
    number of insertions and removals differs by the number of currently active states,
    and the rate counters show that for the time since the counters were last reset,
    the rate of states created and removed matches exactly up to the resolution of
    this display.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，系统处理流量的另一个重要指标是 `状态表` 统计信息。状态表的 `当前条目` 行显示有 319 个活动状态或连接，而状态表平均每秒搜索匹配现有状态的次数略多于
    84 次，自计数器重置以来，总共进行了超过 1.78 亿次搜索。`插入` 和 `移除` 计数器显示了状态被创建和删除的次数。如预期所示，插入和移除的次数与当前活动状态的数量不同，速率计数器显示，自计数器最后重置以来，创建和删除状态的速率与此显示的分辨率完全一致。
- en: The information here is roughly in line with the statistics you should expect
    to see on a gateway for a small network configured for IPv4 only. There’s no reason
    to be alarmed by the packet passed in the IPv6 column. OpenBSD comes with IPv6
    built in. During network interface configuration, by default, the TCP/IP stack
    sends IPv6 neighbor solicitation requests for the link local address. In a normal
    IPv4-only configuration, only the first few packets actually pass, and by the
    time the PF rule set from */etc/ pf.conf* is fully loaded, IPv6 packets are blocked
    by the block all default rule. (In this example, they don’t show up in `nfe0`’s
    statistics because IPv6 is tunneled over a different interface.)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的信息大致与配置为仅支持 IPv4 的小型网络网关上你应当看到的统计数据一致。IPv6 列中的数据包传递不必惊慌。OpenBSD 内置了 IPv6。在网络接口配置期间，默认情况下，TCP/IP
    堆栈会发送 IPv6 邻居发现请求，用于链路本地地址。在一个正常的仅 IPv4 配置中，只有前几个数据包实际上会通过，等到来自*/etc/pf.conf*的
    PF 规则集完全加载时，IPv6 数据包会被默认的“阻止所有”规则拦截。（在这个示例中，它们不会出现在 `nfe0` 的统计信息中，因为 IPv6 是通过不同的接口进行隧道传输的。）
- en: Looking Ahead
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展望未来
- en: You should now have a machine that can communicate with other Internet-connected
    machines, using a very basic rule set that serves as a starting point for controlling
    your network traffic. As you progress through this book, you’ll learn how to add
    rules that do various useful things. In [Chapter 3](ch03.html "Chapter 3. Into
    the Real World"), we’ll extend the configuration to act as a gateway for a small
    network. Serving the needs of several computers has some consequences, and we’ll
    look at how to let at least some ICMP and UDP traffic through—for your own troubleshooting
    needs if nothing else.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该有一台能够与其他联网机器通信的机器，使用一个非常基本的规则集，它作为控制网络流量的起点。随着你阅读本书，你将学习如何添加执行各种有用操作的规则。在[第
    3 章](ch03.html "第 3 章. 走向现实世界")中，我们将扩展配置，使其充当一个小型网络的网关。为几台计算机提供服务会有一些后果，我们将研究如何至少允许某些
    ICMP 和 UDP 流量通过——如果没有别的，至少用于你自己的故障排除需求。
- en: In [Chapter 3](ch03.html "Chapter 3. Into the Real World"), we’ll also consider
    network services that have consequences for your security, like FTP. Using packet
    filtering intelligently to handle services that are demanding, security-wise,
    is a recurring theme in this book.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](ch03.html "第 3 章. 走向现实世界")中，我们还将考虑对你的安全有影响的网络服务，如 FTP。智能使用数据包过滤来处理那些安全要求较高的服务，是本书中的一个反复出现的主题。
- en: '* * *'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[9](#ch02fn01)]) If you’re setting up your first PF configuration on an OpenBSD
    version earlier than this, the best advice is to upgrade to the most recent stable
    version. If for some reason you must stay with the older version, it might be
    useful to consult the first edition of this book as well as the man pages and
    other documentation for the specific version you’re using.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[9](#ch02fn01)]) 如果你在设置 OpenBSD 版本低于这个版本的第一个 PF 配置，最好的建议是升级到最新的稳定版本。如果由于某种原因你必须继续使用旧版本，查阅本书的第一版以及你使用的特定版本的
    man 页和其他文档可能会有所帮助。
- en: ^([[10](#ch02fn02)]) For instructions on using PF in earlier releases, see the
    documentation for your release and look up supporting literature listed in [Appendix A](apa.html
    "Appendix A. Resources") of this book.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[10](#ch02fn02)]) 有关在早期版本中使用PF的说明，请参阅你所使用版本的文档，并查阅本书[附录A](apa.html "附录A.
    资源")中列出的相关资料。
- en: ^([[11](#ch02fn03)]) In fact, the new default corresponds `to keep state flags
    S/SA`, ensuring that only initial SYN packets during connection setup create state,
    eliminating some puzzling error scenarios. To filter statelessly, you can specify
    `no state` for the rules where you don’t want to record or keep state information.
    On FreeBSD, OpenBSD 4.1–equivalent PF code was merged into version 7.0\. If you’re
    using a PF version old enough that it does not have this default, it is a very
    strong indicator that you should consider upgrading your operating system as soon
    as feasible.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[11](#ch02fn03)]) 事实上，新的默认设置对应于`保持状态标志S/SA`，确保只有在连接建立过程中初始的SYN数据包会创建状态，从而消除了某些令人困惑的错误场景。为了无状态地过滤，你可以为那些不想记录或保留状态信息的规则指定`no
    state`。在FreeBSD中，OpenBSD 4.1等效的PF代码已被合并到7.0版本中。如果你正在使用一个较旧的PF版本，且它没有这个默认设置，这强烈表明你应该尽快考虑升级操作系统。
- en: ^([[12](#ch02fn04)]) Why write the rule set to default deny? The short answer
    is that it gives you better control. The point of packet filtering is to take
    control, not to play catch-up with what the bad guys do. Marcus Ranum has written
    a very entertaining and informative article about this called “The Six Dumbest
    Ideas in Computer Security” (*[http://www.ranum.com/security/computer_security/editorials/dumb/index.html](http://www.ranum.com/security/computer_security/editorials/dumb/index.html)*).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[12](#ch02fn04)]) 为什么要将规则集设置为默认拒绝？简短的答案是，这样能让你更好地控制。数据包过滤的目的是掌控局面，而不是在坏人行动之后再做补救。Marcus
    Ranum写过一篇非常有趣且富有启发性的文章，名为《计算机安全中的六大愚蠢想法》(*[http://www.ranum.com/security/computer_security/editorials/dumb/index.html](http://www.ranum.com/security/computer_security/editorials/dumb/index.html)*)。
