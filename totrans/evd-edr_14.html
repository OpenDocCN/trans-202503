<html><head></head><body>
<section epub:type="appendix" role="doc-appendix" aria-labelledby="appA">&#13;
<header>&#13;
<h1 class="CHAPTER" id="appA">&#13;
<span class="APN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_265" aria-label=" Page 265. "/><samp class="SANS_Dogma_OT_Bold_B_11">APPENDIX</samp></span>&#13;
<span class="APH"><samp class="SANS_Dogma_OT_Bold_B_11">AUXILIARY SOURCES</samp></span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.png" alt=""/>&#13;
</figure>&#13;
<p class="CO">Modern EDRs sometimes make use of less popular components not covered in this book so far. These auxiliary telemetry sources can provide immense value to the EDR, offering access to data that would otherwise be unavailable from other sensors.</p>&#13;
<p class="TX">Because these data sources are uncommon, we won’t take a deep dive into their inner workings. Instead, this appendix covers some examples of them, how they work, and what they can offer an EDR agent. This is by no means an exhaustive list, but it shines a light on some of the more niche components you may encounter during your research.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h-189"/><samp class="SANS_Futura_Std_Bold_B_11">Alternative Hooking Methods</samp></h2>&#13;
<p class="TNI">This book has shown the value of intercepting function calls, inspecting the parameters passed to them, and observing their return values. The most prevalent method of hooking function calls at the time of this writing relies <span role="doc-pagebreak" epub:type="pagebreak" id="pg_266" aria-label=" Page 266. "/>on injecting a DLL into the target process and modifying the execution flow of another DLL’s exported functions, such as those of <i>ntdll.dll</i>, forcing execution to pass through the EDR’s DLL. However, this method is trivial to bypass due to weaknesses inherent in its implementation (see <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>).</p>&#13;
<p class="TX">Other, more robust methods of intercepting function calls exist, such as using the Microsoft-Windows-Threat-Intelligence ETW provider to indirectly intercept certain syscalls in the kernel, but these have their own limitations. Having multiple techniques for achieving the same effect provides advantages for defenders, as one method may work better in some contexts than others. For this reason, some vendors have leveraged alternative hooking methods in their products to augment their ability to monitor calls to suspicious functions.</p>&#13;
<p class="TX">In a 2015 Recon talk titled “Esoteric Hooks,” Alex Ionescu expounded on some of these techniques. A few mainstream EDR vendors have implemented one of the methods he outlines: Nirvana hooks. Where garden-variety function hooking works by intercepting the function’s caller, this technique intercepts the point at which the syscall returns to user mode from the kernel. This allows the agent to identify syscalls that didn’t originate from a known location, such as the copy of <i>ntdll.dll</i> mapped into a process’s address space. Thus, it can detect the use of manual syscalls, a technique that has become relatively common in offensive tools in recent years.</p>&#13;
<p class="TX">There are a few notable downsides to this hooking method, though. First, it relies on an undocumented <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_INFORMATION_CLASS</samp> and associated structure being passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationProcess()</samp> for each process the product wishes to monitor. Because it isn’t formally supported, Microsoft may modify its behavior or disable it entirely at any time. Additionally, the developer must identify the source of the call by capturing the return context and correlating it to a known good image in order to detect manual syscall invocation. Lastly, this hooking method is simple to evade, as adversaries can remove the hook from their process by nulling out the callback via a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationProcess()</samp>, similarly to how the security process initially placed it.</p>&#13;
<p class="TX">Even if Nirvana hooks are relatively easy to evade, not every adversary has the capability to do so, and the telemetry they provide might still be valuable. Vendors can employ multiple techniques to provide the coverage they desire.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h2 class="H1" id="sec2"><span id="h-190"/><samp class="SANS_Futura_Std_Bold_B_11">RPC Filters</samp></h2>&#13;
<p class="TNI">Recent attacks have rekindled interest in RPC tradecraft. Lee Christensen’s PrinterBug and topotam’s PetitPotam exploits, for example, have proven their utility in Windows environments. In response, EDR vendors have begun paying attention to emerging RPC tradecraft in hopes of detecting and preventing their use.</p>&#13;
<p class="TX">RPC traffic is notoriously difficult to work with at scale. One way EDRs can monitor it is by using <i>RPC filters</i>. These are essentially firewall rules based on RPC interface identifiers, and they’re simple to create and deploy using <span role="doc-pagebreak" epub:type="pagebreak" id="pg_267" aria-label=" Page 267. "/>built-in system utilities. For example, <a href="#listA-1">Listing A-1</a> demonstrates how to ban all inbound DCSync traffic to the current host using <i>netsh.exe</i> interactively. An EDR could deploy this rule on all domain controllers in an environment.</p>&#13;
<pre id="listA-1"><code>netsh&gt; <b>rpc filter</b>&#13;
netsh rpc filter&gt; <b>add rule layer=um actiontype=block</b>&#13;
Ok.&#13;
&#13;
netsh rpc filter&gt; <b>add condition field=if_uuid matchtype=equal \</b>&#13;
<b>data=e3514235-4b06-11d1-ab04-00c04fc2dcd2</b>&#13;
Ok.&#13;
&#13;
netsh rpc filter&gt; <b>add filter</b>&#13;
FilterKey: 6a377823-cff4-11ec-967c-000c29760114&#13;
Ok.&#13;
netsh rpc filter&gt; <b>show filter</b>&#13;
Listing all RPC Filters.&#13;
-----------------------------&#13;
filterKey: 6a377823-cff4-11ec-967c-000c29760114&#13;
displayData.name: RPCFilter&#13;
displayData.description: RPC Filter&#13;
filterId: 0x12794&#13;
layerKey: um&#13;
weight: Type: FWP_EMPTY Value: Empty&#13;
action.type: block&#13;
&#13;
numFilterConditions: 1&#13;
filterCondition[0]&#13;
        fieldKey: if_uuid&#13;
        matchType: FWP_MATCH_EQUAL&#13;
        conditionValue: Type: FWP_BYTE_ARRAY16_TYPE Value: e3514235 11d14b06 c00004ab d2dcc24f</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing A-1: Adding and listing RPC filters using <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">netsh</samp></span></p>&#13;
<p class="TX">These commands add a new RPC filter that specifically blocks any communications using the <i>Directory Replication Service</i> RPC interface (which has the GUID <samp class="SANS_TheSansMonoCd_W5Regular_11">E3514235-4B06-11D1-AB04-00C04FC2DCD2</samp>). Once the filter is installed via the <samp class="SANS_TheSansMonoCd_W5Regular_11">add filter</samp> command, it is live on the system, prohibiting DCSync.</p>&#13;
<p class="TX">Whenever the RPC filter blocks a connection, the Microsoft-Windows-RPC provider will emit an ETW similar to the one shown in <a href="#listA-2">Listing A-2</a>.</p>&#13;
<pre id="listA-2"><code>An RPC call was blocked by an RPC firewall filter.&#13;
ProcessName: lsass.exe&#13;
InterfaceUuid: e3514235-4b06-11d1-ab04-00c04fc2dcd2&#13;
RpcFilterKey: 6a377823-cff4-11ec-967c-000c29760114</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing A-2: An ETW event showing activity blocked by a filter</span></p>&#13;
<p class="TX">While this event is better than nothing, and defenders could theoretically use it to build detections, it lacks much of the context needed for a robust detection. For example, the principal that issued the request and the direction of traffic (as in, inbound or outbound) are not immediately clear, making it difficult to filter events to help tune a detection.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_268" aria-label=" Page 268. "/>A better option may be to consume a similar event from the Microsoft-Windows-Security-Auditing Secure ETW provider. Since this provider is protected, standard applications can’t consume from it. It is, however, fed into the Windows Event Log, where it populates Event ID 5157 whenever the base filtering engine component of the Windows Filtering Platform blocks a request. <a href="#listA-3">Listing A-3</a> contains an example of Event ID 5157. You can see how much more detailed it is than the one emitted by Microsoft-Windows-RPC.</p>&#13;
<pre id="listA-3"><code>&lt;Event xmlns="http://schemas.microsoft.com/win/2004/08/events/event"&gt;&#13;
    &lt;System&gt;&#13;
        &lt;Provider Name="Microsoft-Windows-Security-Auditing" Guid="{54849625-5478-4994&#13;
          -A5BA-3E3B0328C30D}" /&gt;&#13;
        &lt;EventID&gt;5157&lt;/EventID&gt;&#13;
        &lt;Version&gt;1&lt;/Version&gt;&#13;
        &lt;Level&gt;0&lt;/Level&gt;&#13;
        &lt;Task&gt;12810&lt;/Task&gt;&#13;
        &lt;Opcode&gt;0&lt;/Opcode&gt;&#13;
        &lt;Keywords&gt;0x8010000000000000&lt;/Keywords&gt;&#13;
        &lt;TimeCreated SystemTime="2022-05-10T12:19:09.692752600Z" /&gt;&#13;
        &lt;EventRecordID&gt;11289563&lt;/EventRecordID&gt;&#13;
        &lt;Correlation /&gt;&#13;
        &lt;Execution ProcessID="4" ThreadID="3444" /&gt;&#13;
        &lt;Channel&gt;Security&lt;/Channel&gt;&#13;
        &lt;Computer&gt;sun.milkyway.lab&lt;/Computer&gt;&#13;
        &lt;Security /&gt;&#13;
    &lt;/System&gt;&#13;
    &lt;EventData&gt;&#13;
        &lt;Data Name="ProcessID"&gt;644&lt;/Data&gt;&#13;
        &lt;Data Name="Application"&gt;\device\harddiskvolume2\windows\system32\lsass.exe&lt;/Data&gt;&#13;
        &lt;Data Name="Direction"&gt;%%14592&lt;/Data&gt;&#13;
        &lt;Data Name="SourceAddress"&gt;192.168.1.20&lt;/Data&gt;&#13;
        &lt;Data Name="SourcePort"&gt;62749&lt;/Data&gt;&#13;
        &lt;Data Name="DestAddress"&gt;192.168.1.5&lt;/Data&gt;&#13;
        &lt;Data Name="DestPort"&gt;49667&lt;/Data&gt;&#13;
        &lt;Data Name="Protocol"&gt;6&lt;/Data&gt;&#13;
        &lt;Data Name="FilterRTID"&gt;75664&lt;/Data&gt;&#13;
        &lt;Data Name="LayerName"&gt;%%14610&lt;/Data&gt;&#13;
        &lt;Data Name="LayerRTID"&gt;46&lt;/Data&gt;&#13;
        &lt;Data Name="RemoteUserID"&gt;S-1-0-0&lt;/Data&gt;&#13;
        &lt;Data Name="RemoteMachineID"&gt;S-1-0-0&lt;/Data&gt;&#13;
    &lt;/EventData&gt;&#13;
&lt;/Event&gt;</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing A-3: An event manifest for the Microsoft-Windows-Security-Auditing Secure ETW provider</span></p>&#13;
<p class="TX">While this event contains much more data, it also has some limitations. Notably, although the source and destination ports are included, the interface ID is missing, making it difficult to determine whether the event is related to the filter that blocks DCSync attempts or another filter entirely. Additionally, this event operates inconsistently across Windows versions, generating correctly in some and completely missing in others. Therefore, some defenders might prefer to use the less-enriched but more consistent RPC event as their primary data source.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h2 class="H1" id="sec3"><span id="h-191"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_269" aria-label=" Page 269. "/><samp class="SANS_Futura_Std_Bold_B_11">Hypervisors</samp></h2>&#13;
<p class="TNI">Hypervisors virtualize one or more guest operating systems, then act as an intermediary between the guest and either the hardware or the base operating system, depending on the hypervisor’s architecture. This intermediary position provides EDRs with a unique opportunity for detection.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H2" id="sec4"><span id="h-192"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How Hypervisors Work</samp></h3>&#13;
<p class="TNI">The inner workings of a hypervisor are relatively simple once you understand a few core concepts. Windows runs code at several <i>rings</i>; the code running in a higher ring, such as <i>ring 3</i> for user mode, is less privileged than code running at a lower one, such as <i>ring 0</i> for the kernel. Root mode, where the hypervisor resides, operates at ring 0, the lowest architecturally supported privilege level, and limits the operations that the guest, or non-root mode system, can perform. <a href="#figA-1">Figure A-1</a> shows this process.</p>&#13;
<figure class="IMG"><img id="figA-1" class="img40" src="../images/FigureA-1.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-1: The operation of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">VMEXIT</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">VMENTER</samp></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">When a virtualized guest system attempts to execute an instruction or perform some action that the hypervisor must handle, a <samp class="SANS_TheSansMonoCd_W5Regular_11">VMEXIT</samp> instruction occurs. When this happens, control transitions from the guest to the hypervisor. The <i>Virtual Machine Control Structure (VMCS)</i> preserves the state of the processor for both the guest and the hypervisor so that it can be restored later. It also keeps track of the reason for the <samp class="SANS_TheSansMonoCd_W5Regular_11">VMEXIT</samp>. One VMCS exists for each logical processor of the system, and you can read more about them in volume 3C of the Intel Software Developer’s Manual.</p>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>&#13;
<p class="NOTE-TXT"><i>For the sake of simplicity, this brief exploration covers the operation of a hypervisor based on Intel VT-x, as Intel CPUs remain the most popular at the time of this writing.</i></p>&#13;
<p class="TX">When the hypervisor enters root-mode operation, it may emulate, modify, and log the activity based on the reason for the <samp class="SANS_TheSansMonoCd_W5Regular_11">VMEXIT</samp>. These exits may occur for many common reasons, including instructions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">RDMSR</samp>, for reading model-specific registers, and <samp class="SANS_TheSansMonoCd_W5Regular_11">CPUID</samp>, which returns information about the processor. After the completion of the root-mode operation, execution is transferred back to non-root-mode operation via a <samp class="SANS_TheSansMonoCd_W5Regular_11">VMRESUME</samp> instruction, allowing the guest to continue.</p>&#13;
<p class="TX">There are two types of hypervisors. Products such as Microsoft’s Hyper-V and VMware’s ESX are what we call <i>Type 1 hypervisors</i>. This means the hypervisor runs on the bare metal system, as shown in Figure A-2.</p><span role="doc-pagebreak" epub:type="pagebreak" id="pg_270" aria-label=" Page 270. "/>&#13;
<figure class="IMG"><img id="figA-2" class="img20" src="../images/FigureA-2.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-2: A Type 1 hypervisor architecture</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The other kind of hypervisor, <i>Type 2</i>, runs in an operating system installed on the bare metal system. Examples of these include VMware’s Workstation and Oracle’s VirtualBox. The Type 2 architecture is shown in Figure A-3.</p>&#13;
<figure class="IMG"><img id="figA-3" class="img20" src="../images/FigureA-3.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-3: A Type 2 hypervisor architecture</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Type 2 hypervisors are interesting because they can virtualize a system that is already running. Thus, rather than requiring the end user to log in to their system, start an application such as VMware Workstation, launch a virtual machine, log in to the virtual machine, and then do their work from that virtual machine, their host is the virtual machine. This makes the hypervisor layer transparent to the user (and resident attackers) while allowing the EDR to collect all the telemetry available.</p>&#13;
<p class="TX">Most EDRs that implement a hypervisor take the Type 2 approach. Even so, they must follow a complicated series of steps to virtualize an existing system. Full hypervisor implementation is far beyond the scope of this book. If this topic interests you, both Daax Rynd and Sina Karvandi have excellent resources for implementing your own.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H2" id="sec5"><span id="h-193"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Use Cases</samp></h3>&#13;
<p class="TNI">A hypervisor can provide visibility into system operations at a layer deeper than nearly any other sensor. Using one, an endpoint security product can detect attacks missed by the sensors in other rings, such as the following:</p>&#13;
<p class="LH"><b>Virtual Machine Detection</b></p>&#13;
<p class="LIST1">Some malware attempts to detect that it is running in a virtual machine by issuing a <samp class="SANS_TheSansMonoCd_W5Regular_11">CPUID</samp> instruction. Since this instruction causes a <samp class="SANS_TheSansMonoCd_W5Regular_11">VMEXIT</samp>, the hypervisor has the ability to choose what to return to the caller, allowing it to trick the malware into thinking it isn’t running in a VM.</p>&#13;
<p class="LH"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_271" aria-label=" Page 271. "/><b>Syscall Interception</b></p>&#13;
<p class="LIST1">A hypervisor can potentially leverage the Extended Feature Enable Register (EFER) function to exit on each syscall and emulate its operation.</p>&#13;
<p class="LH"><b>Control Register Modification</b></p>&#13;
<p class="LIST1">A hypervisor can detect the modification of bits in a control register (such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">SMEP</samp> bit in the <samp class="SANS_TheSansMonoCd_W5Regular_11">CR4</samp> register), which is behavior that could be part of an exploit. Additionally, the hypervisor can exit when a control register is changed, allowing it to inspect the guest execution context to identify things such as token-stealing attacks.</p>&#13;
<p class="LH"><b>Memory Change Tracing</b></p>&#13;
<p class="LIST1">A hypervisor can use the page-modification log in conjunction with Extended Page Tables (EPT) to track changes to certain regions of memory.</p>&#13;
<p class="LH"><b>Branch Tracing</b></p>&#13;
<p class="LIST1">A hypervisor can leverage the <i>last branch record</i>, a set of registers used to trace branches, interrupts, and exceptions, along with EPT to trace the execution of the program beyond monitoring its syscalls.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H2" id="sec6"><span id="h-194"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Evading the Hypervisor</samp></h3>&#13;
<p class="TNI">One of the difficult things about operating against a system onto which a vendor has deployed a hypervisor is that, by the time you know you’re in a virtual machine, you’ve likely already been detected. Thus, malware developers commonly use virtual-machine-detection functions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">CPUID</samp> instructions or sleep acceleration, prior to executing their malware. If the malware finds that it is running in a virtual machine, it may opt to terminate or merely do something benign.</p>&#13;
<p class="TX">Another option available to attackers is unloading the hypervisor. In the case of Type 2 hypervisors, you might be able to interact with the driver via an I/O control code, by changing the boot configuration, or by directly stopping the controlling service in order to cause the hypervisor to devirtualize the processors and unload, preventing its ability to monitor future actions. To date, there are no public reports of a real-world adversary employing these techniques.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
</body></html>