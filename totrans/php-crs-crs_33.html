<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="ch27" epub:type="chapter" role="doc-chapter">
<span aria-label="531" epub:type="pagebreak" id="pg_531" role="doc-pagebreak"/>
<hgroup>
<h2 class="CHAPTER" id="ch27">
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">27</span></span>
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">INTRODUCTION TO DATABASES</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="380" src="../images/opener.jpg" width="380"/>
</figure>
<p class="INTRO">Databases are one of the ways computer systems can persistently store data so that it can be remembered when code runs at a later time. We’ll explore how to use PHP to work with databases over the next several chapters, starting in this chapter with database fundamentals. We’ll go over basic database terminology, look at how databases are structured, and consider the motivation for and benefits of connecting a web application to a database.</p>
<p class="TX">We’ll also discuss how a database fits with our coverage so far about web application architecture. You’ll learn how to map the contents of a database onto an object-oriented structure of classes and objects, and you’ll see how a database forms the backbone of the model component of the MVC architecture described in earlier chapters.</p>
<span aria-label="532" epub:type="pagebreak" id="pg_532" role="doc-pagebreak"/>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>This book doesn’t aim to provide a comprehensive guide to relational database design, a complex field in its own right. Our focus will be on interacting with databases by using PHP. Some books for learning more about SQL and databases include</i> <span class="note">Practical SQL</span><i>, 2nd edition (2022), by Anthony DeBarros;</i> <span class="note">The Manga Guide to Databases</span> <i>(2009) by Mana Takahashi; and</i> <span class="note">MySQL Crash Course</span> <i>(2023) by Rick Silva, all from No Starch Press.</i></p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="toc-link_353"/><span class="SANS_Futura_Std_Bold_B_11">Relational Database Basics</span></h3>
<p class="TNI1">The majority of modern database systems are <i>relational</i>, meaning they’re composed of a set of interrelated tables. Each table represents a type of entity. For example, a <span class="SANS_TheSansMonoCd_W5Regular_11">customer</span> table might store information about the customers at an e-commerce site.</p>
<p class="TX">A table consists of columns and rows. Each column represents an attribute of the entity (for example, the <span class="SANS_TheSansMonoCd_W5Regular_11">customer</span> table might have columns for a customer’s name, address, phone number, and so on). Each row represents a single instance of the entity (for example, an individual customer). Each row is also called a <i>record</i>.</p>
<p class="TX">The relationships between database tables are established through keys; each <i>key</i> is a unique identifier associated with one record in a table. Referencing one table’s keys from within another table creates a link between the two tables, while also avoiding duplication of data. Continuing our e-commerce example, each customer in our <span class="SANS_TheSansMonoCd_W5Regular_11">customer</span> table could be given a <i>primary key</i> in the form of a unique customer ID number. Meanwhile, we might also have an <span class="SANS_TheSansMonoCd_W5Regular_11">invoice</span> table for recording transactions, with a unique ID number for each invoice. Every invoice should be related to a single customer (the person who initiated the transaction), while each customer may be associated with multiple invoices, since a person can initiate multiple transactions.</p>
<p class="TX">We would establish this relationship by storing the customer ID associated with each invoice as a column in the <span class="SANS_TheSansMonoCd_W5Regular_11">invoice</span> table, unambiguously associating each invoice with one—and only one—customer. In the context of the <span class="SANS_TheSansMonoCd_W5Regular_11">invoice</span> table, the customer ID is known as a <i>foreign key</i>, since it connects to a field in a different table. Thanks to the foreign key, the <span class="SANS_TheSansMonoCd_W5Regular_11">invoice</span> table doesn’t need to duplicate the name, address, and other information about the customer; we can simply look up those details in the <span class="SANS_TheSansMonoCd_W5Regular_11">customer</span> table based on the customer ID assigned to a given invoice. This is the power of the relational database.</p>
<p class="TX">Assigning a unique key to each row also helps maintain the correctness, or <i>integrity</i>, of the database. When database changes are being attempted, these keys act as links between data items in different tables. The system can ensure there’s an associated data item corresponding to a key referenced by another item in a different table. Rules can be established in the database to prevent new data from being created if it attempts to link to a nonexistent data item. For example, this might save a customer from being charged for a nonexistent invoice, or save an invoice from being assigned to a nonexistent customer. Other rules can be related to deletions of data, <span aria-label="533" epub:type="pagebreak" id="pg_533" role="doc-pagebreak"/>creating a warning or exception if we try to delete an item that other items are linked to.</p>
<p class="TX">Overall, the structure of a database’s tables, the relationships between the tables, and the rules governing data integrity are referred to as the <i>relational schema</i> for that database. Complex web applications often require several relational schemas that operate side by side. For example, one schema might be for the financial records of an organization, another for human resource details, and another for stock items and customer orders.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="H2" id="sec2"><span id="toc-link_354"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Database Management Systems</span></h4>
<p class="TNI1">The software that creates, modifies, retrieves from, and stores a database is called a <i>database management system (DBMS)</i>. For a relational database, we sometimes refer more specifically to a <i>relational database management system (RDBMS)</i>. For the purposes of this book, we’ll focus on two (R)DBMSs: MySQL and SQLite. These are two of the most popular free and open source systems in use today.</p>
<p class="TX">Some DBMSs run as server applications requiring usernames and passwords. They may run on the same computer system as the web application that uses them, or they may run on a completely independent internet server. MySQL is an example of a server-based DBMS. Other DBMSs, such as SQLite, are file-based, meaning the data is stored in files on the same computer as the web application. Server-based DBMSs like MySQL can work with multiple database schemas, whereas SQLite and most other file-based DBMSs store a single database schema in each file. One SQLite file might hold the financial records database, for example, another file could hold the human resource details database, and so on.</p>
<p class="TX">For a computer language like PHP to communicate with a particular DBMS, you need a <i>database driver</i>. This piece of software allows a program to communicate with a DBMS through its own standard protocol. For example, PHP has a driver for MySQL, a driver for SQLite, and other drivers for other DBMSs. The MySQL and SQLite PHP drivers may already be enabled on your system. If not, you’ll get driver errors when you try to run the code in the following chapters, and you may need to tweak the settings in your <i>php.ini</i> configuration file. See <span class="Xref"><a href="appendix-b.xhtml">Appendix B</a></span> for instructions on setting up one or both of these database systems locally, or <span class="Xref"><a href="appendix-c.xhtml">Appendix C</a></span> if you’re working in Replit.</p>
<p class="TX">When your PHP program needs to work with a DBMS, it uses a database <i>connection</i> at runtime. This connection is an active communication link between a computer program and a DBMS. To create a connection with a server-based database system, you must provide the host and port details, and usually the appropriate username and password authentication details as well. In some cases, a connection can be made directly to work with a particular database schema (for example, the human resource details schema); in other cases, a general connection is made to the DBMS, and either a new schema is created or the existing schema to be used is selected after the connection has been created. Once a connection has been established to work with a specific schema, the desired actions can be executed, <span aria-label="534" epub:type="pagebreak" id="pg_534" role="doc-pagebreak"/>which might include creating tables and relationships, inserting or deleting data, or retrieving data from the tables of the schema.</p>
<p class="TX">One key advantage of databases over other persistent storage methods such as files is that many DBMSs are designed to safely be used by multiple people simultaneously. Incorporating a database into a web application thus allows many people to interact with the application at the same time, while still ensuring the security and integrity of the system data. This is one area where server-based DBMSs like MySQL shine over file-based DBMSs like SQLite. While SQLite allows multiple simultaneous users to work on its file-based database, it locks the entire database file when a user is making changes. This is fine for local machine testing and development, but it would result in unacceptable delays for a fully deployed, real-world web application with heavy traffic. Systems such as MySQL can handle large numbers of concurrent connections, locking only single tables or even single database rows to minimize any interference with other users.</p>
<p class="TX">Server-based DBMSs also have the potential to be run as multiple instances, allowing multiple versions of both the web application and its database to help a system handle massive numbers of simultaneous users. Instances can be added and removed as needed to cope with a varying load of traffic over time. This technique is known as <i>load balancing</i>, and many cloud services implement it automatically.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="H2" id="sec3"><span id="toc-link_355"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Structured Query Language</span></h4>
<p class="TNI1">The majority of modern RDBMSs are manipulated using Structured Query Language (SQL). SQL is designed to accomplish three key aspects of working with relational databases:</p>
<ul class="ul">
<li class="ListBullet">Defining the structure of the related tables</li>
<li class="ListBullet">Manipulating the stored data (creating, updating, or deleting data)</li>
<li class="ListBullet">Querying the data (searching the database, given criteria to match against)</li>
</ul>
<p class="TX">Listing 27-1 illustrates SQL statements for each of these kinds of actions.</p>
<span id="lis27-1"/>
<pre><code>CREATE TABLE IF NOT EXISTS product (&#13;
    id integer PRIMARY KEY AUTO_INCREMENT,&#13;
    description text,&#13;
    price float&#13;
)&#13;
&#13;
DELETE FROM product WHERE price &lt; 0&#13;
&#13;
SELECT * FROM product WHERE price &gt; 99</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 27-1: Examples of SQL definition, manipulation, and querying statements</span></p>
<p class="TX">The first SQL statement creates a <span class="SANS_TheSansMonoCd_W5Regular_11">product</span> table and defines its structure. Each entry in this table will store the <span class="SANS_TheSansMonoCd_W5Regular_11">id</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">description</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> of a product. <span aria-label="535" epub:type="pagebreak" id="pg_535" role="doc-pagebreak"/>Each of these columns is given a data type (such as <span class="SANS_TheSansMonoCd_W5Regular_11">float</span> for the <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> column), and the <span class="SANS_TheSansMonoCd_W5Regular_11">id</span> column is designated as the table’s primary key, meaning each table entry should have a unique <span class="SANS_TheSansMonoCd_W5Regular_11">id</span> value.</p>
<p class="TX">The second SQL statement demonstrates how to manipulate the data stored in the database; the statement deletes all entries from the <span class="SANS_TheSansMonoCd_W5Regular_11">product</span> table that have a negative price. Finally, the third SQL statement is an example of a database query; it uses <span class="SANS_TheSansMonoCd_W5Regular_11">SELECT</span> to request all the entries in the <span class="SANS_TheSansMonoCd_W5Regular_11">products</span> table that have a price greater than <span class="SANS_TheSansMonoCd_W5Regular_11">99</span>.</p>
<p class="TX">Although SQL isn’t case-sensitive, it’s common practice to write SQL keywords like <span class="SANS_TheSansMonoCd_W5Regular_11">SELECT</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">FROM</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">WHERE</span> in all caps, and to use lowercase letters for table and column names as well as for strings forming a condition in a statement. Following this convention helps make SQL statements more readable.</p>
</section>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H1" id="sec4"><span id="toc-link_356"/><span class="SANS_Futura_Std_Bold_B_11">Databases and Web Application Architecture</span></h3>
<p class="TNI1">Databases naturally fit into the architecture of object-oriented web applications. Classes of objects can be written to closely map to the data items stored in database tables, and databases and their classes are the usual choice for the model (M) component in the MVC web application pattern.</p>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="H2" id="sec5"><span id="toc-link_357"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Object-Oriented Programming</span></h4>
<p class="TNI1">The class structure of OOP easily maps to relational database tables. A common and straightforward way to structure a web application working with a database is to design a class that corresponds to each table in the database. These <i>entity classes</i> have properties mirroring the table’s columns, and an instance of the class would correspond to a record (row) of the table.</p>
<p class="TX">If we need to write data to a database table, we would first create an object of the appropriate class containing the new data, then use our database connection to send the object’s data to the database table. We can even send data back to that object; for example, if the database needs to choose a new unique key for the new record, this value can be sent back to the web application and stored in the corresponding object for future reference. Conversely, if we need to read a whole record out of a database table, we would read the retrieved data into a new object of the appropriate class, at which point the rest of the application can utilize the database data by accessing that object.</p>
<p class="TX">Consider a web application (and its database) implementing products of various categories. We may have categories with names such as <span class="SANS_TheSansMonoCd_W5Regular_11">food</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">hardware</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">furniture</span>, and each product must be related to one of these categories. <a href="#fig27-1">Figure 27-1</a> shows the database’s relational schema. This kind of diagram is called an <i>entity-relationship (ER) model</i>.</p>
<span aria-label="536" epub:type="pagebreak" id="pg_536" role="doc-pagebreak"/>
<figure class="IMG"><a id="fig27-1"/><img alt="" class="img100" height="415" src="../images/figure27-1.jpg" width="1262"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 27-1: An ER diagram showing related</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Product</span> <span class="SANS_Futura_Std_Book_Oblique_11">and</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Category</span> <span class="SANS_Futura_Std_Book_Oblique_11">entities</span></p></figcaption>
</figure>
<p class="TX">Our database will have a <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> table containing an entry for each product as well as a <span class="SANS_TheSansMonoCd_W5Regular_11">Category</span> table with the possible categories the products can fall into. The line connecting the tables illustrates how entries from these tables can relate. The 1 at the <span class="SANS_TheSansMonoCd_W5Regular_11">Category</span> end of the connecting line expresses the relationship “each product is associated with precisely one category.” The crow’s foot link and asterisk (*) at the <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> end expresses the relationship “each category is associated with zero, one, or more products.”</p>
<p class="TX">Each record in the <span class="SANS_TheSansMonoCd_W5Regular_11">Category</span> table will have a unique integer <span class="SANS_TheSansMonoCd_W5Regular_11">id</span> property (a primary key) and a text description. <a href="#tab27-1">Table 27-1</a> shows sample entries in the table.</p>
<p class="TT"><a id="tab27-1"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 27-1:</span></span> <span class="SANS_Futura_Std_Book_11">Example Rows for the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">Category</span> <span class="SANS_Futura_Std_Book_11">Table</span></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_TheSansMonoCd_W7Bold_11">id</span> <span class="SANS_Futura_Std_Heavy_11">(primary key)</span></p></th>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_TheSansMonoCd_W7Bold_11">name</span></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">1</span></p></td>
<td class="TBF"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">"food"</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">2</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">"hardware"</span></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">3</span></p></td>
<td class="TBL"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">"furniture"</span></p></td>
</tr>
</tbody>
</table>
<p class="TX">Every record in the <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> table will similarly have a unique integer <span class="SANS_TheSansMonoCd_W5Regular_11">id</span> property as a primary key, along with a text <span class="SANS_TheSansMonoCd_W5Regular_11">description</span> and a float <span class="SANS_TheSansMonoCd_W5Regular_11">price</span>. Each product will also be related to exactly one category via the <span class="SANS_TheSansMonoCd_W5Regular_11">category_id</span> column, which will store a reference to the key for one of the records in the <span class="SANS_TheSansMonoCd_W5Regular_11">Category</span> table. Again, this is known as a <i>foreign key</i>. <a href="#tab27-2">Table 27-2</a> shows example rows for the <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> table.</p>
<p class="TT"><a id="tab27-2"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 27-2:</span></span> <span class="SANS_Futura_Std_Book_11">Example Rows for the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> <span class="SANS_Futura_Std_Book_11">Table</span></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_TheSansMonoCd_W7Bold_11">id</span> <span class="SANS_Futura_Std_Heavy_11">(unique key)</span></p></th>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_TheSansMonoCd_W7Bold_11">description</span></p></th>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_TheSansMonoCd_W7Bold_11">price</span></p></th>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_TheSansMonoCd_W7Bold_11">category_id</span></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">1</span></p></td>
<td class="TBF"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">"peanut bar"</span></p></td>
<td class="TBF"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">1.00</span></p></td>
<td class="TBF"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">1</span> <span class="SANS_Futura_Std_Book_11">(food)</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">2</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">"hammer"</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">9.99</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">2</span> <span class="SANS_Futura_Std_Book_11">(hardware)</span></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">3</span></p></td>
<td class="TBL"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">"ladder"</span></p></td>
<td class="TBL"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">59.99</span></p></td>
<td class="TBL"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">2</span> <span class="SANS_Futura_Std_Book_11">(hardware)</span></p></td>
</tr>
</tbody>
</table>
<p class="TX">We can easily map our database tables to object-oriented classes. <a href="#fig27-2">Figure 27-2</a> shows the corresponding class diagram for <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Category</span>. Notice that this UML diagram is essentially the same as the ER model from <a href="#fig27-1">Figure 27-1</a>.</p>
<span aria-label="537" epub:type="pagebreak" id="pg_537" role="doc-pagebreak"/>
<figure class="IMG"><a id="fig27-2"/><img alt="" class="img100" height="487" src="../images/figure27-2.jpg" width="1215"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 27-2: A class diagram of the related</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Product</span> <span class="SANS_Futura_Std_Book_Oblique_11">and</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Category</span> <span class="SANS_Futura_Std_Book_Oblique_11">classes</span></p></figcaption>
</figure>
<p class="TX">Each class has properties for all the columns of its corresponding database table; for example, the <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> class has <span class="SANS_TheSansMonoCd_W5Regular_11">id</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">description</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">price</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">category</span> properties. Each <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> object will be related to exactly one <span class="SANS_TheSansMonoCd_W5Regular_11">Category</span> object via its <span class="SANS_TheSansMonoCd_W5Regular_11">category</span> property, which will store a reference to a <span class="SANS_TheSansMonoCd_W5Regular_11">Category</span> object. Notice that this is the main difference between our class structure and our database structure. In the <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> database table, the <span class="SANS_TheSansMonoCd_W5Regular_11">category_id</span> column simply stores the integer ID of the related category, whereas with our classes we can store a reference to a complete <span class="SANS_TheSansMonoCd_W5Regular_11">Category</span> object.</p>
<p class="TX"><a href="#fig27-3">Figure 27-3</a> shows the objects that will be created when we read the sample database rows from <a href="#tab27-1">Tables 27-1</a> and <a href="#tab27-2">27-2</a> into our web application.</p>
<figure class="IMG"><a id="fig27-3"/><img alt="" class="img70" height="892" src="../images/figure27-3.jpg" width="936"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 27-3: Connecting</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Product</span> <span class="SANS_Futura_Std_Book_Oblique_11">objects to</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Category</span> <span class="SANS_Futura_Std_Book_Oblique_11">objects</span></p></figcaption>
</figure>
<p class="TX">We end up with three <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> objects, linked to their corresponding <span class="SANS_TheSansMonoCd_W5Regular_11">Category</span> objects. Notice that each <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> object is associated with only one <span class="SANS_TheSansMonoCd_W5Regular_11">Category</span> object. In contrast, a <span class="SANS_TheSansMonoCd_W5Regular_11">Category</span> object can be related to zero, <span aria-label="538" epub:type="pagebreak" id="pg_538" role="doc-pagebreak"/>one, or many <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> objects, since at a given point we may have no products for some categories, perhaps just one product, or more.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H2" id="sec6"><span id="toc-link_358"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">The Model-View-Controller Pattern</span></h4>
<p class="TNI1">In previous chapters, we’ve discussed the MVC software architecture, which assigns the various tasks required for operating a web application to different parts of the system. We’ve focused primarily on how a templating library like Twig provides the view component of MVC, preparing content to be displayed to the user, and on how a front controller and other specialized controller classes provide the controller component, making decisions about how to respond to each user request.</p>
<p class="TX">I’ve said little so far about the model part of this architecture, the actual data that underlies the web application. This is where a database comes in. It stores the data in an organized format and serves it up or modifies it when prompted by the controller classes. The classes corresponding to the database tables are part of the model component of the application as well. <a href="#fig27-4">Figure 27-4</a> illustrates the database’s place in the MVC web application architecture.</p>
<figure class="IMG"><a id="fig27-4"/><img alt="" class="img100" height="687" src="../images/figure27-4.jpg" width="1634"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 27-4: The MVC architecture, highlighting the model component</span></p></figcaption>
</figure>
<p class="TX">Notice that the action controller classes communicate with (read from and modify) the <i>model classes</i>. As you’ll learn in the following chapters, these are the object-oriented classes that communicate with the database. All database interactions are kept completely separate from the controller and view components of the application. This compartmentalization means that we could change the underlying database (from a file-based DBMS to a server-based DBMS, for example) without having to make any changes to the front controller, the action controller classes, or the templates.</p>
</section>
</section>
<section aria-labelledby="sec7" epub:type="division">
<span aria-label="539" epub:type="pagebreak" id="pg_539" role="doc-pagebreak"/>
<h3 class="H1" id="sec7"><span id="toc-link_359"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>
<p class="TNI1">In this chapter, we reviewed the concept of databases, especially SQL-based relational databases, and considered some of the advantages of adding databases to web applications. We also explored how databases fit into web application architecture, including how databases are the heart of the MVC pattern’s model component. We observed the close mapping among the tables, columns, and rows of a relational database and the classes, properties, and instances used in OOP. With this introduction, you’re now ready for the remaining chapters in the book, where you’ll learn to use PHP to connect to, create, modify, and retrieve data from MySQL and SQLite relational databases.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="H1" id="sec8"><span id="toc-link_360"/><span class="SANS_Futura_Std_Bold_B_11">Exercises</span></h3>
<p class="ListNumber">1.   Read up on some of the history of databases in the phoenixNAP article “What Is a Database?” by Milica Dancuk (<i><a href="https://phoenixnap.com/kb/what-is-a-database">https://phoenixnap.com/kb/what-is-a-database</a></i>).</p>
<p class="ListNumber">2.   DB Fiddle (<i><a href="https://www.db-fiddle.com">https://www.db-fiddle.com</a></i>) is a great online resource for practicing SQL statements and designing a database. You can create and populate tables, query them, and view the results. Try using DB Fiddle to implement the <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Category</span> database tables discussed in this chapter. Insert the three rows of sample data for each database table (see <a href="#tab27-1">Tables 27-1</a> and <a href="#tab27-2">27-2</a>), then run queries to select the data from each table.</p>
</section>
</section>
</div></body></html>